(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./source/js/app.coffee":[function(require,module,exports){
require("./module/index");

require("./../../vendor/ractive-events-tap/ractive-events-tap.js");

require('./../../vendor/domready/ready.js')(function() {
  var View;
  if ("development" === "development") {
    require("./app-debug")();
  }
  View = require("./view/main-view");
  return window._view = new View();
});



},{"./../../vendor/domready/ready.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/domready/ready.js","./../../vendor/ractive-events-tap/ractive-events-tap.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-events-tap/ractive-events-tap.js","./app-debug":"/Users/luke.hedger/dev/Experiments/040715/source/js/app-debug.coffee","./module/index":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/index.coffee","./view/main-view":"/Users/luke.hedger/dev/Experiments/040715/source/js/view/main-view.coffee"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/index.js":[function(require,module,exports){
module.exports = require('./vendor/dat.gui')
module.exports.color = require('./vendor/dat.color')
},{"./vendor/dat.color":"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.color.js","./vendor/dat.gui":"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.gui.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.color.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);
},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.gui.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/firebase/lib/firebase-web.js":[function(require,module,exports){
/*! @license Firebase v2.1.2 - License: https://www.firebase.com/terms/terms-of-service.html */ (function() {var h,aa=this;function m(a){return void 0!==a}function ba(){}function ca(a){a.Nb=function(){return a.kf?a.kf:a.kf=new a}}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return"array"==da(a)}function fa(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"string"==typeof a}function ga(a){return"number"==typeof a}function ha(a){return"function"==da(a)}function ia(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ja(a,b,c){return a.call.apply(a.bind,arguments)}
function ka(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){q=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ja:ka;return q.apply(null,arguments)}var la=Date.now||function(){return+new Date};
function ma(a,b){function c(){}c.prototype=b.prototype;a.Jg=b.prototype;a.prototype=new c;a.Fg=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};function na(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function oa(){this.Hd=void 0}
function pa(a,b,c){switch(typeof b){case "string":qa(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(ea(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],pa(a,a.Hd?a.Hd.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),qa(f,c),
c.push(":"),pa(a,a.Hd?a.Hd.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var ra={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},sa=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function qa(a,b){b.push('"',a.replace(sa,function(a){if(a in ra)return ra[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return ra[a]=e+b.toString(16)}),'"')};function ta(a){return"undefined"!==typeof JSON&&m(JSON.parse)?JSON.parse(a):na(a)}function r(a){if("undefined"!==typeof JSON&&m(JSON.stringify))a=JSON.stringify(a);else{var b=[];pa(new oa,a,b);a=b.join("")}return a};function s(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function t(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function ua(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])}function va(a){var b={};ua(a,function(a,d){b[a]=d});return b};function wa(a){this.uc=a;this.Ed="firebase:"}h=wa.prototype;h.set=function(a,b){null==b?this.uc.removeItem(this.Ed+a):this.uc.setItem(this.Ed+a,r(b))};h.get=function(a){a=this.uc.getItem(this.Ed+a);return null==a?null:ta(a)};h.remove=function(a){this.uc.removeItem(this.Ed+a)};h.lf=!1;h.toString=function(){return this.uc.toString()};function xa(){this.oc={}}xa.prototype.set=function(a,b){null==b?delete this.oc[a]:this.oc[a]=b};xa.prototype.get=function(a){return s(this.oc,a)?this.oc[a]:null};xa.prototype.remove=function(a){delete this.oc[a]};xa.prototype.lf=!0;function ya(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new wa(b)}}catch(c){}return new xa}var za=ya("localStorage"),v=ya("sessionStorage");function Aa(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.Ab=b;this.tb=c;this.Dg=d;this.Dd=e||"";this.Ma=za.get("host:"+a)||this.host}function Ba(a,b){b!==a.Ma&&(a.Ma=b,"s-"===a.Ma.substr(0,2)&&za.set("host:"+a.host,a.Ma))}Aa.prototype.toString=function(){var a=(this.Ab?"https://":"http://")+this.host;this.Dd&&(a+="<"+this.Dd+">");return a};function Ca(){this.Sa=-1};function Da(){this.Sa=-1;this.Sa=64;this.R=[];this.be=[];this.Ef=[];this.Ad=[];this.Ad[0]=128;for(var a=1;a<this.Sa;++a)this.Ad[a]=0;this.Td=this.Sb=0;this.reset()}ma(Da,Ca);Da.prototype.reset=function(){this.R[0]=1732584193;this.R[1]=4023233417;this.R[2]=2562383102;this.R[3]=271733878;this.R[4]=3285377520;this.Td=this.Sb=0};
function Ea(a,b,c){c||(c=0);var d=a.Ef;if(p(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.R[0];c=a.R[1];for(var g=a.R[2],k=a.R[3],l=a.R[4],n,e=0;80>e;e++)40>e?20>e?(f=k^c&(g^k),n=1518500249):(f=c^g^k,n=1859775393):60>e?(f=c&g|k&(c|g),n=2400959708):(f=c^g^k,n=3395469782),f=(b<<
5|b>>>27)+f+l+n+d[e]&4294967295,l=k,k=g,g=(c<<30|c>>>2)&4294967295,c=b,b=f;a.R[0]=a.R[0]+b&4294967295;a.R[1]=a.R[1]+c&4294967295;a.R[2]=a.R[2]+g&4294967295;a.R[3]=a.R[3]+k&4294967295;a.R[4]=a.R[4]+l&4294967295}
Da.prototype.update=function(a,b){m(b)||(b=a.length);for(var c=b-this.Sa,d=0,e=this.be,f=this.Sb;d<b;){if(0==f)for(;d<=c;)Ea(this,a,d),d+=this.Sa;if(p(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Sa){Ea(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Sa){Ea(this,e);f=0;break}}this.Sb=f;this.Td+=b};function Fa(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^la()).toString(36)};var w=Array.prototype,Ga=w.indexOf?function(a,b,c){return w.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return p(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Ha=w.forEach?function(a,b,c){w.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Ia=w.filter?function(a,b,c){return w.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=p(a)?
a.split(""):a,k=0;k<d;k++)if(k in g){var l=g[k];b.call(c,l,k,a)&&(e[f++]=l)}return e},Ja=w.map?function(a,b,c){return w.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=p(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Ka=w.reduce?function(a,b,c,d){d&&(b=q(b,d));return w.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;Ha(a,function(c,g){e=b.call(d,e,c,g,a)});return e},La=w.every?function(a,b,c){return w.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=
p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Ma(a,b){var c=Na(a,b,void 0);return 0>c?null:p(a)?a.charAt(c):a[c]}function Na(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Oa(a,b){var c=Ga(a,b);0<=c&&w.splice.call(a,c,1)}function Pa(a,b,c){return 2>=arguments.length?w.slice.call(a,b):w.slice.call(a,b,c)}function Qa(a,b){a.sort(b||Ra)}function Ra(a,b){return a>b?1:a<b?-1:0};var Sa;a:{var Ta=aa.navigator;if(Ta){var Ua=Ta.userAgent;if(Ua){Sa=Ua;break a}}Sa=""}function Va(a){return-1!=Sa.indexOf(a)};var Wa=Va("Opera")||Va("OPR"),Xa=Va("Trident")||Va("MSIE"),Ya=Va("Gecko")&&-1==Sa.toLowerCase().indexOf("webkit")&&!(Va("Trident")||Va("MSIE")),Za=-1!=Sa.toLowerCase().indexOf("webkit");(function(){var a="",b;if(Wa&&aa.opera)return a=aa.opera.version,ha(a)?a():a;Ya?b=/rv\:([^\);]+)(\)|;)/:Xa?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:Za&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(Sa))?a[1]:"");return Xa&&(b=(b=aa.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var $a=null,ab=null,bb=null;function cb(a,b){if(!fa(a))throw Error("encodeByteArray takes an array as a parameter");db();for(var c=b?ab:$a,d=[],e=0;e<a.length;e+=3){var f=a[e],g=e+1<a.length,k=g?a[e+1]:0,l=e+2<a.length,n=l?a[e+2]:0,u=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|n>>6,n=n&63;l||(n=64,g||(k=64));d.push(c[u],c[f],c[k],c[n])}return d.join("")}
function db(){if(!$a){$a={};ab={};bb={};for(var a=0;65>a;a++)$a[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),ab[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),bb[ab[a]]=a}};var eb=function(){var a=1;return function(){return a++}}();function y(a,b){if(!a)throw fb(b);}function fb(a){return Error("Firebase INTERNAL ASSERT FAILED:"+a)}
function gb(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{db();for(var c=bb,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],g=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var l=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==g||null==k||null==l)throw Error();d.push(f<<2|g>>4);64!=k&&(d.push(g<<4&240|k>>2),64!=l&&d.push(k<<6&192|l))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Pa(d,c,
c+8192));b=a}}return b}catch(n){hb("base64Decode failed: ",n)}return null}function ib(a){var b=jb(a);a=new Da;a.update(b);var b=[],c=8*a.Td;56>a.Sb?a.update(a.Ad,56-a.Sb):a.update(a.Ad,a.Sa-(a.Sb-56));for(var d=a.Sa-1;56<=d;d--)a.be[d]=c&255,c/=256;Ea(a,a.be);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.R[d]>>e&255,++c;return cb(b)}
function kb(a){for(var b="",c=0;c<arguments.length;c++)b=fa(arguments[c])?b+kb.apply(null,arguments[c]):"object"===typeof arguments[c]?b+r(arguments[c]):b+arguments[c],b+=" ";return b}var lb=null,mb=!0;function hb(a){!0===mb&&(mb=!1,null===lb&&!0===v.get("logging_enabled")&&nb(!0));if(lb){var b=kb.apply(null,arguments);lb(b)}}function ob(a){return function(){hb(a,arguments)}}
function pb(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+kb.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function qb(a){var b=kb.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function z(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+kb.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function rb(a){var b="",c="",d="",e="",f=!0,g="https",k=443;if(p(a)){var l=a.indexOf("//");0<=l&&(g=a.substring(0,l-1),a=a.substring(l+2));l=a.indexOf("/");-1===l&&(l=a.length);b=a.substring(0,l);e="";a=a.substring(l).split("/");for(l=0;l<a.length;l++)if(0<a[l].length){var n=a[l];try{n=decodeURIComponent(n.replace(/\+/g," "))}catch(u){}e+="/"+n}a=b.split(".");3===a.length?(c=a[1],d=a[0].toLowerCase()):2===a.length&&(c=a[0]);l=b.indexOf(":");0<=l&&(f="https"===g||"wss"===g,k=b.substring(l+1),isFinite(k)&&
(k=String(k)),k=p(k)?/^\s*-?0x/i.test(k)?parseInt(k,16):parseInt(k,10):NaN)}return{host:b,port:k,domain:c,Ag:d,Ab:f,scheme:g,Pc:e}}function sb(a){return ga(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function tb(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function ub(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=vb(a),d=vb(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function wb(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+r(b));}
function xb(a){if("object"!==typeof a||null===a)return r(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=r(b[d]),c+=":",c+=xb(a[b[d]]);return c+"}"}function yb(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function zb(a,b){if(ea(a))for(var c=0;c<a.length;++c)b(c,a[c]);else A(a,b)}
function Ab(a){y(!sb(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;a-=1)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;a-=1)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var Bb=/^-?\d{1,10}$/;function vb(a){return Bb.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function Cb(a){try{a()}catch(b){setTimeout(function(){z("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function B(a,b){if(ha(a)){var c=Array.prototype.slice.call(arguments,1).slice();Cb(function(){a.apply(null,c)})}};function Db(a,b,c,d){this.le=b;this.Nd=c;this.Fd=d;this.jd=a}Db.prototype.Qb=function(){var a=this.Nd.cc();return"value"===this.jd?a.path:a.parent().path};Db.prototype.pe=function(){return this.jd};Db.prototype.Lb=function(){return this.le.Lb(this)};Db.prototype.toString=function(){return this.Qb().toString()+":"+this.jd+":"+r(this.Nd.bf())};function Eb(a,b,c){this.le=a;this.error=b;this.path=c}Eb.prototype.Qb=function(){return this.path};Eb.prototype.pe=function(){return"cancel"};
Eb.prototype.Lb=function(){return this.le.Lb(this)};Eb.prototype.toString=function(){return this.path.toString()+":cancel"};function C(a,b,c,d){this.type=a;this.Ha=b;this.Ua=c;this.De=d;this.Fd=void 0}function Fb(a){return new C(Gb,a)}var Gb="value";function Hb(a,b,c){this.Hb=a;this.kb=b;this.mb=c||null}h=Hb.prototype;h.wf=function(a){return"value"===a};h.createEvent=function(a,b){var c=b.n.g;return new Db("value",this,new D(a.Ha,b.cc(),c))};h.Lb=function(a){var b=this.mb;if("cancel"===a.pe()){y(this.kb,"Raising a cancel event on a listener with no cancel callback");var c=this.kb;return function(){c.call(b,a.error)}}var d=this.Hb;return function(){d.call(b,a.Nd)}};h.Ye=function(a,b){return this.kb?new Eb(this,a,b):null};
h.matches=function(a){return a instanceof Hb?a.Hb&&this.Hb?a.Hb===this.Hb&&a.mb===this.mb:!0:!1};h.hf=function(){return null!==this.Hb};function Ib(a,b,c){this.da=a;this.kb=b;this.mb=c}h=Ib.prototype;h.wf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.da};h.Ye=function(a,b){return this.kb?new Eb(this,a,b):null};
h.createEvent=function(a,b){y(null!=a.Ua,"Child events should have a childName.");var c=b.cc().o(a.Ua);return new Db(a.type,this,new D(a.Ha,c,b.n.g),a.Fd)};h.Lb=function(a){var b=this.mb;if("cancel"===a.pe()){y(this.kb,"Raising a cancel event on a listener with no cancel callback");var c=this.kb;return function(){c.call(b,a.error)}}var d=this.da[a.jd];return function(){d.call(b,a.Nd,a.Fd)}};
h.matches=function(a){if(a instanceof Ib){if(!this.da||!a.da)return!0;if(this.mb===a.mb){var b=Jb(a.da);if(b===Jb(this.da)){if(1===b){var b=Kb(a.da),c=Kb(this.da);return c===b&&(!a.da[b]||!this.da[c]||a.da[b]===this.da[c])}return Lb(this.da,function(b,c){return a.da[c]===b})}}}return!1};h.hf=function(){return null!==this.da};function jb(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,y(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b};function F(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function G(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function H(a,b,c,d){if((!d||m(c))&&!ha(c))throw Error(G(a,b,d)+"must be a valid function.");}function Mb(a,b,c){if(m(c)&&(!ia(c)||null===c))throw Error(G(a,b,!0)+"must be a valid context object.");};var Nb=/[\[\].#$\/\u0000-\u001F\u007F]/,Ob=/[\[\].#$\u0000-\u001F\u007F]/;function Pb(a){return p(a)&&0!==a.length&&!Nb.test(a)}function Qb(a){return null===a||p(a)||ga(a)&&!sb(a)||ia(a)&&s(a,".sv")}function Rb(a,b,c){c&&!m(b)||Sb(G(a,1,c),b)}
function Sb(a,b,c,d){c||(c=0);var e=d||[];if(!m(b))throw Error(a+"contains undefined"+Tb(e));if(ha(b))throw Error(a+"contains a function"+Tb(e)+" with contents: "+b.toString());if(sb(b))throw Error(a+"contains "+b.toString()+Tb(e));if(1E3<c)throw new TypeError(a+"contains a cyclic object value ("+e.slice(0,100).join(".")+"...)");if(p(b)&&b.length>10485760/3&&10485760<jb(b).length)throw Error(a+"contains a string greater than 10485760 utf8 bytes"+Tb(e)+" ('"+b.substring(0,50)+"...')");if(ia(b)){var f=
!1,g=!1;ua(b,function(b,d){if(".value"===b)f=!0;else if(".priority"!==b&&".sv"!==b&&(g=!0,!Pb(b)))throw Error(a+" contains an invalid key ("+b+")"+Tb(e)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');e.push(b);Sb(a,d,c+1,e);e.pop()});if(f&&g)throw Error(a+' contains ".value" child'+Tb(e)+" in addition to actual children.");}}function Tb(a){return 0==a.length?"":" in property '"+a.join(".")+"'"}
function Ub(a,b){if(!ia(b)||ea(b))throw Error(G(a,1,!1)+" must be an Object containing the children to replace.");if(s(b,".value"))throw Error(G(a,1,!1)+' must not contain ".value".  To overwrite with a leaf value, just use .set() instead.');Rb(a,b,!1)}
function Vb(a,b,c){if(sb(c))throw Error(G(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!Qb(c))throw Error(G(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function Wb(a,b,c){if(!c||m(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(G(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function Xb(a,b,c,d){if((!d||m(c))&&!Pb(c))throw Error(G(a,b,d)+'was an invalid key: "'+c+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function Yb(a,b){if(!p(b)||0===b.length||Ob.test(b))throw Error(G(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function Zb(a,b){if(".info"===I(b))throw Error(a+" failed: Can't modify data under /.info/");}function $b(a,b){if(!p(b))throw Error(G(a,1,!1)+"must be a valid credential (a string).");}function ac(a,b,c){if(!p(c))throw Error(G(a,b,!1)+"must be a valid string.");}
function J(a,b,c,d){if(!d||m(c))if(!ia(c)||null===c)throw Error(G(a,b,d)+"must be a valid object.");}function K(a,b,c){if(!ia(b)||null===b||!s(b,c))throw Error(G(a,1,!1)+'must contain the key "'+c+'"');if(!p(t(b,c)))throw Error(G(a,1,!1)+'must contain the key "'+c+'" with type "string"');};function bc(a){this.g=a}h=bc.prototype;h.C=function(a,b,c,d,e){y(a.Bc(this.g),"A node must be indexed if only a child is updated");d=a.K(b);if(d.ea(c))return a;null!=e&&(c.e()?a.Da(b)?cc(e,new C("child_removed",d,b)):y(a.M(),"A child remove without an old child only makes sense on a leaf node"):d.e()?cc(e,new C("child_added",c,b)):cc(e,new C("child_changed",c,b,d)));return a.M()&&c.e()?a:a.P(b,c)};
h.oa=function(a,b,c){null!=c&&(a.M()||a.U(L,function(a,e){b.Da(a)||cc(c,new C("child_removed",e,a))}),b.M()||b.U(L,function(b,e){if(a.Da(b)){var f=a.K(b);f.ea(e)||cc(c,new C("child_changed",e,b,f))}else cc(c,new C("child_added",e,b))}));return b.Fb(this.g)};h.Z=function(a,b){return a.e()?M:a.Z(b)};h.ya=function(){return!1};h.Mb=function(){return this};function dc(a){this.re=new bc(a.g);this.g=a.g;var b;a.ia?(b=ec(a),b=a.g.Ae(fc(a),b)):b=a.g.Ce();this.Vc=b;a.qa?(b=gc(a),a=a.g.Ae(hc(a),b)):a=a.g.Be();this.wc=a}h=dc.prototype;h.matches=function(a){return 0>=this.g.compare(this.Vc,a)&&0>=this.g.compare(a,this.wc)};h.C=function(a,b,c,d,e){this.matches(new N(b,c))||(c=M);return this.re.C(a,b,c,d,e)};h.oa=function(a,b,c){b.M()&&(b=M);var d=b.Fb(this.g),d=d.Z(M),e=this;b.U(L,function(a,b){e.matches(new N(a,b))||(d=d.P(a,M))});return this.re.oa(a,d,c)};
h.Z=function(a){return a};h.ya=function(){return!0};h.Mb=function(){return this.re};function ic(a,b){return ub(a.name,b.name)}function jc(a,b){return ub(a,b)};function kc(){}var lc={};function mc(a){return q(a.compare,a)}kc.prototype.jf=function(a,b){return 0!==this.compare(new N("[MIN_NAME]",a),new N("[MIN_NAME]",b))};kc.prototype.Ce=function(){return nc};function oc(a){this.Ub=a}ma(oc,kc);h=oc.prototype;h.ue=function(a){return!a.K(this.Ub).e()};h.compare=function(a,b){var c=a.Y.K(this.Ub),d=b.Y.K(this.Ub),c=c.he(d);return 0===c?ub(a.name,b.name):c};h.Ae=function(a,b){var c=O(a),c=M.P(this.Ub,c);return new N(b,c)};
h.Be=function(){var a=M.P(this.Ub,pc);return new N("[MAX_NAME]",a)};h.toString=function(){return this.Ub};var L=new oc(".priority");function qc(){}ma(qc,kc);h=qc.prototype;h.compare=function(a,b){return ub(a.name,b.name)};h.ue=function(){throw fb("KeyIndex.isDefinedOn not expected to be called.");};h.jf=function(){return!1};h.Ce=function(){return nc};h.Be=function(){return new N("[MAX_NAME]",M)};h.Ae=function(a){y(p(a),"KeyIndex indexValue must always be a string.");return new N(a,M)};
h.toString=function(){return".key"};var rc=new qc;function sc(){}sc.prototype.ef=function(){return null};sc.prototype.oe=function(){return null};var tc=new sc;function uc(a,b,c){this.Bf=a;this.Ia=b;this.zd=c}uc.prototype.ef=function(a){var b=this.Ia.F;if(vc(b,a))return b.j().K(a);b=null!=this.zd?new wc(this.zd,!0,!1):this.Ia.u();return this.Bf.Ta(a,b)};uc.prototype.oe=function(a,b,c){var d=null!=this.zd?this.zd:xc(this.Ia);a=this.Bf.ce(d,b,1,c,a);return 0===a.length?null:a[0]};function yc(){this.Za={}}
function cc(a,b){var c=b.type,d=b.Ua;y("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");y(".priority"!==d,"Only non-priority child changes can be tracked.");var e=t(a.Za,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.Ha);else if("child_removed"==c&&"child_added"==f)delete a.Za[d];else if("child_removed"==c&&"child_changed"==f)a.Za[d]=new C("child_removed",e.De,d);else if("child_changed"==c&&
"child_added"==f)a.Za[d]=new C("child_added",b.Ha,d);else if("child_changed"==c&&"child_changed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.De);else throw fb("Illegal combination of changes: "+b+" occurred after "+e);}else a.Za[d]=b};function N(a,b){this.name=a;this.Y=b}function zc(a,b){return new N(a,b)};function Ac(a){this.ma=new dc(a);this.g=a.g;y(a.ka,"Only valid if limit has been set");this.sa=a.sa;this.zb=!(""===a.Eb?a.ia:"l"===a.Eb)}h=Ac.prototype;h.C=function(a,b,c,d,e){this.ma.matches(new N(b,c))||(c=M);return a.K(b).ea(c)?a:a.ub()<this.sa?this.ma.Mb().C(a,b,c,d,e):Bc(this,a,b,c,d,e)};
h.oa=function(a,b,c){var d;if(b.M()||b.e())d=M.Fb(this.g);else if(2*this.sa<b.ub()&&b.Bc(this.g)){d=M.Fb(this.g);b=this.zb?b.Rb(this.ma.wc,this.g):b.Pb(this.ma.Vc,this.g);for(var e=0;0<b.Na.length&&e<this.sa;){var f=P(b),g;if(g=this.zb?0>=this.g.compare(this.ma.Vc,f):0>=this.g.compare(f,this.ma.wc))d=d.P(f.name,f.Y),e++;else break}}else{d=b.Fb(this.g);d=d.Z(M);var k,l,n;if(this.zb){b=d.gf(this.g);k=this.ma.wc;l=this.ma.Vc;var u=mc(this.g);n=function(a,b){return u(b,a)}}else b=d.Ob(this.g),k=this.ma.Vc,
l=this.ma.wc,n=mc(this.g);for(var e=0,x=!1;0<b.Na.length;)f=P(b),!x&&0>=n(k,f)&&(x=!0),(g=x&&e<this.sa&&0>=n(f,l))?e++:d=d.P(f.name,M)}return this.ma.Mb().oa(a,d,c)};h.Z=function(a){return a};h.ya=function(){return!0};h.Mb=function(){return this.ma.Mb()};
function Bc(a,b,c,d,e,f){var g;if(a.zb){var k=mc(a.g);g=function(a,b){return k(b,a)}}else g=mc(a.g);y(b.ub()==a.sa,"");var l=new N(c,d),n=a.zb?Cc(b,a.g):Dc(b,a.g),u=a.ma.matches(l);if(b.Da(c)){var x=b.K(c),n=e.oe(a.g,n,a.zb);null!=n&&n.name==c&&(n=e.oe(a.g,n,a.zb));e=null==n?1:g(n,l);if(u&&!d.e()&&0<=e)return null!=f&&cc(f,new C("child_changed",d,c,x)),b.P(c,d);null!=f&&cc(f,new C("child_removed",x,c));b=b.P(c,M);return null!=n&&a.ma.matches(n)?(null!=f&&cc(f,new C("child_added",n.Y,n.name)),b.P(n.name,
n.Y)):b}return d.e()?b:u&&0<=g(n,l)?(null!=f&&(cc(f,new C("child_removed",n.Y,n.name)),cc(f,new C("child_added",d,c))),b.P(c,d).P(n.name,M)):b};function Ec(){this.vc=this.qa=this.kc=this.ia=this.ka=!1;this.sa=0;this.Eb="";this.Ac=null;this.Wb="";this.zc=null;this.Tb="";this.g=L}var Fc=new Ec;function fc(a){y(a.ia,"Only valid if start has been set");return a.Ac}function ec(a){y(a.ia,"Only valid if start has been set");return a.kc?a.Wb:"[MIN_NAME]"}function hc(a){y(a.qa,"Only valid if end has been set");return a.zc}function gc(a){y(a.qa,"Only valid if end has been set");return a.vc?a.Tb:"[MAX_NAME]"}
function Gc(a){var b=new Ec;b.ka=a.ka;b.sa=a.sa;b.ia=a.ia;b.Ac=a.Ac;b.kc=a.kc;b.Wb=a.Wb;b.qa=a.qa;b.zc=a.zc;b.vc=a.vc;b.Tb=a.Tb;b.g=a.g;return b}h=Ec.prototype;h.xe=function(a){var b=Gc(this);b.ka=!0;b.sa=a;b.Eb="";return b};h.ye=function(a){var b=Gc(this);b.ka=!0;b.sa=a;b.Eb="l";return b};h.ze=function(a){var b=Gc(this);b.ka=!0;b.sa=a;b.Eb="r";return b};h.Od=function(a,b){var c=Gc(this);c.ia=!0;m(a)||(a=null);c.Ac=a;null!=b?(c.kc=!0,c.Wb=b):(c.kc=!1,c.Wb="");return c};
h.hd=function(a,b){var c=Gc(this);c.qa=!0;m(a)||(a=null);c.zc=a;m(b)?(c.vc=!0,c.Tb=b):(c.Ig=!1,c.Tb="");return c};function Hc(a,b){var c=Gc(a);c.g=b;return c}function Ic(a){var b={};a.ia&&(b.sp=a.Ac,a.kc&&(b.sn=a.Wb));a.qa&&(b.ep=a.zc,a.vc&&(b.en=a.Tb));if(a.ka){b.l=a.sa;var c=a.Eb;""===c&&(c=a.ia?"l":"r");b.vf=c}a.g!==L&&(b.i=a.g.toString());return b}function Jc(a){return!(a.ia||a.qa||a.ka)}h.toString=function(){return r(Ic(this))};function Q(a,b,c,d){this.k=a;this.path=b;this.n=c;this.ac=d}
function Kc(a){var b=null,c=null;a.ia&&(b=fc(a));a.qa&&(c=hc(a));if(a.g===rc){if(a.ia){if("[MIN_NAME]"!=ec(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if(null!=b&&"string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.qa){if("[MAX_NAME]"!=gc(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if(null!=
c&&"string"!==typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===L){if(null!=b&&!Qb(b)||null!=c&&!Qb(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(y(a.g instanceof oc,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function Lc(a){if(a.ia&&a.qa&&a.ka&&(!a.ka||""===a.Eb))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function Mc(a,b){if(!0===a.ac)throw Error(b+": You can't combine multiple orderBy calls.");}Q.prototype.cc=function(){F("Query.ref",0,0,arguments.length);return new R(this.k,this.path)};Q.prototype.ref=Q.prototype.cc;
Q.prototype.vb=function(a,b,c,d){F("Query.on",2,4,arguments.length);Wb("Query.on",a,!1);H("Query.on",2,b,!1);var e=Nc("Query.on",c,d);if("value"===a)Oc(this.k,this,new Hb(b,e.cancel||null,e.Ka||null));else{var f={};f[a]=b;Oc(this.k,this,new Ib(f,e.cancel,e.Ka))}return b};Q.prototype.on=Q.prototype.vb;
Q.prototype.Zb=function(a,b,c){F("Query.off",0,3,arguments.length);Wb("Query.off",a,!0);H("Query.off",2,b,!0);Mb("Query.off",3,c);var d=null,e=null;"value"===a?d=new Hb(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new Ib(e,null,c||null));e=this.k;d=".info"===I(this.path)?e.qd.gb(this,d):e.N.gb(this,d);Pc(e.$,this.path,d)};Q.prototype.off=Q.prototype.Zb;
Q.prototype.lg=function(a,b){function c(g){f&&(f=!1,e.Zb(a,c),b.call(d.Ka,g))}F("Query.once",2,4,arguments.length);Wb("Query.once",a,!1);H("Query.once",2,b,!1);var d=Nc("Query.once",arguments[2],arguments[3]),e=this,f=!0;this.vb(a,c,function(b){e.Zb(a,c);d.cancel&&d.cancel.call(d.Ka,b)})};Q.prototype.once=Q.prototype.lg;
Q.prototype.xe=function(a){z("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");F("Query.limit",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limit: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");var b=this.n.xe(a);Lc(b);return new Q(this.k,this.path,b,this.ac)};Q.prototype.limit=Q.prototype.xe;
Q.prototype.ye=function(a){F("Query.limitToFirst",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.ye(a),this.ac)};Q.prototype.limitToFirst=Q.prototype.ye;
Q.prototype.ze=function(a){F("Query.limitToLast",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.ze(a),this.ac)};Q.prototype.limitToLast=Q.prototype.ze;
Q.prototype.mg=function(a){F("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');Xb("Query.orderByChild",1,a,!1);Mc(this,"Query.orderByChild");var b=Hc(this.n,new oc(a));Kc(b);return new Q(this.k,this.path,b,!0)};Q.prototype.orderByChild=Q.prototype.mg;
Q.prototype.ng=function(){F("Query.orderByKey",0,0,arguments.length);Mc(this,"Query.orderByKey");var a=Hc(this.n,rc);Kc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByKey=Q.prototype.ng;Q.prototype.og=function(){F("Query.orderByPriority",0,0,arguments.length);Mc(this,"Query.orderByPriority");var a=Hc(this.n,L);Kc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByPriority=Q.prototype.og;
Q.prototype.Od=function(a,b){F("Query.startAt",0,2,arguments.length);Rb("Query.startAt",a,!0);Xb("Query.startAt",2,b,!0);var c=this.n.Od(a,b);Lc(c);Kc(c);if(this.n.ia)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");m(a)||(b=a=null);return new Q(this.k,this.path,c,this.ac)};Q.prototype.startAt=Q.prototype.Od;
Q.prototype.hd=function(a,b){F("Query.endAt",0,2,arguments.length);Rb("Query.endAt",a,!0);Xb("Query.endAt",2,b,!0);var c=this.n.hd(a,b);Lc(c);Kc(c);if(this.n.qa)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new Q(this.k,this.path,c,this.ac)};Q.prototype.endAt=Q.prototype.hd;
Q.prototype.Tf=function(a,b){F("Query.equalTo",1,2,arguments.length);Rb("Query.equalTo",a,!1);Xb("Query.equalTo",2,b,!0);if(this.n.ia)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.qa)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.Od(a,b).hd(a,b)};Q.prototype.equalTo=Q.prototype.Tf;Q.prototype.Fa=function(){var a=xb(Ic(this.n));return"{}"===a?"default":a};
function Nc(a,b,c){var d={cancel:null,Ka:null};if(b&&c)d.cancel=b,H(a,3,d.cancel,!0),d.Ka=c,Mb(a,4,d.Ka);else if(b)if("object"===typeof b&&null!==b)d.Ka=b;else if("function"===typeof b)d.cancel=b;else throw Error(G(a,3,!0)+" must either be a cancel callback or a context object.");return d};function S(a,b){if(1==arguments.length){this.w=a.split("/");for(var c=0,d=0;d<this.w.length;d++)0<this.w[d].length&&(this.w[c]=this.w[d],c++);this.w.length=c;this.ca=0}else this.w=a,this.ca=b}function I(a){return a.ca>=a.w.length?null:a.w[a.ca]}function Qc(a){return a.w.length-a.ca}function T(a){var b=a.ca;b<a.w.length&&b++;return new S(a.w,b)}function Rc(a){return a.ca<a.w.length?a.w[a.w.length-1]:null}
S.prototype.toString=function(){for(var a="",b=this.ca;b<this.w.length;b++)""!==this.w[b]&&(a+="/"+this.w[b]);return a||"/"};S.prototype.parent=function(){if(this.ca>=this.w.length)return null;for(var a=[],b=this.ca;b<this.w.length-1;b++)a.push(this.w[b]);return new S(a,0)};
S.prototype.o=function(a){for(var b=[],c=this.ca;c<this.w.length;c++)b.push(this.w[c]);if(a instanceof S)for(c=a.ca;c<a.w.length;c++)b.push(a.w[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new S(b,0)};S.prototype.e=function(){return this.ca>=this.w.length};var U=new S("");function V(a,b){var c=I(a);if(null===c)return b;if(c===I(b))return V(T(a),T(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
S.prototype.ea=function(a){if(Qc(this)!==Qc(a))return!1;for(var b=this.ca,c=a.ca;b<=this.w.length;b++,c++)if(this.w[b]!==a.w[c])return!1;return!0};S.prototype.contains=function(a){var b=this.ca,c=a.ca;if(Qc(this)>Qc(a))return!1;for(;b<this.w.length;){if(this.w[b]!==a.w[c])return!1;++b;++c}return!0};function Sc(){this.children={};this.bd=0;this.value=null}function Tc(a,b,c){this.ud=a?a:"";this.Oc=b?b:null;this.A=c?c:new Sc}function Uc(a,b){for(var c=b instanceof S?b:new S(b),d=a,e;null!==(e=I(c));)d=new Tc(e,d,t(d.A.children,e)||new Sc),c=T(c);return d}h=Tc.prototype;h.za=function(){return this.A.value};function Vc(a,b){y("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;Wc(a)}h.clear=function(){this.A.value=null;this.A.children={};this.A.bd=0;Wc(this)};
h.ld=function(){return 0<this.A.bd};h.e=function(){return null===this.za()&&!this.ld()};h.U=function(a){var b=this;A(this.A.children,function(c,d){a(new Tc(d,b,c))})};function Xc(a,b,c,d){c&&!d&&b(a);a.U(function(a){Xc(a,b,!0,d)});c&&d&&b(a)}function Yc(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}h.path=function(){return new S(null===this.Oc?this.ud:this.Oc.path()+"/"+this.ud)};h.name=function(){return this.ud};h.parent=function(){return this.Oc};
function Wc(a){if(null!==a.Oc){var b=a.Oc,c=a.ud,d=a.e(),e=s(b.A.children,c);d&&e?(delete b.A.children[c],b.A.bd--,Wc(b)):d||e||(b.A.children[c]=a.A,b.A.bd++,Wc(b))}};function Zc(a,b){this.Ja=a;this.ua=b?b:$c}h=Zc.prototype;h.La=function(a,b){return new Zc(this.Ja,this.ua.La(a,b,this.Ja).X(null,null,!1,null,null))};h.remove=function(a){return new Zc(this.Ja,this.ua.remove(a,this.Ja).X(null,null,!1,null,null))};h.get=function(a){for(var b,c=this.ua;!c.e();){b=this.Ja(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function ad(a,b){for(var c,d=a.ua,e=null;!d.e();){c=a.Ja(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}h.e=function(){return this.ua.e()};h.count=function(){return this.ua.count()};h.Ic=function(){return this.ua.Ic()};h.Xb=function(){return this.ua.Xb()};h.fa=function(a){return this.ua.fa(a)};
h.Ob=function(a){return new bd(this.ua,null,this.Ja,!1,a)};h.Pb=function(a,b){return new bd(this.ua,a,this.Ja,!1,b)};h.Rb=function(a,b){return new bd(this.ua,a,this.Ja,!0,b)};h.gf=function(a){return new bd(this.ua,null,this.Ja,!0,a)};function bd(a,b,c,d,e){this.Id=e||null;this.ve=d;this.Na=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.ve?a.left:a.right;else if(0===e){this.Na.push(a);break}else this.Na.push(a),a=this.ve?a.right:a.left}
function P(a){if(0===a.Na.length)return null;var b=a.Na.pop(),c;c=a.Id?a.Id(b.key,b.value):{key:b.key,value:b.value};if(a.ve)for(b=b.left;!b.e();)a.Na.push(b),b=b.right;else for(b=b.right;!b.e();)a.Na.push(b),b=b.left;return c}function cd(a){if(0===a.Na.length)return null;var b;b=a.Na;b=b[b.length-1];return a.Id?a.Id(b.key,b.value):{key:b.key,value:b.value}}function dd(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:$c;this.right=null!=e?e:$c}h=dd.prototype;
h.X=function(a,b,c,d,e){return new dd(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};h.count=function(){return this.left.count()+1+this.right.count()};h.e=function(){return!1};h.fa=function(a){return this.left.fa(a)||a(this.key,this.value)||this.right.fa(a)};function ed(a){return a.left.e()?a:ed(a.left)}h.Ic=function(){return ed(this).key};h.Xb=function(){return this.right.e()?this.key:this.right.Xb()};
h.La=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.X(null,null,null,e.left.La(a,b,c),null):0===d?e.X(null,b,null,null,null):e.X(null,null,null,null,e.right.La(a,b,c));return fd(e)};function gd(a){if(a.left.e())return $c;a.left.ba()||a.left.left.ba()||(a=hd(a));a=a.X(null,null,null,gd(a.left),null);return fd(a)}
h.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.ba()||c.left.left.ba()||(c=hd(c)),c=c.X(null,null,null,c.left.remove(a,b),null);else{c.left.ba()&&(c=jd(c));c.right.e()||c.right.ba()||c.right.left.ba()||(c=kd(c),c.left.left.ba()&&(c=jd(c),c=kd(c)));if(0===b(a,c.key)){if(c.right.e())return $c;d=ed(c.right);c=c.X(d.key,d.value,null,null,gd(c.right))}c=c.X(null,null,null,null,c.right.remove(a,b))}return fd(c)};h.ba=function(){return this.color};
function fd(a){a.right.ba()&&!a.left.ba()&&(a=ld(a));a.left.ba()&&a.left.left.ba()&&(a=jd(a));a.left.ba()&&a.right.ba()&&(a=kd(a));return a}function hd(a){a=kd(a);a.right.left.ba()&&(a=a.X(null,null,null,null,jd(a.right)),a=ld(a),a=kd(a));return a}function ld(a){return a.right.X(null,null,a.color,a.X(null,null,!0,null,a.right.left),null)}function jd(a){return a.left.X(null,null,a.color,null,a.X(null,null,!0,a.left.right,null))}
function kd(a){return a.X(null,null,!a.color,a.left.X(null,null,!a.left.color,null,null),a.right.X(null,null,!a.right.color,null,null))}function md(){}h=md.prototype;h.X=function(){return this};h.La=function(a,b){return new dd(a,b,null)};h.remove=function(){return this};h.count=function(){return 0};h.e=function(){return!0};h.fa=function(){return!1};h.Ic=function(){return null};h.Xb=function(){return null};h.ba=function(){return!1};var $c=new md;function nd(a,b){this.D=a;y(m(this.D)&&null!==this.D,"LeafNode shouldn't be created with null/undefined value.");this.ha=b||M;od(this.ha);this.sb=null}h=nd.prototype;h.M=function(){return!0};h.L=function(){return this.ha};h.Z=function(a){return new nd(this.D,a)};h.K=function(a){return".priority"===a?this.ha:M};h.ra=function(a){return a.e()?this:".priority"===I(a)?this.ha:M};h.Da=function(){return!1};h.ff=function(){return null};
h.P=function(a,b){return".priority"===a?this.Z(b):b.e()&&".priority"!==a?this:M.P(a,b).Z(this.ha)};h.C=function(a,b){var c=I(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;y(".priority"!==c||1===Qc(a),".priority must be the last token in a path");return this.P(c,M.C(T(a),b))};h.e=function(){return!1};h.ub=function(){return 0};h.I=function(a){return a&&!this.L().e()?{".value":this.za(),".priority":this.L().I()}:this.za()};
h.hash=function(){if(null===this.sb){var a="";this.ha.e()||(a+="priority:"+pd(this.ha.I())+":");var b=typeof this.D,a=a+(b+":"),a="number"===b?a+Ab(this.D):a+this.D;this.sb=ib(a)}return this.sb};h.za=function(){return this.D};h.he=function(a){if(a===M)return 1;if(a instanceof W)return-1;y(a.M(),"Unknown node type");var b=typeof a.D,c=typeof this.D,d=Ga(qd,b),e=Ga(qd,c);y(0<=d,"Unknown leaf type: "+b);y(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.D<a.D?-1:this.D===a.D?0:1:e-d};
var qd=["object","boolean","number","string"];nd.prototype.Fb=function(){return this};nd.prototype.Bc=function(){return!0};nd.prototype.ea=function(a){return a===this?!0:a.M()?this.D===a.D&&this.ha.ea(a.ha):!1};nd.prototype.toString=function(){return r(this.I(!0))};function rd(a,b){this.pd=a;this.Vb=b}rd.prototype.get=function(a){var b=t(this.pd,a);if(!b)throw Error("No index defined for "+a);return b===lc?null:b};function sd(a,b,c){var d=td(a.pd,function(d,f){var g=t(a.Vb,f);y(g,"Missing index implementation for "+f);if(d===lc){if(g.ue(b.Y)){for(var k=[],l=c.Ob(zc),n=P(l);n;)n.name!=b.name&&k.push(n),n=P(l);k.push(b);return ud(k,mc(g))}return lc}g=c.get(b.name);k=d;g&&(k=k.remove(new N(b.name,g)));return k.La(b,b.Y)});return new rd(d,a.Vb)}
function vd(a,b,c){var d=td(a.pd,function(a){if(a===lc)return a;var d=c.get(b.name);return d?a.remove(new N(b.name,d)):a});return new rd(d,a.Vb)}var wd=new rd({".priority":lc},{".priority":L});function W(a,b,c){this.m=a;(this.ha=b)&&od(this.ha);this.ob=c;this.sb=null}h=W.prototype;h.M=function(){return!1};h.L=function(){return this.ha||M};h.Z=function(a){return new W(this.m,a,this.ob)};h.K=function(a){if(".priority"===a)return this.L();a=this.m.get(a);return null===a?M:a};h.ra=function(a){var b=I(a);return null===b?this:this.K(b).ra(T(a))};h.Da=function(a){return null!==this.m.get(a)};
h.P=function(a,b){y(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.Z(b);var c=new N(a,b),d;b.e()?(d=this.m.remove(a),c=vd(this.ob,c,this.m)):(d=this.m.La(a,b),c=sd(this.ob,c,this.m));return new W(d,this.ha,c)};h.C=function(a,b){var c=I(a);if(null===c)return b;y(".priority"!==I(a)||1===Qc(a),".priority must be the last token in a path");var d=this.K(c).C(T(a),b);return this.P(c,d)};h.e=function(){return this.m.e()};h.ub=function(){return this.m.count()};var xd=/^(0|[1-9]\d*)$/;
h=W.prototype;h.I=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.U(L,function(f,g){b[f]=g.I(a);c++;e&&xd.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],g;for(g in b)f[g]=b[g];return f}a&&!this.L().e()&&(b[".priority"]=this.L().I());return b};h.hash=function(){if(null===this.sb){var a="";this.L().e()||(a+="priority:"+pd(this.L().I())+":");this.U(L,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.sb=""===a?"":ib(a)}return this.sb};
h.ff=function(a,b,c){return(c=yd(this,c))?(a=ad(c,new N(a,b)))?a.name:null:ad(this.m,a)};function Cc(a,b){var c;c=(c=yd(a,b))?(c=c.Ic())&&c.name:a.m.Ic();return c?new N(c,a.m.get(c)):null}function Dc(a,b){var c;c=(c=yd(a,b))?(c=c.Xb())&&c.name:a.m.Xb();return c?new N(c,a.m.get(c)):null}h.U=function(a,b){var c=yd(this,a);return c?c.fa(function(a){return b(a.name,a.Y)}):this.m.fa(b)};h.Ob=function(a){return this.Pb(a.Ce(),a)};
h.Pb=function(a,b){var c=yd(this,b);if(c)return c.Pb(a,function(a){return a});for(var c=this.m.Pb(a.name,zc),d=cd(c);null!=d&&0>b.compare(d,a);)P(c),d=cd(c);return c};h.gf=function(a){return this.Rb(a.Be(),a)};h.Rb=function(a,b){var c=yd(this,b);if(c)return c.Rb(a,function(a){return a});for(var c=this.m.Rb(a.name,zc),d=cd(c);null!=d&&0<b.compare(d,a);)P(c),d=cd(c);return c};h.he=function(a){return this.e()?a.e()?0:-1:a.M()||a.e()?1:a===pc?-1:0};
h.Fb=function(a){if(a===rc||zd(this.ob.Vb,a.toString()))return this;var b=this.ob,c=this.m;y(a!==rc,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.Ob(zc),f=P(c);f;)e=e||a.ue(f.Y),d.push(f),f=P(c);d=e?ud(d,mc(a)):lc;e=a.toString();c=Ad(b.Vb);c[e]=a;a=Ad(b.pd);a[e]=d;return new W(this.m,this.ha,new rd(a,c))};h.Bc=function(a){return a===rc||zd(this.ob.Vb,a.toString())};
h.ea=function(a){if(a===this)return!0;if(a.M())return!1;if(this.L().ea(a.L())&&this.m.count()===a.m.count()){var b=this.Ob(L);a=a.Ob(L);for(var c=P(b),d=P(a);c&&d;){if(c.name!==d.name||!c.Y.ea(d.Y))return!1;c=P(b);d=P(a)}return null===c&&null===d}return!1};function yd(a,b){return b===rc?null:a.ob.get(b.toString())}h.toString=function(){return r(this.I(!0))};function O(a,b){if(null===a)return M;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);y(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new nd(a,O(c));if(a instanceof Array){var d=M,e=a;A(e,function(a,b){if(s(e,b)&&"."!==b.substring(0,1)){var c=O(a);if(c.M()||!c.e())d=
d.P(b,c)}});return d.Z(O(c))}var f=[],g=!1,k=a;ua(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=O(k[a]);b.e()||(g=g||!b.L().e(),f.push(new N(a,b)))}});var l=ud(f,ic,function(a){return a.name},jc);if(g){var n=ud(f,mc(L));return new W(l,O(c),new rd({".priority":n},{".priority":L}))}return new W(l,O(c),wd)}var Bd=Math.log(2);function Cd(a){this.count=parseInt(Math.log(a+1)/Bd,10);this.$e=this.count-1;this.Nf=a+1&parseInt(Array(this.count+1).join("1"),2)}
function Dd(a){var b=!(a.Nf&1<<a.$e);a.$e--;return b}
function ud(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var n=a[b],u=c?c(n):n;return new dd(u,n.Y,!1,null,null)}var n=parseInt(f/2,10)+b,f=e(b,n),x=e(n+1,d),n=a[n],u=c?c(n):n;return new dd(u,n.Y,!1,f,x)}a.sort(b);var f=function(b){function d(b,g){var k=u-b,x=u;u-=b;var x=e(k+1,x),k=a[k],E=c?c(k):k,x=new dd(E,k.Y,g,null,x);f?f.left=x:n=x;f=x}for(var f=null,n=null,u=a.length,x=0;x<b.count;++x){var E=Dd(b),id=Math.pow(2,b.count-(x+1));E?d(id,!1):(d(id,!1),d(id,!0))}return n}(new Cd(a.length));
return null!==f?new Zc(d||b,f):new Zc(d||b)}function pd(a){return"number"===typeof a?"number:"+Ab(a):"string:"+a}function od(a){if(a.M()){var b=a.I();y("string"===typeof b||"number"===typeof b||"object"===typeof b&&s(b,".sv"),"Priority must be a string or number.")}else y(a===pc||a.e(),"priority of unexpected type.");y(a===pc||a.L().e(),"Priority nodes can't have a priority of their own.")}var M=new W(new Zc(jc),null,wd);function Ed(){W.call(this,new Zc(jc),M,wd)}ma(Ed,W);h=Ed.prototype;
h.he=function(a){return a===this?0:1};h.ea=function(a){return a===this};h.L=function(){throw fb("Why is this called?");};h.K=function(){return M};h.e=function(){return!1};var pc=new Ed,nc=new N("[MIN_NAME]",M);function D(a,b,c){this.A=a;this.V=b;this.g=c}D.prototype.I=function(){F("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.I()};D.prototype.val=D.prototype.I;D.prototype.bf=function(){F("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.I(!0)};D.prototype.exportVal=D.prototype.bf;D.prototype.Wf=function(){F("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};D.prototype.exists=D.prototype.Wf;
D.prototype.o=function(a){F("Firebase.DataSnapshot.child",0,1,arguments.length);ga(a)&&(a=String(a));Yb("Firebase.DataSnapshot.child",a);var b=new S(a),c=this.V.o(b);return new D(this.A.ra(b),c,L)};D.prototype.child=D.prototype.o;D.prototype.Da=function(a){F("Firebase.DataSnapshot.hasChild",1,1,arguments.length);Yb("Firebase.DataSnapshot.hasChild",a);var b=new S(a);return!this.A.ra(b).e()};D.prototype.hasChild=D.prototype.Da;
D.prototype.L=function(){F("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.L().I()};D.prototype.getPriority=D.prototype.L;D.prototype.forEach=function(a){F("Firebase.DataSnapshot.forEach",1,1,arguments.length);H("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.M())return!1;var b=this;return!!this.A.U(this.g,function(c,d){return a(new D(d,b.V.o(c),L))})};D.prototype.forEach=D.prototype.forEach;
D.prototype.ld=function(){F("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.M()?!1:!this.A.e()};D.prototype.hasChildren=D.prototype.ld;D.prototype.name=function(){z("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");F("Firebase.DataSnapshot.name",0,0,arguments.length);return this.key()};D.prototype.name=D.prototype.name;D.prototype.key=function(){F("Firebase.DataSnapshot.key",0,0,arguments.length);return this.V.key()};
D.prototype.key=D.prototype.key;D.prototype.ub=function(){F("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.ub()};D.prototype.numChildren=D.prototype.ub;D.prototype.cc=function(){F("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.V};D.prototype.ref=D.prototype.cc;function Fd(a){y(ea(a)&&0<a.length,"Requires a non-empty array");this.Ff=a;this.Gc={}}Fd.prototype.Vd=function(a,b){for(var c=this.Gc[a]||[],d=0;d<c.length;d++)c[d].qc.apply(c[d].Ka,Array.prototype.slice.call(arguments,1))};Fd.prototype.vb=function(a,b,c){Gd(this,a);this.Gc[a]=this.Gc[a]||[];this.Gc[a].push({qc:b,Ka:c});(a=this.qe(a))&&b.apply(c,a)};Fd.prototype.Zb=function(a,b,c){Gd(this,a);a=this.Gc[a]||[];for(var d=0;d<a.length;d++)if(a[d].qc===b&&(!c||c===a[d].Ka)){a.splice(d,1);break}};
function Gd(a,b){y(Ma(a.Ff,function(a){return a===b}),"Unknown event: "+b)};function Hd(){Fd.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.mc=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.mc&&(c.mc=b,c.Vd("visible",b))},!1)}}ma(Hd,Fd);ca(Hd);Hd.prototype.qe=function(a){y("visible"===a,"Unknown event type: "+a);return[this.mc]};function Id(){Fd.call(this,["online"]);this.Lc=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.Lc||a.Vd("online",!0);a.Lc=!0},!1);window.addEventListener("offline",function(){a.Lc&&a.Vd("online",!1);a.Lc=!1},!1)}}ma(Id,Fd);ca(Id);Id.prototype.qe=function(a){y("online"===a,"Unknown event type: "+a);return[this.Lc]};function A(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function td(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function Lb(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function Jb(a){var b=0,c;for(c in a)b++;return b}function Kb(a){for(var b in a)return b}function Jd(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Kd(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function zd(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function Ld(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function Md(a,b){var c=Ld(a,b,void 0);return c&&a[c]}function Nd(a){for(var b in a)return!1;return!0}function Od(a,b){return b in a?a[b]:void 0}function Ad(a){var b={},c;for(c in a)b[c]=a[c];return b}var Pd="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Qd(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Pd.length;f++)c=Pd[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Rd(){this.tc={}}function Sd(a,b,c){m(c)||(c=1);s(a.tc,b)||(a.tc[b]=0);a.tc[b]+=c}Rd.prototype.get=function(){return Ad(this.tc)};function Td(a){this.Pf=a;this.rd=null}Td.prototype.get=function(){var a=this.Pf.get(),b=Ad(a);if(this.rd)for(var c in this.rd)b[c]-=this.rd[c];this.rd=a;return b};function Ud(a,b){this.zf={};this.Pd=new Td(a);this.S=b;var c=1E4+2E4*Math.random();setTimeout(q(this.tf,this),Math.floor(c))}Ud.prototype.tf=function(){var a=this.Pd.get(),b={},c=!1,d;for(d in a)0<a[d]&&s(this.zf,d)&&(b[d]=a[d],c=!0);c&&(a=this.S,a.ja&&(b={c:b},a.f("reportStats",b),a.Ca("s",b)));setTimeout(q(this.tf,this),Math.floor(6E5*Math.random()))};var Vd={},Wd={};function Xd(a){a=a.toString();Vd[a]||(Vd[a]=new Rd);return Vd[a]}function Yd(a,b){var c=a.toString();Wd[c]||(Wd[c]=b());return Wd[c]};var Zd=null;"undefined"!==typeof MozWebSocket?Zd=MozWebSocket:"undefined"!==typeof WebSocket&&(Zd=WebSocket);function $d(a,b,c){this.ie=a;this.f=ob(this.ie);this.frames=this.Cc=null;this.ib=this.jb=this.Te=0;this.Ra=Xd(b);this.$a=(b.Ab?"wss://":"ws://")+b.Ma+"/.ws?v=5";"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(this.$a+="&r=f");b.host!==b.Ma&&(this.$a=this.$a+"&ns="+b.tb);c&&(this.$a=this.$a+"&s="+c)}var ae;
$d.prototype.open=function(a,b){this.fb=b;this.hg=a;this.f("Websocket connecting to "+this.$a);this.xc=!1;za.set("previous_websocket_failure",!0);try{this.ta=new Zd(this.$a)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.eb();return}var e=this;this.ta.onopen=function(){e.f("Websocket connected.");e.xc=!0};this.ta.onclose=function(){e.f("Websocket connection was disconnected.");e.ta=null;e.eb()};this.ta.onmessage=function(a){if(null!==e.ta)if(a=a.data,e.ib+=
a.length,Sd(e.Ra,"bytes_received",a.length),be(e),null!==e.frames)ce(e,a);else{a:{y(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.Te=b;e.frames=[];a=null;break a}}e.Te=1;e.frames=[]}null!==a&&ce(e,a)}};this.ta.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.eb()}};$d.prototype.start=function(){};
$d.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==Zd&&!ae};$d.responsesRequiredToBeHealthy=2;$d.healthyTimeout=3E4;h=$d.prototype;h.sd=function(){za.remove("previous_websocket_failure")};function ce(a,b){a.frames.push(b);if(a.frames.length==a.Te){var c=a.frames.join("");a.frames=null;c=ta(c);a.hg(c)}}
h.send=function(a){be(this);a=r(a);this.jb+=a.length;Sd(this.Ra,"bytes_sent",a.length);a=yb(a,16384);1<a.length&&this.ta.send(String(a.length));for(var b=0;b<a.length;b++)this.ta.send(a[b])};h.Uc=function(){this.qb=!0;this.Cc&&(clearInterval(this.Cc),this.Cc=null);this.ta&&(this.ta.close(),this.ta=null)};h.eb=function(){this.qb||(this.f("WebSocket is closing itself"),this.Uc(),this.fb&&(this.fb(this.xc),this.fb=null))};h.close=function(){this.qb||(this.f("WebSocket is being closed"),this.Uc())};
function be(a){clearInterval(a.Cc);a.Cc=setInterval(function(){a.ta&&a.ta.send("0");be(a)},Math.floor(45E3))};function de(a){this.$b=a;this.Cd=[];this.Jb=0;this.ge=-1;this.wb=null}function ee(a,b,c){a.ge=b;a.wb=c;a.ge<a.Jb&&(a.wb(),a.wb=null)}function fe(a,b,c){for(a.Cd[b]=c;a.Cd[a.Jb];){var d=a.Cd[a.Jb];delete a.Cd[a.Jb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;Cb(function(){f.$b(d[e])})}if(a.Jb===a.ge){a.wb&&(clearTimeout(a.wb),a.wb(),a.wb=null);break}a.Jb++}};function ge(){this.set={}}h=ge.prototype;h.add=function(a,b){this.set[a]=null!==b?b:!0};h.contains=function(a){return s(this.set,a)};h.get=function(a){return this.contains(a)?this.set[a]:void 0};h.remove=function(a){delete this.set[a]};h.clear=function(){this.set={}};h.e=function(){return Nd(this.set)};h.count=function(){return Jb(this.set)};function he(a,b){A(a.set,function(a,d){b(d,a)})};function ie(a,b,c){this.ie=a;this.f=ob(a);this.ib=this.jb=0;this.Ra=Xd(b);this.Md=c;this.xc=!1;this.Zc=function(a){b.host!==b.Ma&&(a.ns=b.tb);var c=[],f;for(f in a)a.hasOwnProperty(f)&&c.push(f+"="+a[f]);return(b.Ab?"https://":"http://")+b.Ma+"/.lp?"+c.join("&")}}var je,ke;
ie.prototype.open=function(a,b){this.Ze=0;this.ga=b;this.mf=new de(a);this.qb=!1;var c=this;this.lb=setTimeout(function(){c.f("Timed out trying to connect.");c.eb();c.lb=null},Math.floor(3E4));tb(function(){if(!c.qb){c.Pa=new le(function(a,b,d,k,l){me(c,arguments);if(c.Pa)if(c.lb&&(clearTimeout(c.lb),c.lb=null),c.xc=!0,"start"==a)c.id=b,c.rf=d;else if("close"===a)b?(c.Pa.Kd=!1,ee(c.mf,b,function(){c.eb()})):c.eb();else throw Error("Unrecognized command received: "+a);},function(a,b){me(c,arguments);
fe(c.mf,a,b)},function(){c.eb()},c.Zc);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Pa.Wd&&(a.cb=c.Pa.Wd);a.v="5";c.Md&&(a.s=c.Md);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.Zc(a);c.f("Connecting via long-poll to "+a);ne(c.Pa,a,function(){})}})};
ie.prototype.start=function(){var a=this.Pa,b=this.rf;a.cg=this.id;a.dg=b;for(a.ae=!0;oe(a););a=this.id;b=this.rf;this.Yb=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.Yb.src=this.Zc(c);this.Yb.style.display="none";document.body.appendChild(this.Yb)};ie.isAvailable=function(){return!ke&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.Eg)&&(je||!0)};h=ie.prototype;
h.sd=function(){};h.Uc=function(){this.qb=!0;this.Pa&&(this.Pa.close(),this.Pa=null);this.Yb&&(document.body.removeChild(this.Yb),this.Yb=null);this.lb&&(clearTimeout(this.lb),this.lb=null)};h.eb=function(){this.qb||(this.f("Longpoll is closing itself"),this.Uc(),this.ga&&(this.ga(this.xc),this.ga=null))};h.close=function(){this.qb||(this.f("Longpoll is being closed."),this.Uc())};
h.send=function(a){a=r(a);this.jb+=a.length;Sd(this.Ra,"bytes_sent",a.length);a=jb(a);a=cb(a,!0);a=yb(a,1840);for(var b=0;b<a.length;b++){var c=this.Pa;c.Qc.push({tg:this.Ze,Bg:a.length,af:a[b]});c.ae&&oe(c);this.Ze++}};function me(a,b){var c=r(b).length;a.ib+=c;Sd(a.Ra,"bytes_received",c)}
function le(a,b,c,d){this.Zc=d;this.fb=c;this.Ie=new ge;this.Qc=[];this.ke=Math.floor(1E8*Math.random());this.Kd=!0;this.Wd=eb();window["pLPCommand"+this.Wd]=a;window["pRTLPCB"+this.Wd]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||hb("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.ab=a.contentDocument:a.contentWindow?a.ab=a.contentWindow.document:a.document&&(a.ab=a.document);this.Ba=a;a="";this.Ba.src&&"javascript:"===this.Ba.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Ba.ab.open(),this.Ba.ab.write(a),this.Ba.ab.close()}catch(f){hb("frame writing exception"),f.stack&&hb(f.stack),hb(f)}}
le.prototype.close=function(){this.ae=!1;if(this.Ba){this.Ba.ab.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Ba&&(document.body.removeChild(a.Ba),a.Ba=null)},Math.floor(0))}var b=this.fb;b&&(this.fb=null,b())};
function oe(a){if(a.ae&&a.Kd&&a.Ie.count()<(0<a.Qc.length?2:1)){a.ke++;var b={};b.id=a.cg;b.pw=a.dg;b.ser=a.ke;for(var b=a.Zc(b),c="",d=0;0<a.Qc.length;)if(1870>=a.Qc[0].af.length+30+c.length){var e=a.Qc.shift(),c=c+"&seg"+d+"="+e.tg+"&ts"+d+"="+e.Bg+"&d"+d+"="+e.af;d++}else break;pe(a,b+c,a.ke);return!0}return!1}function pe(a,b,c){function d(){a.Ie.remove(c);oe(a)}a.Ie.add(c);var e=setTimeout(d,Math.floor(25E3));ne(a,b,function(){clearTimeout(e);d()})}
function ne(a,b,c){setTimeout(function(){try{if(a.Kd){var d=a.Ba.ab.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){hb("Long-poll script failed to load: "+b);a.Kd=!1;a.close()};a.Ba.ab.body.appendChild(d)}}catch(e){}},Math.floor(1))};function qe(a){re(this,a)}var se=[ie,$d];function re(a,b){var c=$d&&$d.isAvailable(),d=c&&!(za.lf||!0===za.get("previous_websocket_failure"));b.Dg&&(c||z("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.Xc=[$d];else{var e=a.Xc=[];zb(se,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function te(a){if(0<a.Xc.length)return a.Xc[0];throw Error("No transports available");};function ue(a,b,c,d,e,f){this.id=a;this.f=ob("c:"+this.id+":");this.$b=c;this.Kc=d;this.ga=e;this.Ge=f;this.O=b;this.Bd=[];this.Xe=0;this.Af=new qe(b);this.Qa=0;this.f("Connection created");ve(this)}
function ve(a){var b=te(a.Af);a.J=new b("c:"+a.id+":"+a.Xe++,a.O);a.Ke=b.responsesRequiredToBeHealthy||0;var c=we(a,a.J),d=xe(a,a.J);a.Yc=a.J;a.Tc=a.J;a.B=null;a.rb=!1;setTimeout(function(){a.J&&a.J.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.nd=setTimeout(function(){a.nd=null;a.rb||(a.J&&102400<a.J.ib?(a.f("Connection exceeded healthy timeout but has received "+a.J.ib+" bytes.  Marking connection healthy."),a.rb=!0,a.J.sd()):a.J&&10240<a.J.jb?a.f("Connection exceeded healthy timeout but has sent "+
a.J.jb+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function xe(a,b){return function(c){b===a.J?(a.J=null,c||0!==a.Qa?1===a.Qa&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.O.Ma.substr(0,2)&&(za.remove("host:"+a.O.host),a.O.Ma=a.O.host)),a.close()):b===a.B?(a.f("Secondary connection lost."),c=a.B,a.B=null,a.Yc!==c&&a.Tc!==c||a.close()):a.f("closing an old connection")}}
function we(a,b){return function(c){if(2!=a.Qa)if(b===a.Tc){var d=wb("t",c);c=wb("d",c);if("c"==d){if(d=wb("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.Md=c.s;Ba(a.O,f);0==a.Qa&&(a.J.start(),ye(a,a.J,d),"5"!==e&&z("Protocol version mismatch detected"),c=a.Af,(c=1<c.Xc.length?c.Xc[1]:null)&&ze(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.Tc=a.B;for(c=0;c<a.Bd.length;++c)a.xd(a.Bd[c]);a.Bd=[];Ae(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.Ge&&(a.Ge(c),a.Ge=null),a.ga=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),Ba(a.O,c),1===a.Qa?a.close():(Be(a),ve(a))):"e"===d?pb("Server Error: "+c):"o"===d?(a.f("got pong on primary."),Ce(a),De(a)):pb("Unknown control packet command: "+d)}else"d"==d&&a.xd(c)}else if(b===a.B)if(d=wb("t",c),c=wb("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?Ee(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.B.close(),a.Yc!==a.B&&a.Tc!==a.B||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.yf--,Ee(a)));else if("d"==d)a.Bd.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}ue.prototype.Ca=function(a){Fe(this,{t:"d",d:a})};function Ae(a){a.Yc===a.B&&a.Tc===a.B&&(a.f("cleaning up and promoting a connection: "+a.B.ie),a.J=a.B,a.B=null)}
function Ee(a){0>=a.yf?(a.f("Secondary connection is healthy."),a.rb=!0,a.B.sd(),a.B.start(),a.f("sending client ack on secondary"),a.B.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.J.send({t:"c",d:{t:"n",d:{}}}),a.Yc=a.B,Ae(a)):(a.f("sending ping on secondary."),a.B.send({t:"c",d:{t:"p",d:{}}}))}ue.prototype.xd=function(a){Ce(this);this.$b(a)};function Ce(a){a.rb||(a.Ke--,0>=a.Ke&&(a.f("Primary connection is healthy."),a.rb=!0,a.J.sd()))}
function ze(a,b){a.B=new b("c:"+a.id+":"+a.Xe++,a.O,a.Md);a.yf=b.responsesRequiredToBeHealthy||0;a.B.open(we(a,a.B),xe(a,a.B));setTimeout(function(){a.B&&(a.f("Timed out trying to upgrade."),a.B.close())},Math.floor(6E4))}function ye(a,b,c){a.f("Realtime connection established.");a.J=b;a.Qa=1;a.Kc&&(a.Kc(c),a.Kc=null);0===a.Ke?(a.f("Primary connection is healthy."),a.rb=!0):setTimeout(function(){De(a)},Math.floor(5E3))}
function De(a){a.rb||1!==a.Qa||(a.f("sending ping on primary."),Fe(a,{t:"c",d:{t:"p",d:{}}}))}function Fe(a,b){if(1!==a.Qa)throw"Connection is not connected";a.Yc.send(b)}ue.prototype.close=function(){2!==this.Qa&&(this.f("Closing realtime connection."),this.Qa=2,Be(this),this.ga&&(this.ga(),this.ga=null))};function Be(a){a.f("Shutting down all connections");a.J&&(a.J.close(),a.J=null);a.B&&(a.B.close(),a.B=null);a.nd&&(clearTimeout(a.nd),a.nd=null)};function Ge(a){var b={},c={},d={},e="";try{var f=a.split("."),b=ta(gb(f[0])||""),c=ta(gb(f[1])||""),e=f[2],d=c.d||{};delete c.d}catch(g){}return{Gg:b,fe:c,data:d,xg:e}}function He(a){a=Ge(a).fe;return"object"===typeof a&&a.hasOwnProperty("iat")?t(a,"iat"):null}function Ie(a){a=Ge(a);var b=a.fe;return!!a.xg&&!!b&&"object"===typeof b&&b.hasOwnProperty("iat")};function Je(a,b,c,d){this.id=Ke++;this.f=ob("p:"+this.id+":");this.Cb=!0;this.Aa={};this.la=[];this.Nc=0;this.Jc=[];this.ja=!1;this.Wa=1E3;this.td=3E5;this.yd=b;this.wd=c;this.He=d;this.O=a;this.Oe=null;this.Sc={};this.sg=0;this.Dc=this.we=null;Le(this,0);Hd.Nb().vb("visible",this.kg,this);-1===a.host.indexOf("fblocal")&&Id.Nb().vb("online",this.ig,this)}var Ke=0,Me=0;h=Je.prototype;
h.Ca=function(a,b,c){var d=++this.sg;a={r:d,a:a,b:b};this.f(r(a));y(this.ja,"sendRequest call when we're not connected not allowed.");this.Oa.Ca(a);c&&(this.Sc[d]=c)};function Ne(a,b,c,d,e){var f=b.Fa(),g=b.path.toString();a.f("Listen called for "+g+" "+f);a.Aa[g]=a.Aa[g]||{};y(!a.Aa[g][f],"listen() called twice for same path/queryId.");b={H:e,md:c,pg:Ic(b.n),tag:d};a.Aa[g][f]=b;a.ja&&Oe(a,g,f,b)}
function Oe(a,b,c,d){a.f("Listen on "+b+" for "+c);var e={p:b};d.tag&&(e.q=d.pg,e.t=d.tag);e.h=d.md();a.Ca("q",e,function(e){if((a.Aa[b]&&a.Aa[b][c])===d){a.f("listen response",e);var g=e.s;"ok"!==g&&Pe(a,b,c);e=e.d;d.H&&d.H(g,e)}})}h.Q=function(a,b,c){this.Ib={Rf:a,cf:!1,qc:b,ad:c};this.f("Authenticating using credential: "+a);Qe(this);(b=40==a.length)||(a=Ge(a).fe,b="object"===typeof a&&!0===t(a,"admin"));b&&(this.f("Admin auth credential detected.  Reducing max reconnect time."),this.td=3E4)};
h.Ue=function(a){delete this.Ib;this.ja&&this.Ca("unauth",{},function(b){a(b.s,b.d)})};function Qe(a){var b=a.Ib;a.ja&&b&&a.Ca("auth",{cred:b.Rf},function(c){var d=c.s;c=c.d||"error";"ok"!==d&&a.Ib===b&&delete a.Ib;b.cf?"ok"!==d&&b.ad&&b.ad(d,c):(b.cf=!0,b.qc&&b.qc(d,c))})}function Re(a,b,c,d){a.ja?Se(a,"o",b,c,d):a.Jc.push({Pc:b,action:"o",data:c,H:d})}function Te(a,b,c,d){a.ja?Se(a,"om",b,c,d):a.Jc.push({Pc:b,action:"om",data:c,H:d})}
h.Fe=function(a,b){this.ja?Se(this,"oc",a,null,b):this.Jc.push({Pc:a,action:"oc",data:null,H:b})};function Se(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.Ca(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}h.put=function(a,b,c,d){Ue(this,"p",a,b,c,d)};function Ve(a,b,c,d){Ue(a,"m",b,c,d,void 0)}function Ue(a,b,c,d,e,f){d={p:c,d:d};m(f)&&(d.h=f);a.la.push({action:b,uf:d,H:e});a.Nc++;b=a.la.length-1;a.ja?We(a,b):a.f("Buffering put: "+c)}
function We(a,b){var c=a.la[b].action,d=a.la[b].uf,e=a.la[b].H;a.la[b].qg=a.ja;a.Ca(c,d,function(d){a.f(c+" response",d);delete a.la[b];a.Nc--;0===a.Nc&&(a.la=[]);e&&e(d.s,d.d)})}
h.xd=function(a){if("r"in a){this.f("from server: "+r(a));var b=a.r,c=this.Sc[b];c&&(delete this.Sc[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,c=a.b,this.f("handleServerMessage",b,c),"d"===b?this.yd(c.p,c.d,!1,c.t):"m"===b?this.yd(c.p,c.d,!0,c.t):"c"===b?Xe(this,c.p,c.q):"ac"===b?(a=c.s,b=c.d,c=this.Ib,delete this.Ib,c&&c.ad&&c.ad(a,b)):"sd"===b?this.Oe?this.Oe(c):"msg"in c&&"undefined"!==typeof console&&console.log("FIREBASE: "+c.msg.replace("\n",
"\nFIREBASE: ")):pb("Unrecognized action received from server: "+r(b)+"\nAre you using the latest client?"))}};h.Kc=function(a){this.f("connection ready");this.ja=!0;this.Dc=(new Date).getTime();this.He({serverTimeOffset:a-(new Date).getTime()});Ye(this);this.wd(!0)};function Le(a,b){y(!a.Oa,"Scheduling a connect when we're already connected/ing?");a.Kb&&clearTimeout(a.Kb);a.Kb=setTimeout(function(){a.Kb=null;Ze(a)},Math.floor(b))}
h.kg=function(a){a&&!this.mc&&this.Wa===this.td&&(this.f("Window became visible.  Reducing delay."),this.Wa=1E3,this.Oa||Le(this,0));this.mc=a};h.ig=function(a){a?(this.f("Browser went online.  Reconnecting."),this.Wa=1E3,this.Cb=!0,this.Oa||Le(this,0)):(this.f("Browser went offline.  Killing connection; don't reconnect."),this.Cb=!1,this.Oa&&this.Oa.close())};
h.of=function(){this.f("data client disconnected");this.ja=!1;this.Oa=null;for(var a=0;a<this.la.length;a++){var b=this.la[a];b&&"h"in b.uf&&b.qg&&(b.H&&b.H("disconnect"),delete this.la[a],this.Nc--)}0===this.Nc&&(this.la=[]);if(this.Cb)this.mc?this.Dc&&(3E4<(new Date).getTime()-this.Dc&&(this.Wa=1E3),this.Dc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.Wa=this.td,this.we=(new Date).getTime()),a=Math.max(0,this.Wa-((new Date).getTime()-this.we)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),Le(this,a),this.Wa=Math.min(this.td,1.3*this.Wa);else for(var c in this.Sc)delete this.Sc[c];this.wd(!1)};function Ze(a){if(a.Cb){a.f("Making a connection attempt");a.we=(new Date).getTime();a.Dc=null;var b=q(a.xd,a),c=q(a.Kc,a),d=q(a.of,a),e=a.id+":"+Me++;a.Oa=new ue(e,a.O,b,c,d,function(b){z(b+" ("+a.O.toString()+")");a.Cb=!1})}}h.pb=function(){this.Cb=!1;this.Oa?this.Oa.close():(this.Kb&&(clearTimeout(this.Kb),this.Kb=null),this.ja&&this.of())};
h.hc=function(){this.Cb=!0;this.Wa=1E3;this.Oa||Le(this,0)};function Xe(a,b,c){c=c?Ja(c,function(a){return xb(a)}).join("$"):"default";(a=Pe(a,b,c))&&a.H&&a.H("permission_denied")}function Pe(a,b,c){b=(new S(b)).toString();var d=a.Aa[b][c];delete a.Aa[b][c];0===Jb(a.Aa[b])&&delete a.Aa[b];return d}function Ye(a){Qe(a);A(a.Aa,function(b,d){A(b,function(b,c){Oe(a,d,c,b)})});for(var b=0;b<a.la.length;b++)a.la[b]&&We(a,b);for(;a.Jc.length;)b=a.Jc.shift(),Se(a,b.action,b.Pc,b.data,b.H)};function $e(){this.m=this.D=null}$e.prototype.dc=function(a,b){if(a.e())this.D=b,this.m=null;else if(null!==this.D)this.D=this.D.C(a,b);else{null==this.m&&(this.m=new ge);var c=I(a);this.m.contains(c)||this.m.add(c,new $e);c=this.m.get(c);a=T(a);c.dc(a,b)}};
function af(a,b){if(b.e())return a.D=null,a.m=null,!0;if(null!==a.D){if(a.D.M())return!1;var c=a.D;a.D=null;c.U(L,function(b,c){a.dc(new S(b),c)});return af(a,b)}return null!==a.m?(c=I(b),b=T(b),a.m.contains(c)&&af(a.m.get(c),b)&&a.m.remove(c),a.m.e()?(a.m=null,!0):!1):!0}function bf(a,b,c){null!==a.D?c(b,a.D):a.U(function(a,e){var f=new S(b.toString()+"/"+a);bf(e,f,c)})}$e.prototype.U=function(a){null!==this.m&&he(this.m,function(b,c){a(b,c)})};function cf(){this.Jd=M}cf.prototype.j=function(a){return this.Jd.ra(a)};cf.prototype.toString=function(){return this.Jd.toString()};function df(){this.nb=[]}function ef(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.Qb();null===c||f.ea(c.Qb())||(a.nb.push(c),c=null);null===c&&(c=new ff(f));c.add(e)}c&&a.nb.push(c)}function Pc(a,b,c){ef(a,c);gf(a,function(a){return a.ea(b)})}function hf(a,b,c){ef(a,c);gf(a,function(a){return a.contains(b)||b.contains(a)})}
function gf(a,b){for(var c=!0,d=0;d<a.nb.length;d++){var e=a.nb[d];if(e)if(e=e.Qb(),b(e)){for(var e=a.nb[d],f=0;f<e.kd.length;f++){var g=e.kd[f];if(null!==g){e.kd[f]=null;var k=g.Lb();lb&&hb("event: "+g.toString());Cb(k)}}a.nb[d]=null}else c=!1}c&&(a.nb=[])}function ff(a){this.Ea=a;this.kd=[]}ff.prototype.add=function(a){this.kd.push(a)};ff.prototype.Qb=function(){return this.Ea};var jf="auth.firebase.com";function kf(a,b,c){this.cd=a||{};this.Ud=b||{};this.Xa=c||{};this.cd.remember||(this.cd.remember="default")}var lf=["remember","redirectTo"];function mf(a){var b={},c={};ua(a||{},function(a,e){0<=Ga(lf,a)?b[a]=e:c[a]=e});return new kf(b,{},c)};var nf={NETWORK_ERROR:"Unable to contact the Firebase server.",SERVER_ERROR:"An unknown server error occurred.",TRANSPORT_UNAVAILABLE:"There are no login transports available for the requested method.",REQUEST_INTERRUPTED:"The browser redirected the page before the login request could complete.",USER_CANCELLED:"The user cancelled authentication."};function X(a){var b=Error(t(nf,a),a);b.code=a;return b};function of(){var a=window.opener.frames,b;for(b=a.length-1;0<=b;b--)try{if(a[b].location.protocol===window.location.protocol&&a[b].location.host===window.location.host&&"__winchan_relay_frame"===a[b].name)return a[b]}catch(c){}return null}function pf(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,!1)}function qf(a,b,c){a.detachEvent?a.detachEvent("on"+b,c):a.removeEventListener&&a.removeEventListener(b,c,!1)}
function rf(a){/^https?:\/\//.test(a)||(a=window.location.href);var b=/^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);return b?b[1]:a}function sf(a){var b="";try{a=a.replace("#","");var c={},d=a.replace(/^\?/,"").split("&");for(a=0;a<d.length;a++)if(d[a]){var e=d[a].split("=");c[e[0]]=e[1]}c&&s(c,"__firebase_request_key")&&(b=t(c,"__firebase_request_key"))}catch(f){}return b}
function tf(a){var b=[],c;for(c in a)if(s(a,c)){var d=t(a,c);if(ea(d))for(var e=0;e<d.length;e++)b.push(encodeURIComponent(c)+"="+encodeURIComponent(d[e]));else b.push(encodeURIComponent(c)+"="+encodeURIComponent(t(a,c)))}return b?"&"+b.join("&"):""}function uf(){var a=rb(jf);return a.scheme+"://"+a.host+"/v2"}function vf(a){return uf()+"/"+a+"/auth/channel"};function wf(){return!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(navigator.userAgent)}function xf(){var a=navigator.userAgent;if("Microsoft Internet Explorer"===navigator.appName){if((a=a.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1])}else if(-1<a.indexOf("Trident")&&(a=a.match(/rv:([0-9]{2,2}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1]);return!1};function yf(a){a.method||(a.method="GET");a.headers||(a.headers={});a.headers.content_type||(a.headers.content_type="application/json");a.headers.content_type=a.headers.content_type.toLowerCase();this.options=a}
yf.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}var e=new XMLHttpRequest,f=this.options.method.toUpperCase(),g;pf(window,"beforeunload",d);e.onreadystatechange=function(){if(c&&4===e.readyState){var a;if(200<=e.status&&300>e.status){try{a=ta(e.responseText)}catch(b){}c(null,a)}else 500<=e.status&&600>e.status?c(X("SERVER_ERROR")):c(X("NETWORK_ERROR"));c=null;qf(window,"beforeunload",d)}};if("GET"===f)a+=(/\?/.test(a)?"":"?")+tf(b),g=null;else{var k=this.options.headers.content_type;
"application/json"===k&&(g=r(b));"application/x-www-form-urlencoded"===k&&(g=tf(b))}e.open(f,a,!0);a={"X-Requested-With":"XMLHttpRequest",Accept:"application/json;text/plain"};Qd(a,this.options.headers);for(var l in a)e.setRequestHeader(l,a[l]);e.send(g)};yf.isAvailable=function(){return!!window.XMLHttpRequest&&"string"===typeof(new XMLHttpRequest).responseType&&(!(navigator.userAgent.match(/MSIE/)||navigator.userAgent.match(/Trident/))||xf())};yf.prototype.sc=function(){return"json"};function zf(a){this.fc=Fa()+Fa()+Fa();this.pf=a}
zf.prototype.open=function(a,b,c){function d(){c&&(c(X("USER_CANCELLED")),c=null)}var e=this,f=rb(jf),g;b.requestId=this.fc;b.redirectTo=f.scheme+"://"+f.host+"/blank/page.html";a+=/\?/.test(a)?"":"?";a+=tf(b);(g=window.open(a,"_blank","location=no"))&&ha(g.addEventListener)?(g.addEventListener("loadstart",function(a){var b;if(b=a&&a.url)a:{var n=a.url;try{var u=document.createElement("a");u.href=n;b=u.host===f.host&&"/blank/page.html"===u.pathname;break a}catch(x){}b=!1}b&&(a=sf(a.url),g.removeEventListener("exit",
d),g.close(),a=new kf(null,null,{requestId:e.fc,requestKey:a}),e.pf.requestWithCredential("/auth/session",a,c),c=null)}),g.addEventListener("exit",d)):c(X("TRANSPORT_UNAVAILABLE"))};zf.isAvailable=function(){return wf()};zf.prototype.sc=function(){return"redirect"};function Af(a){if(!a.window_features||-1!==navigator.userAgent.indexOf("Fennec/")||-1!==navigator.userAgent.indexOf("Firefox/")&&-1!==navigator.userAgent.indexOf("Android"))a.window_features=void 0;a.window_name||(a.window_name="_blank");this.options=a}
Af.prototype.open=function(a,b,c){function d(a){g&&(document.body.removeChild(g),g=void 0);u&&(u=clearInterval(u));qf(window,"message",e);qf(window,"unload",d);if(n&&!a)try{n.close()}catch(b){k.postMessage("die",l)}n=k=void 0}function e(a){if(a.origin===l)try{var b=ta(a.data);"ready"===b.a?k.postMessage(x,l):"error"===b.a?(d(!1),c&&(c(b.d),c=null)):"response"===b.a&&(d(b.forceKeepWindowOpen),c&&(c(null,b.d),c=null))}catch(e){}}var f=xf(),g,k;if(!this.options.relay_url)return c(Error("invalid arguments: origin of url and relay_url must match"));
var l=rf(a);if(l!==rf(this.options.relay_url))c&&setTimeout(function(){c(Error("invalid arguments: origin of url and relay_url must match"))},0);else{f&&(g=document.createElement("iframe"),g.setAttribute("src",this.options.relay_url),g.style.display="none",g.setAttribute("name","__winchan_relay_frame"),document.body.appendChild(g),k=g.contentWindow);a+=(/\?/.test(a)?"":"?")+tf(b);var n=window.open(a,this.options.window_name,this.options.window_features);k||(k=n);var u=setInterval(function(){n&&n.closed&&
(d(!1),c&&(c(X("USER_CANCELLED")),c=null))},500),x=r({a:"request",d:b});pf(window,"unload",d);pf(window,"message",e)}};
Af.isAvailable=function(){return"postMessage"in window&&!/^file:\//.test(location.href)&&!(wf()||navigator.userAgent.match(/Windows Phone/)||window.Windows&&/^ms-appx:/.test(location.href)||navigator.userAgent.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)||navigator.userAgent.match(/CriOS/)||navigator.userAgent.match(/Twitter for iPhone/)||navigator.userAgent.match(/FBAN\/FBIOS/)||window.navigator.standalone)&&!navigator.userAgent.match(/PhantomJS/)};Af.prototype.sc=function(){return"popup"};function Bf(a){a.callback_parameter||(a.callback_parameter="callback");this.options=a;window.__firebase_auth_jsonp=window.__firebase_auth_jsonp||{}}
Bf.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}function e(){setTimeout(function(){window.__firebase_auth_jsonp[f]=void 0;Nd(window.__firebase_auth_jsonp)&&(window.__firebase_auth_jsonp=void 0);try{var a=document.getElementById(f);a&&a.parentNode.removeChild(a)}catch(b){}},1);qf(window,"beforeunload",d)}var f="fn"+(new Date).getTime()+Math.floor(99999*Math.random());b[this.options.callback_parameter]="__firebase_auth_jsonp."+f;a+=(/\?/.test(a)?"":"?")+tf(b);
pf(window,"beforeunload",d);window.__firebase_auth_jsonp[f]=function(a){c&&(c(null,a),c=null);e()};Cf(f,a,c)};
function Cf(a,b,c){setTimeout(function(){try{var d=document.createElement("script");d.type="text/javascript";d.id=a;d.async=!0;d.src=b;d.onerror=function(){var b=document.getElementById(a);null!==b&&b.parentNode.removeChild(b);c&&c(X("NETWORK_ERROR"))};var e=document.getElementsByTagName("head");(e&&0!=e.length?e[0]:document.documentElement).appendChild(d)}catch(f){c&&c(X("NETWORK_ERROR"))}},0)}Bf.isAvailable=function(){return!wf()};Bf.prototype.sc=function(){return"json"};function Df(a,b){this.Je=["session",a.Dd,a.tb].join(":");this.Rd=b}Df.prototype.set=function(a,b){if(!b)if(this.Rd.length)b=this.Rd[0];else throw Error("fb.login.SessionManager : No storage options available!");b.set(this.Je,a)};Df.prototype.get=function(){var a=Ja(this.Rd,q(this.Zf,this)),a=Ia(a,function(a){return null!==a});Qa(a,function(a,c){return He(c.token)-He(a.token)});return 0<a.length?a.shift():null};Df.prototype.Zf=function(a){try{var b=a.get(this.Je);if(b&&b.token)return b}catch(c){}return null};
Df.prototype.clear=function(){var a=this;Ha(this.Rd,function(b){b.remove(a.Je)})};function Ef(a){this.fc=Fa()+Fa()+Fa();this.pf=a}Ef.prototype.open=function(a,b){v.set("redirect_request_id",this.fc);v.set("redirect_request_id",this.fc);b.requestId=this.fc;b.redirectTo=b.redirectTo||window.location.href;a+=(/\?/.test(a)?"":"?")+tf(b);window.location=a};Ef.isAvailable=function(){return!/^file:\//.test(location.href)&&!wf()};Ef.prototype.sc=function(){return"redirect"};function Ff(a,b,c,d){Fd.call(this,["auth_status"]);this.O=a;this.We=b;this.Cg=c;this.Ee=d;this.ic=new Df(a,[za,v]);this.hb=null;Gf(this)}ma(Ff,Fd);h=Ff.prototype;h.ne=function(){return this.hb||null};function Gf(a){v.get("redirect_request_id")&&Hf(a);var b=a.ic.get();b&&b.token?(If(a,b),a.We(b.token,function(c,d){Jf(a,c,d,!1,b.token,b)},function(b,d){Kf(a,"resumeSession()",b,d)})):If(a,null)}
function Lf(a,b,c,d,e,f){"firebaseio-demo.com"===a.O.domain&&z("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");a.We(b,function(f,k){Jf(a,f,k,!0,b,c,d||{},e)},function(b,c){Kf(a,"auth()",b,c,f)})}function Mf(a,b){a.ic.clear();If(a,null);a.Cg(function(a,d){if("ok"===a)B(b,null);else{var e=(a||"error").toUpperCase(),f=e;d&&(f+=": "+d);f=Error(f);f.code=e;B(b,f)}})}
function Jf(a,b,c,d,e,f,g,k){"ok"===b?(d&&(b=c.auth,f.auth=b,f.expires=c.expires,f.token=Ie(e)?e:"",c=null,b&&s(b,"uid")?c=t(b,"uid"):s(f,"uid")&&(c=t(f,"uid")),f.uid=c,c="custom",b&&s(b,"provider")?c=t(b,"provider"):s(f,"provider")&&(c=t(f,"provider")),f.provider=c,a.ic.clear(),Ie(e)&&(g=g||{},c=za,"sessionOnly"===g.remember&&(c=v),"none"!==g.remember&&a.ic.set(f,c)),If(a,f)),B(k,null,f)):(a.ic.clear(),If(a,null),f=a=(b||"error").toUpperCase(),c&&(f+=": "+c),f=Error(f),f.code=a,B(k,f))}
function Kf(a,b,c,d,e){z(b+" was canceled: "+d);a.ic.clear();If(a,null);a=Error(d);a.code=c.toUpperCase();B(e,a)}function Nf(a,b,c,d,e){Of(a);c=new kf(d||{},{},c||{});Pf(a,[yf,Bf],"/auth/"+b,c,e)}
function Qf(a,b,c,d){Of(a);var e=[Af,zf];c=mf(c);"anonymous"===b||"password"===b?setTimeout(function(){B(d,X("TRANSPORT_UNAVAILABLE"))},0):(c.Ud.window_features="menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top="+("object"===typeof screen?.5*(screen.height-625):0)+",left="+("object"===typeof screen?.5*(screen.width-625):0),c.Ud.relay_url=vf(a.O.tb),c.Ud.requestWithCredential=q(a.gc,a),Pf(a,e,"/auth/"+b,c,d))}
function Hf(a){var b=v.get("redirect_request_id");if(b){var c=v.get("redirect_client_options");v.remove("redirect_request_id");v.remove("redirect_client_options");var d=[yf,Bf],b={requestId:b,requestKey:sf(document.location.hash)},c=new kf(c,{},b);try{document.location.hash=document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/,"")}catch(e){}Pf(a,d,"/auth/session",c)}}h.je=function(a,b){Of(this);var c=mf(a);c.Xa._method="POST";this.gc("/users",c,function(a,c){a?B(b,a):B(b,a,c)})};
h.Le=function(a,b){var c=this;Of(this);var d="/users/"+encodeURIComponent(a.email),e=mf(a);e.Xa._method="DELETE";this.gc(d,e,function(a,d){!a&&d&&d.uid&&c.hb&&c.hb.uid&&c.hb.uid===d.uid&&Mf(c);B(b,a)})};h.ee=function(a,b){Of(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=mf(a);d.Xa._method="PUT";d.Xa.password=a.newPassword;this.gc(c,d,function(a){B(b,a)})};
h.de=function(a,b){Of(this);var c="/users/"+encodeURIComponent(a.oldEmail)+"/email",d=mf(a);d.Xa._method="PUT";d.Xa.email=a.newEmail;d.Xa.password=a.password;this.gc(c,d,function(a){B(b,a)})};h.Me=function(a,b){Of(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=mf(a);d.Xa._method="POST";this.gc(c,d,function(a){B(b,a)})};h.gc=function(a,b,c){Rf(this,[yf,Bf],a,b,c)};
function Pf(a,b,c,d,e){Rf(a,b,c,d,function(b,c){!b&&c&&c.token&&c.uid?Lf(a,c.token,c,d.cd,function(a,b){a?B(e,a):B(e,null,b)}):B(e,b||X("UNKNOWN_ERROR"))})}
function Rf(a,b,c,d,e){b=Ia(b,function(a){return"function"===typeof a.isAvailable&&a.isAvailable()});0===b.length?setTimeout(function(){B(e,X("TRANSPORT_UNAVAILABLE"))},0):(b=new (b.shift())(d.Ud),d=va(d.Xa),d.v="js-2.1.2",d.transport=b.sc(),d.suppress_status_codes=!0,a=uf()+"/"+a.O.tb+c,b.open(a,d,function(a,b){if(a)B(e,a);else if(b&&b.error){var c=Error(b.error.message);c.code=b.error.code;c.details=b.error.details;B(e,c)}else B(e,null,b)}))}
function If(a,b){var c=null!==a.hb||null!==b;a.hb=b;c&&a.Vd("auth_status",b);a.Ee(null!==b)}h.qe=function(a){y("auth_status"===a,'initial event must be of type "auth_status"');return[this.hb]};function Of(a){var b=a.O;if("firebaseio.com"!==b.domain&&"firebaseio-demo.com"!==b.domain&&"auth.firebase.com"===jf)throw Error("This custom Firebase server ('"+a.O.domain+"') does not support delegated login.");};function Sf(a,b){return a&&"object"===typeof a?(y(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function Tf(a,b){var c=new $e;bf(a,new S(""),function(a,e){c.dc(a,Uf(e,b))});return c}function Uf(a,b){var c=a.L().I(),c=Sf(c,b),d;if(a.M()){var e=Sf(a.za(),b);return e!==a.za()||c!==a.L().I()?new nd(e,O(c)):a}d=a;c!==a.L().I()&&(d=d.Z(new nd(c)));a.U(L,function(a,c){var e=Uf(c,b);e!==c&&(d=d.P(a,e))});return d};function wc(a,b,c){this.A=a;this.aa=b;this.yc=c}function Vf(a){return a.aa}function vc(a,b){return a.aa&&!a.yc||a.A.Da(b)}wc.prototype.j=function(){return this.A};function Wf(a,b){this.F=a;this.Ld=b}function Xf(a,b,c,d){return new Wf(new wc(b,c,d),a.Ld)}function Yf(a){return a.F.aa?a.F.j():null}Wf.prototype.u=function(){return this.Ld};function xc(a){return a.Ld.aa?a.Ld.j():null};function Zf(a,b){this.Yd=a;this.Of=b}function $f(a){this.G=a}
$f.prototype.Ya=function(a,b,c,d){var e=new yc,f;if(b.type===ag)b.source.me?c=bg(this,a,b.path,b.Ga,c,d,e):(y(b.source.df,"Unknown source."),f=b.source.Se,c=cg(this,a,b.path,b.Ga,c,d,f,e));else if(b.type===dg)b.source.me?c=eg(this,a,b.path,b.children,c,d,e):(y(b.source.df,"Unknown source."),f=b.source.Se,c=fg(this,a,b.path,b.children,c,d,f,e));else if(b.type===gg)if(b.Ne)if(f=b.path,null!=c.jc(f))c=a;else{b=new uc(c,a,d);d=a.F.j();if(f.e()||".priority"===I(f))Vf(a.u())?b=c.pa(xc(a)):(b=a.u().j(),
y(b instanceof W,"serverChildren would be complete if leaf node"),b=c.pc(b)),b=this.G.oa(d,b,e);else{f=I(f);var g=c.Ta(f,a.u());null==g&&vc(a.u(),f)&&(g=d.K(f));b=null!=g?this.G.C(d,f,g,b,e):a.F.j().Da(f)?this.G.C(d,f,M,b,e):d;b.e()&&Vf(a.u())&&(d=c.pa(xc(a)),d.M()&&(b=this.G.oa(b,d,e)))}d=Vf(a.u())||null!=c.jc(U);c=Xf(a,b,d,this.G.ya())}else c=hg(this,a,b.path,c,d,e);else if(b.type===ig)d=b.path,b=a.u(),f=b.j(),g=b.aa||d.e(),c=jg(this,new Wf(a.F,new wc(f,g,b.yc)),d,c,tc,e);else throw fb("Unknown operation type: "+
b.type);e=Jd(e.Za);d=c;b=d.F;b.aa&&(f=b.j().M()||b.j().e(),g=Yf(a),(0<e.length||!a.F.aa||f&&!b.j().ea(g)||!b.j().L().ea(g.L()))&&e.push(Fb(Yf(d))));return new Zf(c,e)};
function jg(a,b,c,d,e,f){var g=b.F;if(null!=d.jc(c))return b;var k;if(c.e())y(Vf(b.u()),"If change path is empty, we must have complete server data"),a.G.ya()?(e=xc(b),d=d.pc(e instanceof W?e:M)):d=d.pa(xc(b)),f=a.G.oa(b.F.j(),d,f);else{var l=I(c);if(".priority"==l)y(1==Qc(c),"Can't have a priority with additional path components"),f=g.j(),k=b.u().j(),d=d.$c(c,f,k),f=null!=d?a.G.Z(f,d):g.j();else{var n=T(c);vc(g,l)?(k=b.u().j(),d=d.$c(c,g.j(),k),d=null!=d?g.j().K(l).C(n,d):g.j().K(l)):d=d.Ta(l,b.u());
f=null!=d?a.G.C(g.j(),l,d,e,f):g.j()}}return Xf(b,f,g.aa||c.e(),a.G.ya())}function cg(a,b,c,d,e,f,g,k){var l=b.u();g=g?a.G:a.G.Mb();if(c.e())d=g.oa(l.j(),d,null);else if(g.ya()&&!l.yc)d=l.j().C(c,d),d=g.oa(l.j(),d,null);else{var n=I(c);if((c.e()?!l.aa||l.yc:!vc(l,I(c)))&&1<Qc(c))return b;d=l.j().K(n).C(T(c),d);d=".priority"==n?g.Z(l.j(),d):g.C(l.j(),n,d,tc,null)}l=l.aa||c.e();b=new Wf(b.F,new wc(d,l,g.ya()));return jg(a,b,c,e,new uc(e,b,f),k)}
function bg(a,b,c,d,e,f,g){var k=b.F;e=new uc(e,b,f);if(c.e())g=a.G.oa(b.F.j(),d,g),a=Xf(b,g,!0,a.G.ya());else if(f=I(c),".priority"===f)g=a.G.Z(b.F.j(),d),a=Xf(b,g,k.aa,k.yc);else{var l=T(c);c=k.j().K(f);if(!l.e()){var n=e.ef(f);d=null!=n?".priority"===Rc(l)&&n.ra(l.parent()).e()?n:n.C(l,d):M}c.ea(d)?a=b:(g=a.G.C(k.j(),f,d,e,g),a=Xf(b,g,k.aa,a.G.ya()))}return a}
function eg(a,b,c,d,e,f,g){var k=b;kg(d,function(d,n){var u=c.o(d);vc(b.F,I(u))&&(k=bg(a,k,u,n,e,f,g))});kg(d,function(d,n){var u=c.o(d);vc(b.F,I(u))||(k=bg(a,k,u,n,e,f,g))});return k}function lg(a,b){kg(b,function(b,d){a=a.C(b,d)});return a}
function fg(a,b,c,d,e,f,g,k){if(b.u().j().e()&&!Vf(b.u()))return b;var l=b;c=c.e()?d:mg(ng,c,d);var n=b.u().j();c.children.fa(function(c,d){if(n.Da(c)){var E=b.u().j().K(c),E=lg(E,d);l=cg(a,l,new S(c),E,e,f,g,k)}});c.children.fa(function(c,d){var E=!Vf(b.u())&&null==d.value;n.Da(c)||E||(E=b.u().j().K(c),E=lg(E,d),l=cg(a,l,new S(c),E,e,f,g,k))});return l}
function hg(a,b,c,d,e,f){if(null!=d.jc(c))return b;var g=new uc(d,b,e),k=e=b.F.j();if(Vf(b.u())){if(c.e())e=d.pa(xc(b)),k=a.G.oa(b.F.j(),e,f);else if(".priority"===I(c)){var l=d.Ta(I(c),b.u());null==l||e.e()||e.L().ea(l)||(k=a.G.Z(e,l))}else l=I(c),e=d.Ta(l,b.u()),null!=e&&(k=a.G.C(b.F.j(),l,e,g,f));e=!0}else b.F.aa?(k=e,e=Yf(b),e.M()||e.U(L,function(c){var e=d.Ta(c,b.u());null!=e&&(k=a.G.C(k,c,e,g,f))}),e=!0):(!c.e()&&(l=I(c),1==Qc(c)||vc(b.F,l))&&(c=d.Ta(l,b.u()),null!=c&&(k=a.G.C(e,l,c,g,f))),
e=!1);return Xf(b,k,e,a.G.ya())};function og(a){this.V=a;this.g=a.n.g}function pg(a,b,c,d){var e=[],f=[];Ha(b,function(b){"child_changed"===b.type&&a.g.jf(b.De,b.Ha)&&f.push(new C("child_moved",b.Ha,b.Ua))});qg(a,e,"child_removed",b,d,c);qg(a,e,"child_added",b,d,c);qg(a,e,"child_moved",f,d,c);qg(a,e,"child_changed",b,d,c);qg(a,e,Gb,b,d,c);return e}function qg(a,b,c,d,e,f){d=Ia(d,function(a){return a.type===c});Qa(d,q(a.Qf,a));Ha(d,function(c){var d=rg(a,c,f);Ha(e,function(e){e.wf(c.type)&&b.push(e.createEvent(d,a.V))})})}
function rg(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Fd=c.ff(b.Ua,b.Ha,a.g));return b}og.prototype.Qf=function(a,b){if(null==a.Ua||null==b.Ua)throw fb("Should only compare child_ events.");return this.g.compare(new N(a.Ua,a.Ha),new N(b.Ua,b.Ha))};function sg(a,b){this.V=a;var c=a.n,d=new bc(c.g),c=Jc(c)?new bc(c.g):c.ka?new Ac(c):new dc(c);this.sf=new $f(c);var e=b.u(),f=b.F,g=d.oa(M,e.j(),null),k=c.oa(M,f.j(),null);this.Ia=new Wf(new wc(k,f.aa,c.ya()),new wc(g,e.aa,d.ya()));this.Va=[];this.Uf=new og(a)}function tg(a){return a.V}h=sg.prototype;h.u=function(){return this.Ia.u().j()};h.bb=function(a){var b=xc(this.Ia);return b&&(Jc(this.V.n)||!a.e()&&!b.K(I(a)).e())?b.ra(a):null};h.e=function(){return 0===this.Va.length};h.Gb=function(a){this.Va.push(a)};
h.gb=function(a,b){var c=[];if(b){y(null==a,"A cancel should cancel all event registrations.");var d=this.V.path;Ha(this.Va,function(a){(a=a.Ye(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.Va.length;++f){var g=this.Va[f];if(!g.matches(a))e.push(g);else if(a.hf()){e=e.concat(this.Va.slice(f+1));break}}this.Va=e}else this.Va=[];return c};
h.Ya=function(a,b,c){a.type===dg&&null!==a.source.yb&&(y(xc(this.Ia),"We should always have a full cache before handling merges"),y(Yf(this.Ia),"Missing event cache, even though we have a server cache"));var d=this.Ia;a=this.sf.Ya(d,a,b,c);b=this.sf;c=a.Yd;y(c.F.j().Bc(b.G.g),"Event snap not indexed");y(c.u().j().Bc(b.G.g),"Server snap not indexed");y(Vf(a.Yd.u())||!Vf(d.u()),"Once a server snap is complete, it should never go back");this.Ia=a.Yd;return ug(this,a.Of,a.Yd.F.j(),null)};
function vg(a,b){var c=a.Ia.F,d=[];c.j().M()||c.j().U(L,function(a,b){d.push(new C("child_added",b,a))});c.aa&&d.push(Fb(c.j()));return ug(a,d,c.j(),b)}function ug(a,b,c,d){return pg(a.Uf,b,c,d?[d]:a.Va)};function wg(a,b){this.value=a;this.children=b||xg}var xg=new Zc(function(a,b){return a===b?0:a<b?-1:1}),ng=new wg(null);function yg(a){var b=ng;A(a,function(a,d){b=b.set(new S(d),a)});return b}h=wg.prototype;h.e=function(){return null===this.value&&this.children.e()};function zg(a,b,c){if(null!=a.value&&c(a.value))return{path:U,value:a.value};if(b.e())return null;var d=I(b);a=a.children.get(d);return null!==a?(b=zg(a,T(b),c),null!=b?{path:(new S(d)).o(b.path),value:b.value}:null):null}
function Ag(a,b){return zg(a,b,function(){return!0})}h.subtree=function(a){if(a.e())return this;var b=this.children.get(I(a));return null!==b?b.subtree(T(a)):ng};h.set=function(a,b){if(a.e())return new wg(b,this.children);var c=I(a),d=(this.children.get(c)||ng).set(T(a),b),c=this.children.La(c,d);return new wg(this.value,c)};
h.remove=function(a){if(a.e())return this.children.e()?ng:new wg(null,this.children);var b=I(a),c=this.children.get(b);return c?(a=c.remove(T(a)),b=a.e()?this.children.remove(b):this.children.La(b,a),null===this.value&&b.e()?ng:new wg(this.value,b)):this};h.get=function(a){if(a.e())return this.value;var b=this.children.get(I(a));return b?b.get(T(a)):null};
function mg(a,b,c){if(b.e())return c;var d=I(b);b=mg(a.children.get(d)||ng,T(b),c);d=b.e()?a.children.remove(d):a.children.La(d,b);return new wg(a.value,d)}function Bg(a,b){return Cg(a,U,b)}function Cg(a,b,c){var d={};a.children.fa(function(a,f){d[a]=Cg(f,b.o(a),c)});return c(b,a.value,d)}function Dg(a,b,c){return Eg(a,b,U,c)}function Eg(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=I(b);return(a=a.children.get(e))?Eg(a,T(b),c.o(e),d):null}
function Fg(a,b,c){if(!b.e()){var d=!0;a.value&&(d=c(U,a.value));!0===d&&(d=I(b),(a=a.children.get(d))&&Gg(a,T(b),U.o(d),c))}}function Gg(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=I(b);return(a=a.children.get(e))?Gg(a,T(b),c.o(e),d):ng}function kg(a,b){Hg(a,U,b)}function Hg(a,b,c){a.children.fa(function(a,e){Hg(e,b.o(a),c)});a.value&&c(b,a.value)}function Ig(a,b){a.children.fa(function(a,d){d.value&&b(a,d.value)})}
h.toString=function(){var a={};kg(this,function(b,c){a[b.toString()]=c.toString()});return r(a)};function Jg(){this.va={}}h=Jg.prototype;h.e=function(){return Nd(this.va)};h.Ya=function(a,b,c){var d=a.source.yb;if(null!==d)return d=t(this.va,d),y(null!=d,"SyncTree gave us an op for an invalid query."),d.Ya(a,b,c);var e=[];A(this.va,function(d){e=e.concat(d.Ya(a,b,c))});return e};h.Gb=function(a,b,c,d,e){var f=a.Fa(),g=t(this.va,f);if(!g){var g=c.pa(e?d:null),k=!1;g?k=!0:(g=d instanceof W?c.pc(d):M,k=!1);g=new sg(a,new Wf(new wc(g,k,!1),new wc(d,e,!1)));this.va[f]=g}g.Gb(b);return vg(g,b)};
h.gb=function(a,b,c){var d=a.Fa(),e=[],f=[],g=null!=Kg(this);if("default"===d){var k=this;A(this.va,function(a,d){f=f.concat(a.gb(b,c));a.e()&&(delete k.va[d],Jc(a.V.n)||e.push(a.V))})}else{var l=t(this.va,d);l&&(f=f.concat(l.gb(b,c)),l.e()&&(delete this.va[d],Jc(l.V.n)||e.push(l.V)))}g&&null==Kg(this)&&e.push(new R(a.k,a.path));return{rg:e,Vf:f}};function Lg(a){return Ia(Jd(a.va),function(a){return!Jc(a.V.n)})}h.bb=function(a){var b=null;A(this.va,function(c){b=b||c.bb(a)});return b};
function Mg(a,b){if(Jc(b.n))return Kg(a);var c=b.Fa();return t(a.va,c)}function Kg(a){return Md(a.va,function(a){return Jc(a.V.n)})||null};function Ng(a){this.W=a}var Og=new Ng(new wg(null));function Pg(a,b,c){if(b.e())return new Ng(new wg(c));var d=Ag(a.W,b);if(null!=d){var e=d.path,d=d.value;b=V(e,b);d=d.C(b,c);return new Ng(a.W.set(e,d))}a=mg(a.W,b,new wg(c));return new Ng(a)}function Qg(a,b,c){var d=a;ua(c,function(a,c){d=Pg(d,b.o(a),c)});return d}Ng.prototype.Gd=function(a){if(a.e())return Og;a=mg(this.W,a,ng);return new Ng(a)};function Rg(a,b){var c=Ag(a.W,b);return null!=c?a.W.get(c.path).ra(V(c.path,b)):null}
function Sg(a){var b=[],c=a.W.value;null!=c?c.M()||c.U(L,function(a,c){b.push(new N(a,c))}):a.W.children.fa(function(a,c){null!=c.value&&b.push(new N(a,c.value))});return b}function Tg(a,b){if(b.e())return a;var c=Rg(a,b);return null!=c?new Ng(new wg(c)):new Ng(a.W.subtree(b))}Ng.prototype.e=function(){return this.W.e()};Ng.prototype.apply=function(a){return Ug(U,this.W,a)};
function Ug(a,b,c){if(null!=b.value)return c.C(a,b.value);var d=null;b.children.fa(function(b,f){".priority"===b?(y(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=Ug(a.o(b),f,c)});c.ra(a).e()||null===d||(c=c.C(a.o(".priority"),d));return c};function Vg(){this.T=Og;this.wa=[];this.Ec=-1}h=Vg.prototype;
h.Gd=function(a){var b=Na(this.wa,function(b){return b.Zd===a});y(0<=b,"removeWrite called with nonexistent writeId.");var c=this.wa[b];this.wa.splice(b,1);for(var d=c.visible,e=!1,f=this.wa.length-1;d&&0<=f;){var g=this.wa[f];g.visible&&(f>=b&&Wg(g,c.path)?d=!1:c.path.contains(g.path)&&(e=!0));f--}if(d){if(e)this.T=Xg(this.wa,Yg,U),this.Ec=0<this.wa.length?this.wa[this.wa.length-1].Zd:-1;else if(c.Ga)this.T=this.T.Gd(c.path);else{var k=this;A(c.children,function(a,b){k.T=k.T.Gd(c.path.o(b))})}return c.path}return null};
h.pa=function(a,b,c,d){if(c||d){var e=Tg(this.T,a);return!d&&e.e()?b:d||null!=b||null!=Rg(e,U)?(e=Xg(this.wa,function(b){return(b.visible||d)&&(!c||!(0<=Ga(c,b.Zd)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||M,e.apply(b)):null}e=Rg(this.T,a);if(null!=e)return e;e=Tg(this.T,a);return e.e()?b:null!=b||null!=Rg(e,U)?(b=b||M,e.apply(b)):null};
h.pc=function(a,b){var c=M,d=Rg(this.T,a);if(d)d.M()||d.U(L,function(a,b){c=c.P(a,b)});else if(b){var e=Tg(this.T,a);b.U(L,function(a,b){var d=Tg(e,new S(a)).apply(b);c=c.P(a,d)});Ha(Sg(e),function(a){c=c.P(a.name,a.Y)})}else e=Tg(this.T,a),Ha(Sg(e),function(a){c=c.P(a.name,a.Y)});return c};h.$c=function(a,b,c,d){y(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.o(b);if(null!=Rg(this.T,a))return null;a=Tg(this.T,a);return a.e()?d.ra(b):a.apply(d.ra(b))};
h.Ta=function(a,b,c){a=a.o(b);var d=Rg(this.T,a);return null!=d?d:vc(c,b)?Tg(this.T,a).apply(c.j().K(b)):null};h.jc=function(a){return Rg(this.T,a)};h.ce=function(a,b,c,d,e,f){var g;a=Tg(this.T,a);g=Rg(a,U);if(null==g)if(null!=b)g=a.apply(b);else return[];g=g.Fb(f);if(g.e()||g.M())return[];b=[];a=mc(f);e=e?g.Rb(c,f):g.Pb(c,f);for(f=P(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=P(e);return b};
function Wg(a,b){return a.Ga?a.path.contains(b):!!Ld(a.children,function(c,d){return a.path.o(d).contains(b)})}function Yg(a){return a.visible}
function Xg(a,b,c){for(var d=Og,e=0;e<a.length;++e){var f=a[e];if(b(f)){var g=f.path;if(f.Ga)c.contains(g)?(g=V(c,g),d=Pg(d,g,f.Ga)):g.contains(c)&&(g=V(g,c),d=Pg(d,U,f.Ga.ra(g)));else if(f.children)if(c.contains(g))g=V(c,g),d=Qg(d,g,f.children);else{if(g.contains(c))if(g=V(g,c),g.e())d=Qg(d,U,f.children);else if(f=t(f.children,I(g)))f=f.ra(T(g)),d=Pg(d,U,f)}else throw fb("WriteRecord should have .snap or .children");}}return d}function Zg(a,b){this.Db=a;this.W=b}h=Zg.prototype;
h.pa=function(a,b,c){return this.W.pa(this.Db,a,b,c)};h.pc=function(a){return this.W.pc(this.Db,a)};h.$c=function(a,b,c){return this.W.$c(this.Db,a,b,c)};h.jc=function(a){return this.W.jc(this.Db.o(a))};h.ce=function(a,b,c,d,e){return this.W.ce(this.Db,a,b,c,d,e)};h.Ta=function(a,b){return this.W.Ta(this.Db,a,b)};h.o=function(a){return new Zg(this.Db.o(a),this.W)};function $g(a,b,c){this.type=ag;this.source=a;this.path=b;this.Ga=c}$g.prototype.Mc=function(a){return this.path.e()?new $g(this.source,U,this.Ga.K(a)):new $g(this.source,T(this.path),this.Ga)};$g.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ga.toString()+")"};function ah(a,b){this.type=gg;this.source=bh;this.path=a;this.Ne=b}ah.prototype.Mc=function(){return this.path.e()?this:new ah(T(this.path),this.Ne)};ah.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Ne+")"};function ch(a,b){this.type=ig;this.source=a;this.path=b}ch.prototype.Mc=function(){return this.path.e()?new ch(this.source,U):new ch(this.source,T(this.path))};ch.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function dh(a,b,c){this.type=dg;this.source=a;this.path=b;this.children=c}dh.prototype.Mc=function(a){if(this.path.e())return a=this.children.subtree(new S(a)),a.e()?null:a.value?new $g(this.source,U,a.value):new dh(this.source,U,a);y(I(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new dh(this.source,T(this.path),this.children)};dh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};var ag=0,dg=1,gg=2,ig=3;function eh(a,b,c,d){this.me=a;this.df=b;this.yb=c;this.Se=d;y(!d||b,"Tagged queries must be from server.")}var bh=new eh(!0,!1,null,!1),fh=new eh(!1,!0,null,!1);eh.prototype.toString=function(){return this.me?"user":this.Se?"server(queryID="+this.yb+")":"server"};function gh(a){this.na=ng;this.xb=new Vg;this.Wc={};this.bc={};this.Fc=a}function hh(a,b,c,d,e){var f=a.xb,g=e;y(d>f.Ec,"Stacking an older write on top of newer ones");m(g)||(g=!0);f.wa.push({path:b,Ga:c,Zd:d,visible:g});g&&(f.T=Pg(f.T,b,c));f.Ec=d;return e?ih(a,new $g(bh,b,c)):[]}function jh(a,b,c,d){var e=a.xb;y(d>e.Ec,"Stacking an older merge on top of newer ones");e.wa.push({path:b,children:c,Zd:d,visible:!0});e.T=Qg(e.T,b,c);e.Ec=d;c=yg(c);return ih(a,new dh(bh,b,c))}
function kh(a,b,c){c=c||!1;b=a.xb.Gd(b);return null==b?[]:ih(a,new ah(b,c))}function lh(a,b,c){c=yg(c);return ih(a,new dh(fh,b,c))}function mh(a,b,c,d){d=Od(a.Wc,"_"+d);if(null!=d){var e=nh(d);d=e.path;e=e.yb;b=V(d,b);c=new $g(new eh(!1,!0,e,!0),b,c);return oh(a,d,c)}return[]}function ph(a,b,c,d){if(d=Od(a.Wc,"_"+d)){var e=nh(d);d=e.path;e=e.yb;b=V(d,b);c=yg(c);c=new dh(new eh(!1,!0,e,!0),b,c);return oh(a,d,c)}return[]}
gh.prototype.Gb=function(a,b){var c=a.path,d=null,e=!1;Fg(this.na,c,function(a,b){var f=V(a,c);d=b.bb(f);e=e||null!=Kg(b);return!d});var f=this.na.get(c);f?(e=e||null!=Kg(f),d=d||f.bb(U)):(f=new Jg,this.na=this.na.set(c,f));var g;null!=d?g=!0:(g=!1,d=M,Ig(this.na.subtree(c),function(a,b){var c=b.bb(U);c&&(d=d.P(a,c))}));var k=null!=Mg(f,a);if(!k&&!Jc(a.n)){var l=qh(a);y(!(l in this.bc),"View does not exist, but we have a tag");var n=rh++;this.bc[l]=n;this.Wc["_"+n]=l}g=f.Gb(a,b,new Zg(c,this.xb),
d,g);k||e||(f=Mg(f,a),g=g.concat(sh(this,a,f)));return g};
gh.prototype.gb=function(a,b,c){var d=a.path,e=this.na.get(d),f=[];if(e&&("default"===a.Fa()||null!=Mg(e,a))){f=e.gb(a,b,c);e.e()&&(this.na=this.na.remove(d));e=f.rg;f=f.Vf;b=-1!==Na(e,function(a){return Jc(a.n)});var g=Dg(this.na,d,function(a,b){return null!=Kg(b)});if(b&&!g&&(d=this.na.subtree(d),!d.e()))for(var d=th(d),k=0;k<d.length;++k){var l=d[k],n=l.V,l=uh(this,l);this.Fc.Pe(n,vh(this,n),l.md,l.H)}if(!g&&0<e.length&&!c)if(b)this.Fc.Qd(a,null);else{var u=this;Ha(e,function(a){a.Fa();var b=u.bc[qh(a)];
u.Fc.Qd(a,b)})}wh(this,e)}return f};gh.prototype.pa=function(a,b){var c=this.xb,d=Dg(this.na,a,function(b,c){var d=V(b,a);if(d=c.bb(d))return d});return c.pa(a,d,b,!0)};function th(a){return Bg(a,function(a,c,d){if(c&&null!=Kg(c))return[Kg(c)];var e=[];c&&(e=Lg(c));A(d,function(a){e=e.concat(a)});return e})}function wh(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!Jc(d.n)){var d=qh(d),e=a.bc[d];delete a.bc[d];delete a.Wc["_"+e]}}}
function sh(a,b,c){var d=b.path,e=vh(a,b);c=uh(a,c);b=a.Fc.Pe(b,e,c.md,c.H);d=a.na.subtree(d);if(e)y(null==Kg(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=Bg(d,function(a,b,c){if(!a.e()&&b&&null!=Kg(b))return[tg(Kg(b))];var d=[];b&&(d=d.concat(Ja(Lg(b),function(a){return a.V})));A(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Fc.Qd(c,vh(a,c));return b}
function uh(a,b){var c=b.V,d=vh(a,c);return{md:function(){return(b.u()||M).hash()},H:function(b,f){if("ok"===b){if(f&&"object"===typeof f&&s(f,"w")){var g=t(f,"w");ea(g)&&0<=Ga(g,"no_index")&&z("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}if(d){var k=c.path;if(g=Od(a.Wc,"_"+d))var l=nh(g),g=l.path,l=l.yb,k=V(g,k),k=new ch(new eh(!1,!0,l,!0),k),g=oh(a,g,k);else g=[]}else g=ih(a,new ch(fh,
c.path));return g}g="Unknown Error";"too_big"===b?g="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?g="Client doesn't have permission to access the desired data.":"unavailable"==b&&(g="The service is unavailable");g=Error(b+": "+g);g.code=b.toUpperCase();return a.gb(c,null,g)}}}function qh(a){return a.path.toString()+"$"+a.Fa()}
function nh(a){var b=a.indexOf("$");y(-1!==b&&b<a.length-1,"Bad queryKey.");return{yb:a.substr(b+1),path:new S(a.substr(0,b))}}function vh(a,b){var c=qh(b);return t(a.bc,c)}var rh=1;function oh(a,b,c){var d=a.na.get(b);y(d,"Missing sync point for query tag that we're tracking");return d.Ya(c,new Zg(b,a.xb),null)}function ih(a,b){return xh(a,b,a.na,null,new Zg(U,a.xb))}
function xh(a,b,c,d,e){if(b.path.e())return yh(a,b,c,d,e);var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[],k=I(b.path),l=b.Mc(k);if((c=c.children.get(k))&&l)var n=d?d.K(k):null,k=e.o(k),g=g.concat(xh(a,l,c,n,k));f&&(g=g.concat(f.Ya(b,e,d)));return g}function yh(a,b,c,d,e){var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[];c.children.fa(function(c,f){var n=d?d.K(c):null,u=e.o(c),x=b.Mc(c);x&&(g=g.concat(yh(a,x,f,n,u)))});f&&(g=g.concat(f.Ya(b,e,d)));return g};function zh(a){this.O=a;this.Ra=Xd(a);this.$=new df;this.vd=1;this.S=new Je(this.O,q(this.yd,this),q(this.wd,this),q(this.He,this));this.zg=Yd(a,q(function(){return new Ud(this.Ra,this.S)},this));this.lc=new Tc;this.se=new cf;var b=this;this.qd=new gh({Pe:function(a,d,e,f){d=[];e=b.se.j(a.path);e.e()||(d=ih(b.qd,new $g(fh,a.path,e)),setTimeout(function(){f("ok")},0));return d},Qd:ba});Ah(this,"connected",!1);this.ga=new $e;this.Q=new Ff(a,q(this.S.Q,this.S),q(this.S.Ue,this.S),q(this.Ee,this));this.gd=
0;this.te=null;this.N=new gh({Pe:function(a,d,e,f){Ne(b.S,a,e,d,function(d,e){var l=f(d,e);hf(b.$,a.path,l)});return[]},Qd:function(a,d){var e=b.S,f=a.path.toString(),g=a.Fa();e.f("Unlisten called for "+f+" "+g);if(Pe(e,f,g)&&e.ja){var k=Ic(a.n);e.f("Unlisten on "+f+" for "+g);f={p:f};d&&(f.q=k,f.t=d);e.Ca("n",f)}}})}h=zh.prototype;h.toString=function(){return(this.O.Ab?"https://":"http://")+this.O.host};h.name=function(){return this.O.tb};
function Bh(a){a=a.se.j(new S(".info/serverTimeOffset")).I()||0;return(new Date).getTime()+a}function Ch(a){a=a={timestamp:Bh(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}h.yd=function(a,b,c,d){this.gd++;var e=new S(a);b=this.te?this.te(a,b):b;a=[];d?c?(b=td(b,function(a){return O(a)}),a=ph(this.N,e,b,d)):(b=O(b),a=mh(this.N,e,b,d)):c?(d=td(b,function(a){return O(a)}),a=lh(this.N,e,d)):(d=O(b),a=ih(this.N,new $g(fh,e,d)));d=e;0<a.length&&(d=Dh(this,e));hf(this.$,d,a)};
h.wd=function(a){Ah(this,"connected",a);!1===a&&Eh(this)};h.He=function(a){var b=this;zb(a,function(a,d){Ah(b,d,a)})};h.Ee=function(a){Ah(this,"authenticated",a)};function Ah(a,b,c){b=new S("/.info/"+b);c=O(c);var d=a.se;d.Jd=d.Jd.C(b,c);c=ih(a.qd,new $g(fh,b,c));hf(a.$,b,c)}
h.Bb=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,Hg:c});var e=Ch(this);b=O(b,c);var e=Uf(b,e),f=this.vd++,e=hh(this.N,a,e,f,!0);ef(this.$,e);var g=this;this.S.put(a.toString(),b.I(!0),function(b,c){var e="ok"===b;e||z("set at "+a+" failed: "+b);e=kh(g.N,f,!e);hf(g.$,a,e);Fh(d,b,c)});e=Gh(this,a);Dh(this,e);hf(this.$,e,[])};
h.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=Ch(this),f={};A(b,function(a,b){d=!1;var c=O(a);f[b]=Uf(c,e)});if(d)hb("update() called with empty data.  Don't do anything."),Fh(c,"ok");else{var g=this.vd++,k=jh(this.N,a,f,g);ef(this.$,k);var l=this;Ve(this.S,a.toString(),b,function(b,d){y("ok"===b||"permission_denied"===b,"merge at "+a+" failed.");var e="ok"===b;e||z("update at "+a+" failed: "+b);var e=kh(l.N,g,!e),f=a;0<e.length&&(f=Dh(l,a));hf(l.$,f,e);Fh(c,b,d)});
b=Gh(this,a);Dh(this,b);hf(this.$,a,[])}};function Eh(a){a.f("onDisconnectEvents");var b=Ch(a),c=[];bf(Tf(a.ga,b),U,function(b,e){c=c.concat(ih(a.N,new $g(fh,b,e)));var f=Gh(a,b);Dh(a,f)});a.ga=new $e;hf(a.$,U,c)}h.Fe=function(a,b){var c=this;this.S.Fe(a.toString(),function(d,e){"ok"===d&&af(c.ga,a);Fh(b,d,e)})};function Hh(a,b,c,d){var e=O(c);Re(a.S,b.toString(),e.I(!0),function(c,g){"ok"===c&&a.ga.dc(b,e);Fh(d,c,g)})}
function Ih(a,b,c,d,e){var f=O(c,d);Re(a.S,b.toString(),f.I(!0),function(c,d){"ok"===c&&a.ga.dc(b,f);Fh(e,c,d)})}function Jh(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(hb("onDisconnect().update() called with empty data.  Don't do anything."),Fh(d,"ok")):Te(a.S,b.toString(),c,function(e,f){if("ok"===e)for(var l in c){var n=O(c[l]);a.ga.dc(b.o(l),n)}Fh(d,e,f)})}function Oc(a,b,c){c=".info"===I(b.path)?a.qd.Gb(b,c):a.N.Gb(b,c);Pc(a.$,b.path,c)}h.pb=function(){this.S.pb()};h.hc=function(){this.S.hc()};
h.Qe=function(a){if("undefined"!==typeof console){a?(this.Pd||(this.Pd=new Td(this.Ra)),a=this.Pd.get()):a=this.Ra.get();var b=Ka(Kd(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};h.Re=function(a){Sd(this.Ra,a);this.zg.zf[a]=!0};h.f=function(a){hb("r:"+this.S.id+":",arguments)};function Fh(a,b,c){a&&Cb(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function Kh(a,b,c,d,e){function f(){}a.f("transaction on "+b);var g=new R(a,b);g.vb("value",f);c={path:b,update:c,H:d,status:null,qf:eb(),Ve:e,xf:0,Xd:function(){g.Zb("value",f)},$d:null,xa:null,dd:null,ed:null,fd:null};d=a.N.pa(b,void 0)||M;c.dd=d;d=c.update(d.I());if(m(d)){Sb("transaction failed: Data returned ",d);c.status=1;e=Uc(a.lc,b);var k=e.za()||[];k.push(c);Vc(e,k);"object"===typeof d&&null!==d&&s(d,".priority")?(k=t(d,".priority"),y(Qb(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.N.pa(b)||M).L().I();e=Ch(a);d=O(d,k);e=Uf(d,e);c.ed=d;c.fd=e;c.xa=a.vd++;c=hh(a.N,b,e,c.xa,c.Ve);hf(a.$,b,c);Lh(a)}else c.Xd(),c.ed=null,c.fd=null,c.H&&(a=new D(c.dd,new R(a,c.path),L),c.H(null,!1,a))}function Lh(a,b){var c=b||a.lc;b||Mh(a,c);if(null!==c.za()){var d=Nh(a,c);y(0<d.length,"Sending zero length transaction queue");La(d,function(a){return 1===a.status})&&Oh(a,c.path(),d)}else c.ld()&&c.U(function(b){Lh(a,b)})}
function Oh(a,b,c){for(var d=Ja(c,function(a){return a.xa}),e=a.N.pa(b,d)||M,d=e,e=e.hash(),f=0;f<c.length;f++){var g=c[f];y(1===g.status,"tryToSendTransactionQueue_: items in queue should all be run.");g.status=2;g.xf++;var k=V(b,g.path),d=d.C(k,g.ed)}d=d.I(!0);a.S.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(kh(a.N,c[f].xa));if(c[f].H){var g=c[f].fd,k=new R(a,c[f].path);d.push(q(c[f].H,
null,null,!0,new D(g,k,L)))}c[f].Xd()}Mh(a,Uc(a.lc,b));Lh(a);hf(a.$,b,e);for(f=0;f<d.length;f++)Cb(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(z("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].$d=d;Dh(a,b)}},e)}function Dh(a,b){var c=Ph(a,b),d=c.path(),c=Nh(a,c);Qh(a,c,d);return d}
function Qh(a,b,c){if(0!==b.length){for(var d=[],e=[],f=Ja(b,function(a){return a.xa}),g=0;g<b.length;g++){var k=b[g],l=V(c,k.path),n=!1,u;y(null!==l,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)n=!0,u=k.$d,e=e.concat(kh(a.N,k.xa,!0));else if(1===k.status)if(25<=k.xf)n=!0,u="maxretry",e=e.concat(kh(a.N,k.xa,!0));else{var x=a.N.pa(k.path,f)||M;k.dd=x;var E=b[g].update(x.I());m(E)?(Sb("transaction failed: Data returned ",E),l=O(E),"object"===typeof E&&null!=E&&s(E,
".priority")||(l=l.Z(x.L())),x=k.xa,E=Ch(a),E=Uf(l,E),k.ed=l,k.fd=E,k.xa=a.vd++,Oa(f,x),e=e.concat(hh(a.N,k.path,E,k.xa,k.Ve)),e=e.concat(kh(a.N,x,!0))):(n=!0,u="nodata",e=e.concat(kh(a.N,k.xa,!0)))}hf(a.$,c,e);e=[];n&&(b[g].status=3,setTimeout(b[g].Xd,Math.floor(0)),b[g].H&&("nodata"===u?(k=new R(a,b[g].path),d.push(q(b[g].H,null,null,!1,new D(b[g].dd,k,L)))):d.push(q(b[g].H,null,Error(u),!1,null))))}Mh(a,a.lc);for(g=0;g<d.length;g++)Cb(d[g]);Lh(a)}}
function Ph(a,b){for(var c,d=a.lc;null!==(c=I(b))&&null===d.za();)d=Uc(d,c),b=T(b);return d}function Nh(a,b){var c=[];Rh(a,b,c);c.sort(function(a,b){return a.qf-b.qf});return c}function Rh(a,b,c){var d=b.za();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.U(function(b){Rh(a,b,c)})}function Mh(a,b){var c=b.za();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;Vc(b,0<c.length?c:null)}b.U(function(b){Mh(a,b)})}
function Gh(a,b){var c=Ph(a,b).path(),d=Uc(a.lc,b);Yc(d,function(b){Sh(a,b)});Sh(a,d);Xc(d,function(b){Sh(a,b)});return c}
function Sh(a,b){var c=b.za();if(null!==c){for(var d=[],e=[],f=-1,g=0;g<c.length;g++)4!==c[g].status&&(2===c[g].status?(y(f===g-1,"All SENT items should be at beginning of queue."),f=g,c[g].status=4,c[g].$d="set"):(y(1===c[g].status,"Unexpected transaction status in abort"),c[g].Xd(),e=e.concat(kh(a.N,c[g].xa,!0)),c[g].H&&d.push(q(c[g].H,null,Error("set"),!1,null))));-1===f?Vc(b,null):c.length=f+1;hf(a.$,b.path(),e);for(g=0;g<d.length;g++)Cb(d[g])}};function Th(){this.ec={}}ca(Th);Th.prototype.pb=function(){for(var a in this.ec)this.ec[a].pb()};Th.prototype.interrupt=Th.prototype.pb;Th.prototype.hc=function(){for(var a in this.ec)this.ec[a].hc()};Th.prototype.resume=Th.prototype.hc;function Uh(a){var b=this;this.rc=a;this.Sd="*";xf()?this.Hc=this.od=of():(this.Hc=window.opener,this.od=window);if(!b.Hc)throw"Unable to find relay frame";pf(this.od,"message",q(this.$b,this));pf(this.od,"message",q(this.nf,this));try{Vh(this,{a:"ready"})}catch(c){pf(this.Hc,"load",function(){Vh(b,{a:"ready"})})}pf(window,"unload",q(this.jg,this))}function Vh(a,b){b=r(b);xf()?a.Hc.doPost(b,a.Sd):a.Hc.postMessage(b,a.Sd)}
Uh.prototype.$b=function(a){var b=this,c;try{c=ta(a.data)}catch(d){}c&&"request"===c.a&&(qf(window,"message",this.$b),this.Sd=a.origin,this.rc&&setTimeout(function(){b.rc(b.Sd,c.d,function(a,c){b.Mf=!c;b.rc=void 0;Vh(b,{a:"response",d:a,forceKeepWindowOpen:c})})},0))};Uh.prototype.jg=function(){try{qf(this.od,"message",this.nf)}catch(a){}this.rc&&(Vh(this,{a:"error",d:"unknown closed window"}),this.rc=void 0);try{window.close()}catch(b){}};Uh.prototype.nf=function(a){if(this.Mf&&"die"===a.data)try{window.close()}catch(b){}};var Y={Xf:function(){je=ae=!0}};Y.forceLongPolling=Y.Xf;Y.Yf=function(){ke=!0};Y.forceWebSockets=Y.Yf;Y.wg=function(a,b){a.k.S.Oe=b};Y.setSecurityDebugCallback=Y.wg;Y.Qe=function(a,b){a.k.Qe(b)};Y.stats=Y.Qe;Y.Re=function(a,b){a.k.Re(b)};Y.statsIncrementCounter=Y.Re;Y.gd=function(a){return a.k.gd};Y.dataUpdateCount=Y.gd;Y.ag=function(a,b){a.k.te=b};Y.interceptServerData=Y.ag;Y.gg=function(a){new Uh(a)};Y.onPopupOpen=Y.gg;Y.ug=function(a){jf=a};Y.setAuthenticationServer=Y.ug;function Z(a,b){this.Rc=a;this.Ea=b}Z.prototype.cancel=function(a){F("Firebase.onDisconnect().cancel",0,1,arguments.length);H("Firebase.onDisconnect().cancel",1,a,!0);this.Rc.Fe(this.Ea,a||null)};Z.prototype.cancel=Z.prototype.cancel;Z.prototype.remove=function(a){F("Firebase.onDisconnect().remove",0,1,arguments.length);Zb("Firebase.onDisconnect().remove",this.Ea);H("Firebase.onDisconnect().remove",1,a,!0);Hh(this.Rc,this.Ea,null,a)};Z.prototype.remove=Z.prototype.remove;
Z.prototype.set=function(a,b){F("Firebase.onDisconnect().set",1,2,arguments.length);Zb("Firebase.onDisconnect().set",this.Ea);Rb("Firebase.onDisconnect().set",a,!1);H("Firebase.onDisconnect().set",2,b,!0);Hh(this.Rc,this.Ea,a,b)};Z.prototype.set=Z.prototype.set;
Z.prototype.Bb=function(a,b,c){F("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);Zb("Firebase.onDisconnect().setWithPriority",this.Ea);Rb("Firebase.onDisconnect().setWithPriority",a,!1);Vb("Firebase.onDisconnect().setWithPriority",2,b);H("Firebase.onDisconnect().setWithPriority",3,c,!0);Ih(this.Rc,this.Ea,a,b,c)};Z.prototype.setWithPriority=Z.prototype.Bb;
Z.prototype.update=function(a,b){F("Firebase.onDisconnect().update",1,2,arguments.length);Zb("Firebase.onDisconnect().update",this.Ea);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.onDisconnect().update",a);H("Firebase.onDisconnect().update",2,b,!0);Jh(this.Rc,
this.Ea,a,b)};Z.prototype.update=Z.prototype.update;var $={};$.nc=Je;$.DataConnection=$.nc;Je.prototype.yg=function(a,b){this.Ca("q",{p:a},b)};$.nc.prototype.simpleListen=$.nc.prototype.yg;Je.prototype.Sf=function(a,b){this.Ca("echo",{d:a},b)};$.nc.prototype.echo=$.nc.prototype.Sf;Je.prototype.interrupt=Je.prototype.pb;$.Df=ue;$.RealTimeConnection=$.Df;ue.prototype.sendRequest=ue.prototype.Ca;ue.prototype.close=ue.prototype.close;
$.$f=function(a){var b=Je.prototype.put;Je.prototype.put=function(c,d,e,f){m(f)&&(f=a());b.call(this,c,d,e,f)};return function(){Je.prototype.put=b}};$.hijackHash=$.$f;$.Cf=Aa;$.ConnectionTarget=$.Cf;$.Fa=function(a){return a.Fa()};$.queryIdentifier=$.Fa;$.bg=function(a){return a.k.S.Aa};$.listens=$.bg;var Wh=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);y(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);y(20===c.length,"NextPushId: Length should be 20.");
return c}}();function R(a,b){var c,d,e;if(a instanceof zh)c=a,d=b;else{F("new Firebase",1,2,arguments.length);d=rb(arguments[0]);c=d.Ag;"firebase"===d.domain&&qb(d.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");c||qb("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d.Ab||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&z("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
c=new Aa(d.host,d.Ab,c,"ws"===d.scheme||"wss"===d.scheme);d=new S(d.Pc);e=d.toString();var f;!(f=!p(c.host)||0===c.host.length||!Pb(c.tb))&&(f=0!==e.length)&&(e&&(e=e.replace(/^\/*\.info(\/|$)/,"/")),f=!(p(e)&&0!==e.length&&!Ob.test(e)));if(f)throw Error(G("new Firebase",1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');if(b)if(b instanceof Th)e=b;else if(p(b))e=Th.Nb(),c.Dd=b;else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()");
else e=Th.Nb();f=c.toString();var g=t(e.ec,f);g||(g=new zh(c),e.ec[f]=g);c=g}Q.call(this,c,d,Fc,!1)}ma(R,Q);var Xh=R,Yh=["Firebase"],Zh=aa;Yh[0]in Zh||!Zh.execScript||Zh.execScript("var "+Yh[0]);for(var $h;Yh.length&&($h=Yh.shift());)!Yh.length&&m(Xh)?Zh[$h]=Xh:Zh=Zh[$h]?Zh[$h]:Zh[$h]={};R.prototype.name=function(){z("Firebase.name() being deprecated. Please use Firebase.key() instead.");F("Firebase.name",0,0,arguments.length);return this.key()};R.prototype.name=R.prototype.name;
R.prototype.key=function(){F("Firebase.key",0,0,arguments.length);return this.path.e()?null:Rc(this.path)};R.prototype.key=R.prototype.key;R.prototype.o=function(a){F("Firebase.child",1,1,arguments.length);if(ga(a))a=String(a);else if(!(a instanceof S))if(null===I(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));Yb("Firebase.child",b)}else Yb("Firebase.child",a);return new R(this.k,this.path.o(a))};R.prototype.child=R.prototype.o;
R.prototype.parent=function(){F("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new R(this.k,a)};R.prototype.parent=R.prototype.parent;R.prototype.root=function(){F("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.parent();)a=a.parent();return a};R.prototype.root=R.prototype.root;
R.prototype.toString=function(){F("Firebase.toString",0,0,arguments.length);var a;if(null===this.parent())a=this.k.toString();else{a=this.parent().toString()+"/";var b=this.key();a+=encodeURIComponent(String(b))}return a};R.prototype.toString=R.prototype.toString;R.prototype.set=function(a,b){F("Firebase.set",1,2,arguments.length);Zb("Firebase.set",this.path);Rb("Firebase.set",a,!1);H("Firebase.set",2,b,!0);this.k.Bb(this.path,a,null,b||null)};R.prototype.set=R.prototype.set;
R.prototype.update=function(a,b){F("Firebase.update",1,2,arguments.length);Zb("Firebase.update",this.path);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.update",a);H("Firebase.update",2,b,!0);if(s(a,".priority"))throw Error("update() does not currently support updating .priority.");
this.k.update(this.path,a,b||null)};R.prototype.update=R.prototype.update;R.prototype.Bb=function(a,b,c){F("Firebase.setWithPriority",2,3,arguments.length);Zb("Firebase.setWithPriority",this.path);Rb("Firebase.setWithPriority",a,!1);Vb("Firebase.setWithPriority",2,b);H("Firebase.setWithPriority",3,c,!0);if(".length"===this.key()||".keys"===this.key())throw"Firebase.setWithPriority failed: "+this.key()+" is a read-only object.";this.k.Bb(this.path,a,b,c||null)};R.prototype.setWithPriority=R.prototype.Bb;
R.prototype.remove=function(a){F("Firebase.remove",0,1,arguments.length);Zb("Firebase.remove",this.path);H("Firebase.remove",1,a,!0);this.set(null,a)};R.prototype.remove=R.prototype.remove;
R.prototype.transaction=function(a,b,c){F("Firebase.transaction",1,3,arguments.length);Zb("Firebase.transaction",this.path);H("Firebase.transaction",1,a,!1);H("Firebase.transaction",2,b,!0);if(m(c)&&"boolean"!=typeof c)throw Error(G("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.key()||".keys"===this.key())throw"Firebase.transaction failed: "+this.key()+" is a read-only object.";"undefined"===typeof c&&(c=!0);Kh(this.k,this.path,a,b||null,c)};R.prototype.transaction=R.prototype.transaction;
R.prototype.vg=function(a,b){F("Firebase.setPriority",1,2,arguments.length);Zb("Firebase.setPriority",this.path);Vb("Firebase.setPriority",1,a);H("Firebase.setPriority",2,b,!0);this.k.Bb(this.path.o(".priority"),a,null,b)};R.prototype.setPriority=R.prototype.vg;R.prototype.push=function(a,b){F("Firebase.push",0,2,arguments.length);Zb("Firebase.push",this.path);Rb("Firebase.push",a,!0);H("Firebase.push",2,b,!0);var c=Bh(this.k),c=Wh(c),c=this.o(c);"undefined"!==typeof a&&null!==a&&c.set(a,b);return c};
R.prototype.push=R.prototype.push;R.prototype.fb=function(){Zb("Firebase.onDisconnect",this.path);return new Z(this.k,this.path)};R.prototype.onDisconnect=R.prototype.fb;R.prototype.Q=function(a,b,c){z("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");F("Firebase.auth",1,3,arguments.length);$b("Firebase.auth",a);H("Firebase.auth",2,b,!0);H("Firebase.auth",3,b,!0);Lf(this.k.Q,a,{},{remember:"none"},b,c)};R.prototype.auth=R.prototype.Q;
R.prototype.Ue=function(a){F("Firebase.unauth",0,1,arguments.length);H("Firebase.unauth",1,a,!0);Mf(this.k.Q,a)};R.prototype.unauth=R.prototype.Ue;R.prototype.ne=function(){F("Firebase.getAuth",0,0,arguments.length);return this.k.Q.ne()};R.prototype.getAuth=R.prototype.ne;R.prototype.fg=function(a,b){F("Firebase.onAuth",1,2,arguments.length);H("Firebase.onAuth",1,a,!1);Mb("Firebase.onAuth",2,b);this.k.Q.vb("auth_status",a,b)};R.prototype.onAuth=R.prototype.fg;
R.prototype.eg=function(a,b){F("Firebase.offAuth",1,2,arguments.length);H("Firebase.offAuth",1,a,!1);Mb("Firebase.offAuth",2,b);this.k.Q.Zb("auth_status",a,b)};R.prototype.offAuth=R.prototype.eg;R.prototype.Hf=function(a,b,c){F("Firebase.authWithCustomToken",2,3,arguments.length);$b("Firebase.authWithCustomToken",a);H("Firebase.authWithCustomToken",2,b,!1);J("Firebase.authWithCustomToken",3,c,!0);Lf(this.k.Q,a,{},c||{},b)};R.prototype.authWithCustomToken=R.prototype.Hf;
R.prototype.If=function(a,b,c){F("Firebase.authWithOAuthPopup",2,3,arguments.length);ac("Firebase.authWithOAuthPopup",1,a);H("Firebase.authWithOAuthPopup",2,b,!1);J("Firebase.authWithOAuthPopup",3,c,!0);Qf(this.k.Q,a,c,b)};R.prototype.authWithOAuthPopup=R.prototype.If;
R.prototype.Jf=function(a,b,c){F("Firebase.authWithOAuthRedirect",2,3,arguments.length);ac("Firebase.authWithOAuthRedirect",1,a);H("Firebase.authWithOAuthRedirect",2,b,!1);J("Firebase.authWithOAuthRedirect",3,c,!0);var d=this.k.Q;Of(d);var e=[Ef],f=mf(c);"anonymous"===a||"firebase"===a?B(b,X("TRANSPORT_UNAVAILABLE")):(v.set("redirect_client_options",f.cd),Pf(d,e,"/auth/"+a,f,b))};R.prototype.authWithOAuthRedirect=R.prototype.Jf;
R.prototype.Kf=function(a,b,c,d){F("Firebase.authWithOAuthToken",3,4,arguments.length);ac("Firebase.authWithOAuthToken",1,a);H("Firebase.authWithOAuthToken",3,c,!1);J("Firebase.authWithOAuthToken",4,d,!0);p(b)?(ac("Firebase.authWithOAuthToken",2,b),Nf(this.k.Q,a+"/token",{access_token:b},d,c)):(J("Firebase.authWithOAuthToken",2,b,!1),Nf(this.k.Q,a+"/token",b,d,c))};R.prototype.authWithOAuthToken=R.prototype.Kf;
R.prototype.Gf=function(a,b){F("Firebase.authAnonymously",1,2,arguments.length);H("Firebase.authAnonymously",1,a,!1);J("Firebase.authAnonymously",2,b,!0);Nf(this.k.Q,"anonymous",{},b,a)};R.prototype.authAnonymously=R.prototype.Gf;
R.prototype.Lf=function(a,b,c){F("Firebase.authWithPassword",2,3,arguments.length);J("Firebase.authWithPassword",1,a,!1);K("Firebase.authWithPassword",a,"email");K("Firebase.authWithPassword",a,"password");H("Firebase.authAnonymously",2,b,!1);J("Firebase.authAnonymously",3,c,!0);Nf(this.k.Q,"password",a,c,b)};R.prototype.authWithPassword=R.prototype.Lf;
R.prototype.je=function(a,b){F("Firebase.createUser",2,2,arguments.length);J("Firebase.createUser",1,a,!1);K("Firebase.createUser",a,"email");K("Firebase.createUser",a,"password");H("Firebase.createUser",2,b,!1);this.k.Q.je(a,b)};R.prototype.createUser=R.prototype.je;R.prototype.Le=function(a,b){F("Firebase.removeUser",2,2,arguments.length);J("Firebase.removeUser",1,a,!1);K("Firebase.removeUser",a,"email");K("Firebase.removeUser",a,"password");H("Firebase.removeUser",2,b,!1);this.k.Q.Le(a,b)};
R.prototype.removeUser=R.prototype.Le;R.prototype.ee=function(a,b){F("Firebase.changePassword",2,2,arguments.length);J("Firebase.changePassword",1,a,!1);K("Firebase.changePassword",a,"email");K("Firebase.changePassword",a,"oldPassword");K("Firebase.changePassword",a,"newPassword");H("Firebase.changePassword",2,b,!1);this.k.Q.ee(a,b)};R.prototype.changePassword=R.prototype.ee;
R.prototype.de=function(a,b){F("Firebase.changeEmail",2,2,arguments.length);J("Firebase.changeEmail",1,a,!1);K("Firebase.changeEmail",a,"oldEmail");K("Firebase.changeEmail",a,"newEmail");K("Firebase.changeEmail",a,"password");H("Firebase.changeEmail",2,b,!1);this.k.Q.de(a,b)};R.prototype.changeEmail=R.prototype.de;
R.prototype.Me=function(a,b){F("Firebase.resetPassword",2,2,arguments.length);J("Firebase.resetPassword",1,a,!1);K("Firebase.resetPassword",a,"email");H("Firebase.resetPassword",2,b,!1);this.k.Q.Me(a,b)};R.prototype.resetPassword=R.prototype.Me;R.goOffline=function(){F("Firebase.goOffline",0,0,arguments.length);Th.Nb().pb()};R.goOnline=function(){F("Firebase.goOnline",0,0,arguments.length);Th.Nb().hc()};
function nb(a,b){y(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?lb=q(console.log,console):"object"===typeof console.log&&(lb=function(a){console.log(a)})),b&&v.set("logging_enabled",!0)):a?lb=a:(lb=null,v.remove("logging_enabled"))}R.enableLogging=nb;R.ServerValue={TIMESTAMP:{".sv":"timestamp"}};R.SDK_VERSION="2.1.2";R.INTERNAL=Y;R.Context=Th;R.TEST_ACCESS=$;})();
module.exports = Firebase;

},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/index.js":[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys) {
  var index = 0;

  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  return path.replace(PATH_REGEXP, replace);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

},{"isarray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/node_modules/isarray/index.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/luke.hedger/dev/Experiments/040715/source/js/app-debug.coffee":[function(require,module,exports){
var dat, gui, options, page;

dat = require("dat-gui");

page = require("./../../vendor/page/page.js");

gui = window._gui = new dat.GUI();

options = {
  "debug": false,
  "index": function() {
    return page("/");
  },
  "test": function() {
    return page("/test");
  }
};

module.exports = function() {
  var debug, folder;
  debug = gui.add(options, "debug");
  folder = gui.addFolder("navigation");
  folder.add(options, "index").name("/index");
  folder.add(options, "test").name("/test");
  return folder.open();
};



},{"./../../vendor/page/page.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js","dat-gui":"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/index.js"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/config.coffee":[function(require,module,exports){
module.exports = {
  firebase: "aliceluke"
};



},{}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-module.coffee":[function(require,module,exports){
var Ractive;

Ractive = require("./../../../vendor/ractive/ractive.js");

module.exports = Ractive.extend({
  isolated: true
});



},{"./../../../vendor/ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/index.coffee":[function(require,module,exports){

/*
	THIS FILE IS GENERATED AUTOMATICALLY AND IT WILL
	BE REPLACED IF A NEW MODULE IS ADDED OR DELETED.
 */
var Ractive, register;

Ractive = require("./../../../vendor/ractive/ractive.js");

register = function() {
  Ractive.components["ui-nav"] = require("./nav");
  Ractive.components["ui-test"] = require("./test");
  return true;
};

module.exports = register();



},{"./../../../vendor/ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js","./nav":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/nav.coffee","./test":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/test.coffee"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/nav.coffee":[function(require,module,exports){

/*
	@module:   nav
	@author:   Luke Hedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/nav.styl
	@html:     ./source/template/module/nav.html
 */
var Module, page;

Module = require("./abstract-module");

page = require("./../../../vendor/page/page.js");

module.exports = Module.extend({
  template: require("module/nav.html"),
  oninit: function() {
    this.on("toIndex", function() {
      return page("/");
    });
    return this.on("toTest", function() {
      return page("/test");
    });
  }
});



},{"./../../../vendor/page/page.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js","./abstract-module":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-module.coffee","module/nav.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/nav.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/test.coffee":[function(require,module,exports){

/*
	@module:   test
	@author:   Luke Hedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/test.styl
	@html:     ./source/template/module/test.html
 */
var Module;

Module = require("./abstract-module");

module.exports = Module.extend({
  template: require("module/test.html"),
  data: {
    clicked: false
  },
  oninit: function() {
    console.log("test :)");
    return this.on("itemTap", (function(_this) {
      return function(e) {
        return _this.toggle("clicked");
      };
    })(this));
  }
});



},{"./abstract-module":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-module.coffee","module/test.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/test.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/view/main-view.coffee":[function(require,module,exports){
var Firebase, Ractive, config, page;

Ractive = require("./../../../vendor/ractive/ractive.js");

Firebase = require("firebase");

page = require("./../../../vendor/page/page.js");

config = require("../config");

module.exports = Ractive.extend({
  el: document.body,
  append: true,
  template: require("main-view.html"),
  data: {
    view: "map",
    loggedin: false,
    guests: null
  },
  oninit: function() {
    console.log("[main-view] init");
    this.getData();
    return this.set_router();
  },
  getData: function() {
    var db;
    db = new Firebase("https://" + config.firebase + ".firebaseio.com/");
    return db.on("value", (function(_this) {
      return function(snapshot) {
        _this.set("guests", snapshot.val());
        return console.log("ok:", _this.get("guests"));
      };
    })(this), function(err) {
      return console.log("err:", err.code);
    });
  },
  set_router: function() {
    var self;
    self = this;
    page("/", function() {
      console.log("[main-view] index");
      return self.set({
        "view": "index"
      });
    });
    page("/test", function(ctx) {
      console.log("[main-view] test");
      return self.set({
        "view": "test"
      });
    });
    return page({
      click: false,
      dispatch: true,
      hashbang: false
    });
  }
});



},{"../config":"/Users/luke.hedger/dev/Experiments/040715/source/js/config.coffee","./../../../vendor/page/page.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js","./../../../vendor/ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js","firebase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/firebase/lib/firebase-web.js","main-view.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/main-view.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/template/main-view.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"wrapper"},"f":[{"t":7,"e":"header"}," ",{"t":7,"e":"div","a":{"class":"wrapper__row"},"f":[{"t":7,"e":"div","a":{"class":"item--square"}}," ",{"t":7,"e":"div","a":{"class":"item--circle"}}," ",{"t":7,"e":"div","a":{"class":"item--rect"}}," ",{"t":7,"e":"div","a":{"class":"item--triangle"}}]}," ",{"t":7,"e":"div","a":{"class":"wrapper__row"},"f":[{"t":7,"e":"div","a":{"class":"item--rect"}}," ",{"t":7,"e":"div","a":{"class":"item--circle"}}," ",{"t":7,"e":"div","a":{"class":"item--rect"}}]}," ",{"t":7,"e":"div","a":{"class":"wrapper__row"},"f":[{"t":7,"e":"div","a":{"class":"item--square"}}," ",{"t":7,"e":"div","a":{"class":"item--circle"}}," ",{"t":7,"e":"div","a":{"class":"item--square"}}," ",{"t":7,"e":"div","a":{"class":"item--square"}}," ",{"t":7,"e":"div","a":{"class":"item--circle"}}]}," ",{"t":7,"e":"footer"}," ",{"t":7,"e":"ui-nav"}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"index\""},"f":["Home"]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"test\""},"f":[{"t":7,"e":"ui-test"}]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/nav.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"nav"},"f":[{"t":7,"e":"a","v":{"tap":"toIndex"},"f":["Home"]}," ",{"t":7,"e":"a","v":{"tap":"toTest"},"f":["Test"]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/test.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"test"},"f":[{"t":7,"e":"div","a":{"class":["circle ",{"t":2,"x":{"r":["clicked"],"s":"_0?\"clicked\":\"\""}}]},"v":{"tap":"itemTap"}}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/vendor/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.page=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /* globals require, module */

/**
   * Module dependencies.
   */

  var pathtoRegexp = require('path-to-regexp');

  /**
   * Module exports.
   */

  module.exports = page;

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var location = window.history.location || window.location;

  /**
   * Perform initial dispatch.
   */

  var dispatch = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
  * HashBang option
  */

  var hashbang = false;

  /**
   * Previous context, for capturing
   * page exit events.
   */

  var prevContext;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
    // show <path> with [state]
    } else if ('string' == typeof path) {
      'string' === typeof fn
        ? page.redirect(path, fn)
        : page.show(path, fn);
    // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];
  page.exits = [];

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path){
    if (0 === arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options){
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) window.addEventListener('click', onclick, false);
    if (true === options.hashbang) hashbang = true;
    if (!dispatch) return;
    var url = (hashbang && ~location.hash.indexOf('#!'))
      ? location.hash.substr(2) + location.search
      : location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function(){
    if (!running) return;
    running = false;
    window.removeEventListener('click', onclick, false);
    window.removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch){
    var ctx = new Context(path, state);
    if (false !== dispatch) page.dispatch(ctx);
    if (false !== ctx.handled) ctx.pushState();
    return ctx;
  };

  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {String} from - if param 'to' is undefined redirects to 'from'
   * @param {String} [to]
   * @api public
   */
  page.redirect = function(from, to) {
    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page(from, function (e) {
        setTimeout(function() {
          page.replace(to);
        },0);
      });
    }

    // Wait for the push state and replace it with another
    if('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
          page.replace(from);
      },0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */

  page.replace = function(path, state, init, dispatch){
    var ctx = new Context(path, state);
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) page.dispatch(ctx);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx){
    var prev = prevContext;
    var i = 0;
    var j = 0;

    prevContext = ctx;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];
      if (!fn) return unhandled(ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;

    if (hashbang) {
      current = base + location.hash.replace('#!','');
    } else {
      current = location.pathname + location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    location.href = ctx.canonicalPath;
  }

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  page.exit = function(path, fn) {
    if (typeof path == 'function') {
      return page.exit('*', path);
    };

    var route = new Route(path);
    for (var i = 1; i < arguments.length; ++i) {
      page.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
  * Remove URL encoding from the given `str`.
  * Accommodates whitespace in both x-www-form-urlencoded
  * and regular percent-encoded form.
  *
  * @param {str} URL component to decode
  */
  function decodeURLEncodedURIComponent(str) {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    path = decodeURLEncodedURIComponent(path);
    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i
      ? path.slice(i + 1)
      : '';
    this.pathname = ~i
      ? path.slice(0, i)
      : path;
    this.params = [];

    // fragment
    this.hash = '';
    if (!~this.path.indexOf('#')) return;
    var parts = this.path.split('#');
    this.path = parts[0];
    this.hash = parts[1] || '';
    this.querystring = this.querystring.split('#')[0];
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function(){
    history.pushState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function(){
    history.replaceState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(this.path,
      this.keys = [],
      options.sensitive,
      options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn){
    var self = this;
    return function(ctx, next){
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Array} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params){
    var keys = this.keys,
        qsIndex = path.indexOf('?'),
        pathname = ~qsIndex
          ? path.slice(0, qsIndex)
          : path,
        m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];

      var val = 'string' === typeof m[i]
        ? decodeURIComponent(m[i])
        : m[i];

      if (key) {
        params[key.name] = undefined !== params[key.name]
          ? params[key.name]
          : val;
      } else {
        params.push(val);
      }
    }

    return true;
  };

  /**
   * Handle "populate" events.
   */

  function onpopstate(e) {
    if (e.state) {
      var path = e.state.path;
      page.replace(path, e.state);
    }
  }

  /**
   * Handle "click" events.
   */

  function onclick(e) {
    if (1 != which(e)) return;
    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    var el = e.target;
    while (el && 'A' != el.nodeName) el = el.parentNode;
    if (!el || 'A' != el.nodeName) return;

    // Ignore if tag has a "download" attribute
    if (el.getAttribute("download")) return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (el.pathname === location.pathname && (el.hash || '#' === link)) return;

    // Check for mailto: in the href
    if (link && link.indexOf("mailto:") > -1) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;

    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // same page
    var orig = path;

    path = path.replace(base, '');

    if (base && orig === path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null === e.which
      ? e.button
      : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return (href && (0 === href.indexOf(origin)));
  }

  page.sameOrigin = sameOrigin;

},{"path-to-regexp":2}],2:[function(require,module,exports){
/**
 * Expose `pathtoRegexp`.
 */
module.exports = pathtoRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match already escaped characters that would otherwise incorrectly appear
  // in future matches. This allows the user to escape special characters that
  // shouldn't be transformed.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that should always be escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
var attachKeys = function (re, keys) {
  re.keys = keys;

  return re;
};

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array should be passed in, which will contain the placeholder key
 * names. For example `/user/:id` will then contain `["id"]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 keys
 * @param  {Object}                options
 * @return {RegExp}
 */
function pathtoRegexp (path, keys, options) {
  if (keys && !Array.isArray(keys)) {
    options = keys;
    keys = null;
  }

  keys = keys || [];
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var index = 0;

  if (path instanceof RegExp) {
    // Match all capturing groups of a regexp.
    var groups = path.source.match(/\((?!\?)/g) || [];

    // Map all the matches to their numeric keys and push into the keys.
    keys.push.apply(keys, groups.map(function (match, index) {
      return {
        name:      index,
        delimiter: null,
        optional:  false,
        repeat:    false
      };
    }));

    // Return the source back to the user.
    return attachKeys(path, keys);
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    // Generate a new regexp instance by joining all the parts together.
    return attachKeys(new RegExp('(?:' + path.join('|') + ')', flags), keys);
  }

  // Alter the path string into a usable regexp.
  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {
    // Avoiding re-escaping escaped characters.
    if (escaped) {
      return escaped;
    }

    // Escape regexp special characters.
    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    // Escape the prefix character.
    prefix = prefix ? '\\' + prefix : '';

    // Match using the custom capturing group, or fallback to capturing
    // everything up to the next slash (or next period if the param was
    // prefixed with a period).
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    // Allow parameters to be repeated more than once.
    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    // Allow a parameter to be optional.
    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  });

  // Check whether the path ends in a slash as it alters some match behaviour.
  var endsWithSlash = path[path.length - 1] === '/';

  // In non-strict mode we allow an optional trailing slash in the match. If
  // the path to match already ended with a slash, we need to remove it for
  // consistency. The slash is only valid at the very end of a path match, not
  // anywhere in the middle. This is important for non-ending mode, otherwise
  // "/test/" will match "/test//route".
  if (!strict) {
    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\/(?=$))?';
  }

  // In non-ending mode, we need prompt the capturing groups to match as much
  // as possible by using a positive lookahead for the end or next path segment.
  if (!end) {
    path += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + path + (end ? '$' : ''), flags), keys);
};

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"path-to-regexp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/index.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-events-tap/ractive-events-tap.js":[function(require,module,exports){
/*

	ractive-events-tap
	==================

	Version 0.1.2.

	On mobile devices, using `on-click` isn't good enough. Tapping the
	touchscreen will fire a simulated click event, but only after a 300
	millisecond delay, which makes your app feel sluggish. It also
	causes the tapped area to highlight, which in most cases looks a
	bit messy.

	Instead, use `on-tap`. When you tap an area, the simulated click
	event will be prevented, and the user's action is responded to
	instantly. The `on-tap` event also differs from `on-click` in that
	the click event will (frankly rather bizarrely) fire even if you
	hold the mouse down over a single element for several seconds and
	waggle it about.

	Pointer events are also supported, as is pressing the spacebar when
	the relevant element is focused (which triggers a click event, and
	is good for accessibility).

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-events-tap.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-events-tap' );

	Add a tap event in the normal fashion:

	    <div on-tap='foo'>tap me!</div>

	Then add a handler:

	    ractive.on( 'foo', function ( event ) {
	      alert( 'tapped' );
	    });

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-events-tap plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var tap = function ( node, fire ) {
		var mousedown, touchstart, focusHandler, distanceThreshold, timeThreshold, preventMousedownEvents, preventMousedownTimeout;

		distanceThreshold = 5; // maximum pixels pointer can move before cancel
		timeThreshold = 400;   // maximum milliseconds between down and up before cancel

		mousedown = function ( event ) {
			var currentTarget, x, y, pointerId, up, move, cancel;

			if ( preventMousedownEvents ) {
				return;
			}

			if ( event.which !== undefined && event.which !== 1 ) {
				return;
			}

			x = event.clientX;
			y = event.clientY;
			currentTarget = this;
			// This will be null for mouse events.
			pointerId = event.pointerId;

			up = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				if ( ( Math.abs( event.clientX - x ) >= distanceThreshold ) || ( Math.abs( event.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'MSPointerUp', up, false );
				document.removeEventListener( 'MSPointerMove', move, false );
				document.removeEventListener( 'MSPointerCancel', cancel, false );
				node.removeEventListener( 'pointerup', up, false );
				document.removeEventListener( 'pointermove', move, false );
				document.removeEventListener( 'pointercancel', cancel, false );
				node.removeEventListener( 'click', up, false );
				document.removeEventListener( 'mousemove', move, false );
			};

			if ( window.navigator.pointerEnabled ) {
				node.addEventListener( 'pointerup', up, false );
				document.addEventListener( 'pointermove', move, false );
				document.addEventListener( 'pointercancel', cancel, false );
			} else if ( window.navigator.msPointerEnabled ) {
				node.addEventListener( 'MSPointerUp', up, false );
				document.addEventListener( 'MSPointerMove', move, false );
				document.addEventListener( 'MSPointerCancel', cancel, false );
			} else {
				node.addEventListener( 'click', up, false );
				document.addEventListener( 'mousemove', move, false );
			}

			setTimeout( cancel, timeThreshold );
		};

		if ( window.navigator.pointerEnabled ) {
			node.addEventListener( 'pointerdown', mousedown, false );
		} else if ( window.navigator.msPointerEnabled ) {
			node.addEventListener( 'MSPointerDown', mousedown, false );
		} else {
			node.addEventListener( 'mousedown', mousedown, false );
		}


		touchstart = function ( event ) {
			var currentTarget, x, y, touch, finger, move, up, cancel;

			if ( event.touches.length !== 1 ) {
				return;
			}

			touch = event.touches[0];

			x = touch.clientX;
			y = touch.clientY;
			currentTarget = this;

			finger = touch.identifier;

			up = function ( event ) {
				var touch;

				touch = event.changedTouches[0];
				if ( touch.identifier !== finger ) {
					cancel();
				}

				event.preventDefault();  // prevent compatibility mouse event

				// for the benefit of mobile Firefox and old Android browsers, we need this absurd hack.
				preventMousedownEvents = true;
				clearTimeout( preventMousedownTimeout );

				preventMousedownTimeout = setTimeout( function () {
					preventMousedownEvents = false;
				}, 400 );

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				var touch;

				if ( event.touches.length !== 1 || event.touches[0].identifier !== finger ) {
					cancel();
				}

				touch = event.touches[0];
				if ( ( Math.abs( touch.clientX - x ) >= distanceThreshold ) || ( Math.abs( touch.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'touchend', up, false );
				window.removeEventListener( 'touchmove', move, false );
				window.removeEventListener( 'touchcancel', cancel, false );
			};

			node.addEventListener( 'touchend', up, false );
			window.addEventListener( 'touchmove', move, false );
			window.addEventListener( 'touchcancel', cancel, false );

			setTimeout( cancel, timeThreshold );
		};

		node.addEventListener( 'touchstart', touchstart, false );


		// native buttons, and <input type='button'> elements, should fire a tap event
		// when the space key is pressed
		if ( node.tagName === 'BUTTON' || node.type === 'button' ) {
			focusHandler = function () {
				var blurHandler, keydownHandler;

				keydownHandler = function ( event ) {
					if ( event.which === 32 ) { // space key
						fire({
							node: node,
							original: event
						});
					}
				};

				blurHandler = function () {
					node.removeEventListener( 'keydown', keydownHandler, false );
					node.removeEventListener( 'blur', blurHandler, false );
				};

				node.addEventListener( 'keydown', keydownHandler, false );
				node.addEventListener( 'blur', blurHandler, false );
			};

			node.addEventListener( 'focus', focusHandler, false );
		}


		return {
			teardown: function () {
				node.removeEventListener( 'pointerdown', mousedown, false );
				node.removeEventListener( 'MSPointerDown', mousedown, false );
				node.removeEventListener( 'mousedown', mousedown, false );
				node.removeEventListener( 'touchstart', touchstart, false );
				node.removeEventListener( 'focus', focusHandler, false );
			}
		};
	};

	Ractive.events.tap = tap;

}));

},{"./../ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js":[function(require,module,exports){
/*
	ractive.js v0.6.1
	2014-10-25 - commit 3a576eb3 

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

( function( global ) {

	'use strict';

	var noConflict = global.Ractive;

	/* config/defaults/options.js */
	var options = function() {

		var defaultOptions = {
			// render placement:
			el: void 0,
			append: false,
			// template:
			template: {
				v: 1,
				t: []
			},
			yield: null,
			// parse:
			preserveWhitespace: false,
			sanitize: false,
			stripComments: true,
			// data & binding:
			data: {},
			computed: {},
			magic: false,
			modifyArrays: true,
			adapt: [],
			isolated: false,
			twoway: true,
			lazy: false,
			// transitions:
			noIntro: false,
			transitionsEnabled: true,
			complete: void 0,
			// css:
			noCssTransform: false,
			// debug:
			debug: false
		};
		return defaultOptions;
	}();

	/* config/defaults/easing.js */
	var easing = {
		linear: function( pos ) {
			return pos;
		},
		easeIn: function( pos ) {
			return Math.pow( pos, 3 );
		},
		easeOut: function( pos ) {
			return Math.pow( pos - 1, 3 ) + 1;
		},
		easeInOut: function( pos ) {
			if ( ( pos /= 0.5 ) < 1 ) {
				return 0.5 * Math.pow( pos, 3 );
			}
			return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
		}
	};

	/* circular.js */
	var circular = [];

	/* utils/hasOwnProperty.js */
	var hasOwn = Object.prototype.hasOwnProperty;

	/* utils/isArray.js */
	var isArray = function() {

		var toString = Object.prototype.toString;
		// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		return function( thing ) {
			return toString.call( thing ) === '[object Array]';
		};
	}();

	/* utils/isObject.js */
	var isObject = function() {

		var toString = Object.prototype.toString;
		return function( thing ) {
			return thing && toString.call( thing ) === '[object Object]';
		};
	}();

	/* utils/isNumeric.js */
	var isNumeric = function( thing ) {
		return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	};

	/* config/defaults/interpolators.js */
	var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

		var interpolators, interpolate, cssLengthPattern;
		circular.push( function() {
			interpolate = circular.interpolate;
		} );
		cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
		interpolators = {
			number: function( from, to ) {
				var delta;
				if ( !isNumeric( from ) || !isNumeric( to ) ) {
					return null;
				}
				from = +from;
				to = +to;
				delta = to - from;
				if ( !delta ) {
					return function() {
						return from;
					};
				}
				return function( t ) {
					return from + t * delta;
				};
			},
			array: function( from, to ) {
				var intermediate, interpolators, len, i;
				if ( !isArray( from ) || !isArray( to ) ) {
					return null;
				}
				intermediate = [];
				interpolators = [];
				i = len = Math.min( from.length, to.length );
				while ( i-- ) {
					interpolators[ i ] = interpolate( from[ i ], to[ i ] );
				}
				// surplus values - don't interpolate, but don't exclude them either
				for ( i = len; i < from.length; i += 1 ) {
					intermediate[ i ] = from[ i ];
				}
				for ( i = len; i < to.length; i += 1 ) {
					intermediate[ i ] = to[ i ];
				}
				return function( t ) {
					var i = len;
					while ( i-- ) {
						intermediate[ i ] = interpolators[ i ]( t );
					}
					return intermediate;
				};
			},
			object: function( from, to ) {
				var properties, len, interpolators, intermediate, prop;
				if ( !isObject( from ) || !isObject( to ) ) {
					return null;
				}
				properties = [];
				intermediate = {};
				interpolators = {};
				for ( prop in from ) {
					if ( hasOwnProperty.call( from, prop ) ) {
						if ( hasOwnProperty.call( to, prop ) ) {
							properties.push( prop );
							interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
						} else {
							intermediate[ prop ] = from[ prop ];
						}
					}
				}
				for ( prop in to ) {
					if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
						intermediate[ prop ] = to[ prop ];
					}
				}
				len = properties.length;
				return function( t ) {
					var i = len,
						prop;
					while ( i-- ) {
						prop = properties[ i ];
						intermediate[ prop ] = interpolators[ prop ]( t );
					}
					return intermediate;
				};
			}
		};
		return interpolators;
	}( circular, hasOwn, isArray, isObject, isNumeric );

	/* config/svg.js */
	var svg = function() {

		var svg;
		if ( typeof document === 'undefined' ) {
			svg = false;
		} else {
			svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
		}
		return svg;
	}();

	/* utils/warn.js */
	var warn = function() {

		/* global console */
		var warn, warned = {};
		if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
			warn = function( message, allowDuplicates ) {
				if ( !allowDuplicates ) {
					if ( warned[ message ] ) {
						return;
					}
					warned[ message ] = true;
				}
				console.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );
			};
		} else {
			warn = function() {};
		}
		return warn;
	}();

	/* config/errors.js */
	var errors = {
		missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
		mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
		noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
		noTemplateForPartial: 'Could not find template for partial "{name}"',
		noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
		evaluationError: 'Error evaluating "{uniqueString}": {err}',
		badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
		failedComputation: 'Failed to compute "{key}": {err}',
		missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
		badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
		noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned',
		defaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',
		noElementProxyEventWildcards: 'Only component proxy-events may contain "*" wildcards, <{element} on-{event}/> is not valid.',
		methodDeprecated: 'The method "{deprecated}" has been deprecated in favor of "{replacement}" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'
	};

	/* utils/log.js */
	var log = function( consolewarn, errors ) {

		var log = {
			warn: function( options, passthru ) {
				if ( !options.debug && !passthru ) {
					return;
				}
				this.warnAlways( options );
			},
			warnAlways: function( options ) {
				this.logger( getMessage( options ), options.allowDuplicates );
			},
			error: function( options ) {
				this.errorOnly( options );
				if ( !options.debug ) {
					this.warn( options, true );
				}
			},
			errorOnly: function( options ) {
				if ( options.debug ) {
					this.critical( options );
				}
			},
			critical: function( options ) {
				var err = options.err || new Error( getMessage( options ) );
				this.thrower( err );
			},
			logger: consolewarn,
			thrower: function( err ) {
				throw err;
			}
		};

		function getMessage( options ) {
			var message = errors[ options.message ] || options.message || '';
			return interpolate( message, options.args );
		}
		// simple interpolation. probably quicker (and better) out there,
		// but log is not in golden path of execution, only exceptions
		function interpolate( message, args ) {
			return message.replace( /{([^{}]*)}/g, function( a, b ) {
				return args[ b ];
			} );
		}
		return log;
	}( warn, errors );

	/* Ractive/prototype/shared/hooks/Hook.js */
	var Ractive$shared_hooks_Hook = function( log ) {

		var deprecations = {
			construct: {
				deprecated: 'beforeInit',
				replacement: 'onconstruct'
			},
			render: {
				deprecated: 'init',
				message: 'The "init" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the "oninit" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use "onrender" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'
			},
			complete: {
				deprecated: 'complete',
				replacement: 'oncomplete'
			}
		};

		function Hook( event ) {
			this.event = event;
			this.method = 'on' + event;
			this.deprecate = deprecations[ event ];
		}
		Hook.prototype.fire = function( ractive, arg ) {
			function call( method ) {
				if ( ractive[ method ] ) {
					arg ? ractive[ method ]( arg ) : ractive[ method ]();
					return true;
				}
			}
			call( this.method );
			if ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {
				log.warnAlways( {
					debug: ractive.debug,
					message: this.deprecate.message || 'methodDeprecated',
					args: this.deprecate
				} );
			}
			arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
		};
		return Hook;
	}( log );

	/* utils/removeFromArray.js */
	var removeFromArray = function( array, member ) {
		var index = array.indexOf( member );
		if ( index !== -1 ) {
			array.splice( index, 1 );
		}
	};

	/* utils/Promise.js */
	var Promise = function() {

		var __export;
		var _Promise, PENDING = {},
			FULFILLED = {},
			REJECTED = {};
		if ( typeof Promise === 'function' ) {
			// use native Promise
			_Promise = Promise;
		} else {
			_Promise = function( callback ) {
				var fulfilledHandlers = [],
					rejectedHandlers = [],
					state = PENDING,
					result, dispatchHandlers, makeResolver, fulfil, reject, promise;
				makeResolver = function( newState ) {
					return function( value ) {
						if ( state !== PENDING ) {
							return;
						}
						result = value;
						state = newState;
						dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
						// dispatch onFulfilled and onRejected handlers asynchronously
						wait( dispatchHandlers );
					};
				};
				fulfil = makeResolver( FULFILLED );
				reject = makeResolver( REJECTED );
				try {
					callback( fulfil, reject );
				} catch ( err ) {
					reject( err );
				}
				promise = {
					// `then()` returns a Promise - 2.2.7
					then: function( onFulfilled, onRejected ) {
						var promise2 = new _Promise( function( fulfil, reject ) {
							var processResolutionHandler = function( handler, handlers, forward ) {
								// 2.2.1.1
								if ( typeof handler === 'function' ) {
									handlers.push( function( p1result ) {
										var x;
										try {
											x = handler( p1result );
											resolve( promise2, x, fulfil, reject );
										} catch ( err ) {
											reject( err );
										}
									} );
								} else {
									// Forward the result of promise1 to promise2, if resolution handlers
									// are not given
									handlers.push( forward );
								}
							};
							// 2.2
							processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
							processResolutionHandler( onRejected, rejectedHandlers, reject );
							if ( state !== PENDING ) {
								// If the promise has resolved already, dispatch the appropriate handlers asynchronously
								wait( dispatchHandlers );
							}
						} );
						return promise2;
					}
				};
				promise[ 'catch' ] = function( onRejected ) {
					return this.then( null, onRejected );
				};
				return promise;
			};
			_Promise.all = function( promises ) {
				return new _Promise( function( fulfil, reject ) {
					var result = [],
						pending, i, processPromise;
					if ( !promises.length ) {
						fulfil( result );
						return;
					}
					processPromise = function( i ) {
						promises[ i ].then( function( value ) {
							result[ i ] = value;
							if ( !--pending ) {
								fulfil( result );
							}
						}, reject );
					};
					pending = i = promises.length;
					while ( i-- ) {
						processPromise( i );
					}
				} );
			};
			_Promise.resolve = function( value ) {
				return new _Promise( function( fulfil ) {
					fulfil( value );
				} );
			};
			_Promise.reject = function( reason ) {
				return new _Promise( function( fulfil, reject ) {
					reject( reason );
				} );
			};
		}
		__export = _Promise;
		// TODO use MutationObservers or something to simulate setImmediate
		function wait( callback ) {
			setTimeout( callback, 0 );
		}

		function makeDispatcher( handlers, result ) {
			return function() {
				var handler;
				while ( handler = handlers.shift() ) {
					handler( result );
				}
			};
		}

		function resolve( promise, x, fulfil, reject ) {
			// Promise Resolution Procedure
			var then;
			// 2.3.1
			if ( x === promise ) {
				throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
			}
			// 2.3.2
			if ( x instanceof _Promise ) {
				x.then( fulfil, reject );
			} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
				try {
					then = x.then;
				} catch ( e ) {
					reject( e );
					// 2.3.3.2
					return;
				}
				// 2.3.3.3
				if ( typeof then === 'function' ) {
					var called, resolvePromise, rejectPromise;
					resolvePromise = function( y ) {
						if ( called ) {
							return;
						}
						called = true;
						resolve( promise, y, fulfil, reject );
					};
					rejectPromise = function( r ) {
						if ( called ) {
							return;
						}
						called = true;
						reject( r );
					};
					try {
						then.call( x, resolvePromise, rejectPromise );
					} catch ( e ) {
						if ( !called ) {
							// 2.3.3.3.4.1
							reject( e );
							// 2.3.3.3.4.2
							called = true;
							return;
						}
					}
				} else {
					fulfil( x );
				}
			} else {
				fulfil( x );
			}
		}
		return __export;
	}();

	/* utils/normaliseRef.js */
	var normaliseRef = function() {

		var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
		return function normaliseRef( ref ) {
			return ( ref || '' ).replace( regex, '.$1' );
		};
	}();

	/* shared/getInnerContext.js */
	var getInnerContext = function( fragment ) {
		do {
			if ( fragment.context !== undefined ) {
				return fragment.context;
			}
		} while ( fragment = fragment.parent );
		return '';
	};

	/* utils/isEqual.js */
	var isEqual = function( a, b ) {
		if ( a === null && b === null ) {
			return true;
		}
		if ( typeof a === 'object' || typeof b === 'object' ) {
			return false;
		}
		return a === b;
	};

	/* shared/createComponentBinding.js */
	var createComponentBinding = function( circular, isEqual ) {

		var runloop;
		circular.push( function() {
			return runloop = circular.runloop;
		} );
		var Binding = function( ractive, keypath, otherInstance, otherKeypath ) {
			var this$0 = this;
			this.root = ractive;
			this.keypath = keypath;
			this.otherInstance = otherInstance;
			this.otherKeypath = otherKeypath;
			this.lock = function() {
				return this$0.updating = true;
			};
			this.unlock = function() {
				return this$0.updating = false;
			};
			this.bind();
			this.value = this.root.viewmodel.get( this.keypath );
		};
		Binding.prototype = {
			isLocked: function() {
				return this.updating || this.counterpart && this.counterpart.updating;
			},
			shuffle: function( newIndices, value ) {
				this.propagateChange( value, newIndices );
			},
			setValue: function( value ) {
				this.propagateChange( value );
			},
			propagateChange: function( value, newIndices ) {
				var other;
				// Only *you* can prevent infinite loops
				if ( this.isLocked() ) {
					this.value = value;
					return;
				}
				if ( !isEqual( value, this.value ) ) {
					this.lock();
					// TODO maybe the case that `value === this.value` - should that result
					// in an update rather than a set?
					// if the other viewmodel is already locked up, need to do a deferred update
					if ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {
						runloop.scheduleTask( function() {
							return runloop.addViewmodel( other );
						} );
					}
					if ( newIndices ) {
						other.smartUpdate( this.otherKeypath, value, newIndices );
					} else {
						if ( isSettable( other, this.otherKeypath ) ) {
							other.set( this.otherKeypath, value );
						}
					}
					this.value = value;
					// TODO will the counterpart update after this line, during
					// the runloop end cycle? may be a problem...
					runloop.scheduleTask( this.unlock );
				}
			},
			refineValue: function( keypaths ) {
				var this$0 = this;
				var other;
				if ( this.isLocked() ) {
					return;
				}
				this.lock();
				runloop.addViewmodel( other = this.otherInstance.viewmodel );
				keypaths.map( function( keypath ) {
					return this$0.otherKeypath + keypath.substr( this$0.keypath.length );
				} ).forEach( function( keypath ) {
					return other.mark( keypath );
				} );
				runloop.scheduleTask( this.unlock );
			},
			bind: function() {
				this.root.viewmodel.register( this.keypath, this );
			},
			rebind: function( newKeypath ) {
				this.unbind();
				this.keypath = newKeypath;
				this.counterpart.otherKeypath = newKeypath;
				this.bind();
			},
			unbind: function() {
				this.root.viewmodel.unregister( this.keypath, this );
			}
		};

		function isSettable( viewmodel, keypath ) {
			var computed = viewmodel.computations[ keypath ];
			return !computed || computed.setter;
		}
		return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
			var hash, childInstance, bindings, parentToChildBinding, childToParentBinding;
			hash = parentKeypath + '=' + childKeypath;
			bindings = component.bindings;
			if ( bindings[ hash ] ) {
				// TODO does this ever happen?
				return;
			}
			childInstance = component.instance;
			parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );
			bindings.push( parentToChildBinding );
			if ( childInstance.twoway ) {
				childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );
				bindings.push( childToParentBinding );
				parentToChildBinding.counterpart = childToParentBinding;
				childToParentBinding.counterpart = parentToChildBinding;
			}
			bindings[ hash ] = parentToChildBinding;
		};
	}( circular, isEqual );

	/* shared/resolveRef.js */
	var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

		var __export;
		var ancestorErrorMessage, getOptions;
		ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
		getOptions = {
			evaluateWrapped: true
		};
		__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {
			var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
			ref = normaliseRef( ref );
			// If a reference begins '~/', it's a top-level reference
			if ( ref.substr( 0, 2 ) === '~/' ) {
				return ref.substring( 2 );
			}
			// If a reference begins with '.', it's either a restricted reference or
			// an ancestor reference...
			if ( ref.charAt( 0 ) === '.' ) {
				return resolveAncestorReference( getInnerContext( fragment ), ref );
			}
			// ...otherwise we need to find the keypath
			key = ref.split( '.' )[ 0 ];
			// get() in viewmodel creation means no fragment (yet)
			fragment = fragment || {};
			do {
				context = fragment.context;
				if ( !context ) {
					continue;
				}
				hasContextChain = true;
				parentValue = ractive.viewmodel.get( context, getOptions );
				if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
					return context + '.' + ref;
				}
			} while ( fragment = fragment.parent );
			// Root/computed property?
			if ( key in ractive.data || key in ractive.viewmodel.computations ) {
				return ref;
			}
			// If this is an inline component, and it's not isolated, we
			// can try going up the scope chain
			if ( ractive._parent && !ractive.isolated ) {
				hasContextChain = true;
				fragment = ractive.component.parentFragment;
				// Special case - index refs
				if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
					// Create an index ref binding, so that it can be rebound letter if necessary.
					// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
					ractive.component.indexRefBindings[ ref ] = ref;
					ractive.viewmodel.set( ref, index, true );
					return;
				}
				keypath = resolveRef( ractive._parent, ref, fragment, true );
				if ( keypath ) {
					// We need to create an inter-component binding
					// If parent keypath is 'one.foo' and child is 'two.foo', we bind
					// 'one' to 'two' as it's more efficient and avoids edge cases
					parentKeys = keypath.split( '.' );
					childKeys = ref.split( '.' );
					while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
						parentKeys.pop();
						childKeys.pop();
					}
					parentKeypath = parentKeys.join( '.' );
					childKeypath = childKeys.join( '.' );
					ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
					createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
					return ref;
				}
			}
			// If there's no context chain, and the instance is either a) isolated or
			// b) an orphan, then we know that the keypath is identical to the reference
			if ( !isParentLookup && !hasContextChain ) {
				// the data object needs to have a property by this name,
				// to prevent future failed lookups
				ractive.viewmodel.set( ref, undefined );
				return ref;
			}
			if ( ractive.viewmodel.get( ref ) !== undefined ) {
				return ref;
			}
		};

		function resolveAncestorReference( baseContext, ref ) {
			var contextKeys;
			// {{.}} means 'current context'
			if ( ref === '.' )
				return baseContext;
			contextKeys = baseContext ? baseContext.split( '.' ) : [];
			// ancestor references (starting "../") go up the tree
			if ( ref.substr( 0, 3 ) === '../' ) {
				while ( ref.substr( 0, 3 ) === '../' ) {
					if ( !contextKeys.length ) {
						throw new Error( ancestorErrorMessage );
					}
					contextKeys.pop();
					ref = ref.substring( 3 );
				}
				contextKeys.push( ref );
				return contextKeys.join( '.' );
			}
			// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
			if ( !baseContext ) {
				return ref.replace( /^\.\/?/, '' );
			}
			return baseContext + ref.replace( /^\.\//, '.' );
		}
		return __export;
	}( normaliseRef, getInnerContext, createComponentBinding );

	/* global/TransitionManager.js */
	var TransitionManager = function( removeFromArray ) {

		var TransitionManager = function( callback, parent ) {
			this.callback = callback;
			this.parent = parent;
			this.intros = [];
			this.outros = [];
			this.children = [];
			this.totalChildren = this.outroChildren = 0;
			this.detachQueue = [];
			this.outrosComplete = false;
			if ( parent ) {
				parent.addChild( this );
			}
		};
		TransitionManager.prototype = {
			addChild: function( child ) {
				this.children.push( child );
				this.totalChildren += 1;
				this.outroChildren += 1;
			},
			decrementOutros: function() {
				this.outroChildren -= 1;
				check( this );
			},
			decrementTotal: function() {
				this.totalChildren -= 1;
				check( this );
			},
			add: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				list.push( transition );
			},
			remove: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				removeFromArray( list, transition );
				check( this );
			},
			init: function() {
				this.ready = true;
				check( this );
			},
			detachNodes: function() {
				this.detachQueue.forEach( detach );
				this.children.forEach( detachNodes );
			}
		};

		function detach( element ) {
			element.detach();
		}

		function detachNodes( tm ) {
			tm.detachNodes();
		}

		function check( tm ) {
			if ( !tm.ready || tm.outros.length || tm.outroChildren )
				return;
			// If all outros are complete, and we haven't already done this,
			// we notify the parent if there is one, otherwise
			// start detaching nodes
			if ( !tm.outrosComplete ) {
				if ( tm.parent ) {
					tm.parent.decrementOutros( tm );
				} else {
					tm.detachNodes();
				}
				tm.outrosComplete = true;
			}
			// Once everything is done, we can notify parent transition
			// manager and call the callback
			if ( !tm.intros.length && !tm.totalChildren ) {
				if ( typeof tm.callback === 'function' ) {
					tm.callback();
				}
				if ( tm.parent ) {
					tm.parent.decrementTotal();
				}
			}
		}
		return TransitionManager;
	}( removeFromArray );

	/* global/runloop.js */
	var runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {

		var __export;
		var batch, runloop, unresolved = [],
			changeHook = new Hook( 'change' );
		runloop = {
			start: function( instance, returnPromise ) {
				var promise, fulfilPromise;
				if ( returnPromise ) {
					promise = new Promise( function( f ) {
						return fulfilPromise = f;
					} );
				}
				batch = {
					previousBatch: batch,
					transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
					views: [],
					tasks: [],
					viewmodels: [],
					instance: instance
				};
				if ( instance ) {
					batch.viewmodels.push( instance.viewmodel );
				}
				return promise;
			},
			end: function() {
				flushChanges();
				batch.transitionManager.init();
				if ( !batch.previousBatch && !!batch.instance )
					batch.instance.viewmodel.changes = [];
				batch = batch.previousBatch;
			},
			addViewmodel: function( viewmodel ) {
				if ( batch ) {
					if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
						batch.viewmodels.push( viewmodel );
						return true;
					} else {
						return false;
					}
				} else {
					viewmodel.applyChanges();
					return false;
				}
			},
			registerTransition: function( transition ) {
				transition._manager = batch.transitionManager;
				batch.transitionManager.add( transition );
			},
			addView: function( view ) {
				batch.views.push( view );
			},
			addUnresolved: function( thing ) {
				unresolved.push( thing );
			},
			removeUnresolved: function( thing ) {
				removeFromArray( unresolved, thing );
			},
			// synchronise node detachments with transition ends
			detachWhenReady: function( thing ) {
				batch.transitionManager.detachQueue.push( thing );
			},
			scheduleTask: function( task, postRender ) {
				var _batch;
				if ( !batch ) {
					task();
				} else {
					_batch = batch;
					while ( postRender && _batch.previousBatch ) {
						// this can't happen until the DOM has been fully updated
						// otherwise in some situations (with components inside elements)
						// transitions and decorators will initialise prematurely
						_batch = _batch.previousBatch;
					}
					_batch.tasks.push( task );
				}
			}
		};
		circular.runloop = runloop;
		__export = runloop;

		function flushChanges() {
			var i, thing, changeHash;
			for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
				thing = batch.viewmodels[ i ];
				changeHash = thing.applyChanges();
				if ( changeHash ) {
					changeHook.fire( thing.ractive, changeHash );
				}
			}
			batch.viewmodels.length = 0;
			attemptKeypathResolution();
			// Now that changes have been fully propagated, we can update the DOM
			// and complete other tasks
			for ( i = 0; i < batch.views.length; i += 1 ) {
				batch.views[ i ].update();
			}
			batch.views.length = 0;
			for ( i = 0; i < batch.tasks.length; i += 1 ) {
				batch.tasks[ i ]();
			}
			batch.tasks.length = 0;
			// If updating the view caused some model blowback - e.g. a triple
			// containing <option> elements caused the binding on the <select>
			// to update - then we start over
			if ( batch.viewmodels.length )
				return flushChanges();
		}

		function attemptKeypathResolution() {
			var i, item, keypath, resolved;
			i = unresolved.length;
			// see if we can resolve any unresolved references
			while ( i-- ) {
				item = unresolved[ i ];
				if ( item.keypath ) {
					// it resolved some other way. TODO how? two-way binding? Seems
					// weird that we'd still end up here
					unresolved.splice( i, 1 );
				}
				if ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {
					( resolved || ( resolved = [] ) ).push( {
						item: item,
						keypath: keypath
					} );
					unresolved.splice( i, 1 );
				}
			}
			if ( resolved ) {
				resolved.forEach( resolve );
			}
		}

		function resolve( resolved ) {
			resolved.item.resolve( resolved.keypath );
		}
		return __export;
	}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );

	/* utils/createBranch.js */
	var createBranch = function() {

		var numeric = /^\s*[0-9]+\s*$/;
		return function( key ) {
			return numeric.test( key ) ? [] : {};
		};
	}();

	/* viewmodel/prototype/get/magicAdaptor.js */
	var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

		var __export;
		var magicAdaptor, MagicWrapper;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			magicAdaptor = {
				filter: function( object, keypath, ractive ) {
					var keys, key, parentKeypath, parentWrapper, parentValue;
					if ( !keypath ) {
						return false;
					}
					keys = keypath.split( '.' );
					key = keys.pop();
					parentKeypath = keys.join( '.' );
					// If the parent value is a wrapper, other than a magic wrapper,
					// we shouldn't wrap this property
					if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
						return false;
					}
					parentValue = ractive.get( parentKeypath );
					// if parentValue is an array that doesn't include this member,
					// we should return false otherwise lengths will get messed up
					if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
						return false;
					}
					return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
				},
				wrap: function( ractive, property, keypath ) {
					return new MagicWrapper( ractive, property, keypath );
				}
			};
			MagicWrapper = function( ractive, value, keypath ) {
				var keys, objKeypath, template, siblings;
				this.magic = true;
				this.ractive = ractive;
				this.keypath = keypath;
				this.value = value;
				keys = keypath.split( '.' );
				this.prop = keys.pop();
				objKeypath = keys.join( '.' );
				this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
				template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
				// Has this property already been wrapped?
				if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
					// Yes. Register this wrapper to this property, if it hasn't been already
					if ( siblings.indexOf( this ) === -1 ) {
						siblings.push( this );
					}
					return;
				}
				// No, it hasn't been wrapped
				createAccessors( this, value, template );
			};
			MagicWrapper.prototype = {
				get: function() {
					return this.value;
				},
				reset: function( value ) {
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.obj[ this.prop ] = value;
					// trigger set() accessor
					runloop.addViewmodel( this.ractive.viewmodel );
					this.ractive.viewmodel.mark( this.keypath );
					this.updating = false;
				},
				set: function( key, value ) {
					if ( this.updating ) {
						return;
					}
					if ( !this.obj[ this.prop ] ) {
						this.updating = true;
						this.obj[ this.prop ] = createBranch( key );
						this.updating = false;
					}
					this.obj[ this.prop ][ key ] = value;
				},
				teardown: function() {
					var template, set, value, wrappers, index;
					// If this method was called because the cache was being cleared as a
					// result of a set()/update() call made by this wrapper, we return false
					// so that it doesn't get torn down
					if ( this.updating ) {
						return false;
					}
					template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					set = template && template.set;
					if ( !set ) {
						// most likely, this was an array member that was spliced out
						return;
					}
					wrappers = set._ractiveWrappers;
					index = wrappers.indexOf( this );
					if ( index !== -1 ) {
						wrappers.splice( index, 1 );
					}
					// Last one out, turn off the lights
					if ( !wrappers.length ) {
						value = this.obj[ this.prop ];
						Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
							writable: true,
							enumerable: true,
							configurable: true
						} );
						this.obj[ this.prop ] = value;
					}
				}
			};
		} catch ( err ) {
			magicAdaptor = false;
		}
		__export = magicAdaptor;

		function createAccessors( originalWrapper, value, template ) {
			var object, property, oldGet, oldSet, get, set;
			object = originalWrapper.obj;
			property = originalWrapper.prop;
			// Is this template configurable?
			if ( template && !template.configurable ) {
				// Special case - array length
				if ( property === 'length' ) {
					return;
				}
				throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
			}
			// Time to wrap this property
			if ( template ) {
				oldGet = template.get;
				oldSet = template.set;
			}
			get = oldGet || function() {
				return value;
			};
			set = function( v ) {
				if ( oldSet ) {
					oldSet( v );
				}
				value = oldGet ? oldGet() : v;
				set._ractiveWrappers.forEach( updateWrapper );
			};

			function updateWrapper( wrapper ) {
				var keypath, ractive;
				wrapper.value = value;
				if ( wrapper.updating ) {
					return;
				}
				ractive = wrapper.ractive;
				keypath = wrapper.keypath;
				wrapper.updating = true;
				runloop.start( ractive );
				ractive.viewmodel.mark( keypath );
				runloop.end();
				wrapper.updating = false;
			}
			// Create an array of wrappers, in case other keypaths/ractives depend on this property.
			// Handily, we can store them as a property of the set function. Yay JavaScript.
			set._ractiveWrappers = [ originalWrapper ];
			Object.defineProperty( object, property, {
				get: get,
				set: set,
				enumerable: true,
				configurable: true
			} );
		}
		return __export;
	}( runloop, createBranch, isArray );

	/* config/magic.js */
	var magic = function( magicAdaptor ) {

		return !!magicAdaptor;
	}( viewmodel$get_magicAdaptor );

	/* config/namespaces.js */
	var namespaces = {
		html: 'http://www.w3.org/1999/xhtml',
		mathml: 'http://www.w3.org/1998/Math/MathML',
		svg: 'http://www.w3.org/2000/svg',
		xlink: 'http://www.w3.org/1999/xlink',
		xml: 'http://www.w3.org/XML/1998/namespace',
		xmlns: 'http://www.w3.org/2000/xmlns/'
	};

	/* utils/createElement.js */
	var createElement = function( svg, namespaces ) {

		var createElement;
		// Test for SVG support
		if ( !svg ) {
			createElement = function( type, ns ) {
				if ( ns && ns !== namespaces.html ) {
					throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
				}
				return document.createElement( type );
			};
		} else {
			createElement = function( type, ns ) {
				if ( !ns || ns === namespaces.html ) {
					return document.createElement( type );
				}
				return document.createElementNS( ns, type );
			};
		}
		return createElement;
	}( svg, namespaces );

	/* config/isClient.js */
	var isClient = function() {

		var isClient = typeof document === 'object';
		return isClient;
	}();

	/* utils/defineProperty.js */
	var defineProperty = function( isClient ) {

		var defineProperty;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			if ( isClient ) {
				Object.defineProperty( document.createElement( 'div' ), 'test', {
					value: 0
				} );
			}
			defineProperty = Object.defineProperty;
		} catch ( err ) {
			// Object.defineProperty doesn't exist, or we're in IE8 where you can
			// only use it with DOM objects (what the fuck were you smoking, MSFT?)
			defineProperty = function( obj, prop, desc ) {
				obj[ prop ] = desc.value;
			};
		}
		return defineProperty;
	}( isClient );

	/* utils/defineProperties.js */
	var defineProperties = function( createElement, defineProperty, isClient ) {

		var defineProperties;
		try {
			try {
				Object.defineProperties( {}, {
					test: {
						value: 0
					}
				} );
			} catch ( err ) {
				// TODO how do we account for this? noMagic = true;
				throw err;
			}
			if ( isClient ) {
				Object.defineProperties( createElement( 'div' ), {
					test: {
						value: 0
					}
				} );
			}
			defineProperties = Object.defineProperties;
		} catch ( err ) {
			defineProperties = function( obj, props ) {
				var prop;
				for ( prop in props ) {
					if ( props.hasOwnProperty( prop ) ) {
						defineProperty( obj, prop, props[ prop ] );
					}
				}
			};
		}
		return defineProperties;
	}( createElement, defineProperty, isClient );

	/* Ractive/prototype/shared/add.js */
	var Ractive$shared_add = function( isNumeric ) {

		return function add( root, keypath, d ) {
			var value;
			if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
				throw new Error( 'Bad arguments' );
			}
			value = +root.get( keypath ) || 0;
			if ( !isNumeric( value ) ) {
				throw new Error( 'Cannot add to a non-numeric value' );
			}
			return root.set( keypath, value + d );
		};
	}( isNumeric );

	/* Ractive/prototype/add.js */
	var Ractive$add = function( add ) {

		return function Ractive$add( keypath, d ) {
			return add( this, keypath, d === undefined ? 1 : +d );
		};
	}( Ractive$shared_add );

	/* utils/normaliseKeypath.js */
	var normaliseKeypath = function( normaliseRef ) {

		var leadingDot = /^\.+/;
		return function normaliseKeypath( keypath ) {
			return normaliseRef( keypath ).replace( leadingDot, '' );
		};
	}( normaliseRef );

	/* config/vendors.js */
	var vendors = [
		'o',
		'ms',
		'moz',
		'webkit'
	];

	/* utils/requestAnimationFrame.js */
	var requestAnimationFrame = function( vendors ) {

		var requestAnimationFrame;
		// If window doesn't exist, we don't need requestAnimationFrame
		if ( typeof window === 'undefined' ) {
			requestAnimationFrame = null;
		} else {
			// https://gist.github.com/paulirish/1579671
			( function( vendors, lastTime, window ) {
				var x, setTimeout;
				if ( window.requestAnimationFrame ) {
					return;
				}
				for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
					window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
				}
				if ( !window.requestAnimationFrame ) {
					setTimeout = window.setTimeout;
					window.requestAnimationFrame = function( callback ) {
						var currTime, timeToCall, id;
						currTime = Date.now();
						timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
						id = setTimeout( function() {
							callback( currTime + timeToCall );
						}, timeToCall );
						lastTime = currTime + timeToCall;
						return id;
					};
				}
			}( vendors, 0, window ) );
			requestAnimationFrame = window.requestAnimationFrame;
		}
		return requestAnimationFrame;
	}( vendors );

	/* utils/getTime.js */
	var getTime = function() {

		var getTime;
		if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
			getTime = function() {
				return window.performance.now();
			};
		} else {
			getTime = function() {
				return Date.now();
			};
		}
		return getTime;
	}();

	/* shared/animations.js */
	var animations = function( rAF, getTime, runloop ) {

		var queue = [];
		var animations = {
			tick: function() {
				var i, animation, now;
				now = getTime();
				runloop.start();
				for ( i = 0; i < queue.length; i += 1 ) {
					animation = queue[ i ];
					if ( !animation.tick( now ) ) {
						// animation is complete, remove it from the stack, and decrement i so we don't miss one
						queue.splice( i--, 1 );
					}
				}
				runloop.end();
				if ( queue.length ) {
					rAF( animations.tick );
				} else {
					animations.running = false;
				}
			},
			add: function( animation ) {
				queue.push( animation );
				if ( !animations.running ) {
					animations.running = true;
					rAF( animations.tick );
				}
			},
			// TODO optimise this
			abort: function( keypath, root ) {
				var i = queue.length,
					animation;
				while ( i-- ) {
					animation = queue[ i ];
					if ( animation.root === root && animation.keypath === keypath ) {
						animation.stop();
					}
				}
			}
		};
		return animations;
	}( requestAnimationFrame, getTime, runloop );

	/* config/options/css/transform.js */
	var transform = function() {

		var __export;
		var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
			commentsPattern = /\/\*.*?\*\//g,
			selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
			mediaQueryPattern = /^@media/,
			dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
		__export = function transformCss( css, guid ) {
			var transformed, addGuid;
			addGuid = function( selector ) {
				var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
				selectorUnits = [];
				while ( match = selectorUnitPattern.exec( selector ) ) {
					selectorUnits.push( {
						str: match[ 0 ],
						base: match[ 1 ],
						modifiers: match[ 2 ]
					} );
				}
				// For each simple selector within the selector, we need to create a version
				// that a) combines with the guid, and b) is inside the guid
				dataAttr = '[data-rvcguid="' + guid + '"]';
				base = selectorUnits.map( extractString );
				i = selectorUnits.length;
				while ( i-- ) {
					appended = base.slice();
					// Pseudo-selectors should go after the attribute selector
					unit = selectorUnits[ i ];
					appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
					prepended = base.slice();
					prepended[ i ] = dataAttr + ' ' + prepended[ i ];
					transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
				}
				return transformed.join( ', ' );
			};
			if ( dataRvcGuidPattern.test( css ) ) {
				transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
			} else {
				transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
					var selectors, transformed;
					// don't transform media queries!
					if ( mediaQueryPattern.test( $1 ) )
						return match;
					selectors = $1.split( ',' ).map( trim );
					transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
					return match.replace( $1, transformed );
				} );
			}
			return transformed;
		};

		function trim( str ) {
			if ( str.trim ) {
				return str.trim();
			}
			return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
		}

		function extractString( unit ) {
			return unit.str;
		}
		return __export;
	}();

	/* config/options/css/css.js */
	var css = function( transformCss ) {

		var cssConfig = {
			name: 'css',
			extend: extend,
			init: function() {}
		};

		function extend( Parent, proto, options ) {
			var guid = proto.constructor._guid,
				css;
			if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
				proto.constructor.css = css;
			}
		}

		function getCss( css, target, guid ) {
			if ( !css ) {
				return;
			}
			return target.noCssTransform ? css : transformCss( css, guid );
		}
		return cssConfig;
	}( transform );

	/* utils/wrapMethod.js */
	var wrapMethod = function() {

		var __export;
		__export = function( method, superMethod, force ) {
			if ( force || needsSuper( method, superMethod ) ) {
				return function() {
					var hasSuper = '_super' in this,
						_super = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = _super;
					}
					return result;
				};
			} else {
				return method;
			}
		};

		function needsSuper( method, superMethod ) {
			return typeof superMethod === 'function' && /_super/.test( method );
		}
		return __export;
	}();

	/* config/options/data.js */
	var data = function( wrap ) {

		var __export;
		var dataConfig = {
			name: 'data',
			extend: extend,
			init: init,
			reset: reset
		};
		__export = dataConfig;

		function combine( Parent, target, options ) {
			var value = options.data || {},
				parentValue = getAddedKeys( Parent.prototype.data );
			if ( typeof value !== 'object' && typeof value !== 'function' ) {
				throw new TypeError( 'data option must be an object or a function, "' + value + '" is not valid' );
			}
			return dispatch( parentValue, value );
		}

		function extend( Parent, proto, options ) {
			proto.data = combine( Parent, proto, options );
		}

		function init( Parent, ractive, options ) {
			var value = options.data,
				result = combine( Parent, ractive, options );
			if ( typeof result === 'function' ) {
				result = result.call( ractive, value ) || value;
			}
			return ractive.data = result || {};
		}

		function reset( ractive ) {
			var result = this.init( ractive.constructor, ractive, ractive );
			if ( result ) {
				ractive.data = result;
				return true;
			}
		}

		function getAddedKeys( parent ) {
			// only for functions that had keys added
			if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
				return parent;
			}
			// copy the added keys to temp 'object', otherwise
			// parent would be interpreted as 'function' by dispatch
			var temp = {};
			copy( parent, temp );
			// roll in added keys
			return dispatch( parent, temp );
		}

		function dispatch( parent, child ) {
			if ( typeof child === 'function' ) {
				return extendFn( child, parent );
			} else if ( typeof parent === 'function' ) {
				return fromFn( child, parent );
			} else {
				return fromProperties( child, parent );
			}
		}

		function copy( from, to, fillOnly ) {
			for ( var key in from ) {
				if ( fillOnly && key in to ) {
					continue;
				}
				to[ key ] = from[ key ];
			}
		}

		function fromProperties( child, parent ) {
			child = child || {};
			if ( !parent ) {
				return child;
			}
			copy( parent, child, true );
			return child;
		}

		function fromFn( child, parentFn ) {
			return function( data ) {
				var keys;
				if ( child ) {
					// Track the keys that our on the child,
					// but not on the data. We'll need to apply these
					// after the parent function returns.
					keys = [];
					for ( var key in child ) {
						if ( !data || !( key in data ) ) {
							keys.push( key );
						}
					}
				}
				// call the parent fn, use data if no return value
				data = parentFn.call( this, data ) || data;
				// Copy child keys back onto data. The child keys
				// should take precedence over whatever the
				// parent did with the data.
				if ( keys && keys.length ) {
					data = data || {};
					keys.forEach( function( key ) {
						data[ key ] = child[ key ];
					} );
				}
				return data;
			};
		}

		function extendFn( childFn, parent ) {
			var parentFn;
			if ( typeof parent !== 'function' ) {
				// copy props to data
				parentFn = function( data ) {
					fromProperties( data, parent );
				};
			} else {
				parentFn = function( data ) {
					// give parent function it's own this._super context,
					// otherwise this._super is from child and
					// causes infinite loop
					parent = wrap( parent, function() {}, true );
					return parent.call( this, data ) || data;
				};
			}
			return wrap( childFn, parentFn );
		}
		return __export;
	}( wrapMethod );

	/* config/types.js */
	var types = {
		TEXT: 1,
		INTERPOLATOR: 2,
		TRIPLE: 3,
		SECTION: 4,
		INVERTED: 5,
		CLOSING: 6,
		ELEMENT: 7,
		PARTIAL: 8,
		COMMENT: 9,
		DELIMCHANGE: 10,
		MUSTACHE: 11,
		TAG: 12,
		ATTRIBUTE: 13,
		CLOSING_TAG: 14,
		COMPONENT: 15,
		NUMBER_LITERAL: 20,
		STRING_LITERAL: 21,
		ARRAY_LITERAL: 22,
		OBJECT_LITERAL: 23,
		BOOLEAN_LITERAL: 24,
		GLOBAL: 26,
		KEY_VALUE_PAIR: 27,
		REFERENCE: 30,
		REFINEMENT: 31,
		MEMBER: 32,
		PREFIX_OPERATOR: 33,
		BRACKETED: 34,
		CONDITIONAL: 35,
		INFIX_OPERATOR: 36,
		INVOCATION: 40,
		SECTION_IF: 50,
		SECTION_UNLESS: 51,
		SECTION_EACH: 52,
		SECTION_WITH: 53,
		SECTION_IF_WITH: 54
	};

	/* utils/create.js */
	var create = function() {

		var create;
		try {
			Object.create( null );
			create = Object.create;
		} catch ( err ) {
			// sigh
			create = function() {
				var F = function() {};
				return function( proto, props ) {
					var obj;
					if ( proto === null ) {
						return {};
					}
					F.prototype = proto;
					obj = new F();
					if ( props ) {
						Object.defineProperties( obj, props );
					}
					return obj;
				};
			}();
		}
		return create;
	}();

	/* parse/Parser/expressions/shared/errors.js */
	var parse_Parser_expressions_shared_errors = {
		expectedExpression: 'Expected a JavaScript expression',
		expectedParen: 'Expected closing paren'
	};

	/* parse/Parser/expressions/primary/literal/numberLiteral.js */
	var numberLiteral = function( types ) {

		var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		return function( parser ) {
			var result;
			if ( result = parser.matchPattern( numberPattern ) ) {
				return {
					t: types.NUMBER_LITERAL,
					v: result
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
	var booleanLiteral = function( types ) {

		return function( parser ) {
			var remaining = parser.remaining();
			if ( remaining.substr( 0, 4 ) === 'true' ) {
				parser.pos += 4;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'true'
				};
			}
			if ( remaining.substr( 0, 5 ) === 'false' ) {
				parser.pos += 5;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'false'
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
	var makeQuotedStringMatcher = function() {

		var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
		// Match one or more characters until: ", ', \, or EOL/EOF.
		// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
		stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
		// Match one escape sequence, including the backslash.
		escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
		// Match one ES5 line continuation (backslash + line terminator).
		lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
		// Helper for defining getDoubleQuotedString and getSingleQuotedString.
		return function( okQuote ) {
			return function( parser ) {
				var start, literal, done, next;
				start = parser.pos;
				literal = '"';
				done = false;
				while ( !done ) {
					next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
					if ( next ) {
						if ( next === '"' ) {
							literal += '\\"';
						} else if ( next === '\\\'' ) {
							literal += '\'';
						} else {
							literal += next;
						}
					} else {
						next = parser.matchPattern( lineContinuationPattern );
						if ( next ) {
							// convert \(newline-like) into a \u escape, which is allowed in JSON
							literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
						} else {
							done = true;
						}
					}
				}
				literal += '"';
				// use JSON.parse to interpret escapes
				return JSON.parse( literal );
			};
		};
	}();

	/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
	var singleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '"' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
	var doubleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '\'' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
	var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

		return function( parser ) {
			var start, string;
			start = parser.pos;
			if ( parser.matchString( '"' ) ) {
				string = getDoubleQuotedString( parser );
				if ( !parser.matchString( '"' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			if ( parser.matchString( '\'' ) ) {
				string = getSingleQuotedString( parser );
				if ( !parser.matchString( '\'' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			return null;
		};
	}( types, singleQuotedString, doubleQuotedString );

	/* parse/Parser/expressions/shared/patterns.js */
	var patterns = {
		name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
	};

	/* parse/Parser/expressions/shared/key.js */
	var key = function( getStringLiteral, getNumberLiteral, patterns ) {

		var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		// http://mathiasbynens.be/notes/javascript-properties
		// can be any name, string literal, or number literal
		return function( parser ) {
			var token;
			if ( token = getStringLiteral( parser ) ) {
				return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
			}
			if ( token = getNumberLiteral( parser ) ) {
				return token.v;
			}
			if ( token = parser.matchPattern( patterns.name ) ) {
				return token;
			}
		};
	}( stringLiteral, numberLiteral, patterns );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
	var keyValuePair = function( types, getKey ) {

		return function( parser ) {
			var start, key, value;
			start = parser.pos;
			// allow whitespace between '{' and key
			parser.allowWhitespace();
			key = getKey( parser );
			if ( key === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between key and ':'
			parser.allowWhitespace();
			// next character must be ':'
			if ( !parser.matchString( ':' ) ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between ':' and value
			parser.allowWhitespace();
			// next expression must be a, well... expression
			value = parser.readExpression();
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.KEY_VALUE_PAIR,
				k: key,
				v: value
			};
		};
	}( types, key );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
	var keyValuePairs = function( getKeyValuePair ) {

		return function getKeyValuePairs( parser ) {
			var start, pairs, pair, keyValuePairs;
			start = parser.pos;
			pair = getKeyValuePair( parser );
			if ( pair === null ) {
				return null;
			}
			pairs = [ pair ];
			if ( parser.matchString( ',' ) ) {
				keyValuePairs = getKeyValuePairs( parser );
				if ( !keyValuePairs ) {
					parser.pos = start;
					return null;
				}
				return pairs.concat( keyValuePairs );
			}
			return pairs;
		};
	}( keyValuePair );

	/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
	var objectLiteral = function( types, getKeyValuePairs ) {

		return function( parser ) {
			var start, keyValuePairs;
			start = parser.pos;
			// allow whitespace
			parser.allowWhitespace();
			if ( !parser.matchString( '{' ) ) {
				parser.pos = start;
				return null;
			}
			keyValuePairs = getKeyValuePairs( parser );
			// allow whitespace between final value and '}'
			parser.allowWhitespace();
			if ( !parser.matchString( '}' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.OBJECT_LITERAL,
				m: keyValuePairs
			};
		};
	}( types, keyValuePairs );

	/* parse/Parser/expressions/shared/expressionList.js */
	var expressionList = function( errors ) {

		return function getExpressionList( parser ) {
			var start, expressions, expr, next;
			start = parser.pos;
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( expr === null ) {
				return null;
			}
			expressions = [ expr ];
			// allow whitespace between expression and ','
			parser.allowWhitespace();
			if ( parser.matchString( ',' ) ) {
				next = getExpressionList( parser );
				if ( next === null ) {
					parser.error( errors.expectedExpression );
				}
				next.forEach( append );
			}

			function append( expression ) {
				expressions.push( expression );
			}
			return expressions;
		};
	}( parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
	var arrayLiteral = function( types, getExpressionList ) {

		return function( parser ) {
			var start, expressionList;
			start = parser.pos;
			// allow whitespace before '['
			parser.allowWhitespace();
			if ( !parser.matchString( '[' ) ) {
				parser.pos = start;
				return null;
			}
			expressionList = getExpressionList( parser );
			if ( !parser.matchString( ']' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.ARRAY_LITERAL,
				m: expressionList
			};
		};
	}( types, expressionList );

	/* parse/Parser/expressions/primary/literal/_literal.js */
	var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

		return function( parser ) {
			var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
			return literal;
		};
	}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

	/* parse/Parser/expressions/primary/reference.js */
	var reference = function( types, patterns ) {

		var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
		dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
		getArrayRefinement = function( parser ) {
			var num = parser.matchPattern( arrayMemberPattern );
			if ( num ) {
				return '.' + num;
			}
			return null;
		};
		arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
		// if a reference is a browser global, we don't deference it later, so it needs special treatment
		globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
		// keywords are not valid references, with the exception of `this`
		keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
		return function( parser ) {
			var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
			startPos = parser.pos;
			// we might have a root-level reference
			if ( parser.matchString( '~/' ) ) {
				ancestor = '~/';
			} else {
				// we might have ancestor refs...
				ancestor = '';
				while ( parser.matchString( '../' ) ) {
					ancestor += '../';
				}
			}
			if ( !ancestor ) {
				// we might have an implicit iterator or a restricted reference
				dot = parser.matchString( './' ) || parser.matchString( '.' ) || '';
			}
			name = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';
			// bug out if it's a keyword
			if ( keywords.test( name ) ) {
				parser.pos = startPos;
				return null;
			}
			// if this is a browser global, stop here
			if ( !ancestor && !dot && globals.test( name ) ) {
				return {
					t: types.GLOBAL,
					v: name
				};
			}
			combo = ( ancestor || dot ) + name;
			if ( !combo ) {
				return null;
			}
			while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
				combo += refinement;
			}
			if ( parser.matchString( '(' ) ) {
				// if this is a method invocation (as opposed to a function) we need
				// to strip the method name from the reference combo, else the context
				// will be wrong
				lastDotIndex = combo.lastIndexOf( '.' );
				if ( lastDotIndex !== -1 ) {
					combo = combo.substr( 0, lastDotIndex );
					parser.pos = startPos + combo.length;
				} else {
					parser.pos -= 1;
				}
			}
			return {
				t: types.REFERENCE,
				n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
			};
		};
	}( types, patterns );

	/* parse/Parser/expressions/primary/bracketedExpression.js */
	var bracketedExpression = function( types, errors ) {

		return function( parser ) {
			var start, expr;
			start = parser.pos;
			if ( !parser.matchString( '(' ) ) {
				return null;
			}
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( !expr ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ')' ) ) {
				parser.error( errors.expectedParen );
			}
			return {
				t: types.BRACKETED,
				x: expr
			};
		};
	}( types, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/_primary.js */
	var primary = function( getLiteral, getReference, getBracketedExpression ) {

		return function( parser ) {
			return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
		};
	}( literal, reference, bracketedExpression );

	/* parse/Parser/expressions/shared/refinement.js */
	var refinement = function( types, errors, patterns ) {

		return function getRefinement( parser ) {
			var start, name, expr;
			start = parser.pos;
			parser.allowWhitespace();
			// "." name
			if ( parser.matchString( '.' ) ) {
				parser.allowWhitespace();
				if ( name = parser.matchPattern( patterns.name ) ) {
					return {
						t: types.REFINEMENT,
						n: name
					};
				}
				parser.error( 'Expected a property name' );
			}
			// "[" expression "]"
			if ( parser.matchString( '[' ) ) {
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ']' ) ) {
					parser.error( 'Expected \']\'' );
				}
				return {
					t: types.REFINEMENT,
					x: expr
				};
			}
			return null;
		};
	}( types, parse_Parser_expressions_shared_errors, patterns );

	/* parse/Parser/expressions/memberOrInvocation.js */
	var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

		return function( parser ) {
			var current, expression, refinement, expressionList;
			expression = getPrimary( parser );
			if ( !expression ) {
				return null;
			}
			while ( expression ) {
				current = parser.pos;
				if ( refinement = getRefinement( parser ) ) {
					expression = {
						t: types.MEMBER,
						x: expression,
						r: refinement
					};
				} else if ( parser.matchString( '(' ) ) {
					parser.allowWhitespace();
					expressionList = getExpressionList( parser );
					parser.allowWhitespace();
					if ( !parser.matchString( ')' ) ) {
						parser.error( errors.expectedParen );
					}
					expression = {
						t: types.INVOCATION,
						x: expression
					};
					if ( expressionList ) {
						expression.o = expressionList;
					}
				} else {
					break;
				}
			}
			return expression;
		};
	}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/typeof.js */
	var _typeof = function( types, errors, getMemberOrInvocation ) {

		var getTypeof, makePrefixSequenceMatcher;
		makePrefixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var expression;
				if ( expression = fallthrough( parser ) ) {
					return expression;
				}
				if ( !parser.matchString( symbol ) ) {
					return null;
				}
				parser.allowWhitespace();
				expression = parser.readExpression();
				if ( !expression ) {
					parser.error( errors.expectedExpression );
				}
				return {
					s: symbol,
					o: expression,
					t: types.PREFIX_OPERATOR
				};
			};
		};
		// create all prefix sequence matchers, return getTypeof
		( function() {
			var i, len, matcher, prefixOperators, fallthrough;
			prefixOperators = '! ~ + - typeof'.split( ' ' );
			fallthrough = getMemberOrInvocation;
			for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
				matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// typeof operator is higher precedence than multiplication, so provides the
			// fallthrough for the multiplication sequence matcher we're about to create
			// (we're skipping void and delete)
			getTypeof = fallthrough;
		}() );
		return getTypeof;
	}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

	/* parse/Parser/expressions/logicalOr.js */
	var logicalOr = function( types, getTypeof ) {

		var getLogicalOr, makeInfixSequenceMatcher;
		makeInfixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var start, left, right;
				left = fallthrough( parser );
				if ( !left ) {
					return null;
				}
				// Loop to handle left-recursion in a case like `a * b * c` and produce
				// left association, i.e. `(a * b) * c`.  The matcher can't call itself
				// to parse `left` because that would be infinite regress.
				while ( true ) {
					start = parser.pos;
					parser.allowWhitespace();
					if ( !parser.matchString( symbol ) ) {
						parser.pos = start;
						return left;
					}
					// special case - in operator must not be followed by [a-zA-Z_$0-9]
					if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
						parser.pos = start;
						return left;
					}
					parser.allowWhitespace();
					// right operand must also consist of only higher-precedence operators
					right = fallthrough( parser );
					if ( !right ) {
						parser.pos = start;
						return left;
					}
					left = {
						t: types.INFIX_OPERATOR,
						s: symbol,
						o: [
							left,
							right
						]
					};
				}
			};
		};
		// create all infix sequence matchers, and return getLogicalOr
		( function() {
			var i, len, matcher, infixOperators, fallthrough;
			// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
			// Each sequence matcher will initially fall through to its higher precedence
			// neighbour, and only attempt to match if one of the higher precedence operators
			// (or, ultimately, a literal, reference, or bracketed expression) already matched
			infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
			// A typeof operator is higher precedence than multiplication
			fallthrough = getTypeof;
			for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
				matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// Logical OR is the fallthrough for the conditional matcher
			getLogicalOr = fallthrough;
		}() );
		return getLogicalOr;
	}( types, _typeof );

	/* parse/Parser/expressions/conditional.js */
	var conditional = function( types, getLogicalOr, errors ) {

		return function( parser ) {
			var start, expression, ifTrue, ifFalse;
			expression = getLogicalOr( parser );
			if ( !expression ) {
				return null;
			}
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '?' ) ) {
				parser.pos = start;
				return expression;
			}
			parser.allowWhitespace();
			ifTrue = parser.readExpression();
			if ( !ifTrue ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				parser.error( 'Expected ":"' );
			}
			parser.allowWhitespace();
			ifFalse = parser.readExpression();
			if ( !ifFalse ) {
				parser.error( errors.expectedExpression );
			}
			return {
				t: types.CONDITIONAL,
				o: [
					expression,
					ifTrue,
					ifFalse
				]
			};
		};
	}( types, logicalOr, parse_Parser_expressions_shared_errors );

	/* parse/Parser/utils/flattenExpression.js */
	var flattenExpression = function( types, isObject ) {

		var __export;
		__export = function( expression ) {
			var refs = [],
				flattened;
			extractRefs( expression, refs );
			flattened = {
				r: refs,
				s: stringify( this, expression, refs )
			};
			return flattened;
		};

		function quoteStringLiteral( str ) {
			return JSON.stringify( String( str ) );
		}
		// TODO maybe refactor this?
		function extractRefs( node, refs ) {
			var i, list;
			if ( node.t === types.REFERENCE ) {
				if ( refs.indexOf( node.n ) === -1 ) {
					refs.unshift( node.n );
				}
			}
			list = node.o || node.m;
			if ( list ) {
				if ( isObject( list ) ) {
					extractRefs( list, refs );
				} else {
					i = list.length;
					while ( i-- ) {
						extractRefs( list[ i ], refs );
					}
				}
			}
			if ( node.x ) {
				extractRefs( node.x, refs );
			}
			if ( node.r ) {
				extractRefs( node.r, refs );
			}
			if ( node.v ) {
				extractRefs( node.v, refs );
			}
		}

		function stringify( parser, node, refs ) {
			var stringifyAll = function( item ) {
				return stringify( parser, item, refs );
			};
			switch ( node.t ) {
				case types.BOOLEAN_LITERAL:
				case types.GLOBAL:
				case types.NUMBER_LITERAL:
					return node.v;
				case types.STRING_LITERAL:
					return quoteStringLiteral( node.v );
				case types.ARRAY_LITERAL:
					return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
				case types.OBJECT_LITERAL:
					return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
				case types.KEY_VALUE_PAIR:
					return node.k + ':' + stringify( parser, node.v, refs );
				case types.PREFIX_OPERATOR:
					return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
				case types.INFIX_OPERATOR:
					return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
				case types.INVOCATION:
					return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
				case types.BRACKETED:
					return '(' + stringify( parser, node.x, refs ) + ')';
				case types.MEMBER:
					return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
				case types.REFINEMENT:
					return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
				case types.CONDITIONAL:
					return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
				case types.REFERENCE:
					return '_' + refs.indexOf( node.n );
				default:
					parser.error( 'Expected legal JavaScript' );
			}
		}
		return __export;
	}( types, isObject );

	/* parse/Parser/_Parser.js */
	var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

		var Parser, ParseError, leadingWhitespace = /^\s+/;
		ParseError = function( message ) {
			this.name = 'ParseError';
			this.message = message;
			try {
				throw new Error( message );
			} catch ( e ) {
				this.stack = e.stack;
			}
		};
		ParseError.prototype = Error.prototype;
		Parser = function( str, options ) {
			var items, item, lineStart = 0;
			this.str = str;
			this.options = options || {};
			this.pos = 0;
			this.lines = this.str.split( '\n' );
			this.lineEnds = this.lines.map( function( line ) {
				var lineEnd = lineStart + line.length + 1;
				// +1 for the newline
				lineStart = lineEnd;
				return lineEnd;
			}, 0 );
			// Custom init logic
			if ( this.init )
				this.init( str, options );
			items = [];
			while ( this.pos < this.str.length && ( item = this.read() ) ) {
				items.push( item );
			}
			this.leftover = this.remaining();
			this.result = this.postProcess ? this.postProcess( items, options ) : items;
		};
		Parser.prototype = {
			read: function( converters ) {
				var pos, i, len, item;
				if ( !converters )
					converters = this.converters;
				pos = this.pos;
				len = converters.length;
				for ( i = 0; i < len; i += 1 ) {
					this.pos = pos;
					// reset for each attempt
					if ( item = converters[ i ]( this ) ) {
						return item;
					}
				}
				return null;
			},
			readExpression: function() {
				// The conditional operator is the lowest precedence operator (except yield,
				// assignment operators, and commas, none of which are supported), so we
				// start there. If it doesn't match, it 'falls through' to progressively
				// higher precedence operators, until it eventually matches (or fails to
				// match) a 'primary' - a literal or a reference. This way, the abstract syntax
				// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
				return getConditional( this );
			},
			flattenExpression: flattenExpression,
			getLinePos: function( char ) {
				var lineNum = 0,
					lineStart = 0,
					columnNum;
				while ( char >= this.lineEnds[ lineNum ] ) {
					lineStart = this.lineEnds[ lineNum ];
					lineNum += 1;
				}
				columnNum = char - lineStart;
				return [
					lineNum + 1,
					columnNum + 1,
					char
				];
			},
			error: function( message ) {
				var pos, lineNum, columnNum, line, annotation, error;
				pos = this.getLinePos( this.pos );
				lineNum = pos[ 0 ];
				columnNum = pos[ 1 ];
				line = this.lines[ pos[ 0 ] - 1 ];
				annotation = line + '\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';
				error = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\n' + annotation );
				error.line = pos[ 0 ];
				error.character = pos[ 1 ];
				error.shortMessage = message;
				throw error;
			},
			matchString: function( string ) {
				if ( this.str.substr( this.pos, string.length ) === string ) {
					this.pos += string.length;
					return string;
				}
			},
			matchPattern: function( pattern ) {
				var match;
				if ( match = pattern.exec( this.remaining() ) ) {
					this.pos += match[ 0 ].length;
					return match[ 1 ] || match[ 0 ];
				}
			},
			allowWhitespace: function() {
				this.matchPattern( leadingWhitespace );
			},
			remaining: function() {
				return this.str.substring( this.pos );
			},
			nextChar: function() {
				return this.str.charAt( this.pos );
			}
		};
		Parser.extend = function( proto ) {
			var Parent = this,
				Child, key;
			Child = function( str, options ) {
				Parser.call( this, str, options );
			};
			Child.prototype = create( Parent.prototype );
			for ( key in proto ) {
				if ( hasOwnProperty.call( proto, key ) ) {
					Child.prototype[ key ] = proto[ key ];
				}
			}
			Child.extend = Parser.extend;
			return Child;
		};
		circular.Parser = Parser;
		return Parser;
	}( circular, create, hasOwn, conditional, flattenExpression );

	/* parse/converters/mustache/delimiterChange.js */
	var delimiterChange = function() {

		var delimiterChangePattern = /^[^\s=]+/,
			whitespacePattern = /^\s+/;
		return function( parser ) {
			var start, opening, closing;
			if ( !parser.matchString( '=' ) ) {
				return null;
			}
			start = parser.pos;
			// allow whitespace before new opening delimiter
			parser.allowWhitespace();
			opening = parser.matchPattern( delimiterChangePattern );
			if ( !opening ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace (in fact, it's necessary...)
			if ( !parser.matchPattern( whitespacePattern ) ) {
				return null;
			}
			closing = parser.matchPattern( delimiterChangePattern );
			if ( !closing ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing '='
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			return [
				opening,
				closing
			];
		};
	}();

	/* parse/converters/mustache/delimiterTypes.js */
	var delimiterTypes = [ {
		delimiters: 'delimiters',
		isTriple: false,
		isStatic: false
	}, {
		delimiters: 'tripleDelimiters',
		isTriple: true,
		isStatic: false
	}, {
		delimiters: 'staticDelimiters',
		isTriple: false,
		isStatic: true
	}, {
		delimiters: 'staticTripleDelimiters',
		isTriple: true,
		isStatic: true
	} ];

	/* parse/converters/mustache/type.js */
	var type = function( types ) {

		var mustacheTypes = {
			'#': types.SECTION,
			'^': types.INVERTED,
			'/': types.CLOSING,
			'>': types.PARTIAL,
			'!': types.COMMENT,
			'&': types.TRIPLE
		};
		return function( parser ) {
			var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
			if ( !type ) {
				return null;
			}
			parser.pos += 1;
			return type;
		};
	}( types );

	/* parse/converters/mustache/handlebarsBlockCodes.js */
	var handlebarsBlockCodes = function( types ) {

		return {
			'each': types.SECTION_EACH,
			'if': types.SECTION_IF,
			'if-with': types.SECTION_IF_WITH,
			'with': types.SECTION_WITH,
			'unless': types.SECTION_UNLESS
		};
	}( types );

	/* empty/legacy.js */
	var legacy = null;

	/* parse/converters/mustache/content.js */
	var content = function( types, mustacheType, handlebarsBlockCodes ) {

		var __export;
		var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
			arrayMemberPattern = /^[0-9][1-9]*$/,
			handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
			legalReference;
		legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
		__export = function( parser, delimiterType ) {
			var start, pos, mustache, type, block, expression, i, remaining, index, delimiters;
			start = parser.pos;
			mustache = {};
			delimiters = parser[ delimiterType.delimiters ];
			if ( delimiterType.isStatic ) {
				mustache.s = true;
			}
			// Determine mustache type
			if ( delimiterType.isTriple ) {
				mustache.t = types.TRIPLE;
			} else {
				// We need to test for expressions before we test for mustache type, because
				// an expression that begins '!' looks a lot like a comment
				if ( parser.remaining()[ 0 ] === '!' ) {
					try {
						expression = parser.readExpression();
						// Was it actually an expression, or a comment block in disguise?
						parser.allowWhitespace();
						if ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {
							expression = null;
						} else {
							mustache.t = types.INTERPOLATOR;
						}
					} catch ( err ) {}
					if ( !expression ) {
						index = parser.remaining().indexOf( delimiters[ 1 ] );
						if ( ~index ) {
							parser.pos += index;
						} else {
							parser.error( 'Expected closing delimiter (\'' + delimiters[ 1 ] + '\')' );
						}
						return {
							t: types.COMMENT
						};
					}
				}
				if ( !expression ) {
					type = mustacheType( parser );
					mustache.t = type || types.INTERPOLATOR;
					// default
					// See if there's an explicit section type e.g. {{#with}}...{{/with}}
					if ( type === types.SECTION ) {
						if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
							mustache.n = block;
						}
						parser.allowWhitespace();
					} else if ( type === types.COMMENT || type === types.CLOSING ) {
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];
							parser.pos += index;
							return mustache;
						}
					}
				}
			}
			if ( !expression ) {
				// allow whitespace
				parser.allowWhitespace();
				// get expression
				expression = parser.readExpression();
				// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These
				// cases involve a bit of a hack - we want to turn it into the equivalent of
				// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append
				// a 'contextPartialExpression' to the mustache, and process the context instead of
				// the reference
				var temp;
				if ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {
					mustache = {
						contextPartialExpression: expression
					};
					expression = temp;
				}
				// With certain valid references that aren't valid expressions,
				// e.g. {{1.foo}}, we have a problem: it looks like we've got an
				// expression, but the expression didn't consume the entire
				// reference. So we need to check that the mustache delimiters
				// appear next, unless there's an index reference (i.e. a colon)
				remaining = parser.remaining();
				if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
					pos = parser.pos;
					parser.pos = start;
					remaining = parser.remaining();
					index = remaining.indexOf( delimiters[ 1 ] );
					if ( index !== -1 ) {
						mustache.r = remaining.substr( 0, index ).trim();
						// Check it's a legal reference
						if ( !legalReference.test( mustache.r ) ) {
							parser.error( 'Expected a legal Mustache reference' );
						}
						parser.pos += index;
						return mustache;
					}
					parser.pos = pos;
				}
			}
			refineExpression( parser, expression, mustache );
			// if there was context, process the expression now and save it for later
			if ( mustache.contextPartialExpression ) {
				mustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {
					t: types.PARTIAL
				} ) ];
			}
			// optional index reference
			if ( i = parser.matchPattern( indexRefPattern ) ) {
				mustache.i = i;
			}
			return mustache;
		};

		function refineExpression( parser, expression, mustache ) {
			var referenceExpression;
			if ( expression ) {
				while ( expression.t === types.BRACKETED && expression.x ) {
					expression = expression.x;
				}
				// special case - integers should be treated as array members references,
				// rather than as expressions in their own right
				if ( expression.t === types.REFERENCE ) {
					mustache.r = expression.n;
				} else {
					if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
						mustache.r = expression.v;
					} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
						mustache.rx = referenceExpression;
					} else {
						mustache.x = parser.flattenExpression( expression );
					}
				}
				return mustache;
			}
		}
		// TODO refactor this! it's bewildering
		function getReferenceExpression( parser, expression ) {
			var members = [],
				refinement;
			while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
				refinement = expression.r;
				if ( refinement.x ) {
					if ( refinement.x.t === types.REFERENCE ) {
						members.unshift( refinement.x );
					} else {
						members.unshift( parser.flattenExpression( refinement.x ) );
					}
				} else {
					members.unshift( refinement.n );
				}
				expression = expression.x;
			}
			if ( expression.t !== types.REFERENCE ) {
				return null;
			}
			return {
				r: expression.n,
				m: members
			};
		}
		return __export;
	}( types, type, handlebarsBlockCodes, legacy );

	/* parse/converters/mustache.js */
	var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

		var __export;
		var delimiterChangeToken = {
			t: types.DELIMCHANGE,
			exclude: true
		};
		__export = getMustache;

		function getMustache( parser ) {
			var types;
			// If we're inside a <script> or <style> tag, and we're not
			// interpolating, bug out
			if ( parser.interpolate[ parser.inside ] === false ) {
				return null;
			}
			types = delimiterTypes.slice().sort( function compare( a, b ) {
				// Sort in order of descending opening delimiter length (longer first),
				// to protect against opening delimiters being substrings of each other
				return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
			} );
			return function r( type ) {
				if ( !type ) {
					return null;
				} else {
					return getMustacheOfType( parser, type ) || r( types.shift() );
				}
			}( types.shift() );
		}

		function getMustacheOfType( parser, delimiterType ) {
			var start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;
			start = parser.pos;
			delimiters = parser[ delimiterType.delimiters ];
			if ( !parser.matchString( delimiters[ 0 ] ) ) {
				return null;
			}
			// delimiter change?
			if ( mustache = delimiterChange( parser ) ) {
				// find closing delimiter or abort...
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					return null;
				}
				// ...then make the switch
				parser[ delimiterType.delimiters ] = mustache;
				return delimiterChangeToken;
			}
			parser.allowWhitespace();
			mustache = mustacheContent( parser, delimiterType );
			if ( mustache === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing delimiter
			parser.allowWhitespace();
			if ( !parser.matchString( delimiters[ 1 ] ) ) {
				parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
			}
			if ( mustache.t === types.COMMENT ) {
				mustache.exclude = true;
			}
			if ( mustache.t === types.CLOSING ) {
				parser.sectionDepth -= 1;
				if ( parser.sectionDepth < 0 ) {
					parser.pos = start;
					parser.error( 'Attempted to close a section that wasn\'t open' );
				}
			}
			// partials with context
			if ( mustache.contextPartialExpression ) {
				mustache.f = mustache.contextPartialExpression;
				mustache.t = types.SECTION;
				mustache.n = 'with';
				delete mustache.contextPartialExpression;
			} else if ( isSection( mustache ) ) {
				parser.sectionDepth += 1;
				children = [];
				currentChildren = children;
				expectedClose = mustache.n;
				while ( child = parser.read() ) {
					if ( child.t === types.CLOSING ) {
						if ( expectedClose && child.r !== expectedClose ) {
							parser.error( 'Expected {{/' + expectedClose + '}}' );
						}
						break;
					}
					// {{else}} tags require special treatment
					if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
						// no {{else}} allowed in {{#unless}}
						if ( mustache.n === 'unless' ) {
							parser.error( '{{else}} not allowed in {{#unless}}' );
						} else {
							currentChildren = elseChildren = [];
							continue;
						}
					}
					currentChildren.push( child );
				}
				if ( children.length ) {
					mustache.f = children;
				}
				if ( elseChildren && elseChildren.length ) {
					mustache.l = elseChildren;
					if ( mustache.n === 'with' ) {
						mustache.n = 'if-with';
					}
				}
			}
			if ( parser.includeLinePositions ) {
				mustache.p = parser.getLinePos( start );
			}
			// Replace block name with code
			if ( mustache.n ) {
				mustache.n = handlebarsBlockCodes[ mustache.n ];
			} else if ( mustache.t === types.INVERTED ) {
				mustache.t = types.SECTION;
				mustache.n = types.SECTION_UNLESS;
			}
			return mustache;
		}

		function isSection( mustache ) {
			return mustache.t === types.SECTION || mustache.t === types.INVERTED;
		}
		return __export;
	}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

	/* parse/converters/comment.js */
	var comment = function( types ) {

		var OPEN_COMMENT = '<!--',
			CLOSE_COMMENT = '-->';
		return function( parser ) {
			var start, content, remaining, endIndex, comment;
			start = parser.pos;
			if ( !parser.matchString( OPEN_COMMENT ) ) {
				return null;
			}
			remaining = parser.remaining();
			endIndex = remaining.indexOf( CLOSE_COMMENT );
			if ( endIndex === -1 ) {
				parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
			}
			content = remaining.substr( 0, endIndex );
			parser.pos += endIndex + 3;
			comment = {
				t: types.COMMENT,
				c: content
			};
			if ( parser.includeLinePositions ) {
				comment.p = parser.getLinePos( start );
			}
			return comment;
		};
	}( types );

	/* config/voidElementNames.js */
	var voidElementNames = function() {

		var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
		return voidElementNames;
	}();

	/* parse/converters/utils/getLowestIndex.js */
	var getLowestIndex = function( haystack, needles ) {
		var i, index, lowest;
		i = needles.length;
		while ( i-- ) {
			index = haystack.indexOf( needles[ i ] );
			// short circuit
			if ( !index ) {
				return 0;
			}
			if ( index === -1 ) {
				continue;
			}
			if ( !lowest || index < lowest ) {
				lowest = index;
			}
		}
		return lowest || -1;
	};

	/* shared/decodeCharacterReferences.js */
	var decodeCharacterReferences = function() {

		var __export;
		var htmlEntities, controlCharacters, entityPattern;
		htmlEntities = {
			quot: 34,
			amp: 38,
			apos: 39,
			lt: 60,
			gt: 62,
			nbsp: 160,
			iexcl: 161,
			cent: 162,
			pound: 163,
			curren: 164,
			yen: 165,
			brvbar: 166,
			sect: 167,
			uml: 168,
			copy: 169,
			ordf: 170,
			laquo: 171,
			not: 172,
			shy: 173,
			reg: 174,
			macr: 175,
			deg: 176,
			plusmn: 177,
			sup2: 178,
			sup3: 179,
			acute: 180,
			micro: 181,
			para: 182,
			middot: 183,
			cedil: 184,
			sup1: 185,
			ordm: 186,
			raquo: 187,
			frac14: 188,
			frac12: 189,
			frac34: 190,
			iquest: 191,
			Agrave: 192,
			Aacute: 193,
			Acirc: 194,
			Atilde: 195,
			Auml: 196,
			Aring: 197,
			AElig: 198,
			Ccedil: 199,
			Egrave: 200,
			Eacute: 201,
			Ecirc: 202,
			Euml: 203,
			Igrave: 204,
			Iacute: 205,
			Icirc: 206,
			Iuml: 207,
			ETH: 208,
			Ntilde: 209,
			Ograve: 210,
			Oacute: 211,
			Ocirc: 212,
			Otilde: 213,
			Ouml: 214,
			times: 215,
			Oslash: 216,
			Ugrave: 217,
			Uacute: 218,
			Ucirc: 219,
			Uuml: 220,
			Yacute: 221,
			THORN: 222,
			szlig: 223,
			agrave: 224,
			aacute: 225,
			acirc: 226,
			atilde: 227,
			auml: 228,
			aring: 229,
			aelig: 230,
			ccedil: 231,
			egrave: 232,
			eacute: 233,
			ecirc: 234,
			euml: 235,
			igrave: 236,
			iacute: 237,
			icirc: 238,
			iuml: 239,
			eth: 240,
			ntilde: 241,
			ograve: 242,
			oacute: 243,
			ocirc: 244,
			otilde: 245,
			ouml: 246,
			divide: 247,
			oslash: 248,
			ugrave: 249,
			uacute: 250,
			ucirc: 251,
			uuml: 252,
			yacute: 253,
			thorn: 254,
			yuml: 255,
			OElig: 338,
			oelig: 339,
			Scaron: 352,
			scaron: 353,
			Yuml: 376,
			fnof: 402,
			circ: 710,
			tilde: 732,
			Alpha: 913,
			Beta: 914,
			Gamma: 915,
			Delta: 916,
			Epsilon: 917,
			Zeta: 918,
			Eta: 919,
			Theta: 920,
			Iota: 921,
			Kappa: 922,
			Lambda: 923,
			Mu: 924,
			Nu: 925,
			Xi: 926,
			Omicron: 927,
			Pi: 928,
			Rho: 929,
			Sigma: 931,
			Tau: 932,
			Upsilon: 933,
			Phi: 934,
			Chi: 935,
			Psi: 936,
			Omega: 937,
			alpha: 945,
			beta: 946,
			gamma: 947,
			delta: 948,
			epsilon: 949,
			zeta: 950,
			eta: 951,
			theta: 952,
			iota: 953,
			kappa: 954,
			lambda: 955,
			mu: 956,
			nu: 957,
			xi: 958,
			omicron: 959,
			pi: 960,
			rho: 961,
			sigmaf: 962,
			sigma: 963,
			tau: 964,
			upsilon: 965,
			phi: 966,
			chi: 967,
			psi: 968,
			omega: 969,
			thetasym: 977,
			upsih: 978,
			piv: 982,
			ensp: 8194,
			emsp: 8195,
			thinsp: 8201,
			zwnj: 8204,
			zwj: 8205,
			lrm: 8206,
			rlm: 8207,
			ndash: 8211,
			mdash: 8212,
			lsquo: 8216,
			rsquo: 8217,
			sbquo: 8218,
			ldquo: 8220,
			rdquo: 8221,
			bdquo: 8222,
			dagger: 8224,
			Dagger: 8225,
			bull: 8226,
			hellip: 8230,
			permil: 8240,
			prime: 8242,
			Prime: 8243,
			lsaquo: 8249,
			rsaquo: 8250,
			oline: 8254,
			frasl: 8260,
			euro: 8364,
			image: 8465,
			weierp: 8472,
			real: 8476,
			trade: 8482,
			alefsym: 8501,
			larr: 8592,
			uarr: 8593,
			rarr: 8594,
			darr: 8595,
			harr: 8596,
			crarr: 8629,
			lArr: 8656,
			uArr: 8657,
			rArr: 8658,
			dArr: 8659,
			hArr: 8660,
			forall: 8704,
			part: 8706,
			exist: 8707,
			empty: 8709,
			nabla: 8711,
			isin: 8712,
			notin: 8713,
			ni: 8715,
			prod: 8719,
			sum: 8721,
			minus: 8722,
			lowast: 8727,
			radic: 8730,
			prop: 8733,
			infin: 8734,
			ang: 8736,
			and: 8743,
			or: 8744,
			cap: 8745,
			cup: 8746,
			'int': 8747,
			there4: 8756,
			sim: 8764,
			cong: 8773,
			asymp: 8776,
			ne: 8800,
			equiv: 8801,
			le: 8804,
			ge: 8805,
			sub: 8834,
			sup: 8835,
			nsub: 8836,
			sube: 8838,
			supe: 8839,
			oplus: 8853,
			otimes: 8855,
			perp: 8869,
			sdot: 8901,
			lceil: 8968,
			rceil: 8969,
			lfloor: 8970,
			rfloor: 8971,
			lang: 9001,
			rang: 9002,
			loz: 9674,
			spades: 9824,
			clubs: 9827,
			hearts: 9829,
			diams: 9830
		};
		controlCharacters = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
		__export = function decodeCharacterReferences( html ) {
			return html.replace( entityPattern, function( match, entity ) {
				var code;
				// Handle named entities
				if ( entity[ 0 ] !== '#' ) {
					code = htmlEntities[ entity ];
				} else if ( entity[ 1 ] === 'x' ) {
					code = parseInt( entity.substring( 2 ), 16 );
				} else {
					code = parseInt( entity.substring( 1 ), 10 );
				}
				if ( !code ) {
					return match;
				}
				return String.fromCharCode( validateCode( code ) );
			} );
		};
		// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
		// code points with alternatives in some cases - since we're bypassing that mechanism, we need
		// to replace them ourselves
		//
		// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
		function validateCode( code ) {
			if ( !code ) {
				return 65533;
			}
			// line feed becomes generic whitespace
			if ( code === 10 ) {
				return 32;
			}
			// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
			if ( code < 128 ) {
				return code;
			}
			// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
			// to correct the mistake or we'll end up with missing € signs and so on
			if ( code <= 159 ) {
				return controlCharacters[ code - 128 ];
			}
			// basic multilingual plane
			if ( code < 55296 ) {
				return code;
			}
			// UTF-16 surrogate halves
			if ( code <= 57343 ) {
				return 65533;
			}
			// rest of the basic multilingual plane
			if ( code <= 65535 ) {
				return code;
			}
			return 65533;
		}
		return __export;
	}( legacy );

	/* parse/converters/text.js */
	var text = function( getLowestIndex, decodeCharacterReferences ) {

		return function( parser ) {
			var index, remaining, disallowed, barrier;
			remaining = parser.remaining();
			barrier = parser.inside ? '</' + parser.inside : '<';
			if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
				index = remaining.indexOf( barrier );
			} else {
				disallowed = [
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				// http://developers.whatwg.org/syntax.html#syntax-attributes
				if ( parser.inAttribute === true ) {
					// we're inside an unquoted attribute value
					disallowed.push( '"', '\'', '=', '<', '>', '`' );
				} else if ( parser.inAttribute ) {
					// quoted attribute value
					disallowed.push( parser.inAttribute );
				} else {
					disallowed.push( barrier );
				}
				index = getLowestIndex( remaining, disallowed );
			}
			if ( !index ) {
				return null;
			}
			if ( index === -1 ) {
				index = remaining.length;
			}
			parser.pos += index;
			return parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );
		};
	}( getLowestIndex, decodeCharacterReferences );

	/* parse/converters/element/closingTag.js */
	var closingTag = function( types ) {

		var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
		return function( parser ) {
			var tag;
			// are we looking at a closing tag?
			if ( !parser.matchString( '</' ) ) {
				return null;
			}
			if ( tag = parser.matchPattern( closingTagPattern ) ) {
				return {
					t: types.CLOSING_TAG,
					e: tag
				};
			}
			// We have an illegal closing tag, report it
			parser.pos -= 2;
			parser.error( 'Illegal closing tag' );
		};
	}( types );

	/* parse/converters/element/attribute.js */
	var attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {

		var __export;
		var attributeNamePattern = /^[^\s"'>\/=]+/,
			unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
		__export = getAttribute;

		function getAttribute( parser ) {
			var attr, name, value;
			parser.allowWhitespace();
			name = parser.matchPattern( attributeNamePattern );
			if ( !name ) {
				return null;
			}
			attr = {
				name: name
			};
			value = getAttributeValue( parser );
			if ( value ) {
				attr.value = value;
			}
			return attr;
		}

		function getAttributeValue( parser ) {
			var start, valueStart, startDepth, value;
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			parser.allowWhitespace();
			valueStart = parser.pos;
			startDepth = parser.sectionDepth;
			value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
			if ( parser.sectionDepth !== startDepth ) {
				parser.pos = valueStart;
				parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
			}
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			if ( !value.length ) {
				return null;
			}
			if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
				return decodeCharacterReferences( value[ 0 ] );
			}
			return value;
		}

		function getUnquotedAttributeValueToken( parser ) {
			var start, text, haystack, needles, index;
			start = parser.pos;
			text = parser.matchPattern( unquotedAttributeValueTextPattern );
			if ( !text ) {
				return null;
			}
			haystack = text;
			needles = [
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
				text = text.substr( 0, index );
				parser.pos = start + text.length;
			}
			return text;
		}

		function getUnquotedAttributeValue( parser ) {
			var tokens, token;
			parser.inAttribute = true;
			tokens = [];
			token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			}
			if ( !tokens.length ) {
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedAttributeValue( parser, quoteMark ) {
			var start, tokens, token;
			start = parser.pos;
			if ( !parser.matchString( quoteMark ) ) {
				return null;
			}
			parser.inAttribute = quoteMark;
			tokens = [];
			token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			}
			if ( !parser.matchString( quoteMark ) ) {
				parser.pos = start;
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedStringToken( parser, quoteMark ) {
			var start, index, haystack, needles;
			start = parser.pos;
			haystack = parser.remaining();
			needles = [
				quoteMark,
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			index = getLowestIndex( haystack, needles );
			if ( index === -1 ) {
				parser.error( 'Quoted attribute value must have a closing quote' );
			}
			if ( !index ) {
				return null;
			}
			parser.pos += index;
			return haystack.substr( 0, index );
		}
		return __export;
	}( getLowestIndex, mustache, decodeCharacterReferences );

	/* utils/parseJSON.js */
	var parseJSON = function( Parser, getStringLiteral, getKey ) {

		var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
		specials = {
			'true': true,
			'false': false,
			'undefined': undefined,
			'null': null
		};
		specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
		numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		placeholderPattern = /\$\{([^\}]+)\}/g;
		placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
		onlyWhitespace = /^\s*$/;
		JsonParser = Parser.extend( {
			init: function( str, options ) {
				this.values = options.values;
				this.allowWhitespace();
			},
			postProcess: function( result ) {
				if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
					return null;
				}
				return {
					value: result[ 0 ].v
				};
			},
			converters: [

				function getPlaceholder( parser ) {
					var placeholder;
					if ( !parser.values ) {
						return null;
					}
					placeholder = parser.matchPattern( placeholderAtStartPattern );
					if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
						return {
							v: parser.values[ placeholder ]
						};
					}
				},
				function getSpecial( parser ) {
					var special;
					if ( special = parser.matchPattern( specialsPattern ) ) {
						return {
							v: specials[ special ]
						};
					}
				},
				function getNumber( parser ) {
					var number;
					if ( number = parser.matchPattern( numberPattern ) ) {
						return {
							v: +number
						};
					}
				},
				function getString( parser ) {
					var stringLiteral = getStringLiteral( parser ),
						values;
					if ( stringLiteral && ( values = parser.values ) ) {
						return {
							v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
								return $1 in values ? values[ $1 ] : $1;
							} )
						};
					}
					return stringLiteral;
				},
				function getObject( parser ) {
					var result, pair;
					if ( !parser.matchString( '{' ) ) {
						return null;
					}
					result = {};
					parser.allowWhitespace();
					if ( parser.matchString( '}' ) ) {
						return {
							v: result
						};
					}
					while ( pair = getKeyValuePair( parser ) ) {
						result[ pair.key ] = pair.value;
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
					}
					return null;
				},
				function getArray( parser ) {
					var result, valueToken;
					if ( !parser.matchString( '[' ) ) {
						return null;
					}
					result = [];
					parser.allowWhitespace();
					if ( parser.matchString( ']' ) ) {
						return {
							v: result
						};
					}
					while ( valueToken = parser.read() ) {
						result.push( valueToken.v );
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
						parser.allowWhitespace();
					}
					return null;
				}
			]
		} );

		function getKeyValuePair( parser ) {
			var key, valueToken, pair;
			parser.allowWhitespace();
			key = getKey( parser );
			if ( !key ) {
				return null;
			}
			pair = {
				key: key
			};
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				return null;
			}
			parser.allowWhitespace();
			valueToken = parser.read();
			if ( !valueToken ) {
				return null;
			}
			pair.value = valueToken.v;
			return pair;
		}
		return function( str, values ) {
			var parser = new JsonParser( str, {
				values: values
			} );
			return parser.result;
		};
	}( Parser, stringLiteral, key );

	/* parse/converters/element/processDirective.js */
	var processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {

		var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
			ExpressionParser;
		ExpressionParser = Parser.extend( {
			converters: [ conditional ]
		} );
		// TODO clean this up, it's shocking
		return function( tokens ) {
			var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;
			if ( typeof tokens === 'string' ) {
				if ( match = methodCallPattern.exec( tokens ) ) {
					result = {
						m: match[ 1 ]
					};
					args = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';
					parser = new ExpressionParser( args );
					result.a = flattenExpression( parser.result[ 0 ] );
					return result;
				}
				if ( tokens.indexOf( ':' ) === -1 ) {
					return tokens.trim();
				}
				tokens = [ tokens ];
			}
			result = {};
			directiveName = [];
			directiveArgs = [];
			if ( tokens ) {
				while ( tokens.length ) {
					token = tokens.shift();
					if ( typeof token === 'string' ) {
						colonIndex = token.indexOf( ':' );
						if ( colonIndex === -1 ) {
							directiveName.push( token );
						} else {
							// is the colon the first character?
							if ( colonIndex ) {
								// no
								directiveName.push( token.substr( 0, colonIndex ) );
							}
							// if there is anything after the colon in this token, treat
							// it as the first token of the directiveArgs fragment
							if ( token.length > colonIndex + 1 ) {
								directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
							}
							break;
						}
					} else {
						directiveName.push( token );
					}
				}
				directiveArgs = directiveArgs.concat( tokens );
			}
			if ( !directiveName.length ) {
				result = '';
			} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
				result = {
					// TODO is this really necessary? just use the array
					n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
				};
				if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
					parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
					result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
				} else {
					result.d = directiveArgs;
				}
			} else {
				result = directiveName;
			}
			return result;
		};
	}( Parser, conditional, flattenExpression, parseJSON );

	/* parse/converters/element.js */
	var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

		var __export;
		var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
			validTagNameFollower = /^[\s\n\/>]/,
			onPattern = /^on/,
			proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
			reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
			directives = {
				'intro-outro': 't0',
				intro: 't1',
				outro: 't2',
				decorator: 'o'
			},
			exclude = {
				exclude: true
			},
			converters, disallowedContents;
		// Different set of converters, because this time we're looking for closing tags
		converters = [
			getMustache,
			getComment,
			getElement,
			getText,
			getClosingTag
		];
		// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
		disallowedContents = {
			li: [ 'li' ],
			dt: [
				'dt',
				'dd'
			],
			dd: [
				'dt',
				'dd'
			],
			p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
			rt: [
				'rt',
				'rp'
			],
			rp: [
				'rt',
				'rp'
			],
			optgroup: [ 'optgroup' ],
			option: [
				'option',
				'optgroup'
			],
			thead: [
				'tbody',
				'tfoot'
			],
			tbody: [
				'tbody',
				'tfoot'
			],
			tfoot: [ 'tbody' ],
			tr: [
				'tr',
				'tbody'
			],
			td: [
				'td',
				'th',
				'tr'
			],
			th: [
				'td',
				'th',
				'tr'
			]
		};
		__export = getElement;

		function getElement( parser ) {
			var start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
			start = parser.pos;
			if ( parser.inside || parser.inAttribute ) {
				return null;
			}
			if ( !parser.matchString( '<' ) ) {
				return null;
			}
			// if this is a closing tag, abort straight away
			if ( parser.nextChar() === '/' ) {
				return null;
			}
			element = {
				t: types.ELEMENT
			};
			if ( parser.includeLinePositions ) {
				element.p = parser.getLinePos( start );
			}
			if ( parser.matchString( '!' ) ) {
				element.y = 1;
			}
			// element name
			element.e = parser.matchPattern( tagNamePattern );
			if ( !element.e ) {
				return null;
			}
			// next character must be whitespace, closing solidus or '>'
			if ( !validTagNameFollower.test( parser.nextChar() ) ) {
				parser.error( 'Illegal tag name' );
			}
			addProxyEvent = function( name, directive ) {
				var directiveName = directive.n || directive;
				if ( reservedEventNames.test( directiveName ) ) {
					parser.pos -= directiveName.length;
					parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
				}
				element.v[ name ] = directive;
			};
			parser.allowWhitespace();
			// directives and attributes
			while ( attribute = getMustache( parser ) || getAttribute( parser ) ) {
				// regular attributes
				if ( attribute.name ) {
					// intro, outro, decorator
					if ( directiveName = directives[ attribute.name ] ) {
						element[ directiveName ] = processDirective( attribute.value );
					} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
						if ( !element.v )
							element.v = {};
						directive = processDirective( attribute.value );
						addProxyEvent( match[ 1 ], directive );
					} else {
						if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
							if ( !element.a )
								element.a = {};
							element.a[ attribute.name ] = attribute.value || 0;
						}
					}
				} else {
					if ( !element.m )
						element.m = [];
					element.m.push( attribute );
				}
				parser.allowWhitespace();
			}
			// allow whitespace before closing solidus
			parser.allowWhitespace();
			// self-closing solidus?
			if ( parser.matchString( '/' ) ) {
				selfClosing = true;
			}
			// closing angle bracket
			if ( !parser.matchString( '>' ) ) {
				return null;
			}
			lowerCaseName = element.e.toLowerCase();
			if ( !selfClosing && !voidElementNames.test( element.e ) ) {
				// Special case - if we open a script element, further tags should
				// be ignored unless they're a closing script element
				if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
					parser.inside = lowerCaseName;
				}
				children = [];
				while ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {
					// Special case - closing section tag
					if ( child.t === types.CLOSING ) {
						break;
					}
					if ( child.t === types.CLOSING_TAG ) {
						break;
					}
					children.push( child );
				}
				if ( children.length ) {
					element.f = children;
				}
			}
			parser.inside = null;
			if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
				return exclude;
			}
			return element;
		}

		function canContain( name, remaining ) {
			var match, disallowed;
			match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
			disallowed = disallowedContents[ name ];
			if ( !match || !disallowed ) {
				return true;
			}
			return !~disallowed.indexOf( match[ 1 ].toLowerCase() );
		}
		return __export;
	}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

	/* parse/utils/trimWhitespace.js */
	var trimWhitespace = function() {

		var leadingWhitespace = /^[ \t\f\r\n]+/,
			trailingWhitespace = /[ \t\f\r\n]+$/;
		return function( items, leading, trailing ) {
			var item;
			if ( leading ) {
				item = items[ 0 ];
				if ( typeof item === 'string' ) {
					item = item.replace( leadingWhitespace, '' );
					if ( !item ) {
						items.shift();
					} else {
						items[ 0 ] = item;
					}
				}
			}
			if ( trailing ) {
				item = items[ items.length - 1 ];
				if ( typeof item === 'string' ) {
					item = item.replace( trailingWhitespace, '' );
					if ( !item ) {
						items.pop();
					} else {
						items[ items.length - 1 ] = item;
					}
				}
			}
		};
	}();

	/* parse/utils/stripStandalones.js */
	var stripStandalones = function( types ) {

		var __export;
		var leadingLinebreak = /^\s*\r?\n/,
			trailingLinebreak = /\r?\n\s*$/;
		__export = function( items ) {
			var i, current, backOne, backTwo, lastSectionItem;
			for ( i = 1; i < items.length; i += 1 ) {
				current = items[ i ];
				backOne = items[ i - 1 ];
				backTwo = items[ i - 2 ];
				// if we're at the end of a [text][comment][text] sequence...
				if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
					// ... and the comment is a standalone (i.e. line breaks either side)...
					if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
						// ... then we want to remove the whitespace after the first line break
						items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
						// and the leading line break of the second text token
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
				// if the current item is a section, and it is preceded by a linebreak, and
				// its first item is a linebreak...
				if ( isSection( current ) && isString( backOne ) ) {
					if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
						items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
						current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
					}
				}
				// if the last item was a section, and it is followed by a linebreak, and
				// its last item is a linebreak...
				if ( isString( current ) && isSection( backOne ) ) {
					lastSectionItem = backOne.f[ backOne.f.length - 1 ];
					if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
						backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
			}
			return items;
		};

		function isString( item ) {
			return typeof item === 'string';
		}

		function isComment( item ) {
			return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
		}

		function isSection( item ) {
			return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
		}
		return __export;
	}( types );

	/* utils/escapeRegExp.js */
	var escapeRegExp = function() {

		var pattern = /[-/\\^$*+?.()|[\]{}]/g;
		return function escapeRegExp( str ) {
			return str.replace( pattern, '\\$&' );
		};
	}();

	/* parse/_parse.js */
	var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {

		var __export;
		var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
			preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
			leadingWhitespace = /^\s+/,
			trailingWhitespace = /\s+$/;
		StandardParser = Parser.extend( {
			init: function( str, options ) {
				// config
				setDelimiters( options, this );
				this.sectionDepth = 0;
				this.interpolate = {
					script: !options.interpolate || options.interpolate.script !== false,
					style: !options.interpolate || options.interpolate.style !== false
				};
				if ( options.sanitize === true ) {
					options.sanitize = {
						// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
						elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
						eventAttributes: true
					};
				}
				this.sanitizeElements = options.sanitize && options.sanitize.elements;
				this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
				this.includeLinePositions = options.includeLinePositions;
			},
			postProcess: function( items, options ) {
				if ( this.sectionDepth > 0 ) {
					this.error( 'A section was left open' );
				}
				cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
				return items;
			},
			converters: [
				mustache,
				comment,
				element,
				text
			]
		} );
		parse = function( template ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;
			setDelimiters( options );
			inlinePartialStart = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*>\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			inlinePartialEnd = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*\\/\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			result = {
				v: 1
			};
			if ( inlinePartialStart.test( template ) ) {
				remaining = template;
				template = '';
				while ( startMatch = inlinePartialStart.exec( remaining ) ) {
					name = startMatch[ 1 ];
					template += remaining.substr( 0, startMatch.index );
					remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
					endMatch = inlinePartialEnd.exec( remaining );
					if ( !endMatch || endMatch[ 1 ] !== name ) {
						throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for "' + name + '", but ' + ( endMatch ? 'instead found "' + endMatch[ 1 ] + '"' : ' no closing found' ) );
					}
					( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
					remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
				}
				template += remaining;
				result.p = partials;
			}
			result.t = new StandardParser( template, options ).result;
			return result;
		};
		__export = parse;

		function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
			var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
			// First pass - remove standalones and comments etc
			stripStandalones( items );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Remove delimiter changes, unsafe elements etc
				if ( item.exclude ) {
					items.splice( i, 1 );
				} else if ( stripComments && item.t === types.COMMENT ) {
					items.splice( i, 1 );
				}
			}
			// If necessary, remove leading and trailing whitespace
			trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Recurse
				if ( item.f ) {
					preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
					if ( !preserveWhitespaceInsideFragment ) {
						previousItem = items[ i - 1 ];
						nextItem = items[ i + 1 ];
						// if the previous item was a text item with trailing whitespace,
						// remove leading whitespace inside the fragment
						if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
							removeLeadingWhitespaceInsideFragment = true;
						}
						// and vice versa
						if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
							removeTrailingWhitespaceInsideFragment = true;
						}
					}
					cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
				}
				// Split if-else blocks into two (an if, and an unless)
				if ( item.l ) {
					cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					if ( rewriteElse ) {
						unlessBlock = {
							t: 4,
							n: types.SECTION_UNLESS,
							f: item.l
						};
						// copy the conditional based on its type
						if ( item.r ) {
							unlessBlock.r = item.r;
						}
						if ( item.x ) {
							unlessBlock.x = item.x;
						}
						if ( item.rx ) {
							unlessBlock.rx = item.rx;
						}
						items.splice( i + 1, 0, unlessBlock );
						delete item.l;
					}
				}
				// Clean up element attributes
				if ( item.a ) {
					for ( key in item.a ) {
						if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
							cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						}
					}
				}
			}
			// final pass - fuse text nodes together
			i = items.length;
			while ( i-- ) {
				if ( typeof items[ i ] === 'string' ) {
					if ( typeof items[ i + 1 ] === 'string' ) {
						items[ i ] = items[ i ] + items[ i + 1 ];
						items.splice( i + 1, 1 );
					}
					if ( !preserveWhitespace ) {
						items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
					}
					if ( items[ i ] === '' ) {
						items.splice( i, 1 );
					}
				}
			}
		}

		function setDelimiters( source ) {
			var target = arguments[ 1 ];
			if ( target === void 0 )
				target = source;
			target.delimiters = source.delimiters || [
				'{{',
				'}}'
			];
			target.tripleDelimiters = source.tripleDelimiters || [
				'{{{',
				'}}}'
			];
			target.staticDelimiters = source.staticDelimiters || [
				'[[',
				']]'
			];
			target.staticTripleDelimiters = source.staticTripleDelimiters || [
				'[[[',
				']]]'
			];
		}
		return __export;
	}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );

	/* config/options/groups/optionGroup.js */
	var optionGroup = function() {

		return function createOptionGroup( keys, config ) {
			var group = keys.map( config );
			keys.forEach( function( key, i ) {
				group[ key ] = group[ i ];
			} );
			return group;
		};
	}( legacy );

	/* config/options/groups/parseOptions.js */
	var parseOptions = function( optionGroup ) {

		var keys, parseOptions;
		keys = [
			'preserveWhitespace',
			'sanitize',
			'stripComments',
			'delimiters',
			'tripleDelimiters',
			'interpolate'
		];
		parseOptions = optionGroup( keys, function( key ) {
			return key;
		} );
		return parseOptions;
	}( optionGroup );

	/* config/options/template/parser.js */
	var parser = function( errors, isClient, parse, create, parseOptions ) {

		var parser = {
			parse: doParse,
			fromId: fromId,
			isHashedId: isHashedId,
			isParsed: isParsed,
			getParseOptions: getParseOptions,
			createHelper: createHelper
		};

		function createHelper( parseOptions ) {
			var helper = create( parser );
			helper.parse = function( template, options ) {
				return doParse( template, options || parseOptions );
			};
			return helper;
		}

		function doParse( template, parseOptions ) {
			if ( !parse ) {
				throw new Error( errors.missingParser );
			}
			return parse( template, parseOptions || this.options );
		}

		function fromId( id, options ) {
			var template;
			if ( !isClient ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
			}
			if ( isHashedId( id ) ) {
				id = id.substring( 1 );
			}
			if ( !( template = document.getElementById( id ) ) ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Could not find template element with id #' + id );
			}
			if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
			}
			return template.innerHTML;
		}

		function isHashedId( id ) {
			return id && id.charAt( 0 ) === '#';
		}

		function isParsed( template ) {
			return !( typeof template === 'string' );
		}

		function getParseOptions( ractive ) {
			// Could be Ractive or a Component
			if ( ractive.defaults ) {
				ractive = ractive.defaults;
			}
			return parseOptions.reduce( function( val, key ) {
				val[ key ] = ractive[ key ];
				return val;
			}, {} );
		}
		return parser;
	}( errors, isClient, parse, create, parseOptions );

	/* config/options/template/template.js */
	var template = function( parser, parse ) {

		var templateConfig = {
			name: 'template',
			extend: function extend( Parent, proto, options ) {
				var template;
				// only assign if exists
				if ( 'template' in options ) {
					template = options.template;
					if ( typeof template === 'function' ) {
						proto.template = template;
					} else {
						proto.template = parseIfString( template, proto );
					}
				}
			},
			init: function init( Parent, ractive, options ) {
				var template, fn;
				// TODO because of prototypal inheritance, we might just be able to use
				// ractive.template, and not bother passing through the Parent object.
				// At present that breaks the test mocks' expectations
				template = 'template' in options ? options.template : Parent.prototype.template;
				if ( typeof template === 'function' ) {
					fn = template;
					template = getDynamicTemplate( ractive, fn );
					ractive._config.template = {
						fn: fn,
						result: template
					};
				}
				template = parseIfString( template, ractive );
				// TODO the naming of this is confusing - ractive.template refers to [...],
				// but Component.prototype.template refers to {v:1,t:[],p:[]}...
				// it's unnecessary, because the developer never needs to access
				// ractive.template
				ractive.template = template.t;
				if ( template.p ) {
					extendPartials( ractive.partials, template.p );
				}
			},
			reset: function( ractive ) {
				var result = resetValue( ractive ),
					parsed;
				if ( result ) {
					parsed = parseIfString( result, ractive );
					ractive.template = parsed.t;
					extendPartials( ractive.partials, parsed.p, true );
					return true;
				}
			}
		};

		function resetValue( ractive ) {
			var initial = ractive._config.template,
				result;
			// If this isn't a dynamic template, there's nothing to do
			if ( !initial || !initial.fn ) {
				return;
			}
			result = getDynamicTemplate( ractive, initial.fn );
			// TODO deep equality check to prevent unnecessary re-rendering
			// in the case of already-parsed templates
			if ( result !== initial.result ) {
				initial.result = result;
				result = parseIfString( result, ractive );
				return result;
			}
		}

		function getDynamicTemplate( ractive, fn ) {
			var helper = parser.createHelper( parser.getParseOptions( ractive ) );
			return fn.call( ractive, ractive.data, helper );
		}

		function parseIfString( template, ractive ) {
			if ( typeof template === 'string' ) {
				// ID of an element containing the template?
				if ( template[ 0 ] === '#' ) {
					template = parser.fromId( template );
				}
				template = parse( template, parser.getParseOptions( ractive ) );
			} else if ( template.v !== 1 ) {
				throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
			}
			return template;
		}

		function extendPartials( existingPartials, newPartials, overwrite ) {
			if ( !newPartials )
				return;
			// TODO there's an ambiguity here - we need to overwrite in the `reset()`
			// case, but not initially...
			for ( var key in newPartials ) {
				if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
					existingPartials[ key ] = newPartials[ key ];
				}
			}
		}
		return templateConfig;
	}( parser, parse );

	/* config/options/Registry.js */
	var Registry = function( create ) {

		function Registry( name, useDefaults ) {
			this.name = name;
			this.useDefaults = useDefaults;
		}
		Registry.prototype = {
			constructor: Registry,
			extend: function( Parent, proto, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
			},
			init: function( Parent, ractive, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
			},
			configure: function( Parent, target, options ) {
				var name = this.name,
					option = options[ name ],
					registry;
				registry = create( Parent[ name ] );
				for ( var key in option ) {
					registry[ key ] = option[ key ];
				}
				target[ name ] = registry;
			},
			reset: function( ractive ) {
				var registry = ractive[ this.name ];
				var changed = false;
				Object.keys( registry ).forEach( function( key ) {
					var item = registry[ key ];
					if ( item._fn ) {
						if ( item._fn.isOwner ) {
							registry[ key ] = item._fn;
						} else {
							delete registry[ key ];
						}
						changed = true;
					}
				} );
				return changed;
			},
			findOwner: function( ractive, key ) {
				return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
			},
			findConstructor: function( constructor, key ) {
				if ( !constructor ) {
					return;
				}
				return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
			},
			find: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ];
				} );
			},
			findInstance: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ] ? r : void 0;
				} );
			}
		};

		function recurseFind( ractive, fn ) {
			var find, parent;
			if ( find = fn( ractive ) ) {
				return find;
			}
			if ( !ractive.isolated && ( parent = ractive._parent ) ) {
				return recurseFind( parent, fn );
			}
		}
		return Registry;
	}( create, legacy );

	/* config/options/groups/registries.js */
	var registries = function( optionGroup, Registry ) {

		var keys = [
				'adaptors',
				'components',
				'computed',
				'decorators',
				'easing',
				'events',
				'interpolators',
				'partials',
				'transitions'
			],
			registries = optionGroup( keys, function( key ) {
				return new Registry( key, key === 'computed' );
			} );
		return registries;
	}( optionGroup, Registry );

	/* utils/noop.js */
	var noop = function() {};

	/* utils/wrapPrototypeMethod.js */
	var wrapPrototypeMethod = function( noop ) {

		var __export;
		__export = function wrap( parent, name, method ) {
			if ( !/_super/.test( method ) ) {
				return method;
			}
			var wrapper = function wrapSuper() {
				var superMethod = getSuperMethod( wrapper._parent, name ),
					hasSuper = '_super' in this,
					oldSuper = this._super,
					result;
				this._super = superMethod;
				result = method.apply( this, arguments );
				if ( hasSuper ) {
					this._super = oldSuper;
				} else {
					delete this._super;
				}
				return result;
			};
			wrapper._parent = parent;
			wrapper._method = method;
			return wrapper;
		};

		function getSuperMethod( parent, name ) {
			var method;
			if ( name in parent ) {
				var value = parent[ name ];
				if ( typeof value === 'function' ) {
					method = value;
				} else {
					method = function returnValue() {
						return value;
					};
				}
			} else {
				method = noop;
			}
			return method;
		}
		return __export;
	}( noop );

	/* config/deprecate.js */
	var deprecate = function( warn, isArray ) {

		function deprecate( options, deprecated, correct ) {
			if ( deprecated in options ) {
				if ( !( correct in options ) ) {
					warn( getMessage( deprecated, correct ) );
					options[ correct ] = options[ deprecated ];
				} else {
					throw new Error( getMessage( deprecated, correct, true ) );
				}
			}
		}

		function getMessage( deprecated, correct, isError ) {
			return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
		}

		function deprecateEventDefinitions( options ) {
			deprecate( options, 'eventDefinitions', 'events' );
		}

		function deprecateAdaptors( options ) {
			// Using extend with Component instead of options,
			// like Human.extend( Spider ) means adaptors as a registry
			// gets copied to options. So we have to check if actually an array
			if ( isArray( options.adaptors ) ) {
				deprecate( options, 'adaptors', 'adapt' );
			}
		}
		return function deprecateOptions( options ) {
			deprecate( options, 'beforeInit', 'onconstruct' );
			deprecate( options, 'init', 'onrender' );
			deprecate( options, 'complete', 'oncomplete' );
			deprecateEventDefinitions( options );
			deprecateAdaptors( options );
		};
	}( warn, isArray );

	/* config/config.js */
	var config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {

		var custom, options, config, blacklisted;
		// would be nice to not have these here,
		// they get added during initialise, so for now we have
		// to make sure not to try and extend them.
		// Possibly, we could re-order and not add till later
		// in process.
		blacklisted = {
			'_parent': true,
			'_component': true
		};
		custom = {
			data: data,
			template: template,
			css: css
		};
		options = Object.keys( defaults ).filter( function( key ) {
			return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
		} );
		// this defines the order:
		config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
		for ( var key in custom ) {
			config[ key ] = custom[ key ];
		}
		// for iteration
		config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
			return r.name;
		} ) ).concat( [ 'css' ] );
		// add these to blacklisted key's that we don't double extend
		config.keys.forEach( function( key ) {
			return blacklisted[ key ] = true;
		} );
		config.parseOptions = parseOptions;
		config.registries = registries;

		function customConfig( method, key, Parent, instance, options ) {
			custom[ key ][ method ]( Parent, instance, options );
		}
		config.extend = function( Parent, proto, options ) {
			configure( 'extend', Parent, proto, options );
		};
		config.init = function( Parent, ractive, options ) {
			configure( 'init', Parent, ractive, options );
		};

		function isStandardDefaultKey( key ) {
			return key in defaults && !( key in config.parseOptions ) && !( key in custom );
		}

		function configure( method, Parent, instance, options ) {
			deprecate( options );
			customConfig( method, 'data', Parent, instance, options );
			config.parseOptions.forEach( function( key ) {
				if ( key in options ) {
					instance[ key ] = options[ key ];
				}
			} );
			for ( var key in options ) {
				if ( isStandardDefaultKey( key ) ) {
					var value = options[ key ];
					instance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;
				}
			}
			config.registries.forEach( function( registry ) {
				registry[ method ]( Parent, instance, options );
			} );
			customConfig( method, 'template', Parent, instance, options );
			customConfig( method, 'css', Parent, instance, options );
			extendOtherMethods( Parent.prototype, instance, options );
		}

		function extendOtherMethods( parent, instance, options ) {
			for ( var key in options ) {
				if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
					var member = options[ key ];
					// if this is a method that overwrites a method, wrap it:
					if ( typeof member === 'function' ) {
						member = wrapPrototype( parent, key, member );
					}
					instance[ key ] = member;
				}
			}
		}
		config.reset = function( ractive ) {
			return config.filter( function( c ) {
				return c.reset && c.reset( ractive );
			} ).map( function( c ) {
				return c.name;
			} );
		};
		config.getConstructTarget = function( ractive, options ) {
			if ( options.onconstruct ) {
				// pretend this object literal is the ractive instance
				return {
					onconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),
					fire: ractive.fire.bind( ractive )
				};
			} else {
				return ractive;
			}
		};
		return config;
	}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

	/* shared/interpolate.js */
	var interpolate = function( circular, warn, interpolators, config ) {

		var __export;
		var interpolate = function( from, to, ractive, type ) {
			if ( from === to ) {
				return snap( to );
			}
			if ( type ) {
				var interpol = config.registries.interpolators.find( ractive, type );
				if ( interpol ) {
					return interpol( from, to ) || snap( to );
				}
				warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
			}
			return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );
		};
		circular.interpolate = interpolate;
		__export = interpolate;

		function snap( to ) {
			return function() {
				return to;
			};
		}
		return __export;
	}( circular, warn, interpolators, config );

	/* Ractive/prototype/animate/Animation.js */
	var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

		var Animation = function( options ) {
			var key;
			this.startTime = Date.now();
			// from and to
			for ( key in options ) {
				if ( options.hasOwnProperty( key ) ) {
					this[ key ] = options[ key ];
				}
			}
			this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
			this.running = true;
			this.tick();
		};
		Animation.prototype = {
			tick: function() {
				var elapsed, t, value, timeNow, index, keypath;
				keypath = this.keypath;
				if ( this.running ) {
					timeNow = Date.now();
					elapsed = timeNow - this.startTime;
					if ( elapsed >= this.duration ) {
						if ( keypath !== null ) {
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, this.to );
							runloop.end();
						}
						if ( this.step ) {
							this.step( 1, this.to );
						}
						this.complete( this.to );
						index = this.root._animations.indexOf( this );
						// TODO investigate why this happens
						if ( index === -1 ) {
							warn( 'Animation was not found' );
						}
						this.root._animations.splice( index, 1 );
						this.running = false;
						return false;
					}
					t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
					if ( keypath !== null ) {
						value = this.interpolator( t );
						runloop.start( this.root );
						this.root.viewmodel.set( keypath, value );
						runloop.end();
					}
					if ( this.step ) {
						this.step( t, value );
					}
					return true;
				}
				return false;
			},
			stop: function() {
				var index;
				this.running = false;
				index = this.root._animations.indexOf( this );
				// TODO investigate why this happens
				if ( index === -1 ) {
					warn( 'Animation was not found' );
				}
				this.root._animations.splice( index, 1 );
			}
		};
		return Animation;
	}( warn, runloop, interpolate );

	/* Ractive/prototype/animate.js */
	var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

		var __export;
		var noop = function() {},
			noAnimation = {
				stop: noop
			};
		__export = function Ractive$animate( keypath, to, options ) {
			var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
			promise = new Promise( function( fulfil ) {
				fulfilPromise = fulfil;
			} );
			// animate multiple keypaths
			if ( typeof keypath === 'object' ) {
				options = to || {};
				easing = options.easing;
				duration = options.duration;
				animations = [];
				// we don't want to pass the `step` and `complete` handlers, as they will
				// run for each animation! So instead we'll store the handlers and create
				// our own...
				step = options.step;
				complete = options.complete;
				if ( step || complete ) {
					currentValues = {};
					options.step = null;
					options.complete = null;
					makeValueCollector = function( keypath ) {
						return function( t, value ) {
							currentValues[ keypath ] = value;
						};
					};
				}
				for ( k in keypath ) {
					if ( keypath.hasOwnProperty( k ) ) {
						if ( step || complete ) {
							collectValue = makeValueCollector( k );
							options = {
								easing: easing,
								duration: duration
							};
							if ( step ) {
								options.step = collectValue;
							}
						}
						options.complete = complete ? collectValue : noop;
						animations.push( animate( this, k, keypath[ k ], options ) );
					}
				}
				// Create a dummy animation, to facilitate step/complete
				// callbacks, and Promise fulfilment
				dummyOptions = {
					easing: easing,
					duration: duration
				};
				if ( step ) {
					dummyOptions.step = function( t ) {
						step( t, currentValues );
					};
				}
				if ( complete ) {
					promise.then( function( t ) {
						complete( t, currentValues );
					} );
				}
				dummyOptions.complete = fulfilPromise;
				dummy = animate( this, null, null, dummyOptions );
				animations.push( dummy );
				promise.stop = function() {
					var animation;
					while ( animation = animations.pop() ) {
						animation.stop();
					}
					if ( dummy ) {
						dummy.stop();
					}
				};
				return promise;
			}
			// animate a single keypath
			options = options || {};
			if ( options.complete ) {
				promise.then( options.complete );
			}
			options.complete = fulfilPromise;
			animation = animate( this, keypath, to, options );
			promise.stop = function() {
				animation.stop();
			};
			return promise;
		};

		function animate( root, keypath, to, options ) {
			var easing, duration, animation, from;
			if ( keypath ) {
				keypath = normaliseKeypath( keypath );
			}
			if ( keypath !== null ) {
				from = root.viewmodel.get( keypath );
			}
			// cancel any existing animation
			// TODO what about upstream/downstream keypaths?
			animations.abort( keypath, root );
			// don't bother animating values that stay the same
			if ( isEqual( from, to ) ) {
				if ( options.complete ) {
					options.complete( options.to );
				}
				return noAnimation;
			}
			// easing function
			if ( options.easing ) {
				if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = root.easing[ options.easing ];
				}
				if ( typeof easing !== 'function' ) {
					easing = null;
				}
			}
			// duration
			duration = options.duration === undefined ? 400 : options.duration;
			// TODO store keys, use an internal set method
			animation = new Animation( {
				keypath: keypath,
				from: from,
				to: to,
				root: root,
				duration: duration,
				easing: easing,
				interpolator: options.interpolator,
				// TODO wrap callbacks if necessary, to use instance as context
				step: options.step,
				complete: options.complete
			} );
			animations.add( animation );
			root._animations.push( animation );
			return animation;
		}
		return __export;
	}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

	/* Ractive/prototype/detach.js */
	var Ractive$detach = function( Hook, removeFromArray ) {

		var detachHook = new Hook( 'detach' );
		return function Ractive$detach() {
			if ( this.detached ) {
				return this.detached;
			}
			if ( this.el ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.detached = this.fragment.detach();
			detachHook.fire( this );
			return this.detached;
		};
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* Ractive/prototype/find.js */
	var Ractive$find = function Ractive$find( selector ) {
		if ( !this.el ) {
			return null;
		}
		return this.fragment.find( selector );
	};

	/* utils/matches.js */
	var matches = function( isClient, vendors, createElement ) {

		var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
		if ( !isClient ) {
			matches = null;
		} else {
			div = createElement( 'div' );
			methodNames = [
				'matches',
				'matchesSelector'
			];
			makeFunction = function( methodName ) {
				return function( node, selector ) {
					return node[ methodName ]( selector );
				};
			};
			i = methodNames.length;
			while ( i-- && !matches ) {
				unprefixed = methodNames[ i ];
				if ( div[ unprefixed ] ) {
					matches = makeFunction( unprefixed );
				} else {
					j = vendors.length;
					while ( j-- ) {
						prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
						if ( div[ prefixed ] ) {
							matches = makeFunction( prefixed );
							break;
						}
					}
				}
			}
			// IE8...
			if ( !matches ) {
				matches = function( node, selector ) {
					var nodes, parentNode, i;
					parentNode = node.parentNode;
					if ( !parentNode ) {
						// empty dummy <div>
						div.innerHTML = '';
						parentNode = div;
						node = node.cloneNode();
						div.appendChild( node );
					}
					nodes = parentNode.querySelectorAll( selector );
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] === node ) {
							return true;
						}
					}
					return false;
				};
			}
		}
		return matches;
	}( isClient, vendors, createElement );

	/* Ractive/prototype/shared/makeQuery/test.js */
	var Ractive$shared_makeQuery_test = function( matches ) {

		return function( item, noDirty ) {
			var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
			if ( itemMatches ) {
				this.push( item.node || item.instance );
				if ( !noDirty ) {
					this._makeDirty();
				}
				return true;
			}
		};
	}( matches );

	/* Ractive/prototype/shared/makeQuery/cancel.js */
	var Ractive$shared_makeQuery_cancel = function() {
		var liveQueries, selector, index;
		liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
		selector = this.selector;
		index = liveQueries.indexOf( selector );
		if ( index !== -1 ) {
			liveQueries.splice( index, 1 );
			liveQueries[ selector ] = null;
		}
	};

	/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
	var Ractive$shared_makeQuery_sortByItemPosition = function() {

		var __export;
		__export = function( a, b ) {
			var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
			ancestryA = getAncestry( a.component || a._ractive.proxy );
			ancestryB = getAncestry( b.component || b._ractive.proxy );
			oldestA = ancestryA[ ancestryA.length - 1 ];
			oldestB = ancestryB[ ancestryB.length - 1 ];
			// remove items from the end of both ancestries as long as they are identical
			// - the final one removed is the closest mutual ancestor
			while ( oldestA && oldestA === oldestB ) {
				ancestryA.pop();
				ancestryB.pop();
				mutualAncestor = oldestA;
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
			}
			// now that we have the mutual ancestor, we can find which is earliest
			oldestA = oldestA.component || oldestA;
			oldestB = oldestB.component || oldestB;
			fragmentA = oldestA.parentFragment;
			fragmentB = oldestB.parentFragment;
			// if both items share a parent fragment, our job is easy
			if ( fragmentA === fragmentB ) {
				indexA = fragmentA.items.indexOf( oldestA );
				indexB = fragmentB.items.indexOf( oldestB );
				// if it's the same index, it means one contains the other,
				// so we see which has the longest ancestry
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			// if mutual ancestor is a section, we first test to see which section
			// fragment comes first
			if ( fragments = mutualAncestor.fragments ) {
				indexA = fragments.indexOf( fragmentA );
				indexB = fragments.indexOf( fragmentB );
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
		};

		function getParent( item ) {
			var parentFragment;
			if ( parentFragment = item.parentFragment ) {
				return parentFragment.owner;
			}
			if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
				return parentFragment.owner;
			}
		}

		function getAncestry( item ) {
			var ancestry, ancestor;
			ancestry = [ item ];
			ancestor = getParent( item );
			while ( ancestor ) {
				ancestry.push( ancestor );
				ancestor = getParent( ancestor );
			}
			return ancestry;
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
	var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

		return function( node, otherNode ) {
			var bitmask;
			if ( node.compareDocumentPosition ) {
				bitmask = node.compareDocumentPosition( otherNode );
				return bitmask & 2 ? 1 : -1;
			}
			// In old IE, we can piggy back on the mechanism for
			// comparing component positions
			return sortByItemPosition( node, otherNode );
		};
	}( Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/sort.js */
	var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

		return function() {
			this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
			this._dirty = false;
		};
	}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/dirty.js */
	var Ractive$shared_makeQuery_dirty = function( runloop ) {

		return function() {
			var this$0 = this;
			if ( !this._dirty ) {
				this._dirty = true;
				// Once the DOM has been updated, ensure the query
				// is correctly ordered
				runloop.scheduleTask( function() {
					this$0._sort();
				} );
			}
		};
	}( runloop );

	/* Ractive/prototype/shared/makeQuery/remove.js */
	var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
		var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
		if ( index !== -1 ) {
			this.splice( index, 1 );
		}
	};

	/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
	var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

		return function makeQuery( ractive, selector, live, isComponentQuery ) {
			var query = [];
			defineProperties( query, {
				selector: {
					value: selector
				},
				live: {
					value: live
				},
				_isComponentQuery: {
					value: isComponentQuery
				},
				_test: {
					value: test
				}
			} );
			if ( !live ) {
				return query;
			}
			defineProperties( query, {
				cancel: {
					value: cancel
				},
				_root: {
					value: ractive
				},
				_sort: {
					value: sort
				},
				_makeDirty: {
					value: dirty
				},
				_remove: {
					value: remove
				},
				_dirty: {
					value: false,
					writable: true
				}
			} );
			return query;
		};
	}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

	/* Ractive/prototype/findAll.js */
	var Ractive$findAll = function( makeQuery ) {

		return function Ractive$findAll( selector, options ) {
			var liveQueries, query;
			if ( !this.el ) {
				return [];
			}
			options = options || {};
			liveQueries = this._liveQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, false );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAll( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findAllComponents.js */
	var Ractive$findAllComponents = function( makeQuery ) {

		return function Ractive$findAllComponents( selector, options ) {
			var liveQueries, query;
			options = options || {};
			liveQueries = this._liveComponentQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, true );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAllComponents( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findComponent.js */
	var Ractive$findComponent = function Ractive$findComponent( selector ) {
		return this.fragment.findComponent( selector );
	};

	/* utils/getPotentialWildcardMatches.js */
	var getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, i, result, wildcardKeypath;
			keys = keypath.split( '.' );
			if ( !( starMap = starMaps[ keys.length ] ) ) {
				starMap = getStarMap( keys.length );
			}
			result = [];
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			i = starMap.length;
			while ( i-- ) {
				wildcardKeypath = starMap[ i ].map( mapper ).join( '.' );
				if ( !result.hasOwnProperty( wildcardKeypath ) ) {
					result.push( wildcardKeypath );
					result[ wildcardKeypath ] = true;
				}
			}
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( num ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ num ] ) {
				starMap = [];
				while ( ones.length < num ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < num ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ num ] = starMap;
			}
			return starMaps[ num ];
		}
		return __export;
	}();

	/* Ractive/prototype/shared/fireEvent.js */
	var Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {

		var __export;
		__export = function fireEvent( ractive, eventName ) {
			var options = arguments[ 2 ];
			if ( options === void 0 )
				options = {};
			if ( !eventName ) {
				return;
			}
			if ( !options.event ) {
				options.event = {
					name: eventName,
					context: ractive.data,
					keypath: '',
					// until event not included as argument default
					_noArg: true
				};
			} else {
				options.event.name = eventName;
			}
			var eventNames = getPotentialWildcardMatches( eventName );
			fireEventAs( ractive, eventNames, options.event, options.args, true );
		};

		function fireEventAs( ractive, eventNames, event, args ) {
			var initialFire = arguments[ 4 ];
			if ( initialFire === void 0 )
				initialFire = false;
			var subscribers, i, bubble = true;
			if ( event ) {
				ractive.event = event;
			}
			for ( i = eventNames.length; i >= 0; i-- ) {
				subscribers = ractive._subs[ eventNames[ i ] ];
				if ( subscribers ) {
					bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
				}
			}
			if ( event ) {
				delete ractive.event;
			}
			if ( ractive._parent && bubble ) {
				if ( initialFire && ractive.component ) {
					var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];
					eventNames = getPotentialWildcardMatches( fullName );
					if ( event ) {
						event.component = ractive;
					}
				}
				fireEventAs( ractive._parent, eventNames, event, args );
			}
		}

		function notifySubscribers( ractive, subscribers, event, args ) {
			var originalEvent = null,
				stopEvent = false;
			if ( event && !event._noArg ) {
				args = [ event ].concat( args );
			}
			for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
				if ( subscribers[ i ].apply( ractive, args ) === false ) {
					stopEvent = true;
				}
			}
			if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
				originalEvent.preventDefault && originalEvent.preventDefault();
				originalEvent.stopPropagation && originalEvent.stopPropagation();
			}
			return !stopEvent;
		}
		return __export;
	}( getPotentialWildcardMatches );

	/* Ractive/prototype/fire.js */
	var Ractive$fire = function( fireEvent ) {

		return function Ractive$fire( eventName ) {
			var options = {
				args: Array.prototype.slice.call( arguments, 1 )
			};
			fireEvent( this, eventName, options );
		};
	}( Ractive$shared_fireEvent );

	/* Ractive/prototype/get.js */
	var Ractive$get = function( normaliseKeypath, resolveRef ) {

		var options = {
			capture: true
		};
		// top-level calls should be intercepted
		return function Ractive$get( keypath ) {
			var value;
			keypath = normaliseKeypath( keypath );
			value = this.viewmodel.get( keypath, options );
			// Create inter-component binding, if necessary
			if ( value === undefined && this._parent && !this.isolated ) {
				if ( resolveRef( this, keypath, this.fragment ) ) {
					// creates binding as side-effect, if appropriate
					value = this.viewmodel.get( keypath );
				}
			}
			return value;
		};
	}( normaliseKeypath, resolveRef );

	/* utils/getElement.js */
	var getElement = function getElement( input ) {
		var output;
		if ( !input || typeof input === 'boolean' ) {
			return;
		}
		if ( typeof window === 'undefined' || !document || !input ) {
			return null;
		}
		// We already have a DOM node - no work to do. (Duck typing alert!)
		if ( input.nodeType ) {
			return input;
		}
		// Get node from string
		if ( typeof input === 'string' ) {
			// try ID first
			output = document.getElementById( input );
			// then as selector, if possible
			if ( !output && document.querySelector ) {
				output = document.querySelector( input );
			}
			// did it work?
			if ( output && output.nodeType ) {
				return output;
			}
		}
		// If we've been given a collection (jQuery, Zepto etc), extract the first item
		if ( input[ 0 ] && input[ 0 ].nodeType ) {
			return input[ 0 ];
		}
		return null;
	};

	/* Ractive/prototype/insert.js */
	var Ractive$insert = function( Hook, getElement ) {

		var __export;
		var insertHook = new Hook( 'insert' );
		__export = function Ractive$insert( target, anchor ) {
			if ( !this.fragment.rendered ) {
				// TODO create, and link to, documentation explaining this
				throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
			}
			target = getElement( target );
			anchor = getElement( anchor ) || null;
			if ( !target ) {
				throw new Error( 'You must specify a valid target to insert into' );
			}
			target.insertBefore( this.detach(), anchor );
			this.el = target;
			( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
			this.detached = null;
			fireInsertHook( this );
		};

		function fireInsertHook( ractive ) {
			insertHook.fire( ractive );
			ractive.findAllComponents( '*' ).forEach( function( child ) {
				fireInsertHook( child.instance );
			} );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, getElement );

	/* Ractive/prototype/merge.js */
	var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

		return function Ractive$merge( keypath, array, options ) {
			var currentArray, promise;
			keypath = normaliseKeypath( keypath );
			currentArray = this.viewmodel.get( keypath );
			// If either the existing value or the new value isn't an
			// array, just do a regular set
			if ( !isArray( currentArray ) || !isArray( array ) ) {
				return this.set( keypath, array, options && options.complete );
			}
			// Manage transitions
			promise = runloop.start( this, true );
			this.viewmodel.merge( keypath, currentArray, array, options );
			runloop.end();
			// attach callback as fulfilment handler, if specified
			if ( options && options.complete ) {
				promise.then( options.complete );
			}
			return promise;
		};
	}( runloop, isArray, normaliseKeypath );

	/* Ractive/prototype/observe/Observer.js */
	var Ractive$observe_Observer = function( runloop, isEqual ) {

		var Observer = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.keypath = keypath;
			this.callback = callback;
			this.defer = options.defer;
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		Observer.prototype = {
			init: function( immediate ) {
				this.value = this.root.get( this.keypath );
				if ( immediate !== false ) {
					this.update();
				} else {
					this.oldValue = this.value;
				}
			},
			setValue: function( value ) {
				var this$0 = this;
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.update();
						} );
					} else {
						this.update();
					}
				}
			},
			update: function() {
				// Prevent infinite loops
				if ( this.updating ) {
					return;
				}
				this.updating = true;
				this.callback.call( this.context, this.value, this.oldValue, this.keypath );
				this.oldValue = this.value;
				this.updating = false;
			}
		};
		return Observer;
	}( runloop, isEqual );

	/* shared/getMatchingKeypaths.js */
	var getMatchingKeypaths = function( isArray ) {

		return function getMatchingKeypaths( ractive, pattern ) {
			var keys, key, matchingKeypaths;
			keys = pattern.split( '.' );
			matchingKeypaths = [ '' ];
			while ( key = keys.shift() ) {
				if ( key === '*' ) {
					// expand to find all valid child keypaths
					matchingKeypaths = matchingKeypaths.reduce( expand, [] );
				} else {
					if ( matchingKeypaths[ 0 ] === '' ) {
						// first key
						matchingKeypaths[ 0 ] = key;
					} else {
						matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
					}
				}
			}
			return matchingKeypaths;

			function expand( matchingKeypaths, keypath ) {
				var value, key, childKeypath;
				value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
				for ( key in value ) {
					if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
						// for benefit of IE8
						childKeypath = keypath ? keypath + '.' + key : key;
						matchingKeypaths.push( childKeypath );
					}
				}
				return matchingKeypaths;
			}

			function concatenate( key ) {
				return function( keypath ) {
					return keypath ? keypath + '.' + key : key;
				};
			}
		};
	}( isArray );

	/* Ractive/prototype/observe/getPattern.js */
	var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

		return function getPattern( ractive, pattern ) {
			var matchingKeypaths, values;
			matchingKeypaths = getMatchingKeypaths( ractive, pattern );
			values = {};
			matchingKeypaths.forEach( function( keypath ) {
				values[ keypath ] = ractive.get( keypath );
			} );
			return values;
		};
	}( getMatchingKeypaths );

	/* Ractive/prototype/observe/PatternObserver.js */
	var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

		var PatternObserver, wildcard = /\*/,
			slice = Array.prototype.slice;
		PatternObserver = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.callback = callback;
			this.defer = options.defer;
			this.keypath = keypath;
			this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
			this.values = {};
			if ( this.defer ) {
				this.proxies = [];
			}
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		PatternObserver.prototype = {
			init: function( immediate ) {
				var values, keypath;
				values = getPattern( this.root, this.keypath );
				if ( immediate !== false ) {
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
				} else {
					this.values = values;
				}
			},
			update: function( keypath ) {
				var this$0 = this;
				var values;
				if ( wildcard.test( keypath ) ) {
					values = getPattern( this.root, keypath );
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
					return;
				}
				// special case - array mutation should not trigger `array.*`
				// pattern observer with `array.length`
				if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
					return;
				}
				if ( this.defer && this.ready ) {
					runloop.scheduleTask( function() {
						return this$0.getProxy( keypath ).update();
					} );
					return;
				}
				this.reallyUpdate( keypath );
			},
			reallyUpdate: function( keypath ) {
				var value, keys, args;
				value = this.root.viewmodel.get( keypath );
				// Prevent infinite loops
				if ( this.updating ) {
					this.values[ keypath ] = value;
					return;
				}
				this.updating = true;
				if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
					keys = slice.call( this.regex.exec( keypath ), 1 );
					args = [
						value,
						this.values[ keypath ],
						keypath
					].concat( keys );
					this.callback.apply( this.context, args );
					this.values[ keypath ] = value;
				}
				this.updating = false;
			},
			getProxy: function( keypath ) {
				var self = this;
				if ( !this.proxies[ keypath ] ) {
					this.proxies[ keypath ] = {
						update: function() {
							self.reallyUpdate( keypath );
						}
					};
				}
				return this.proxies[ keypath ];
			}
		};
		return PatternObserver;
	}( runloop, isEqual, Ractive$observe_getPattern );

	/* Ractive/prototype/observe/getObserverFacade.js */
	var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

		var wildcard = /\*/,
			emptyObject = {};
		return function getObserverFacade( ractive, keypath, callback, options ) {
			var observer, isPatternObserver, cancelled;
			keypath = normaliseKeypath( keypath );
			options = options || emptyObject;
			// pattern observers are treated differently
			if ( wildcard.test( keypath ) ) {
				observer = new PatternObserver( ractive, keypath, callback, options );
				ractive.viewmodel.patternObservers.push( observer );
				isPatternObserver = true;
			} else {
				observer = new Observer( ractive, keypath, callback, options );
			}
			ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
			observer.init( options.init );
			// This flag allows observers to initialise even with undefined values
			observer.ready = true;
			return {
				cancel: function() {
					var index;
					if ( cancelled ) {
						return;
					}
					if ( isPatternObserver ) {
						index = ractive.viewmodel.patternObservers.indexOf( observer );
						ractive.viewmodel.patternObservers.splice( index, 1 );
						ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
					} else {
						ractive.viewmodel.unregister( keypath, observer, 'observers' );
					}
					cancelled = true;
				}
			};
		};
	}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

	/* Ractive/prototype/observe.js */
	var Ractive$observe = function( isObject, getObserverFacade ) {

		return function Ractive$observe( keypath, callback, options ) {
			var observers, map, keypaths, i;
			// Allow a map of keypaths to handlers
			if ( isObject( keypath ) ) {
				options = callback;
				map = keypath;
				observers = [];
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						callback = map[ keypath ];
						observers.push( this.observe( keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			}
			// Allow `ractive.observe( callback )` - i.e. observe entire model
			if ( typeof keypath === 'function' ) {
				options = callback;
				callback = keypath;
				keypath = '';
				return getObserverFacade( this, keypath, callback, options );
			}
			keypaths = keypath.split( ' ' );
			// Single keypath
			if ( keypaths.length === 1 ) {
				return getObserverFacade( this, keypath, callback, options );
			}
			// Multiple space-separated keypaths
			observers = [];
			i = keypaths.length;
			while ( i-- ) {
				keypath = keypaths[ i ];
				if ( keypath ) {
					observers.push( getObserverFacade( this, keypath, callback, options ) );
				}
			}
			return {
				cancel: function() {
					while ( observers.length ) {
						observers.pop().cancel();
					}
				}
			};
		};
	}( isObject, Ractive$observe_getObserverFacade );

	/* Ractive/prototype/shared/trim.js */
	var Ractive$shared_trim = function( str ) {
		return str.trim();
	};

	/* Ractive/prototype/shared/notEmptyString.js */
	var Ractive$shared_notEmptyString = function( str ) {
		return str !== '';
	};

	/* Ractive/prototype/off.js */
	var Ractive$off = function( trim, notEmptyString ) {

		return function Ractive$off( eventName, callback ) {
			var this$0 = this;
			var eventNames;
			// if no arguments specified, remove all callbacks
			if ( !eventName ) {
				// TODO use this code instead, once the following issue has been resolved
				// in PhantomJS (tests are unpassable otherwise!)
				// https://github.com/ariya/phantomjs/issues/11856
				// defineProperty( this, '_subs', { value: create( null ), configurable: true });
				for ( eventName in this._subs ) {
					delete this._subs[ eventName ];
				}
			} else {
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					var subscribers, index;
					// If we have subscribers for this event...
					if ( subscribers = this$0._subs[ eventName ] ) {
						// ...if a callback was specified, only remove that
						if ( callback ) {
							index = subscribers.indexOf( callback );
							if ( index !== -1 ) {
								subscribers.splice( index, 1 );
							}
						} else {
							this$0._subs[ eventName ] = [];
						}
					}
				} );
			}
			return this;
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* Ractive/prototype/on.js */
	var Ractive$on = function( trim, notEmptyString ) {

		return function Ractive$on( eventName, callback ) {
			var this$0 = this;
			var self = this,
				listeners, n, eventNames;
			// allow mutliple listeners to be bound in one go
			if ( typeof eventName === 'object' ) {
				listeners = [];
				for ( n in eventName ) {
					if ( eventName.hasOwnProperty( n ) ) {
						listeners.push( this.on( n, eventName[ n ] ) );
					}
				}
				return {
					cancel: function() {
						var listener;
						while ( listener = listeners.pop() ) {
							listener.cancel();
						}
					}
				};
			}
			// Handle multiple space-separated event names
			eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
			eventNames.forEach( function( eventName ) {
				( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
			} );
			return {
				cancel: function() {
					self.off( eventName, callback );
				}
			};
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* shared/getNewIndices.js */
	var getNewIndices = function() {

		var __export;
		// This function takes an array, the name of a mutator method, and the
		// arguments to call that mutator method with, and returns an array that
		// maps the old indices to their new indices.
		// So if you had something like this...
		//
		//     array = [ 'a', 'b', 'c', 'd' ];
		//     array.push( 'e' );
		//
		// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
		// have changed. If you then did this...
		//
		//     array.unshift( 'z' );
		//
		// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
		// one higher to make room for the 'z'. If you removed an item, the new index
		// would be -1...
		//
		//     array.splice( 2, 2 );
		//
		// ...this would result in [ 0, 1, -1, -1, 2, 3 ].
		//
		// This information is used to enable fast, non-destructive shuffling of list
		// sections when you do e.g. `ractive.splice( 'items', 2, 2 );
		__export = function getNewIndices( array, methodName, args ) {
			var spliceArguments, len, newIndices = [],
				removeStart, removeEnd, balance, i;
			spliceArguments = getSpliceEquivalent( array, methodName, args );
			if ( !spliceArguments ) {
				return null;
			}
			len = array.length;
			balance = spliceArguments.length - 2 - spliceArguments[ 1 ];
			removeStart = Math.min( len, spliceArguments[ 0 ] );
			removeEnd = removeStart + spliceArguments[ 1 ];
			for ( i = 0; i < removeStart; i += 1 ) {
				newIndices.push( i );
			}
			for ( ; i < removeEnd; i += 1 ) {
				newIndices.push( -1 );
			}
			for ( ; i < len; i += 1 ) {
				newIndices.push( i + balance );
			}
			return newIndices;
		};
		// The pop, push, shift an unshift methods can all be represented
		// as an equivalent splice
		function getSpliceEquivalent( array, methodName, args ) {
			switch ( methodName ) {
				case 'splice':
					if ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {
						args[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );
					}
					while ( args.length < 2 ) {
						args.push( 0 );
					}
					// ensure we only remove elements that exist
					args[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );
					return args;
				case 'sort':
				case 'reverse':
					return null;
				case 'pop':
					if ( array.length ) {
						return [
							array.length - 1,
							1
						];
					}
					return null;
				case 'push':
					return [
						array.length,
						0
					].concat( args );
				case 'shift':
					return [
						0,
						1
					];
				case 'unshift':
					return [
						0,
						0
					].concat( args );
			}
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeArrayMethod.js */
	var Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {

		var arrayProto = Array.prototype;
		return function( methodName ) {
			return function( keypath ) {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 1 );
				var array, newIndices = [],
					len, promise, result;
				array = this.get( keypath );
				len = array.length;
				if ( !isArray( array ) ) {
					throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
				}
				newIndices = getNewIndices( array, methodName, args );
				result = arrayProto[ methodName ].apply( array, args );
				promise = runloop.start( this, true ).then( function() {
					return result;
				} );
				if ( !!newIndices ) {
					this.viewmodel.smartUpdate( keypath, array, newIndices );
				} else {
					this.viewmodel.mark( keypath );
				}
				runloop.end();
				return promise;
			};
		};
	}( isArray, runloop, getNewIndices );

	/* Ractive/prototype/pop.js */
	var Ractive$pop = function( makeArrayMethod ) {

		return makeArrayMethod( 'pop' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/push.js */
	var Ractive$push = function( makeArrayMethod ) {

		return makeArrayMethod( 'push' );
	}( Ractive$shared_makeArrayMethod );

	/* global/css.js */
	var global_css = function( circular, isClient, removeFromArray ) {

		var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
			componentsInPage = {},
			styles = [];
		if ( !isClient ) {
			css = null;
		} else {
			circular.push( function() {
				runloop = circular.runloop;
			} );
			styleElement = document.createElement( 'style' );
			styleElement.type = 'text/css';
			head = document.getElementsByTagName( 'head' )[ 0 ];
			inDom = false;
			// Internet Exploder won't let you use styleSheet.innerHTML - we have to
			// use styleSheet.cssText instead
			styleSheet = styleElement.styleSheet;
			update = function() {
				var css;
				if ( styles.length ) {
					css = prefix + styles.join( ' ' );
					if ( styleSheet ) {
						styleSheet.cssText = css;
					} else {
						styleElement.innerHTML = css;
					}
					if ( !inDom ) {
						head.appendChild( styleElement );
						inDom = true;
					}
				} else if ( inDom ) {
					head.removeChild( styleElement );
					inDom = false;
				}
			};
			css = {
				add: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					if ( !componentsInPage[ Component._guid ] ) {
						// we create this counter so that we can in/decrement it as
						// instances are added and removed. When all components are
						// removed, the style is too
						componentsInPage[ Component._guid ] = 0;
						styles.push( Component.css );
						update();
					}
					componentsInPage[ Component._guid ] += 1;
				},
				remove: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					componentsInPage[ Component._guid ] -= 1;
					if ( !componentsInPage[ Component._guid ] ) {
						removeFromArray( styles, Component.css );
						runloop.scheduleTask( update );
					}
				}
			};
		}
		return css;
	}( circular, isClient, removeFromArray );

	/* Ractive/prototype/render.js */
	var Ractive$render = function( css, Hook, getElement, runloop ) {

		var renderHook = new Hook( 'render' ),
			completeHook = new Hook( 'complete' );
		return function Ractive$render( target, anchor ) {
			var this$0 = this;
			var promise, instances, transitionsEnabled;
			// if `noIntro` is `true`, temporarily disable transitions
			transitionsEnabled = this.transitionsEnabled;
			if ( this.noIntro ) {
				this.transitionsEnabled = false;
			}
			promise = runloop.start( this, true );
			runloop.scheduleTask( function() {
				return renderHook.fire( this$0 );
			}, true );
			if ( this.fragment.rendered ) {
				throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
			}
			target = getElement( target ) || this.el;
			anchor = getElement( anchor ) || this.anchor;
			this.el = target;
			this.anchor = anchor;
			// Add CSS, if applicable
			if ( this.constructor.css ) {
				css.add( this.constructor );
			}
			if ( target ) {
				if ( !( instances = target.__ractive_instances__ ) ) {
					target.__ractive_instances__ = [ this ];
				} else {
					instances.push( this );
				}
				if ( anchor ) {
					target.insertBefore( this.fragment.render(), anchor );
				} else {
					target.appendChild( this.fragment.render() );
				}
			}
			runloop.end();
			this.transitionsEnabled = transitionsEnabled;
			// It is now more problematic to know if the complete hook
			// would fire. Method checking is straight-forward, but would
			// also require preflighting event subscriptions. Which seems
			// like more work then just letting the promise happen.
			// But perhaps I'm wrong about that...
			promise.then( function() {
				return completeHook.fire( this$0 );
			} );
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );

	/* virtualdom/Fragment/prototype/bubble.js */
	var virtualdom_Fragment$bubble = function Fragment$bubble() {
		this.dirtyValue = this.dirtyArgs = true;
		if ( this.bound && typeof this.owner.bubble === 'function' ) {
			this.owner.bubble();
		}
	};

	/* virtualdom/Fragment/prototype/detach.js */
	var virtualdom_Fragment$detach = function Fragment$detach() {
		var docFrag;
		if ( this.items.length === 1 ) {
			return this.items[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.items.forEach( function( item ) {
			var node = item.detach();
			// TODO The if {...} wasn't previously required - it is now, because we're
			// forcibly detaching everything to reorder sections after an update. That's
			// a non-ideal brute force approach, implemented to get all the tests to pass
			// - as soon as it's replaced with something more elegant, this should
			// revert to `docFrag.appendChild( item.detach() )`
			if ( node ) {
				docFrag.appendChild( node );
			}
		} );
		return docFrag;
	};

	/* virtualdom/Fragment/prototype/find.js */
	var virtualdom_Fragment$find = function Fragment$find( selector ) {
		var i, len, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.find && ( queryResult = item.find( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findAll.js */
	var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAll ) {
					item.findAll( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findAllComponents.js */
	var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAllComponents ) {
					item.findAllComponents( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findComponent.js */
	var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
		var len, i, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findNextNode.js */
	var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
		var index = item.index,
			node;
		if ( this.items[ index + 1 ] ) {
			node = this.items[ index + 1 ].firstNode();
		} else if ( this.owner === this.root ) {
			if ( !this.owner.component ) {
				// TODO but something else could have been appended to
				// this.root.el, no?
				node = null;
			} else {
				node = this.owner.component.findNextNode();
			}
		} else {
			node = this.owner.findNextNode( this );
		}
		return node;
	};

	/* virtualdom/Fragment/prototype/firstNode.js */
	var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
		if ( this.items && this.items[ 0 ] ) {
			return this.items[ 0 ].firstNode();
		}
		return null;
	};

	/* virtualdom/Fragment/prototype/getNode.js */
	var virtualdom_Fragment$getNode = function Fragment$getNode() {
		var fragment = this;
		do {
			if ( fragment.pElement ) {
				return fragment.pElement.node;
			}
		} while ( fragment = fragment.parent );
		return this.root.detached || this.root.el;
	};

	/* virtualdom/Fragment/prototype/getValue.js */
	var virtualdom_Fragment$getValue = function( parseJSON ) {

		var __export;
		var empty = {};
		__export = function Fragment$getValue() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = empty;
			var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
			asArgs = options.args;
			cachedResult = asArgs ? 'argsList' : 'value';
			dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
			if ( this[ dirtyFlag ] ) {
				source = processItems( this.items, values = {}, this.root._guid );
				parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
				if ( !parsed ) {
					result = asArgs ? [ this.toString() ] : this.toString();
				} else {
					result = parsed.value;
				}
				this[ cachedResult ] = result;
				this[ dirtyFlag ] = false;
			}
			return this[ cachedResult ];
		};

		function processItems( items, values, guid, counter ) {
			counter = counter || 0;
			return items.map( function( item ) {
				var placeholderId, wrapped, value;
				if ( item.text ) {
					return item.text;
				}
				if ( item.fragments ) {
					return item.fragments.map( function( fragment ) {
						return processItems( fragment.items, values, guid, counter );
					} ).join( '' );
				}
				placeholderId = guid + '-' + counter++;
				if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
					value = wrapped.value;
				} else {
					value = item.getValue();
				}
				values[ placeholderId ] = value;
				return '${' + placeholderId + '}';
			} ).join( '' );
		}
		return __export;
	}( parseJSON );

	/* utils/escapeHtml.js */
	var escapeHtml = function() {

		var lessThan = /</g;
		var greaterThan = />/g;
		var amp = /&/g;
		return function escapeHtml( str ) {
			return str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
		};
	}();

	/* utils/detachNode.js */
	var detachNode = function detachNode( node ) {
		if ( node && node.parentNode ) {
			node.parentNode.removeChild( node );
		}
		return node;
	};

	/* virtualdom/items/shared/detach.js */
	var detach = function( detachNode ) {

		return function() {
			return detachNode( this.node );
		};
	}( detachNode );

	/* virtualdom/items/Text.js */
	var Text = function( types, escapeHtml, detach ) {

		var Text = function( options ) {
			this.type = types.TEXT;
			this.text = options.template;
		};
		Text.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.text );
				}
				return this.node;
			},
			toString: function( escape ) {
				return escape ? escapeHtml( this.text ) : this.text;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					return this.detach();
				}
			}
		};
		return Text;
	}( types, escapeHtml, detach );

	/* virtualdom/items/shared/unbind.js */
	var unbind = function unbind() {
		if ( this.registered ) {
			// this was registered as a dependant
			this.root.viewmodel.unregister( this.keypath, this );
		}
		if ( this.resolver ) {
			this.resolver.unbind();
		}
	};

	/* virtualdom/items/shared/Mustache/getValue.js */
	var getValue = function Mustache$getValue() {
		return this.value;
	};

	/* virtualdom/items/shared/utils/startsWithKeypath.js */
	var startsWithKeypath = function startsWithKeypath( target, keypath ) {
		return target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';
	};

	/* virtualdom/items/shared/utils/getNewKeypath.js */
	var getNewKeypath = function( startsWithKeypath ) {

		return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
			// exact match
			if ( targetKeypath === oldKeypath ) {
				return newKeypath !== undefined ? newKeypath : null;
			}
			// partial match based on leading keypath segments
			if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
				return newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
			}
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */
	var ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {

		var ReferenceResolver = function( owner, ref, callback ) {
			var keypath;
			this.ref = ref;
			this.resolved = false;
			this.root = owner.root;
			this.parentFragment = owner.parentFragment;
			this.callback = callback;
			keypath = resolveRef( owner.root, ref, owner.parentFragment );
			if ( keypath !== undefined ) {
				this.resolve( keypath );
			} else {
				runloop.addUnresolved( this );
			}
		};
		ReferenceResolver.prototype = {
			resolve: function( keypath ) {
				this.resolved = true;
				this.keypath = keypath;
				this.callback( keypath );
			},
			forceResolution: function() {
				this.resolve( this.ref );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var keypath;
				if ( this.keypath !== undefined ) {
					keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );
					// was a new keypath created?
					if ( keypath !== undefined ) {
						// resolve it
						this.resolve( keypath );
					}
				}
			},
			unbind: function() {
				if ( !this.resolved ) {
					runloop.removeUnresolved( this );
				}
			}
		};
		return ReferenceResolver;
	}( runloop, resolveRef, getNewKeypath );

	/* virtualdom/items/shared/Resolvers/SpecialResolver.js */
	var SpecialResolver = function() {

		var SpecialResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		SpecialResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					fragment = this.parentFragment;
				if ( ref === '@keypath' ) {
					while ( fragment ) {
						if ( !!fragment.context ) {
							return this.callback( '@' + fragment.context );
						}
						fragment = fragment.parent;
					}
				}
				if ( ref === '@index' || ref === '@key' ) {
					while ( fragment ) {
						if ( fragment.index !== undefined ) {
							return this.callback( '@' + fragment.index );
						}
						fragment = fragment.parent;
					}
				}
				throw new Error( 'Unknown special reference "' + ref + '" - valid references are @index, @key and @keypath' );
			},
			unbind: function() {}
		};
		return SpecialResolver;
	}();

	/* virtualdom/items/shared/Resolvers/IndexResolver.js */
	var IndexResolver = function() {

		var IndexResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		IndexResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					indexRefs = this.parentFragment.indexRefs,
					index = indexRefs[ ref ];
				if ( index !== undefined ) {
					this.callback( '@' + index );
				}
			},
			unbind: function() {}
		};
		return IndexResolver;
	}();

	/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */
	var createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {

		return function createReferenceResolver( owner, ref, callback ) {
			var indexRefs, index;
			if ( ref.charAt( 0 ) === '@' ) {
				return new SpecialResolver( owner, ref, callback );
			}
			indexRefs = owner.parentFragment.indexRefs;
			if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
				return new IndexResolver( owner, ref, callback );
			}
			return new ReferenceResolver( owner, ref, callback );
		};
	}( ReferenceResolver, SpecialResolver, IndexResolver );

	/* shared/getFunctionFromString.js */
	var getFunctionFromString = function() {

		var cache = {};
		return function getFunctionFromString( str, i ) {
			var fn, args;
			if ( cache[ str ] ) {
				return cache[ str ];
			}
			args = [];
			while ( i-- ) {
				args[ i ] = '_' + i;
			}
			fn = new Function( args.join( ',' ), 'return(' + str + ')' );
			cache[ str ] = fn;
			return fn;
		};
	}();

	/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
	var ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {

		var __export;
		var ExpressionResolver, bind = Function.prototype.bind;
		ExpressionResolver = function( owner, parentFragment, expression, callback ) {
			var resolver = this,
				ractive, indexRefs;
			ractive = owner.root;
			resolver.root = ractive;
			resolver.parentFragment = parentFragment;
			resolver.callback = callback;
			resolver.owner = owner;
			resolver.str = expression.s;
			resolver.keypaths = [];
			indexRefs = parentFragment.indexRefs;
			// Create resolvers for each reference
			resolver.pending = expression.r.length;
			resolver.refResolvers = expression.r.map( function( ref, i ) {
				return createReferenceResolver( resolver, ref, function( keypath ) {
					resolver.resolve( i, keypath );
				} );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ExpressionResolver.prototype = {
			bubble: function() {
				if ( !this.ready ) {
					return;
				}
				this.uniqueString = getUniqueString( this.str, this.keypaths );
				this.keypath = getKeypath( this.uniqueString );
				this.createEvaluator();
				this.callback( this.keypath );
			},
			unbind: function() {
				var resolver;
				while ( resolver = this.refResolvers.pop() ) {
					resolver.unbind();
				}
			},
			resolve: function( index, keypath ) {
				this.keypaths[ index ] = keypath;
				this.bubble();
			},
			createEvaluator: function() {
				var this$0 = this;
				var self = this,
					computation, valueGetters, signature, keypath, fn;
				computation = this.root.viewmodel.computations[ this.keypath ];
				// only if it doesn't exist yet!
				if ( !computation ) {
					fn = getFunctionFromString( this.str, this.refResolvers.length );
					valueGetters = this.keypaths.map( function( keypath ) {
						var value;
						if ( keypath === 'undefined' ) {
							return function() {
								return undefined;
							};
						}
						// 'special' keypaths encode a value
						if ( keypath[ 0 ] === '@' ) {
							value = keypath.slice( 1 );
							return isNumeric( value ) ? function() {
								return +value;
							} : function() {
								return value;
							};
						}
						return function() {
							var value = this$0.root.viewmodel.get( keypath );
							if ( typeof value === 'function' ) {
								value = wrapFunction( value, self.root );
							}
							return value;
						};
					} );
					signature = {
						deps: this.keypaths.filter( isValidDependency ),
						get: function() {
							var args = valueGetters.map( call );
							return fn.apply( null, args );
						}
					};
					computation = this.root.viewmodel.compute( this.keypath, signature );
				} else {
					this.root.viewmodel.mark( this.keypath );
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				// TODO only bubble once, no matter how many references are affected by the rebind
				this.refResolvers.forEach( function( r ) {
					return r.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
		};
		__export = ExpressionResolver;

		function call( value ) {
			return value.call();
		}

		function getUniqueString( str, keypaths ) {
			// get string that is unique to this expression
			return str.replace( /_([0-9]+)/g, function( match, $1 ) {
				var keypath, value;
				keypath = keypaths[ $1 ];
				if ( keypath === undefined ) {
					return 'undefined';
				}
				if ( keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					return isNumeric( value ) ? value : '"' + value + '"';
				}
				return keypath;
			} );
		}

		function getKeypath( uniqueString ) {
			// Sanitize by removing any periods or square brackets. Otherwise
			// we can't split the keypath into keys!
			return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
		}

		function isValidDependency( keypath ) {
			return keypath !== undefined && keypath[ 0 ] !== '@';
		}

		function wrapFunction( fn, ractive ) {
			var wrapped, prop, key;
			if ( fn._noWrap ) {
				return fn;
			}
			prop = '__ractive_' + ractive._guid;
			wrapped = fn[ prop ];
			if ( wrapped ) {
				return wrapped;
			} else if ( /this/.test( fn.toString() ) ) {
				defineProperty( fn, prop, {
					value: bind.call( fn, ractive )
				} );
				// Add properties/methods to wrapped function
				for ( key in fn ) {
					if ( fn.hasOwnProperty( key ) ) {
						fn[ prop ][ key ] = fn[ key ];
					}
				}
				return fn[ prop ];
			}
			defineProperty( fn, '__ractive_nowrap', {
				value: fn
			} );
			return fn.__ractive_nowrap;
		}
		return __export;
	}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
	var MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {

		var MemberResolver = function( template, resolver, parentFragment ) {
			var member = this,
				keypath;
			member.resolver = resolver;
			member.root = resolver.root;
			member.parentFragment = parentFragment;
			member.viewmodel = resolver.root.viewmodel;
			if ( typeof template === 'string' ) {
				member.value = template;
			} else if ( template.t === types.REFERENCE ) {
				member.refResolver = createReferenceResolver( this, template.n, function( keypath ) {
					member.resolve( keypath );
				} );
			} else {
				new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
					member.resolve( keypath );
				} );
			}
		};
		MemberResolver.prototype = {
			resolve: function( keypath ) {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				this.keypath = keypath;
				this.value = this.viewmodel.get( keypath );
				this.bind();
				this.resolver.bubble();
			},
			bind: function() {
				this.viewmodel.register( this.keypath, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.refResolver ) {
					this.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			setValue: function( value ) {
				this.value = value;
				this.resolver.bubble();
			},
			unbind: function() {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				if ( this.unresolved ) {
					this.unresolved.unbind();
				}
			},
			forceResolution: function() {
				if ( this.refResolver ) {
					this.refResolver.forceResolution();
				}
			}
		};
		return MemberResolver;
	}( types, createReferenceResolver, ExpressionResolver );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
	var ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {

		var ReferenceExpressionResolver = function( mustache, template, callback ) {
			var this$0 = this;
			var resolver = this,
				ractive, ref, keypath, parentFragment;
			resolver.parentFragment = parentFragment = mustache.parentFragment;
			resolver.root = ractive = mustache.root;
			resolver.mustache = mustache;
			resolver.ref = ref = template.r;
			resolver.callback = callback;
			resolver.unresolved = [];
			// Find base keypath
			if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
				resolver.base = keypath;
			} else {
				resolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {
					resolver.base = keypath;
					resolver.baseResolver = null;
					resolver.bubble();
				} );
			}
			// Find values for members, or mark them as unresolved
			resolver.members = template.m.map( function( template ) {
				return new MemberResolver( template, this$0, parentFragment );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ReferenceExpressionResolver.prototype = {
			getKeypath: function() {
				var values = this.members.map( getValue );
				if ( !values.every( isDefined ) || this.baseResolver ) {
					return null;
				}
				return this.base + '.' + values.join( '.' );
			},
			bubble: function() {
				if ( !this.ready || this.baseResolver ) {
					return;
				}
				this.callback( this.getKeypath() );
			},
			unbind: function() {
				this.members.forEach( unbind );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.members.forEach( function( members ) {
					if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			},
			forceResolution: function() {
				if ( this.baseResolver ) {
					this.base = this.ref;
					this.baseResolver.unbind();
					this.baseResolver = null;
				}
				this.members.forEach( function( m ) {
					return m.forceResolution();
				} );
				this.bubble();
			}
		};

		function getValue( member ) {
			return member.value;
		}

		function isDefined( value ) {
			return value != undefined;
		}

		function unbind( member ) {
			member.unbind();
		}
		return ReferenceExpressionResolver;
	}( resolveRef, ReferenceResolver, MemberResolver );

	/* virtualdom/items/shared/Mustache/initialise.js */
	var initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {

		return function Mustache$init( mustache, options ) {
			var ref, parentFragment, template;
			parentFragment = options.parentFragment;
			template = options.template;
			mustache.root = parentFragment.root;
			mustache.parentFragment = parentFragment;
			mustache.pElement = parentFragment.pElement;
			mustache.template = options.template;
			mustache.index = options.index || 0;
			mustache.isStatic = options.template.s;
			mustache.type = options.template.t;
			mustache.registered = false;
			// if this is a simple mustache, with a reference, we just need to resolve
			// the reference to a keypath
			if ( ref = template.r ) {
				mustache.resolver = new createReferenceResolver( mustache, ref, resolve );
			}
			// if it's an expression, we have a bit more work to do
			if ( options.template.x ) {
				mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
			}
			if ( options.template.rx ) {
				mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
			}
			// Special case - inverted sections
			if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
				mustache.setValue( undefined );
			}

			function resolve( keypath ) {
				mustache.resolve( keypath );
			}

			function resolveAndRebindChildren( newKeypath ) {
				var oldKeypath = mustache.keypath;
				if ( newKeypath !== oldKeypath ) {
					mustache.resolve( newKeypath );
					if ( oldKeypath !== undefined ) {
						mustache.fragments && mustache.fragments.forEach( function( f ) {
							f.rebind( null, null, oldKeypath, newKeypath );
						} );
					}
				}
			}
		};
	}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );

	/* virtualdom/items/shared/Mustache/resolve.js */
	var resolve = function( isNumeric ) {

		return function Mustache$resolve( keypath ) {
			var wasResolved, value, twowayBinding;
			// 'Special' keypaths, e.g. @foo or @7, encode a value
			if ( keypath && keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				if ( isNumeric( value ) ) {
					value = +value;
				}
				this.keypath = keypath;
				this.setValue( value );
				return;
			}
			// If we resolved previously, we need to unregister
			if ( this.registered ) {
				// undefined or null
				this.root.viewmodel.unregister( this.keypath, this );
				this.registered = false;
				wasResolved = true;
			}
			this.keypath = keypath;
			// If the new keypath exists, we need to register
			// with the viewmodel
			if ( keypath != undefined ) {
				// undefined or null
				value = this.root.viewmodel.get( keypath );
				this.root.viewmodel.register( keypath, this );
				this.registered = true;
			}
			// Either way we need to queue up a render (`value`
			// will be `undefined` if there's no keypath)
			this.setValue( value );
			// Two-way bindings need to point to their new target keypath
			if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
				twowayBinding.rebound();
			}
		};
	}( isNumeric );

	/* virtualdom/items/shared/Mustache/rebind.js */
	var rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		// Children first
		if ( this.fragments ) {
			this.fragments.forEach( function( f ) {
				return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			} );
		}
		// Expression mustache?
		if ( this.resolver ) {
			this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/shared/Mustache/_Mustache.js */
	var Mustache = function( getValue, init, resolve, rebind ) {

		return {
			getValue: getValue,
			init: init,
			resolve: resolve,
			rebind: rebind
		};
	}( getValue, initialise, resolve, rebind );

	/* virtualdom/items/Interpolator.js */
	var Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {

		var Interpolator = function( options ) {
			this.type = types.INTERPOLATOR;
			Mustache.init( this, options );
		};
		Interpolator.prototype = {
			update: function() {
				this.node.data = this.value == undefined ? '' : this.value;
			},
			resolve: Mustache.resolve,
			rebind: Mustache.rebind,
			detach: detach,
			unbind: unbind,
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.value != undefined ? this.value : '' );
				}
				return this.node;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					detachNode( this.node );
				}
			},
			getValue: Mustache.getValue,
			// TEMP
			setValue: function( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.node ) {
						runloop.addView( this );
					}
				}
			},
			firstNode: function() {
				return this.node;
			},
			toString: function( escape ) {
				var string = this.value != undefined ? '' + this.value : '';
				return escape ? escapeHtml( string ) : string;
			}
		};
		return Interpolator;
	}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );

	/* virtualdom/items/Section/prototype/bubble.js */
	var virtualdom_items_Section$bubble = function Section$bubble() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Section/prototype/detach.js */
	var virtualdom_items_Section$detach = function Section$detach() {
		var docFrag;
		if ( this.fragments.length === 1 ) {
			return this.fragments[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.fragments.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/find.js */
	var virtualdom_items_Section$find = function Section$find( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].find( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findAll.js */
	var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAll( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findAllComponents.js */
	var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findComponent.js */
	var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findNextNode.js */
	var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
		if ( this.fragments[ fragment.index + 1 ] ) {
			return this.fragments[ fragment.index + 1 ].firstNode();
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/firstNode.js */
	var virtualdom_items_Section$firstNode = function Section$firstNode() {
		var len, i, node;
		if ( len = this.fragments.length ) {
			for ( i = 0; i < len; i += 1 ) {
				if ( node = this.fragments[ i ].firstNode() ) {
					return node;
				}
			}
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/shuffle.js */
	var virtualdom_items_Section$shuffle = function( types, runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$shuffle( newIndices ) {
			var this$0 = this;
			var section = this,
				parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;
			// short circuit any double-updates, and ensure that this isn't applied to
			// non-list sections
			if ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {
				return;
			}
			this.shuffling = true;
			runloop.scheduleTask( function() {
				return this$0.shuffling = false;
			} );
			parentFragment = this.parentFragment;
			reboundFragments = [];
			// first, rebind existing fragments
			newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
				var fragment, by, oldKeypath, newKeypath;
				if ( newIndex === oldIndex ) {
					reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
					return;
				}
				fragment = section.fragments[ oldIndex ];
				if ( firstChange === undefined ) {
					firstChange = oldIndex;
				}
				// does this fragment need to be torn down?
				if ( newIndex === -1 ) {
					section.fragmentsToUnrender.push( fragment );
					fragment.unbind();
					return;
				}
				// Otherwise, it needs to be rebound to a new index
				by = newIndex - oldIndex;
				oldKeypath = section.keypath + '.' + oldIndex;
				newKeypath = section.keypath + '.' + newIndex;
				fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
				fragment.index = newIndex;
				reboundFragments[ newIndex ] = fragment;
			} );
			newLength = this.root.get( this.keypath ).length;
			// If nothing changed with the existing fragments, then we start adding
			// new fragments at the end...
			if ( firstChange === undefined ) {
				// ...unless there are no new fragments to add
				if ( this.length === newLength ) {
					return;
				}
				firstChange = this.length;
			}
			this.length = this.fragments.length = newLength;
			if ( this.rendered ) {
				runloop.addView( this );
			}
			// Prepare new fragment options
			fragmentOptions = {
				template: this.template.f,
				root: this.root,
				owner: this
			};
			if ( this.template.i ) {
				fragmentOptions.indexRef = this.template.i;
			}
			// Add as many new fragments as we need to, or add back existing
			// (detached) fragments
			for ( i = firstChange; i < newLength; i += 1 ) {
				fragment = reboundFragments[ i ];
				if ( !fragment ) {
					this.fragmentsToCreate.push( i );
				}
				this.fragments[ i ] = fragment;
			}
		};
	}( types, runloop, circular );

	/* virtualdom/items/Section/prototype/render.js */
	var virtualdom_items_Section$render = function Section$render() {
		var docFrag;
		docFrag = this.docFrag = document.createDocumentFragment();
		this.update();
		this.rendered = true;
		return docFrag;
	};

	/* utils/isArrayLike.js */
	var isArrayLike = function() {

		var pattern = /^\[object (?:Array|FileList)\]$/,
			toString = Object.prototype.toString;
		return function isArrayLike( obj ) {
			return pattern.test( toString.call( obj ) );
		};
	}();

	/* virtualdom/items/Section/prototype/setValue.js */
	var virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function Section$setValue( value ) {
			var this$0 = this;
			var wrapper, fragmentOptions;
			if ( this.updating ) {
				// If a child of this section causes a re-evaluation - for example, an
				// expression refers to a function that mutates the array that this
				// section depends on - we'll end up with a double rendering bug (see
				// https://github.com/ractivejs/ractive/issues/748). This prevents it.
				return;
			}
			this.updating = true;
			// with sections, we need to get the fake value if we have a wrapped object
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			// If any fragments are awaiting creation after a splice,
			// this is the place to do it
			if ( this.fragmentsToCreate.length ) {
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					pElement: this.pElement,
					owner: this,
					indexRef: this.template.i
				};
				this.fragmentsToCreate.forEach( function( index ) {
					var fragment;
					fragmentOptions.context = this$0.keypath + '.' + index;
					fragmentOptions.index = index;
					fragment = new Fragment( fragmentOptions );
					this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
				} );
				this.fragmentsToCreate.length = 0;
			} else if ( reevaluateSection( this, value ) ) {
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
			this.value = value;
			this.updating = false;
		};

		function reevaluateSection( section, value ) {
			var fragmentOptions = {
				template: section.template.f,
				root: section.root,
				pElement: section.parentFragment.pElement,
				owner: section
			};
			// If we already know the section type, great
			// TODO can this be optimised? i.e. pick an reevaluateSection function during init
			// and avoid doing this each time?
			if ( section.subtype ) {
				switch ( section.subtype ) {
					case types.SECTION_IF:
						return reevaluateConditionalSection( section, value, false, fragmentOptions );
					case types.SECTION_UNLESS:
						return reevaluateConditionalSection( section, value, true, fragmentOptions );
					case types.SECTION_WITH:
						return reevaluateContextSection( section, fragmentOptions );
					case types.SECTION_IF_WITH:
						return reevaluateConditionalContextSection( section, value, fragmentOptions );
					case types.SECTION_EACH:
						if ( isObject( value ) ) {
							return reevaluateListObjectSection( section, value, fragmentOptions );
						}
				}
			}
			// Otherwise we need to work out what sort of section we're dealing with
			section.ordered = !!isArrayLike( value );
			// Ordered list section
			if ( section.ordered ) {
				return reevaluateListSection( section, value, fragmentOptions );
			}
			// Unordered list, or context
			if ( isObject( value ) || typeof value === 'function' ) {
				// Index reference indicates section should be treated as a list
				if ( section.template.i ) {
					return reevaluateListObjectSection( section, value, fragmentOptions );
				}
				// Otherwise, object provides context for contents
				return reevaluateContextSection( section, fragmentOptions );
			}
			// Conditional section
			return reevaluateConditionalSection( section, value, false, fragmentOptions );
		}

		function reevaluateListSection( section, value, fragmentOptions ) {
			var i, length, fragment;
			length = value.length;
			if ( length === section.length ) {
				// Nothing to do
				return false;
			}
			// if the array is shorter than it was previously, remove items
			if ( length < section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
				section.fragmentsToUnrender.forEach( unbind );
			} else {
				if ( length > section.length ) {
					// add any new ones
					for ( i = section.length; i < length; i += 1 ) {
						// append list item to context stack
						fragmentOptions.context = section.keypath + '.' + i;
						fragmentOptions.index = i;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ i ] = fragment );
					}
				}
			}
			section.length = length;
			return true;
		}

		function reevaluateListObjectSection( section, value, fragmentOptions ) {
			var id, i, hasKey, fragment, changed;
			hasKey = section.hasKey || ( section.hasKey = {} );
			// remove any fragments that should no longer exist
			i = section.fragments.length;
			while ( i-- ) {
				fragment = section.fragments[ i ];
				if ( !( fragment.index in value ) ) {
					changed = true;
					fragment.unbind();
					section.fragmentsToUnrender.push( fragment );
					section.fragments.splice( i, 1 );
					hasKey[ fragment.index ] = false;
				}
			}
			// add any that haven't been created yet
			for ( id in value ) {
				if ( !hasKey[ id ] ) {
					changed = true;
					fragmentOptions.context = section.keypath + '.' + id;
					fragmentOptions.index = id;
					if ( section.template.i ) {
						fragmentOptions.indexRef = section.template.i;
					}
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( fragment );
					section.fragments.push( fragment );
					hasKey[ id ] = true;
				}
			}
			section.length = section.fragments.length;
			return changed;
		}

		function reevaluateConditionalContextSection( section, value, fragmentOptions ) {
			if ( value ) {
				return reevaluateContextSection( section, fragmentOptions );
			} else {
				return removeSectionFragments( section );
			}
		}

		function reevaluateContextSection( section, fragmentOptions ) {
			var fragment;
			// ...then if it isn't rendered, render it, adding section.keypath to the context stack
			// (if it is already rendered, then any children dependent on the context stack
			// will update themselves without any prompting)
			if ( !section.length ) {
				// append this section to the context stack
				fragmentOptions.context = section.keypath;
				fragmentOptions.index = 0;
				fragment = new Fragment( fragmentOptions );
				section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
				section.length = 1;
				return true;
			}
		}

		function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
			var doRender, emptyArray, emptyObject, fragment, name;
			emptyArray = isArrayLike( value ) && value.length === 0;
			emptyObject = false;
			if ( !isArrayLike( value ) && isObject( value ) ) {
				emptyObject = true;
				for ( name in value ) {
					emptyObject = false;
					break;
				}
			}
			if ( inverted ) {
				doRender = emptyArray || emptyObject || !value;
			} else {
				doRender = value && !emptyArray && !emptyObject;
			}
			if ( doRender ) {
				if ( !section.length ) {
					// no change to context stack
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
				if ( section.length > 1 ) {
					section.fragmentsToUnrender = section.fragments.splice( 1 );
					section.fragmentsToUnrender.forEach( unbind );
					return true;
				}
			} else {
				return removeSectionFragments( section );
			}
		}

		function removeSectionFragments( section ) {
			if ( section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );
				section.fragmentsToUnrender.forEach( unbind );
				section.length = section.fragmentsToRender.length = 0;
				return true;
			}
		}

		function unbind( fragment ) {
			fragment.unbind();
		}

		function isRendered( fragment ) {
			return fragment.rendered;
		}
		return __export;
	}( types, isArrayLike, isObject, runloop, circular );

	/* virtualdom/items/Section/prototype/toString.js */
	var virtualdom_items_Section$toString = function Section$toString( escape ) {
		var str, i, len;
		str = '';
		i = 0;
		len = this.length;
		for ( i = 0; i < len; i += 1 ) {
			str += this.fragments[ i ].toString( escape );
		}
		return str;
	};

	/* virtualdom/items/Section/prototype/unbind.js */
	var virtualdom_items_Section$unbind = function( unbind ) {

		var __export;
		__export = function Section$unbind() {
			this.fragments.forEach( unbindFragment );
			unbind.call( this );
			this.length = 0;
			this.unbound = true;
		};

		function unbindFragment( fragment ) {
			fragment.unbind();
		}
		return __export;
	}( unbind );

	/* virtualdom/items/Section/prototype/unrender.js */
	var virtualdom_items_Section$unrender = function() {

		var __export;
		__export = function Section$unrender( shouldDestroy ) {
			this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
		};

		function unrenderAndDestroy( fragment ) {
			fragment.unrender( true );
		}

		function unrender( fragment ) {
			fragment.unrender( false );
		}
		return __export;
	}();

	/* virtualdom/items/Section/prototype/update.js */
	var virtualdom_items_Section$update = function Section$update() {
		var fragment, renderIndex, renderedFragments, anchor, target, i, len;
		// `this.renderedFragments` is in the order of the previous render.
		// If fragments have shuffled about, this allows us to quickly
		// reinsert them in the correct place
		renderedFragments = this.renderedFragments;
		// Remove fragments that have been marked for destruction
		while ( fragment = this.fragmentsToUnrender.pop() ) {
			fragment.unrender( true );
			renderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );
		}
		// Render new fragments (but don't insert them yet)
		while ( fragment = this.fragmentsToRender.shift() ) {
			fragment.render();
		}
		if ( this.rendered ) {
			target = this.parentFragment.getNode();
		}
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			fragment = this.fragments[ i ];
			renderIndex = renderedFragments.indexOf( fragment, i );
			// search from current index - it's guaranteed to be the same or higher
			if ( renderIndex === i ) {
				// already in the right place. insert accumulated nodes (if any) and carry on
				if ( this.docFrag.childNodes.length ) {
					anchor = fragment.firstNode();
					target.insertBefore( this.docFrag, anchor );
				}
				continue;
			}
			this.docFrag.appendChild( fragment.detach() );
			// update renderedFragments
			if ( renderIndex !== -1 ) {
				renderedFragments.splice( renderIndex, 1 );
			}
			renderedFragments.splice( i, 0, fragment );
		}
		if ( this.rendered && this.docFrag.childNodes.length ) {
			anchor = this.parentFragment.findNextNode( this );
			target.insertBefore( this.docFrag, anchor );
		}
		// Save the rendering order for next time
		this.renderedFragments = this.fragments.slice();
	};

	/* virtualdom/items/Section/_Section.js */
	var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {

		var Section = function( options ) {
			this.type = types.SECTION;
			this.subtype = options.template.n;
			this.inverted = this.subtype === types.SECTION_UNLESS;
			this.pElement = options.pElement;
			this.fragments = [];
			this.fragmentsToCreate = [];
			this.fragmentsToRender = [];
			this.fragmentsToUnrender = [];
			this.renderedFragments = [];
			this.length = 0;
			// number of times this section is rendered
			Mustache.init( this, options );
		};
		Section.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			shuffle: shuffle,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Section;
	}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

	/* virtualdom/items/Triple/prototype/detach.js */
	var virtualdom_items_Triple$detach = function Triple$detach() {
		var len, i;
		if ( this.docFrag ) {
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				this.docFrag.appendChild( this.nodes[ i ] );
			}
			return this.docFrag;
		}
	};

	/* virtualdom/items/Triple/prototype/find.js */
	var virtualdom_items_Triple$find = function( matches ) {

		return function Triple$find( selector ) {
			var i, len, node, queryResult;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					return node;
				}
				if ( queryResult = node.querySelector( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/findAll.js */
	var virtualdom_items_Triple$findAll = function( matches ) {

		return function Triple$findAll( selector, queryResult ) {
			var i, len, node, queryAllResult, numNodes, j;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					queryResult.push( node );
				}
				if ( queryAllResult = node.querySelectorAll( selector ) ) {
					numNodes = queryAllResult.length;
					for ( j = 0; j < numNodes; j += 1 ) {
						queryResult.push( queryAllResult[ j ] );
					}
				}
			}
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/firstNode.js */
	var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
		if ( this.rendered && this.nodes[ 0 ] ) {
			return this.nodes[ 0 ];
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Triple/helpers/insertHtml.js */
	var insertHtml = function( namespaces, createElement ) {

		var __export;
		var elementCache = {},
			ieBug, ieBlacklist;
		try {
			createElement( 'table' ).innerHTML = 'foo';
		} catch ( err ) {
			ieBug = true;
			ieBlacklist = {
				TABLE: [
					'<table class="x">',
					'</table>'
				],
				THEAD: [
					'<table><thead class="x">',
					'</thead></table>'
				],
				TBODY: [
					'<table><tbody class="x">',
					'</tbody></table>'
				],
				TR: [
					'<table><tr class="x">',
					'</tr></table>'
				],
				SELECT: [
					'<select class="x">',
					'</select>'
				]
			};
		}
		__export = function( html, node, docFrag ) {
			var container, nodes = [],
				wrapper, selectedOption, child, i;
			// render 0 and false
			if ( html != null && html !== '' ) {
				if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
					container = element( 'DIV' );
					container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
					container = container.querySelector( '.x' );
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				} else if ( node.namespaceURI === namespaces.svg ) {
					container = element( 'DIV' );
					container.innerHTML = '<svg class="x">' + html + '</svg>';
					container = container.querySelector( '.x' );
				} else {
					container = element( node.tagName );
					container.innerHTML = html;
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				}
				while ( child = container.firstChild ) {
					nodes.push( child );
					docFrag.appendChild( child );
				}
				// This is really annoying. Extracting <option> nodes from the
				// temporary container <select> causes the remaining ones to
				// become selected. So now we have to deselect them. IE8, you
				// amaze me. You really do
				// ...and now Chrome too
				if ( node.tagName === 'SELECT' ) {
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] !== selectedOption ) {
							nodes[ i ].selected = false;
						}
					}
				}
			}
			return nodes;
		};

		function element( tagName ) {
			return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
		}
		return __export;
	}( namespaces, createElement );

	/* utils/toArray.js */
	var toArray = function toArray( arrayLike ) {
		var array = [],
			i = arrayLike.length;
		while ( i-- ) {
			array[ i ] = arrayLike[ i ];
		}
		return array;
	};

	/* virtualdom/items/Triple/helpers/updateSelect.js */
	var updateSelect = function( toArray ) {

		var __export;
		__export = function updateSelect( parentElement ) {
			var selectedOptions, option, value;
			if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
				return;
			}
			selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
			// If one of them had a `selected` attribute, we need to sync
			// the model to the view
			if ( parentElement.getAttribute( 'multiple' ) ) {
				value = selectedOptions.map( function( o ) {
					return o.value;
				} );
			} else if ( option = selectedOptions[ 0 ] ) {
				value = option.value;
			}
			if ( value !== undefined ) {
				parentElement.binding.setValue( value );
			}
			parentElement.bubble();
		};

		function isSelected( option ) {
			return option.selected;
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Triple/prototype/render.js */
	var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

		return function Triple$render() {
			if ( this.rendered ) {
				throw new Error( 'Attempted to render an item that was already rendered' );
			}
			this.docFrag = document.createDocumentFragment();
			this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
			this.rendered = true;
			return this.docFrag;
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/prototype/setValue.js */
	var virtualdom_items_Triple$setValue = function( runloop ) {

		return function Triple$setValue( value ) {
			var wrapper;
			// TODO is there a better way to approach this?
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			if ( value !== this.value ) {
				this.value = value;
				this.parentFragment.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Triple/prototype/toString.js */
	var virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {

		return function Triple$toString() {
			return this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';
		};
	}( decodeCharacterReferences );

	/* virtualdom/items/Triple/prototype/unrender.js */
	var virtualdom_items_Triple$unrender = function( detachNode ) {

		return function Triple$unrender( shouldDestroy ) {
			if ( this.rendered && shouldDestroy ) {
				this.nodes.forEach( detachNode );
				this.rendered = false;
			}
		};
	}( detachNode );

	/* virtualdom/items/Triple/prototype/update.js */
	var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

		return function Triple$update() {
			var node, parentNode;
			if ( !this.rendered ) {
				return;
			}
			// Remove existing nodes
			while ( this.nodes && this.nodes.length ) {
				node = this.nodes.pop();
				node.parentNode.removeChild( node );
			}
			// Insert new nodes
			parentNode = this.parentFragment.getNode();
			this.nodes = insertHtml( this.value, parentNode, this.docFrag );
			parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/_Triple.js */
	var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

		var Triple = function( options ) {
			this.type = types.TRIPLE;
			Mustache.init( this, options );
		};
		Triple.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Triple;
	}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

	/* virtualdom/items/Element/prototype/bubble.js */
	var virtualdom_items_Element$bubble = function() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Element/prototype/detach.js */
	var virtualdom_items_Element$detach = function Element$detach() {
		var node = this.node,
			parentNode;
		if ( node ) {
			// need to check for parent node - DOM may have been altered
			// by something other than Ractive! e.g. jQuery UI...
			if ( parentNode = node.parentNode ) {
				parentNode.removeChild( node );
			}
			return node;
		}
	};

	/* virtualdom/items/Element/prototype/find.js */
	var virtualdom_items_Element$find = function( matches ) {

		return function( selector ) {
			if ( matches( this.node, selector ) ) {
				return this.node;
			}
			if ( this.fragment && this.fragment.find ) {
				return this.fragment.find( selector );
			}
		};
	}( matches );

	/* virtualdom/items/Element/prototype/findAll.js */
	var virtualdom_items_Element$findAll = function( selector, query ) {
		// Add this node to the query, if applicable, and register the
		// query on this element
		if ( query._test( this, true ) && query.live ) {
			( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
		}
		if ( this.fragment ) {
			this.fragment.findAll( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findAllComponents.js */
	var virtualdom_items_Element$findAllComponents = function( selector, query ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findComponent.js */
	var virtualdom_items_Element$findComponent = function( selector ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( selector );
		}
	};

	/* virtualdom/items/Element/prototype/findNextNode.js */
	var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
		return null;
	};

	/* virtualdom/items/Element/prototype/firstNode.js */
	var virtualdom_items_Element$firstNode = function Element$firstNode() {
		return this.node;
	};

	/* virtualdom/items/Element/prototype/getAttribute.js */
	var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
		if ( !this.attributes || !this.attributes[ name ] ) {
			return;
		}
		return this.attributes[ name ].value;
	};

	/* virtualdom/items/Element/shared/enforceCase.js */
	var enforceCase = function() {

		var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
		svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
		svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
		createMap = function( items ) {
			var map = {},
				i = items.length;
			while ( i-- ) {
				map[ items[ i ].toLowerCase() ] = items[ i ];
			}
			return map;
		};
		map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
		return function( elementName ) {
			var lowerCaseElementName = elementName.toLowerCase();
			return map[ lowerCaseElementName ] || lowerCaseElementName;
		};
	}();

	/* virtualdom/items/Element/Attribute/prototype/bubble.js */
	var virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {

		return function Attribute$bubble() {
			var value = this.fragment.getValue();
			// TODO this can register the attribute multiple times (see render test
			// 'Attribute with nested mustaches')
			if ( !isEqual( value, this.value ) ) {
				// Need to clear old id from ractive.nodes
				if ( this.name === 'id' && this.value ) {
					delete this.root.nodes[ this.value ];
				}
				this.value = value;
				if ( this.name === 'value' && this.node ) {
					// We need to store the value on the DOM like this so we
					// can retrieve it later without it being coerced to a string
					this.node._ractive.value = value;
				}
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop, isEqual );

	/* config/booleanAttributes.js */
	var booleanAttributes = function() {

		// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
		var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
		return booleanAttributes;
	}();

	/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
	var determineNameAndNamespace = function( namespaces, enforceCase ) {

		return function( attribute, name ) {
			var colonIndex, namespacePrefix;
			// are we dealing with a namespaced attribute, e.g. xlink:href?
			colonIndex = name.indexOf( ':' );
			if ( colonIndex !== -1 ) {
				// looks like we are, yes...
				namespacePrefix = name.substr( 0, colonIndex );
				// ...unless it's a namespace *declaration*, which we ignore (on the assumption
				// that only valid namespaces will be used)
				if ( namespacePrefix !== 'xmlns' ) {
					name = name.substring( colonIndex + 1 );
					attribute.name = enforceCase( name );
					attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
					attribute.namespacePrefix = namespacePrefix;
					if ( !attribute.namespace ) {
						throw 'Unknown namespace ("' + namespacePrefix + '")';
					}
					return;
				}
			}
			// SVG attribute names are case sensitive
			attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
		};
	}( namespaces, enforceCase );

	/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
	var getInterpolator = function( types ) {

		return function getInterpolator( attribute ) {
			var items = attribute.fragment.items;
			if ( items.length !== 1 ) {
				return;
			}
			if ( items[ 0 ].type === types.INTERPOLATOR ) {
				return items[ 0 ];
			}
		};
	}( types );

	/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
	var determinePropertyName = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			accesskey: 'accessKey',
			bgcolor: 'bgColor',
			'class': 'className',
			codebase: 'codeBase',
			colspan: 'colSpan',
			contenteditable: 'contentEditable',
			datetime: 'dateTime',
			dirname: 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			ismap: 'isMap',
			maxlength: 'maxLength',
			novalidate: 'noValidate',
			pubdate: 'pubDate',
			readonly: 'readOnly',
			rowspan: 'rowSpan',
			tabindex: 'tabIndex',
			usemap: 'useMap'
		};
		return function( attribute, options ) {
			var propertyName;
			if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
				propertyName = propertyNames[ attribute.name ] || attribute.name;
				if ( options.pNode[ propertyName ] !== undefined ) {
					attribute.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					attribute.useProperty = true;
				}
			}
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/init.js */
	var virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Attribute$init( options ) {
			this.type = types.ATTRIBUTE;
			this.element = options.element;
			this.root = options.root;
			determineNameAndNamespace( this, options.name );
			// if it's an empty attribute, or just a straight key-value pair, with no
			// mustache shenanigans, set the attribute accordingly and go home
			if ( !options.value || typeof options.value === 'string' ) {
				this.value = booleanAttributes.test( this.name ) ? true : options.value || '';
				return;
			}
			// otherwise we need to do some work
			// share parentFragment with parent element
			this.parentFragment = this.element.parentFragment;
			this.fragment = new Fragment( {
				template: options.value,
				root: this.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
			// Store a reference to this attribute's interpolator, if its fragment
			// takes the form `{{foo}}`. This is necessary for two-way binding and
			// for correctly rendering HTML later
			this.interpolator = getInterpolator( this );
			this.isBindable = !!this.interpolator && !this.interpolator.isStatic;
			// can we establish this attribute's property name equivalent?
			determinePropertyName( this, options );
			// mark as ready
			this.ready = true;
		};
	}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

	/* virtualdom/items/Element/Attribute/prototype/rebind.js */
	var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( this.fragment ) {
			this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/render.js */
	var virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			'accesskey': 'accessKey',
			'bgcolor': 'bgColor',
			'class': 'className',
			'codebase': 'codeBase',
			'colspan': 'colSpan',
			'contenteditable': 'contentEditable',
			'datetime': 'dateTime',
			'dirname': 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			'ismap': 'isMap',
			'maxlength': 'maxLength',
			'novalidate': 'noValidate',
			'pubdate': 'pubDate',
			'readonly': 'readOnly',
			'rowspan': 'rowSpan',
			'tabindex': 'tabIndex',
			'usemap': 'useMap'
		};
		return function Attribute$render( node ) {
			var propertyName;
			this.node = node;
			// should we use direct property access, or setAttribute?
			if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
				propertyName = propertyNames[ this.name ] || this.name;
				if ( node[ propertyName ] !== undefined ) {
					this.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					this.useProperty = true;
				}
				if ( propertyName === 'value' ) {
					this.useProperty = true;
					node._ractive.value = this.value;
				}
			}
			this.rendered = true;
			this.update();
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/toString.js */
	var virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {

		var __export;
		__export = function Attribute$toString() {
			var name = ( fragment = this ).name,
				namespacePrefix = fragment.namespacePrefix,
				value = fragment.value,
				interpolator = fragment.interpolator,
				fragment = fragment.fragment;
			// Special case - select and textarea values (should not be stringified)
			if ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {
				return;
			}
			// Special case - content editable
			if ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {
				return;
			}
			// Special case - radio names
			if ( name === 'name' && this.element.name === 'input' && interpolator ) {
				return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
			}
			// Boolean attributes
			if ( booleanAttributes.test( name ) ) {
				return value ? name : '';
			}
			if ( fragment ) {
				value = fragment.toString();
			}
			if ( namespacePrefix ) {
				name = namespacePrefix + ':' + name;
			}
			return value ? name + '="' + escape( value ) + '"' : name;
		};

		function escape( value ) {
			return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
		}
		return __export;
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/unbind.js */
	var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
		// ignore non-dynamic attributes
		if ( this.fragment ) {
			this.fragment.unbind();
		}
		if ( this.name === 'id' ) {
			delete this.root.nodes[ this.value ];
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
		var value = this.value,
			options, option, optionValue, i;
		if ( !this.locked ) {
			this.node._ractive.value = value;
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				if ( optionValue == value ) {
					// double equals as we may be comparing numbers with strings
					option.selected = true;
					break;
				}
			}
		}
	};

	/* utils/arrayContains.js */
	var arrayContains = function arrayContains( array, value ) {
		for ( var i = 0, c = array.length; i < c; i++ ) {
			if ( array[ i ] == value ) {
				return true;
			}
		}
		return false;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {

		return function Attribute$updateMultipleSelect() {
			var value = this.value,
				options, i, option, optionValue;
			if ( !isArray( value ) ) {
				value = [ value ];
			}
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				option.selected = arrayContains( value, optionValue );
			}
		};
	}( arrayContains, isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
	var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
		var node = ( value = this ).node,
			value = value.value;
		node.checked = value == node._ractive.value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
	var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

		return function Attribute$updateRadioValue() {
			var wasChecked, node = this.node,
				binding, bindings, i;
			wasChecked = node.checked;
			node.value = this.element.getAttribute( 'value' );
			node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
			// This is a special case - if the input was checked, and the value
			// changed so that it's no longer checked, the twoway binding is
			// most likely out of date. To fix it we have to jump through some
			// hoops... this is a little kludgy but it works
			if ( wasChecked && !node.checked && this.element.binding ) {
				bindings = this.element.binding.siblings;
				if ( i = bindings.length ) {
					while ( i-- ) {
						binding = bindings[ i ];
						if ( !binding.element.node ) {
							// this is the initial render, siblings are still rendering!
							// we'll come back later...
							return;
						}
						if ( binding.element.node.checked ) {
							runloop.addViewmodel( binding.root.viewmodel );
							return binding.handleChange();
						}
					}
					runloop.addViewmodel( binding.root.viewmodel );
					this.root.viewmodel.set( binding.keypath, undefined );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
	var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

		return function Attribute$updateCheckboxName() {
			var element = ( value = this ).element,
				node = value.node,
				value = value.value,
				valueAttribute, i;
			valueAttribute = element.getAttribute( 'value' );
			if ( !isArray( value ) ) {
				node.checked = value == valueAttribute;
			} else {
				i = value.length;
				while ( i-- ) {
					if ( valueAttribute == value[ i ] ) {
						node.checked = true;
						return;
					}
				}
				node.checked = false;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
	var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.className = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
		var node = ( value = this ).node,
			value = value.value;
		this.root.nodes[ value ] = node;
		node.id = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.style.setAttribute( 'cssText', value );
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
	var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
		var value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		if ( !this.locked ) {
			this.node.innerHTML = value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
	var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
		var node = ( value = this ).node,
			value = value.value;
		// store actual value, so it doesn't get coerced to a string
		node._ractive.value = value;
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			node.value = value == undefined ? '' : value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
	var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			this.node[ this.propertyName ] = this.value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
	var virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {

		return function Attribute$updateEverythingElse() {
			var node = ( fragment = this ).node,
				namespace = fragment.namespace,
				name = fragment.name,
				value = fragment.value,
				fragment = fragment.fragment;
			if ( namespace ) {
				node.setAttributeNS( namespace, name, ( fragment || value ).toString() );
			} else if ( !booleanAttributes.test( name ) ) {
				node.setAttribute( name, ( fragment || value ).toString() );
			} else {
				if ( value ) {
					node.setAttribute( name, '' );
				} else {
					node.removeAttribute( name );
				}
			}
		};
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/update.js */
	var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

		return function Attribute$update() {
			var name = ( node = this ).name,
				element = node.element,
				node = node.node,
				type, updateMethod;
			if ( name === 'id' ) {
				updateMethod = updateIdAttribute;
			} else if ( name === 'value' ) {
				// special case - selects
				if ( element.name === 'select' && name === 'value' ) {
					updateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
				} else if ( element.name === 'textarea' ) {
					updateMethod = updateValue;
				} else if ( element.getAttribute( 'contenteditable' ) != null ) {
					updateMethod = updateContentEditableValue;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					// type='file' value='{{fileList}}'>
					if ( type === 'file' ) {
						updateMethod = noop;
					} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
						updateMethod = updateRadioValue;
					} else {
						updateMethod = updateValue;
					}
				}
			} else if ( this.twoway && name === 'name' ) {
				if ( node.type === 'radio' ) {
					updateMethod = updateRadioName;
				} else if ( node.type === 'checkbox' ) {
					updateMethod = updateCheckboxName;
				}
			} else if ( name === 'style' && node.style.setAttribute ) {
				updateMethod = updateIEStyleAttribute;
			} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
				updateMethod = updateClassName;
			} else if ( this.useProperty ) {
				updateMethod = updateBoolean;
			}
			if ( !updateMethod ) {
				updateMethod = updateEverythingElse;
			}
			this.update = updateMethod;
			this.update();
		};
	}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

	/* virtualdom/items/Element/Attribute/_Attribute.js */
	var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

		var Attribute = function( options ) {
			this.init( options );
		};
		Attribute.prototype = {
			bubble: bubble,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			update: update
		};
		return Attribute;
	}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

	/* virtualdom/items/Element/prototype/init/createAttributes.js */
	var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

		return function( element, attributes ) {
			var name, attribute, result = [];
			for ( name in attributes ) {
				if ( attributes.hasOwnProperty( name ) ) {
					attribute = new Attribute( {
						element: element,
						name: name,
						value: attributes[ name ],
						root: element.root
					} );
					result.push( result[ name ] = attribute );
				}
			}
			return result;
		};
	}( Attribute );

	/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */
	var ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {

		var __export;
		var Fragment, div;
		if ( typeof document !== 'undefined' ) {
			div = createElement( 'div' );
		}
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var ConditionalAttribute = function( element, template ) {
			this.element = element;
			this.root = element.root;
			this.parentFragment = element.parentFragment;
			this.attributes = [];
			this.fragment = new Fragment( {
				root: element.root,
				owner: this,
				template: [ template ]
			} );
		};
		ConditionalAttribute.prototype = {
			bubble: function() {
				if ( this.node ) {
					this.update();
				}
				this.element.bubble();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function( node ) {
				this.node = node;
				this.isSvg = node.namespaceURI === namespaces.svg;
				this.update();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			update: function() {
				var this$0 = this;
				var str, attrs;
				str = this.fragment.toString();
				attrs = parseAttributes( str, this.isSvg );
				// any attributes that previously existed but no longer do
				// must be removed
				this.attributes.filter( function( a ) {
					return notIn( attrs, a );
				} ).forEach( function( a ) {
					this$0.node.removeAttribute( a.name );
				} );
				attrs.forEach( function( a ) {
					this$0.node.setAttribute( a.name, a.value );
				} );
				this.attributes = attrs;
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		__export = ConditionalAttribute;

		function parseAttributes( str, isSvg ) {
			var tag = isSvg ? 'svg' : 'div';
			div.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';
			return toArray( div.childNodes[ 0 ].attributes );
		}

		function notIn( haystack, needle ) {
			var i = haystack.length;
			while ( i-- ) {
				if ( haystack[ i ].name === needle.name ) {
					return false;
				}
			}
			return true;
		}
		return __export;
	}( circular, namespaces, createElement, toArray );

	/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */
	var virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {

		return function( element, attributes ) {
			if ( !attributes ) {
				return [];
			}
			return attributes.map( function( a ) {
				return new ConditionalAttribute( element, a );
			} );
		};
	}( ConditionalAttribute );

	/* utils/extend.js */
	var extend = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		var prop, source;
		while ( source = sources.shift() ) {
			for ( prop in source ) {
				if ( source.hasOwnProperty( prop ) ) {
					target[ prop ] = source[ prop ];
				}
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Binding/Binding.js */
	var Binding = function( runloop, warn, create, extend, removeFromArray ) {

		var Binding = function( element ) {
			var interpolator, keypath, value;
			this.element = element;
			this.root = element.root;
			this.attribute = element.attributes[ this.name || 'value' ];
			interpolator = this.attribute.interpolator;
			interpolator.twowayBinding = this;
			if ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {
				warn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );
				return false;
			}
			// A mustache may be *ambiguous*. Let's say we were given
			// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
			// *wasn't* `undefined`, the keypath would be `foo.bar`.
			// Then, any user input would result in `foo.bar` being updated.
			//
			// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
			// left with an unresolved partial keypath - so we are forced to make an
			// assumption. That assumption is that the input in question should
			// be forced to resolve to `bar`, and any user input would affect `bar`
			// and not `foo.bar`.
			//
			// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
			// be explicit when using two-way data-binding about what keypath you're
			// updating. Using it in lists is probably a recipe for confusion...
			if ( !interpolator.keypath ) {
				interpolator.resolver.forceResolution();
			}
			this.keypath = keypath = interpolator.keypath;
			// initialise value, if it's undefined
			if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
				value = this.getInitialValue();
				if ( value !== undefined ) {
					this.root.viewmodel.set( keypath, value );
				}
			}
		};
		Binding.prototype = {
			handleChange: function() {
				var this$0 = this;
				runloop.start( this.root );
				this.attribute.locked = true;
				this.root.viewmodel.set( this.keypath, this.getValue() );
				runloop.scheduleTask( function() {
					return this$0.attribute.locked = false;
				} );
				runloop.end();
			},
			rebound: function() {
				var bindings, oldKeypath, newKeypath;
				oldKeypath = this.keypath;
				newKeypath = this.attribute.interpolator.keypath;
				// The attribute this binding is linked to has already done the work
				if ( oldKeypath === newKeypath ) {
					return;
				}
				removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
				this.keypath = newKeypath;
				bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
				bindings.push( this );
			},
			unbind: function() {}
		};
		Binding.extend = function( properties ) {
			var Parent = this,
				SpecialisedBinding;
			SpecialisedBinding = function( element ) {
				Binding.call( this, element );
				if ( this.init ) {
					this.init();
				}
			};
			SpecialisedBinding.prototype = create( Parent.prototype );
			extend( SpecialisedBinding.prototype, properties );
			SpecialisedBinding.extend = Binding.extend;
			return SpecialisedBinding;
		};
		return Binding;
	}( runloop, warn, create, extend, removeFromArray );

	/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
	var handleDomEvent = function handleChange() {
		this._ractive.binding.handleChange();
	};

	/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
	var ContentEditableBinding = function( Binding, handleDomEvent ) {

		var ContentEditableBinding = Binding.extend( {
			getInitialValue: function() {
				return this.element.fragment ? this.element.fragment.toString() : '';
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.innerHTML;
			}
		} );
		return ContentEditableBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/shared/getSiblings.js */
	var getSiblings = function() {

		var sets = {};
		return function getSiblings( id, group, keypath ) {
			var hash = id + group + keypath;
			return sets[ hash ] || ( sets[ hash ] = [] );
		};
	}();

	/* virtualdom/items/Element/Binding/RadioBinding.js */
	var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var RadioBinding = Binding.extend( {
			name: 'checked',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
				this.siblings.push( this );
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			handleChange: function() {
				runloop.start( this.root );
				this.siblings.forEach( function( binding ) {
					binding.root.viewmodel.set( binding.keypath, binding.getValue() );
				} );
				runloop.end();
			},
			getValue: function() {
				return this.element.node.checked;
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioBinding;
	}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/RadioNameBinding.js */
	var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

		var RadioNameBinding = Binding.extend( {
			name: 'name',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
				this.siblings.push( this );
				this.radioName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
			},
			getInitialValue: function() {
				if ( this.element.getAttribute( 'checked' ) ) {
					return this.element.getAttribute( 'value' );
				}
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				var node = this.element.node;
				return node._ractive ? node._ractive.value : node.value;
			},
			handleChange: function() {
				// If this <input> is the one that's checked, then the value of its
				// `name` keypath gets set to its value
				if ( this.element.node.checked ) {
					Binding.prototype.handleChange.call( this );
				}
			},
			rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var node;
				Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				if ( node = this.element.node ) {
					node.name = '{{' + this.keypath + '}}';
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioNameBinding;
	}( removeFromArray, Binding, handleDomEvent, getSiblings );

	/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
	var CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var CheckboxNameBinding = Binding.extend( {
			name: 'name',
			getInitialValue: function() {
				// This only gets called once per group (of inputs that
				// share a name), because it only gets called if there
				// isn't an initial value. By the same token, we can make
				// a note of that fact that there was no initial value,
				// and populate it using any `checked` attributes that
				// exist (which users should avoid, but which we should
				// support anyway to avoid breaking expectations)
				this.noInitialValue = true;
				return [];
			},
			init: function() {
				var existingValue, bindingValue;
				this.checkboxName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
				// we set this property so that the attribute gets the correct update method
				// Each input has a reference to an array containing it and its
				// siblings, as two-way binding depends on being able to ascertain
				// the status of all inputs within the group
				this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
				this.siblings.push( this );
				if ( this.noInitialValue ) {
					this.siblings.noInitialValue = true;
				}
				// If no initial value was set, and this input is checked, we
				// update the model
				if ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {
					existingValue = this.root.viewmodel.get( this.keypath );
					bindingValue = this.element.getAttribute( 'value' );
					existingValue.push( bindingValue );
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			},
			render: function() {
				var node = this.element.node,
					existingValue, bindingValue;
				existingValue = this.root.viewmodel.get( this.keypath );
				bindingValue = this.element.getAttribute( 'value' );
				if ( isArray( existingValue ) ) {
					this.isChecked = arrayContains( existingValue, bindingValue );
				} else {
					this.isChecked = existingValue == bindingValue;
				}
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.isChecked;
				node.addEventListener( 'change', handleDomEvent, false );
				// in case of IE emergency, bind to click event as well
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			changed: function() {
				var wasChecked = !!this.isChecked;
				this.isChecked = this.element.node.checked;
				return this.isChecked === wasChecked;
			},
			handleChange: function() {
				this.isChecked = this.element.node.checked;
				Binding.prototype.handleChange.call( this );
			},
			getValue: function() {
				return this.siblings.filter( isChecked ).map( getValue );
			}
		} );

		function isChecked( binding ) {
			return binding.isChecked;
		}

		function getValue( binding ) {
			return binding.element.getAttribute( 'value' );
		}
		return CheckboxNameBinding;
	}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/CheckboxBinding.js */
	var CheckboxBinding = function( Binding, handleDomEvent ) {

		var CheckboxBinding = Binding.extend( {
			name: 'checked',
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.checked;
			}
		} );
		return CheckboxBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/SelectBinding.js */
	var SelectBinding = function( runloop, Binding, handleDomEvent ) {

		var SelectBinding = Binding.extend( {
			getInitialValue: function() {
				var options = this.element.options,
					len, i, value, optionWasSelected;
				if ( this.element.getAttribute( 'value' ) !== undefined ) {
					return;
				}
				i = len = options.length;
				if ( !len ) {
					return;
				}
				// take the final selected option...
				while ( i-- ) {
					if ( options[ i ].getAttribute( 'selected' ) ) {
						value = options[ i ].getAttribute( 'value' );
						optionWasSelected = true;
						break;
					}
				}
				// or the first non-disabled option, if none are selected
				if ( !optionWasSelected ) {
					while ( ++i < len ) {
						if ( !options[ i ].getAttribute( 'disabled' ) ) {
							value = options[ i ].getAttribute( 'value' );
							break;
						}
					}
				}
				// This is an optimisation (aka hack) that allows us to forgo some
				// other more expensive work
				if ( value !== undefined ) {
					this.element.attributes.value.value = value;
				}
				return value;
			},
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			// TODO this method is an anomaly... is it necessary?
			setValue: function( value ) {
				runloop.addViewmodel( this.root.viewmodel );
				this.root.viewmodel.set( this.keypath, value );
			},
			getValue: function() {
				var options, i, len, option, optionValue;
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( options[ i ].selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						return optionValue;
					}
				}
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			}
		} );
		return SelectBinding;
	}( runloop, Binding, handleDomEvent );

	/* utils/arrayContentsMatch.js */
	var arrayContentsMatch = function( isArray ) {

		return function( a, b ) {
			var i;
			if ( !isArray( a ) || !isArray( b ) ) {
				return false;
			}
			if ( a.length !== b.length ) {
				return false;
			}
			i = a.length;
			while ( i-- ) {
				if ( a[ i ] !== b[ i ] ) {
					return false;
				}
			}
			return true;
		};
	}( isArray );

	/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
	var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

		var MultipleSelectBinding = SelectBinding.extend( {
			getInitialValue: function() {
				return this.element.options.filter( function( option ) {
					return option.getAttribute( 'selected' );
				} ).map( function( option ) {
					return option.getAttribute( 'value' );
				} );
			},
			render: function() {
				var valueFromModel;
				this.element.node.addEventListener( 'change', handleDomEvent, false );
				valueFromModel = this.root.viewmodel.get( this.keypath );
				if ( valueFromModel === undefined ) {
					// get value from DOM, if possible
					this.handleChange();
				}
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			setValue: function() {
				throw new Error( 'TODO not implemented yet' );
			},
			getValue: function() {
				var selectedValues, options, i, len, option, optionValue;
				selectedValues = [];
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( option.selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						selectedValues.push( optionValue );
					}
				}
				return selectedValues;
			},
			handleChange: function() {
				var attribute, previousValue, value;
				attribute = this.attribute;
				previousValue = attribute.value;
				value = this.getValue();
				if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
					SelectBinding.prototype.handleChange.call( this );
				}
				return this;
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			},
			updateModel: function() {
				if ( this.attribute.value === undefined || !this.attribute.value.length ) {
					this.root.viewmodel.set( this.keypath, this.initialValue );
				}
			}
		} );
		return MultipleSelectBinding;
	}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

	/* virtualdom/items/Element/Binding/FileListBinding.js */
	var FileListBinding = function( Binding, handleDomEvent ) {

		var FileListBinding = Binding.extend( {
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.files;
			}
		} );
		return FileListBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/GenericBinding.js */
	var GenericBinding = function( Binding, handleDomEvent ) {

		var __export;
		var GenericBinding, getOptions;
		getOptions = {
			evaluateWrapped: true
		};
		GenericBinding = Binding.extend( {
			getInitialValue: function() {
				return '';
			},
			getValue: function() {
				return this.element.node.value;
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
				node.addEventListener( 'blur', handleBlur, false );
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
				node.removeEventListener( 'blur', handleBlur, false );
			}
		} );
		__export = GenericBinding;

		function handleBlur() {
			var value;
			handleDomEvent.call( this );
			value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
			this.value = value == undefined ? '' : value;
		}
		return __export;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/NumericBinding.js */
	var NumericBinding = function( GenericBinding ) {

		return GenericBinding.extend( {
			getInitialValue: function() {
				return undefined;
			},
			getValue: function() {
				var value = parseFloat( this.element.node.value );
				return isNaN( value ) ? undefined : value;
			}
		} );
	}( GenericBinding );

	/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
	var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

		var __export;
		__export = function createTwowayBinding( element ) {
			var attributes = element.attributes,
				type, Binding, bindName, bindChecked;
			// if this is a late binding, and there's already one, it
			// needs to be torn down
			if ( element.binding ) {
				element.binding.teardown();
				element.binding = null;
			}
			// contenteditable
			if ( // if the contenteditable attribute is true or is bindable and may thus become true
				( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {
				Binding = ContentEditableBinding;
			} else if ( element.name === 'input' ) {
				type = element.getAttribute( 'type' );
				if ( type === 'radio' || type === 'checkbox' ) {
					bindName = isBindable( attributes.name );
					bindChecked = isBindable( attributes.checked );
					// we can either bind the name attribute, or the checked attribute - not both
					if ( bindName && bindChecked ) {
						log.error( {
							message: 'badRadioInputBinding'
						} );
					}
					if ( bindName ) {
						Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
					} else if ( bindChecked ) {
						Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
					}
				} else if ( type === 'file' && isBindable( attributes.value ) ) {
					Binding = FileListBinding;
				} else if ( isBindable( attributes.value ) ) {
					Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
				}
			} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
				Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
			} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
				Binding = GenericBinding;
			}
			if ( Binding ) {
				return new Binding( element );
			}
		};

		function isBindable( attribute ) {
			return attribute && attribute.isBindable;
		}
		return __export;
	}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

	/* virtualdom/items/Element/EventHandler/prototype/bubble.js */
	var virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {
		var hasAction = this.getAction();
		if ( hasAction && !this.hasListener ) {
			this.listen();
		} else if ( !hasAction && this.hasListener ) {
			this.unrender();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/fire.js */
	var virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {

		return function EventHandler$fire( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event
			} );
		};
	}( Ractive$shared_fireEvent );

	/* virtualdom/items/Element/EventHandler/prototype/getAction.js */
	var virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {
		return this.action.toString().trim();
	};

	/* virtualdom/items/Element/EventHandler/prototype/init.js */
	var virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {

		var __export;
		var Fragment, getValueOptions = {
				args: true
			},
			eventPattern = /^event(?:\.(.+))?/;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function EventHandler$init( element, name, template ) {
			var handler = this,
				action, refs, ractive;
			handler.element = element;
			handler.root = element.root;
			handler.name = name;
			if ( name.indexOf( '*' ) !== -1 ) {
				log.error( {
					debug: this.root.debug,
					message: 'noElementProxyEventWildcards',
					args: {
						element: element.tagName,
						event: name
					}
				} );
				this.invalid = true;
			}
			if ( template.m ) {
				refs = template.a.r;
				// This is a method call
				handler.method = template.m;
				handler.keypaths = [];
				handler.fn = getFunctionFromString( template.a.s, refs.length );
				handler.parentFragment = element.parentFragment;
				ractive = handler.root;
				// Create resolvers for each reference
				handler.refResolvers = refs.map( function( ref, i ) {
					var match;
					// special case - the `event` object
					if ( match = eventPattern.exec( ref ) ) {
						handler.keypaths[ i ] = {
							eventObject: true,
							refinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []
						};
						return null;
					}
					return createReferenceResolver( handler, ref, function( keypath ) {
						handler.resolve( i, keypath );
					} );
				} );
				this.fire = fireMethodCall;
			} else {
				// Get action ('foo' in 'on-click='foo')
				action = template.n || template;
				if ( typeof action !== 'string' ) {
					action = new Fragment( {
						template: action,
						root: this.root,
						owner: this
					} );
				}
				this.action = action;
				// Get parameters
				if ( template.d ) {
					this.dynamicParams = new Fragment( {
						template: template.d,
						root: this.root,
						owner: this.element
					} );
					this.fire = fireEventWithDynamicParams;
				} else if ( template.a ) {
					this.params = template.a;
					this.fire = fireEventWithParams;
				}
			}
		};

		function fireMethodCall( event ) {
			var ractive, values, args;
			ractive = this.root;
			if ( typeof ractive[ this.method ] !== 'function' ) {
				throw new Error( 'Attempted to call a non-existent method ("' + this.method + '")' );
			}
			values = this.keypaths.map( function( keypath ) {
				var value, len, i;
				if ( keypath === undefined ) {
					// not yet resolved
					return undefined;
				}
				// TODO the refinements stuff would be better handled at parse time
				if ( keypath.eventObject ) {
					value = event;
					if ( len = keypath.refinements.length ) {
						for ( i = 0; i < len; i += 1 ) {
							value = value[ keypath.refinements[ i ] ];
						}
					}
				} else {
					value = ractive.viewmodel.get( keypath );
				}
				return value;
			} );
			ractive.event = event;
			args = this.fn.apply( null, values );
			ractive[ this.method ].apply( ractive, args );
			delete ractive.event;
		}

		function fireEventWithParams( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: this.params
			} );
		}

		function fireEventWithDynamicParams( event ) {
			var args = this.dynamicParams.getValue( getValueOptions );
			// need to strip [] from ends if a string!
			if ( typeof args === 'string' ) {
				args = args.substr( 1, args.length - 2 );
			}
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: args
			} );
		}
		return __export;
	}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
	var genericHandler = function genericHandler( event ) {
		var storage, handler;
		storage = this._ractive;
		handler = storage.events[ event.type ];
		handler.fire( {
			node: this,
			original: event,
			index: storage.index,
			keypath: storage.keypath,
			context: storage.root.get( storage.keypath )
		} );
	};

	/* virtualdom/items/Element/EventHandler/prototype/listen.js */
	var virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {

		var __export;
		var customHandlers = {},
			touchEvents = {
				touchstart: true,
				touchmove: true,
				touchend: true,
				touchcancel: true,
				//not w3c, but supported in some browsers
				touchleave: true
			};
		__export = function EventHandler$listen() {
			var definition, name = this.name;
			if ( this.invalid ) {
				return;
			}
			if ( definition = config.registries.events.find( this.root, name ) ) {
				this.custom = definition( this.node, getCustomHandler( name ) );
			} else {
				// Looks like we're dealing with a standard DOM event... but let's check
				if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
					// okay to use touch events if this browser doesn't support them
					if ( !touchEvents[ name ] ) {
						log.error( {
							debug: this.root.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'event',
								name: name
							}
						} );
					}
					return;
				}
				this.node.addEventListener( name, genericHandler, false );
			}
			this.hasListener = true;
		};

		function getCustomHandler( name ) {
			if ( !customHandlers[ name ] ) {
				customHandlers[ name ] = function( event ) {
					var storage = event.node._ractive;
					event.index = storage.index;
					event.keypath = storage.keypath;
					event.context = storage.root.get( storage.keypath );
					storage.events[ name ].fire( event );
				};
			}
			return customHandlers[ name ];
		}
		return __export;
	}( config, genericHandler, log );

	/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
	var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		var fragment;
		if ( this.method ) {
			fragment = this.element.parentFragment;
			this.refResolvers.forEach( rebind );
			return;
		}
		if ( typeof this.action !== 'string' ) {
			rebind( this.action );
		}
		if ( this.dynamicParams ) {
			rebind( this.dynamicParams );
		}

		function rebind( thing ) {
			thing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/render.js */
	var virtualdom_items_Element_EventHandler$render = function EventHandler$render() {
		this.node = this.element.node;
		// store this on the node itself, so it can be retrieved by a
		// universal handler
		this.node._ractive.events[ this.name ] = this;
		if ( this.method || this.getAction() ) {
			this.listen();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/resolve.js */
	var virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {
		this.keypaths[ index ] = keypath;
	};

	/* virtualdom/items/Element/EventHandler/prototype/unbind.js */
	var virtualdom_items_Element_EventHandler$unbind = function() {

		var __export;
		__export = function EventHandler$unbind() {
			if ( this.method ) {
				this.refResolvers.forEach( unbind );
				return;
			}
			// Tear down dynamic name
			if ( typeof this.action !== 'string' ) {
				this.action.unbind();
			}
			// Tear down dynamic parameters
			if ( this.dynamicParams ) {
				this.dynamicParams.unbind();
			}
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}();

	/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
	var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

		return function EventHandler$unrender() {
			if ( this.custom ) {
				this.custom.teardown();
			} else {
				this.node.removeEventListener( this.name, genericHandler, false );
			}
			this.hasListener = false;
		};
	}( genericHandler );

	/* virtualdom/items/Element/EventHandler/_EventHandler.js */
	var EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {

		var EventHandler = function( element, name, template ) {
			this.init( element, name, template );
		};
		EventHandler.prototype = {
			bubble: bubble,
			fire: fire,
			getAction: getAction,
			init: init,
			listen: listen,
			rebind: rebind,
			render: render,
			resolve: resolve,
			unbind: unbind,
			unrender: unrender
		};
		return EventHandler;
	}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );

	/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
	var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

		return function( element, template ) {
			var i, name, names, handler, result = [];
			for ( name in template ) {
				if ( template.hasOwnProperty( name ) ) {
					names = name.split( '-' );
					i = names.length;
					while ( i-- ) {
						handler = new EventHandler( element, names[ i ], template[ name ] );
						result.push( handler );
					}
				}
			}
			return result;
		};
	}( EventHandler );

	/* virtualdom/items/Element/Decorator/_Decorator.js */
	var Decorator = function( log, circular, config ) {

		var Fragment, getValueOptions, Decorator;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		getValueOptions = {
			args: true
		};
		Decorator = function( element, template ) {
			var decorator = this,
				ractive, name, fragment;
			decorator.element = element;
			decorator.root = ractive = element.root;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			if ( template.a ) {
				decorator.params = template.a;
			} else if ( template.d ) {
				decorator.fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				decorator.params = decorator.fragment.getValue( getValueOptions );
				decorator.fragment.bubble = function() {
					this.dirtyArgs = this.dirtyValue = true;
					decorator.params = this.getValue( getValueOptions );
					if ( decorator.ready ) {
						decorator.update();
					}
				};
			}
			decorator.fn = config.registries.decorators.find( ractive, name );
			if ( !decorator.fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'decorator',
						name: name
					}
				} );
			}
		};
		Decorator.prototype = {
			init: function() {
				var decorator = this,
					node, result, args;
				node = decorator.element.node;
				if ( decorator.params ) {
					args = [ node ].concat( decorator.params );
					result = decorator.fn.apply( decorator.root, args );
				} else {
					result = decorator.fn.call( decorator.root, node );
				}
				if ( !result || !result.teardown ) {
					throw new Error( 'Decorator definition must return an object with a teardown method' );
				}
				// TODO does this make sense?
				decorator.actual = result;
				decorator.ready = true;
			},
			update: function() {
				if ( this.actual.update ) {
					this.actual.update.apply( this.root, this.params );
				} else {
					this.actual.teardown( true );
					this.init();
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.fragment ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			teardown: function( updating ) {
				this.actual.teardown();
				if ( !updating && this.fragment ) {
					this.fragment.unbind();
				}
			}
		};
		return Decorator;
	}( log, circular, config );

	/* virtualdom/items/Element/special/select/sync.js */
	var sync = function( toArray ) {

		var __export;
		__export = function syncSelect( selectElement ) {
			var selectNode, selectValue, isMultiple, options, optionWasSelected;
			selectNode = selectElement.node;
			if ( !selectNode ) {
				return;
			}
			options = toArray( selectNode.options );
			selectValue = selectElement.getAttribute( 'value' );
			isMultiple = selectElement.getAttribute( 'multiple' );
			// If the <select> has a specified value, that should override
			// these options
			if ( selectValue !== undefined ) {
				options.forEach( function( o ) {
					var optionValue, shouldSelect;
					optionValue = o._ractive ? o._ractive.value : o.value;
					shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
					if ( shouldSelect ) {
						optionWasSelected = true;
					}
					o.selected = shouldSelect;
				} );
				if ( !optionWasSelected ) {
					if ( options[ 0 ] ) {
						options[ 0 ].selected = true;
					}
					if ( selectElement.binding ) {
						selectElement.binding.forceUpdate();
					}
				}
			} else if ( selectElement.binding ) {
				selectElement.binding.forceUpdate();
			}
		};

		function valueContains( selectValue, optionValue ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( selectValue[ i ] == optionValue ) {
					return true;
				}
			}
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Element/special/select/bubble.js */
	var bubble = function( runloop, syncSelect ) {

		return function bubbleSelect() {
			var this$0 = this;
			if ( !this.dirty ) {
				this.dirty = true;
				runloop.scheduleTask( function() {
					syncSelect( this$0 );
					this$0.dirty = false;
				} );
			}
			this.parentFragment.bubble();
		};
	}( runloop, sync );

	/* virtualdom/items/Element/special/option/findParentSelect.js */
	var findParentSelect = function findParentSelect( element ) {
		do {
			if ( element.name === 'select' ) {
				return element;
			}
		} while ( element = element.parent );
	};

	/* virtualdom/items/Element/special/option/init.js */
	var init = function( findParentSelect ) {

		return function initOption( option, template ) {
			option.select = findParentSelect( option.parent );
			// we might be inside a <datalist> element
			if ( !option.select ) {
				return;
			}
			option.select.options.push( option );
			// If the value attribute is missing, use the element's content
			if ( !template.a ) {
				template.a = {};
			}
			// ...as long as it isn't disabled
			if ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {
				template.a.value = template.f;
			}
			// If there is a `selected` attribute, but the <select>
			// already has a value, delete it
			if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
				delete template.a.selected;
			}
		};
	}( findParentSelect );

	/* virtualdom/items/Element/prototype/init.js */
	var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Element$init( options ) {
			var parentFragment, template, ractive, binding, bindings;
			this.type = types.ELEMENT;
			// stuff we'll need later
			parentFragment = this.parentFragment = options.parentFragment;
			template = this.template = options.template;
			this.parent = options.pElement || parentFragment.pElement;
			this.root = ractive = parentFragment.root;
			this.index = options.index;
			this.name = enforceCase( template.e );
			// Special case - <option> elements
			if ( this.name === 'option' ) {
				initOption( this, template );
			}
			// Special case - <select> elements
			if ( this.name === 'select' ) {
				this.options = [];
				this.bubble = bubbleSelect;
			}
			// create attributes
			this.attributes = createAttributes( this, template.a );
			this.conditionalAttributes = createConditionalAttributes( this, template.m );
			// append children, if there are any
			if ( template.f ) {
				this.fragment = new Fragment( {
					template: template.f,
					root: ractive,
					owner: this,
					pElement: this
				} );
			}
			// create twoway binding
			if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
				this.binding = binding;
				// register this with the root, so that we can do ractive.updateModel()
				bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
				bindings.push( binding );
			}
			// create event proxies
			if ( template.v ) {
				this.eventHandlers = createEventHandlers( this, template.v );
			}
			// create decorator
			if ( template.o ) {
				this.decorator = new Decorator( this, template.o );
			}
			// create transitions
			this.intro = template.t0 || template.t1;
			this.outro = template.t0 || template.t2;
		};
	}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

	/* virtualdom/items/shared/utils/startsWith.js */
	var startsWith = function( startsWithKeypath ) {

		return function startsWith( target, keypath ) {
			return target === keypath || startsWithKeypath( target, keypath );
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/utils/assignNewKeypath.js */
	var assignNewKeypath = function( startsWith, getNewKeypath ) {

		return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
			var existingKeypath = target[ property ];
			if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
				return;
			}
			target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
		};
	}( startsWith, getNewKeypath );

	/* virtualdom/items/Element/prototype/rebind.js */
	var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

		return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var i, storage, liveQueries, ractive;
			if ( this.attributes ) {
				this.attributes.forEach( rebind );
			}
			if ( this.conditionalAttributes ) {
				this.conditionalAttributes.forEach( rebind );
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( rebind );
			}
			if ( this.decorator ) {
				rebind( this.decorator );
			}
			// rebind children
			if ( this.fragment ) {
				rebind( this.fragment );
			}
			// Update live queries, if necessary
			if ( liveQueries = this.liveQueries ) {
				ractive = this.root;
				i = liveQueries.length;
				while ( i-- ) {
					liveQueries[ i ]._makeDirty();
				}
			}
			if ( this.node && ( storage = this.node._ractive ) ) {
				// adjust keypath if needed
				assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
				if ( indexRef != undefined ) {
					storage.index[ indexRef ] = newIndex;
				}
			}

			function rebind( thing ) {
				thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( assignNewKeypath );

	/* virtualdom/items/Element/special/img/render.js */
	var render = function renderImage( img ) {
		var loadHandler;
		// if this is an <img>, and we're in a crap browser, we may need to prevent it
		// from overriding width and height when it loads the src
		if ( img.attributes.width || img.attributes.height ) {
			img.node.addEventListener( 'load', loadHandler = function() {
				var width = img.getAttribute( 'width' ),
					height = img.getAttribute( 'height' );
				if ( width !== undefined ) {
					img.node.setAttribute( 'width', width );
				}
				if ( height !== undefined ) {
					img.node.setAttribute( 'height', height );
				}
				img.node.removeEventListener( 'load', loadHandler, false );
			}, false );
		}
	};

	/* virtualdom/items/Element/Transition/prototype/init.js */
	var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

		var Fragment, getValueOptions = {};
		// TODO what are the options?
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Transition$init( element, template, isIntro ) {
			var t = this,
				ractive, name, fragment;
			t.element = element;
			t.root = ractive = element.root;
			t.isIntro = isIntro;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			t.name = name;
			if ( template.a ) {
				t.params = template.a;
			} else if ( template.d ) {
				// TODO is there a way to interpret dynamic arguments without all the
				// 'dependency thrashing'?
				fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				t.params = fragment.getValue( getValueOptions );
				fragment.unbind();
			}
			t._fn = config.registries.transitions.find( ractive, name );
			if ( !t._fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'transition',
						name: name
					}
				} );
				return;
			}
		};
	}( log, config, circular );

	/* utils/camelCase.js */
	var camelCase = function( hyphenatedStr ) {
		return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
			return $1.toUpperCase();
		} );
	};

	/* virtualdom/items/Element/Transition/helpers/prefix.js */
	var prefix = function( isClient, vendors, createElement, camelCase ) {

		var prefix, prefixCache, testStyle;
		if ( !isClient ) {
			prefix = null;
		} else {
			prefixCache = {};
			testStyle = createElement( 'div' ).style;
			prefix = function( prop ) {
				var i, vendor, capped;
				prop = camelCase( prop );
				if ( !prefixCache[ prop ] ) {
					if ( testStyle[ prop ] !== undefined ) {
						prefixCache[ prop ] = prop;
					} else {
						// test vendors...
						capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
						i = vendors.length;
						while ( i-- ) {
							vendor = vendors[ i ];
							if ( testStyle[ vendor + capped ] !== undefined ) {
								prefixCache[ prop ] = vendor + capped;
								break;
							}
						}
					}
				}
				return prefixCache[ prop ];
			};
		}
		return prefix;
	}( isClient, vendors, createElement, camelCase );

	/* virtualdom/items/Element/Transition/prototype/getStyle.js */
	var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

		var getStyle, getComputedStyle;
		if ( !isClient ) {
			getStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			getStyle = function( props ) {
				var computedStyle, styles, i, prop, value;
				computedStyle = getComputedStyle( this.node );
				if ( typeof props === 'string' ) {
					value = computedStyle[ prefix( props ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					return value;
				}
				if ( !isArray( props ) ) {
					throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
				}
				styles = {};
				i = props.length;
				while ( i-- ) {
					prop = props[ i ];
					value = computedStyle[ prefix( prop ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					styles[ prop ] = value;
				}
				return styles;
			};
		}
		return getStyle;
	}( legacy, isClient, isArray, prefix );

	/* virtualdom/items/Element/Transition/prototype/setStyle.js */
	var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

		return function( style, value ) {
			var prop;
			if ( typeof style === 'string' ) {
				this.node.style[ prefix( style ) ] = value;
			} else {
				for ( prop in style ) {
					if ( style.hasOwnProperty( prop ) ) {
						this.node.style[ prefix( prop ) ] = style[ prop ];
					}
				}
			}
			return this;
		};
	}( prefix );

	/* shared/Ticker.js */
	var Ticker = function( warn, getTime, animations ) {

		var __export;
		var Ticker = function( options ) {
			var easing;
			this.duration = options.duration;
			this.step = options.step;
			this.complete = options.complete;
			// easing
			if ( typeof options.easing === 'string' ) {
				easing = options.root.easing[ options.easing ];
				if ( !easing ) {
					warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
					easing = linear;
				}
			} else if ( typeof options.easing === 'function' ) {
				easing = options.easing;
			} else {
				easing = linear;
			}
			this.easing = easing;
			this.start = getTime();
			this.end = this.start + this.duration;
			this.running = true;
			animations.add( this );
		};
		Ticker.prototype = {
			tick: function( now ) {
				var elapsed, eased;
				if ( !this.running ) {
					return false;
				}
				if ( now > this.end ) {
					if ( this.step ) {
						this.step( 1 );
					}
					if ( this.complete ) {
						this.complete( 1 );
					}
					return false;
				}
				elapsed = now - this.start;
				eased = this.easing( elapsed / this.duration );
				if ( this.step ) {
					this.step( eased );
				}
				return true;
			},
			stop: function() {
				if ( this.abort ) {
					this.abort();
				}
				this.running = false;
			}
		};
		__export = Ticker;

		function linear( t ) {
			return t;
		}
		return __export;
	}( warn, getTime, animations );

	/* virtualdom/items/Element/Transition/helpers/unprefix.js */
	var unprefix = function( vendors ) {

		var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
		return function( prop ) {
			return prop.replace( unprefixPattern, '' );
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
	var hyphenate = function( vendors ) {

		var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
		return function( str ) {
			var hyphenated;
			if ( !str ) {
				return '';
			}
			if ( vendorPattern.test( str ) ) {
				str = '-' + str;
			}
			hyphenated = str.replace( /[A-Z]/g, function( match ) {
				return '-' + match.toLowerCase();
			} );
			return hyphenated;
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
	var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

		var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
			cannotUseCssTransitions = {};
		if ( !isClient ) {
			createTransitions = null;
		} else {
			testStyle = createElement( 'div' ).style;
			// determine some facts about our environment
			( function() {
				if ( testStyle.transition !== undefined ) {
					TRANSITION = 'transition';
					TRANSITIONEND = 'transitionend';
					CSS_TRANSITIONS_ENABLED = true;
				} else if ( testStyle.webkitTransition !== undefined ) {
					TRANSITION = 'webkitTransition';
					TRANSITIONEND = 'webkitTransitionEnd';
					CSS_TRANSITIONS_ENABLED = true;
				} else {
					CSS_TRANSITIONS_ENABLED = false;
				}
			}() );
			if ( TRANSITION ) {
				TRANSITION_DURATION = TRANSITION + 'Duration';
				TRANSITION_PROPERTY = TRANSITION + 'Property';
				TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
			}
			createTransitions = function( t, to, options, changedProperties, resolve ) {
				// Wait a beat (otherwise the target styles will be applied immediately)
				// TODO use a fastdom-style mechanism?
				setTimeout( function() {
					var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
					checkComplete = function() {
						if ( jsTransitionsComplete && cssTransitionsComplete ) {
							// will changes to events and fire have an unexpected consequence here?
							t.root.fire( t.name + ':end', t.node, t.isIntro );
							resolve();
						}
					};
					// this is used to keep track of which elements can use CSS to animate
					// which properties
					hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
					t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
					t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
					t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
					transitionEndHandler = function( event ) {
						var index;
						index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
						if ( index !== -1 ) {
							changedProperties.splice( index, 1 );
						}
						if ( changedProperties.length ) {
							// still transitioning...
							return;
						}
						t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
						cssTransitionsComplete = true;
						checkComplete();
					};
					t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
					setTimeout( function() {
						var i = changedProperties.length,
							hash, originalValue, index, propertiesToTransitionInJs = [],
							prop, suffix;
						while ( i-- ) {
							prop = changedProperties[ i ];
							hash = hashPrefix + prop;
							if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
								t.node.style[ prefix( prop ) ] = to[ prop ];
								// If we're not sure if CSS transitions are supported for
								// this tag/property combo, find out now
								if ( !canUseCssTransitions[ hash ] ) {
									originalValue = t.getStyle( prop );
									// if this property is transitionable in this browser,
									// the current style will be different from the target style
									canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
									cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
									// Reset, if we're going to use timers after all
									if ( cannotUseCssTransitions[ hash ] ) {
										t.node.style[ prefix( prop ) ] = originalValue;
									}
								}
							}
							if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
								// we need to fall back to timer-based stuff
								if ( originalValue === undefined ) {
									originalValue = t.getStyle( prop );
								}
								// need to remove this from changedProperties, otherwise transitionEndHandler
								// will get confused
								index = changedProperties.indexOf( prop );
								if ( index === -1 ) {
									warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
								} else {
									changedProperties.splice( index, 1 );
								}
								// TODO Determine whether this property is animatable at all
								suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
								// ...then kick off a timer-based transition
								propertiesToTransitionInJs.push( {
									name: prefix( prop ),
									interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
									suffix: suffix
								} );
							}
						}
						// javascript transitions
						if ( propertiesToTransitionInJs.length ) {
							new Ticker( {
								root: t.root,
								duration: options.duration,
								easing: camelCase( options.easing || '' ),
								step: function( pos ) {
									var prop, i;
									i = propertiesToTransitionInJs.length;
									while ( i-- ) {
										prop = propertiesToTransitionInJs[ i ];
										t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
									}
								},
								complete: function() {
									jsTransitionsComplete = true;
									checkComplete();
								}
							} );
						} else {
							jsTransitionsComplete = true;
						}
						if ( !changedProperties.length ) {
							// We need to cancel the transitionEndHandler, and deal with
							// the fact that it will never fire
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						}
					}, 0 );
				}, options.delay || 0 );
			};
		}
		return createTransitions;
	}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
	var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

		var hidden, vendor, prefix, i, visibility;
		if ( typeof document !== 'undefined' ) {
			hidden = 'hidden';
			visibility = {};
			if ( hidden in document ) {
				prefix = '';
			} else {
				i = vendors.length;
				while ( i-- ) {
					vendor = vendors[ i ];
					hidden = vendor + 'Hidden';
					if ( hidden in document ) {
						prefix = vendor;
					}
				}
			}
			if ( prefix !== undefined ) {
				document.addEventListener( prefix + 'visibilitychange', onChange );
				// initialise
				onChange();
			} else {
				// gah, we're in an old browser
				if ( 'onfocusout' in document ) {
					document.addEventListener( 'focusout', onHide );
					document.addEventListener( 'focusin', onShow );
				} else {
					window.addEventListener( 'pagehide', onHide );
					window.addEventListener( 'blur', onHide );
					window.addEventListener( 'pageshow', onShow );
					window.addEventListener( 'focus', onShow );
				}
				visibility.hidden = false;
			}
		}

		function onChange() {
			visibility.hidden = document[ hidden ];
		}

		function onHide() {
			visibility.hidden = true;
		}

		function onShow() {
			visibility.hidden = false;
		}
		return visibility;
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
	var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

		var animateStyle, getComputedStyle, resolved;
		if ( !isClient ) {
			animateStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			animateStyle = function( style, value, options, complete ) {
				var t = this,
					to;
				// Special case - page isn't visible. Don't animate anything, because
				// that way you'll never get CSS transitionend events
				if ( visibility.hidden ) {
					this.setStyle( style, value );
					return resolved || ( resolved = Promise.resolve() );
				}
				if ( typeof style === 'string' ) {
					to = {};
					to[ style ] = value;
				} else {
					to = style;
					// shuffle arguments
					complete = options;
					options = value;
				}
				// As of 0.3.9, transition authors should supply an `option` object with
				// `duration` and `easing` properties (and optional `delay`), plus a
				// callback function that gets called after the animation completes
				// TODO remove this check in a future version
				if ( !options ) {
					warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
					options = t;
					complete = t.complete;
				}
				var promise = new Promise( function( resolve ) {
					var propertyNames, changedProperties, computedStyle, current, from, i, prop;
					// Edge case - if duration is zero, set style synchronously and complete
					if ( !options.duration ) {
						t.setStyle( to );
						resolve();
						return;
					}
					// Get a list of the properties we're animating
					propertyNames = Object.keys( to );
					changedProperties = [];
					// Store the current styles
					computedStyle = getComputedStyle( t.node );
					from = {};
					i = propertyNames.length;
					while ( i-- ) {
						prop = propertyNames[ i ];
						current = computedStyle[ prefix( prop ) ];
						if ( current === '0px' ) {
							current = 0;
						}
						// we need to know if we're actually changing anything
						if ( current != to[ prop ] ) {
							// use != instead of !==, so we can compare strings with numbers
							changedProperties.push( prop );
							// make the computed style explicit, so we can animate where
							// e.g. height='auto'
							t.node.style[ prefix( prop ) ] = current;
						}
					}
					// If we're not actually changing anything, the transitionend event
					// will never fire! So we complete early
					if ( !changedProperties.length ) {
						resolve();
						return;
					}
					createTransitions( t, to, options, changedProperties, resolve );
				} );
				// If a callback was supplied, do the honours
				// TODO remove this check in future
				if ( complete ) {
					warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
					promise.then( complete );
				}
				return promise;
			};
		}
		return animateStyle;
	}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

	/* utils/fillGaps.js */
	var fillGaps = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		sources.forEach( function( s ) {
			for ( var key in s ) {
				if ( s.hasOwnProperty( key ) && !( key in target ) ) {
					target[ key ] = s[ key ];
				}
			}
		} );
		return target;
	};

	/* virtualdom/items/Element/Transition/prototype/processParams.js */
	var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

		return function( params, defaults ) {
			if ( typeof params === 'number' ) {
				params = {
					duration: params
				};
			} else if ( typeof params === 'string' ) {
				if ( params === 'slow' ) {
					params = {
						duration: 600
					};
				} else if ( params === 'fast' ) {
					params = {
						duration: 200
					};
				} else {
					params = {
						duration: 400
					};
				}
			} else if ( !params ) {
				params = {};
			}
			return fillGaps( {}, params, defaults );
		};
	}( fillGaps );

	/* virtualdom/items/Element/Transition/prototype/start.js */
	var virtualdom_items_Element_Transition$start = function() {

		var __export;
		__export = function Transition$start() {
			var t = this,
				node, originalStyle, completed;
			node = t.node = t.element.node;
			originalStyle = node.getAttribute( 'style' );
			// create t.complete() - we don't want this on the prototype,
			// because we don't want `this` silliness when passing it as
			// an argument
			t.complete = function( noReset ) {
				if ( completed ) {
					return;
				}
				if ( !noReset && t.isIntro ) {
					resetStyle( node, originalStyle );
				}
				node._ractive.transition = null;
				t._manager.remove( t );
				completed = true;
			};
			// If the transition function doesn't exist, abort
			if ( !t._fn ) {
				t.complete();
				return;
			}
			t._fn.apply( t.root, [ t ].concat( t.params ) );
		};

		function resetStyle( node, style ) {
			if ( style ) {
				node.setAttribute( 'style', style );
			} else {
				// Next line is necessary, to remove empty style attribute!
				// See http://stackoverflow.com/a/7167553
				node.getAttribute( 'style' );
				node.removeAttribute( 'style' );
			}
		}
		return __export;
	}();

	/* virtualdom/items/Element/Transition/_Transition.js */
	var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

		var Fragment, Transition;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Transition = function( owner, template, isIntro ) {
			this.init( owner, template, isIntro );
		};
		Transition.prototype = {
			init: init,
			start: start,
			getStyle: getStyle,
			setStyle: setStyle,
			animateStyle: animateStyle,
			processParams: processParams
		};
		return Transition;
	}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

	/* virtualdom/items/Element/prototype/render.js */
	var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

		var __export;
		var updateCss, updateScript;
		updateCss = function() {
			var node = this.node,
				content = this.fragment.toString( false );
			// IE8 has no styleSheet unless there's a type text/css
			if ( window && window.appearsToBeIELessEqual8 ) {
				node.type = 'text/css';
			}
			if ( node.styleSheet ) {
				node.styleSheet.cssText = content;
			} else {
				while ( node.hasChildNodes() ) {
					node.removeChild( node.firstChild );
				}
				node.appendChild( document.createTextNode( content ) );
			}
		};
		updateScript = function() {
			if ( !this.node.type || this.node.type === 'text/javascript' ) {
				warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
			}
			this.node.text = this.fragment.toString( false );
		};
		__export = function Element$render() {
			var this$0 = this;
			var root = this.root,
				namespace, node;
			namespace = getNamespace( this );
			node = this.node = createElement( this.name, namespace );
			// Is this a top-level node of a component? If so, we may need to add
			// a data-rvcguid attribute, for CSS encapsulation
			// NOTE: css no longer copied to instance, so we check constructor.css -
			// we can enhance to handle instance, but this is more "correct" with current
			// functionality
			if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
				this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
			}
			// Add _ractive property to the node - we use this object to store stuff
			// related to proxy events, two-way bindings etc
			defineProperty( this.node, '_ractive', {
				value: {
					proxy: this,
					keypath: getInnerContext( this.parentFragment ),
					index: this.parentFragment.indexRefs,
					events: create( null ),
					root: root
				}
			} );
			// Render attributes
			this.attributes.forEach( function( a ) {
				return a.render( node );
			} );
			this.conditionalAttributes.forEach( function( a ) {
				return a.render( node );
			} );
			// Render children
			if ( this.fragment ) {
				// Special case - <script> element
				if ( this.name === 'script' ) {
					this.bubble = updateScript;
					this.node.text = this.fragment.toString( false );
					// bypass warning initially
					this.fragment.unrender = noop;
				} else if ( this.name === 'style' ) {
					this.bubble = updateCss;
					this.bubble();
					this.fragment.unrender = noop;
				} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
					this.fragment.unrender = noop;
				} else {
					this.node.appendChild( this.fragment.render() );
				}
			}
			// Add proxy event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.render();
				} );
			}
			// deal with two-way bindings
			if ( this.binding ) {
				this.binding.render();
				this.node._ractive.binding = this.binding;
			}
			// Special case: if this is an <img>, and we're in a crap browser, we may
			// need to prevent it from overriding width and height when it loads the src
			if ( this.name === 'img' ) {
				renderImage( this );
			}
			// apply decorator(s)
			if ( this.decorator && this.decorator.fn ) {
				runloop.scheduleTask( function() {
					return this$0.decorator.init();
				}, true );
			}
			// trigger intro transition
			if ( root.transitionsEnabled && this.intro ) {
				var transition = new Transition( this, this.intro, true );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				}, true );
				this.transition = transition;
			}
			if ( this.name === 'option' ) {
				processOption( this );
			}
			if ( this.node.autofocus ) {
				// Special case. Some browsers (*cough* Firefix *cough*) have a problem
				// with dynamically-generated elements having autofocus, and they won't
				// allow you to programmatically focus the element until it's in the DOM
				runloop.scheduleTask( function() {
					return this$0.node.focus();
				}, true );
			}
			updateLiveQueries( this );
			return this.node;
		};

		function getNamespace( element ) {
			var namespace, xmlns, parent;
			// Use specified namespace...
			if ( xmlns = element.getAttribute( 'xmlns' ) ) {
				namespace = xmlns;
			} else if ( element.name === 'svg' ) {
				namespace = namespaces.svg;
			} else if ( parent = element.parent ) {
				// ...or HTML, if the parent is a <foreignObject>
				if ( parent.name === 'foreignObject' ) {
					namespace = namespaces.html;
				} else {
					namespace = parent.node.namespaceURI;
				}
			} else {
				namespace = element.root.el.namespaceURI;
			}
			return namespace;
		}

		function processOption( option ) {
			var optionValue, selectValue, i;
			if ( !option.select ) {
				return;
			}
			selectValue = option.select.getAttribute( 'value' );
			if ( selectValue === undefined ) {
				return;
			}
			optionValue = option.getAttribute( 'value' );
			if ( option.select.node.multiple && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( optionValue == selectValue[ i ] ) {
						option.node.selected = true;
						break;
					}
				}
			} else {
				option.node.selected = optionValue == selectValue;
			}
		}

		function updateLiveQueries( element ) {
			var instance, liveQueries, i, selector, query;
			// Does this need to be added to any live queries?
			instance = element.root;
			do {
				liveQueries = instance._liveQueries;
				i = liveQueries.length;
				while ( i-- ) {
					selector = liveQueries[ i ];
					query = liveQueries[ '_' + selector ];
					if ( query._test( element ) ) {
						// keep register of applicable selectors, for when we teardown
						( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
					}
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

	/* virtualdom/items/Element/prototype/toString.js */
	var virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {

		var __export;
		__export = function() {
			var str, escape;
			str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
			str += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );
			// Special case - selected options
			if ( this.name === 'option' && optionIsSelected( this ) ) {
				str += ' selected';
			}
			// Special case - two-way radio name bindings
			if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
				str += ' checked';
			}
			str += '>';
			// Special case - textarea
			if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
				str += escapeHtml( this.getAttribute( 'value' ) );
			} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
				str += this.getAttribute( 'value' );
			}
			if ( this.fragment ) {
				escape = this.name !== 'script' && this.name !== 'style';
				str += this.fragment.toString( escape );
			}
			// add a closing tag if this isn't a void element
			if ( !voidElementNames.test( this.template.e ) ) {
				str += '</' + this.template.e + '>';
			}
			return str;
		};

		function optionIsSelected( element ) {
			var optionValue, selectValue, i;
			optionValue = element.getAttribute( 'value' );
			if ( optionValue === undefined || !element.select ) {
				return false;
			}
			selectValue = element.select.getAttribute( 'value' );
			if ( selectValue == optionValue ) {
				return true;
			}
			if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
		}

		function inputIsCheckedRadio( element ) {
			var attributes, typeAttribute, valueAttribute, nameAttribute;
			attributes = element.attributes;
			typeAttribute = attributes.type;
			valueAttribute = attributes.value;
			nameAttribute = attributes.name;
			if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
				return;
			}
			if ( valueAttribute.value === nameAttribute.interpolator.value ) {
				return true;
			}
		}

		function stringifyAttribute( attribute ) {
			var str = attribute.toString();
			return str ? ' ' + str : '';
		}
		return __export;
	}( voidElementNames, isArray, escapeHtml );

	/* virtualdom/items/Element/special/option/unbind.js */
	var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

		return function unbindOption( option ) {
			if ( option.select ) {
				removeFromArray( option.select.options, option );
			}
		};
	}( removeFromArray );

	/* virtualdom/items/Element/prototype/unbind.js */
	var virtualdom_items_Element$unbind = function( unbindOption ) {

		var __export;
		__export = function Element$unbind() {
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.binding ) {
				this.binding.unbind();
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( unbind );
			}
			// Special case - <option>
			if ( this.name === 'option' ) {
				unbindOption( this );
			}
			this.attributes.forEach( unbind );
			this.conditionalAttributes.forEach( unbind );
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}( virtualdom_items_Element_special_option_unbind );

	/* virtualdom/items/Element/prototype/unrender.js */
	var virtualdom_items_Element$unrender = function( runloop, Transition ) {

		var __export;
		__export = function Element$unrender( shouldDestroy ) {
			var binding, bindings;
			if ( this.transition ) {
				this.transition.complete();
			}
			// Detach as soon as we can
			if ( this.name === 'option' ) {
				// <option> elements detach immediately, so that
				// their parent <select> element syncs correctly, and
				// since option elements can't have transitions anyway
				this.detach();
			} else if ( shouldDestroy ) {
				runloop.detachWhenReady( this );
			}
			// Children first. that way, any transitions on child elements will be
			// handled by the current transitionManager
			if ( this.fragment ) {
				this.fragment.unrender( false );
			}
			if ( binding = this.binding ) {
				this.binding.unrender();
				this.node._ractive.binding = null;
				bindings = this.root._twowayBindings[ binding.keypath ];
				bindings.splice( bindings.indexOf( binding ), 1 );
			}
			// Remove event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.unrender();
				} );
			}
			if ( this.decorator ) {
				this.decorator.teardown();
			}
			// trigger outro transition if necessary
			if ( this.root.transitionsEnabled && this.outro ) {
				var transition = new Transition( this, this.outro, false );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			// Remove this node from any live queries
			if ( this.liveQueries ) {
				removeFromLiveQueries( this );
			}
		};

		function removeFromLiveQueries( element ) {
			var query, selector, i;
			i = element.liveQueries.length;
			while ( i-- ) {
				query = element.liveQueries[ i ];
				selector = query.selector;
				query._remove( element.node );
			}
		}
		return __export;
	}( runloop, Transition );

	/* virtualdom/items/Element/_Element.js */
	var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

		var Element = function( options ) {
			this.init( options );
		};
		Element.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getAttribute: getAttribute,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Element;
	}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

	/* virtualdom/items/Partial/deIndent.js */
	var deIndent = function() {

		var __export;
		var empty = /^\s*$/,
			leadingWhitespace = /^\s*/;
		__export = function( str ) {
			var lines, firstLine, lastLine, minIndent;
			lines = str.split( '\n' );
			// remove first and last line, if they only contain whitespace
			firstLine = lines[ 0 ];
			if ( firstLine !== undefined && empty.test( firstLine ) ) {
				lines.shift();
			}
			lastLine = lines[ lines.length - 1 ];
			if ( lastLine !== undefined && empty.test( lastLine ) ) {
				lines.pop();
			}
			minIndent = lines.reduce( reducer, null );
			if ( minIndent ) {
				str = lines.map( function( line ) {
					return line.replace( minIndent, '' );
				} ).join( '\n' );
			}
			return str;
		};

		function reducer( previous, line ) {
			var lineIndent = leadingWhitespace.exec( line )[ 0 ];
			if ( previous === null || lineIndent.length < previous.length ) {
				return lineIndent;
			}
			return previous;
		}
		return __export;
	}();

	/* virtualdom/items/Partial/getPartialTemplate.js */
	var getPartialTemplate = function( log, config, parser, deIndent ) {

		var __export;
		__export = function getPartialTemplate( ractive, name ) {
			var partial;
			// If the partial in instance or view heirarchy instances, great
			if ( partial = getPartialFromRegistry( ractive, name ) ) {
				return partial;
			}
			// Does it exist on the page as a script tag?
			partial = parser.fromId( name, {
				noThrow: true
			} );
			if ( partial ) {
				// is this necessary?
				partial = deIndent( partial );
				// parse and register to this ractive instance
				var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
				// register (and return main partial if there are others in the template)
				return ractive.partials[ name ] = parsed.t;
			}
		};

		function getPartialFromRegistry( ractive, name ) {
			var partials = config.registries.partials;
			// find first instance in the ractive or view hierarchy that has this partial
			var instance = partials.findInstance( ractive, name );
			if ( !instance ) {
				return;
			}
			var partial = instance.partials[ name ],
				fn;
			// partial is a function?
			if ( typeof partial === 'function' ) {
				fn = partial.bind( instance );
				fn.isOwner = instance.partials.hasOwnProperty( name );
				partial = fn( instance.data, parser );
			}
			if ( !partial ) {
				log.warn( {
					debug: ractive.debug,
					message: 'noRegistryFunctionReturn',
					args: {
						registry: 'partial',
						name: name
					}
				} );
				return;
			}
			// If this was added manually to the registry,
			// but hasn't been parsed, parse it now
			if ( !parser.isParsed( partial ) ) {
				// use the parseOptions of the ractive instance on which it was found
				var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
				// Partials cannot contain nested partials!
				// TODO add a test for this
				if ( parsed.p ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noNestedPartials',
						args: {
							rname: name
						}
					} );
				}
				// if fn, use instance to store result, otherwise needs to go
				// in the correct point in prototype chain on instance or constructor
				var target = fn ? instance : partials.findOwner( instance, name );
				// may be a template with partials, which need to be registered and main template extracted
				target.partials[ name ] = partial = parsed.t;
			}
			// store for reset
			if ( fn ) {
				partial._fn = fn;
			}
			return partial.v ? partial.t : partial;
		}
		return __export;
	}( log, config, parser, deIndent );

	/* virtualdom/items/Partial/applyIndent.js */
	var applyIndent = function( string, indent ) {
		var indented;
		if ( !indent ) {
			return string;
		}
		indented = string.split( '\n' ).map( function( line, notFirstLine ) {
			return notFirstLine ? indent + line : line;
		} ).join( '\n' );
		return indented;
	};

	/* virtualdom/items/Partial/_Partial.js */
	var Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {

		var Partial, Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Partial = function( options ) {
			var parentFragment, template;
			parentFragment = this.parentFragment = options.parentFragment;
			this.root = parentFragment.root;
			this.type = types.PARTIAL;
			this.index = options.index;
			this.name = options.template.r;
			this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;
			Mustache.init( this, options );
			// If this didn't resolve, it most likely means we have a named partial
			// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
			// whose name is the value of `foo`')
			if ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {
				unbind.call( this );
				// prevent any further changes
				this.isNamed = true;
				this.setTemplate( template );
			}
		};
		Partial.prototype = {
			bubble: function() {
				this.parentFragment.bubble();
			},
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			findNextNode: function() {
				return this.parentFragment.findNextNode( this );
			},
			getValue: function() {
				return this.fragment.getValue();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				rebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function() {
				this.docFrag = document.createDocumentFragment();
				this.update();
				this.rendered = true;
				return this.docFrag;
			},
			resolve: Mustache.resolve,
			setValue: function( value ) {
				var template;
				if ( value !== undefined && value === this.value ) {
					// nothing has changed, so no work to be done
					return;
				}
				template = getPartialTemplate( this.root, '' + value );
				// we may be here if we have a partial like `{{>foo}}` and `foo` is the
				// name of both a data property (whose value ISN'T the name of a partial)
				// and a partial. In those cases, this becomes a named partial
				if ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {
					unbind.call( this );
					this.isNamed = true;
				}
				if ( !template ) {
					log.error( {
						debug: this.root.debug,
						message: 'noTemplateForPartial',
						args: {
							name: this.name
						}
					} );
				}
				this.setTemplate( template || [] );
				this.value = value;
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			},
			setTemplate: function( template ) {
				if ( this.fragment ) {
					this.fragment.unbind();
					this.fragmentToUnrender = this.fragment;
				}
				this.fragment = new Fragment( {
					template: template,
					root: this.root,
					owner: this,
					pElement: this.parentFragment.pElement
				} );
				this.fragmentToRender = this.fragment;
			},
			toString: function( toString ) {
				var string, previousItem, lastLine, match;
				string = this.fragment.toString( toString );
				previousItem = this.parentFragment.items[ this.index - 1 ];
				if ( !previousItem || previousItem.type !== types.TEXT ) {
					return string;
				}
				lastLine = previousItem.text.split( '\n' ).pop();
				if ( match = /^\s+$/.exec( lastLine ) ) {
					return applyIndent( string, match[ 0 ] );
				}
				return string;
			},
			unbind: function() {
				if ( !this.isNamed ) {
					// dynamic partial - need to unbind self
					unbind.call( this );
				}
				if ( this.fragment ) {
					this.fragment.unbind();
				}
			},
			unrender: function( shouldDestroy ) {
				if ( this.rendered ) {
					if ( this.fragment ) {
						this.fragment.unrender( shouldDestroy );
					}
					this.rendered = false;
				}
			},
			update: function() {
				var target, anchor;
				if ( this.fragmentToUnrender ) {
					this.fragmentToUnrender.unrender( true );
					this.fragmentToUnrender = null;
				}
				if ( this.fragmentToRender ) {
					this.docFrag.appendChild( this.fragmentToRender.render() );
					this.fragmentToRender = null;
				}
				if ( this.rendered ) {
					target = this.parentFragment.getNode();
					anchor = this.parentFragment.findNextNode( this );
					target.insertBefore( this.docFrag, anchor );
				}
			}
		};
		return Partial;
	}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );

	/* virtualdom/items/Component/getComponent.js */
	var getComponent = function( config, log, circular ) {

		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		// finds the component constructor in the registry or view hierarchy registries
		return function getComponent( ractive, name ) {
			var component, instance = config.registries.components.findInstance( ractive, name );
			if ( instance ) {
				component = instance.components[ name ];
				// best test we have for not Ractive.extend
				if ( !component._parent ) {
					// function option, execute and store for reset
					var fn = component.bind( instance );
					fn.isOwner = instance.components.hasOwnProperty( name );
					component = fn( instance.data );
					if ( !component ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noRegistryFunctionReturn',
							args: {
								registry: 'component',
								name: name
							}
						} );
						return;
					}
					if ( typeof component === 'string' ) {
						//allow string lookup
						component = getComponent( ractive, component );
					}
					component._fn = fn;
					instance.components[ name ] = component;
				}
			}
			return component;
		};
	}( config, log, circular );

	/* virtualdom/items/Component/prototype/detach.js */
	var virtualdom_items_Component$detach = function( Hook ) {

		var detachHook = new Hook( 'detach' );
		return function Component$detach() {
			var detached = this.instance.fragment.detach();
			detachHook.fire( this.instance );
			return detached;
		};
	}( Ractive$shared_hooks_Hook );

	/* virtualdom/items/Component/prototype/find.js */
	var virtualdom_items_Component$find = function Component$find( selector ) {
		return this.instance.fragment.find( selector );
	};

	/* virtualdom/items/Component/prototype/findAll.js */
	var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
		return this.instance.fragment.findAll( selector, query );
	};

	/* virtualdom/items/Component/prototype/findAllComponents.js */
	var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
		query._test( this, true );
		if ( this.instance.fragment ) {
			this.instance.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Component/prototype/findComponent.js */
	var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
		if ( !selector || selector === this.name ) {
			return this.instance;
		}
		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( selector );
		}
		return null;
	};

	/* virtualdom/items/Component/prototype/findNextNode.js */
	var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Component/prototype/firstNode.js */
	var virtualdom_items_Component$firstNode = function Component$firstNode() {
		if ( this.rendered ) {
			return this.instance.fragment.firstNode();
		}
		return null;
	};

	/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
	var ComponentParameter = function( runloop, circular ) {

		var Fragment, ComponentParameter;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		ComponentParameter = function( component, key, value ) {
			this.parentFragment = component.parentFragment;
			this.component = component;
			this.key = key;
			this.fragment = new Fragment( {
				template: value,
				root: component.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
		};
		ComponentParameter.prototype = {
			bubble: function() {
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.addView( this );
				}
			},
			update: function() {
				var value = this.fragment.getValue();
				this.component.instance.viewmodel.set( this.key, value );
				runloop.addViewmodel( this.component.instance.viewmodel );
				this.value = value;
				this.dirty = false;
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			}
		};
		return ComponentParameter;
	}( runloop, circular );

	/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */
	var ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {

		var ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {
			var this$0 = this;
			this.root = component.root;
			this.parentFragment = component.parentFragment;
			this.ready = false;
			this.hash = null;
			this.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {
				// Are we updating an existing binding?
				if ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {
					component.bindings[ this$0.hash ] = null;
					this$0.binding.rebind( keypath );
					this$0.hash = keypath + '=' + childKeypath;
					component.bindings[ this$0.hash ];
				} else {
					if ( !this$0.ready ) {
						// The child instance isn't created yet, we need to create the binding later
						toBind.push( {
							childKeypath: childKeypath,
							parentKeypath: keypath
						} );
					} else {
						createComponentBinding( component, component.root, keypath, childKeypath );
					}
				}
				this$0.value = component.root.viewmodel.get( keypath );
			} );
		};
		ReferenceExpressionParameter.prototype = {
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.resolver.unbind();
			}
		};
		return ReferenceExpressionParameter;
	}( ReferenceExpressionResolver, createComponentBinding );

	/* virtualdom/items/Component/initialise/createModel/_createModel.js */
	var createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {

		var __export;
		__export = function( component, defaultData, attributes, toBind ) {
			var data = {},
				key, value;
			// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
			// other words, we need to construct a string fragment to watch
			// when they change. We store these so they can be torn down later
			component.complexParameters = [];
			for ( key in attributes ) {
				if ( attributes.hasOwnProperty( key ) ) {
					value = getValue( component, key, attributes[ key ], toBind );
					if ( value !== undefined || defaultData[ key ] === undefined ) {
						data[ key ] = value;
					}
				}
			}
			return data;
		};

		function getValue( component, key, template, toBind ) {
			var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
			parentInstance = component.root;
			parentFragment = component.parentFragment;
			// If this is a static value, great
			if ( typeof template === 'string' ) {
				parsed = parseJSON( template );
				if ( !parsed ) {
					return template;
				}
				return parsed.value;
			}
			// If null, we treat it as a boolean attribute (i.e. true)
			if ( template === null ) {
				return true;
			}
			// Single interpolator?
			if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {
				// If it's a regular interpolator, we bind to it
				if ( template[ 0 ].r ) {
					// Is it an index reference?
					if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
						component.indexRefBindings[ indexRef ] = key;
						return parentFragment.indexRefs[ indexRef ];
					}
					// TODO what about references that resolve late? Should these be considered?
					keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
					// We need to set up bindings between parent and child, but
					// we can't do it yet because the child instance doesn't exist
					// yet - so we make a note instead
					toBind.push( {
						childKeypath: key,
						parentKeypath: keypath
					} );
					return parentInstance.viewmodel.get( keypath );
				}
				// If it's a reference expression (e.g. `{{foo[bar]}}`), we need
				// to watch the keypath and create/destroy bindings
				if ( template[ 0 ].rx ) {
					parameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );
					component.complexParameters.push( parameter );
					parameter.ready = true;
					return parameter.value;
				}
			}
			// We have a 'complex parameter' - we need to create a full-blown string
			// fragment in order to evaluate and observe its value
			parameter = new ComponentParameter( component, key, template );
			component.complexParameters.push( parameter );
			return parameter.value;
		}
		return __export;
	}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );

	/* virtualdom/items/Component/initialise/createInstance.js */
	var createInstance = function( log ) {

		return function( component, Component, data, contentDescriptor ) {
			var instance, parentFragment, partials, ractive;
			parentFragment = component.parentFragment;
			ractive = component.root;
			// Make contents available as a {{>content}} partial
			partials = {
				content: contentDescriptor || []
			};
			if ( Component.defaults.el ) {
				log.warn( {
					debug: ractive.debug,
					message: 'defaultElSpecified',
					args: {
						name: component.name
					}
				} );
			}
			instance = new Component( {
				el: null,
				append: true,
				data: data,
				partials: partials,
				magic: ractive.magic || Component.defaults.magic,
				modifyArrays: ractive.modifyArrays,
				_parent: ractive,
				_component: component,
				// need to inherit runtime parent adaptors
				adapt: ractive.adapt,
				yield: {
					template: contentDescriptor,
					instance: ractive
				}
			} );
			return instance;
		};
	}( log );

	/* virtualdom/items/Component/initialise/createBindings.js */
	var createBindings = function( createComponentBinding ) {

		return function createInitialComponentBindings( component, toBind ) {
			toBind.forEach( function createInitialComponentBinding( pair ) {
				var childValue, parentValue;
				createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
				childValue = component.instance.viewmodel.get( pair.childKeypath );
				parentValue = component.root.viewmodel.get( pair.parentKeypath );
				if ( childValue !== undefined && parentValue === undefined ) {
					component.root.viewmodel.set( pair.parentKeypath, childValue );
				}
			} );
		};
	}( createComponentBinding );

	/* virtualdom/items/Component/initialise/propagateEvents.js */
	var propagateEvents = function( circular, fireEvent, log ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function propagateEvents( component, eventsDescriptor ) {
			var eventName;
			for ( eventName in eventsDescriptor ) {
				if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
					propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
				}
			}
		};

		function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
			if ( typeof proxyEventName !== 'string' ) {
				log.error( {
					debug: parentInstance.debug,
					message: 'noComponentEventArguments'
				} );
			}
			childInstance.on( eventName, function() {
				var event, args;
				// semi-weak test, but what else? tag the event obj ._isEvent ?
				if ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {
					event = Array.prototype.shift.call( arguments );
				}
				args = Array.prototype.slice.call( arguments );
				fireEvent( parentInstance, proxyEventName, {
					event: event,
					args: args
				} );
				// cancel bubbling
				return false;
			} );
		}
		return __export;
	}( circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Component/initialise/updateLiveQueries.js */
	var updateLiveQueries = function( component ) {
		var ancestor, query;
		// If there's a live query for this component type, add it
		ancestor = component.root;
		while ( ancestor ) {
			if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
				query.push( component.instance );
			}
			ancestor = ancestor._parent;
		}
	};

	/* virtualdom/items/Component/prototype/init.js */
	var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

		return function Component$init( options, Component ) {
			var parentFragment, root, data, toBind;
			parentFragment = this.parentFragment = options.parentFragment;
			root = parentFragment.root;
			this.root = root;
			this.type = types.COMPONENT;
			this.name = options.template.e;
			this.index = options.index;
			this.indexRefBindings = {};
			this.bindings = [];
			// even though only one yielder is allowed, we need to have an array of them
			// as it's possible to cause a yielder to be created before the last one
			// was destroyed in the same turn of the runloop
			this.yielders = [];
			if ( !Component ) {
				throw new Error( 'Component "' + this.name + '" not found' );
			}
			// First, we need to create a model for the component - e.g. if we
			// encounter <widget foo='bar'/> then we need to create a widget
			// with `data: { foo: 'bar' }`.
			//
			// This may involve setting up some bindings, but we can't do it
			// yet so we take some notes instead
			toBind = [];
			data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
			createInstance( this, Component, data, options.template.f );
			createBindings( this, toBind );
			propagateEvents( this, options.template.v );
			// intro, outro and decorator directives have no effect
			if ( options.template.t1 || options.template.t2 || options.template.o ) {
				warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
			}
			updateLiveQueries( this );
		};
	}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

	/* virtualdom/items/Component/prototype/rebind.js */
	var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

		return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var childInstance = this.instance,
				parentInstance = childInstance._parent,
				indexRefAlias, query;
			this.bindings.forEach( function( binding ) {
				var updated;
				if ( binding.root !== parentInstance ) {
					return;
				}
				if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
					binding.rebind( updated );
				}
			} );
			this.complexParameters.forEach( rebind );
			if ( this.yielders[ 0 ] ) {
				rebind( this.yielders[ 0 ] );
			}
			if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
				runloop.addViewmodel( childInstance.viewmodel );
				childInstance.viewmodel.set( indexRefAlias, newIndex );
			}
			if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
				query._makeDirty();
			}

			function rebind( x ) {
				x.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( runloop, getNewKeypath );

	/* virtualdom/items/Component/prototype/render.js */
	var virtualdom_items_Component$render = function Component$render() {
		var instance = this.instance;
		instance.render( this.parentFragment.getNode() );
		this.rendered = true;
		return instance.fragment.detach();
	};

	/* virtualdom/items/Component/prototype/toString.js */
	var virtualdom_items_Component$toString = function Component$toString() {
		return this.instance.fragment.toString();
	};

	/* virtualdom/items/Component/prototype/unbind.js */
	var virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {

		var __export;
		var teardownHook = new Hook( 'teardown' );
		__export = function Component$unbind() {
			var instance = this.instance;
			this.complexParameters.forEach( unbind );
			this.bindings.forEach( unbind );
			removeFromLiveComponentQueries( this );
			// teardown the instance
			instance.fragment.unbind();
			instance.viewmodel.teardown();
			if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
				removeFromArray( instance.el.__ractive_instances__, instance );
			}
			teardownHook.fire( instance );
		};

		function unbind( thing ) {
			thing.unbind();
		}

		function removeFromLiveComponentQueries( component ) {
			var instance, query;
			instance = component.root;
			do {
				if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
					query._remove( component );
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* virtualdom/items/Component/prototype/unrender.js */
	var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
		this.shouldDestroy = shouldDestroy;
		this.instance.unrender();
	};

	/* virtualdom/items/Component/_Component.js */
	var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

		var Component = function( options, Constructor ) {
			this.init( options, Constructor );
		};
		Component.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Component;
	}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

	/* virtualdom/items/Comment.js */
	var Comment = function( types, detach ) {

		var Comment = function( options ) {
			this.type = types.COMMENT;
			this.value = options.template.c;
		};
		Comment.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createComment( this.value );
				}
				return this.node;
			},
			toString: function() {
				return '<!--' + this.value + '-->';
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					this.node.parentNode.removeChild( this.node );
				}
			}
		};
		return Comment;
	}( types, detach );

	/* virtualdom/items/Yielder.js */
	var Yielder = function( runloop, removeFromArray, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var Yielder = function( options ) {
			var componentInstance, component;
			componentInstance = options.parentFragment.root;
			this.component = component = componentInstance.component;
			this.surrogateParent = options.parentFragment;
			this.parentFragment = component.parentFragment;
			this.fragment = new Fragment( {
				owner: this,
				root: componentInstance.yield.instance,
				template: componentInstance.yield.template,
				pElement: this.surrogateParent.pElement
			} );
			component.yielders.push( this );
			runloop.scheduleTask( function() {
				if ( component.yielders.length > 1 ) {
					throw new Error( 'A component template can only have one {{yield}} declaration at a time' );
				}
			} );
		};
		Yielder.prototype = {
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			findNextNode: function() {
				return this.surrogateParent.findNextNode( this );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			getValue: function( options ) {
				return this.fragment.getValue( options );
			},
			render: function() {
				return this.fragment.render();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			unrender: function( shouldDestroy ) {
				this.fragment.unrender( shouldDestroy );
				removeFromArray( this.component.yielders, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		return Yielder;
	}( runloop, removeFromArray, circular );

	/* virtualdom/Fragment/prototype/init/createItem.js */
	var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {

		return function createItem( options ) {
			if ( typeof options.template === 'string' ) {
				return new Text( options );
			}
			switch ( options.template.t ) {
				case types.INTERPOLATOR:
					if ( options.template.r === 'yield' ) {
						return new Yielder( options );
					}
					return new Interpolator( options );
				case types.SECTION:
					return new Section( options );
				case types.TRIPLE:
					return new Triple( options );
				case types.ELEMENT:
					var constructor;
					if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
						return new Component( options, constructor );
					}
					return new Element( options );
				case types.PARTIAL:
					return new Partial( options );
				case types.COMMENT:
					return new Comment( options );
				default:
					throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
			}
		};
	}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );

	/* virtualdom/Fragment/prototype/init.js */
	var virtualdom_Fragment$init = function( types, create, createItem ) {

		return function Fragment$init( options ) {
			var this$0 = this;
			var parentFragment, parentRefs, ref;
			// The item that owns this fragment - an element, section, partial, or attribute
			this.owner = options.owner;
			parentFragment = this.parent = this.owner.parentFragment;
			// inherited properties
			this.root = options.root;
			this.pElement = options.pElement;
			this.context = options.context;
			// If parent item is a section, this may not be the only fragment
			// that belongs to it - we need to make a note of the index
			if ( this.owner.type === types.SECTION ) {
				this.index = options.index;
			}
			// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
			// down the tree
			if ( parentFragment ) {
				parentRefs = parentFragment.indexRefs;
				if ( parentRefs ) {
					this.indexRefs = create( null );
					// avoids need for hasOwnProperty
					for ( ref in parentRefs ) {
						this.indexRefs[ ref ] = parentRefs[ ref ];
					}
				}
			}
			if ( options.indexRef ) {
				if ( !this.indexRefs ) {
					this.indexRefs = {};
				}
				this.indexRefs[ options.indexRef ] = options.index;
			}
			// Time to create this fragment's child items
			// TEMP should this be happening?
			if ( typeof options.template === 'string' ) {
				options.template = [ options.template ];
			} else if ( !options.template ) {
				options.template = [];
			}
			this.items = options.template.map( function( template, i ) {
				return createItem( {
					parentFragment: this$0,
					pElement: options.pElement,
					template: template,
					index: i
				} );
			} );
			this.value = this.argsList = null;
			this.dirtyArgs = this.dirtyValue = true;
			this.bound = true;
		};
	}( types, create, virtualdom_Fragment$init_createItem );

	/* virtualdom/Fragment/prototype/rebind.js */
	var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

		return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			this.index = newIndex;
			// assign new context keypath if needed
			assignNewKeypath( this, 'context', oldKeypath, newKeypath );
			if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
				this.indexRefs[ indexRef ] = newIndex;
			}
			this.items.forEach( function( item ) {
				if ( item.rebind ) {
					item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			} );
		};
	}( assignNewKeypath );

	/* virtualdom/Fragment/prototype/render.js */
	var virtualdom_Fragment$render = function Fragment$render() {
		var result;
		if ( this.items.length === 1 ) {
			result = this.items[ 0 ].render();
		} else {
			result = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				result.appendChild( item.render() );
			} );
		}
		this.rendered = true;
		return result;
	};

	/* virtualdom/Fragment/prototype/toString.js */
	var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
		if ( !this.items ) {
			return '';
		}
		return this.items.map( function( item ) {
			return item.toString( escape );
		} ).join( '' );
	};

	/* virtualdom/Fragment/prototype/unbind.js */
	var virtualdom_Fragment$unbind = function() {

		var __export;
		__export = function Fragment$unbind() {
			if ( !this.bound ) {
				return;
			}
			this.items.forEach( unbindItem );
			this.bound = false;
		};

		function unbindItem( item ) {
			if ( item.unbind ) {
				item.unbind();
			}
		}
		return __export;
	}();

	/* virtualdom/Fragment/prototype/unrender.js */
	var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
		if ( !this.rendered ) {
			throw new Error( 'Attempted to unrender a fragment that was not rendered' );
		}
		this.items.forEach( function( i ) {
			return i.unrender( shouldDestroy );
		} );
		this.rendered = false;
	};

	/* virtualdom/Fragment.js */
	var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

		var Fragment = function( options ) {
			this.init( options );
		};
		Fragment.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getNode: getNode,
			getValue: getValue,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		circular.Fragment = Fragment;
		return Fragment;
	}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

	/* Ractive/prototype/reset.js */
	var Ractive$reset = function( Hook, runloop, Fragment, config ) {

		var shouldRerender = [
				'template',
				'partials',
				'components',
				'decorators',
				'events'
			],
			resetHook = new Hook( 'reset' );
		return function Ractive$reset( data, callback ) {
			var promise, wrapper, changes, i, rerender;
			if ( typeof data === 'function' && !callback ) {
				callback = data;
				data = {};
			} else {
				data = data || {};
			}
			if ( typeof data !== 'object' ) {
				throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
			}
			// If the root object is wrapped, try and use the wrapper's reset value
			if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
				if ( wrapper.reset( data ) === false ) {
					// reset was rejected, we need to replace the object
					this.data = data;
				}
			} else {
				this.data = data;
			}
			// reset config items and track if need to rerender
			changes = config.reset( this );
			i = changes.length;
			while ( i-- ) {
				if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
					rerender = true;
					break;
				}
			}
			if ( rerender ) {
				var component;
				this.viewmodel.mark( '' );
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// If the template changed, we need to destroy the parallel DOM
				// TODO if we're here, presumably it did?
				if ( this.fragment.template !== this.template ) {
					this.fragment.unbind();
					this.fragment = new Fragment( {
						template: this.template,
						root: this,
						owner: this
					} );
				}
				promise = this.render( this.el, this.anchor );
			} else {
				promise = runloop.start( this, true );
				this.viewmodel.mark( '' );
				runloop.end();
			}
			resetHook.fire( this, data );
			if ( callback ) {
				promise.then( callback );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop, Fragment, config );

	/* Ractive/prototype/resetTemplate.js */
	var Ractive$resetTemplate = function( config, Fragment ) {

		return function Ractive$resetTemplate( template ) {
			var transitionsEnabled, component;
			config.template.init( null, this, {
				template: template
			} );
			transitionsEnabled = this.transitionsEnabled;
			this.transitionsEnabled = false;
			// Is this is a component, we need to set the `shouldDestroy`
			// flag, otherwise it will assume by default that a parent node
			// will be detached, and therefore it doesn't need to bother
			// detaching its own nodes
			if ( component = this.component ) {
				component.shouldDestroy = true;
			}
			this.unrender();
			if ( component ) {
				component.shouldDestroy = false;
			}
			// remove existing fragment and create new one
			this.fragment.unbind();
			this.fragment = new Fragment( {
				template: this.template,
				root: this,
				owner: this
			} );
			this.render( this.el, this.anchor );
			this.transitionsEnabled = transitionsEnabled;
		};
	}( config, Fragment );

	/* Ractive/prototype/reverse.js */
	var Ractive$reverse = function( makeArrayMethod ) {

		return makeArrayMethod( 'reverse' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/set.js */
	var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

		var wildcard = /\*/;
		return function Ractive$set( keypath, value, callback ) {
			var this$0 = this;
			var map, promise;
			promise = runloop.start( this, true );
			// Set multiple keypaths in one go
			if ( isObject( keypath ) ) {
				map = keypath;
				callback = value;
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						value = map[ keypath ];
						keypath = normaliseKeypath( keypath );
						this.viewmodel.set( keypath, value );
					}
				}
			} else {
				keypath = normaliseKeypath( keypath );
				if ( wildcard.test( keypath ) ) {
					getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
						this$0.viewmodel.set( keypath, value );
					} );
				} else {
					this.viewmodel.set( keypath, value );
				}
			}
			runloop.end();
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

	/* Ractive/prototype/shift.js */
	var Ractive$shift = function( makeArrayMethod ) {

		return makeArrayMethod( 'shift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/sort.js */
	var Ractive$sort = function( makeArrayMethod ) {

		return makeArrayMethod( 'sort' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/splice.js */
	var Ractive$splice = function( makeArrayMethod ) {

		return makeArrayMethod( 'splice' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/subtract.js */
	var Ractive$subtract = function( add ) {

		return function Ractive$subtract( keypath, d ) {
			return add( this, keypath, d === undefined ? -1 : -d );
		};
	}( Ractive$shared_add );

	/* Ractive/prototype/teardown.js */
	var Ractive$teardown = function( Hook, Promise, removeFromArray ) {

		var teardownHook = new Hook( 'teardown' );
		// Teardown. This goes through the root fragment and all its children, removing observers
		// and generally cleaning up after itself
		return function Ractive$teardown( callback ) {
			var promise;
			this.fragment.unbind();
			this.viewmodel.teardown();
			if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.shouldDestroy = true;
			promise = this.fragment.rendered ? this.unrender() : Promise.resolve();
			teardownHook.fire( this );
			if ( callback ) {
				// TODO deprecate this?
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, Promise, removeFromArray );

	/* Ractive/prototype/toggle.js */
	var Ractive$toggle = function( log ) {

		return function Ractive$toggle( keypath, callback ) {
			var value;
			if ( typeof keypath !== 'string' ) {
				log.errorOnly( {
					debug: this.debug,
					messsage: 'badArguments',
					arg: {
						arguments: keypath
					}
				} );
			}
			value = this.get( keypath );
			return this.set( keypath, !value, callback );
		};
	}( log );

	/* Ractive/prototype/toHTML.js */
	var Ractive$toHTML = function Ractive$toHTML() {
		return this.fragment.toString( true );
	};

	/* Ractive/prototype/unrender.js */
	var Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {

		var unrenderHook = new Hook( 'unrender' );
		return function Ractive$unrender() {
			var this$0 = this;
			var promise, shouldDestroy;
			if ( !this.fragment.rendered ) {
				log.warn( {
					debug: this.debug,
					message: 'ractive.unrender() was called on a Ractive instance that was not rendered'
				} );
				return Promise.resolve();
			}
			promise = runloop.start( this, true );
			// If this is a component, and the component isn't marked for destruction,
			// don't detach nodes from the DOM unnecessarily
			shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
			if ( this.constructor.css ) {
				promise.then( function() {
					css.remove( this$0.constructor );
				} );
			}
			// Cancel any animations in progress
			while ( this._animations[ 0 ] ) {
				this._animations[ 0 ].stop();
			}
			this.fragment.unrender( shouldDestroy );
			removeFromArray( this.el.__ractive_instances__, this );
			unrenderHook.fire( this );
			runloop.end();
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );

	/* Ractive/prototype/unshift.js */
	var Ractive$unshift = function( makeArrayMethod ) {

		return makeArrayMethod( 'unshift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/update.js */
	var Ractive$update = function( Hook, runloop ) {

		var updateHook = new Hook( 'update' );
		return function Ractive$update( keypath, callback ) {
			var promise;
			if ( typeof keypath === 'function' ) {
				callback = keypath;
				keypath = '';
			} else {
				keypath = keypath || '';
			}
			promise = runloop.start( this, true );
			this.viewmodel.mark( keypath );
			runloop.end();
			updateHook.fire( this, keypath );
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop );

	/* Ractive/prototype/updateModel.js */
	var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

		var __export;
		__export = function Ractive$updateModel( keypath, cascade ) {
			var values;
			if ( typeof keypath !== 'string' ) {
				keypath = '';
				cascade = true;
			}
			consolidateChangedValues( this, keypath, values = {}, cascade );
			return this.set( values );
		};

		function consolidateChangedValues( ractive, keypath, values, cascade ) {
			var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
			bindings = ractive._twowayBindings[ keypath ];
			if ( bindings && ( i = bindings.length ) ) {
				while ( i-- ) {
					binding = bindings[ i ];
					// special case - radio name bindings
					if ( binding.radioName && !binding.element.node.checked ) {
						continue;
					}
					// special case - checkbox name bindings come in groups, so
					// we want to get the value once at most
					if ( binding.checkboxName ) {
						if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
							checkboxGroups.push( binding.keypath );
							checkboxGroups[ binding.keypath ] = binding;
						}
						continue;
					}
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( arrayContentsMatch( oldValue, newValue ) ) {
						continue;
					}
					if ( !isEqual( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				}
			}
			// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
			if ( checkboxGroups.length ) {
				checkboxGroups.forEach( function( keypath ) {
					var binding, oldValue, newValue;
					binding = checkboxGroups[ keypath ];
					// one to represent the entire group
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( !arrayContentsMatch( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				} );
			}
			if ( !cascade ) {
				return;
			}
			// cascade
			childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
			if ( childDeps ) {
				i = childDeps.length;
				while ( i-- ) {
					consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
				}
			}
		}
		return __export;
	}( arrayContentsMatch, isEqual );

	/* Ractive/prototype.js */
	var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

		return {
			add: add,
			animate: animate,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			fire: fire,
			get: get,
			insert: insert,
			merge: merge,
			observe: observe,
			off: off,
			on: on,
			pop: pop,
			push: push,
			render: render,
			reset: reset,
			resetTemplate: resetTemplate,
			reverse: reverse,
			set: set,
			shift: shift,
			sort: sort,
			splice: splice,
			subtract: subtract,
			teardown: teardown,
			toggle: toggle,
			toHTML: toHTML,
			unrender: unrender,
			unshift: unshift,
			update: update,
			updateModel: updateModel
		};
	}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

	/* utils/getGuid.js */
	var getGuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
			var r, v;
			r = Math.random() * 16 | 0;
			v = c == 'x' ? r : r & 3 | 8;
			return v.toString( 16 );
		} );
	};

	/* utils/getNextNumber.js */
	var getNextNumber = function() {

		var i = 0;
		return function() {
			return 'r-' + i++;
		};
	}();

	/* Ractive/prototype/shared/hooks/HookQueue.js */
	var Ractive$shared_hooks_HookQueue = function( Hook ) {

		function HookQueue( event ) {
			this.hook = new Hook( event );
			this.inProcess = {};
			this.queue = {};
		}
		HookQueue.prototype = {
			constructor: HookQueue,
			begin: function( ractive ) {
				this.inProcess[ ractive._guid ] = true;
			},
			end: function( ractive ) {
				var parent = ractive._parent;
				// If this is *isn't* a child of a component that's in process,
				// it should call methods or fire at this point
				if ( !parent || !this.inProcess[ parent._guid ] ) {
					fire( this, ractive );
				} else {
					getChildQueue( this.queue, parent ).push( ractive );
				}
				delete this.inProcess[ ractive._guid ];
			}
		};

		function getChildQueue( queue, ractive ) {
			return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
		}

		function fire( hookQueue, ractive ) {
			var childQueue = getChildQueue( hookQueue.queue, ractive );
			hookQueue.hook.fire( ractive );
			// queue is "live" because components can end up being
			// added while hooks fire on parents that modify data values.
			while ( childQueue.length ) {
				fire( hookQueue, childQueue.shift() );
			}
			delete hookQueue.queue[ ractive._guid ];
		}
		return HookQueue;
	}( Ractive$shared_hooks_Hook );

	/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
	var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {
		var root = wrapper.root,
			keypath = wrapper.keypath;
		// If this is a sort or reverse, we just do root.set()...
		// TODO use merge logic?
		if ( methodName === 'sort' || methodName === 'reverse' ) {
			root.viewmodel.set( keypath, array );
			return;
		}
		root.viewmodel.smartUpdate( keypath, array, newIndices );
	};

	/* viewmodel/prototype/get/arrayAdaptor/patch.js */
	var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {

		var patchedArrayProto = [],
			mutatorMethods = [
				'pop',
				'push',
				'reverse',
				'shift',
				'sort',
				'splice',
				'unshift'
			],
			testObj, patchArrayMethods, unpatchArrayMethods;
		mutatorMethods.forEach( function( methodName ) {
			var method = function() {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 0 );
				var newIndices, result, wrapper, i;
				newIndices = getNewIndices( this, methodName, args );
				// apply the underlying method
				result = Array.prototype[ methodName ].apply( this, arguments );
				// trigger changes
				runloop.start();
				this._ractive.setting = true;
				i = this._ractive.wrappers.length;
				while ( i-- ) {
					wrapper = this._ractive.wrappers[ i ];
					runloop.addViewmodel( wrapper.root.viewmodel );
					processWrapper( wrapper, this, methodName, newIndices );
				}
				runloop.end();
				this._ractive.setting = false;
				return result;
			};
			defineProperty( patchedArrayProto, methodName, {
				value: method
			} );
		} );
		// can we use prototype chain injection?
		// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
		testObj = {};
		if ( testObj.__proto__ ) {
			// yes, we can
			patchArrayMethods = function( array ) {
				array.__proto__ = patchedArrayProto;
			};
			unpatchArrayMethods = function( array ) {
				array.__proto__ = Array.prototype;
			};
		} else {
			// no, we can't
			patchArrayMethods = function( array ) {
				var i, methodName;
				i = mutatorMethods.length;
				while ( i-- ) {
					methodName = mutatorMethods[ i ];
					defineProperty( array, methodName, {
						value: patchedArrayProto[ methodName ],
						configurable: true
					} );
				}
			};
			unpatchArrayMethods = function( array ) {
				var i;
				i = mutatorMethods.length;
				while ( i-- ) {
					delete array[ mutatorMethods[ i ] ];
				}
			};
		}
		patchArrayMethods.unpatch = unpatchArrayMethods;
		return patchArrayMethods;
	}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );

	/* viewmodel/prototype/get/arrayAdaptor.js */
	var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

		var arrayAdaptor,
			// helpers
			ArrayWrapper, errorMessage;
		arrayAdaptor = {
			filter: function( object ) {
				// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
				// or the array didn't trigger the get() itself
				return isArray( object ) && ( !object._ractive || !object._ractive.setting );
			},
			wrap: function( ractive, array, keypath ) {
				return new ArrayWrapper( ractive, array, keypath );
			}
		};
		ArrayWrapper = function( ractive, array, keypath ) {
			this.root = ractive;
			this.value = array;
			this.keypath = keypath;
			// if this array hasn't already been ractified, ractify it
			if ( !array._ractive ) {
				// define a non-enumerable _ractive property to store the wrappers
				defineProperty( array, '_ractive', {
					value: {
						wrappers: [],
						instances: [],
						setting: false
					},
					configurable: true
				} );
				patch( array );
			}
			// store the ractive instance, so we can handle transitions later
			if ( !array._ractive.instances[ ractive._guid ] ) {
				array._ractive.instances[ ractive._guid ] = 0;
				array._ractive.instances.push( ractive );
			}
			array._ractive.instances[ ractive._guid ] += 1;
			array._ractive.wrappers.push( this );
		};
		ArrayWrapper.prototype = {
			get: function() {
				return this.value;
			},
			teardown: function() {
				var array, storage, wrappers, instances, index;
				array = this.value;
				storage = array._ractive;
				wrappers = storage.wrappers;
				instances = storage.instances;
				// if teardown() was invoked because we're clearing the cache as a result of
				// a change that the array itself triggered, we can save ourselves the teardown
				// and immediate setup
				if ( storage.setting ) {
					return false;
				}
				index = wrappers.indexOf( this );
				if ( index === -1 ) {
					throw new Error( errorMessage );
				}
				wrappers.splice( index, 1 );
				// if nothing else depends on this array, we can revert it to its
				// natural state
				if ( !wrappers.length ) {
					delete array._ractive;
					patch.unpatch( this.value );
				} else {
					// remove ractive instance if possible
					instances[ this.root._guid ] -= 1;
					if ( !instances[ this.root._guid ] ) {
						index = instances.indexOf( this.root );
						if ( index === -1 ) {
							throw new Error( errorMessage );
						}
						instances.splice( index, 1 );
					}
				}
			}
		};
		errorMessage = 'Something went wrong in a rather interesting way';
		return arrayAdaptor;
	}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

	/* viewmodel/prototype/get/magicArrayAdaptor.js */
	var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

		var magicArrayAdaptor, MagicArrayWrapper;
		if ( magicAdaptor ) {
			magicArrayAdaptor = {
				filter: function( object, keypath, ractive ) {
					return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
				},
				wrap: function( ractive, array, keypath ) {
					return new MagicArrayWrapper( ractive, array, keypath );
				}
			};
			MagicArrayWrapper = function( ractive, array, keypath ) {
				this.value = array;
				this.magic = true;
				this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
				this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
			};
			MagicArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					this.arrayWrapper.teardown();
					this.magicWrapper.teardown();
				},
				reset: function( value ) {
					return this.magicWrapper.reset( value );
				}
			};
		}
		return magicArrayAdaptor;
	}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

	/* viewmodel/prototype/adapt.js */
	var viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {

		var __export;
		var prefixers = {};
		__export = function Viewmodel$adapt( keypath, value ) {
			var ractive = this.ractive,
				len, i, adaptor, wrapped;
			// Do we have an adaptor for this value?
			len = ractive.adapt.length;
			for ( i = 0; i < len; i += 1 ) {
				adaptor = ractive.adapt[ i ];
				// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
				// we need to get the actual adaptor if that's the case
				if ( typeof adaptor === 'string' ) {
					var found = config.registries.adaptors.find( ractive, adaptor );
					if ( !found ) {
						// will throw. "return" for safety, if we downgrade :)
						return log.critical( {
							debug: ractive.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'adaptor',
								name: adaptor
							}
						} );
					}
					adaptor = ractive.adapt[ i ] = found;
				}
				if ( adaptor.filter( value, keypath, ractive ) ) {
					wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
					wrapped.value = value;
					return value;
				}
			}
			if ( ractive.magic ) {
				if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
				} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
				}
			} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
				this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
			}
			return value;
		};

		function prefixKeypath( obj, prefix ) {
			var prefixed = {},
				key;
			if ( !prefix ) {
				return obj;
			}
			prefix += '.';
			for ( key in obj ) {
				if ( obj.hasOwnProperty( key ) ) {
					prefixed[ prefix + key ] = obj[ key ];
				}
			}
			return prefixed;
		}

		function getPrefixer( rootKeypath ) {
			var rootDot;
			if ( !prefixers[ rootKeypath ] ) {
				rootDot = rootKeypath ? rootKeypath + '.' : '';
				prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
					var obj;
					if ( typeof relativeKeypath === 'string' ) {
						obj = {};
						obj[ rootDot + relativeKeypath ] = value;
						return obj;
					}
					if ( typeof relativeKeypath === 'object' ) {
						// 'relativeKeypath' is in fact a hash, not a keypath
						return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
					}
				};
			}
			return prefixers[ rootKeypath ];
		}
		return __export;
	}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

	/* viewmodel/helpers/getUpstreamChanges.js */
	var getUpstreamChanges = function getUpstreamChanges( changes ) {
		var upstreamChanges = [ '' ],
			i, keypath, keys, upstreamKeypath;
		i = changes.length;
		while ( i-- ) {
			keypath = changes[ i ];
			keys = keypath.split( '.' );
			while ( keys.length > 1 ) {
				keys.pop();
				upstreamKeypath = keys.join( '.' );
				if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
					upstreamChanges.push( upstreamKeypath );
				}
			}
		}
		return upstreamChanges;
	};

	/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
	var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, result;
			keys = keypath.split( '.' );
			starMap = getStarMap( keys.length );
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			result = starMap.map( function( mask ) {
				return mask.map( mapper ).join( '.' );
			} );
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( length ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ length ] ) {
				starMap = [];
				while ( ones.length < length ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < length ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ length ] = starMap;
			}
			return starMaps[ length ];
		}
		return __export;
	}();

	/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
	var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

		var __export;
		var lastKey = /[^\.]+$/;
		__export = notifyPatternObservers;

		function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
			var potentialWildcardMatches;
			updateMatchingPatternObservers( viewmodel, keypath );
			if ( onlyDirect ) {
				return;
			}
			potentialWildcardMatches = getPotentialWildcardMatches( keypath );
			potentialWildcardMatches.forEach( function( upstreamPattern ) {
				cascade( viewmodel, upstreamPattern, keypath );
			} );
		}

		function cascade( viewmodel, upstreamPattern, keypath ) {
			var group, map, actualChildKeypath;
			group = viewmodel.depsMap.patternObservers;
			map = group[ upstreamPattern ];
			if ( map ) {
				map.forEach( function( childKeypath ) {
					var key = lastKey.exec( childKeypath )[ 0 ];
					// 'baz'
					actualChildKeypath = keypath ? keypath + '.' + key : key;
					// 'foo.bar.baz'
					updateMatchingPatternObservers( viewmodel, actualChildKeypath );
					cascade( viewmodel, childKeypath, actualChildKeypath );
				} );
			}
		}

		function updateMatchingPatternObservers( viewmodel, keypath ) {
			viewmodel.patternObservers.forEach( function( observer ) {
				if ( observer.regex.test( keypath ) ) {
					observer.update( keypath );
				}
			} );
		}
		return __export;
	}( viewmodel$applyChanges_getPotentialWildcardMatches );

	/* viewmodel/prototype/applyChanges.js */
	var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

		var __export;
		__export = function Viewmodel$applyChanges() {
			var this$0 = this;
			var self = this,
				changes, upstreamChanges, hash = {};
			changes = this.changes;
			if ( !changes.length ) {
				// TODO we end up here on initial render. Perhaps we shouldn't?
				return;
			}

			function cascade( keypath ) {
				var map, dependants, keys;
				if ( self.noCascade.hasOwnProperty( keypath ) ) {
					return;
				}
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
				if ( map = self.depsMap.computed[ keypath ] ) {
					map.forEach( cascade );
				}
			}

			function mark( keypath ) {
				self.mark( keypath );
			}
			changes.forEach( cascade );
			upstreamChanges = getUpstreamChanges( changes );
			upstreamChanges.forEach( function( keypath ) {
				var dependants, keys;
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
			} );
			this.changes = [];
			// Pattern observers are a weird special case
			if ( this.patternObservers.length ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath, true );
				} );
				changes.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath );
				} );
			}
			if ( this.deps.observers ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, null, keypath, 'observers' );
				} );
				notifyAllDependants( this, changes, 'observers' );
			}
			if ( this.deps[ 'default' ] ) {
				var bindings = [];
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, bindings, keypath, 'default' );
				} );
				if ( bindings.length ) {
					notifyBindings( this, bindings, changes );
				}
				notifyAllDependants( this, changes, 'default' );
			}
			// Return a hash of keypaths to updated values
			changes.forEach( function( keypath ) {
				hash[ keypath ] = this$0.get( keypath );
			} );
			this.implicitChanges = {};
			this.noCascade = {};
			return hash;
		};

		function invalidate( computation ) {
			computation.invalidate();
		}

		function getKey( computation ) {
			return computation.key;
		}

		function notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {
			var dependants, value;
			if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
				value = viewmodel.get( keypath );
				dependants.forEach( function( d ) {
					// don't "set" the parent value, refine it
					// i.e. not data = value, but data[foo] = fooValue
					if ( bindings && d.refineValue ) {
						bindings.push( d );
					} else {
						d.setValue( value );
					}
				} );
			}
		}

		function notifyBindings( viewmodel, bindings, changes ) {
			bindings.forEach( function( binding ) {
				var useSet = false,
					i = 0,
					length = changes.length,
					refinements = [];
				while ( i < length ) {
					var keypath = changes[ i ];
					if ( keypath === binding.keypath ) {
						useSet = true;
						break;
					}
					if ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {
						refinements.push( keypath );
					}
					i++;
				}
				if ( useSet ) {
					binding.setValue( viewmodel.get( binding.keypath ) );
				}
				if ( refinements.length ) {
					binding.refineValue( refinements );
				}
			} );
		}

		function notifyAllDependants( viewmodel, keypaths, groupName ) {
			var queue = [];
			addKeypaths( keypaths );
			queue.forEach( dispatch );

			function addKeypaths( keypaths ) {
				keypaths.forEach( addKeypath );
				keypaths.forEach( cascade );
			}

			function addKeypath( keypath ) {
				var deps = findDependants( viewmodel, keypath, groupName );
				if ( deps ) {
					queue.push( {
						keypath: keypath,
						deps: deps
					} );
				}
			}

			function cascade( keypath ) {
				var childDeps;
				if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
					addKeypaths( childDeps );
				}
			}

			function dispatch( set ) {
				var value = viewmodel.get( set.keypath );
				set.deps.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function findDependants( viewmodel, keypath, groupName ) {
			var group = viewmodel.deps[ groupName ];
			return group ? group[ keypath ] : null;
		}
		return __export;
	}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

	/* viewmodel/prototype/capture.js */
	var viewmodel$capture = function Viewmodel$capture() {
		this.captureGroups.push( [] );
	};

	/* viewmodel/prototype/clearCache.js */
	var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
		var cacheMap, wrapper;
		if ( !dontTeardownWrapper ) {
			// Is there a wrapped property at this keypath?
			if ( wrapper = this.wrapped[ keypath ] ) {
				// Did we unwrap it?
				if ( wrapper.teardown() !== false ) {
					// Is this right?
					// What's the meaning of returning false from teardown?
					// Could there be a GC ramification if this is a "real" ractive.teardown()?
					this.wrapped[ keypath ] = null;
				}
			}
		}
		this.cache[ keypath ] = undefined;
		if ( cacheMap = this.cacheMap[ keypath ] ) {
			while ( cacheMap.length ) {
				this.clearCache( cacheMap.pop() );
			}
		}
	};

	/* viewmodel/Computation/getComputationSignature.js */
	var getComputationSignature = function() {

		var __export;
		var pattern = /\$\{([^\}]+)\}/g;
		__export = function( signature ) {
			if ( typeof signature === 'function' ) {
				return {
					get: signature
				};
			}
			if ( typeof signature === 'string' ) {
				return {
					get: createFunctionFromString( signature )
				};
			}
			if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
				signature = {
					get: createFunctionFromString( signature.get ),
					set: signature.set
				};
			}
			return signature;
		};

		function createFunctionFromString( signature ) {
			var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
				return '__ractive.get("' + keypath + '")';
			} ) + ')';
			return new Function( functionBody );
		}
		return __export;
	}();

	/* viewmodel/Computation/Computation.js */
	var Computation = function( log, isEqual ) {

		var Computation = function( ractive, key, signature ) {
			var this$0 = this;
			this.ractive = ractive;
			this.viewmodel = ractive.viewmodel;
			this.key = key;
			this.getter = signature.get;
			this.setter = signature.set;
			this.hardDeps = signature.deps || [];
			this.softDeps = [];
			this.depValues = {};
			if ( this.hardDeps ) {
				this.hardDeps.forEach( function( d ) {
					return ractive.viewmodel.register( d, this$0, 'computed' );
				} );
			}
			this._dirty = this._firstRun = true;
		};
		Computation.prototype = {
			constructor: Computation,
			init: function() {
				var initial;
				this.bypass = true;
				initial = this.ractive.viewmodel.get( this.key );
				this.ractive.viewmodel.clearCache( this.key );
				this.bypass = false;
				if ( this.setter && initial !== undefined ) {
					this.set( initial );
				}
			},
			invalidate: function() {
				this._dirty = true;
			},
			get: function() {
				var this$0 = this;
				var ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;
				if ( this.getting ) {
					// prevent double-computation (e.g. caused by array mutation inside computation)
					return;
				}
				this.getting = true;
				if ( this._dirty ) {
					ractive = this.ractive;
					// determine whether the inputs have changed, in case this depends on
					// other computed values
					if ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {
						dependencyValuesChanged = true;
					} else {
						[
							this.hardDeps,
							this.softDeps
						].forEach( function( deps ) {
							var keypath, value, i;
							if ( dependencyValuesChanged ) {
								return;
							}
							i = deps.length;
							while ( i-- ) {
								keypath = deps[ i ];
								value = ractive.viewmodel.get( keypath );
								if ( !isEqual( value, this$0.depValues[ keypath ] ) ) {
									this$0.depValues[ keypath ] = value;
									dependencyValuesChanged = true;
									return;
								}
							}
						} );
					}
					if ( dependencyValuesChanged ) {
						ractive.viewmodel.capture();
						try {
							this.value = this.getter.call( ractive );
						} catch ( err ) {
							log.warn( {
								debug: ractive.debug,
								message: 'failedComputation',
								args: {
									key: this.key,
									err: err.message || err
								}
							} );
							this.value = void 0;
						}
						newDeps = ractive.viewmodel.release();
						dependenciesChanged = this.updateDependencies( newDeps );
						if ( dependenciesChanged ) {
							[
								this.hardDeps,
								this.softDeps
							].forEach( function( deps ) {
								deps.forEach( function( keypath ) {
									this$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );
								} );
							} );
						}
					}
					this._dirty = false;
				}
				this.getting = this._firstRun = false;
				return this.value;
			},
			set: function( value ) {
				if ( this.setting ) {
					this.value = value;
					return;
				}
				if ( !this.setter ) {
					throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
				}
				this.setter.call( this.ractive, value );
			},
			updateDependencies: function( newDeps ) {
				var i, oldDeps, keypath, dependenciesChanged;
				oldDeps = this.softDeps;
				// remove dependencies that are no longer used
				i = oldDeps.length;
				while ( i-- ) {
					keypath = oldDeps[ i ];
					if ( newDeps.indexOf( keypath ) === -1 ) {
						dependenciesChanged = true;
						this.viewmodel.unregister( keypath, this, 'computed' );
					}
				}
				// create references for any new dependencies
				i = newDeps.length;
				while ( i-- ) {
					keypath = newDeps[ i ];
					if ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {
						dependenciesChanged = true;
						this.viewmodel.register( keypath, this, 'computed' );
					}
				}
				if ( dependenciesChanged ) {
					this.softDeps = newDeps.slice();
				}
				return dependenciesChanged;
			}
		};
		return Computation;
	}( log, isEqual );

	/* viewmodel/prototype/compute.js */
	var viewmodel$compute = function( getComputationSignature, Computation ) {

		return function Viewmodel$compute( key, signature ) {
			signature = getComputationSignature( signature );
			return this.computations[ key ] = new Computation( this.ractive, key, signature );
		};
	}( getComputationSignature, Computation );

	/* viewmodel/prototype/get/FAILED_LOOKUP.js */
	var viewmodel$get_FAILED_LOOKUP = {
		FAILED_LOOKUP: true
	};

	/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
	var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

		var empty = {};
		var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
			this.viewmodel = viewmodel;
			this.root = viewmodel.ractive;
			// TODO eliminate this
			this.ref = keypath;
			this.parentFragment = empty;
			viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
			viewmodel.unresolvedImplicitDependencies.push( this );
			runloop.addUnresolved( this );
		};
		UnresolvedImplicitDependency.prototype = {
			resolve: function() {
				this.viewmodel.mark( this.ref );
				this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
				removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
			},
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return UnresolvedImplicitDependency;
	}( removeFromArray, runloop );

	/* viewmodel/prototype/get.js */
	var viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {

		var __export;
		var empty = {};
		__export = function Viewmodel$get( keypath ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = empty;
			var ractive = this.ractive,
				cache = this.cache,
				value, computation, wrapped, captureGroup;
			if ( keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				return isNumeric( value ) ? +value : value;
			}
			if ( cache[ keypath ] === undefined ) {
				// Is this a computed property?
				if ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {
					value = computation.get();
					this.adapt( keypath, value );
				} else if ( wrapped = this.wrapped[ keypath ] ) {
					value = wrapped.value;
				} else if ( !keypath ) {
					this.adapt( '', ractive.data );
					value = ractive.data;
				} else {
					value = retrieve( this, keypath );
				}
				cache[ keypath ] = value;
			} else {
				value = cache[ keypath ];
			}
			if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
				value = wrapped.get();
			}
			// capture the keypath, if we're inside a computation
			if ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {
				if ( !~captureGroup.indexOf( keypath ) ) {
					captureGroup.push( keypath );
					// if we couldn't resolve the keypath, we need to make it as a failed
					// lookup, so that the computation updates correctly once we CAN
					// resolve the keypath
					if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
						new UnresolvedImplicitDependency( this, keypath );
					}
				}
			}
			return value === FAILED_LOOKUP ? void 0 : value;
		};

		function retrieve( viewmodel, keypath ) {
			var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
			keys = keypath.split( '.' );
			key = keys.pop();
			parentKeypath = keys.join( '.' );
			parentValue = viewmodel.get( parentKeypath );
			if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
				parentValue = wrapped.get();
			}
			if ( parentValue === null || parentValue === undefined ) {
				return;
			}
			// update cache map
			if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
				viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
			} else {
				if ( cacheMap.indexOf( keypath ) === -1 ) {
					cacheMap.push( keypath );
				}
			}
			// If this property doesn't exist, we return a sentinel value
			// so that we know to query parent scope (if such there be)
			if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
				return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
			}
			value = parentValue[ key ];
			// Do we have an adaptor for this value?
			viewmodel.adapt( keypath, value, false );
			// Update cache
			viewmodel.cache[ keypath ] = value;
			return value;
		}
		return __export;
	}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

	/* viewmodel/prototype/init.js */
	var viewmodel$init = function() {

		var __export;
		__export = function Viewmodel$init() {
			var key, computation, computations = [];
			for ( key in this.ractive.computed ) {
				computation = this.compute( key, this.ractive.computed[ key ] );
				computations.push( computation );
			}
			computations.forEach( init );
		};

		function init( computation ) {
			computation.init();
		}
		return __export;
	}();

	/* viewmodel/prototype/mark.js */
	var viewmodel$mark = function Viewmodel$mark( keypath, options ) {
		var computation;
		// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
		// should not be picked up by pattern observers
		if ( options ) {
			if ( options.implicit ) {
				this.implicitChanges[ keypath ] = true;
			}
			if ( options.noCascade ) {
				this.noCascade[ keypath ] = true;
			}
		}
		if ( computation = this.computations[ keypath ] ) {
			computation.invalidate();
		}
		if ( this.changes.indexOf( keypath ) === -1 ) {
			this.changes.push( keypath );
		}
		this.clearCache( keypath );
	};

	/* viewmodel/prototype/merge/mapOldToNewIndex.js */
	var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
		var usedIndices, firstUnusedIndex, newIndices, changed;
		usedIndices = {};
		firstUnusedIndex = 0;
		newIndices = oldArray.map( function( item, i ) {
			var index, start, len;
			start = firstUnusedIndex;
			len = newArray.length;
			do {
				index = newArray.indexOf( item, start );
				if ( index === -1 ) {
					changed = true;
					return -1;
				}
				start = index + 1;
			} while ( usedIndices[ index ] && start < len );
			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			if ( index !== i ) {
				changed = true;
			}
			usedIndices[ index ] = true;
			return index;
		} );
		return newIndices;
	};

	/* viewmodel/prototype/merge.js */
	var viewmodel$merge = function( warn, mapOldToNewIndex ) {

		var __export;
		var comparators = {};
		__export = function Viewmodel$merge( keypath, currentArray, array, options ) {
			var oldArray, newArray, comparator, newIndices;
			this.mark( keypath );
			if ( options && options.compare ) {
				comparator = getComparatorFunction( options.compare );
				try {
					oldArray = currentArray.map( comparator );
					newArray = array.map( comparator );
				} catch ( err ) {
					// fallback to an identity check - worst case scenario we have
					// to do more DOM manipulation than we thought...
					// ...unless we're in debug mode of course
					if ( this.debug ) {
						throw err;
					} else {
						warn( 'Merge operation: comparison failed. Falling back to identity checking' );
					}
					oldArray = currentArray;
					newArray = array;
				}
			} else {
				oldArray = currentArray;
				newArray = array;
			}
			// find new indices for members of oldArray
			newIndices = mapOldToNewIndex( oldArray, newArray );
			this.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );
		};

		function stringify( item ) {
			return JSON.stringify( item );
		}

		function getComparatorFunction( comparator ) {
			// If `compare` is `true`, we use JSON.stringify to compare
			// objects that are the same shape, but non-identical - i.e.
			// { foo: 'bar' } !== { foo: 'bar' }
			if ( comparator === true ) {
				return stringify;
			}
			if ( typeof comparator === 'string' ) {
				if ( !comparators[ comparator ] ) {
					comparators[ comparator ] = function( item ) {
						return item[ comparator ];
					};
				}
				return comparators[ comparator ];
			}
			if ( typeof comparator === 'function' ) {
				return comparator;
			}
			throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
		}
		return __export;
	}( warn, viewmodel$merge_mapOldToNewIndex );

	/* viewmodel/prototype/register.js */
	var viewmodel$register = function() {

		var __export;
		__export = function Viewmodel$register( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var depsByKeypath, deps;
			if ( dependant.isStatic ) {
				return;
			}
			depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
			deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
			deps.push( dependant );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
				parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
				if ( parent[ keypath ] === undefined ) {
					parent[ keypath ] = 0;
					parent.push( keypath );
				}
				parent[ keypath ] += 1;
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/prototype/release.js */
	var viewmodel$release = function Viewmodel$release() {
		return this.captureGroups.pop();
	};

	/* viewmodel/prototype/set.js */
	var viewmodel$set = function( isEqual, createBranch ) {

		var __export;
		__export = function Viewmodel$set( keypath, value, silent ) {
			var computation, wrapper, dontTeardownWrapper;
			computation = this.computations[ keypath ];
			if ( computation ) {
				if ( computation.setting ) {
					// let the other computation set() handle things...
					return;
				}
				computation.set( value );
				value = computation.get();
			}
			if ( isEqual( this.cache[ keypath ], value ) ) {
				return;
			}
			wrapper = this.wrapped[ keypath ];
			// If we have a wrapper with a `reset()` method, we try and use it. If the
			// `reset()` method returns false, the wrapper should be torn down, and
			// (most likely) a new one should be created later
			if ( wrapper && wrapper.reset ) {
				dontTeardownWrapper = wrapper.reset( value ) !== false;
				if ( dontTeardownWrapper ) {
					value = wrapper.get();
				}
			}
			if ( !computation && !dontTeardownWrapper ) {
				resolveSet( this, keypath, value );
			}
			if ( !silent ) {
				this.mark( keypath );
			} else {
				// We're setting a parent of the original target keypath (i.e.
				// creating a fresh branch) - we need to clear the cache, but
				// not mark it as a change
				this.clearCache( keypath );
			}
		};

		function resolveSet( viewmodel, keypath, value ) {
			var keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;
			wrapperSet = function() {
				if ( wrapper.set ) {
					wrapper.set( lastKey, value );
				} else {
					parentValue = wrapper.get();
					valueSet();
				}
			};
			valueSet = function() {
				if ( !parentValue ) {
					parentValue = createBranch( lastKey );
					viewmodel.set( parentKeypath, parentValue, true );
				}
				parentValue[ lastKey ] = value;
			};
			keys = keypath.split( '.' );
			lastKey = keys.pop();
			parentKeypath = keys.join( '.' );
			wrapper = viewmodel.wrapped[ parentKeypath ];
			if ( wrapper ) {
				wrapperSet();
			} else {
				parentValue = viewmodel.get( parentKeypath );
				// may have been wrapped via the above .get()
				// call on viewmodel if this is first access via .set()!
				if ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {
					wrapperSet();
				} else {
					valueSet();
				}
			}
		}
		return __export;
	}( isEqual, createBranch );

	/* viewmodel/prototype/smartUpdate.js */
	var viewmodel$smartUpdate = function() {

		var __export;
		var implicitOption = {
				implicit: true
			},
			noCascadeOption = {
				noCascade: true
			};
		__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {
			var this$0 = this;
			var dependants, oldLength;
			oldLength = newIndices.length;
			// Indices that are being removed should be marked as dirty
			newIndices.forEach( function( newIndex, oldIndex ) {
				if ( newIndex === -1 ) {
					this$0.mark( keypath + '.' + oldIndex, noCascadeOption );
				}
			} );
			// Update the model
			// TODO allow existing array to be updated in place, rather than replaced?
			this.set( keypath, array, true );
			if ( dependants = this.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canShuffle ).forEach( function( d ) {
					return d.shuffle( newIndices, array );
				} );
			}
			if ( oldLength !== array.length ) {
				this.mark( keypath + '.length', implicitOption );
				for ( var i = oldLength; i < array.length; i += 1 ) {
					this.mark( keypath + '.' + i );
				}
				// don't allow removed indexes beyond end of new array to trigger recomputations
				for ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {
					this.mark( keypath + '.' + i$0, noCascadeOption );
				}
			}
		};

		function canShuffle( dependant ) {
			return typeof dependant.shuffle === 'function';
		}
		return __export;
	}();

	/* viewmodel/prototype/teardown.js */
	var viewmodel$teardown = function Viewmodel$teardown() {
		var this$0 = this;
		var unresolvedImplicitDependency;
		// Clear entire cache - this has the desired side-effect
		// of unwrapping adapted values (e.g. arrays)
		Object.keys( this.cache ).forEach( function( keypath ) {
			return this$0.clearCache( keypath );
		} );
		// Teardown any failed lookups - we don't need them to resolve any more
		while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
			unresolvedImplicitDependency.teardown();
		}
	};

	/* viewmodel/prototype/unregister.js */
	var viewmodel$unregister = function() {

		var __export;
		__export = function Viewmodel$unregister( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var deps, index;
			if ( dependant.isStatic ) {
				return;
			}
			deps = this.deps[ group ][ keypath ];
			index = deps.indexOf( dependant );
			if ( index === -1 ) {
				throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
			}
			deps.splice( index, 1 );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ];
				parent = map[ parentKeypath ];
				parent[ keypath ] -= 1;
				if ( !parent[ keypath ] ) {
					// remove from parent deps map
					parent.splice( parent.indexOf( keypath ), 1 );
					parent[ keypath ] = undefined;
				}
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/adaptConfig.js */
	var adaptConfig = function() {

		// should this be combined with prototype/adapt.js?
		var configure = {
			lookup: function( target, adaptors ) {
				var i, adapt = target.adapt;
				if ( !adapt || !adapt.length ) {
					return adapt;
				}
				if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
					while ( i-- ) {
						var adaptor = adapt[ i ];
						if ( typeof adaptor === 'string' ) {
							adapt[ i ] = adaptors[ adaptor ] || adaptor;
						}
					}
				}
				return adapt;
			},
			combine: function( parent, adapt ) {
				// normalize 'Foo' to [ 'Foo' ]
				parent = arrayIfString( parent );
				adapt = arrayIfString( adapt );
				// no parent? return adapt
				if ( !parent || !parent.length ) {
					return adapt;
				}
				// no adapt? return 'copy' of parent
				if ( !adapt || !adapt.length ) {
					return parent.slice();
				}
				// add parent adaptors to options
				parent.forEach( function( a ) {
					// don't put in duplicates
					if ( adapt.indexOf( a ) === -1 ) {
						adapt.push( a );
					}
				} );
				return adapt;
			}
		};

		function arrayIfString( adapt ) {
			if ( typeof adapt === 'string' ) {
				adapt = [ adapt ];
			}
			return adapt;
		}
		return configure;
	}();

	/* viewmodel/Viewmodel.js */
	var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {

		var noMagic;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
		} catch ( err ) {
			noMagic = true;
		}
		var Viewmodel = function( ractive ) {
			this.ractive = ractive;
			// TODO eventually, we shouldn't need this reference
			Viewmodel.extend( ractive.constructor, ractive );
			this.cache = {};
			// we need to be able to use hasOwnProperty, so can't inherit from null
			this.cacheMap = create( null );
			this.deps = {
				computed: {},
				'default': {}
			};
			this.depsMap = {
				computed: {},
				'default': {}
			};
			this.patternObservers = [];
			this.wrapped = create( null );
			this.computations = create( null );
			this.captureGroups = [];
			this.unresolvedImplicitDependencies = [];
			this.changes = [];
			this.implicitChanges = {};
			this.noCascade = {};
		};
		Viewmodel.extend = function( Parent, instance ) {
			if ( instance.magic && noMagic ) {
				throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
			}
			instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
			instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
		};
		Viewmodel.prototype = {
			adapt: adapt,
			applyChanges: applyChanges,
			capture: capture,
			clearCache: clearCache,
			compute: compute,
			get: get,
			init: init,
			mark: mark,
			merge: merge,
			register: register,
			release: release,
			set: set,
			smartUpdate: smartUpdate,
			teardown: teardown,
			unregister: unregister
		};
		return Viewmodel;
	}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );

	/* Ractive/initialise.js */
	var Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {

		var __export;
		var constructHook = new Hook( 'construct' ),
			configHook = new Hook( 'config' ),
			initHook = new HookQueue( 'init' );
		__export = function initialiseRactiveInstance( ractive ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var el;
			initialiseProperties( ractive, options );
			// make this option do what would be expected if someone
			// did include it on a new Ractive() or new Component() call.
			// Silly to do so (put a hook on the very options being used),
			// but handle it correctly, consistent with the intent.
			constructHook.fire( config.getConstructTarget( ractive, options ), options );
			// init config from Parent and options
			config.init( ractive.constructor, ractive, options );
			configHook.fire( ractive );
			// Teardown any existing instances *before* trying to set up the new one -
			// avoids certain weird bugs
			if ( el = getElement( ractive.el ) ) {
				if ( !ractive.append ) {
					if ( el.__ractive_instances__ ) {
						try {
							el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
								return r.teardown();
							} );
						} catch ( err ) {}
					}
					el.innerHTML = '';
				}
			}
			initHook.begin( ractive );
			// TEMPORARY. This is so we can implement Viewmodel gradually
			ractive.viewmodel = new Viewmodel( ractive );
			// hacky circular problem until we get this sorted out
			// if viewmodel immediately processes computed properties,
			// they may call ractive.get, which calls ractive.viewmodel,
			// which hasn't been set till line above finishes.
			ractive.viewmodel.init();
			// Render our *root fragment*
			if ( ractive.template ) {
				ractive.fragment = new Fragment( {
					template: ractive.template,
					root: ractive,
					owner: ractive
				} );
			}
			initHook.end( ractive );
			// render automatically ( if `el` is specified )
			if ( el ) {
				ractive.render( el, ractive.append );
			}
		};

		function initialiseProperties( ractive, options ) {
			// Generate a unique identifier, for places where you'd use a weak map if it
			// existed
			ractive._guid = getNextNumber();
			// events
			ractive._subs = create( null );
			// storage for item configuration from instantiation to reset,
			// like dynamic functions or original values
			ractive._config = {};
			// two-way bindings
			ractive._twowayBindings = create( null );
			// animations (so we can stop any in progress at teardown)
			ractive._animations = [];
			// nodes registry
			ractive.nodes = {};
			// live queries
			ractive._liveQueries = [];
			ractive._liveComponentQueries = [];
			// If this is a component, store a reference to the parent
			if ( options._parent && options._component ) {
				ractive._parent = options._parent;
				ractive.component = options._component;
				// And store a reference to the instance on the component
				options._component.instance = ractive;
			}
		}
		return __export;
	}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );

	/* extend/unwrapExtended.js */
	var unwrapExtended = function( wrap, config, circular ) {

		var __export;
		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		__export = function unwrapExtended( Child ) {
			if ( !( Child.prototype instanceof Ractive ) ) {
				return Child;
			}
			var options = {};
			while ( Child ) {
				config.registries.forEach( function( r ) {
					addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
				} );
				Object.keys( Child.prototype ).forEach( function( key ) {
					if ( key === 'computed' ) {
						return;
					}
					var value = Child.prototype[ key ];
					if ( !( key in options ) ) {
						options[ key ] = value._method ? value._method : value;
					} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
						var result, needsSuper = value._method;
						if ( needsSuper ) {
							value = value._method;
						}
						// rewrap bound directly to parent fn
						result = wrap( options[ key ]._method, value );
						if ( needsSuper ) {
							result._method = result;
						}
						options[ key ] = result;
					}
				} );
				if ( Child._parent !== Ractive ) {
					Child = Child._parent;
				} else {
					Child = false;
				}
			}
			return options;
		};

		function addRegistry( target, options, name ) {
			var registry, keys = Object.keys( target[ name ] );
			if ( !keys.length ) {
				return;
			}
			if ( !( registry = options[ name ] ) ) {
				registry = options[ name ] = {};
			}
			keys.filter( function( key ) {
				return !( key in registry );
			} ).forEach( function( key ) {
				return registry[ key ] = target[ name ][ key ];
			} );
		}
		return __export;
	}( wrapMethod, config, circular );

	/* extend/_extend.js */
	var Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {

		return function extend() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = {};
			var Parent = this,
				Child, proto, staticProperties;
			// if we're extending with another Ractive instance, inherit its
			// prototype methods and default options as well
			options = unwrap( options );
			// create Child constructor
			Child = function( options ) {
				initialise( this, options );
			};
			proto = create( Parent.prototype );
			proto.constructor = Child;
			staticProperties = {
				// each component needs a guid, for managing CSS etc
				_guid: {
					value: getGuid()
				},
				// alias prototype as defaults
				defaults: {
					value: proto
				},
				// extendable
				extend: {
					value: extend,
					writable: true,
					configurable: true
				},
				// Parent - for IE8, can't use Object.getPrototypeOf
				_parent: {
					value: Parent
				}
			};
			defineProperties( Child, staticProperties );
			// extend configuration
			config.extend( Parent, proto, options );
			Viewmodel.extend( Parent, proto );
			Child.prototype = proto;
			return Child;
		};
	}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );

	/* Ractive.js */
	var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

		var Ractive, properties;
		// Main Ractive required object
		Ractive = function( options ) {
			initialise( this, options );
		};
		// Ractive properties
		properties = {
			// static methods:
			extend: {
				value: extend
			},
			parse: {
				value: parse
			},
			// Namespaced constructors
			Promise: {
				value: Promise
			},
			// support
			svg: {
				value: svg
			},
			magic: {
				value: magic
			},
			// version
			VERSION: {
				value: '0.6.1'
			},
			// Plugins
			adaptors: {
				writable: true,
				value: {}
			},
			components: {
				writable: true,
				value: {}
			},
			decorators: {
				writable: true,
				value: {}
			},
			easing: {
				writable: true,
				value: easing
			},
			events: {
				writable: true,
				value: {}
			},
			interpolators: {
				writable: true,
				value: interpolators
			},
			partials: {
				writable: true,
				value: {}
			},
			transitions: {
				writable: true,
				value: {}
			}
		};
		// Ractive properties
		defineProperties( Ractive, properties );
		Ractive.prototype = extendObj( proto, defaults );
		Ractive.prototype.constructor = Ractive;
		// alias prototype as defaults
		Ractive.defaults = Ractive.prototype;
		// Certain modules have circular dependencies. If we were bundling a
		// module loader, e.g. almond.js, this wouldn't be a problem, but we're
		// not - we're using amdclean as part of the build process. Because of
		// this, we need to wait until all modules have loaded before those
		// circular dependencies can be required.
		circular.Ractive = Ractive;
		while ( circular.length ) {
			circular.pop()();
		}
		// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
		// older browsers, these are made available via a shim - here, we do a quick
		// pre-flight check to make sure that either a) we're not in a shit browser,
		// or b) we're using a Ractive-legacy.js build
		var FUNCTION = 'function';
		if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
			throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
		}
		return Ractive;
	}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


	// export as Common JS module...
	if ( typeof module !== "undefined" && module.exports ) {
		module.exports = Ractive;
	}

	// ... or as AMD module
	else if ( typeof define === "function" && define.amd ) {
		define( function() {
			return Ractive;
		} );
	}

	// ... or as browser global
	global.Ractive = Ractive;

	Ractive.noConflict = function() {
		global.Ractive = noConflict;
		return Ractive;
	};

}( typeof window !== 'undefined' ? window : this ) );

},{}]},{},["./source/js/app.coffee"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvYXBwLmNvZmZlZSIsIm5vZGVfbW9kdWxlcy9kYXQtZ3VpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5jb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9kYXQtZ3VpL3ZlbmRvci9kYXQuZ3VpLmpzIiwibm9kZV9tb2R1bGVzL2ZpcmViYXNlL2xpYi9maXJlYmFzZS13ZWIuanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvYXBwLWRlYnVnLmNvZmZlZSIsIi9Vc2Vycy9sdWtlLmhlZGdlci9kZXYvRXhwZXJpbWVudHMvMDQwNzE1L3NvdXJjZS9qcy9jb25maWcuY29mZmVlIiwiL1VzZXJzL2x1a2UuaGVkZ2VyL2Rldi9FeHBlcmltZW50cy8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9hYnN0cmFjdC1tb2R1bGUuY29mZmVlIiwiL1VzZXJzL2x1a2UuaGVkZ2VyL2Rldi9FeHBlcmltZW50cy8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9pbmRleC5jb2ZmZWUiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL25hdi5jb2ZmZWUiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL3Rlc3QuY29mZmVlIiwiL1VzZXJzL2x1a2UuaGVkZ2VyL2Rldi9FeHBlcmltZW50cy8wNDA3MTUvc291cmNlL2pzL3ZpZXcvbWFpbi12aWV3LmNvZmZlZSIsInNvdXJjZS90ZW1wbGF0ZS9tYWluLXZpZXcuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvbmF2Lmh0bWwiLCJzb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3Rlc3QuaHRtbCIsInZlbmRvci9kb21yZWFkeS9yZWFkeS5qcyIsInZlbmRvci9wYWdlL3BhZ2UuanMiLCJ2ZW5kb3IvcmFjdGl2ZS1ldmVudHMtdGFwL3JhY3RpdmUtZXZlbnRzLXRhcC5qcyIsInZlbmRvci9yYWN0aXZlL3JhY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNDQSxPQUFBLENBQVMsZ0JBQVQsQ0FBQSxDQUFBOztBQUFBLE9BR0EsQ0FBUyxvQkFBVCxDQUhBLENBQUE7O0FBQUEsT0FNQSxDQUFTLFVBQVQsQ0FBQSxDQUFvQixTQUFBLEdBQUE7QUFDbkIsTUFBQSxJQUFBO0FBQUEsRUFBQSxJQUE0QixPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVosS0FBeUIsYUFBckQ7QUFBQSxJQUFBLE9BQUEsQ0FBUyxhQUFULENBQUEsQ0FBQSxDQUFBLENBQUE7R0FBQTtBQUFBLEVBRUEsSUFBQSxHQUFPLE9BQUEsQ0FBUyxrQkFBVCxDQUZQLENBQUE7U0FHQSxNQUFNLENBQUMsS0FBUCxHQUFtQixJQUFBLElBQUEsQ0FBQSxFQUpBO0FBQUEsQ0FBcEIsQ0FOQSxDQUFBOzs7OztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMza0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBLElBQUEsdUJBQUE7O0FBQUEsR0FBQSxHQUFNLE9BQUEsQ0FBUyxTQUFULENBQU4sQ0FBQTs7QUFBQSxJQUNBLEdBQU8sT0FBQSxDQUFTLE1BQVQsQ0FEUCxDQUFBOztBQUFBLEdBSUEsR0FBTSxNQUFNLENBQUMsSUFBUCxHQUFrQixJQUFBLEdBQUcsQ0FBQyxHQUFKLENBQUEsQ0FKeEIsQ0FBQTs7QUFBQSxPQU1BLEdBQ0U7QUFBQSxFQUFBLE9BQUEsRUFBUSxLQUFSO0FBQUEsRUFDQSxPQUFBLEVBQVEsU0FBQSxHQUFBO1dBQUcsSUFBQSxDQUFNLEdBQU4sRUFBSDtFQUFBLENBRFI7QUFBQSxFQUVBLE1BQUEsRUFBTyxTQUFBLEdBQUE7V0FBRyxJQUFBLENBQU0sT0FBTixFQUFIO0VBQUEsQ0FGUDtDQVBGLENBQUE7O0FBQUEsTUFXTSxDQUFDLE9BQVAsR0FBaUIsU0FBQSxHQUFBO0FBRWhCLE1BQUEsYUFBQTtBQUFBLEVBQUEsS0FBQSxHQUFRLEdBQUcsQ0FBQyxHQUFKLENBQVEsT0FBUixFQUFrQixPQUFsQixDQUFSLENBQUE7QUFBQSxFQUdBLE1BQUEsR0FBUyxHQUFHLENBQUMsU0FBSixDQUFlLFlBQWYsQ0FIVCxDQUFBO0FBQUEsRUFJQSxNQUFNLENBQUMsR0FBUCxDQUFXLE9BQVgsRUFBcUIsT0FBckIsQ0FBNEIsQ0FBQyxJQUE3QixDQUFtQyxRQUFuQyxDQUpBLENBQUE7QUFBQSxFQUtBLE1BQU0sQ0FBQyxHQUFQLENBQVcsT0FBWCxFQUFxQixNQUFyQixDQUEyQixDQUFDLElBQTVCLENBQWtDLE9BQWxDLENBTEEsQ0FBQTtTQU1BLE1BQU0sQ0FBQyxJQUFQLENBQUEsRUFSZ0I7QUFBQSxDQVhqQixDQUFBOzs7OztBQ0FBLE1BQU0sQ0FBQyxPQUFQLEdBRUk7QUFBQSxFQUFBLFFBQUEsRUFBVyxXQUFYO0NBRkosQ0FBQTs7Ozs7QUNBQSxJQUFBLE9BQUE7O0FBQUEsT0FBQSxHQUFVLE9BQUEsQ0FBUyxTQUFULENBQVYsQ0FBQTs7QUFBQSxNQUdNLENBQUMsT0FBUCxHQUFpQixPQUFPLENBQUMsTUFBUixDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLElBQVY7Q0FGZ0IsQ0FIakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7R0FBQTtBQUFBLElBQUEsaUJBQUE7O0FBQUEsT0FJQSxHQUFVLE9BQUEsQ0FBUyxTQUFULENBSlYsQ0FBQTs7QUFBQSxRQU1BLEdBQVcsU0FBQSxHQUFBO0FBQ1YsRUFBQSxPQUFPLENBQUMsVUFBWSxDQUFBLFFBQUEsQ0FBcEIsR0FBK0IsT0FBQSxDQUFTLE9BQVQsQ0FBL0IsQ0FBQTtBQUFBLEVBQ0EsT0FBTyxDQUFDLFVBQVksQ0FBQSxTQUFBLENBQXBCLEdBQWdDLE9BQUEsQ0FBUyxRQUFULENBRGhDLENBQUE7U0FHQSxLQUpVO0FBQUEsQ0FOWCxDQUFBOztBQUFBLE1BWU0sQ0FBQyxPQUFQLEdBQWlCLFFBQUEsQ0FBQSxDQVpqQixDQUFBOzs7OztBQ0FBO0FBQUE7Ozs7O0dBQUE7QUFBQSxJQUFBLFlBQUE7O0FBQUEsTUFRQSxHQUFTLE9BQUEsQ0FBUyxtQkFBVCxDQVJULENBQUE7O0FBQUEsSUFVQSxHQUFPLE9BQUEsQ0FBUyxNQUFULENBVlAsQ0FBQTs7QUFBQSxNQVlNLENBQUMsT0FBUCxHQUFpQixNQUFNLENBQUMsTUFBUCxDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLE9BQUEsQ0FBUyxpQkFBVCxDQUFWO0FBQUEsRUFFQSxNQUFBLEVBQVEsU0FBQSxHQUFBO0FBRVAsSUFBQSxJQUFDLENBQUEsRUFBRCxDQUFLLFNBQUwsRUFBZSxTQUFBLEdBQUE7YUFBRyxJQUFBLENBQU0sR0FBTixFQUFIO0lBQUEsQ0FBZixDQUFBLENBQUE7V0FDQSxJQUFDLENBQUEsRUFBRCxDQUFLLFFBQUwsRUFBYyxTQUFBLEdBQUE7YUFBRyxJQUFBLENBQU0sT0FBTixFQUFIO0lBQUEsQ0FBZCxFQUhPO0VBQUEsQ0FGUjtDQUZnQixDQVpqQixDQUFBOzs7OztBQ0FBO0FBQUE7Ozs7O0dBQUE7QUFBQSxJQUFBLE1BQUE7O0FBQUEsTUFRQSxHQUFTLE9BQUEsQ0FBUyxtQkFBVCxDQVJULENBQUE7O0FBQUEsTUFXTSxDQUFDLE9BQVAsR0FBaUIsTUFBTSxDQUFDLE1BQVAsQ0FFaEI7QUFBQSxFQUFBLFFBQUEsRUFBVSxPQUFBLENBQVMsa0JBQVQsQ0FBVjtBQUFBLEVBRUEsSUFBQSxFQUNDO0FBQUEsSUFBQSxPQUFBLEVBQVMsS0FBVDtHQUhEO0FBQUEsRUFLQSxNQUFBLEVBQVEsU0FBQSxHQUFBO0FBQ1AsSUFBQSxPQUFPLENBQUMsR0FBUixDQUFhLFNBQWIsQ0FBQSxDQUFBO1dBRUEsSUFBQyxDQUFBLEVBQUQsQ0FBSyxTQUFMLEVBQWUsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsQ0FBRCxHQUFBO2VBQU8sS0FBQyxDQUFBLE1BQUQsQ0FBUyxTQUFULEVBQVA7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFmLEVBSE87RUFBQSxDQUxSO0NBRmdCLENBWGpCLENBQUE7Ozs7O0FDQUEsSUFBQSwrQkFBQTs7QUFBQSxPQUFBLEdBQVUsT0FBQSxDQUFTLFNBQVQsQ0FBVixDQUFBOztBQUFBLFFBQ0EsR0FBVyxPQUFBLENBQVMsVUFBVCxDQURYLENBQUE7O0FBQUEsSUFFQSxHQUFPLE9BQUEsQ0FBUyxNQUFULENBRlAsQ0FBQTs7QUFBQSxNQUlBLEdBQVMsT0FBQSxDQUFTLFdBQVQsQ0FKVCxDQUFBOztBQUFBLE1BTU0sQ0FBQyxPQUFQLEdBQWlCLE9BQU8sQ0FBQyxNQUFSLENBRWhCO0FBQUEsRUFBQSxFQUFBLEVBQUksUUFBUSxDQUFDLElBQWI7QUFBQSxFQUVBLE1BQUEsRUFBUSxJQUZSO0FBQUEsRUFJQSxRQUFBLEVBQVUsT0FBQSxDQUFTLGdCQUFULENBSlY7QUFBQSxFQU1BLElBQUEsRUFDQztBQUFBLElBQUEsSUFBQSxFQUFPLEtBQVA7QUFBQSxJQUNBLFFBQUEsRUFBVSxLQURWO0FBQUEsSUFFQSxNQUFBLEVBQVEsSUFGUjtHQVBEO0FBQUEsRUFXQSxNQUFBLEVBQVEsU0FBQSxHQUFBO0FBQ1AsSUFBQSxPQUFPLENBQUMsR0FBUixDQUFhLGtCQUFiLENBQUEsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLE9BQUQsQ0FBQSxDQUZBLENBQUE7V0FJQSxJQUFDLENBQUEsVUFBRCxDQUFBLEVBTE87RUFBQSxDQVhSO0FBQUEsRUFrQkEsT0FBQSxFQUFTLFNBQUEsR0FBQTtBQUVSLFFBQUEsRUFBQTtBQUFBLElBQUEsRUFBQSxHQUFTLElBQUEsUUFBQSxDQUFVLFVBQUEsR0FBVSxNQUFNLENBQUMsUUFBakIsR0FBMEIsa0JBQXBDLENBQVQsQ0FBQTtXQUNBLEVBQUUsQ0FBQyxFQUFILENBQU8sT0FBUCxFQUFlLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLFFBQUQsR0FBQTtBQUNkLFFBQUEsS0FBQyxDQUFBLEdBQUQsQ0FBTSxRQUFOLEVBQWUsUUFBUSxDQUFDLEdBQVQsQ0FBQSxDQUFmLENBQUEsQ0FBQTtlQUNBLE9BQU8sQ0FBQyxHQUFSLENBQWEsS0FBYixFQUFtQixLQUFDLENBQUEsR0FBRCxDQUFNLFFBQU4sQ0FBbkIsRUFGYztNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQWYsRUFHRSxTQUFDLEdBQUQsR0FBQTthQUNFLE9BQU8sQ0FBQyxHQUFSLENBQWEsTUFBYixFQUFvQixHQUFHLENBQUMsSUFBeEIsRUFERjtJQUFBLENBSEYsRUFIUTtFQUFBLENBbEJUO0FBQUEsRUEyQkEsVUFBQSxFQUFZLFNBQUEsR0FBQTtBQUNYLFFBQUEsSUFBQTtBQUFBLElBQUEsSUFBQSxHQUFPLElBQVAsQ0FBQTtBQUFBLElBRUEsSUFBQSxDQUFNLEdBQU4sRUFBVSxTQUFBLEdBQUE7QUFDVCxNQUFBLE9BQU8sQ0FBQyxHQUFSLENBQWEsbUJBQWIsQ0FBQSxDQUFBO2FBQ0EsSUFBSSxDQUFDLEdBQUwsQ0FBVTtBQUFBLFFBQUEsTUFBQSxFQUFRLE9BQVI7T0FBVixFQUZTO0lBQUEsQ0FBVixDQUZBLENBQUE7QUFBQSxJQU1BLElBQUEsQ0FBTSxPQUFOLEVBQWMsU0FBQyxHQUFELEdBQUE7QUFDYixNQUFBLE9BQU8sQ0FBQyxHQUFSLENBQWEsa0JBQWIsQ0FBQSxDQUFBO2FBQ0EsSUFBSSxDQUFDLEdBQUwsQ0FBVTtBQUFBLFFBQUEsTUFBQSxFQUFRLE1BQVI7T0FBVixFQUZhO0lBQUEsQ0FBZCxDQU5BLENBQUE7V0FVQSxJQUFBLENBQUs7QUFBQSxNQUFBLEtBQUEsRUFBTyxLQUFQO0FBQUEsTUFBYyxRQUFBLEVBQVUsSUFBeEI7QUFBQSxNQUE4QixRQUFBLEVBQVUsS0FBeEM7S0FBTCxFQVhXO0VBQUEsQ0EzQlo7Q0FGZ0IsQ0FOakIsQ0FBQTs7Ozs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIjIHJlZ2lzdGVyIGFsbCBtb2R1bGVzXG5yZXF1aXJlIFwiLi9tb2R1bGUvaW5kZXhcIlxuXG4jIHJlcXVpcmUgUmFjdGl2ZSBwbHVnaW5zXG5yZXF1aXJlIFwicmFjdGl2ZS1ldmVudHMtdGFwXCJcblxuIyB3YWl0IGZvciB3aGVuIHRoZSBkb20gaXMgcmVhZHkgYW5kIGxvYWQgbWFpbiB2aWV3XG5yZXF1aXJlKFwiZG9tcmVhZHlcIikgLT5cblx0cmVxdWlyZShcIi4vYXBwLWRlYnVnXCIpKCkgaWYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgaXMgXCJkZXZlbG9wbWVudFwiXG5cblx0VmlldyA9IHJlcXVpcmUgXCIuL3ZpZXcvbWFpbi12aWV3XCJcblx0d2luZG93Ll92aWV3ID0gbmV3IFZpZXcoKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3ZlbmRvci9kYXQuZ3VpJylcbm1vZHVsZS5leHBvcnRzLmNvbG9yID0gcmVxdWlyZSgnLi92ZW5kb3IvZGF0LmNvbG9yJykiLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBkYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdCB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb2xvciA9IGRhdC5jb2xvciB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC51dGlscyA9IGRhdC51dGlscyB8fCB7fTtcblxuZGF0LnV0aWxzLmNvbW1vbiA9IChmdW5jdGlvbiAoKSB7XG4gIFxuICB2YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgdmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuICAgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcbiAgICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICAgKi9cblxuICByZXR1cm4geyBcbiAgICBcbiAgICBCUkVBSzoge30sXG4gIFxuICAgIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZhdWx0czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgXG4gICAgfSxcbiAgICBcbiAgICBjb21wb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRyLCBzY29wZSkge1xuXG4gICAgICBcbiAgICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHsgXG4gICAgICAgIFxuICAgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7IC8vIElzIG51bWJlciBidXQgbm90IE5hTlxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgXG4gICAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZlcjogZnVuY3Rpb24oZm5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gICAgfSxcbiAgICBcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgICB9LFxuXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdWxsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfSxcbiAgICBcbiAgICBpc05hTjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaiswO1xuICAgIH0sXG4gICAgXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKycnO1xuICAgIH0sXG4gICAgXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgXG4gIH07XG4gICAgXG59KSgpO1xuXG5cbmRhdC5jb2xvci50b1N0cmluZyA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9yKSB7XG5cbiAgICBpZiAoY29sb3IuYSA9PSAxIHx8IGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5hKSkge1xuXG4gICAgICB2YXIgcyA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChjb2xvci5yKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZykgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIpICsgJywnICsgY29sb3IuYSArICcpJztcblxuICAgIH1cblxuICB9XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5Db2xvciA9IGRhdC5jb2xvci5Db2xvciA9IChmdW5jdGlvbiAoaW50ZXJwcmV0LCBtYXRoLCB0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyAnRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcblxuXG4gIH07XG5cbiAgQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsJ2cnLCdiJywnaCcsJ3MnLCd2JywnaGV4JywnYSddO1xuXG4gIGNvbW1vbi5leHRlbmQoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfSxcblxuICAgIHRvT3JpZ2luYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuXG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gbWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUkdCKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblxuICAgICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gbWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblxuICAgICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBtYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhyb3cgJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZSc7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlSFNWKGNvbG9yKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gbWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLFxuICAgICAgICB7XG4gICAgICAgICAgczogcmVzdWx0LnMsXG4gICAgICAgICAgdjogcmVzdWx0LnZcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICAgIH0gZWxzZSBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29sb3I7XG5cbn0pKGRhdC5jb2xvci5pbnRlcnByZXQgPSAoZnVuY3Rpb24gKHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgcmVzdWx0LCB0b1JldHVybjtcblxuICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0b1JldHVybiA9IGZhbHNlO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuXG4gICAgY29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbihmYW1pbHkpIHtcblxuICAgICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG5cbiAgICAgICAgY29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbihjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblxuICAgICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfTtcblxuICB2YXIgSU5URVJQUkVUQVRJT05TID0gW1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNTdHJpbmcsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgU0lYX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQjoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCQToge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE51bWJlcnNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzTnVtYmVyLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIEhFWDoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBcnJheXNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzQXJyYXksXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCQV9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNPYmplY3QsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgXTtcblxuICByZXR1cm4gaW50ZXJwcmV0O1xuXG5cbn0pKGRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbG9yLm1hdGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0bXBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcblxuICAgIGhzdl90b19yZ2I6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcblxuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblxuICAgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMS4wIC0gKGYgKiBzKSk7XG4gICAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKCgxLjAgLSBmKSAqIHMpKTtcbiAgICAgIHZhciBjID0gW1xuICAgICAgICBbdiwgdCwgcF0sXG4gICAgICAgIFtxLCB2LCBwXSxcbiAgICAgICAgW3AsIHYsIHRdLFxuICAgICAgICBbcCwgcSwgdl0sXG4gICAgICAgIFt0LCBwLCB2XSxcbiAgICAgICAgW3YsIHAsIHFdXG4gICAgICBdW2hpXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgICAgYjogY1syXSAqIDI1NVxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICByZ2JfdG9faHN2OiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICBoLCBzO1xuXG4gICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBOYU4sXG4gICAgICAgICAgczogMCxcbiAgICAgICAgICB2OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCAqIDM2MCxcbiAgICAgICAgczogcyxcbiAgICAgICAgdjogbWF4IC8gMjU1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZ2JfdG9faGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIChoZXggPj4gKGNvbXBvbmVudEluZGV4ICogOCkpICYgMHhGRjtcbiAgICB9LFxuXG4gICAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgKGhleCAmIH4gKDB4RkYgPDwgdG1wQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gIH1cblxufSkoKSxcbmRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pOyIsIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4vKiogQG5hbWVzcGFjZSAqL1xudmFyIGRhdCA9IG1vZHVsZS5leHBvcnRzID0gZGF0IHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0Lmd1aSA9IGRhdC5ndWkgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQudXRpbHMgPSBkYXQudXRpbHMgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29udHJvbGxlcnMgPSBkYXQuY29udHJvbGxlcnMgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuZG9tID0gZGF0LmRvbSB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb2xvciA9IGRhdC5jb2xvciB8fCB7fTtcblxuZGF0LnV0aWxzLmNzcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbG9hZDogZnVuY3Rpb24gKHVybCwgZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICBsaW5rLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9LFxuICAgIGluamVjdDogZnVuY3Rpb24oY3NzLCBkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBpbmplY3RlZC50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgIGluamVjdGVkLmlubmVySFRNTCA9IGNzcztcbiAgICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cblxuZGF0LnV0aWxzLmNvbW1vbiA9IChmdW5jdGlvbiAoKSB7XG4gIFxuICB2YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgdmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuICAgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcbiAgICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICAgKi9cblxuICByZXR1cm4geyBcbiAgICBcbiAgICBCUkVBSzoge30sXG4gIFxuICAgIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZhdWx0czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgXG4gICAgfSxcbiAgICBcbiAgICBjb21wb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRyLCBzY29wZSkge1xuXG4gICAgICBcbiAgICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHsgXG4gICAgICAgIFxuICAgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7IC8vIElzIG51bWJlciBidXQgbm90IE5hTlxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgXG4gICAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZlcjogZnVuY3Rpb24oZm5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gICAgfSxcbiAgICBcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgICB9LFxuXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdWxsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfSxcbiAgICBcbiAgICBpc05hTjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaiswO1xuICAgIH0sXG4gICAgXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKycnO1xuICAgIH0sXG4gICAgXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgXG4gIH07XG4gICAgXG59KSgpO1xuXG5cbmRhdC5jb250cm9sbGVycy5Db250cm9sbGVyID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIEFuIFwiYWJzdHJhY3RcIiBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgIC8qKlxuICAgICAqIFRob3NlIHdobyBleHRlbmQgdGhpcyBjbGFzcyB3aWxsIHB1dCB0aGVpciBET00gZWxlbWVudHMgaW4gaGVyZS5cbiAgICAgKiBAdHlwZSB7RE9NRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdG8gbWFuaXB1bGF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gbWFuaXB1bGF0ZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjaGFuZ2UuXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fb25DaGFuZ2UgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGZpbmlzaGluZyBjaGFuZ2UuXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG5cbiAgfTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlci5wcm90b3R5cGUgKi9cbiAgICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSB0aGF0IGEgZnVuY3Rpb24gZmlyZSBldmVyeSB0aW1lIHNvbWVvbmUgY2hhbmdlcyB0aGUgdmFsdWUgd2l0aFxuICAgICAgICAgKiB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuYyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZVxuICAgICAgICAgKiBpcyBtb2RpZmllZCB2aWEgdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UgPSBmbmM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgdGhhdCBhIGZ1bmN0aW9uIGZpcmUgZXZlcnkgdGltZSBzb21lb25lIFwiZmluaXNoZXNcIiBjaGFuZ2luZ1xuICAgICAgICAgKiB0aGUgdmFsdWUgd2loIHRoaXMgQ29udHJvbGxlci4gVXNlZnVsIGZvciB2YWx1ZXMgdGhhdCBjaGFuZ2VcbiAgICAgICAgICogaW5jcmVtZW50YWxseSBsaWtlIG51bWJlcnMgb3Igc3RyaW5ncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5jIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXJcbiAgICAgICAgICogc29tZW9uZSBcImZpbmlzaGVzXCIgY2hhbmdpbmcgdGhlIHZhbHVlIHZpYSB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgb25GaW5pc2hDaGFuZ2U6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIHRoZSB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaGVzIHRoZSB2aXN1YWwgZGlzcGxheSBvZiBhIENvbnRyb2xsZXIgaW4gb3JkZXIgdG8ga2VlcCBzeW5jXG4gICAgICAgICAqIHdpdGggdGhlIG9iamVjdCdzIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSB2YWx1ZSBoYXMgZGV2aWF0ZWQgZnJvbSBpbml0aWFsVmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGlzTW9kaWZpZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5nZXRWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIENvbnRyb2xsZXI7XG5cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmRvbS5kb20gPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHZhciBFVkVOVF9NQVAgPSB7XG4gICAgJ0hUTUxFdmVudHMnOiBbJ2NoYW5nZSddLFxuICAgICdNb3VzZUV2ZW50cyc6IFsnY2xpY2snLCdtb3VzZW1vdmUnLCdtb3VzZWRvd24nLCdtb3VzZXVwJywgJ21vdXNlb3ZlciddLFxuICAgICdLZXlib2FyZEV2ZW50cyc6IFsna2V5ZG93biddXG4gIH07XG5cbiAgdmFyIEVWRU5UX01BUF9JTlYgPSB7fTtcbiAgY29tbW9uLmVhY2goRVZFTlRfTUFQLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgY29tbW9uLmVhY2godiwgZnVuY3Rpb24oZSkge1xuICAgICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBDU1NfVkFMVUVfUElYRUxTID0gLyhcXGQrKFxcLlxcZCspPylweC87XG5cbiAgZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcblxuICAgIGlmICh2YWwgPT09ICcwJyB8fCBjb21tb24uaXNVbmRlZmluZWQodmFsKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goQ1NTX1ZBTFVFX1BJWEVMUyk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAuLi5lbXM/ICU/XG5cbiAgICByZXR1cm4gMDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlciBkYXQuZG9tXG4gICAqL1xuICB2YXIgZG9tID0ge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gc2VsZWN0YWJsZVxuICAgICAqL1xuICAgIG1ha2VTZWxlY3RhYmxlOiBmdW5jdGlvbihlbGVtLCBzZWxlY3RhYmxlKSB7XG5cbiAgICAgIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbS5zdHlsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcblxuICAgICAgZWxlbS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGVsZW0uc3R5bGUuS2h0bWxVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGhvcml6b250YWxcbiAgICAgKiBAcGFyYW0gdmVydGljYWxcbiAgICAgKi9cbiAgICBtYWtlRnVsbHNjcmVlbjogZnVuY3Rpb24oZWxlbSwgaG9yaXpvbnRhbCwgdmVydGljYWwpIHtcblxuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHZlcnRpY2FsKSkgdmVydGljYWwgPSB0cnVlO1xuXG4gICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgICBlbGVtLnN0eWxlLmJvdHRvbSA9IDA7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgZmFrZUV2ZW50OiBmdW5jdGlvbihlbGVtLCBldmVudFR5cGUsIHBhcmFtcywgYXV4KSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoY2xhc3NOYW1lKTtcbiAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XG4gICAgICAgICAgdmFyIGNsaWVudFkgPSBwYXJhbXMueSB8fCBwYXJhbXMuY2xpZW50WSB8fCAwO1xuICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlLCB3aW5kb3csIHBhcmFtcy5jbGlja0NvdW50IHx8IDEsXG4gICAgICAgICAgICAgIDAsIC8vc2NyZWVuIFhcbiAgICAgICAgICAgICAgMCwgLy9zY3JlZW4gWVxuICAgICAgICAgICAgICBjbGllbnRYLCAvL2NsaWVudCBYXG4gICAgICAgICAgICAgIGNsaWVudFksIC8vY2xpZW50IFlcbiAgICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XG4gICAgICAgICAgdmFyIGluaXQgPSBldnQuaW5pdEtleWJvYXJkRXZlbnQgfHwgZXZ0LmluaXRLZXlFdmVudDsgLy8gd2Via2l0IHx8IG1velxuICAgICAgICAgIGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXJDb2RlOiB1bmRlZmluZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csXG4gICAgICAgICAgICAgIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LFxuICAgICAgICAgICAgICBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LFxuICAgICAgICAgICAgICBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29tbW9uLmRlZmF1bHRzKGV2dCwgYXV4KTtcbiAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiBAcGFyYW0gYm9vbFxuICAgICAqL1xuICAgIGJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBib29sID0gYm9vbCB8fCBmYWxzZTtcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KVxuICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiBAcGFyYW0gYm9vbFxuICAgICAqL1xuICAgIHVuYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGJvb2wgPSBib29sIHx8IGZhbHNlO1xuICAgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpXG4gICAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgPT09IGNsYXNzTmFtZSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKS50ZXN0KGVsZW0uY2xhc3NOYW1lKSB8fCBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cbiAgICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWxlZnQnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3dpZHRoJ10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cbiAgICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1ib3R0b20nXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2hlaWdodCddKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldE9mZnNldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgdmFyIG9mZnNldCA9IHtsZWZ0OiAwLCB0b3A6MH07XG4gICAgICBpZiAoZWxlbS5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgICBvZmZzZXQudG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICB9IHdoaWxlIChlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3Bvc3RzLzI2ODQ1NjEvcmV2aXNpb25zXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmICk7XG4gICAgfVxuXG4gIH07XG5cbiAgcmV0dXJuIGRvbTtcblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIHNlbGVjdCBpbnB1dCB0byBhbHRlciB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB1c2luZyBhXG4gICAqIGxpc3Qgb2YgYWNjZXB0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmdbXX0gb3B0aW9ucyBBIG1hcCBvZiBsYWJlbHMgdG8gYWNjZXB0YWJsZSB2YWx1ZXMsIG9yXG4gICAqIGEgbGlzdCBvZiBhY2NlcHRhYmxlIHN0cmluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIG9wdGlvbnMpIHtcblxuICAgIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkcm9wIGRvd24gbWVudVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cbiAgICBpZiAoY29tbW9uLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgIGNvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgbWFwW2VsZW1lbnRdID0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucyA9IG1hcDtcbiAgICB9XG5cbiAgICBjb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cbiAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICAgIF90aGlzLl9fc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG5cbiAgICB9KTtcblxuICAgIC8vIEFja25vd2xlZGdlIG9yaWdpbmFsIHZhbHVlXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVzaXJlZFZhbHVlID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShkZXNpcmVkVmFsdWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19zZWxlY3QpO1xuXG4gIH07XG5cbiAgT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5taW5dIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5zdGVwXSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICB0aGlzLl9fbWluID0gcGFyYW1zLm1pbjtcbiAgICB0aGlzLl9fbWF4ID0gcGFyYW1zLm1heDtcbiAgICB0aGlzLl9fc3RlcCA9IHBhcmFtcy5zdGVwO1xuXG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fc3RlcCkpIHtcblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlID09IDApIHtcbiAgICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gMTsgLy8gV2hhdCBhcmUgd2UsIHBzeWNoaWNzP1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGV5IERvdWcsIGNoZWNrIHRoaXMgb3V0LlxuICAgICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyh0aGlzLmluaXRpYWxWYWx1ZSkvTWF0aC5MTjEwKSkvMTA7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSB0aGlzLl9fc3RlcDtcblxuICAgIH1cblxuICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyh0aGlzLl9faW1wbGllZFN0ZXApO1xuXG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlICovXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLl9fbWluO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX21heCAhPT0gdW5kZWZpbmVkICYmIHYgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fX21heDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fX3N0ZXAgIT09IHVuZGVmaW5lZCAmJiB2ICUgdGhpcy5fX3N0ZXAgIT0gMCkge1xuICAgICAgICAgICAgdiA9IE1hdGgucm91bmQodiAvIHRoaXMuX19zdGVwKSAqIHRoaXMuX19zdGVwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIG1pbmltdW0gdmFsdWUgZm9yIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgVGhlIG1pbmltdW0gdmFsdWUgZm9yXG4gICAgICAgICAqIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX21pbiA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBtYXhpbXVtIHZhbHVlIGZvciA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlIFRoZSBtYXhpbXVtIHZhbHVlIGZvclxuICAgICAgICAgKiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19tYXggPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgc3RlcCB2YWx1ZSB0aGF0IGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAgICAgICAqIGluY3JlbWVudHMgYnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwVmFsdWUgVGhlIHN0ZXAgdmFsdWUgZm9yXG4gICAgICAgICAqIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAgICAgICAqIEBkZWZhdWx0IGlmIG1pbmltdW0gYW5kIG1heGltdW0gc3BlY2lmaWVkIGluY3JlbWVudCBpcyAxJSBvZiB0aGVcbiAgICAgICAgICogZGlmZmVyZW5jZSBvdGhlcndpc2Ugc3RlcFZhbHVlIGlzIDFcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBzdGVwOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX3N0ZXAgPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIG51bURlY2ltYWxzKHgpIHtcbiAgICB4ID0geC50b1N0cmluZygpO1xuICAgIGlmICh4LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICByZXR1cm4geC5sZW5ndGggLSB4LmluZGV4T2YoJy4nKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94ID0gKGZ1bmN0aW9uIChOdW1iZXJDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyIGFuZFxuICAgKiBwcm92aWRlcyBhbiBpbnB1dCBlbGVtZW50IHdpdGggd2hpY2ggdG8gbWFuaXB1bGF0ZSBpdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWluXSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4XSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3RlcF0gSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXJCb3ggPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIHtOdW1iZXJ9IFByZXZpb3VzIG1vdXNlIHkgcG9zaXRpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdmFyIHByZXZfeTtcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG5cbiAgICAvLyBNYWtlcyBpdCBzbyBtYW51YWxseSBzcGVjaWZpZWQgdmFsdWVzIGFyZSBub3QgdHJ1bmNhdGVkLlxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAvLyBXaGVuIHByZXNzaW5nIGVudGlyZSwgeW91IGNhbiBiZSBhcyBwcmVjaXNlIGFzIHlvdSB3YW50LlxuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFjb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkgX3RoaXMuc2V0VmFsdWUoYXR0ZW1wdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBvbkNoYW5nZSgpO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIHByZXZfeSA9IGUuY2xpZW50WTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG5cbiAgICAgIHZhciBkaWZmID0gcHJldl95IC0gZS5jbGllbnRZO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuZ2V0VmFsdWUoKSArIGRpZmYgKiBfdGhpcy5fX2ltcGxpZWRTdGVwKTtcblxuICAgICAgcHJldl95ID0gZS5jbGllbnRZO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MgPSBOdW1iZXJDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLFxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID8gdGhpcy5nZXRWYWx1ZSgpIDogcm91bmRUb0RlY2ltYWwodGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9fcHJlY2lzaW9uKTtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgdmFyIHRlblRvID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHRlblRvKSAvIHRlblRvO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3g7XG5cbn0pKGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IChmdW5jdGlvbiAoTnVtYmVyQ29udHJvbGxlciwgZG9tLCBjc3MsIGNvbW1vbiwgc3R5bGVTaGVldCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyLCBjb250YWluc1xuICAgKiBhIG1pbmltdW0gYW5kIG1heGltdW0sIGFuZCBwcm92aWRlcyBhIHNsaWRlciBlbGVtZW50IHdpdGggd2hpY2ggdG9cbiAgICogbWFuaXB1bGF0ZSBpdC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgdGhlIHNsaWRlciBlbGVtZW50IGlzIG1hZGUgdXAgb2ZcbiAgICogPGNvZGU+Jmx0O2RpdiZndDs8L2NvZGU+IHRhZ3MsIDxzdHJvbmc+bm90PC9zdHJvbmc+IHRoZSBodG1sNVxuICAgKiA8Y29kZT4mbHQ7c2xpZGVyJmd0OzwvY29kZT4gZWxlbWVudC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5WYWx1ZSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFZhbHVlIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyU2xpZGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcblxuICAgIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBcblxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2JhY2tncm91bmQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19iYWNrZ3JvdW5kLCAnc2xpZGVyJyk7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG5cbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXG4gICAgICBvbk1vdXNlRHJhZyhlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIG9mZnNldCA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19iYWNrZ3JvdW5kKTtcbiAgICAgIHZhciB3aWR0aCA9IGRvbS5nZXRXaWR0aChfdGhpcy5fX2JhY2tncm91bmQpO1xuICAgICAgXG4gICAgICBfdGhpcy5zZXRWYWx1ZShcbiAgICAgICAgbWFwKGUuY2xpZW50WCwgb2Zmc2V0LmxlZnQsIG9mZnNldC5sZWZ0ICsgd2lkdGgsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLl9fYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLl9fZm9yZWdyb3VuZCk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19iYWNrZ3JvdW5kKTtcblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcyA9IE51bWJlckNvbnRyb2xsZXI7XG5cbiAgLyoqXG4gICAqIEluamVjdHMgZGVmYXVsdCBzdHlsZXNoZWV0IGZvciBzbGlkZXIgZWxlbWVudHMuXG4gICAqL1xuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnVzZURlZmF1bHRTdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICBjc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xuICB9O1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlLFxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGN0ID0gKHRoaXMuZ2V0VmFsdWUoKSAtIHRoaXMuX19taW4pLyh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICAgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QqMTAwKyclJztcbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cblxuICApO1xuXG4gIGZ1bmN0aW9uIG1hcCh2LCBpMSwgaTIsIG8xLCBvMikge1xuICAgIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlcjtcbiAgXG59KShkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNzcyxcbmRhdC51dGlscy5jb21tb24sXG5cIi5zbGlkZXIge1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAycHggNHB4IHJnYmEoMCwwLDAsMC4xNSk7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICBwYWRkaW5nOiAwIDAuNWVtO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnNsaWRlci1mZyB7XFxuICBwYWRkaW5nOiAxcHggMCAycHggMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIG1hcmdpbi1sZWZ0OiAtMC41ZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjVlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbSAwIDAgMWVtO1xcbn1cXG5cXG4uc2xpZGVyLWZnOmFmdGVyIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXI6ICAxcHggc29saWQgI2FhYTtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgbWFyZ2luLXJpZ2h0OiAtMWVtO1xcbiAgbWFyZ2luLXRvcDogLTFweDtcXG4gIGhlaWdodDogMC45ZW07XFxuICB3aWR0aDogMC45ZW07XFxufVwiKTtcblxuXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBHVUkgaW50ZXJmYWNlIHRvIGZpcmUgYSBzcGVjaWZpZWQgbWV0aG9kLCBhIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBGdW5jdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCB0ZXh0KSB7XG5cbiAgICBGdW5jdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fYnV0dG9uLmlubmVySFRNTCA9IHRleHQgPT09IHVuZGVmaW5lZCA/ICdGaXJlJyA6IHRleHQ7XG4gICAgZG9tLmJpbmQodGhpcy5fX2J1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19idXR0b24sICdidXR0b24nKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fYnV0dG9uKTtcblxuXG4gIH07XG5cbiAgRnVuY3Rpb25Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEZ1bmN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIHtcbiAgICAgICAgXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmdldFZhbHVlKCkuY2FsbCh0aGlzLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBGdW5jdGlvbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIGNoZWNrYm94IGlucHV0IHRvIGFsdGVyIHRoZSBib29sZWFuIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBCb29sZWFuQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgICB0aGlzLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcblxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hlY2tib3gpO1xuXG4gICAgLy8gTWF0Y2ggb3JpZ2luYWwgdmFsdWVcbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuXG4gIH07XG5cbiAgQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciB0b1JldHVybiA9IEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSB0cnVlOyAgICBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBCb29sZWFuQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb2xvci50b1N0cmluZyA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9yKSB7XG5cbiAgICBpZiAoY29sb3IuYSA9PSAxIHx8IGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5hKSkge1xuXG4gICAgICB2YXIgcyA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChjb2xvci5yKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZykgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIpICsgJywnICsgY29sb3IuYSArICcpJztcblxuICAgIH1cblxuICB9XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb2xvci5pbnRlcnByZXQgPSAoZnVuY3Rpb24gKHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgcmVzdWx0LCB0b1JldHVybjtcblxuICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0b1JldHVybiA9IGZhbHNlO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuXG4gICAgY29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbihmYW1pbHkpIHtcblxuICAgICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG5cbiAgICAgICAgY29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbihjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblxuICAgICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfTtcblxuICB2YXIgSU5URVJQUkVUQVRJT05TID0gW1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNTdHJpbmcsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgU0lYX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQjoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCQToge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE51bWJlcnNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzTnVtYmVyLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIEhFWDoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBcnJheXNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzQXJyYXksXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCQV9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNPYmplY3QsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgXTtcblxuICByZXR1cm4gaW50ZXJwcmV0O1xuXG5cbn0pKGRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5HVUkgPSBkYXQuZ3VpLkdVSSA9IChmdW5jdGlvbiAoY3NzLCBzYXZlRGlhbG9ndWVDb250ZW50cywgc3R5bGVTaGVldCwgY29udHJvbGxlckZhY3RvcnksIENvbnRyb2xsZXIsIEJvb2xlYW5Db250cm9sbGVyLCBGdW5jdGlvbkNvbnRyb2xsZXIsIE51bWJlckNvbnRyb2xsZXJCb3gsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIE9wdGlvbkNvbnRyb2xsZXIsIENvbG9yQ29udHJvbGxlciwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBDZW50ZXJlZERpdiwgZG9tLCBjb21tb24pIHtcblxuICBjc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xuXG4gIC8qKiBPdXRlci1tb3N0IGNsYXNzTmFtZSBmb3IgR1VJJ3MgKi9cbiAgdmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xuXG4gIHZhciBISURFX0tFWV9DT0RFID0gNzI7XG5cbiAgLyoqIFRoZSBvbmx5IHZhbHVlIHNoYXJlZCBiZXR3ZWVuIHRoZSBKUyBhbmQgU0NTUy4gVXNlIGNhdXRpb24uICovXG4gIHZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG5cbiAgdmFyIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSA9ICdEZWZhdWx0JztcblxuICB2YXIgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdyAmJiB3aW5kb3dbJ2xvY2FsU3RvcmFnZSddICE9PSBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgdmFyIFNBVkVfRElBTE9HVUU7XG5cbiAgLyoqIEhhdmUgd2UgeWV0IHRvIGNyZWF0ZSBhbiBhdXRvUGxhY2UgR1VJPyAqL1xuICB2YXIgYXV0b19wbGFjZV92aXJnaW4gPSB0cnVlO1xuXG4gIC8qKiBGaXhlZCBwb3NpdGlvbiBkaXYgdGhhdCBhdXRvIHBsYWNlIEdVSSdzIGdvIGluc2lkZSAqL1xuICB2YXIgYXV0b19wbGFjZV9jb250YWluZXI7XG5cbiAgLyoqIEFyZSB3ZSBoaWRpbmcgdGhlIEdVSSdzID8gKi9cbiAgdmFyIGhpZGUgPSBmYWxzZTtcblxuICAvKiogR1VJJ3Mgd2hpY2ggc2hvdWxkIGJlIGhpZGRlbiAqL1xuICB2YXIgaGlkZWFibGVfZ3VpcyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGxpZ2h0d2VpZ2h0IGNvbnRyb2xsZXIgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC4gSXQgYWxsb3dzIHlvdSB0byBlYXNpbHlcbiAgICogbWFuaXB1bGF0ZSB2YXJpYWJsZXMgYW5kIGZpcmUgZnVuY3Rpb25zIG9uIHRoZSBmbHkuXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5ndWlcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLm5hbWVdIFRoZSBuYW1lIG9mIHRoaXMgR1VJLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcy5sb2FkXSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNhdmVkIHN0YXRlIG9mXG4gICAqIHRoaXMgR1VJLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuYXV0bz10cnVlXVxuICAgKiBAcGFyYW0ge2RhdC5ndWkuR1VJfSBbcGFyYW1zLnBhcmVudF0gVGhlIEdVSSBJJ20gbmVzdGVkIGluLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuY2xvc2VkXSBJZiB0cnVlLCBzdGFydHMgY2xvc2VkXG4gICAqL1xuICB2YXIgR1VJID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogT3V0ZXJtb3N0IERPTSBFbGVtZW50XG4gICAgICogQHR5cGUgRE9NRWxlbWVudFxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX191bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG5cbiAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBDU1NfTkFNRVNQQUNFKTtcblxuICAgIC8qKlxuICAgICAqIE5lc3RlZCBHVUkncyBieSBuYW1lXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19mb2xkZXJzID0ge307XG5cbiAgICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygb2JqZWN0cyBJJ20gcmVtZW1iZXJpbmcgZm9yIHNhdmUsIG9ubHkgdXNlZCBpbiB0b3AgbGV2ZWwgR1VJXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTWFwcyB0aGUgaW5kZXggb2YgcmVtZW1iZXJlZCBvYmplY3RzIHRvIGEgbWFwIG9mIGNvbnRyb2xsZXJzLCBvbmx5IHVzZWRcbiAgICAgKiBpbiB0b3AgbGV2ZWwgR1VJLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFtcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnR5TmFtZTogQ29udHJvbGxlcixcbiAgICAgKiAgICBhbm90aGVyUHJvcGVydHlOYW1lOiBDb250cm9sbGVyXG4gICAgICogIH0sXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXJcbiAgICAgKiAgfVxuICAgICAqIF1cbiAgICAgKi9cbiAgICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzID0gW107XG5cbiAgICB0aGlzLl9fbGlzdGVuaW5nID0gW107XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBEZWZhdWx0IHBhcmFtZXRlcnNcbiAgICBwYXJhbXMgPSBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICBhdXRvUGxhY2U6IHRydWUsXG4gICAgICB3aWR0aDogR1VJLkRFRkFVTFRfV0lEVEhcbiAgICB9KTtcblxuICAgIHBhcmFtcyA9IGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICAgIGhpZGVhYmxlOiBwYXJhbXMuYXV0b1BsYWNlXG4gICAgfSk7XG5cblxuICAgIGlmICghY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5sb2FkKSkge1xuXG4gICAgICAvLyBFeHBsaWNpdCBwcmVzZXRcbiAgICAgIGlmIChwYXJhbXMucHJlc2V0KSBwYXJhbXMubG9hZC5wcmVzZXQgPSBwYXJhbXMucHJlc2V0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcGFyYW1zLmxvYWQgPSB7IHByZXNldDogREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FIH07XG5cbiAgICB9XG5cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5oaWRlYWJsZSkge1xuICAgICAgaGlkZWFibGVfZ3Vpcy5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgcm9vdCBsZXZlbCBHVUkncyBhcmUgcmVzaXphYmxlLlxuICAgIHBhcmFtcy5yZXNpemFibGUgPSBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcblxuXG4gICAgaWYgKHBhcmFtcy5hdXRvUGxhY2UgJiYgY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5zY3JvbGxhYmxlKSkge1xuICAgICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICAgIH1cbi8vICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5zY3JvbGxhYmxlID09PSB0cnVlO1xuXG4gICAgLy8gTm90IHBhcnQgb2YgcGFyYW1zIGJlY2F1c2UgSSBkb24ndCB3YW50IHBlb3BsZSBwYXNzaW5nIHRoaXMgaW4gdmlhXG4gICAgLy8gY29uc3RydWN0b3IuIFNob3VsZCBiZSBhICdyZW1lbWJlcmVkJyB2YWx1ZS5cbiAgICB2YXIgdXNlX2xvY2FsX3N0b3JhZ2UgPVxuICAgICAgICBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuXG4gICAgICAgIC8qKiBAbGVuZHMgZGF0Lmd1aS5HVUkucHJvdG90eXBlICovXG4gICAgICAgIHtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBwYXJlbnQgPGNvZGU+R1VJPC9jb2RlPlxuICAgICAgICAgICAqIEB0eXBlIGRhdC5ndWkuR1VJXG4gICAgICAgICAgICovXG4gICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2Nyb2xsYWJsZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBIYW5kbGVzIDxjb2RlPkdVSTwvY29kZT4ncyBlbGVtZW50IHBsYWNlbWVudCBmb3IgeW91XG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIGF1dG9QbGFjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBpZGVudGlmaWVyIGZvciBhIHNldCBvZiBzYXZlZCB2YWx1ZXNcbiAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwcmVzZXQ6IHtcblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHdpZHRoIG9mIDxjb2RlPkdVSTwvY29kZT4gZWxlbWVudFxuICAgICAgICAgICAqIEB0eXBlIE51bWJlclxuICAgICAgICAgICAqL1xuICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLndpZHRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBuYW1lIG9mIDxjb2RlPkdVSTwvY29kZT4uIFVzZWQgZm9yIGZvbGRlcnMuIGkuZVxuICAgICAgICAgICAqIGEgZm9sZGVyJ3MgbmFtZVxuICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBDaGVjayBmb3IgY29sbGlzaW9ucyBhbW9uZyBzaWJsaW5nIGZvbGRlcnNcbiAgICAgICAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICAgICAgICBpZiAodGl0bGVfcm93X25hbWUpIHtcbiAgICAgICAgICAgICAgICB0aXRsZV9yb3dfbmFtZS5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGV0aGVyIHRoZSA8Y29kZT5HVUk8L2NvZGU+IGlzIGNvbGxhcHNlZCBvciBub3RcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgY2xvc2VkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHY7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBhcmVuJ3QgZ29pbmcgdG8gcmVzcGVjdCB0aGUgQ1NTIHRyYW5zaXRpb24sXG4gICAgICAgICAgICAgIC8vIExldHMganVzdCBjaGVjayBvdXIgaGVpZ2h0IGFnYWluc3QgdGhlIHdpbmRvdyBoZWlnaHQgcmlnaHQgb2ZmXG4gICAgICAgICAgICAgIC8vIHRoZSBiYXQuXG4gICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcblxuICAgICAgICAgICAgICBpZiAoX3RoaXMuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gdiA/IEdVSS5URVhUX09QRU4gOiBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ29udGFpbnMgYWxsIHByZXNldHNcbiAgICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsb2FkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gdXNlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU3RvcmFnZSNsb2NhbFN0b3JhZ2VcIj5sb2NhbFN0b3JhZ2U8L2E+IGFzIHRoZSBtZWFucyBmb3JcbiAgICAgICAgICAgKiA8Y29kZT5yZW1lbWJlcjwvY29kZT5pbmdcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlOiB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1c2VfbG9jYWxfc3RvcmFnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICAgICAgICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgICAgICAgICAgICB1c2VfbG9jYWxfc3RvcmFnZSA9IGJvb2w7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSwgYm9vbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgIC8vIEFyZSB3ZSBhIHJvb3QgbGV2ZWwgR1VJP1xuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcblxuICAgICAgcGFyYW1zLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfTUFJTik7XG4gICAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBzdXBwb3NlZCB0byBiZSBsb2FkaW5nIGxvY2FsbHk/XG4gICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXG4gICAgICAgIGlmICh1c2VfbG9jYWxfc3RvcmFnZSkge1xuXG4gICAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzYXZlZF9ndWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG5cbiAgICAgICAgICBpZiAoc2F2ZWRfZ3VpKSB7XG4gICAgICAgICAgICBwYXJhbXMubG9hZCA9IEpTT04ucGFyc2Uoc2F2ZWRfZ3VpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19jbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CVVRUT04pO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XG5cbiAgICAgIGRvbS5iaW5kKHRoaXMuX19jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcblxuXG4gICAgICB9KTtcblxuXG4gICAgICAvLyBPaCwgeW91J3JlIGEgbmVzdGVkIEdVSSFcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAocGFyYW1zLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGl0bGVfcm93X25hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXJhbXMubmFtZSk7XG4gICAgICBkb20uYWRkQ2xhc3ModGl0bGVfcm93X25hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcblxuICAgICAgdmFyIHRpdGxlX3JvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVfcm93X25hbWUpO1xuXG4gICAgICB2YXIgb25fY2xpY2tfdGl0bGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aXRsZV9yb3csICd0aXRsZScpO1xuICAgICAgZG9tLmJpbmQodGl0bGVfcm93LCAnY2xpY2snLCBvbl9jbGlja190aXRsZSk7XG5cbiAgICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcblxuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuXG4gICAgICAgIGlmIChhdXRvX3BsYWNlX3Zpcmdpbikge1xuICAgICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9fcGxhY2VfY29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b19wbGFjZV9jb250YWluZXIsIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUik7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvX3BsYWNlX2NvbnRhaW5lcik7XG4gICAgICAgICAgYXV0b19wbGFjZV92aXJnaW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBpdCBpbiB0aGUgZG9tIGZvciB5b3UuXG4gICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIGF1dG8gc3R5bGVzXG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19BVVRPX1BMQUNFKTtcblxuICAgICAgfVxuXG5cbiAgICAgIC8vIE1ha2UgaXQgbm90IGVsYXN0aWMuXG4gICAgICBpZiAoIXRoaXMucGFyZW50KSBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcblxuICAgIH1cblxuICAgIGRvbS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKTsgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ29UcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuXG5cbiAgICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgICAgYWRkUmVzaXplSGFuZGxlKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVUb0xvY2FsU3RvcmFnZSgpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdndWknKSwgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZ2V0U2F2ZU9iamVjdCgpKSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgICAgIHJvb3Qud2lkdGggKz0gMTtcbiAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLnBhcmVudCkge1xuICAgICAgICByZXNldFdpZHRoKCk7XG4gICAgICB9XG5cbiAgfTtcblxuICBHVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaGlkZSA9ICFoaWRlO1xuICAgIGNvbW1vbi5lYWNoKGhpZGVhYmxlX2d1aXMsIGZ1bmN0aW9uKGd1aSkge1xuICAgICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUuekluZGV4ID0gaGlkZSA/IC05OTkgOiA5OTk7XG4gICAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gaGlkZSA/IDAgOiAxO1xuICAgIH0pO1xuICB9O1xuXG4gIEdVSS5DTEFTU19BVVRPX1BMQUNFID0gJ2EnO1xuICBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIgPSAnYWMnO1xuICBHVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbiAgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XID0gJ2NyJztcbiAgR1VJLkNMQVNTX1RPT19UQUxMID0gJ3RhbGxlci10aGFuLXdpbmRvdyc7XG4gIEdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbiAgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTiA9ICdjbG9zZS1idXR0b24nO1xuICBHVUkuQ0xBU1NfRFJBRyA9ICdkcmFnJztcblxuICBHVUkuREVGQVVMVF9XSURUSCA9IDI0NTtcbiAgR1VJLlRFWFRfQ0xPU0VEID0gJ0Nsb3NlIENvbnRyb2xzJztcbiAgR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcblxuICBkb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSAhPT0gJ3RleHQnICYmXG4gICAgICAgIChlLndoaWNoID09PSBISURFX0tFWV9DT0RFIHx8IGUua2V5Q29kZSA9PSBISURFX0tFWV9DT0RFKSkge1xuICAgICAgR1VJLnRvZ2dsZUhpZGUoKTtcbiAgICB9XG5cbiAgfSwgZmFsc2UpO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEdVSS5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0Lmd1aS5HVUkgKi9cbiAgICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSBUaGUgbmV3IGNvbnRyb2xsZXIgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db2xvckNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDb2xvcjogZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbG9yOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBjb250cm9sbGVyXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cbiAgICAgICAgICAvLyBUT0RPIGxpc3RlbmluZz9cbiAgICAgICAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoY29udHJvbGxlci5fX2xpKTtcbiAgICAgICAgICB0aGlzLl9fY29udHJvbGxlcnMuc2xpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlciksIDEpO1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0Lmd1aS5HVUl9IFRoZSBuZXcgZm9sZGVyLlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhpcyBHVUkgYWxyZWFkeSBoYXMgYSBmb2xkZXIgYnkgdGhlIHNwZWNpZmllZFxuICAgICAgICAgKiBuYW1lXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRm9sZGVyOiBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIHByZXZlbnQgY29sbGlzaW9ucyBvbiBuYW1lcyBpbiBvcmRlciB0byBoYXZlIGEga2V5XG4gICAgICAgICAgLy8gYnkgd2hpY2ggdG8gcmVtZW1iZXIgc2F2ZWQgdmFsdWVzXG4gICAgICAgICAgaWYgKHRoaXMuX19mb2xkZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICtcbiAgICAgICAgICAgICAgICAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdfZ3VpX3BhcmFtcyA9IHsgbmFtZTogbmFtZSwgcGFyZW50OiB0aGlzIH07XG5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHBhc3MgZG93biB0aGUgYXV0b1BsYWNlIHRyYWl0IHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0byBvcGVuL2Nsb3NlIGZvbGRlciBhY3Rpb25zIHRvXG4gICAgICAgICAgLy8gZW5zdXJlIHRoYXQgYSBzY3JvbGxiYXIgYXBwZWFycyBpZiB0aGUgd2luZG93IGlzIHRvbyBzaG9ydC5cbiAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5hdXRvUGxhY2UgPSB0aGlzLmF1dG9QbGFjZTtcblxuICAgICAgICAgIC8vIERvIHdlIGhhdmUgc2F2ZWQgYXBwZWFyYW5jZSBkYXRhIGZvciB0aGlzIGZvbGRlcj9cblxuICAgICAgICAgIGlmICh0aGlzLmxvYWQgJiYgLy8gQW55dGhpbmcgbG9hZGVkP1xuICAgICAgICAgICAgICB0aGlzLmxvYWQuZm9sZGVycyAmJiAvLyBXYXMgbXkgcGFyZW50IGEgZGVhZC1lbmQ/XG4gICAgICAgICAgICAgIHRoaXMubG9hZC5mb2xkZXJzW25hbWVdKSB7IC8vIERpZCBkYWRkeSByZW1lbWJlciBtZT9cblxuICAgICAgICAgICAgLy8gU3RhcnQgbWUgY2xvc2VkIGlmIEkgd2FzIGNsb3NlZFxuICAgICAgICAgICAgbmV3X2d1aV9wYXJhbXMuY2xvc2VkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0uY2xvc2VkO1xuXG4gICAgICAgICAgICAvLyBQYXNzIGRvd24gdGhlIGxvYWRlZCBkYXRhXG4gICAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5sb2FkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV07XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdfZ3VpX3BhcmFtcyk7XG4gICAgICAgICAgdGhpcy5fX2ZvbGRlcnNbbmFtZV0gPSBndWk7XG5cbiAgICAgICAgICB2YXIgbGkgPSBhZGRSb3codGhpcywgZ3VpLmRvbUVsZW1lbnQpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2ZvbGRlcicpO1xuICAgICAgICAgIHJldHVybiBndWk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcblxuICAgICAgICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcblxuICAgICAgICAgICAgdmFyIHRvcCA9IGRvbS5nZXRPZmZzZXQocm9vdC5fX3VsKS50b3A7XG4gICAgICAgICAgICB2YXIgaCA9IDA7XG5cbiAgICAgICAgICAgIGNvbW1vbi5lYWNoKHJvb3QuX191bC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmICghIChyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKVxuICAgICAgICAgICAgICAgIGggKz0gZG9tLmdldEhlaWdodChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCA8IGgpIHtcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgKyAncHgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByb290Ll9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQgPSByb290Ll9fdWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyb290Ll9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIHJvb3QuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHJvb3Qud2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIG9iamVjdHMgZm9yIHNhdmluZy4gVGhlIG9yZGVyIG9mIHRoZXNlIG9iamVjdHMgY2Fubm90IGNoYW5nZSBhc1xuICAgICAgICAgKiB0aGUgR1VJIGdyb3dzLiBXaGVuIHJlbWVtYmVyaW5nIG5ldyBvYmplY3RzLCBhcHBlbmQgdGhlbSB0byB0aGUgZW5kXG4gICAgICAgICAqIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC4uLn0gb2JqZWN0c1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm90IGNhbGxlZCBvbiBhIHRvcCBsZXZlbCBHVUkuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtZW1iZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChTQVZFX0RJQUxPR1VFKSkge1xuICAgICAgICAgICAgU0FWRV9ESUFMT0dVRSA9IG5ldyBDZW50ZXJlZERpdigpO1xuICAgICAgICAgICAgU0FWRV9ESUFMT0dVRS5kb21FbGVtZW50LmlubmVySFRNTCA9IHNhdmVEaWFsb2d1ZUNvbnRlbnRzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICBhZGRTYXZlTWVudShfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgICAgICAgIC8vIFNldCBzYXZlIHJvdyB3aWR0aFxuICAgICAgICAgICAgc2V0V2lkdGgodGhpcywgdGhpcy53aWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuZ3VpLkdVSX0gdGhlIHRvcG1vc3QgcGFyZW50IEdVSSBvZiBhIG5lc3RlZCBHVUkuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgICAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBndWk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mXG4gICAgICAgICAqIHRoaXMgR1VJIGFzIHdlbGwgYXMgaXRzIHJlbWVtYmVyZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTYXZlT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciB0b1JldHVybiA9IHRoaXMubG9hZDtcblxuICAgICAgICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuXG4gICAgICAgICAgLy8gQW0gSSByZW1lbWJlcmluZyBhbnkgdmFsdWVzP1xuICAgICAgICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICB0b1JldHVybi5wcmVzZXQgPSB0aGlzLnByZXNldDtcblxuICAgICAgICAgICAgaWYgKCF0b1JldHVybi5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9SZXR1cm4uZm9sZGVycyA9IHt9O1xuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbihlbGVtZW50LCBrZXkpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVBczogZnVuY3Rpb24ocHJlc2V0TmFtZSkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICAgICAgICAvLyBSZXRhaW4gZGVmYXVsdCB2YWx1ZXMgdXBvbiBmaXJzdCBzYXZlXG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtwcmVzZXROYW1lXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgICAgICAgdGhpcy5wcmVzZXQgPSBwcmVzZXROYW1lO1xuICAgICAgICAgIGFkZFByZXNldE9wdGlvbih0aGlzLCBwcmVzZXROYW1lLCB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHJldmVydDogZnVuY3Rpb24oZ3VpKSB7XG5cbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgcmV2ZXJ0IHdvcmsgb24gRGVmYXVsdC5cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRSb290KCkubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUoY29udHJvbGxlci5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjYWxsU2F2ZWRWYWx1ZShndWkgfHwgdGhpcy5nZXRSb290KCksIGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uKGZvbGRlcikge1xuICAgICAgICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFndWkpIHtcbiAgICAgICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLmdldFJvb3QoKSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdGVuOiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cbiAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09IDA7XG4gICAgICAgICAgdGhpcy5fX2xpc3RlbmluZy5wdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIGlmIChpbml0KSB1cGRhdGVEaXNwbGF5cyh0aGlzLl9fbGlzdGVuaW5nKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIGFkZChndWksIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IFwiICsgb2JqZWN0ICsgXCIgaGFzIG5vIHByb3BlcnR5IFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBjb250cm9sbGVyO1xuXG4gICAgaWYgKHBhcmFtcy5jb2xvcikge1xuXG4gICAgICBjb250cm9sbGVyID0gbmV3IENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QscHJvcGVydHldLmNvbmNhdChwYXJhbXMuZmFjdG9yeUFyZ3MpO1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJGYWN0b3J5LmFwcGx5KGd1aSwgZmFjdG9yeUFyZ3MpO1xuXG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgICBwYXJhbXMuYmVmb3JlID0gcGFyYW1zLmJlZm9yZS5fX2xpO1xuICAgIH1cblxuICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKTtcblxuICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG5cbiAgICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgICBuYW1lLmlubmVySFRNTCA9IGNvbnRyb2xsZXIucHJvcGVydHk7XG5cbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5hbWUpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sbGVyLmRvbUVsZW1lbnQpO1xuXG4gICAgdmFyIGxpID0gYWRkUm93KGd1aSwgY29udGFpbmVyLCBwYXJhbXMuYmVmb3JlKTtcblxuICAgIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgICBkb20uYWRkQ2xhc3MobGksIHR5cGVvZiBjb250cm9sbGVyLmdldFZhbHVlKCkpO1xuXG4gICAgYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcik7XG5cbiAgICBndWkuX19jb250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSByb3cgdG8gdGhlIGVuZCBvZiB0aGUgR1VJIG9yIGJlZm9yZSBhbm90aGVyIHJvdy5cbiAgICpcbiAgICogQHBhcmFtIGd1aVxuICAgKiBAcGFyYW0gW2RvbV0gSWYgc3BlY2lmaWVkLCBpbnNlcnRzIHRoZSBkb20gY29udGVudCBpbiB0aGUgbmV3IHJvd1xuICAgKiBAcGFyYW0gW2xpQmVmb3JlXSBJZiBzcGVjaWZpZWQsIHBsYWNlcyB0aGUgbmV3IHJvdyBiZWZvcmUgYW5vdGhlciByb3dcbiAgICovXG4gIGZ1bmN0aW9uIGFkZFJvdyhndWksIGRvbSwgbGlCZWZvcmUpIHtcbiAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGlmIChkb20pIGxpLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgaWYgKGxpQmVmb3JlKSB7XG4gICAgICBndWkuX191bC5pbnNlcnRCZWZvcmUobGksIHBhcmFtcy5iZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBndWkuX191bC5hcHBlbmRDaGlsZChsaSk7XG4gICAgfVxuICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgIHJldHVybiBsaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcblxuICAgIGNvbnRyb2xsZXIuX19saSA9IGxpO1xuICAgIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbnRyb2xsZXIsIHtcblxuICAgICAgb3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNBcnJheShvcHRpb25zKSB8fCBjb21tb24uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW29wdGlvbnNdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgbmFtZTogZnVuY3Rpb24odikge1xuICAgICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gdjtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9LFxuXG4gICAgICBsaXN0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250cm9sbGVyLl9fZ3VpLmxpc3Rlbihjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250cm9sbGVyLl9fZ3VpLnJlbW92ZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIEFsbCBzbGlkZXJzIHNob3VsZCBiZSBhY2NvbXBhbmllZCBieSBhIGJveC5cbiAgICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcblxuICAgICAgdmFyIGJveCA9IG5ldyBOdW1iZXJDb250cm9sbGVyQm94KGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuXG4gICAgICBjb21tb24uZWFjaChbJ3VwZGF0ZURpc3BsYXknLCAnb25DaGFuZ2UnLCAnb25GaW5pc2hDaGFuZ2UnXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBwYyA9IGNvbnRyb2xsZXJbbWV0aG9kXTtcbiAgICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICAgIGNvbnRyb2xsZXJbbWV0aG9kXSA9IGJveFttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIHBjLmFwcGx5KGNvbnRyb2xsZXIsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZG9tLmFkZENsYXNzKGxpLCAnaGFzLXNsaWRlcicpO1xuICAgICAgY29udHJvbGxlci5kb21FbGVtZW50Lmluc2VydEJlZm9yZShib3guZG9tRWxlbWVudCwgY29udHJvbGxlci5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlckJveCkge1xuXG4gICAgICB2YXIgciA9IGZ1bmN0aW9uKHJldHVybmVkKSB7XG5cbiAgICAgICAgLy8gSGF2ZSB3ZSBkZWZpbmVkIGJvdGggYm91bmRhcmllcz9cbiAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWluKSAmJiBjb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21heCkpIHtcblxuICAgICAgICAgIC8vIFdlbGwsIHRoZW4gbGV0cyBqdXN0IHJlcGxhY2UgdGhpcyB3aXRoIGEgc2xpZGVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbnRyb2xsZXIuX19taW4sIGNvbnRyb2xsZXIuX19tYXgsIGNvbnRyb2xsZXIuX19zdGVwXVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybmVkO1xuXG4gICAgICB9O1xuXG4gICAgICBjb250cm9sbGVyLm1pbiA9IGNvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICAgIGNvbnRyb2xsZXIubWF4ID0gY29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5tYXgpO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBCb29sZWFuQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudHMgZG91YmxlLXRvZ2dsZVxuICAgICAgfSlcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRnVuY3Rpb25Db250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fYnV0dG9uLCAnY2xpY2snKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChsaSwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQobGksICdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgICB9KTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkgPSBjb21tb24uY29tcG9zZShmdW5jdGlvbihyKSB7XG4gICAgICAgIGxpLnN0eWxlLmJvcmRlckxlZnRDb2xvciA9IGNvbnRyb2xsZXIuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG5cbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgfVxuXG4gICAgY29udHJvbGxlci5zZXRWYWx1ZSA9IGNvbW1vbi5jb21wb3NlKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGlmIChndWkuZ2V0Um9vdCgpLl9fcHJlc2V0X3NlbGVjdCAmJiBjb250cm9sbGVyLmlzTW9kaWZpZWQoKSkge1xuICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLmdldFJvb3QoKSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBjb250cm9sbGVyLnNldFZhbHVlKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpIHtcblxuICAgIC8vIEZpbmQgdGhlIHRvcG1vc3QgR1VJLCB0aGF0J3Mgd2hlcmUgcmVtZW1iZXJlZCBvYmplY3RzIGxpdmUuXG4gICAgdmFyIHJvb3QgPSBndWkuZ2V0Um9vdCgpO1xuXG4gICAgLy8gRG9lcyB0aGUgb2JqZWN0IHdlJ3JlIGNvbnRyb2xsaW5nIG1hdGNoIGFueXRoaW5nIHdlJ3ZlIGJlZW4gdG9sZCB0b1xuICAgIC8vIHJlbWVtYmVyP1xuICAgIHZhciBtYXRjaGVkX2luZGV4ID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2YoY29udHJvbGxlci5vYmplY3QpO1xuXG4gICAgLy8gV2h5IHllcywgaXQgZG9lcyFcbiAgICBpZiAobWF0Y2hlZF9pbmRleCAhPSAtMSkge1xuXG4gICAgICAvLyBMZXQgbWUgZmV0Y2ggYSBtYXAgb2YgY29udHJvbGxlcnMgZm9yIHRoY29tbW9uLmlzT2JqZWN0LlxuICAgICAgdmFyIGNvbnRyb2xsZXJfbWFwID1cbiAgICAgICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRfaW5kZXhdO1xuXG4gICAgICAvLyBPaHAsIEkgYmVsaWV2ZSB0aGlzIGlzIHRoZSBmaXJzdCBjb250cm9sbGVyIHdlJ3ZlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgIC8vIG9iamVjdC4gTGV0cyBtYWtlIHRoZSBtYXAgZnJlc2guXG4gICAgICBpZiAoY29udHJvbGxlcl9tYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250cm9sbGVyX21hcCA9IHt9O1xuICAgICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRfaW5kZXhdID1cbiAgICAgICAgICAgIGNvbnRyb2xsZXJfbWFwO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoaXMgY29udHJvbGxlclxuICAgICAgY29udHJvbGxlcl9tYXBbY29udHJvbGxlci5wcm9wZXJ0eV0gPSBjb250cm9sbGVyO1xuXG4gICAgICAvLyBPa2F5LCBub3cgaGF2ZSB3ZSBzYXZlZCBhbnkgdmFsdWVzIGZvciB0aGlzIGNvbnRyb2xsZXI/XG4gICAgICBpZiAocm9vdC5sb2FkICYmIHJvb3QubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgICAgdmFyIHByZXNldF9tYXAgPSByb290LmxvYWQucmVtZW1iZXJlZDtcblxuICAgICAgICAvLyBXaGljaCBwcmVzZXQgYXJlIHdlIHRyeWluZyB0byBsb2FkP1xuICAgICAgICB2YXIgcHJlc2V0O1xuXG4gICAgICAgIGlmIChwcmVzZXRfbWFwW2d1aS5wcmVzZXRdKSB7XG5cbiAgICAgICAgICBwcmVzZXQgPSBwcmVzZXRfbWFwW2d1aS5wcmVzZXRdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocHJlc2V0X21hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdKSB7XG5cbiAgICAgICAgICAvLyBVaGgsIHlvdSBjYW4gaGF2ZSB0aGUgZGVmYXVsdCBpbnN0ZWFkP1xuICAgICAgICAgIHByZXNldCA9IHByZXNldF9tYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gTmFkYS5cblxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBEaWQgdGhlIGxvYWRlZCBvYmplY3QgcmVtZW1iZXIgdGhjb21tb24uaXNPYmplY3Q/XG4gICAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZF9pbmRleF0gJiZcblxuICAgICAgICAgIC8vIERpZCB3ZSByZW1lbWJlciB0aGlzIHBhcnRpY3VsYXIgcHJvcGVydHk/XG4gICAgICAgICAgICBwcmVzZXRbbWF0Y2hlZF9pbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgLy8gV2UgZGlkIHJlbWVtYmVyIHNvbWV0aGluZyBmb3IgdGhpcyBndXkgLi4uXG4gICAgICAgICAgdmFyIHZhbHVlID0gcHJlc2V0W21hdGNoZWRfaW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuXG4gICAgICAgICAgLy8gQW5kIHRoYXQncyB3aGF0IGl0IGlzLlxuICAgICAgICAgIGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCBrZXkpIHtcbiAgICAvLyBUT0RPIGhvdyBkb2VzIHRoaXMgZGVhbCB3aXRoIG11bHRpcGxlIEdVSSdzP1xuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcblxuICAgIHZhciBkaXYgPSBndWkuX19zYXZlX3JvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICBkb20uYWRkQ2xhc3MoZ3VpLmRvbUVsZW1lbnQsICdoYXMtc2F2ZScpO1xuXG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG5cbiAgICBkb20uYWRkQ2xhc3MoZGl2LCAnc2F2ZS1yb3cnKTtcblxuICAgIHZhciBnZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBnZWFycy5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcblxuICAgIC8vIFRPRE8gcmVwbGFjZSB3aXRoIEZ1bmN0aW9uQ29udHJvbGxlclxuICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ3NhdmUnKTtcblxuICAgIHZhciBidXR0b24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbjIuaW5uZXJIVE1MID0gJ05ldyc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ3NhdmUtYXMnKTtcblxuICAgIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbjMuaW5uZXJIVE1MID0gJ1JldmVydCc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuXG4gICAgdmFyIHNlbGVjdCA9IGd1aS5fX3ByZXNldF9zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblxuICAgIGlmIChndWkubG9hZCAmJiBndWkubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgIGNvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwga2V5LCBrZXkgPT0gZ3VpLnByZXNldCk7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBkb20uYmluZChzZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblxuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuXG4gICAgfSk7XG5cbiAgICBkaXYuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoZ2VhcnMpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMyk7XG5cbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXG4gICAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG5cbiAgICAgIHNhdmVMb2NhbGx5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICB2YXIgbG9jYWxTdG9yYWdlQ2hlY2tCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtc3RvcmFnZScpO1xuXG4gICAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlQ2hlY2tCb3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvd0hpZGVFeHBsYWluKCkge1xuICAgICAgICBleHBsYWluLnN0eWxlLmRpc3BsYXkgPSBndWkudXNlTG9jYWxTdG9yYWdlID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgIH1cblxuICAgICAgc2hvd0hpZGVFeHBsYWluKCk7XG5cbiAgICAgIC8vIFRPRE86IFVzZSBhIGJvb2xlYW4gY29udHJvbGxlciwgZm9vbCFcbiAgICAgIGRvbS5iaW5kKGxvY2FsU3RvcmFnZUNoZWNrQm94LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgICAgc2hvd0hpZGVFeHBsYWluKCk7XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuXG4gICAgZG9tLmJpbmQobmV3Q29uc3RydWN0b3JUZXh0QXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5tZXRhS2V5ICYmIChlLndoaWNoID09PSA2NyB8fCBlLmtleUNvZGUgPT0gNjcpKSB7XG4gICAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoZ2VhcnMsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgICAgU0FWRV9ESUFMT0dVRS5zaG93KCk7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmZvY3VzKCk7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIGd1aS5zYXZlKCk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24yLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcmVzZXROYW1lID0gcHJvbXB0KCdFbnRlciBhIG5ldyBwcmVzZXQgbmFtZS4nKTtcbiAgICAgIGlmIChwcmVzZXROYW1lKSBndWkuc2F2ZUFzKHByZXNldE5hbWUpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBndWkucmV2ZXJ0KCk7XG4gICAgfSk7XG5cbi8vICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlKGd1aSkge1xuXG4gICAgZ3VpLl9fcmVzaXplX2hhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29tbW9uLmV4dGVuZChndWkuX19yZXNpemVfaGFuZGxlLnN0eWxlLCB7XG5cbiAgICAgIHdpZHRoOiAnNnB4JyxcbiAgICAgIG1hcmdpbkxlZnQ6ICctM3B4JyxcbiAgICAgIGhlaWdodDogJzIwMHB4JyxcbiAgICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuLy8gICAgICBib3JkZXI6ICcxcHggc29saWQgYmx1ZSdcblxuICAgIH0pO1xuXG4gICAgdmFyIHBtb3VzZVg7XG5cbiAgICBkb20uYmluZChndWkuX19yZXNpemVfaGFuZGxlLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG5cbiAgICBndWkuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZ3VpLl9fcmVzaXplX2hhbmRsZSwgZ3VpLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuXG4gICAgICBkb20uYWRkQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhZyhlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgZ3VpLndpZHRoICs9IHBtb3VzZVggLSBlLmNsaWVudFg7XG4gICAgICBndWkub25SZXNpemUoKTtcbiAgICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWdTdG9wKCkge1xuXG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFdpZHRoKGd1aSwgdykge1xuICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgLy8gQXV0byBwbGFjZWQgc2F2ZS1yb3dzIGFyZSBwb3NpdGlvbiBmaXhlZCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHNldCB0aGUgd2lkdGggbWFudWFsbHkgaWYgd2Ugd2FudCBpdCB0byBibGVlZCB0byB0aGUgZWRnZVxuICAgIGlmIChndWkuX19zYXZlX3JvdyAmJiBndWkuYXV0b1BsYWNlKSB7XG4gICAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIH1pZiAoZ3VpLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFByZXNldChndWksIHVzZUluaXRpYWxWYWx1ZXMpIHtcblxuICAgIHZhciB0b1JldHVybiA9IHt9O1xuXG4gICAgLy8gRm9yIGVhY2ggb2JqZWN0IEknbSByZW1lbWJlcmluZ1xuICAgIGNvbW1vbi5lYWNoKGd1aS5fX3JlbWVtYmVyZWRPYmplY3RzLCBmdW5jdGlvbih2YWwsIGluZGV4KSB7XG5cbiAgICAgIHZhciBzYXZlZF92YWx1ZXMgPSB7fTtcblxuICAgICAgLy8gVGhlIGNvbnRyb2xsZXJzIEkndmUgbWFkZSBmb3IgdGhjb21tb24uaXNPYmplY3QgYnkgcHJvcGVydHlcbiAgICAgIHZhciBjb250cm9sbGVyX21hcCA9XG4gICAgICAgICAgZ3VpLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW2luZGV4XTtcblxuICAgICAgLy8gUmVtZW1iZXIgZWFjaCB2YWx1ZSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgY29tbW9uLmVhY2goY29udHJvbGxlcl9tYXAsIGZ1bmN0aW9uKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICAgIHNhdmVkX3ZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2F2ZSB0aGUgdmFsdWVzIGZvciB0aGNvbW1vbi5pc09iamVjdFxuICAgICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRfdmFsdWVzO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFByZXNldE9wdGlvbihndWksIG5hbWUsIHNldFNlbGVjdGVkKSB7XG4gICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIG9wdC5pbm5lckhUTUwgPSBuYW1lO1xuICAgIG9wdC52YWx1ZSA9IG5hbWU7XG4gICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICAgIGlmIChzZXRTZWxlY3RlZCkge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByZXNldFNlbGVjdEluZGV4KGd1aSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09IGd1aS5wcmVzZXQpIHtcbiAgICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1ByZXNldE1vZGlmaWVkKGd1aSwgbW9kaWZpZWQpIHtcbiAgICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuLy8gICAgY29uc29sZS5sb2coJ21hcmsnLCBtb2RpZmllZCwgb3B0KTtcbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWUgKyBcIipcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpIHtcblxuXG4gICAgaWYgKGNvbnRyb2xsZXJBcnJheS5sZW5ndGggIT0gMCkge1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSk7XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIGNvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24oYykge1xuICAgICAgYy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIHJldHVybiBHVUk7XG5cbn0pKGRhdC51dGlscy5jc3MsXG5cIjxkaXYgaWQ9XFxcImRnLXNhdmVcXFwiIGNsYXNzPVxcXCJkZyBkaWFsb2d1ZVxcXCI+XFxuXFxuICBIZXJlJ3MgdGhlIG5ldyBsb2FkIHBhcmFtZXRlciBmb3IgeW91ciA8Y29kZT5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3I6XFxuXFxuICA8dGV4dGFyZWEgaWQ9XFxcImRnLW5ldy1jb25zdHJ1Y3RvclxcXCI+PC90ZXh0YXJlYT5cXG5cXG4gIDxkaXYgaWQ9XFxcImRnLXNhdmUtbG9jYWxseVxcXCI+XFxuXFxuICAgIDxpbnB1dCBpZD1cXFwiZGctbG9jYWwtc3RvcmFnZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiLz4gQXV0b21hdGljYWxseSBzYXZlXFxuICAgIHZhbHVlcyB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IG9uIGV4aXQuXFxuXFxuICAgIDxkaXYgaWQ9XFxcImRnLWxvY2FsLWV4cGxhaW5cXFwiPlRoZSB2YWx1ZXMgc2F2ZWQgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiB3aWxsXFxuICAgICAgb3ZlcnJpZGUgdGhvc2UgcGFzc2VkIHRvIDxjb2RlPmRhdC5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3IuIFRoaXMgbWFrZXMgaXRcXG4gICAgICBlYXNpZXIgdG8gd29yayBpbmNyZW1lbnRhbGx5LCBidXQgPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpcyBmcmFnaWxlLFxcbiAgICAgIGFuZCB5b3VyIGZyaWVuZHMgbWF5IG5vdCBzZWUgdGhlIHNhbWUgdmFsdWVzIHlvdSBkby5cXG4gICAgICBcXG4gICAgPC9kaXY+XFxuICAgIFxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCIsXG5cIi5kZyB1bHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO3dpZHRoOjEwMCU7Y2xlYXI6Ym90aH0uZGcuYWN7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjA7ei1pbmRleDowfS5kZzpub3QoLmFjKSAubWFpbntvdmVyZmxvdzpoaWRkZW59LmRnLm1haW57LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO2JvcmRlcjowO3Bvc2l0aW9uOmFic29sdXRlO2xpbmUtaGVpZ2h0OjE5cHg7aGVpZ2h0OjIwcHg7Y3Vyc29yOnBvaW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDAwfS5kZy5tYWluIC5jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTExfS5kZy5he2Zsb2F0OnJpZ2h0O21hcmdpbi1yaWdodDoxNXB4O292ZXJmbG93LXg6aGlkZGVufS5kZy5hLmhhcy1zYXZlIHVse21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZSB1bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3twb3NpdGlvbjpmaXhlZDt0b3A6MDt6LWluZGV4OjEwMDJ9LmRnIGxpey13ZWJraXQtdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0Oy1tb3otdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDt0cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0fS5kZyBsaTpub3QoLmZvbGRlcil7Y3Vyc29yOmF1dG87aGVpZ2h0OjI3cHg7bGluZS1oZWlnaHQ6MjdweDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowIDRweCAwIDVweH0uZGcgbGkuZm9sZGVye3BhZGRpbmc6MDtib3JkZXItbGVmdDo0cHggc29saWQgcmdiYSgwLDAsMCwwKX0uZGcgbGkudGl0bGV7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWxlZnQ6LTRweH0uZGcgLmNsb3NlZCBsaTpub3QoLnRpdGxlKSwuZGcgLmNsb3NlZCB1bCBsaSwuZGcgLmNsb3NlZCB1bCBsaSA+ICp7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjowfS5kZyAuY3J7Y2xlYXI6Ym90aDtwYWRkaW5nLWxlZnQ6M3B4O2hlaWdodDoyN3B4fS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3tmbG9hdDpsZWZ0O3dpZHRoOjYwJX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtib3JkZXI6MDttYXJnaW4tdG9wOjRweDtwYWRkaW5nOjNweDt3aWR0aDoxMDAlO2Zsb2F0OnJpZ2h0fS5kZyAuaGFzLXNsaWRlciBpbnB1dFt0eXBlPXRleHRde3dpZHRoOjMwJTttYXJnaW4tbGVmdDowfS5kZyAuc2xpZGVye2Zsb2F0OmxlZnQ7d2lkdGg6NjYlO21hcmdpbi1sZWZ0Oi01cHg7bWFyZ2luLXJpZ2h0OjA7aGVpZ2h0OjE5cHg7bWFyZ2luLXRvcDo0cHh9LmRnIC5zbGlkZXItZmd7aGVpZ2h0OjEwMCV9LmRnIC5jIGlucHV0W3R5cGU9Y2hlY2tib3hde21hcmdpbi10b3A6OXB4fS5kZyAuYyBzZWxlY3R7bWFyZ2luLXRvcDo1cHh9LmRnIC5jci5mdW5jdGlvbiwuZGcgLmNyLmZ1bmN0aW9uIC5wcm9wZXJ0eS1uYW1lLC5kZyAuY3IuZnVuY3Rpb24gKiwuZGcgLmNyLmJvb2xlYW4sLmRnIC5jci5ib29sZWFuICp7Y3Vyc29yOnBvaW50ZXJ9LmRnIC5zZWxlY3RvcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWxlZnQ6LTlweDttYXJnaW4tdG9wOjIzcHg7ei1pbmRleDoxMH0uZGcgLmM6aG92ZXIgLnNlbGVjdG9yLC5kZyAuc2VsZWN0b3IuZHJhZ3tkaXNwbGF5OmJsb2NrfS5kZyBsaS5zYXZlLXJvd3twYWRkaW5nOjB9LmRnIGxpLnNhdmUtcm93IC5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzowcHggNnB4fS5kZy5kaWFsb2d1ZXtiYWNrZ3JvdW5kLWNvbG9yOiMyMjI7d2lkdGg6NDYwcHg7cGFkZGluZzoxNXB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE1cHh9I2RnLW5ldy1jb25zdHJ1Y3RvcntwYWRkaW5nOjEwcHg7Y29sb3I6IzIyMjtmb250LWZhbWlseTpNb25hY28sIG1vbm9zcGFjZTtmb250LXNpemU6MTBweDtib3JkZXI6MDtyZXNpemU6bm9uZTtib3gtc2hhZG93Omluc2V0IDFweCAxcHggMXB4ICM4ODg7d29yZC13cmFwOmJyZWFrLXdvcmQ7bWFyZ2luOjEycHggMDtkaXNwbGF5OmJsb2NrO3dpZHRoOjQ0MHB4O292ZXJmbG93LXk6c2Nyb2xsO2hlaWdodDoxMDBweDtwb3NpdGlvbjpyZWxhdGl2ZX0jZGctbG9jYWwtZXhwbGFpbntkaXNwbGF5Om5vbmU7Zm9udC1zaXplOjExcHg7bGluZS1oZWlnaHQ6MTdweDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo4cHg7bWFyZ2luLXRvcDoxMHB4fSNkZy1sb2NhbC1leHBsYWluIGNvZGV7Zm9udC1zaXplOjEwcHh9I2RhdC1ndWktc2F2ZS1sb2NhbGx5e2Rpc3BsYXk6bm9uZX0uZGd7Y29sb3I6I2VlZTtmb250OjExcHggJ0x1Y2lkYSBHcmFuZGUnLCBzYW5zLXNlcmlmO3RleHQtc2hhZG93OjAgLTFweCAwICMxMTF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjVweDtiYWNrZ3JvdW5kOiMxYTFhMWF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lcntoZWlnaHQ6MDtkaXNwbGF5Om5vbmV9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6IzY3Njc2N30uZGcgbGk6bm90KC5mb2xkZXIpe2JhY2tncm91bmQ6IzFhMWExYTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMmMyYzJjfS5kZyBsaS5zYXZlLXJvd3tsaW5lLWhlaWdodDoyNXB4O2JhY2tncm91bmQ6I2RhZDVjYjtib3JkZXI6MH0uZGcgbGkuc2F2ZS1yb3cgc2VsZWN0e21hcmdpbi1sZWZ0OjVweDt3aWR0aDoxMDhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbnttYXJnaW4tbGVmdDo1cHg7bWFyZ2luLXRvcDoxcHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1zaXplOjlweDtsaW5lLWhlaWdodDo3cHg7cGFkZGluZzo0cHggNHB4IDVweCA0cHg7YmFja2dyb3VuZDojYzViZGFkO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAxcHggMCAjYjBhNThmO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4ZjtjdXJzb3I6cG9pbnRlcn0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbi5nZWFyc3tiYWNrZ3JvdW5kOiNjNWJkYWQgdXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXNBQUFBTkNBWUFBQUIvOVpRN0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBUUpKUkVGVWVOcGlZS0FVL1AvL1B3R0lDL0FwQ0FCaUJTQVcrSThBQ2xBY2dLeFE0VDlob01BRVVyeHgyUVNHTjYrZWdEWCsvdldUNGU3TjgyQU1Zb1BBeC9ldndXb1lvU1liQUNYMnM3S3hDeHpjc2V6RGgzZXZGb0RFQllURUVxeWNnZ1dBekE5QXVVU1FRZ2VZUGE5ZlB2Ni9ZV20vQWN4NUlQYjd0eS9mdytRWmJsdzY3dkRzOFIwWUh5UWhnT2J4K3lBSmtCcW1HNWRQUERoMWFQT0dSL2V1Z1cwRzR2bElvVElmeUZjQStRZWtoaEhKaFBkUXhiaUFJZ3VNQlRRWnJQRDcxMDhNNnJvV1lERlFpSUFBdjZBb3cvMWJGd1hnaXMrZjJMVUF5bndvSWFOY3o4WE54M0RsN01FSlVER1FweDlndFE4WUN1ZUIrRDI2T0VDQUFRRGFkdDdlNDZENDJRQUFBQUJKUlU1RXJrSmdnZz09KSAycHggMXB4IG5vLXJlcGVhdDtoZWlnaHQ6N3B4O3dpZHRoOjhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNiYWIxOWU7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmfS5kZyBsaS5mb2xkZXJ7Ym9yZGVyLWJvdHRvbTowfS5kZyBsaS50aXRsZXtwYWRkaW5nLWxlZnQ6MTZweDtiYWNrZ3JvdW5kOiMwMDAgdXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsSStoS2dGeG9DZ0FPdz09KSA2cHggMTBweCBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpfS5kZyAuY2xvc2VkIGxpLnRpdGxle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsR0lXcU1DYldBRUFPdz09KX0uZGcgLmNyLmJvb2xlYW57Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICM4MDY3ODd9LmRnIC5jci5mdW5jdGlvbntib3JkZXItbGVmdDozcHggc29saWQgI2U2MWQ1Zn0uZGcgLmNyLm51bWJlcntib3JkZXItbGVmdDozcHggc29saWQgIzJmYTFkNn0uZGcgLmNyLm51bWJlciBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMyZmExZDZ9LmRnIC5jci5zdHJpbmd7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMxZWQzNmZ9LmRnIC5jci5zdHJpbmcgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMWVkMzZmfS5kZyAuY3IuZnVuY3Rpb246aG92ZXIsLmRnIC5jci5ib29sZWFuOmhvdmVye2JhY2tncm91bmQ6IzExMX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtiYWNrZ3JvdW5kOiMzMDMwMzA7b3V0bGluZTpub25lfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpmb2N1c3tiYWNrZ3JvdW5kOiM0OTQ5NDk7Y29sb3I6I2ZmZn0uZGcgLmMgLnNsaWRlcntiYWNrZ3JvdW5kOiMzMDMwMzA7Y3Vyc29yOmV3LXJlc2l6ZX0uZGcgLmMgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiMyZmExZDZ9LmRnIC5jIC5zbGlkZXI6aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyAuc2xpZGVyOmhvdmVyIC5zbGlkZXItZmd7YmFja2dyb3VuZDojNDRhYmRhfVxcblwiLFxuZGF0LmNvbnRyb2xsZXJzLmZhY3RvcnkgPSAoZnVuY3Rpb24gKE9wdGlvbkNvbnRyb2xsZXIsIE51bWJlckNvbnRyb2xsZXJCb3gsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIFN0cmluZ0NvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgQm9vbGVhbkNvbnRyb2xsZXIsIGNvbW1vbikge1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXG4gICAgICAgIC8vIFByb3ZpZGluZyBvcHRpb25zP1xuICAgICAgICBpZiAoY29tbW9uLmlzQXJyYXkoYXJndW1lbnRzWzJdKSB8fCBjb21tb24uaXNPYmplY3QoYXJndW1lbnRzWzJdKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvdmlkaW5nIGEgbWFwP1xuXG4gICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoaW5pdGlhbFZhbHVlKSkge1xuXG4gICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIGNvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG5cbiAgICAgICAgICAgIC8vIEhhcyBtaW4gYW5kIG1heC5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10gfSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNGdW5jdGlvbihpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0Jvb2xlYW4oaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSkoZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCxcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuZGF0LmNvbnRyb2xsZXJzLlN0cmluZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIHRleHQgaW5wdXQgdG8gYWx0ZXIgdGhlIHN0cmluZyBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgU3RyaW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG5cbiAgfTtcblxuICBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBTdG9wcyB0aGUgY2FyZXQgZnJvbSBtb3Zpbmcgb24gYWNjb3VudCBvZjpcbiAgICAgICAgICAvLyBrZXl1cCAtPiBzZXRWYWx1ZSAtPiB1cGRhdGVEaXNwbGF5XG4gICAgICAgICAgaWYgKCFkb20uaXNBY3RpdmUodGhpcy5fX2lucHV0KSkge1xuICAgICAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94LFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG5kYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Db2xvckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgQ29sb3IsIGludGVycHJldCwgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIENvbG9yQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB0aGlzLl9fY29sb3IgPSBuZXcgQ29sb3IodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICB0aGlzLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcblxuICAgIHRoaXMuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5jbGFzc05hbWUgPSAnc2VsZWN0b3InO1xuXG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5jbGFzc05hbWUgPSAnc2F0dXJhdGlvbi1maWVsZCc7XG5cbiAgICB0aGlzLl9fZmllbGRfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgPSAnMnB4IHNvbGlkICc7XG5cbiAgICB0aGlzLl9faHVlX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9faHVlX2tub2IuY2xhc3NOYW1lID0gJ2h1ZS1rbm9iJztcblxuICAgIHRoaXMuX19odWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyA9ICcwIDFweCAxcHggJztcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykgeyAvLyBvbiBlbnRlclxuICAgICAgICBvbkJsdXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICBkb21cbiAgICAgICAgLmFkZENsYXNzKHRoaXMsICdkcmFnJylcbiAgICAgICAgLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHZhciB2YWx1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAodGhpcy5fX2NvbG9yLnYgPCAuNSA/ICcjZmZmJyA6ICcjMDAwJyksXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcbiAgICBcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19odWVfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMnB4JyxcbiAgICAgIGJvcmRlclJpZ2h0OiAnNHB4IHNvbGlkICNmZmYnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMHB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnM3B4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodmFsdWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuICAgIH0pO1xuICAgIFxuICAgIGxpbmVhckdyYWRpZW50KHZhbHVlX2ZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBjdXJzb3I6ICducy1yZXNpemUnXG4gICAgfSk7XG5cbiAgICBodWVHcmFkaWVudCh0aGlzLl9faHVlX2ZpZWxkKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4vLyAgICAgIHdpZHRoOiAnMTIwcHgnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbi8vICAgICAgcGFkZGluZzogJzRweCcsXG4vLyAgICAgIG1hcmdpbkJvdHRvbTogJzZweCcsXG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgwLDAsMCwwLjcpJ1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKHRoaXMuX19maWVsZF9rbm9iLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19odWVfZmllbGQsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kSCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdub25lJztcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRTVik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kU1YoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZFNWKTtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMudmFsdWUpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLl9fY29sb3IuX19zdGF0ZSA9IGk7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kSCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRIKTtcbiAgICB9XG5cbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZV9maWVsZCk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19maWVsZF9rbm9iKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9faHVlX2ZpZWxkKTtcbiAgICB0aGlzLl9faHVlX2ZpZWxkLmFwcGVuZENoaWxkKHRoaXMuX19odWVfa25vYik7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3NlbGVjdG9yKTtcblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZnVuY3Rpb24gc2V0U1YoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciB3ID0gZG9tLmdldFdpZHRoKF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgICB2YXIgbyA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICAgIHZhciBzID0gKGUuY2xpZW50WCAtIG8ubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCkgLyB3O1xuICAgICAgdmFyIHYgPSAxIC0gKGUuY2xpZW50WSAtIG8udG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC8gdztcblxuICAgICAgaWYgKHYgPiAxKSB2ID0gMTtcbiAgICAgIGVsc2UgaWYgKHYgPCAwKSB2ID0gMDtcblxuICAgICAgaWYgKHMgPiAxKSBzID0gMTtcbiAgICAgIGVsc2UgaWYgKHMgPCAwKSBzID0gMDtcblxuICAgICAgX3RoaXMuX19jb2xvci52ID0gdjtcbiAgICAgIF90aGlzLl9fY29sb3IucyA9IHM7XG5cbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblxuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgcyA9IGRvbS5nZXRIZWlnaHQoX3RoaXMuX19odWVfZmllbGQpO1xuICAgICAgdmFyIG8gPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9faHVlX2ZpZWxkKTtcbiAgICAgIHZhciBoID0gMSAtIChlLmNsaWVudFkgLSBvLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSAvIHM7XG5cbiAgICAgIGlmIChoID4gMSkgaCA9IDE7XG4gICAgICBlbHNlIGlmIChoIDwgMCkgaCA9IDA7XG5cbiAgICAgIF90aGlzLl9fY29sb3IuaCA9IGggKiAzNjA7XG5cbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgQ29sb3JDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIENvbG9yQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy5nZXRWYWx1ZSgpKTtcblxuICAgICAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuXG4gICAgICAgICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1pc21hdGNoIG9uIHRoZSBpbnRlcnByZXRlZCB2YWx1ZS5cblxuICAgICAgICAgICAgY29tbW9uLmVhY2goQ29sb3IuQ09NUE9ORU5UUywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIGlmICghY29tbW9uLmlzVW5kZWZpbmVkKGlbY29tcG9uZW50XSkgJiZcbiAgICAgICAgICAgICAgICAgICFjb21tb24uaXNVbmRlZmluZWQodGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkgJiZcbiAgICAgICAgICAgICAgICAgIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307IC8vIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBJZiBub3RoaW5nIGRpdmVyZ2VzLCB3ZSBrZWVwIG91ciBwcmV2aW91cyB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGZvciBzdGF0ZWZ1bG5lc3MsIG90aGVyd2lzZSB3ZSByZWNhbGN1bGF0ZSBmcmVzaFxuICAgICAgICAgICAgaWYgKG1pc21hdGNoKSB7XG4gICAgICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fdGVtcC5fX3N0YXRlLCB0aGlzLl9fY29sb3IuX19zdGF0ZSk7XG5cbiAgICAgICAgICB0aGlzLl9fdGVtcC5hID0gMTtcblxuICAgICAgICAgIHZhciBmbGlwID0gKHRoaXMuX19jb2xvci52IDwgLjUgfHwgdGhpcy5fX2NvbG9yLnMgPiAuNSkgPyAyNTUgOiAwO1xuICAgICAgICAgIHZhciBfZmxpcCA9IDI1NSAtIGZsaXA7XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAxMDAgKiAoMSAtIHRoaXMuX19jb2xvci52KSAtIDcgKyAncHgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fdGVtcC50b1N0cmluZygpLFxuICAgICAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKycpJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4J1xuXG4gICAgICAgICAgdGhpcy5fX3RlbXAucyA9IDE7XG4gICAgICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG5cbiAgICAgICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsnKScsXG4gICAgICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKycsLjcpJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG4gIFxuICB2YXIgdmVuZG9ycyA9IFsnLW1vei0nLCctby0nLCctd2Via2l0LScsJy1tcy0nLCcnXTtcbiAgXG4gIGZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICBjb21tb24uZWFjaCh2ZW5kb3JzLCBmdW5jdGlvbih2ZW5kb3IpIHtcbiAgICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogJyArIHZlbmRvciArICdsaW5lYXItZ3JhZGllbnQoJyt4KycsICcrYSsnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGh1ZUdyYWRpZW50KGVsZW0pIHtcbiAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgfVxuXG5cbiAgcmV0dXJuIENvbG9yQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC5jb2xvci5Db2xvciA9IChmdW5jdGlvbiAoaW50ZXJwcmV0LCBtYXRoLCB0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyAnRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcblxuXG4gIH07XG5cbiAgQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsJ2cnLCdiJywnaCcsJ3MnLCd2JywnaGV4JywnYSddO1xuXG4gIGNvbW1vbi5leHRlbmQoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfSxcblxuICAgIHRvT3JpZ2luYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuXG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gbWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUkdCKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblxuICAgICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gbWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblxuICAgICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBtYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhyb3cgJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZSc7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlSFNWKGNvbG9yKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gbWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLFxuICAgICAgICB7XG4gICAgICAgICAgczogcmVzdWx0LnMsXG4gICAgICAgICAgdjogcmVzdWx0LnZcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICAgIH0gZWxzZSBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29sb3I7XG5cbn0pKGRhdC5jb2xvci5pbnRlcnByZXQsXG5kYXQuY29sb3IubWF0aCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRtcENvbXBvbmVudDtcblxuICByZXR1cm4ge1xuXG4gICAgaHN2X3RvX3JnYjogZnVuY3Rpb24oaCwgcywgdikge1xuXG4gICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuXG4gICAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxLjAgLSAoZiAqIHMpKTtcbiAgICAgIHZhciB0ID0gdiAqICgxLjAgLSAoKDEuMCAtIGYpICogcykpO1xuICAgICAgdmFyIGMgPSBbXG4gICAgICAgIFt2LCB0LCBwXSxcbiAgICAgICAgW3EsIHYsIHBdLFxuICAgICAgICBbcCwgdiwgdF0sXG4gICAgICAgIFtwLCBxLCB2XSxcbiAgICAgICAgW3QsIHAsIHZdLFxuICAgICAgICBbdiwgcCwgcV1cbiAgICAgIF1baGldO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdICogMjU1LFxuICAgICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgICBiOiBjWzJdICogMjU1XG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIHJnYl90b19oc3Y6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblxuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgIGgsIHM7XG5cbiAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IE5hTixcbiAgICAgICAgICBzOiAwLFxuICAgICAgICAgIHY6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIgPT0gbWF4KSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBoICogMzYwLFxuICAgICAgICBzOiBzLFxuICAgICAgICB2OiBtYXggLyAyNTVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJnYl90b19oZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgICAgcmV0dXJuIGhleDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgICByZXR1cm4gKGhleCA+PiAoY29tcG9uZW50SW5kZXggKiA4KSkgJiAweEZGO1xuICAgIH0sXG5cbiAgICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCAoaGV4ICYgfiAoMHhGRiA8PCB0bXBDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgfVxuXG59KSgpLFxuZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29sb3IuaW50ZXJwcmV0LFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogcmVxdWlyZWpzIHZlcnNpb24gb2YgUGF1bCBJcmlzaCdzIFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKi9cblxuICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcblxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcblxuICAgICAgfTtcbn0pKCksXG5kYXQuZG9tLkNlbnRlcmVkRGl2ID0gKGZ1bmN0aW9uIChkb20sIGNvbW1vbikge1xuXG5cbiAgdmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLCB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDAnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuXG4gICAgZG9tLm1ha2VGdWxsc2NyZWVuKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG5cblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBkb20uYmluZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLmhpZGUoKTtcbiAgICB9KTtcblxuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgXG5cblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc1MiUnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG5cbiAgICB0aGlzLmxheW91dCgpO1xuXG4gICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICAgIH0pO1xuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuXG4gICAgfTtcblxuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4vLyAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzQ4JSc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmxlZnQgPSB3aW5kb3cuaW5uZXJXaWR0aC8yIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gd2luZG93LmlubmVySGVpZ2h0LzIgLSBkb20uZ2V0SGVpZ2h0KHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIGxvY2tTY3JvbGwoZSkge1xuICAgIGNvbnNvbGUubG9nKGUpO1xuICB9XG5cbiAgcmV0dXJuIENlbnRlcmVkRGl2O1xuXG59KShkYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTsiLCIvKiEgQGxpY2Vuc2UgRmlyZWJhc2UgdjIuMS4yIC0gTGljZW5zZTogaHR0cHM6Ly93d3cuZmlyZWJhc2UuY29tL3Rlcm1zL3Rlcm1zLW9mLXNlcnZpY2UuaHRtbCAqLyAoZnVuY3Rpb24oKSB7dmFyIGgsYWE9dGhpcztmdW5jdGlvbiBtKGEpe3JldHVybiB2b2lkIDAhPT1hfWZ1bmN0aW9uIGJhKCl7fWZ1bmN0aW9uIGNhKGEpe2EuTmI9ZnVuY3Rpb24oKXtyZXR1cm4gYS5rZj9hLmtmOmEua2Y9bmV3IGF9fVxuZnVuY3Rpb24gZGEoYSl7dmFyIGI9dHlwZW9mIGE7aWYoXCJvYmplY3RcIj09YilpZihhKXtpZihhIGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuXCJhcnJheVwiO2lmKGEgaW5zdGFuY2VvZiBPYmplY3QpcmV0dXJuIGI7dmFyIGM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBXaW5kb3ddXCI9PWMpcmV0dXJuXCJvYmplY3RcIjtpZihcIltvYmplY3QgQXJyYXldXCI9PWN8fFwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuc3BsaWNlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpcmV0dXJuXCJhcnJheVwiO2lmKFwiW29iamVjdCBGdW5jdGlvbl1cIj09Y3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuY2FsbCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSlyZXR1cm5cImZ1bmN0aW9uXCJ9ZWxzZSByZXR1cm5cIm51bGxcIjtcbmVsc2UgaWYoXCJmdW5jdGlvblwiPT1iJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgYS5jYWxsKXJldHVyblwib2JqZWN0XCI7cmV0dXJuIGJ9ZnVuY3Rpb24gZWEoYSl7cmV0dXJuXCJhcnJheVwiPT1kYShhKX1mdW5jdGlvbiBmYShhKXt2YXIgYj1kYShhKTtyZXR1cm5cImFycmF5XCI9PWJ8fFwib2JqZWN0XCI9PWImJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aH1mdW5jdGlvbiBwKGEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGdhKGEpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGhhKGEpe3JldHVyblwiZnVuY3Rpb25cIj09ZGEoYSl9ZnVuY3Rpb24gaWEoYSl7dmFyIGI9dHlwZW9mIGE7cmV0dXJuXCJvYmplY3RcIj09YiYmbnVsbCE9YXx8XCJmdW5jdGlvblwiPT1ifWZ1bmN0aW9uIGphKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfVxuZnVuY3Rpb24ga2EoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gcShhLGIsYyl7cT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCYmLTEhPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpP2phOmthO3JldHVybiBxLmFwcGx5KG51bGwsYXJndW1lbnRzKX12YXIgbGE9RGF0ZS5ub3d8fGZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfTtcbmZ1bmN0aW9uIG1hKGEsYil7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT1iLnByb3RvdHlwZTthLkpnPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBjO2EuRmc9ZnVuY3Rpb24oYSxjLGYpe3JldHVybiBiLnByb3RvdHlwZVtjXS5hcHBseShhLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSl9fTtmdW5jdGlvbiBuYShhKXthPVN0cmluZyhhKTtpZigvXlxccyokLy50ZXN0KGEpPzA6L15bXFxdLDp7fVxcc1xcdTIwMjhcXHUyMDI5XSokLy50ZXN0KGEucmVwbGFjZSgvXFxcXFtcIlxcXFxcXC9iZm5ydHVdL2csXCJAXCIpLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOVxceDAwLVxceDA4XFx4MGEtXFx4MWZdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLFwiXVwiKS5yZXBsYWNlKC8oPzpefDp8LCkoPzpbXFxzXFx1MjAyOFxcdTIwMjldKlxcWykrL2csXCJcIikpKXRyeXtyZXR1cm4gZXZhbChcIihcIithK1wiKVwiKX1jYXRjaChiKXt9dGhyb3cgRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RyaW5nOiBcIithKTt9ZnVuY3Rpb24gb2EoKXt0aGlzLkhkPXZvaWQgMH1cbmZ1bmN0aW9uIHBhKGEsYixjKXtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJzdHJpbmdcIjpxYShiLGMpO2JyZWFrO2Nhc2UgXCJudW1iZXJcIjpjLnB1c2goaXNGaW5pdGUoYikmJiFpc05hTihiKT9iOlwibnVsbFwiKTticmVhaztjYXNlIFwiYm9vbGVhblwiOmMucHVzaChiKTticmVhaztjYXNlIFwidW5kZWZpbmVkXCI6Yy5wdXNoKFwibnVsbFwiKTticmVhaztjYXNlIFwib2JqZWN0XCI6aWYobnVsbD09Yil7Yy5wdXNoKFwibnVsbFwiKTticmVha31pZihlYShiKSl7dmFyIGQ9Yi5sZW5ndGg7Yy5wdXNoKFwiW1wiKTtmb3IodmFyIGU9XCJcIixmPTA7ZjxkO2YrKyljLnB1c2goZSksZT1iW2ZdLHBhKGEsYS5IZD9hLkhkLmNhbGwoYixTdHJpbmcoZiksZSk6ZSxjKSxlPVwiLFwiO2MucHVzaChcIl1cIik7YnJlYWt9Yy5wdXNoKFwie1wiKTtkPVwiXCI7Zm9yKGYgaW4gYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixmKSYmKGU9YltmXSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYoYy5wdXNoKGQpLHFhKGYsYyksXG5jLnB1c2goXCI6XCIpLHBhKGEsYS5IZD9hLkhkLmNhbGwoYixmLGUpOmUsYyksZD1cIixcIikpO2MucHVzaChcIn1cIik7YnJlYWs7Y2FzZSBcImZ1bmN0aW9uXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZTogXCIrdHlwZW9mIGIpO319dmFyIHJhPXsnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIixcIi9cIjpcIlxcXFwvXCIsXCJcXGJcIjpcIlxcXFxiXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXHJcIjpcIlxcXFxyXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LHNhPS9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKT8vW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHVmZmZmXS9nOi9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceGZmXS9nO1xuZnVuY3Rpb24gcWEoYSxiKXtiLnB1c2goJ1wiJyxhLnJlcGxhY2Uoc2EsZnVuY3Rpb24oYSl7aWYoYSBpbiByYSlyZXR1cm4gcmFbYV07dmFyIGI9YS5jaGFyQ29kZUF0KDApLGU9XCJcXFxcdVwiOzE2PmI/ZSs9XCIwMDBcIjoyNTY+Yj9lKz1cIjAwXCI6NDA5Nj5iJiYoZSs9XCIwXCIpO3JldHVybiByYVthXT1lK2IudG9TdHJpbmcoMTYpfSksJ1wiJyl9O2Z1bmN0aW9uIHRhKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgSlNPTiYmbShKU09OLnBhcnNlKT9KU09OLnBhcnNlKGEpOm5hKGEpfWZ1bmN0aW9uIHIoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBKU09OJiZtKEpTT04uc3RyaW5naWZ5KSlhPUpTT04uc3RyaW5naWZ5KGEpO2Vsc2V7dmFyIGI9W107cGEobmV3IG9hLGEsYik7YT1iLmpvaW4oXCJcIil9cmV0dXJuIGF9O2Z1bmN0aW9uIHMoYSxiKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYil9ZnVuY3Rpb24gdChhLGIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGIpKXJldHVybiBhW2JdfWZ1bmN0aW9uIHVhKGEsYil7Zm9yKHZhciBjIGluIGEpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYykmJmIoYyxhW2NdKX1mdW5jdGlvbiB2YShhKXt2YXIgYj17fTt1YShhLGZ1bmN0aW9uKGEsZCl7YlthXT1kfSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIHdhKGEpe3RoaXMudWM9YTt0aGlzLkVkPVwiZmlyZWJhc2U6XCJ9aD13YS5wcm90b3R5cGU7aC5zZXQ9ZnVuY3Rpb24oYSxiKXtudWxsPT1iP3RoaXMudWMucmVtb3ZlSXRlbSh0aGlzLkVkK2EpOnRoaXMudWMuc2V0SXRlbSh0aGlzLkVkK2EscihiKSl9O2guZ2V0PWZ1bmN0aW9uKGEpe2E9dGhpcy51Yy5nZXRJdGVtKHRoaXMuRWQrYSk7cmV0dXJuIG51bGw9PWE/bnVsbDp0YShhKX07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7dGhpcy51Yy5yZW1vdmVJdGVtKHRoaXMuRWQrYSl9O2gubGY9ITE7aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVjLnRvU3RyaW5nKCl9O2Z1bmN0aW9uIHhhKCl7dGhpcy5vYz17fX14YS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7bnVsbD09Yj9kZWxldGUgdGhpcy5vY1thXTp0aGlzLm9jW2FdPWJ9O3hhLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHModGhpcy5vYyxhKT90aGlzLm9jW2FdOm51bGx9O3hhLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMub2NbYV19O3hhLnByb3RvdHlwZS5sZj0hMDtmdW5jdGlvbiB5YShhKXt0cnl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93W2FdKXt2YXIgYj13aW5kb3dbYV07Yi5zZXRJdGVtKFwiZmlyZWJhc2U6c2VudGluZWxcIixcImNhY2hlXCIpO2IucmVtb3ZlSXRlbShcImZpcmViYXNlOnNlbnRpbmVsXCIpO3JldHVybiBuZXcgd2EoYil9fWNhdGNoKGMpe31yZXR1cm4gbmV3IHhhfXZhciB6YT15YShcImxvY2FsU3RvcmFnZVwiKSx2PXlhKFwic2Vzc2lvblN0b3JhZ2VcIik7ZnVuY3Rpb24gQWEoYSxiLGMsZCxlKXt0aGlzLmhvc3Q9YS50b0xvd2VyQ2FzZSgpO3RoaXMuZG9tYWluPXRoaXMuaG9zdC5zdWJzdHIodGhpcy5ob3N0LmluZGV4T2YoXCIuXCIpKzEpO3RoaXMuQWI9Yjt0aGlzLnRiPWM7dGhpcy5EZz1kO3RoaXMuRGQ9ZXx8XCJcIjt0aGlzLk1hPXphLmdldChcImhvc3Q6XCIrYSl8fHRoaXMuaG9zdH1mdW5jdGlvbiBCYShhLGIpe2IhPT1hLk1hJiYoYS5NYT1iLFwicy1cIj09PWEuTWEuc3Vic3RyKDAsMikmJnphLnNldChcImhvc3Q6XCIrYS5ob3N0LGEuTWEpKX1BYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT0odGhpcy5BYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuaG9zdDt0aGlzLkRkJiYoYSs9XCI8XCIrdGhpcy5EZCtcIj5cIik7cmV0dXJuIGF9O2Z1bmN0aW9uIENhKCl7dGhpcy5TYT0tMX07ZnVuY3Rpb24gRGEoKXt0aGlzLlNhPS0xO3RoaXMuU2E9NjQ7dGhpcy5SPVtdO3RoaXMuYmU9W107dGhpcy5FZj1bXTt0aGlzLkFkPVtdO3RoaXMuQWRbMF09MTI4O2Zvcih2YXIgYT0xO2E8dGhpcy5TYTsrK2EpdGhpcy5BZFthXT0wO3RoaXMuVGQ9dGhpcy5TYj0wO3RoaXMucmVzZXQoKX1tYShEYSxDYSk7RGEucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5SWzBdPTE3MzI1ODQxOTM7dGhpcy5SWzFdPTQwMjMyMzM0MTc7dGhpcy5SWzJdPTI1NjIzODMxMDI7dGhpcy5SWzNdPTI3MTczMzg3ODt0aGlzLlJbNF09MzI4NTM3NzUyMDt0aGlzLlRkPXRoaXMuU2I9MH07XG5mdW5jdGlvbiBFYShhLGIsYyl7Y3x8KGM9MCk7dmFyIGQ9YS5FZjtpZihwKGIpKWZvcih2YXIgZT0wOzE2PmU7ZSsrKWRbZV09Yi5jaGFyQ29kZUF0KGMpPDwyNHxiLmNoYXJDb2RlQXQoYysxKTw8MTZ8Yi5jaGFyQ29kZUF0KGMrMik8PDh8Yi5jaGFyQ29kZUF0KGMrMyksYys9NDtlbHNlIGZvcihlPTA7MTY+ZTtlKyspZFtlXT1iW2NdPDwyNHxiW2MrMV08PDE2fGJbYysyXTw8OHxiW2MrM10sYys9NDtmb3IoZT0xNjs4MD5lO2UrKyl7dmFyIGY9ZFtlLTNdXmRbZS04XV5kW2UtMTRdXmRbZS0xNl07ZFtlXT0oZjw8MXxmPj4+MzEpJjQyOTQ5NjcyOTV9Yj1hLlJbMF07Yz1hLlJbMV07Zm9yKHZhciBnPWEuUlsyXSxrPWEuUlszXSxsPWEuUls0XSxuLGU9MDs4MD5lO2UrKyk0MD5lPzIwPmU/KGY9a15jJihnXmspLG49MTUxODUwMDI0OSk6KGY9Y15nXmssbj0xODU5Nzc1MzkzKTo2MD5lPyhmPWMmZ3xrJihjfGcpLG49MjQwMDk1OTcwOCk6KGY9Y15nXmssbj0zMzk1NDY5NzgyKSxmPShiPDxcbjV8Yj4+PjI3KStmK2wrbitkW2VdJjQyOTQ5NjcyOTUsbD1rLGs9ZyxnPShjPDwzMHxjPj4+MikmNDI5NDk2NzI5NSxjPWIsYj1mO2EuUlswXT1hLlJbMF0rYiY0Mjk0OTY3Mjk1O2EuUlsxXT1hLlJbMV0rYyY0Mjk0OTY3Mjk1O2EuUlsyXT1hLlJbMl0rZyY0Mjk0OTY3Mjk1O2EuUlszXT1hLlJbM10rayY0Mjk0OTY3Mjk1O2EuUls0XT1hLlJbNF0rbCY0Mjk0OTY3Mjk1fVxuRGEucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe20oYil8fChiPWEubGVuZ3RoKTtmb3IodmFyIGM9Yi10aGlzLlNhLGQ9MCxlPXRoaXMuYmUsZj10aGlzLlNiO2Q8Yjspe2lmKDA9PWYpZm9yKDtkPD1jOylFYSh0aGlzLGEsZCksZCs9dGhpcy5TYTtpZihwKGEpKWZvcig7ZDxiOyl7aWYoZVtmXT1hLmNoYXJDb2RlQXQoZCksKytmLCsrZCxmPT10aGlzLlNhKXtFYSh0aGlzLGUpO2Y9MDticmVha319ZWxzZSBmb3IoO2Q8YjspaWYoZVtmXT1hW2RdLCsrZiwrK2QsZj09dGhpcy5TYSl7RWEodGhpcyxlKTtmPTA7YnJlYWt9fXRoaXMuU2I9Zjt0aGlzLlRkKz1ifTtmdW5jdGlvbiBGYSgpe3JldHVybiBNYXRoLmZsb29yKDIxNDc0ODM2NDgqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpK01hdGguYWJzKE1hdGguZmxvb3IoMjE0NzQ4MzY0OCpNYXRoLnJhbmRvbSgpKV5sYSgpKS50b1N0cmluZygzNil9O3ZhciB3PUFycmF5LnByb3RvdHlwZSxHYT13LmluZGV4T2Y/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmluZGV4T2YuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtjPW51bGw9PWM/MDowPmM/TWF0aC5tYXgoMCxhLmxlbmd0aCtjKTpjO2lmKHAoYSkpcmV0dXJuIHAoYikmJjE9PWIubGVuZ3RoP2EuaW5kZXhPZihiLGMpOi0xO2Zvcig7YzxhLmxlbmd0aDtjKyspaWYoYyBpbiBhJiZhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sSGE9dy5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXt3LmZvckVhY2guY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1wKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKX0sSWE9dy5maWx0ZXI/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmZpbHRlci5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVtdLGY9MCxnPXAoYSk/XG5hLnNwbGl0KFwiXCIpOmEsaz0wO2s8ZDtrKyspaWYoayBpbiBnKXt2YXIgbD1nW2tdO2IuY2FsbChjLGwsayxhKSYmKGVbZisrXT1sKX1yZXR1cm4gZX0sSmE9dy5tYXA/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3Lm1hcC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPUFycmF5KGQpLGY9cChhKT9hLnNwbGl0KFwiXCIpOmEsZz0wO2c8ZDtnKyspZyBpbiBmJiYoZVtnXT1iLmNhbGwoYyxmW2ddLGcsYSkpO3JldHVybiBlfSxLYT13LnJlZHVjZT9mdW5jdGlvbihhLGIsYyxkKXtkJiYoYj1xKGIsZCkpO3JldHVybiB3LnJlZHVjZS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YztIYShhLGZ1bmN0aW9uKGMsZyl7ZT1iLmNhbGwoZCxlLGMsZyxhKX0pO3JldHVybiBlfSxMYT13LmV2ZXJ5P2Z1bmN0aW9uKGEsYixjKXtyZXR1cm4gdy5ldmVyeS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVxucChhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspaWYoZiBpbiBlJiYhYi5jYWxsKGMsZVtmXSxmLGEpKXJldHVybiExO3JldHVybiEwfTtmdW5jdGlvbiBNYShhLGIpe3ZhciBjPU5hKGEsYix2b2lkIDApO3JldHVybiAwPmM/bnVsbDpwKGEpP2EuY2hhckF0KGMpOmFbY119ZnVuY3Rpb24gTmEoYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXAoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpKXJldHVybiBmO3JldHVybi0xfWZ1bmN0aW9uIE9hKGEsYil7dmFyIGM9R2EoYSxiKTswPD1jJiZ3LnNwbGljZS5jYWxsKGEsYywxKX1mdW5jdGlvbiBQYShhLGIsYyl7cmV0dXJuIDI+PWFyZ3VtZW50cy5sZW5ndGg/dy5zbGljZS5jYWxsKGEsYik6dy5zbGljZS5jYWxsKGEsYixjKX1mdW5jdGlvbiBRYShhLGIpe2Euc29ydChifHxSYSl9ZnVuY3Rpb24gUmEoYSxiKXtyZXR1cm4gYT5iPzE6YTxiPy0xOjB9O3ZhciBTYTthOnt2YXIgVGE9YWEubmF2aWdhdG9yO2lmKFRhKXt2YXIgVWE9VGEudXNlckFnZW50O2lmKFVhKXtTYT1VYTticmVhayBhfX1TYT1cIlwifWZ1bmN0aW9uIFZhKGEpe3JldHVybi0xIT1TYS5pbmRleE9mKGEpfTt2YXIgV2E9VmEoXCJPcGVyYVwiKXx8VmEoXCJPUFJcIiksWGE9VmEoXCJUcmlkZW50XCIpfHxWYShcIk1TSUVcIiksWWE9VmEoXCJHZWNrb1wiKSYmLTE9PVNhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKSYmIShWYShcIlRyaWRlbnRcIil8fFZhKFwiTVNJRVwiKSksWmE9LTEhPVNhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKTsoZnVuY3Rpb24oKXt2YXIgYT1cIlwiLGI7aWYoV2EmJmFhLm9wZXJhKXJldHVybiBhPWFhLm9wZXJhLnZlcnNpb24saGEoYSk/YSgpOmE7WWE/Yj0vcnZcXDooW15cXCk7XSspKFxcKXw7KS86WGE/Yj0vXFxiKD86TVNJRXxydilbOiBdKFteXFwpO10rKShcXCl8OykvOlphJiYoYj0vV2ViS2l0XFwvKFxcUyspLyk7YiYmKGE9KGE9Yi5leGVjKFNhKSk/YVsxXTpcIlwiKTtyZXR1cm4gWGEmJihiPShiPWFhLmRvY3VtZW50KT9iLmRvY3VtZW50TW9kZTp2b2lkIDAsYj5wYXJzZUZsb2F0KGEpKT9TdHJpbmcoYik6YX0pKCk7dmFyICRhPW51bGwsYWI9bnVsbCxiYj1udWxsO2Z1bmN0aW9uIGNiKGEsYil7aWYoIWZhKGEpKXRocm93IEVycm9yKFwiZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyXCIpO2RiKCk7Zm9yKHZhciBjPWI/YWI6JGEsZD1bXSxlPTA7ZTxhLmxlbmd0aDtlKz0zKXt2YXIgZj1hW2VdLGc9ZSsxPGEubGVuZ3RoLGs9Zz9hW2UrMV06MCxsPWUrMjxhLmxlbmd0aCxuPWw/YVtlKzJdOjAsdT1mPj4yLGY9KGYmMyk8PDR8az4+NCxrPShrJjE1KTw8MnxuPj42LG49biY2MztsfHwobj02NCxnfHwoaz02NCkpO2QucHVzaChjW3VdLGNbZl0sY1trXSxjW25dKX1yZXR1cm4gZC5qb2luKFwiXCIpfVxuZnVuY3Rpb24gZGIoKXtpZighJGEpeyRhPXt9O2FiPXt9O2JiPXt9O2Zvcih2YXIgYT0wOzY1PmE7YSsrKSRhW2FdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSksYWJbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fLlwiLmNoYXJBdChhKSxiYlthYlthXV09YX19O3ZhciBlYj1mdW5jdGlvbigpe3ZhciBhPTE7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGErK319KCk7ZnVuY3Rpb24geShhLGIpe2lmKCFhKXRocm93IGZiKGIpO31mdW5jdGlvbiBmYihhKXtyZXR1cm4gRXJyb3IoXCJGaXJlYmFzZSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOlwiK2EpfVxuZnVuY3Rpb24gZ2IoYSl7dHJ5e3ZhciBiO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYXRvYiliPWF0b2IoYSk7ZWxzZXtkYigpO2Zvcih2YXIgYz1iYixkPVtdLGU9MDtlPGEubGVuZ3RoOyl7dmFyIGY9Y1thLmNoYXJBdChlKyspXSxnPWU8YS5sZW5ndGg/Y1thLmNoYXJBdChlKV06MDsrK2U7dmFyIGs9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTo2NDsrK2U7dmFyIGw9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTo2NDsrK2U7aWYobnVsbD09Znx8bnVsbD09Z3x8bnVsbD09a3x8bnVsbD09bCl0aHJvdyBFcnJvcigpO2QucHVzaChmPDwyfGc+PjQpOzY0IT1rJiYoZC5wdXNoKGc8PDQmMjQwfGs+PjIpLDY0IT1sJiZkLnB1c2goazw8NiYxOTJ8bCkpfWlmKDgxOTI+ZC5sZW5ndGgpYj1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZCk7ZWxzZXthPVwiXCI7Zm9yKGM9MDtjPGQubGVuZ3RoO2MrPTgxOTIpYSs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLFBhKGQsYyxcbmMrODE5MikpO2I9YX19cmV0dXJuIGJ9Y2F0Y2gobil7aGIoXCJiYXNlNjREZWNvZGUgZmFpbGVkOiBcIixuKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBpYihhKXt2YXIgYj1qYihhKTthPW5ldyBEYTthLnVwZGF0ZShiKTt2YXIgYj1bXSxjPTgqYS5UZDs1Nj5hLlNiP2EudXBkYXRlKGEuQWQsNTYtYS5TYik6YS51cGRhdGUoYS5BZCxhLlNhLShhLlNiLTU2KSk7Zm9yKHZhciBkPWEuU2EtMTs1Njw9ZDtkLS0pYS5iZVtkXT1jJjI1NSxjLz0yNTY7RWEoYSxhLmJlKTtmb3IoZD1jPTA7NT5kO2QrKylmb3IodmFyIGU9MjQ7MDw9ZTtlLT04KWJbY109YS5SW2RdPj5lJjI1NSwrK2M7cmV0dXJuIGNiKGIpfVxuZnVuY3Rpb24ga2IoYSl7Zm9yKHZhciBiPVwiXCIsYz0wO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYj1mYShhcmd1bWVudHNbY10pP2Ira2IuYXBwbHkobnVsbCxhcmd1bWVudHNbY10pOlwib2JqZWN0XCI9PT10eXBlb2YgYXJndW1lbnRzW2NdP2Ircihhcmd1bWVudHNbY10pOmIrYXJndW1lbnRzW2NdLGIrPVwiIFwiO3JldHVybiBifXZhciBsYj1udWxsLG1iPSEwO2Z1bmN0aW9uIGhiKGEpeyEwPT09bWImJihtYj0hMSxudWxsPT09bGImJiEwPT09di5nZXQoXCJsb2dnaW5nX2VuYWJsZWRcIikmJm5iKCEwKSk7aWYobGIpe3ZhciBiPWtiLmFwcGx5KG51bGwsYXJndW1lbnRzKTtsYihiKX19ZnVuY3Rpb24gb2IoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7aGIoYSxhcmd1bWVudHMpfX1cbmZ1bmN0aW9uIHBiKGEpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIGI9XCJGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogXCIra2IuYXBwbHkobnVsbCxhcmd1bWVudHMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZS5lcnJvcj9jb25zb2xlLmVycm9yKGIpOmNvbnNvbGUubG9nKGIpfX1mdW5jdGlvbiBxYihhKXt2YXIgYj1rYi5hcHBseShudWxsLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoXCJGSVJFQkFTRSBGQVRBTCBFUlJPUjogXCIrYik7fWZ1bmN0aW9uIHooYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXt2YXIgYj1cIkZJUkVCQVNFIFdBUk5JTkc6IFwiK2tiLmFwcGx5KG51bGwsYXJndW1lbnRzKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUud2Fybj9jb25zb2xlLndhcm4oYik6Y29uc29sZS5sb2coYil9fVxuZnVuY3Rpb24gcmIoYSl7dmFyIGI9XCJcIixjPVwiXCIsZD1cIlwiLGU9XCJcIixmPSEwLGc9XCJodHRwc1wiLGs9NDQzO2lmKHAoYSkpe3ZhciBsPWEuaW5kZXhPZihcIi8vXCIpOzA8PWwmJihnPWEuc3Vic3RyaW5nKDAsbC0xKSxhPWEuc3Vic3RyaW5nKGwrMikpO2w9YS5pbmRleE9mKFwiL1wiKTstMT09PWwmJihsPWEubGVuZ3RoKTtiPWEuc3Vic3RyaW5nKDAsbCk7ZT1cIlwiO2E9YS5zdWJzdHJpbmcobCkuc3BsaXQoXCIvXCIpO2ZvcihsPTA7bDxhLmxlbmd0aDtsKyspaWYoMDxhW2xdLmxlbmd0aCl7dmFyIG49YVtsXTt0cnl7bj1kZWNvZGVVUklDb21wb25lbnQobi5yZXBsYWNlKC9cXCsvZyxcIiBcIikpfWNhdGNoKHUpe31lKz1cIi9cIitufWE9Yi5zcGxpdChcIi5cIik7Mz09PWEubGVuZ3RoPyhjPWFbMV0sZD1hWzBdLnRvTG93ZXJDYXNlKCkpOjI9PT1hLmxlbmd0aCYmKGM9YVswXSk7bD1iLmluZGV4T2YoXCI6XCIpOzA8PWwmJihmPVwiaHR0cHNcIj09PWd8fFwid3NzXCI9PT1nLGs9Yi5zdWJzdHJpbmcobCsxKSxpc0Zpbml0ZShrKSYmXG4oaz1TdHJpbmcoaykpLGs9cChrKT8vXlxccyotPzB4L2kudGVzdChrKT9wYXJzZUludChrLDE2KTpwYXJzZUludChrLDEwKTpOYU4pfXJldHVybntob3N0OmIscG9ydDprLGRvbWFpbjpjLEFnOmQsQWI6ZixzY2hlbWU6ZyxQYzplfX1mdW5jdGlvbiBzYihhKXtyZXR1cm4gZ2EoYSkmJihhIT1hfHxhPT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl8fGE9PU51bWJlci5ORUdBVElWRV9JTkZJTklUWSl9XG5mdW5jdGlvbiB0YihhKXtpZihcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlKWEoKTtlbHNle3ZhciBiPSExLGM9ZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5P2J8fChiPSEwLGEoKSk6c2V0VGltZW91dChjLE1hdGguZmxvb3IoMTApKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcj8oZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixjLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixjLCExKSk6ZG9jdW1lbnQuYXR0YWNoRXZlbnQmJihkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmYygpfSksd2luZG93LmF0dGFjaEV2ZW50KFwib25sb2FkXCIsYykpfX1cbmZ1bmN0aW9uIHViKGEsYil7aWYoYT09PWIpcmV0dXJuIDA7aWYoXCJbTUlOX05BTUVdXCI9PT1hfHxcIltNQVhfTkFNRV1cIj09PWIpcmV0dXJuLTE7aWYoXCJbTUlOX05BTUVdXCI9PT1ifHxcIltNQVhfTkFNRV1cIj09PWEpcmV0dXJuIDE7dmFyIGM9dmIoYSksZD12YihiKTtyZXR1cm4gbnVsbCE9PWM/bnVsbCE9PWQ/MD09Yy1kP2EubGVuZ3RoLWIubGVuZ3RoOmMtZDotMTpudWxsIT09ZD8xOmE8Yj8tMToxfWZ1bmN0aW9uIHdiKGEsYil7aWYoYiYmYSBpbiBiKXJldHVybiBiW2FdO3Rocm93IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBrZXkgKFwiK2ErXCIpIGluIG9iamVjdDogXCIrcihiKSk7fVxuZnVuY3Rpb24geGIoYSl7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhfHxudWxsPT09YSlyZXR1cm4gcihhKTt2YXIgYj1bXSxjO2ZvcihjIGluIGEpYi5wdXNoKGMpO2Iuc29ydCgpO2M9XCJ7XCI7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspMCE9PWQmJihjKz1cIixcIiksYys9cihiW2RdKSxjKz1cIjpcIixjKz14YihhW2JbZF1dKTtyZXR1cm4gYytcIn1cIn1mdW5jdGlvbiB5YihhLGIpe2lmKGEubGVuZ3RoPD1iKXJldHVyblthXTtmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCs9YilkK2I+YT9jLnB1c2goYS5zdWJzdHJpbmcoZCxhLmxlbmd0aCkpOmMucHVzaChhLnN1YnN0cmluZyhkLGQrYikpO3JldHVybiBjfWZ1bmN0aW9uIHpiKGEsYil7aWYoZWEoYSkpZm9yKHZhciBjPTA7YzxhLmxlbmd0aDsrK2MpYihjLGFbY10pO2Vsc2UgQShhLGIpfVxuZnVuY3Rpb24gQWIoYSl7eSghc2IoYSksXCJJbnZhbGlkIEpTT04gbnVtYmVyXCIpO3ZhciBiLGMsZCxlOzA9PT1hPyhkPWM9MCxiPS1JbmZpbml0eT09PTEvYT8xOjApOihiPTA+YSxhPU1hdGguYWJzKGEpLGE+PU1hdGgucG93KDIsLTEwMjIpPyhkPU1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2coYSkvTWF0aC5MTjIpLDEwMjMpLGM9ZCsxMDIzLGQ9TWF0aC5yb3VuZChhKk1hdGgucG93KDIsNTItZCktTWF0aC5wb3coMiw1MikpKTooYz0wLGQ9TWF0aC5yb3VuZChhL01hdGgucG93KDIsLTEwNzQpKSkpO2U9W107Zm9yKGE9NTI7YTthLT0xKWUucHVzaChkJTI/MTowKSxkPU1hdGguZmxvb3IoZC8yKTtmb3IoYT0xMTthO2EtPTEpZS5wdXNoKGMlMj8xOjApLGM9TWF0aC5mbG9vcihjLzIpO2UucHVzaChiPzE6MCk7ZS5yZXZlcnNlKCk7Yj1lLmpvaW4oXCJcIik7Yz1cIlwiO2ZvcihhPTA7NjQ+YTthKz04KWQ9cGFyc2VJbnQoYi5zdWJzdHIoYSw4KSwyKS50b1N0cmluZygxNiksMT09PWQubGVuZ3RoJiZcbihkPVwiMFwiK2QpLGMrPWQ7cmV0dXJuIGMudG9Mb3dlckNhc2UoKX12YXIgQmI9L14tP1xcZHsxLDEwfSQvO2Z1bmN0aW9uIHZiKGEpe3JldHVybiBCYi50ZXN0KGEpJiYoYT1OdW1iZXIoYSksLTIxNDc0ODM2NDg8PWEmJjIxNDc0ODM2NDc+PWEpP2E6bnVsbH1mdW5jdGlvbiBDYihhKXt0cnl7YSgpfWNhdGNoKGIpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt6KFwiRXhjZXB0aW9uIHdhcyB0aHJvd24gYnkgdXNlciBjYWxsYmFjay5cIixiLnN0YWNrfHxcIlwiKTt0aHJvdyBiO30sTWF0aC5mbG9vcigwKSl9fWZ1bmN0aW9uIEIoYSxiKXtpZihoYShhKSl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLnNsaWNlKCk7Q2IoZnVuY3Rpb24oKXthLmFwcGx5KG51bGwsYyl9KX19O2Z1bmN0aW9uIERiKGEsYixjLGQpe3RoaXMubGU9Yjt0aGlzLk5kPWM7dGhpcy5GZD1kO3RoaXMuamQ9YX1EYi5wcm90b3R5cGUuUWI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLk5kLmNjKCk7cmV0dXJuXCJ2YWx1ZVwiPT09dGhpcy5qZD9hLnBhdGg6YS5wYXJlbnQoKS5wYXRofTtEYi5wcm90b3R5cGUucGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5qZH07RGIucHJvdG90eXBlLkxiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGUuTGIodGhpcyl9O0RiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLlFiKCkudG9TdHJpbmcoKStcIjpcIit0aGlzLmpkK1wiOlwiK3IodGhpcy5OZC5iZigpKX07ZnVuY3Rpb24gRWIoYSxiLGMpe3RoaXMubGU9YTt0aGlzLmVycm9yPWI7dGhpcy5wYXRoPWN9RWIucHJvdG90eXBlLlFiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aH07RWIucHJvdG90eXBlLnBlPWZ1bmN0aW9uKCl7cmV0dXJuXCJjYW5jZWxcIn07XG5FYi5wcm90b3R5cGUuTGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZS5MYih0aGlzKX07RWIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpK1wiOmNhbmNlbFwifTtmdW5jdGlvbiBDKGEsYixjLGQpe3RoaXMudHlwZT1hO3RoaXMuSGE9Yjt0aGlzLlVhPWM7dGhpcy5EZT1kO3RoaXMuRmQ9dm9pZCAwfWZ1bmN0aW9uIEZiKGEpe3JldHVybiBuZXcgQyhHYixhKX12YXIgR2I9XCJ2YWx1ZVwiO2Z1bmN0aW9uIEhiKGEsYixjKXt0aGlzLkhiPWE7dGhpcy5rYj1iO3RoaXMubWI9Y3x8bnVsbH1oPUhiLnByb3RvdHlwZTtoLndmPWZ1bmN0aW9uKGEpe3JldHVyblwidmFsdWVcIj09PWF9O2guY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLm4uZztyZXR1cm4gbmV3IERiKFwidmFsdWVcIix0aGlzLG5ldyBEKGEuSGEsYi5jYygpLGMpKX07aC5MYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm1iO2lmKFwiY2FuY2VsXCI9PT1hLnBlKCkpe3kodGhpcy5rYixcIlJhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFja1wiKTt2YXIgYz10aGlzLmtiO3JldHVybiBmdW5jdGlvbigpe2MuY2FsbChiLGEuZXJyb3IpfX12YXIgZD10aGlzLkhiO3JldHVybiBmdW5jdGlvbigpe2QuY2FsbChiLGEuTmQpfX07aC5ZZT1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmtiP25ldyBFYih0aGlzLGEsYik6bnVsbH07XG5oLm1hdGNoZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBIYj9hLkhiJiZ0aGlzLkhiP2EuSGI9PT10aGlzLkhiJiZhLm1iPT09dGhpcy5tYjohMDohMX07aC5oZj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5IYn07ZnVuY3Rpb24gSWIoYSxiLGMpe3RoaXMuZGE9YTt0aGlzLmtiPWI7dGhpcy5tYj1jfWg9SWIucHJvdG90eXBlO2gud2Y9ZnVuY3Rpb24oYSl7YT1cImNoaWxkcmVuX2FkZGVkXCI9PT1hP1wiY2hpbGRfYWRkZWRcIjphO3JldHVybihcImNoaWxkcmVuX3JlbW92ZWRcIj09PWE/XCJjaGlsZF9yZW1vdmVkXCI6YSlpbiB0aGlzLmRhfTtoLlllPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMua2I/bmV3IEViKHRoaXMsYSxiKTpudWxsfTtcbmguY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oYSxiKXt5KG51bGwhPWEuVWEsXCJDaGlsZCBldmVudHMgc2hvdWxkIGhhdmUgYSBjaGlsZE5hbWUuXCIpO3ZhciBjPWIuY2MoKS5vKGEuVWEpO3JldHVybiBuZXcgRGIoYS50eXBlLHRoaXMsbmV3IEQoYS5IYSxjLGIubi5nKSxhLkZkKX07aC5MYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm1iO2lmKFwiY2FuY2VsXCI9PT1hLnBlKCkpe3kodGhpcy5rYixcIlJhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFja1wiKTt2YXIgYz10aGlzLmtiO3JldHVybiBmdW5jdGlvbigpe2MuY2FsbChiLGEuZXJyb3IpfX12YXIgZD10aGlzLmRhW2EuamRdO3JldHVybiBmdW5jdGlvbigpe2QuY2FsbChiLGEuTmQsYS5GZCl9fTtcbmgubWF0Y2hlcz1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgSWIpe2lmKCF0aGlzLmRhfHwhYS5kYSlyZXR1cm4hMDtpZih0aGlzLm1iPT09YS5tYil7dmFyIGI9SmIoYS5kYSk7aWYoYj09PUpiKHRoaXMuZGEpKXtpZigxPT09Yil7dmFyIGI9S2IoYS5kYSksYz1LYih0aGlzLmRhKTtyZXR1cm4gYz09PWImJighYS5kYVtiXXx8IXRoaXMuZGFbY118fGEuZGFbYl09PT10aGlzLmRhW2NdKX1yZXR1cm4gTGIodGhpcy5kYSxmdW5jdGlvbihiLGMpe3JldHVybiBhLmRhW2NdPT09Yn0pfX19cmV0dXJuITF9O2guaGY9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuZGF9O2Z1bmN0aW9uIGpiKGEpe2Zvcih2YXIgYj1bXSxjPTAsZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hLmNoYXJDb2RlQXQoZCk7NTUyOTY8PWUmJjU2MzE5Pj1lJiYoZS09NTUyOTYsZCsrLHkoZDxhLmxlbmd0aCxcIlN1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLlwiKSxlPTY1NTM2KyhlPDwxMCkrKGEuY2hhckNvZGVBdChkKS01NjMyMCkpOzEyOD5lP2JbYysrXT1lOigyMDQ4PmU/YltjKytdPWU+PjZ8MTkyOig2NTUzNj5lP2JbYysrXT1lPj4xMnwyMjQ6KGJbYysrXT1lPj4xOHwyNDAsYltjKytdPWU+PjEyJjYzfDEyOCksYltjKytdPWU+PjYmNjN8MTI4KSxiW2MrK109ZSY2M3wxMjgpfXJldHVybiBifTtmdW5jdGlvbiBGKGEsYixjLGQpe3ZhciBlO2Q8Yj9lPVwiYXQgbGVhc3QgXCIrYjpkPmMmJihlPTA9PT1jP1wibm9uZVwiOlwibm8gbW9yZSB0aGFuIFwiK2MpO2lmKGUpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCBcIitkKygxPT09ZD9cIiBhcmd1bWVudC5cIjpcIiBhcmd1bWVudHMuXCIpK1wiIEV4cGVjdHMgXCIrZStcIi5cIik7fWZ1bmN0aW9uIEcoYSxiLGMpe3ZhciBkPVwiXCI7c3dpdGNoKGIpe2Nhc2UgMTpkPWM/XCJmaXJzdFwiOlwiRmlyc3RcIjticmVhaztjYXNlIDI6ZD1jP1wic2Vjb25kXCI6XCJTZWNvbmRcIjticmVhaztjYXNlIDM6ZD1jP1widGhpcmRcIjpcIlRoaXJkXCI7YnJlYWs7Y2FzZSA0OmQ9Yz9cImZvdXJ0aFwiOlwiRm91cnRoXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImVycm9yUHJlZml4IGNhbGxlZCB3aXRoIGFyZ3VtZW50TnVtYmVyID4gNC4gIE5lZWQgdG8gdXBkYXRlIGl0P1wiKTt9cmV0dXJuIGE9YStcIiBmYWlsZWQ6IFwiKyhkK1wiIGFyZ3VtZW50IFwiKX1cbmZ1bmN0aW9uIEgoYSxiLGMsZCl7aWYoKCFkfHxtKGMpKSYmIWhhKGMpKXRocm93IEVycm9yKEcoYSxiLGQpK1wibXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLlwiKTt9ZnVuY3Rpb24gTWIoYSxiLGMpe2lmKG0oYykmJighaWEoYyl8fG51bGw9PT1jKSl0aHJvdyBFcnJvcihHKGEsYiwhMCkrXCJtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuXCIpO307dmFyIE5iPS9bXFxbXFxdLiMkXFwvXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vLE9iPS9bXFxbXFxdLiMkXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vO2Z1bmN0aW9uIFBiKGEpe3JldHVybiBwKGEpJiYwIT09YS5sZW5ndGgmJiFOYi50ZXN0KGEpfWZ1bmN0aW9uIFFiKGEpe3JldHVybiBudWxsPT09YXx8cChhKXx8Z2EoYSkmJiFzYihhKXx8aWEoYSkmJnMoYSxcIi5zdlwiKX1mdW5jdGlvbiBSYihhLGIsYyl7YyYmIW0oYil8fFNiKEcoYSwxLGMpLGIpfVxuZnVuY3Rpb24gU2IoYSxiLGMsZCl7Y3x8KGM9MCk7dmFyIGU9ZHx8W107aWYoIW0oYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIHVuZGVmaW5lZFwiK1RiKGUpKTtpZihoYShiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgYSBmdW5jdGlvblwiK1RiKGUpK1wiIHdpdGggY29udGVudHM6IFwiK2IudG9TdHJpbmcoKSk7aWYoc2IoYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIFwiK2IudG9TdHJpbmcoKStUYihlKSk7aWYoMUUzPGMpdGhyb3cgbmV3IFR5cGVFcnJvcihhK1wiY29udGFpbnMgYSBjeWNsaWMgb2JqZWN0IHZhbHVlIChcIitlLnNsaWNlKDAsMTAwKS5qb2luKFwiLlwiKStcIi4uLilcIik7aWYocChiKSYmYi5sZW5ndGg+MTA0ODU3NjAvMyYmMTA0ODU3NjA8amIoYikubGVuZ3RoKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gMTA0ODU3NjAgdXRmOCBieXRlc1wiK1RiKGUpK1wiICgnXCIrYi5zdWJzdHJpbmcoMCw1MCkrXCIuLi4nKVwiKTtpZihpYShiKSl7dmFyIGY9XG4hMSxnPSExO3VhKGIsZnVuY3Rpb24oYixkKXtpZihcIi52YWx1ZVwiPT09YilmPSEwO2Vsc2UgaWYoXCIucHJpb3JpdHlcIiE9PWImJlwiLnN2XCIhPT1iJiYoZz0hMCwhUGIoYikpKXRocm93IEVycm9yKGErXCIgY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKFwiK2IrXCIpXCIrVGIoZSkrJy4gIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTtlLnB1c2goYik7U2IoYSxkLGMrMSxlKTtlLnBvcCgpfSk7aWYoZiYmZyl0aHJvdyBFcnJvcihhKycgY29udGFpbnMgXCIudmFsdWVcIiBjaGlsZCcrVGIoZSkrXCIgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLlwiKTt9fWZ1bmN0aW9uIFRiKGEpe3JldHVybiAwPT1hLmxlbmd0aD9cIlwiOlwiIGluIHByb3BlcnR5ICdcIithLmpvaW4oXCIuXCIpK1wiJ1wifVxuZnVuY3Rpb24gVWIoYSxiKXtpZighaWEoYil8fGVhKGIpKXRocm93IEVycm9yKEcoYSwxLCExKStcIiBtdXN0IGJlIGFuIE9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLlwiKTtpZihzKGIsXCIudmFsdWVcIikpdGhyb3cgRXJyb3IoRyhhLDEsITEpKycgbXVzdCBub3QgY29udGFpbiBcIi52YWx1ZVwiLiAgVG8gb3ZlcndyaXRlIHdpdGggYSBsZWFmIHZhbHVlLCBqdXN0IHVzZSAuc2V0KCkgaW5zdGVhZC4nKTtSYihhLGIsITEpfVxuZnVuY3Rpb24gVmIoYSxiLGMpe2lmKHNiKGMpKXRocm93IEVycm9yKEcoYSxiLCExKStcImlzIFwiK2MudG9TdHJpbmcoKStcIiwgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO2lmKCFRYihjKSl0aHJvdyBFcnJvcihHKGEsYiwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLlwiKTt9XG5mdW5jdGlvbiBXYihhLGIsYyl7aWYoIWN8fG0oYikpc3dpdGNoKGIpe2Nhc2UgXCJ2YWx1ZVwiOmNhc2UgXCJjaGlsZF9hZGRlZFwiOmNhc2UgXCJjaGlsZF9yZW1vdmVkXCI6Y2FzZSBcImNoaWxkX2NoYW5nZWRcIjpjYXNlIFwiY2hpbGRfbW92ZWRcIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKEcoYSwxLGMpKydtdXN0IGJlIGEgdmFsaWQgZXZlbnQgdHlwZTogXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCBcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLicpO319ZnVuY3Rpb24gWGIoYSxiLGMsZCl7aWYoKCFkfHxtKGMpKSYmIVBiKGMpKXRocm93IEVycm9yKEcoYSxiLGQpKyd3YXMgYW4gaW52YWxpZCBrZXk6IFwiJytjKydcIi4gIEZpcmViYXNlIGtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO31cbmZ1bmN0aW9uIFliKGEsYil7aWYoIXAoYil8fDA9PT1iLmxlbmd0aHx8T2IudGVzdChiKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJ3dhcyBhbiBpbnZhbGlkIHBhdGg6IFwiJytiKydcIi4gUGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO31mdW5jdGlvbiBaYihhLGIpe2lmKFwiLmluZm9cIj09PUkoYikpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IENhbid0IG1vZGlmeSBkYXRhIHVuZGVyIC8uaW5mby9cIik7fWZ1bmN0aW9uICRiKGEsYil7aWYoIXAoYikpdGhyb3cgRXJyb3IoRyhhLDEsITEpK1wibXVzdCBiZSBhIHZhbGlkIGNyZWRlbnRpYWwgKGEgc3RyaW5nKS5cIik7fWZ1bmN0aW9uIGFjKGEsYixjKXtpZighcChjKSl0aHJvdyBFcnJvcihHKGEsYiwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLlwiKTt9XG5mdW5jdGlvbiBKKGEsYixjLGQpe2lmKCFkfHxtKGMpKWlmKCFpYShjKXx8bnVsbD09PWMpdGhyb3cgRXJyb3IoRyhhLGIsZCkrXCJtdXN0IGJlIGEgdmFsaWQgb2JqZWN0LlwiKTt9ZnVuY3Rpb24gSyhhLGIsYyl7aWYoIWlhKGIpfHxudWxsPT09Ynx8IXMoYixjKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJ211c3QgY29udGFpbiB0aGUga2V5IFwiJytjKydcIicpO2lmKCFwKHQoYixjKSkpdGhyb3cgRXJyb3IoRyhhLDEsITEpKydtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicrYysnXCIgd2l0aCB0eXBlIFwic3RyaW5nXCInKTt9O2Z1bmN0aW9uIGJjKGEpe3RoaXMuZz1hfWg9YmMucHJvdG90eXBlO2guQz1mdW5jdGlvbihhLGIsYyxkLGUpe3koYS5CYyh0aGlzLmcpLFwiQSBub2RlIG11c3QgYmUgaW5kZXhlZCBpZiBvbmx5IGEgY2hpbGQgaXMgdXBkYXRlZFwiKTtkPWEuSyhiKTtpZihkLmVhKGMpKXJldHVybiBhO251bGwhPWUmJihjLmUoKT9hLkRhKGIpP2NjKGUsbmV3IEMoXCJjaGlsZF9yZW1vdmVkXCIsZCxiKSk6eShhLk0oKSxcIkEgY2hpbGQgcmVtb3ZlIHdpdGhvdXQgYW4gb2xkIGNoaWxkIG9ubHkgbWFrZXMgc2Vuc2Ugb24gYSBsZWFmIG5vZGVcIik6ZC5lKCk/Y2MoZSxuZXcgQyhcImNoaWxkX2FkZGVkXCIsYyxiKSk6Y2MoZSxuZXcgQyhcImNoaWxkX2NoYW5nZWRcIixjLGIsZCkpKTtyZXR1cm4gYS5NKCkmJmMuZSgpP2E6YS5QKGIsYyl9O1xuaC5vYT1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YyYmKGEuTSgpfHxhLlUoTCxmdW5jdGlvbihhLGUpe2IuRGEoYSl8fGNjKGMsbmV3IEMoXCJjaGlsZF9yZW1vdmVkXCIsZSxhKSl9KSxiLk0oKXx8Yi5VKEwsZnVuY3Rpb24oYixlKXtpZihhLkRhKGIpKXt2YXIgZj1hLksoYik7Zi5lYShlKXx8Y2MoYyxuZXcgQyhcImNoaWxkX2NoYW5nZWRcIixlLGIsZikpfWVsc2UgY2MoYyxuZXcgQyhcImNoaWxkX2FkZGVkXCIsZSxiKSl9KSk7cmV0dXJuIGIuRmIodGhpcy5nKX07aC5aPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZSgpP006YS5aKGIpfTtoLnlhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guTWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307ZnVuY3Rpb24gZGMoYSl7dGhpcy5yZT1uZXcgYmMoYS5nKTt0aGlzLmc9YS5nO3ZhciBiO2EuaWE/KGI9ZWMoYSksYj1hLmcuQWUoZmMoYSksYikpOmI9YS5nLkNlKCk7dGhpcy5WYz1iO2EucWE/KGI9Z2MoYSksYT1hLmcuQWUoaGMoYSksYikpOmE9YS5nLkJlKCk7dGhpcy53Yz1hfWg9ZGMucHJvdG90eXBlO2gubWF0Y2hlcz1mdW5jdGlvbihhKXtyZXR1cm4gMD49dGhpcy5nLmNvbXBhcmUodGhpcy5WYyxhKSYmMD49dGhpcy5nLmNvbXBhcmUoYSx0aGlzLndjKX07aC5DPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5tYXRjaGVzKG5ldyBOKGIsYykpfHwoYz1NKTtyZXR1cm4gdGhpcy5yZS5DKGEsYixjLGQsZSl9O2gub2E9ZnVuY3Rpb24oYSxiLGMpe2IuTSgpJiYoYj1NKTt2YXIgZD1iLkZiKHRoaXMuZyksZD1kLlooTSksZT10aGlzO2IuVShMLGZ1bmN0aW9uKGEsYil7ZS5tYXRjaGVzKG5ldyBOKGEsYikpfHwoZD1kLlAoYSxNKSl9KTtyZXR1cm4gdGhpcy5yZS5vYShhLGQsYyl9O1xuaC5aPWZ1bmN0aW9uKGEpe3JldHVybiBhfTtoLnlhPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guTWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZX07ZnVuY3Rpb24gaWMoYSxiKXtyZXR1cm4gdWIoYS5uYW1lLGIubmFtZSl9ZnVuY3Rpb24gamMoYSxiKXtyZXR1cm4gdWIoYSxiKX07ZnVuY3Rpb24ga2MoKXt9dmFyIGxjPXt9O2Z1bmN0aW9uIG1jKGEpe3JldHVybiBxKGEuY29tcGFyZSxhKX1rYy5wcm90b3R5cGUuamY9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMCE9PXRoaXMuY29tcGFyZShuZXcgTihcIltNSU5fTkFNRV1cIixhKSxuZXcgTihcIltNSU5fTkFNRV1cIixiKSl9O2tjLnByb3RvdHlwZS5DZT1mdW5jdGlvbigpe3JldHVybiBuY307ZnVuY3Rpb24gb2MoYSl7dGhpcy5VYj1hfW1hKG9jLGtjKTtoPW9jLnByb3RvdHlwZTtoLnVlPWZ1bmN0aW9uKGEpe3JldHVybiFhLksodGhpcy5VYikuZSgpfTtoLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLlkuSyh0aGlzLlViKSxkPWIuWS5LKHRoaXMuVWIpLGM9Yy5oZShkKTtyZXR1cm4gMD09PWM/dWIoYS5uYW1lLGIubmFtZSk6Y307aC5BZT1mdW5jdGlvbihhLGIpe3ZhciBjPU8oYSksYz1NLlAodGhpcy5VYixjKTtyZXR1cm4gbmV3IE4oYixjKX07XG5oLkJlPWZ1bmN0aW9uKCl7dmFyIGE9TS5QKHRoaXMuVWIscGMpO3JldHVybiBuZXcgTihcIltNQVhfTkFNRV1cIixhKX07aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLlVifTt2YXIgTD1uZXcgb2MoXCIucHJpb3JpdHlcIik7ZnVuY3Rpb24gcWMoKXt9bWEocWMsa2MpO2g9cWMucHJvdG90eXBlO2guY29tcGFyZT1mdW5jdGlvbihhLGIpe3JldHVybiB1YihhLm5hbWUsYi5uYW1lKX07aC51ZT1mdW5jdGlvbigpe3Rocm93IGZiKFwiS2V5SW5kZXguaXNEZWZpbmVkT24gbm90IGV4cGVjdGVkIHRvIGJlIGNhbGxlZC5cIik7fTtoLmpmPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guQ2U9ZnVuY3Rpb24oKXtyZXR1cm4gbmN9O2guQmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE4oXCJbTUFYX05BTUVdXCIsTSl9O2guQWU9ZnVuY3Rpb24oYSl7eShwKGEpLFwiS2V5SW5kZXggaW5kZXhWYWx1ZSBtdXN0IGFsd2F5cyBiZSBhIHN0cmluZy5cIik7cmV0dXJuIG5ldyBOKGEsTSl9O1xuaC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLmtleVwifTt2YXIgcmM9bmV3IHFjO2Z1bmN0aW9uIHNjKCl7fXNjLnByb3RvdHlwZS5lZj1mdW5jdGlvbigpe3JldHVybiBudWxsfTtzYy5wcm90b3R5cGUub2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07dmFyIHRjPW5ldyBzYztmdW5jdGlvbiB1YyhhLGIsYyl7dGhpcy5CZj1hO3RoaXMuSWE9Yjt0aGlzLnpkPWN9dWMucHJvdG90eXBlLmVmPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuSWEuRjtpZih2YyhiLGEpKXJldHVybiBiLmooKS5LKGEpO2I9bnVsbCE9dGhpcy56ZD9uZXcgd2ModGhpcy56ZCwhMCwhMSk6dGhpcy5JYS51KCk7cmV0dXJuIHRoaXMuQmYuVGEoYSxiKX07dWMucHJvdG90eXBlLm9lPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1udWxsIT10aGlzLnpkP3RoaXMuemQ6eGModGhpcy5JYSk7YT10aGlzLkJmLmNlKGQsYiwxLGMsYSk7cmV0dXJuIDA9PT1hLmxlbmd0aD9udWxsOmFbMF19O2Z1bmN0aW9uIHljKCl7dGhpcy5aYT17fX1cbmZ1bmN0aW9uIGNjKGEsYil7dmFyIGM9Yi50eXBlLGQ9Yi5VYTt5KFwiY2hpbGRfYWRkZWRcIj09Y3x8XCJjaGlsZF9jaGFuZ2VkXCI9PWN8fFwiY2hpbGRfcmVtb3ZlZFwiPT1jLFwiT25seSBjaGlsZCBjaGFuZ2VzIHN1cHBvcnRlZCBmb3IgdHJhY2tpbmdcIik7eShcIi5wcmlvcml0eVwiIT09ZCxcIk9ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuXCIpO3ZhciBlPXQoYS5aYSxkKTtpZihlKXt2YXIgZj1lLnR5cGU7aWYoXCJjaGlsZF9hZGRlZFwiPT1jJiZcImNoaWxkX3JlbW92ZWRcIj09ZilhLlphW2RdPW5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGIuSGEsZCxlLkhhKTtlbHNlIGlmKFwiY2hpbGRfcmVtb3ZlZFwiPT1jJiZcImNoaWxkX2FkZGVkXCI9PWYpZGVsZXRlIGEuWmFbZF07ZWxzZSBpZihcImNoaWxkX3JlbW92ZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5aYVtkXT1uZXcgQyhcImNoaWxkX3JlbW92ZWRcIixlLkRlLGQpO2Vsc2UgaWYoXCJjaGlsZF9jaGFuZ2VkXCI9PWMmJlxuXCJjaGlsZF9hZGRlZFwiPT1mKWEuWmFbZF09bmV3IEMoXCJjaGlsZF9hZGRlZFwiLGIuSGEsZCk7ZWxzZSBpZihcImNoaWxkX2NoYW5nZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5aYVtkXT1uZXcgQyhcImNoaWxkX2NoYW5nZWRcIixiLkhhLGQsZS5EZSk7ZWxzZSB0aHJvdyBmYihcIklsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogXCIrYitcIiBvY2N1cnJlZCBhZnRlciBcIitlKTt9ZWxzZSBhLlphW2RdPWJ9O2Z1bmN0aW9uIE4oYSxiKXt0aGlzLm5hbWU9YTt0aGlzLlk9Yn1mdW5jdGlvbiB6YyhhLGIpe3JldHVybiBuZXcgTihhLGIpfTtmdW5jdGlvbiBBYyhhKXt0aGlzLm1hPW5ldyBkYyhhKTt0aGlzLmc9YS5nO3koYS5rYSxcIk9ubHkgdmFsaWQgaWYgbGltaXQgaGFzIGJlZW4gc2V0XCIpO3RoaXMuc2E9YS5zYTt0aGlzLnpiPSEoXCJcIj09PWEuRWI/YS5pYTpcImxcIj09PWEuRWIpfWg9QWMucHJvdG90eXBlO2guQz1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMubWEubWF0Y2hlcyhuZXcgTihiLGMpKXx8KGM9TSk7cmV0dXJuIGEuSyhiKS5lYShjKT9hOmEudWIoKTx0aGlzLnNhP3RoaXMubWEuTWIoKS5DKGEsYixjLGQsZSk6QmModGhpcyxhLGIsYyxkLGUpfTtcbmgub2E9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2lmKGIuTSgpfHxiLmUoKSlkPU0uRmIodGhpcy5nKTtlbHNlIGlmKDIqdGhpcy5zYTxiLnViKCkmJmIuQmModGhpcy5nKSl7ZD1NLkZiKHRoaXMuZyk7Yj10aGlzLnpiP2IuUmIodGhpcy5tYS53Yyx0aGlzLmcpOmIuUGIodGhpcy5tYS5WYyx0aGlzLmcpO2Zvcih2YXIgZT0wOzA8Yi5OYS5sZW5ndGgmJmU8dGhpcy5zYTspe3ZhciBmPVAoYiksZztpZihnPXRoaXMuemI/MD49dGhpcy5nLmNvbXBhcmUodGhpcy5tYS5WYyxmKTowPj10aGlzLmcuY29tcGFyZShmLHRoaXMubWEud2MpKWQ9ZC5QKGYubmFtZSxmLlkpLGUrKztlbHNlIGJyZWFrfX1lbHNle2Q9Yi5GYih0aGlzLmcpO2Q9ZC5aKE0pO3ZhciBrLGwsbjtpZih0aGlzLnpiKXtiPWQuZ2YodGhpcy5nKTtrPXRoaXMubWEud2M7bD10aGlzLm1hLlZjO3ZhciB1PW1jKHRoaXMuZyk7bj1mdW5jdGlvbihhLGIpe3JldHVybiB1KGIsYSl9fWVsc2UgYj1kLk9iKHRoaXMuZyksaz10aGlzLm1hLlZjLFxubD10aGlzLm1hLndjLG49bWModGhpcy5nKTtmb3IodmFyIGU9MCx4PSExOzA8Yi5OYS5sZW5ndGg7KWY9UChiKSwheCYmMD49bihrLGYpJiYoeD0hMCksKGc9eCYmZTx0aGlzLnNhJiYwPj1uKGYsbCkpP2UrKzpkPWQuUChmLm5hbWUsTSl9cmV0dXJuIHRoaXMubWEuTWIoKS5vYShhLGQsYyl9O2guWj1mdW5jdGlvbihhKXtyZXR1cm4gYX07aC55YT1mdW5jdGlvbigpe3JldHVybiEwfTtoLk1iPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWEuTWIoKX07XG5mdW5jdGlvbiBCYyhhLGIsYyxkLGUsZil7dmFyIGc7aWYoYS56Yil7dmFyIGs9bWMoYS5nKTtnPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGsoYixhKX19ZWxzZSBnPW1jKGEuZyk7eShiLnViKCk9PWEuc2EsXCJcIik7dmFyIGw9bmV3IE4oYyxkKSxuPWEuemI/Q2MoYixhLmcpOkRjKGIsYS5nKSx1PWEubWEubWF0Y2hlcyhsKTtpZihiLkRhKGMpKXt2YXIgeD1iLksoYyksbj1lLm9lKGEuZyxuLGEuemIpO251bGwhPW4mJm4ubmFtZT09YyYmKG49ZS5vZShhLmcsbixhLnpiKSk7ZT1udWxsPT1uPzE6ZyhuLGwpO2lmKHUmJiFkLmUoKSYmMDw9ZSlyZXR1cm4gbnVsbCE9ZiYmY2MoZixuZXcgQyhcImNoaWxkX2NoYW5nZWRcIixkLGMseCkpLGIuUChjLGQpO251bGwhPWYmJmNjKGYsbmV3IEMoXCJjaGlsZF9yZW1vdmVkXCIseCxjKSk7Yj1iLlAoYyxNKTtyZXR1cm4gbnVsbCE9biYmYS5tYS5tYXRjaGVzKG4pPyhudWxsIT1mJiZjYyhmLG5ldyBDKFwiY2hpbGRfYWRkZWRcIixuLlksbi5uYW1lKSksYi5QKG4ubmFtZSxcbm4uWSkpOmJ9cmV0dXJuIGQuZSgpP2I6dSYmMDw9ZyhuLGwpPyhudWxsIT1mJiYoY2MoZixuZXcgQyhcImNoaWxkX3JlbW92ZWRcIixuLlksbi5uYW1lKSksY2MoZixuZXcgQyhcImNoaWxkX2FkZGVkXCIsZCxjKSkpLGIuUChjLGQpLlAobi5uYW1lLE0pKTpifTtmdW5jdGlvbiBFYygpe3RoaXMudmM9dGhpcy5xYT10aGlzLmtjPXRoaXMuaWE9dGhpcy5rYT0hMTt0aGlzLnNhPTA7dGhpcy5FYj1cIlwiO3RoaXMuQWM9bnVsbDt0aGlzLldiPVwiXCI7dGhpcy56Yz1udWxsO3RoaXMuVGI9XCJcIjt0aGlzLmc9TH12YXIgRmM9bmV3IEVjO2Z1bmN0aW9uIGZjKGEpe3koYS5pYSxcIk9ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLkFjfWZ1bmN0aW9uIGVjKGEpe3koYS5pYSxcIk9ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLmtjP2EuV2I6XCJbTUlOX05BTUVdXCJ9ZnVuY3Rpb24gaGMoYSl7eShhLnFhLFwiT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLnpjfWZ1bmN0aW9uIGdjKGEpe3koYS5xYSxcIk9ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS52Yz9hLlRiOlwiW01BWF9OQU1FXVwifVxuZnVuY3Rpb24gR2MoYSl7dmFyIGI9bmV3IEVjO2Iua2E9YS5rYTtiLnNhPWEuc2E7Yi5pYT1hLmlhO2IuQWM9YS5BYztiLmtjPWEua2M7Yi5XYj1hLldiO2IucWE9YS5xYTtiLnpjPWEuemM7Yi52Yz1hLnZjO2IuVGI9YS5UYjtiLmc9YS5nO3JldHVybiBifWg9RWMucHJvdG90eXBlO2gueGU9ZnVuY3Rpb24oYSl7dmFyIGI9R2ModGhpcyk7Yi5rYT0hMDtiLnNhPWE7Yi5FYj1cIlwiO3JldHVybiBifTtoLnllPWZ1bmN0aW9uKGEpe3ZhciBiPUdjKHRoaXMpO2Iua2E9ITA7Yi5zYT1hO2IuRWI9XCJsXCI7cmV0dXJuIGJ9O2guemU9ZnVuY3Rpb24oYSl7dmFyIGI9R2ModGhpcyk7Yi5rYT0hMDtiLnNhPWE7Yi5FYj1cInJcIjtyZXR1cm4gYn07aC5PZD1mdW5jdGlvbihhLGIpe3ZhciBjPUdjKHRoaXMpO2MuaWE9ITA7bShhKXx8KGE9bnVsbCk7Yy5BYz1hO251bGwhPWI/KGMua2M9ITAsYy5XYj1iKTooYy5rYz0hMSxjLldiPVwiXCIpO3JldHVybiBjfTtcbmguaGQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1HYyh0aGlzKTtjLnFhPSEwO20oYSl8fChhPW51bGwpO2MuemM9YTttKGIpPyhjLnZjPSEwLGMuVGI9Yik6KGMuSWc9ITEsYy5UYj1cIlwiKTtyZXR1cm4gY307ZnVuY3Rpb24gSGMoYSxiKXt2YXIgYz1HYyhhKTtjLmc9YjtyZXR1cm4gY31mdW5jdGlvbiBJYyhhKXt2YXIgYj17fTthLmlhJiYoYi5zcD1hLkFjLGEua2MmJihiLnNuPWEuV2IpKTthLnFhJiYoYi5lcD1hLnpjLGEudmMmJihiLmVuPWEuVGIpKTtpZihhLmthKXtiLmw9YS5zYTt2YXIgYz1hLkViO1wiXCI9PT1jJiYoYz1hLmlhP1wibFwiOlwiclwiKTtiLnZmPWN9YS5nIT09TCYmKGIuaT1hLmcudG9TdHJpbmcoKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gSmMoYSl7cmV0dXJuIShhLmlhfHxhLnFhfHxhLmthKX1oLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHIoSWModGhpcykpfTtmdW5jdGlvbiBRKGEsYixjLGQpe3RoaXMuaz1hO3RoaXMucGF0aD1iO3RoaXMubj1jO3RoaXMuYWM9ZH1cbmZ1bmN0aW9uIEtjKGEpe3ZhciBiPW51bGwsYz1udWxsO2EuaWEmJihiPWZjKGEpKTthLnFhJiYoYz1oYyhhKSk7aWYoYS5nPT09cmMpe2lmKGEuaWEpe2lmKFwiW01JTl9OQU1FXVwiIT1lYyhhKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLlwiKTtpZihudWxsIT1iJiZcInN0cmluZ1wiIT09dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLlwiKTt9aWYoYS5xYSl7aWYoXCJbTUFYX05BTUVdXCIhPWdjKGEpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuXCIpO2lmKG51bGwhPVxuYyYmXCJzdHJpbmdcIiE9PXR5cGVvZiBjKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSxvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy5cIik7fX1lbHNlIGlmKGEuZz09PUwpe2lmKG51bGwhPWImJiFRYihiKXx8bnVsbCE9YyYmIVFiKGMpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkgcHJpb3JpdHksIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlIChudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLlwiKTt9ZWxzZSBpZih5KGEuZyBpbnN0YW5jZW9mIG9jLFwidW5rbm93biBpbmRleCB0eXBlLlwiKSxudWxsIT1iJiZcIm9iamVjdFwiPT09dHlwZW9mIGJ8fG51bGwhPWMmJlwib2JqZWN0XCI9PT10eXBlb2YgYyl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgY2Fubm90IGJlIGFuIG9iamVjdC5cIik7XG59ZnVuY3Rpb24gTGMoYSl7aWYoYS5pYSYmYS5xYSYmYS5rYSYmKCFhLmthfHxcIlwiPT09YS5FYikpdGhyb3cgRXJyb3IoXCJRdWVyeTogQ2FuJ3QgY29tYmluZSBzdGFydEF0KCksIGVuZEF0KCksIGFuZCBsaW1pdCgpLiBVc2UgbGltaXRUb0ZpcnN0KCkgb3IgbGltaXRUb0xhc3QoKSBpbnN0ZWFkLlwiKTt9ZnVuY3Rpb24gTWMoYSxiKXtpZighMD09PWEuYWMpdGhyb3cgRXJyb3IoYitcIjogWW91IGNhbid0IGNvbWJpbmUgbXVsdGlwbGUgb3JkZXJCeSBjYWxscy5cIik7fVEucHJvdG90eXBlLmNjPWZ1bmN0aW9uKCl7RihcIlF1ZXJ5LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gbmV3IFIodGhpcy5rLHRoaXMucGF0aCl9O1EucHJvdG90eXBlLnJlZj1RLnByb3RvdHlwZS5jYztcblEucHJvdG90eXBlLnZiPWZ1bmN0aW9uKGEsYixjLGQpe0YoXCJRdWVyeS5vblwiLDIsNCxhcmd1bWVudHMubGVuZ3RoKTtXYihcIlF1ZXJ5Lm9uXCIsYSwhMSk7SChcIlF1ZXJ5Lm9uXCIsMixiLCExKTt2YXIgZT1OYyhcIlF1ZXJ5Lm9uXCIsYyxkKTtpZihcInZhbHVlXCI9PT1hKU9jKHRoaXMuayx0aGlzLG5ldyBIYihiLGUuY2FuY2VsfHxudWxsLGUuS2F8fG51bGwpKTtlbHNle3ZhciBmPXt9O2ZbYV09YjtPYyh0aGlzLmssdGhpcyxuZXcgSWIoZixlLmNhbmNlbCxlLkthKSl9cmV0dXJuIGJ9O1EucHJvdG90eXBlLm9uPVEucHJvdG90eXBlLnZiO1xuUS5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oYSxiLGMpe0YoXCJRdWVyeS5vZmZcIiwwLDMsYXJndW1lbnRzLmxlbmd0aCk7V2IoXCJRdWVyeS5vZmZcIixhLCEwKTtIKFwiUXVlcnkub2ZmXCIsMixiLCEwKTtNYihcIlF1ZXJ5Lm9mZlwiLDMsYyk7dmFyIGQ9bnVsbCxlPW51bGw7XCJ2YWx1ZVwiPT09YT9kPW5ldyBIYihifHxudWxsLG51bGwsY3x8bnVsbCk6YSYmKGImJihlPXt9LGVbYV09YiksZD1uZXcgSWIoZSxudWxsLGN8fG51bGwpKTtlPXRoaXMuaztkPVwiLmluZm9cIj09PUkodGhpcy5wYXRoKT9lLnFkLmdiKHRoaXMsZCk6ZS5OLmdiKHRoaXMsZCk7UGMoZS4kLHRoaXMucGF0aCxkKX07US5wcm90b3R5cGUub2ZmPVEucHJvdG90eXBlLlpiO1xuUS5wcm90b3R5cGUubGc9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGcpe2YmJihmPSExLGUuWmIoYSxjKSxiLmNhbGwoZC5LYSxnKSl9RihcIlF1ZXJ5Lm9uY2VcIiwyLDQsYXJndW1lbnRzLmxlbmd0aCk7V2IoXCJRdWVyeS5vbmNlXCIsYSwhMSk7SChcIlF1ZXJ5Lm9uY2VcIiwyLGIsITEpO3ZhciBkPU5jKFwiUXVlcnkub25jZVwiLGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10pLGU9dGhpcyxmPSEwO3RoaXMudmIoYSxjLGZ1bmN0aW9uKGIpe2UuWmIoYSxjKTtkLmNhbmNlbCYmZC5jYW5jZWwuY2FsbChkLkthLGIpfSl9O1EucHJvdG90eXBlLm9uY2U9US5wcm90b3R5cGUubGc7XG5RLnByb3RvdHlwZS54ZT1mdW5jdGlvbihhKXt6KFwiUXVlcnkubGltaXQoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFF1ZXJ5LmxpbWl0VG9GaXJzdCgpIG9yIFF1ZXJ5LmxpbWl0VG9MYXN0KCkgaW5zdGVhZC5cIik7RihcIlF1ZXJ5LmxpbWl0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXCIpO2lmKHRoaXMubi5rYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvcmxpbWl0VG9MYXN0LlwiKTt2YXIgYj10aGlzLm4ueGUoYSk7TGMoYik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYix0aGlzLmFjKX07US5wcm90b3R5cGUubGltaXQ9US5wcm90b3R5cGUueGU7XG5RLnByb3RvdHlwZS55ZT1mdW5jdGlvbihhKXtGKFwiUXVlcnkubGltaXRUb0ZpcnN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4ua2EpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS5cIik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsdGhpcy5uLnllKGEpLHRoaXMuYWMpfTtRLnByb3RvdHlwZS5saW1pdFRvRmlyc3Q9US5wcm90b3R5cGUueWU7XG5RLnByb3RvdHlwZS56ZT1mdW5jdGlvbihhKXtGKFwiUXVlcnkubGltaXRUb0xhc3RcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoIWdhKGEpfHxNYXRoLmZsb29yKGEpIT09YXx8MD49YSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0VG9MYXN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmthKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0xhc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS5cIik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsdGhpcy5uLnplKGEpLHRoaXMuYWMpfTtRLnByb3RvdHlwZS5saW1pdFRvTGFzdD1RLnByb3RvdHlwZS56ZTtcblEucHJvdG90eXBlLm1nPWZ1bmN0aW9uKGEpe0YoXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoXCIka2V5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2UgUXVlcnkub3JkZXJCeUtleSgpIGluc3RlYWQuJyk7aWYoXCIkcHJpb3JpdHlcIj09PWEpdGhyb3cgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJyk7WGIoXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIiwxLGEsITEpO01jKHRoaXMsXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIik7dmFyIGI9SGModGhpcy5uLG5ldyBvYyhhKSk7S2MoYik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYiwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlDaGlsZD1RLnByb3RvdHlwZS5tZztcblEucHJvdG90eXBlLm5nPWZ1bmN0aW9uKCl7RihcIlF1ZXJ5Lm9yZGVyQnlLZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7TWModGhpcyxcIlF1ZXJ5Lm9yZGVyQnlLZXlcIik7dmFyIGE9SGModGhpcy5uLHJjKTtLYyhhKTtyZXR1cm4gbmV3IFEodGhpcy5rLHRoaXMucGF0aCxhLCEwKX07US5wcm90b3R5cGUub3JkZXJCeUtleT1RLnByb3RvdHlwZS5uZztRLnByb3RvdHlwZS5vZz1mdW5jdGlvbigpe0YoXCJRdWVyeS5vcmRlckJ5UHJpb3JpdHlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7TWModGhpcyxcIlF1ZXJ5Lm9yZGVyQnlQcmlvcml0eVwiKTt2YXIgYT1IYyh0aGlzLm4sTCk7S2MoYSk7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYSwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlQcmlvcml0eT1RLnByb3RvdHlwZS5vZztcblEucHJvdG90eXBlLk9kPWZ1bmN0aW9uKGEsYil7RihcIlF1ZXJ5LnN0YXJ0QXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7UmIoXCJRdWVyeS5zdGFydEF0XCIsYSwhMCk7WGIoXCJRdWVyeS5zdGFydEF0XCIsMixiLCEwKTt2YXIgYz10aGlzLm4uT2QoYSxiKTtMYyhjKTtLYyhjKTtpZih0aGlzLm4uaWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5zdGFydEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0IG9yIGVxdWFsVG8pLlwiKTttKGEpfHwoYj1hPW51bGwpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGMsdGhpcy5hYyl9O1EucHJvdG90eXBlLnN0YXJ0QXQ9US5wcm90b3R5cGUuT2Q7XG5RLnByb3RvdHlwZS5oZD1mdW5jdGlvbihhLGIpe0YoXCJRdWVyeS5lbmRBdFwiLDAsMixhcmd1bWVudHMubGVuZ3RoKTtSYihcIlF1ZXJ5LmVuZEF0XCIsYSwhMCk7WGIoXCJRdWVyeS5lbmRBdFwiLDIsYiwhMCk7dmFyIGM9dGhpcy5uLmhkKGEsYik7TGMoYyk7S2MoYyk7aWYodGhpcy5uLnFhKXRocm93IEVycm9yKFwiUXVlcnkuZW5kQXQ6IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYyx0aGlzLmFjKX07US5wcm90b3R5cGUuZW5kQXQ9US5wcm90b3R5cGUuaGQ7XG5RLnByb3RvdHlwZS5UZj1mdW5jdGlvbihhLGIpe0YoXCJRdWVyeS5lcXVhbFRvXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1JiKFwiUXVlcnkuZXF1YWxUb1wiLGEsITEpO1hiKFwiUXVlcnkuZXF1YWxUb1wiLDIsYiwhMCk7aWYodGhpcy5uLmlhKXRocm93IEVycm9yKFwiUXVlcnkuZXF1YWxUbzogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO2lmKHRoaXMubi5xYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVxdWFsVG86IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7cmV0dXJuIHRoaXMuT2QoYSxiKS5oZChhLGIpfTtRLnByb3RvdHlwZS5lcXVhbFRvPVEucHJvdG90eXBlLlRmO1EucHJvdG90eXBlLkZhPWZ1bmN0aW9uKCl7dmFyIGE9eGIoSWModGhpcy5uKSk7cmV0dXJuXCJ7fVwiPT09YT9cImRlZmF1bHRcIjphfTtcbmZ1bmN0aW9uIE5jKGEsYixjKXt2YXIgZD17Y2FuY2VsOm51bGwsS2E6bnVsbH07aWYoYiYmYylkLmNhbmNlbD1iLEgoYSwzLGQuY2FuY2VsLCEwKSxkLkthPWMsTWIoYSw0LGQuS2EpO2Vsc2UgaWYoYilpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKWQuS2E9YjtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKWQuY2FuY2VsPWI7ZWxzZSB0aHJvdyBFcnJvcihHKGEsMywhMCkrXCIgbXVzdCBlaXRoZXIgYmUgYSBjYW5jZWwgY2FsbGJhY2sgb3IgYSBjb250ZXh0IG9iamVjdC5cIik7cmV0dXJuIGR9O2Z1bmN0aW9uIFMoYSxiKXtpZigxPT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLnc9YS5zcGxpdChcIi9cIik7Zm9yKHZhciBjPTAsZD0wO2Q8dGhpcy53Lmxlbmd0aDtkKyspMDx0aGlzLndbZF0ubGVuZ3RoJiYodGhpcy53W2NdPXRoaXMud1tkXSxjKyspO3RoaXMudy5sZW5ndGg9Yzt0aGlzLmNhPTB9ZWxzZSB0aGlzLnc9YSx0aGlzLmNhPWJ9ZnVuY3Rpb24gSShhKXtyZXR1cm4gYS5jYT49YS53Lmxlbmd0aD9udWxsOmEud1thLmNhXX1mdW5jdGlvbiBRYyhhKXtyZXR1cm4gYS53Lmxlbmd0aC1hLmNhfWZ1bmN0aW9uIFQoYSl7dmFyIGI9YS5jYTtiPGEudy5sZW5ndGgmJmIrKztyZXR1cm4gbmV3IFMoYS53LGIpfWZ1bmN0aW9uIFJjKGEpe3JldHVybiBhLmNhPGEudy5sZW5ndGg/YS53W2Eudy5sZW5ndGgtMV06bnVsbH1cblMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVwiXCIsYj10aGlzLmNhO2I8dGhpcy53Lmxlbmd0aDtiKyspXCJcIiE9PXRoaXMud1tiXSYmKGErPVwiL1wiK3RoaXMud1tiXSk7cmV0dXJuIGF8fFwiL1wifTtTLnByb3RvdHlwZS5wYXJlbnQ9ZnVuY3Rpb24oKXtpZih0aGlzLmNhPj10aGlzLncubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgYT1bXSxiPXRoaXMuY2E7Yjx0aGlzLncubGVuZ3RoLTE7YisrKWEucHVzaCh0aGlzLndbYl0pO3JldHVybiBuZXcgUyhhLDApfTtcblMucHJvdG90eXBlLm89ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9dGhpcy5jYTtjPHRoaXMudy5sZW5ndGg7YysrKWIucHVzaCh0aGlzLndbY10pO2lmKGEgaW5zdGFuY2VvZiBTKWZvcihjPWEuY2E7YzxhLncubGVuZ3RoO2MrKyliLnB1c2goYS53W2NdKTtlbHNlIGZvcihhPWEuc3BsaXQoXCIvXCIpLGM9MDtjPGEubGVuZ3RoO2MrKykwPGFbY10ubGVuZ3RoJiZiLnB1c2goYVtjXSk7cmV0dXJuIG5ldyBTKGIsMCl9O1MucHJvdG90eXBlLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYT49dGhpcy53Lmxlbmd0aH07dmFyIFU9bmV3IFMoXCJcIik7ZnVuY3Rpb24gVihhLGIpe3ZhciBjPUkoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7aWYoYz09PUkoYikpcmV0dXJuIFYoVChhKSxUKGIpKTt0aHJvdyBFcnJvcihcIklOVEVSTkFMIEVSUk9SOiBpbm5lclBhdGggKFwiK2IrXCIpIGlzIG5vdCB3aXRoaW4gb3V0ZXJQYXRoIChcIithK1wiKVwiKTt9XG5TLnByb3RvdHlwZS5lYT1mdW5jdGlvbihhKXtpZihRYyh0aGlzKSE9PVFjKGEpKXJldHVybiExO2Zvcih2YXIgYj10aGlzLmNhLGM9YS5jYTtiPD10aGlzLncubGVuZ3RoO2IrKyxjKyspaWYodGhpcy53W2JdIT09YS53W2NdKXJldHVybiExO3JldHVybiEwfTtTLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNhLGM9YS5jYTtpZihRYyh0aGlzKT5RYyhhKSlyZXR1cm4hMTtmb3IoO2I8dGhpcy53Lmxlbmd0aDspe2lmKHRoaXMud1tiXSE9PWEud1tjXSlyZXR1cm4hMTsrK2I7KytjfXJldHVybiEwfTtmdW5jdGlvbiBTYygpe3RoaXMuY2hpbGRyZW49e307dGhpcy5iZD0wO3RoaXMudmFsdWU9bnVsbH1mdW5jdGlvbiBUYyhhLGIsYyl7dGhpcy51ZD1hP2E6XCJcIjt0aGlzLk9jPWI/YjpudWxsO3RoaXMuQT1jP2M6bmV3IFNjfWZ1bmN0aW9uIFVjKGEsYil7Zm9yKHZhciBjPWIgaW5zdGFuY2VvZiBTP2I6bmV3IFMoYiksZD1hLGU7bnVsbCE9PShlPUkoYykpOylkPW5ldyBUYyhlLGQsdChkLkEuY2hpbGRyZW4sZSl8fG5ldyBTYyksYz1UKGMpO3JldHVybiBkfWg9VGMucHJvdG90eXBlO2guemE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5BLnZhbHVlfTtmdW5jdGlvbiBWYyhhLGIpe3koXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiLFwiQ2Fubm90IHNldCB2YWx1ZSB0byB1bmRlZmluZWRcIik7YS5BLnZhbHVlPWI7V2MoYSl9aC5jbGVhcj1mdW5jdGlvbigpe3RoaXMuQS52YWx1ZT1udWxsO3RoaXMuQS5jaGlsZHJlbj17fTt0aGlzLkEuYmQ9MDtXYyh0aGlzKX07XG5oLmxkPWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5BLmJkfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuemEoKSYmIXRoaXMubGQoKX07aC5VPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7QSh0aGlzLkEuY2hpbGRyZW4sZnVuY3Rpb24oYyxkKXthKG5ldyBUYyhkLGIsYykpfSl9O2Z1bmN0aW9uIFhjKGEsYixjLGQpe2MmJiFkJiZiKGEpO2EuVShmdW5jdGlvbihhKXtYYyhhLGIsITAsZCl9KTtjJiZkJiZiKGEpfWZ1bmN0aW9uIFljKGEsYil7Zm9yKHZhciBjPWEucGFyZW50KCk7bnVsbCE9PWMmJiFiKGMpOyljPWMucGFyZW50KCl9aC5wYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTKG51bGw9PT10aGlzLk9jP3RoaXMudWQ6dGhpcy5PYy5wYXRoKCkrXCIvXCIrdGhpcy51ZCl9O2gubmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVkfTtoLnBhcmVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLk9jfTtcbmZ1bmN0aW9uIFdjKGEpe2lmKG51bGwhPT1hLk9jKXt2YXIgYj1hLk9jLGM9YS51ZCxkPWEuZSgpLGU9cyhiLkEuY2hpbGRyZW4sYyk7ZCYmZT8oZGVsZXRlIGIuQS5jaGlsZHJlbltjXSxiLkEuYmQtLSxXYyhiKSk6ZHx8ZXx8KGIuQS5jaGlsZHJlbltjXT1hLkEsYi5BLmJkKyssV2MoYikpfX07ZnVuY3Rpb24gWmMoYSxiKXt0aGlzLkphPWE7dGhpcy51YT1iP2I6JGN9aD1aYy5wcm90b3R5cGU7aC5MYT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgWmModGhpcy5KYSx0aGlzLnVhLkxhKGEsYix0aGlzLkphKS5YKG51bGwsbnVsbCwhMSxudWxsLG51bGwpKX07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBaYyh0aGlzLkphLHRoaXMudWEucmVtb3ZlKGEsdGhpcy5KYSkuWChudWxsLG51bGwsITEsbnVsbCxudWxsKSl9O2guZ2V0PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjPXRoaXMudWE7IWMuZSgpOyl7Yj10aGlzLkphKGEsYy5rZXkpO2lmKDA9PT1iKXJldHVybiBjLnZhbHVlOzA+Yj9jPWMubGVmdDowPGImJihjPWMucmlnaHQpfXJldHVybiBudWxsfTtcbmZ1bmN0aW9uIGFkKGEsYil7Zm9yKHZhciBjLGQ9YS51YSxlPW51bGw7IWQuZSgpOyl7Yz1hLkphKGIsZC5rZXkpO2lmKDA9PT1jKXtpZihkLmxlZnQuZSgpKXJldHVybiBlP2Uua2V5Om51bGw7Zm9yKGQ9ZC5sZWZ0OyFkLnJpZ2h0LmUoKTspZD1kLnJpZ2h0O3JldHVybiBkLmtleX0wPmM/ZD1kLmxlZnQ6MDxjJiYoZT1kLGQ9ZC5yaWdodCl9dGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZmluZCBwcmVkZWNlc3NvciBrZXkgZm9yIGEgbm9uZXhpc3RlbnQga2V5LiAgV2hhdCBnaXZlcz9cIik7fWguZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVhLmUoKX07aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVhLmNvdW50KCl9O2guSWM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51YS5JYygpfTtoLlhiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudWEuWGIoKX07aC5mYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy51YS5mYShhKX07XG5oLk9iPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYmQodGhpcy51YSxudWxsLHRoaXMuSmEsITEsYSl9O2guUGI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGJkKHRoaXMudWEsYSx0aGlzLkphLCExLGIpfTtoLlJiPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBiZCh0aGlzLnVhLGEsdGhpcy5KYSwhMCxiKX07aC5nZj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGJkKHRoaXMudWEsbnVsbCx0aGlzLkphLCEwLGEpfTtmdW5jdGlvbiBiZChhLGIsYyxkLGUpe3RoaXMuSWQ9ZXx8bnVsbDt0aGlzLnZlPWQ7dGhpcy5OYT1bXTtmb3IoZT0xOyFhLmUoKTspaWYoZT1iP2MoYS5rZXksYik6MSxkJiYoZSo9LTEpLDA+ZSlhPXRoaXMudmU/YS5sZWZ0OmEucmlnaHQ7ZWxzZSBpZigwPT09ZSl7dGhpcy5OYS5wdXNoKGEpO2JyZWFrfWVsc2UgdGhpcy5OYS5wdXNoKGEpLGE9dGhpcy52ZT9hLnJpZ2h0OmEubGVmdH1cbmZ1bmN0aW9uIFAoYSl7aWYoMD09PWEuTmEubGVuZ3RoKXJldHVybiBudWxsO3ZhciBiPWEuTmEucG9wKCksYztjPWEuSWQ/YS5JZChiLmtleSxiLnZhbHVlKTp7a2V5OmIua2V5LHZhbHVlOmIudmFsdWV9O2lmKGEudmUpZm9yKGI9Yi5sZWZ0OyFiLmUoKTspYS5OYS5wdXNoKGIpLGI9Yi5yaWdodDtlbHNlIGZvcihiPWIucmlnaHQ7IWIuZSgpOylhLk5hLnB1c2goYiksYj1iLmxlZnQ7cmV0dXJuIGN9ZnVuY3Rpb24gY2QoYSl7aWYoMD09PWEuTmEubGVuZ3RoKXJldHVybiBudWxsO3ZhciBiO2I9YS5OYTtiPWJbYi5sZW5ndGgtMV07cmV0dXJuIGEuSWQ/YS5JZChiLmtleSxiLnZhbHVlKTp7a2V5OmIua2V5LHZhbHVlOmIudmFsdWV9fWZ1bmN0aW9uIGRkKGEsYixjLGQsZSl7dGhpcy5rZXk9YTt0aGlzLnZhbHVlPWI7dGhpcy5jb2xvcj1udWxsIT1jP2M6ITA7dGhpcy5sZWZ0PW51bGwhPWQ/ZDokYzt0aGlzLnJpZ2h0PW51bGwhPWU/ZTokY31oPWRkLnByb3RvdHlwZTtcbmguWD1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiBuZXcgZGQobnVsbCE9YT9hOnRoaXMua2V5LG51bGwhPWI/Yjp0aGlzLnZhbHVlLG51bGwhPWM/Yzp0aGlzLmNvbG9yLG51bGwhPWQ/ZDp0aGlzLmxlZnQsbnVsbCE9ZT9lOnRoaXMucmlnaHQpfTtoLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVmdC5jb3VudCgpKzErdGhpcy5yaWdodC5jb3VudCgpfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5mYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5sZWZ0LmZhKGEpfHxhKHRoaXMua2V5LHRoaXMudmFsdWUpfHx0aGlzLnJpZ2h0LmZhKGEpfTtmdW5jdGlvbiBlZChhKXtyZXR1cm4gYS5sZWZ0LmUoKT9hOmVkKGEubGVmdCl9aC5JYz1mdW5jdGlvbigpe3JldHVybiBlZCh0aGlzKS5rZXl9O2guWGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodC5lKCk/dGhpcy5rZXk6dGhpcy5yaWdodC5YYigpfTtcbmguTGE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7ZT10aGlzO2Q9YyhhLGUua2V5KTtlPTA+ZD9lLlgobnVsbCxudWxsLG51bGwsZS5sZWZ0LkxhKGEsYixjKSxudWxsKTowPT09ZD9lLlgobnVsbCxiLG51bGwsbnVsbCxudWxsKTplLlgobnVsbCxudWxsLG51bGwsbnVsbCxlLnJpZ2h0LkxhKGEsYixjKSk7cmV0dXJuIGZkKGUpfTtmdW5jdGlvbiBnZChhKXtpZihhLmxlZnQuZSgpKXJldHVybiAkYzthLmxlZnQuYmEoKXx8YS5sZWZ0LmxlZnQuYmEoKXx8KGE9aGQoYSkpO2E9YS5YKG51bGwsbnVsbCxudWxsLGdkKGEubGVmdCksbnVsbCk7cmV0dXJuIGZkKGEpfVxuaC5yZW1vdmU9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkO2M9dGhpcztpZigwPmIoYSxjLmtleSkpYy5sZWZ0LmUoKXx8Yy5sZWZ0LmJhKCl8fGMubGVmdC5sZWZ0LmJhKCl8fChjPWhkKGMpKSxjPWMuWChudWxsLG51bGwsbnVsbCxjLmxlZnQucmVtb3ZlKGEsYiksbnVsbCk7ZWxzZXtjLmxlZnQuYmEoKSYmKGM9amQoYykpO2MucmlnaHQuZSgpfHxjLnJpZ2h0LmJhKCl8fGMucmlnaHQubGVmdC5iYSgpfHwoYz1rZChjKSxjLmxlZnQubGVmdC5iYSgpJiYoYz1qZChjKSxjPWtkKGMpKSk7aWYoMD09PWIoYSxjLmtleSkpe2lmKGMucmlnaHQuZSgpKXJldHVybiAkYztkPWVkKGMucmlnaHQpO2M9Yy5YKGQua2V5LGQudmFsdWUsbnVsbCxudWxsLGdkKGMucmlnaHQpKX1jPWMuWChudWxsLG51bGwsbnVsbCxudWxsLGMucmlnaHQucmVtb3ZlKGEsYikpfXJldHVybiBmZChjKX07aC5iYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbG9yfTtcbmZ1bmN0aW9uIGZkKGEpe2EucmlnaHQuYmEoKSYmIWEubGVmdC5iYSgpJiYoYT1sZChhKSk7YS5sZWZ0LmJhKCkmJmEubGVmdC5sZWZ0LmJhKCkmJihhPWpkKGEpKTthLmxlZnQuYmEoKSYmYS5yaWdodC5iYSgpJiYoYT1rZChhKSk7cmV0dXJuIGF9ZnVuY3Rpb24gaGQoYSl7YT1rZChhKTthLnJpZ2h0LmxlZnQuYmEoKSYmKGE9YS5YKG51bGwsbnVsbCxudWxsLG51bGwsamQoYS5yaWdodCkpLGE9bGQoYSksYT1rZChhKSk7cmV0dXJuIGF9ZnVuY3Rpb24gbGQoYSl7cmV0dXJuIGEucmlnaHQuWChudWxsLG51bGwsYS5jb2xvcixhLlgobnVsbCxudWxsLCEwLG51bGwsYS5yaWdodC5sZWZ0KSxudWxsKX1mdW5jdGlvbiBqZChhKXtyZXR1cm4gYS5sZWZ0LlgobnVsbCxudWxsLGEuY29sb3IsbnVsbCxhLlgobnVsbCxudWxsLCEwLGEubGVmdC5yaWdodCxudWxsKSl9XG5mdW5jdGlvbiBrZChhKXtyZXR1cm4gYS5YKG51bGwsbnVsbCwhYS5jb2xvcixhLmxlZnQuWChudWxsLG51bGwsIWEubGVmdC5jb2xvcixudWxsLG51bGwpLGEucmlnaHQuWChudWxsLG51bGwsIWEucmlnaHQuY29sb3IsbnVsbCxudWxsKSl9ZnVuY3Rpb24gbWQoKXt9aD1tZC5wcm90b3R5cGU7aC5YPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2guTGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGRkKGEsYixudWxsKX07aC5yZW1vdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiAwfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07aC5mYT1mdW5jdGlvbigpe3JldHVybiExfTtoLkljPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O2guWGI9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07aC5iYT1mdW5jdGlvbigpe3JldHVybiExfTt2YXIgJGM9bmV3IG1kO2Z1bmN0aW9uIG5kKGEsYil7dGhpcy5EPWE7eShtKHRoaXMuRCkmJm51bGwhPT10aGlzLkQsXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTt0aGlzLmhhPWJ8fE07b2QodGhpcy5oYSk7dGhpcy5zYj1udWxsfWg9bmQucHJvdG90eXBlO2guTT1mdW5jdGlvbigpe3JldHVybiEwfTtoLkw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYX07aC5aPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbmQodGhpcy5ELGEpfTtoLks9ZnVuY3Rpb24oYSl7cmV0dXJuXCIucHJpb3JpdHlcIj09PWE/dGhpcy5oYTpNfTtoLnJhPWZ1bmN0aW9uKGEpe3JldHVybiBhLmUoKT90aGlzOlwiLnByaW9yaXR5XCI9PT1JKGEpP3RoaXMuaGE6TX07aC5EYT1mdW5jdGlvbigpe3JldHVybiExfTtoLmZmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuaC5QPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCIucHJpb3JpdHlcIj09PWE/dGhpcy5aKGIpOmIuZSgpJiZcIi5wcmlvcml0eVwiIT09YT90aGlzOk0uUChhLGIpLloodGhpcy5oYSl9O2guQz1mdW5jdGlvbihhLGIpe3ZhciBjPUkoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7aWYoYi5lKCkmJlwiLnByaW9yaXR5XCIhPT1jKXJldHVybiB0aGlzO3koXCIucHJpb3JpdHlcIiE9PWN8fDE9PT1RYyhhKSxcIi5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aFwiKTtyZXR1cm4gdGhpcy5QKGMsTS5DKFQoYSksYikpfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC51Yj1mdW5jdGlvbigpe3JldHVybiAwfTtoLkk9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJiF0aGlzLkwoKS5lKCk/e1wiLnZhbHVlXCI6dGhpcy56YSgpLFwiLnByaW9yaXR5XCI6dGhpcy5MKCkuSSgpfTp0aGlzLnphKCl9O1xuaC5oYXNoPWZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuc2Ipe3ZhciBhPVwiXCI7dGhpcy5oYS5lKCl8fChhKz1cInByaW9yaXR5OlwiK3BkKHRoaXMuaGEuSSgpKStcIjpcIik7dmFyIGI9dHlwZW9mIHRoaXMuRCxhPWErKGIrXCI6XCIpLGE9XCJudW1iZXJcIj09PWI/YStBYih0aGlzLkQpOmErdGhpcy5EO3RoaXMuc2I9aWIoYSl9cmV0dXJuIHRoaXMuc2J9O2guemE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5EfTtoLmhlPWZ1bmN0aW9uKGEpe2lmKGE9PT1NKXJldHVybiAxO2lmKGEgaW5zdGFuY2VvZiBXKXJldHVybi0xO3koYS5NKCksXCJVbmtub3duIG5vZGUgdHlwZVwiKTt2YXIgYj10eXBlb2YgYS5ELGM9dHlwZW9mIHRoaXMuRCxkPUdhKHFkLGIpLGU9R2EocWQsYyk7eSgwPD1kLFwiVW5rbm93biBsZWFmIHR5cGU6IFwiK2IpO3koMDw9ZSxcIlVua25vd24gbGVhZiB0eXBlOiBcIitjKTtyZXR1cm4gZD09PWU/XCJvYmplY3RcIj09PWM/MDp0aGlzLkQ8YS5EPy0xOnRoaXMuRD09PWEuRD8wOjE6ZS1kfTtcbnZhciBxZD1bXCJvYmplY3RcIixcImJvb2xlYW5cIixcIm51bWJlclwiLFwic3RyaW5nXCJdO25kLnByb3RvdHlwZS5GYj1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtuZC5wcm90b3R5cGUuQmM9ZnVuY3Rpb24oKXtyZXR1cm4hMH07bmQucHJvdG90eXBlLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpcz8hMDphLk0oKT90aGlzLkQ9PT1hLkQmJnRoaXMuaGEuZWEoYS5oYSk6ITF9O25kLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiByKHRoaXMuSSghMCkpfTtmdW5jdGlvbiByZChhLGIpe3RoaXMucGQ9YTt0aGlzLlZiPWJ9cmQucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXt2YXIgYj10KHRoaXMucGQsYSk7aWYoIWIpdGhyb3cgRXJyb3IoXCJObyBpbmRleCBkZWZpbmVkIGZvciBcIithKTtyZXR1cm4gYj09PWxjP251bGw6Yn07ZnVuY3Rpb24gc2QoYSxiLGMpe3ZhciBkPXRkKGEucGQsZnVuY3Rpb24oZCxmKXt2YXIgZz10KGEuVmIsZik7eShnLFwiTWlzc2luZyBpbmRleCBpbXBsZW1lbnRhdGlvbiBmb3IgXCIrZik7aWYoZD09PWxjKXtpZihnLnVlKGIuWSkpe2Zvcih2YXIgaz1bXSxsPWMuT2IoemMpLG49UChsKTtuOyluLm5hbWUhPWIubmFtZSYmay5wdXNoKG4pLG49UChsKTtrLnB1c2goYik7cmV0dXJuIHVkKGssbWMoZykpfXJldHVybiBsY31nPWMuZ2V0KGIubmFtZSk7az1kO2cmJihrPWsucmVtb3ZlKG5ldyBOKGIubmFtZSxnKSkpO3JldHVybiBrLkxhKGIsYi5ZKX0pO3JldHVybiBuZXcgcmQoZCxhLlZiKX1cbmZ1bmN0aW9uIHZkKGEsYixjKXt2YXIgZD10ZChhLnBkLGZ1bmN0aW9uKGEpe2lmKGE9PT1sYylyZXR1cm4gYTt2YXIgZD1jLmdldChiLm5hbWUpO3JldHVybiBkP2EucmVtb3ZlKG5ldyBOKGIubmFtZSxkKSk6YX0pO3JldHVybiBuZXcgcmQoZCxhLlZiKX12YXIgd2Q9bmV3IHJkKHtcIi5wcmlvcml0eVwiOmxjfSx7XCIucHJpb3JpdHlcIjpMfSk7ZnVuY3Rpb24gVyhhLGIsYyl7dGhpcy5tPWE7KHRoaXMuaGE9YikmJm9kKHRoaXMuaGEpO3RoaXMub2I9Yzt0aGlzLnNiPW51bGx9aD1XLnByb3RvdHlwZTtoLk09ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5MPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGF8fE19O2guWj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFcodGhpcy5tLGEsdGhpcy5vYil9O2guSz1mdW5jdGlvbihhKXtpZihcIi5wcmlvcml0eVwiPT09YSlyZXR1cm4gdGhpcy5MKCk7YT10aGlzLm0uZ2V0KGEpO3JldHVybiBudWxsPT09YT9NOmF9O2gucmE9ZnVuY3Rpb24oYSl7dmFyIGI9SShhKTtyZXR1cm4gbnVsbD09PWI/dGhpczp0aGlzLksoYikucmEoVChhKSl9O2guRGE9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT10aGlzLm0uZ2V0KGEpfTtcbmguUD1mdW5jdGlvbihhLGIpe3koYixcIldlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2Rlc1wiKTtpZihcIi5wcmlvcml0eVwiPT09YSlyZXR1cm4gdGhpcy5aKGIpO3ZhciBjPW5ldyBOKGEsYiksZDtiLmUoKT8oZD10aGlzLm0ucmVtb3ZlKGEpLGM9dmQodGhpcy5vYixjLHRoaXMubSkpOihkPXRoaXMubS5MYShhLGIpLGM9c2QodGhpcy5vYixjLHRoaXMubSkpO3JldHVybiBuZXcgVyhkLHRoaXMuaGEsYyl9O2guQz1mdW5jdGlvbihhLGIpe3ZhciBjPUkoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7eShcIi5wcmlvcml0eVwiIT09SShhKXx8MT09PVFjKGEpLFwiLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoXCIpO3ZhciBkPXRoaXMuSyhjKS5DKFQoYSksYik7cmV0dXJuIHRoaXMuUChjLGQpfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tLmUoKX07aC51Yj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm0uY291bnQoKX07dmFyIHhkPS9eKDB8WzEtOV1cXGQqKSQvO1xuaD1XLnByb3RvdHlwZTtoLkk9ZnVuY3Rpb24oYSl7aWYodGhpcy5lKCkpcmV0dXJuIG51bGw7dmFyIGI9e30sYz0wLGQ9MCxlPSEwO3RoaXMuVShMLGZ1bmN0aW9uKGYsZyl7YltmXT1nLkkoYSk7YysrO2UmJnhkLnRlc3QoZik/ZD1NYXRoLm1heChkLE51bWJlcihmKSk6ZT0hMX0pO2lmKCFhJiZlJiZkPDIqYyl7dmFyIGY9W10sZztmb3IoZyBpbiBiKWZbZ109YltnXTtyZXR1cm4gZn1hJiYhdGhpcy5MKCkuZSgpJiYoYltcIi5wcmlvcml0eVwiXT10aGlzLkwoKS5JKCkpO3JldHVybiBifTtoLmhhc2g9ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5zYil7dmFyIGE9XCJcIjt0aGlzLkwoKS5lKCl8fChhKz1cInByaW9yaXR5OlwiK3BkKHRoaXMuTCgpLkkoKSkrXCI6XCIpO3RoaXMuVShMLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yy5oYXNoKCk7XCJcIiE9PWQmJihhKz1cIjpcIitiK1wiOlwiK2QpfSk7dGhpcy5zYj1cIlwiPT09YT9cIlwiOmliKGEpfXJldHVybiB0aGlzLnNifTtcbmguZmY9ZnVuY3Rpb24oYSxiLGMpe3JldHVybihjPXlkKHRoaXMsYykpPyhhPWFkKGMsbmV3IE4oYSxiKSkpP2EubmFtZTpudWxsOmFkKHRoaXMubSxhKX07ZnVuY3Rpb24gQ2MoYSxiKXt2YXIgYztjPShjPXlkKGEsYikpPyhjPWMuSWMoKSkmJmMubmFtZTphLm0uSWMoKTtyZXR1cm4gYz9uZXcgTihjLGEubS5nZXQoYykpOm51bGx9ZnVuY3Rpb24gRGMoYSxiKXt2YXIgYztjPShjPXlkKGEsYikpPyhjPWMuWGIoKSkmJmMubmFtZTphLm0uWGIoKTtyZXR1cm4gYz9uZXcgTihjLGEubS5nZXQoYykpOm51bGx9aC5VPWZ1bmN0aW9uKGEsYil7dmFyIGM9eWQodGhpcyxhKTtyZXR1cm4gYz9jLmZhKGZ1bmN0aW9uKGEpe3JldHVybiBiKGEubmFtZSxhLlkpfSk6dGhpcy5tLmZhKGIpfTtoLk9iPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlBiKGEuQ2UoKSxhKX07XG5oLlBiPWZ1bmN0aW9uKGEsYil7dmFyIGM9eWQodGhpcyxiKTtpZihjKXJldHVybiBjLlBiKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmb3IodmFyIGM9dGhpcy5tLlBiKGEubmFtZSx6YyksZD1jZChjKTtudWxsIT1kJiYwPmIuY29tcGFyZShkLGEpOylQKGMpLGQ9Y2QoYyk7cmV0dXJuIGN9O2guZ2Y9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuUmIoYS5CZSgpLGEpfTtoLlJiPWZ1bmN0aW9uKGEsYil7dmFyIGM9eWQodGhpcyxiKTtpZihjKXJldHVybiBjLlJiKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmb3IodmFyIGM9dGhpcy5tLlJiKGEubmFtZSx6YyksZD1jZChjKTtudWxsIT1kJiYwPGIuY29tcGFyZShkLGEpOylQKGMpLGQ9Y2QoYyk7cmV0dXJuIGN9O2guaGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZSgpP2EuZSgpPzA6LTE6YS5NKCl8fGEuZSgpPzE6YT09PXBjPy0xOjB9O1xuaC5GYj1mdW5jdGlvbihhKXtpZihhPT09cmN8fHpkKHRoaXMub2IuVmIsYS50b1N0cmluZygpKSlyZXR1cm4gdGhpczt2YXIgYj10aGlzLm9iLGM9dGhpcy5tO3koYSE9PXJjLFwiS2V5SW5kZXggYWx3YXlzIGV4aXN0cyBhbmQgaXNuJ3QgbWVhbnQgdG8gYmUgYWRkZWQgdG8gdGhlIEluZGV4TWFwLlwiKTtmb3IodmFyIGQ9W10sZT0hMSxjPWMuT2IoemMpLGY9UChjKTtmOyllPWV8fGEudWUoZi5ZKSxkLnB1c2goZiksZj1QKGMpO2Q9ZT91ZChkLG1jKGEpKTpsYztlPWEudG9TdHJpbmcoKTtjPUFkKGIuVmIpO2NbZV09YTthPUFkKGIucGQpO2FbZV09ZDtyZXR1cm4gbmV3IFcodGhpcy5tLHRoaXMuaGEsbmV3IHJkKGEsYykpfTtoLkJjPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09cmN8fHpkKHRoaXMub2IuVmIsYS50b1N0cmluZygpKX07XG5oLmVhPWZ1bmN0aW9uKGEpe2lmKGE9PT10aGlzKXJldHVybiEwO2lmKGEuTSgpKXJldHVybiExO2lmKHRoaXMuTCgpLmVhKGEuTCgpKSYmdGhpcy5tLmNvdW50KCk9PT1hLm0uY291bnQoKSl7dmFyIGI9dGhpcy5PYihMKTthPWEuT2IoTCk7Zm9yKHZhciBjPVAoYiksZD1QKGEpO2MmJmQ7KXtpZihjLm5hbWUhPT1kLm5hbWV8fCFjLlkuZWEoZC5ZKSlyZXR1cm4hMTtjPVAoYik7ZD1QKGEpfXJldHVybiBudWxsPT09YyYmbnVsbD09PWR9cmV0dXJuITF9O2Z1bmN0aW9uIHlkKGEsYil7cmV0dXJuIGI9PT1yYz9udWxsOmEub2IuZ2V0KGIudG9TdHJpbmcoKSl9aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiByKHRoaXMuSSghMCkpfTtmdW5jdGlvbiBPKGEsYil7aWYobnVsbD09PWEpcmV0dXJuIE07dmFyIGM9bnVsbDtcIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiLnByaW9yaXR5XCJpbiBhP2M9YVtcIi5wcmlvcml0eVwiXTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGImJihjPWIpO3kobnVsbD09PWN8fFwic3RyaW5nXCI9PT10eXBlb2YgY3x8XCJudW1iZXJcIj09PXR5cGVvZiBjfHxcIm9iamVjdFwiPT09dHlwZW9mIGMmJlwiLnN2XCJpbiBjLFwiSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiBcIit0eXBlb2YgYyk7XCJvYmplY3RcIj09PXR5cGVvZiBhJiZcIi52YWx1ZVwiaW4gYSYmbnVsbCE9PWFbXCIudmFsdWVcIl0mJihhPWFbXCIudmFsdWVcIl0pO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8XCIuc3ZcImluIGEpcmV0dXJuIG5ldyBuZChhLE8oYykpO2lmKGEgaW5zdGFuY2VvZiBBcnJheSl7dmFyIGQ9TSxlPWE7QShlLGZ1bmN0aW9uKGEsYil7aWYocyhlLGIpJiZcIi5cIiE9PWIuc3Vic3RyaW5nKDAsMSkpe3ZhciBjPU8oYSk7aWYoYy5NKCl8fCFjLmUoKSlkPVxuZC5QKGIsYyl9fSk7cmV0dXJuIGQuWihPKGMpKX12YXIgZj1bXSxnPSExLGs9YTt1YShrLGZ1bmN0aW9uKGEpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYXx8XCIuXCIhPT1hLnN1YnN0cmluZygwLDEpKXt2YXIgYj1PKGtbYV0pO2IuZSgpfHwoZz1nfHwhYi5MKCkuZSgpLGYucHVzaChuZXcgTihhLGIpKSl9fSk7dmFyIGw9dWQoZixpYyxmdW5jdGlvbihhKXtyZXR1cm4gYS5uYW1lfSxqYyk7aWYoZyl7dmFyIG49dWQoZixtYyhMKSk7cmV0dXJuIG5ldyBXKGwsTyhjKSxuZXcgcmQoe1wiLnByaW9yaXR5XCI6bn0se1wiLnByaW9yaXR5XCI6TH0pKX1yZXR1cm4gbmV3IFcobCxPKGMpLHdkKX12YXIgQmQ9TWF0aC5sb2coMik7ZnVuY3Rpb24gQ2QoYSl7dGhpcy5jb3VudD1wYXJzZUludChNYXRoLmxvZyhhKzEpL0JkLDEwKTt0aGlzLiRlPXRoaXMuY291bnQtMTt0aGlzLk5mPWErMSZwYXJzZUludChBcnJheSh0aGlzLmNvdW50KzEpLmpvaW4oXCIxXCIpLDIpfVxuZnVuY3Rpb24gRGQoYSl7dmFyIGI9IShhLk5mJjE8PGEuJGUpO2EuJGUtLTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHVkKGEsYixjLGQpe2Z1bmN0aW9uIGUoYixkKXt2YXIgZj1kLWI7aWYoMD09ZilyZXR1cm4gbnVsbDtpZigxPT1mKXt2YXIgbj1hW2JdLHU9Yz9jKG4pOm47cmV0dXJuIG5ldyBkZCh1LG4uWSwhMSxudWxsLG51bGwpfXZhciBuPXBhcnNlSW50KGYvMiwxMCkrYixmPWUoYixuKSx4PWUobisxLGQpLG49YVtuXSx1PWM/YyhuKTpuO3JldHVybiBuZXcgZGQodSxuLlksITEsZix4KX1hLnNvcnQoYik7dmFyIGY9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZChiLGcpe3ZhciBrPXUtYix4PXU7dS09Yjt2YXIgeD1lKGsrMSx4KSxrPWFba10sRT1jP2Moayk6ayx4PW5ldyBkZChFLGsuWSxnLG51bGwseCk7Zj9mLmxlZnQ9eDpuPXg7Zj14fWZvcih2YXIgZj1udWxsLG49bnVsbCx1PWEubGVuZ3RoLHg9MDt4PGIuY291bnQ7Kyt4KXt2YXIgRT1EZChiKSxpZD1NYXRoLnBvdygyLGIuY291bnQtKHgrMSkpO0U/ZChpZCwhMSk6KGQoaWQsITEpLGQoaWQsITApKX1yZXR1cm4gbn0obmV3IENkKGEubGVuZ3RoKSk7XG5yZXR1cm4gbnVsbCE9PWY/bmV3IFpjKGR8fGIsZik6bmV3IFpjKGR8fGIpfWZ1bmN0aW9uIHBkKGEpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYT9cIm51bWJlcjpcIitBYihhKTpcInN0cmluZzpcIithfWZ1bmN0aW9uIG9kKGEpe2lmKGEuTSgpKXt2YXIgYj1hLkkoKTt5KFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBifHxcIm9iamVjdFwiPT09dHlwZW9mIGImJnMoYixcIi5zdlwiKSxcIlByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLlwiKX1lbHNlIHkoYT09PXBjfHxhLmUoKSxcInByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS5cIik7eShhPT09cGN8fGEuTCgpLmUoKSxcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpfXZhciBNPW5ldyBXKG5ldyBaYyhqYyksbnVsbCx3ZCk7ZnVuY3Rpb24gRWQoKXtXLmNhbGwodGhpcyxuZXcgWmMoamMpLE0sd2QpfW1hKEVkLFcpO2g9RWQucHJvdG90eXBlO1xuaC5oZT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/MDoxfTtoLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpc307aC5MPWZ1bmN0aW9uKCl7dGhyb3cgZmIoXCJXaHkgaXMgdGhpcyBjYWxsZWQ/XCIpO307aC5LPWZ1bmN0aW9uKCl7cmV0dXJuIE19O2guZT1mdW5jdGlvbigpe3JldHVybiExfTt2YXIgcGM9bmV3IEVkLG5jPW5ldyBOKFwiW01JTl9OQU1FXVwiLE0pO2Z1bmN0aW9uIEQoYSxiLGMpe3RoaXMuQT1hO3RoaXMuVj1iO3RoaXMuZz1jfUQucHJvdG90eXBlLkk9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LnZhbFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkkoKX07RC5wcm90b3R5cGUudmFsPUQucHJvdG90eXBlLkk7RC5wcm90b3R5cGUuYmY9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmV4cG9ydFZhbFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkkoITApfTtELnByb3RvdHlwZS5leHBvcnRWYWw9RC5wcm90b3R5cGUuYmY7RC5wcm90b3R5cGUuV2Y9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmV4aXN0c1wiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4hdGhpcy5BLmUoKX07RC5wcm90b3R5cGUuZXhpc3RzPUQucHJvdG90eXBlLldmO1xuRC5wcm90b3R5cGUubz1mdW5jdGlvbihhKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmNoaWxkXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO2dhKGEpJiYoYT1TdHJpbmcoYSkpO1liKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmNoaWxkXCIsYSk7dmFyIGI9bmV3IFMoYSksYz10aGlzLlYubyhiKTtyZXR1cm4gbmV3IEQodGhpcy5BLnJhKGIpLGMsTCl9O0QucHJvdG90eXBlLmNoaWxkPUQucHJvdG90eXBlLm87RC5wcm90b3R5cGUuRGE9ZnVuY3Rpb24oYSl7RihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtZYihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZFwiLGEpO3ZhciBiPW5ldyBTKGEpO3JldHVybiF0aGlzLkEucmEoYikuZSgpfTtELnByb3RvdHlwZS5oYXNDaGlsZD1ELnByb3RvdHlwZS5EYTtcbkQucHJvdG90eXBlLkw9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmdldFByaW9yaXR5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuTCgpLkkoKX07RC5wcm90b3R5cGUuZ2V0UHJpb3JpdHk9RC5wcm90b3R5cGUuTDtELnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGEpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZm9yRWFjaFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmZvckVhY2hcIiwxLGEsITEpO2lmKHRoaXMuQS5NKCkpcmV0dXJuITE7dmFyIGI9dGhpcztyZXR1cm4hIXRoaXMuQS5VKHRoaXMuZyxmdW5jdGlvbihjLGQpe3JldHVybiBhKG5ldyBEKGQsYi5WLm8oYyksTCkpfSl9O0QucHJvdG90eXBlLmZvckVhY2g9RC5wcm90b3R5cGUuZm9yRWFjaDtcbkQucHJvdG90eXBlLmxkPWZ1bmN0aW9uKCl7RihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLk0oKT8hMTohdGhpcy5BLmUoKX07RC5wcm90b3R5cGUuaGFzQ2hpbGRyZW49RC5wcm90b3R5cGUubGQ7RC5wcm90b3R5cGUubmFtZT1mdW5jdGlvbigpe3ooXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubmFtZSgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2UuRGF0YVNuYXBzaG90LmtleSgpIGluc3RlYWQuXCIpO0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubmFtZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5rZXkoKX07RC5wcm90b3R5cGUubmFtZT1ELnByb3RvdHlwZS5uYW1lO0QucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3Qua2V5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLlYua2V5KCl9O1xuRC5wcm90b3R5cGUua2V5PUQucHJvdG90eXBlLmtleTtELnByb3RvdHlwZS51Yj1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubnVtQ2hpbGRyZW5cIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS51YigpfTtELnByb3RvdHlwZS5udW1DaGlsZHJlbj1ELnByb3RvdHlwZS51YjtELnByb3RvdHlwZS5jYz1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLlZ9O0QucHJvdG90eXBlLnJlZj1ELnByb3RvdHlwZS5jYztmdW5jdGlvbiBGZChhKXt5KGVhKGEpJiYwPGEubGVuZ3RoLFwiUmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXlcIik7dGhpcy5GZj1hO3RoaXMuR2M9e319RmQucHJvdG90eXBlLlZkPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuR2NbYV18fFtdLGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLnFjLmFwcGx5KGNbZF0uS2EsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX07RmQucHJvdG90eXBlLnZiPWZ1bmN0aW9uKGEsYixjKXtHZCh0aGlzLGEpO3RoaXMuR2NbYV09dGhpcy5HY1thXXx8W107dGhpcy5HY1thXS5wdXNoKHtxYzpiLEthOmN9KTsoYT10aGlzLnFlKGEpKSYmYi5hcHBseShjLGEpfTtGZC5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oYSxiLGMpe0dkKHRoaXMsYSk7YT10aGlzLkdjW2FdfHxbXTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLnFjPT09YiYmKCFjfHxjPT09YVtkXS5LYSkpe2Euc3BsaWNlKGQsMSk7YnJlYWt9fTtcbmZ1bmN0aW9uIEdkKGEsYil7eShNYShhLkZmLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09Yn0pLFwiVW5rbm93biBldmVudDogXCIrYil9O2Z1bmN0aW9uIEhkKCl7RmQuY2FsbCh0aGlzLFtcInZpc2libGVcIl0pO3ZhciBhLGI7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyJiYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5oaWRkZW4/KGI9XCJ2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cImhpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbj8oYj1cIm1venZpc2liaWxpdHljaGFuZ2VcIixhPVwibW96SGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4/KGI9XCJtc3Zpc2liaWxpdHljaGFuZ2VcIixhPVwibXNIaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4mJihiPVwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJ3ZWJraXRIaWRkZW5cIikpO3RoaXMubWM9ITA7aWYoYil7dmFyIGM9dGhpcztkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGIsXG5mdW5jdGlvbigpe3ZhciBiPSFkb2N1bWVudFthXTtiIT09Yy5tYyYmKGMubWM9YixjLlZkKFwidmlzaWJsZVwiLGIpKX0sITEpfX1tYShIZCxGZCk7Y2EoSGQpO0hkLnByb3RvdHlwZS5xZT1mdW5jdGlvbihhKXt5KFwidmlzaWJsZVwiPT09YSxcIlVua25vd24gZXZlbnQgdHlwZTogXCIrYSk7cmV0dXJuW3RoaXMubWNdfTtmdW5jdGlvbiBJZCgpe0ZkLmNhbGwodGhpcyxbXCJvbmxpbmVcIl0pO3RoaXMuTGM9ITA7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBhPXRoaXM7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIixmdW5jdGlvbigpe2EuTGN8fGEuVmQoXCJvbmxpbmVcIiwhMCk7YS5MYz0hMH0sITEpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLGZ1bmN0aW9uKCl7YS5MYyYmYS5WZChcIm9ubGluZVwiLCExKTthLkxjPSExfSwhMSl9fW1hKElkLEZkKTtjYShJZCk7SWQucHJvdG90eXBlLnFlPWZ1bmN0aW9uKGEpe3koXCJvbmxpbmVcIj09PWEsXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiK2EpO3JldHVyblt0aGlzLkxjXX07ZnVuY3Rpb24gQShhLGIpe2Zvcih2YXIgYyBpbiBhKWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpfWZ1bmN0aW9uIHRkKGEsYil7dmFyIGM9e30sZDtmb3IoZCBpbiBhKWNbZF09Yi5jYWxsKHZvaWQgMCxhW2RdLGQsYSk7cmV0dXJuIGN9ZnVuY3Rpb24gTGIoYSxiKXtmb3IodmFyIGMgaW4gYSlpZighYi5jYWxsKHZvaWQgMCxhW2NdLGMsYSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gSmIoYSl7dmFyIGI9MCxjO2ZvcihjIGluIGEpYisrO3JldHVybiBifWZ1bmN0aW9uIEtiKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiBifWZ1bmN0aW9uIEpkKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWFbZF07cmV0dXJuIGJ9ZnVuY3Rpb24gS2QoYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109ZDtyZXR1cm4gYn1mdW5jdGlvbiB6ZChhLGIpe2Zvcih2YXIgYyBpbiBhKWlmKGFbY109PWIpcmV0dXJuITA7cmV0dXJuITF9XG5mdW5jdGlvbiBMZChhLGIsYyl7Zm9yKHZhciBkIGluIGEpaWYoYi5jYWxsKGMsYVtkXSxkLGEpKXJldHVybiBkfWZ1bmN0aW9uIE1kKGEsYil7dmFyIGM9TGQoYSxiLHZvaWQgMCk7cmV0dXJuIGMmJmFbY119ZnVuY3Rpb24gTmQoYSl7Zm9yKHZhciBiIGluIGEpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gT2QoYSxiKXtyZXR1cm4gYiBpbiBhP2FbYl06dm9pZCAwfWZ1bmN0aW9uIEFkKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSliW2NdPWFbY107cmV0dXJuIGJ9dmFyIFBkPVwiY29uc3RydWN0b3IgaGFzT3duUHJvcGVydHkgaXNQcm90b3R5cGVPZiBwcm9wZXJ0eUlzRW51bWVyYWJsZSB0b0xvY2FsZVN0cmluZyB0b1N0cmluZyB2YWx1ZU9mXCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gUWQoYSxiKXtmb3IodmFyIGMsZCxlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7ZD1hcmd1bWVudHNbZV07Zm9yKGMgaW4gZClhW2NdPWRbY107Zm9yKHZhciBmPTA7ZjxQZC5sZW5ndGg7ZisrKWM9UGRbZl0sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsYykmJihhW2NdPWRbY10pfX07ZnVuY3Rpb24gUmQoKXt0aGlzLnRjPXt9fWZ1bmN0aW9uIFNkKGEsYixjKXttKGMpfHwoYz0xKTtzKGEudGMsYil8fChhLnRjW2JdPTApO2EudGNbYl0rPWN9UmQucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3JldHVybiBBZCh0aGlzLnRjKX07ZnVuY3Rpb24gVGQoYSl7dGhpcy5QZj1hO3RoaXMucmQ9bnVsbH1UZC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5QZi5nZXQoKSxiPUFkKGEpO2lmKHRoaXMucmQpZm9yKHZhciBjIGluIHRoaXMucmQpYltjXS09dGhpcy5yZFtjXTt0aGlzLnJkPWE7cmV0dXJuIGJ9O2Z1bmN0aW9uIFVkKGEsYil7dGhpcy56Zj17fTt0aGlzLlBkPW5ldyBUZChhKTt0aGlzLlM9Yjt2YXIgYz0xRTQrMkU0Kk1hdGgucmFuZG9tKCk7c2V0VGltZW91dChxKHRoaXMudGYsdGhpcyksTWF0aC5mbG9vcihjKSl9VWQucHJvdG90eXBlLnRmPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5QZC5nZXQoKSxiPXt9LGM9ITEsZDtmb3IoZCBpbiBhKTA8YVtkXSYmcyh0aGlzLnpmLGQpJiYoYltkXT1hW2RdLGM9ITApO2MmJihhPXRoaXMuUyxhLmphJiYoYj17YzpifSxhLmYoXCJyZXBvcnRTdGF0c1wiLGIpLGEuQ2EoXCJzXCIsYikpKTtzZXRUaW1lb3V0KHEodGhpcy50Zix0aGlzKSxNYXRoLmZsb29yKDZFNSpNYXRoLnJhbmRvbSgpKSl9O3ZhciBWZD17fSxXZD17fTtmdW5jdGlvbiBYZChhKXthPWEudG9TdHJpbmcoKTtWZFthXXx8KFZkW2FdPW5ldyBSZCk7cmV0dXJuIFZkW2FdfWZ1bmN0aW9uIFlkKGEsYil7dmFyIGM9YS50b1N0cmluZygpO1dkW2NdfHwoV2RbY109YigpKTtyZXR1cm4gV2RbY119O3ZhciBaZD1udWxsO1widW5kZWZpbmVkXCIhPT10eXBlb2YgTW96V2ViU29ja2V0P1pkPU1veldlYlNvY2tldDpcInVuZGVmaW5lZFwiIT09dHlwZW9mIFdlYlNvY2tldCYmKFpkPVdlYlNvY2tldCk7ZnVuY3Rpb24gJGQoYSxiLGMpe3RoaXMuaWU9YTt0aGlzLmY9b2IodGhpcy5pZSk7dGhpcy5mcmFtZXM9dGhpcy5DYz1udWxsO3RoaXMuaWI9dGhpcy5qYj10aGlzLlRlPTA7dGhpcy5SYT1YZChiKTt0aGlzLiRhPShiLkFiP1wid3NzOi8vXCI6XCJ3czovL1wiKStiLk1hK1wiLy53cz92PTVcIjtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGxvY2F0aW9uJiZsb2NhdGlvbi5ocmVmJiYtMSE9PWxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImZpcmViYXNlaW8uY29tXCIpJiYodGhpcy4kYSs9XCImcj1mXCIpO2IuaG9zdCE9PWIuTWEmJih0aGlzLiRhPXRoaXMuJGErXCImbnM9XCIrYi50Yik7YyYmKHRoaXMuJGE9dGhpcy4kYStcIiZzPVwiK2MpfXZhciBhZTtcbiRkLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7dGhpcy5mYj1iO3RoaXMuaGc9YTt0aGlzLmYoXCJXZWJzb2NrZXQgY29ubmVjdGluZyB0byBcIit0aGlzLiRhKTt0aGlzLnhjPSExO3phLnNldChcInByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlXCIsITApO3RyeXt0aGlzLnRhPW5ldyBaZCh0aGlzLiRhKX1jYXRjaChjKXt0aGlzLmYoXCJFcnJvciBpbnN0YW50aWF0aW5nIFdlYlNvY2tldC5cIik7dmFyIGQ9Yy5tZXNzYWdlfHxjLmRhdGE7ZCYmdGhpcy5mKGQpO3RoaXMuZWIoKTtyZXR1cm59dmFyIGU9dGhpczt0aGlzLnRhLm9ub3Blbj1mdW5jdGlvbigpe2UuZihcIldlYnNvY2tldCBjb25uZWN0ZWQuXCIpO2UueGM9ITB9O3RoaXMudGEub25jbG9zZT1mdW5jdGlvbigpe2UuZihcIldlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkaXNjb25uZWN0ZWQuXCIpO2UudGE9bnVsbDtlLmViKCl9O3RoaXMudGEub25tZXNzYWdlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPT1lLnRhKWlmKGE9YS5kYXRhLGUuaWIrPVxuYS5sZW5ndGgsU2QoZS5SYSxcImJ5dGVzX3JlY2VpdmVkXCIsYS5sZW5ndGgpLGJlKGUpLG51bGwhPT1lLmZyYW1lcyljZShlLGEpO2Vsc2V7YTp7eShudWxsPT09ZS5mcmFtZXMsXCJXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXJcIik7aWYoNj49YS5sZW5ndGgpe3ZhciBiPU51bWJlcihhKTtpZighaXNOYU4oYikpe2UuVGU9YjtlLmZyYW1lcz1bXTthPW51bGw7YnJlYWsgYX19ZS5UZT0xO2UuZnJhbWVzPVtdfW51bGwhPT1hJiZjZShlLGEpfX07dGhpcy50YS5vbmVycm9yPWZ1bmN0aW9uKGEpe2UuZihcIldlYlNvY2tldCBlcnJvci4gIENsb3NpbmcgY29ubmVjdGlvbi5cIik7KGE9YS5tZXNzYWdlfHxhLmRhdGEpJiZlLmYoYSk7ZS5lYigpfX07JGQucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7fTtcbiRkLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7dmFyIGE9ITE7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQpe3ZhciBiPW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQgKFswLTldezAsfVxcLlswLTldezAsfSkvKTtiJiYxPGIubGVuZ3RoJiY0LjQ+cGFyc2VGbG9hdChiWzFdKSYmKGE9ITApfXJldHVybiFhJiZudWxsIT09WmQmJiFhZX07JGQucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeT0yOyRkLmhlYWx0aHlUaW1lb3V0PTNFNDtoPSRkLnByb3RvdHlwZTtoLnNkPWZ1bmN0aW9uKCl7emEucmVtb3ZlKFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIil9O2Z1bmN0aW9uIGNlKGEsYil7YS5mcmFtZXMucHVzaChiKTtpZihhLmZyYW1lcy5sZW5ndGg9PWEuVGUpe3ZhciBjPWEuZnJhbWVzLmpvaW4oXCJcIik7YS5mcmFtZXM9bnVsbDtjPXRhKGMpO2EuaGcoYyl9fVxuaC5zZW5kPWZ1bmN0aW9uKGEpe2JlKHRoaXMpO2E9cihhKTt0aGlzLmpiKz1hLmxlbmd0aDtTZCh0aGlzLlJhLFwiYnl0ZXNfc2VudFwiLGEubGVuZ3RoKTthPXliKGEsMTYzODQpOzE8YS5sZW5ndGgmJnRoaXMudGEuc2VuZChTdHJpbmcoYS5sZW5ndGgpKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLnRhLnNlbmQoYVtiXSl9O2guVWM9ZnVuY3Rpb24oKXt0aGlzLnFiPSEwO3RoaXMuQ2MmJihjbGVhckludGVydmFsKHRoaXMuQ2MpLHRoaXMuQ2M9bnVsbCk7dGhpcy50YSYmKHRoaXMudGEuY2xvc2UoKSx0aGlzLnRhPW51bGwpfTtoLmViPWZ1bmN0aW9uKCl7dGhpcy5xYnx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBjbG9zaW5nIGl0c2VsZlwiKSx0aGlzLlVjKCksdGhpcy5mYiYmKHRoaXMuZmIodGhpcy54YyksdGhpcy5mYj1udWxsKSl9O2guY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnFifHwodGhpcy5mKFwiV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZFwiKSx0aGlzLlVjKCkpfTtcbmZ1bmN0aW9uIGJlKGEpe2NsZWFySW50ZXJ2YWwoYS5DYyk7YS5DYz1zZXRJbnRlcnZhbChmdW5jdGlvbigpe2EudGEmJmEudGEuc2VuZChcIjBcIik7YmUoYSl9LE1hdGguZmxvb3IoNDVFMykpfTtmdW5jdGlvbiBkZShhKXt0aGlzLiRiPWE7dGhpcy5DZD1bXTt0aGlzLkpiPTA7dGhpcy5nZT0tMTt0aGlzLndiPW51bGx9ZnVuY3Rpb24gZWUoYSxiLGMpe2EuZ2U9YjthLndiPWM7YS5nZTxhLkpiJiYoYS53YigpLGEud2I9bnVsbCl9ZnVuY3Rpb24gZmUoYSxiLGMpe2ZvcihhLkNkW2JdPWM7YS5DZFthLkpiXTspe3ZhciBkPWEuQ2RbYS5KYl07ZGVsZXRlIGEuQ2RbYS5KYl07Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDsrK2UpaWYoZFtlXSl7dmFyIGY9YTtDYihmdW5jdGlvbigpe2YuJGIoZFtlXSl9KX1pZihhLkpiPT09YS5nZSl7YS53YiYmKGNsZWFyVGltZW91dChhLndiKSxhLndiKCksYS53Yj1udWxsKTticmVha31hLkpiKyt9fTtmdW5jdGlvbiBnZSgpe3RoaXMuc2V0PXt9fWg9Z2UucHJvdG90eXBlO2guYWRkPWZ1bmN0aW9uKGEsYil7dGhpcy5zZXRbYV09bnVsbCE9PWI/YjohMH07aC5jb250YWlucz1mdW5jdGlvbihhKXtyZXR1cm4gcyh0aGlzLnNldCxhKX07aC5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuY29udGFpbnMoYSk/dGhpcy5zZXRbYV06dm9pZCAwfTtoLnJlbW92ZT1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5zZXRbYV19O2guY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLnNldD17fX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIE5kKHRoaXMuc2V0KX07aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiBKYih0aGlzLnNldCl9O2Z1bmN0aW9uIGhlKGEsYil7QShhLnNldCxmdW5jdGlvbihhLGQpe2IoZCxhKX0pfTtmdW5jdGlvbiBpZShhLGIsYyl7dGhpcy5pZT1hO3RoaXMuZj1vYihhKTt0aGlzLmliPXRoaXMuamI9MDt0aGlzLlJhPVhkKGIpO3RoaXMuTWQ9Yzt0aGlzLnhjPSExO3RoaXMuWmM9ZnVuY3Rpb24oYSl7Yi5ob3N0IT09Yi5NYSYmKGEubnM9Yi50Yik7dmFyIGM9W10sZjtmb3IoZiBpbiBhKWEuaGFzT3duUHJvcGVydHkoZikmJmMucHVzaChmK1wiPVwiK2FbZl0pO3JldHVybihiLkFiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrYi5NYStcIi8ubHA/XCIrYy5qb2luKFwiJlwiKX19dmFyIGplLGtlO1xuaWUucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiKXt0aGlzLlplPTA7dGhpcy5nYT1iO3RoaXMubWY9bmV3IGRlKGEpO3RoaXMucWI9ITE7dmFyIGM9dGhpczt0aGlzLmxiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtjLmYoXCJUaW1lZCBvdXQgdHJ5aW5nIHRvIGNvbm5lY3QuXCIpO2MuZWIoKTtjLmxiPW51bGx9LE1hdGguZmxvb3IoM0U0KSk7dGIoZnVuY3Rpb24oKXtpZighYy5xYil7Yy5QYT1uZXcgbGUoZnVuY3Rpb24oYSxiLGQsayxsKXttZShjLGFyZ3VtZW50cyk7aWYoYy5QYSlpZihjLmxiJiYoY2xlYXJUaW1lb3V0KGMubGIpLGMubGI9bnVsbCksYy54Yz0hMCxcInN0YXJ0XCI9PWEpYy5pZD1iLGMucmY9ZDtlbHNlIGlmKFwiY2xvc2VcIj09PWEpYj8oYy5QYS5LZD0hMSxlZShjLm1mLGIsZnVuY3Rpb24oKXtjLmViKCl9KSk6Yy5lYigpO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbnJlY29nbml6ZWQgY29tbWFuZCByZWNlaXZlZDogXCIrYSk7fSxmdW5jdGlvbihhLGIpe21lKGMsYXJndW1lbnRzKTtcbmZlKGMubWYsYSxiKX0sZnVuY3Rpb24oKXtjLmViKCl9LGMuWmMpO3ZhciBhPXtzdGFydDpcInRcIn07YS5zZXI9TWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7Yy5QYS5XZCYmKGEuY2I9Yy5QYS5XZCk7YS52PVwiNVwiO2MuTWQmJihhLnM9Yy5NZCk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsb2NhdGlvbiYmbG9jYXRpb24uaHJlZiYmLTEhPT1sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJmaXJlYmFzZWlvLmNvbVwiKSYmKGEucj1cImZcIik7YT1jLlpjKGEpO2MuZihcIkNvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byBcIithKTtuZShjLlBhLGEsZnVuY3Rpb24oKXt9KX19KX07XG5pZS5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLlBhLGI9dGhpcy5yZjthLmNnPXRoaXMuaWQ7YS5kZz1iO2ZvcihhLmFlPSEwO29lKGEpOyk7YT10aGlzLmlkO2I9dGhpcy5yZjt0aGlzLlliPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7dmFyIGM9e2RmcmFtZTpcInRcIn07Yy5pZD1hO2MucHc9Yjt0aGlzLlliLnNyYz10aGlzLlpjKGMpO3RoaXMuWWIuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuWWIpfTtpZS5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVybiFrZSYmIShcIm9iamVjdFwiPT09dHlwZW9mIHdpbmRvdyYmd2luZG93LmNocm9tZSYmd2luZG93LmNocm9tZS5leHRlbnNpb24mJiEvXmNocm9tZS8udGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZikpJiYhKFwib2JqZWN0XCI9PT10eXBlb2YgV2luZG93cyYmXCJvYmplY3RcIj09PXR5cGVvZiBXaW5kb3dzLkVnKSYmKGplfHwhMCl9O2g9aWUucHJvdG90eXBlO1xuaC5zZD1mdW5jdGlvbigpe307aC5VYz1mdW5jdGlvbigpe3RoaXMucWI9ITA7dGhpcy5QYSYmKHRoaXMuUGEuY2xvc2UoKSx0aGlzLlBhPW51bGwpO3RoaXMuWWImJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuWWIpLHRoaXMuWWI9bnVsbCk7dGhpcy5sYiYmKGNsZWFyVGltZW91dCh0aGlzLmxiKSx0aGlzLmxiPW51bGwpfTtoLmViPWZ1bmN0aW9uKCl7dGhpcy5xYnx8KHRoaXMuZihcIkxvbmdwb2xsIGlzIGNsb3NpbmcgaXRzZWxmXCIpLHRoaXMuVWMoKSx0aGlzLmdhJiYodGhpcy5nYSh0aGlzLnhjKSx0aGlzLmdhPW51bGwpKX07aC5jbG9zZT1mdW5jdGlvbigpe3RoaXMucWJ8fCh0aGlzLmYoXCJMb25ncG9sbCBpcyBiZWluZyBjbG9zZWQuXCIpLHRoaXMuVWMoKSl9O1xuaC5zZW5kPWZ1bmN0aW9uKGEpe2E9cihhKTt0aGlzLmpiKz1hLmxlbmd0aDtTZCh0aGlzLlJhLFwiYnl0ZXNfc2VudFwiLGEubGVuZ3RoKTthPWpiKGEpO2E9Y2IoYSwhMCk7YT15YihhLDE4NDApO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz10aGlzLlBhO2MuUWMucHVzaCh7dGc6dGhpcy5aZSxCZzphLmxlbmd0aCxhZjphW2JdfSk7Yy5hZSYmb2UoYyk7dGhpcy5aZSsrfX07ZnVuY3Rpb24gbWUoYSxiKXt2YXIgYz1yKGIpLmxlbmd0aDthLmliKz1jO1NkKGEuUmEsXCJieXRlc19yZWNlaXZlZFwiLGMpfVxuZnVuY3Rpb24gbGUoYSxiLGMsZCl7dGhpcy5aYz1kO3RoaXMuZmI9Yzt0aGlzLkllPW5ldyBnZTt0aGlzLlFjPVtdO3RoaXMua2U9TWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7dGhpcy5LZD0hMDt0aGlzLldkPWViKCk7d2luZG93W1wicExQQ29tbWFuZFwiK3RoaXMuV2RdPWE7d2luZG93W1wicFJUTFBDQlwiK3RoaXMuV2RdPWI7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtpZihkb2N1bWVudC5ib2R5KXtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO3RyeXthLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnR8fGhiKFwiTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWRcIil9Y2F0Y2goZSl7YS5zcmM9XCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIrZG9jdW1lbnQuZG9tYWluK1wiJztkb2N1bWVudC5jbG9zZSgpO30pKCkpXCJ9fWVsc2UgdGhyb3dcIkRvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS5cIjtcbmEuY29udGVudERvY3VtZW50P2EuYWI9YS5jb250ZW50RG9jdW1lbnQ6YS5jb250ZW50V2luZG93P2EuYWI9YS5jb250ZW50V2luZG93LmRvY3VtZW50OmEuZG9jdW1lbnQmJihhLmFiPWEuZG9jdW1lbnQpO3RoaXMuQmE9YTthPVwiXCI7dGhpcy5CYS5zcmMmJlwiamF2YXNjcmlwdDpcIj09PXRoaXMuQmEuc3JjLnN1YnN0cigwLDExKSYmKGE9JzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJytkb2N1bWVudC5kb21haW4rJ1wiO1xceDNjL3NjcmlwdD4nKTthPVwiPGh0bWw+PGJvZHk+XCIrYStcIjwvYm9keT48L2h0bWw+XCI7dHJ5e3RoaXMuQmEuYWIub3BlbigpLHRoaXMuQmEuYWIud3JpdGUoYSksdGhpcy5CYS5hYi5jbG9zZSgpfWNhdGNoKGYpe2hiKFwiZnJhbWUgd3JpdGluZyBleGNlcHRpb25cIiksZi5zdGFjayYmaGIoZi5zdGFjayksaGIoZil9fVxubGUucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5hZT0hMTtpZih0aGlzLkJhKXt0aGlzLkJhLmFiLmJvZHkuaW5uZXJIVE1MPVwiXCI7dmFyIGE9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bnVsbCE9PWEuQmEmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEuQmEpLGEuQmE9bnVsbCl9LE1hdGguZmxvb3IoMCkpfXZhciBiPXRoaXMuZmI7YiYmKHRoaXMuZmI9bnVsbCxiKCkpfTtcbmZ1bmN0aW9uIG9lKGEpe2lmKGEuYWUmJmEuS2QmJmEuSWUuY291bnQoKTwoMDxhLlFjLmxlbmd0aD8yOjEpKXthLmtlKys7dmFyIGI9e307Yi5pZD1hLmNnO2IucHc9YS5kZztiLnNlcj1hLmtlO2Zvcih2YXIgYj1hLlpjKGIpLGM9XCJcIixkPTA7MDxhLlFjLmxlbmd0aDspaWYoMTg3MD49YS5RY1swXS5hZi5sZW5ndGgrMzArYy5sZW5ndGgpe3ZhciBlPWEuUWMuc2hpZnQoKSxjPWMrXCImc2VnXCIrZCtcIj1cIitlLnRnK1wiJnRzXCIrZCtcIj1cIitlLkJnK1wiJmRcIitkK1wiPVwiK2UuYWY7ZCsrfWVsc2UgYnJlYWs7cGUoYSxiK2MsYS5rZSk7cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gcGUoYSxiLGMpe2Z1bmN0aW9uIGQoKXthLkllLnJlbW92ZShjKTtvZShhKX1hLkllLmFkZChjKTt2YXIgZT1zZXRUaW1lb3V0KGQsTWF0aC5mbG9vcigyNUUzKSk7bmUoYSxiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUpO2QoKX0pfVxuZnVuY3Rpb24gbmUoYSxiLGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0cnl7aWYoYS5LZCl7dmFyIGQ9YS5CYS5hYi5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2QudHlwZT1cInRleHQvamF2YXNjcmlwdFwiO2QuYXN5bmM9ITA7ZC5zcmM9YjtkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe3ZhciBhPWQucmVhZHlTdGF0ZTthJiZcImxvYWRlZFwiIT09YSYmXCJjb21wbGV0ZVwiIT09YXx8KGQub25sb2FkPWQub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsZC5wYXJlbnROb2RlJiZkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksYygpKX07ZC5vbmVycm9yPWZ1bmN0aW9uKCl7aGIoXCJMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiBcIitiKTthLktkPSExO2EuY2xvc2UoKX07YS5CYS5hYi5ib2R5LmFwcGVuZENoaWxkKGQpfX1jYXRjaChlKXt9fSxNYXRoLmZsb29yKDEpKX07ZnVuY3Rpb24gcWUoYSl7cmUodGhpcyxhKX12YXIgc2U9W2llLCRkXTtmdW5jdGlvbiByZShhLGIpe3ZhciBjPSRkJiYkZC5pc0F2YWlsYWJsZSgpLGQ9YyYmISh6YS5sZnx8ITA9PT16YS5nZXQoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiKSk7Yi5EZyYmKGN8fHooXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpLGQ9ITApO2lmKGQpYS5YYz1bJGRdO2Vsc2V7dmFyIGU9YS5YYz1bXTt6YihzZSxmdW5jdGlvbihhLGIpe2ImJmIuaXNBdmFpbGFibGUoKSYmZS5wdXNoKGIpfSl9fWZ1bmN0aW9uIHRlKGEpe2lmKDA8YS5YYy5sZW5ndGgpcmV0dXJuIGEuWGNbMF07dGhyb3cgRXJyb3IoXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTt9O2Z1bmN0aW9uIHVlKGEsYixjLGQsZSxmKXt0aGlzLmlkPWE7dGhpcy5mPW9iKFwiYzpcIit0aGlzLmlkK1wiOlwiKTt0aGlzLiRiPWM7dGhpcy5LYz1kO3RoaXMuZ2E9ZTt0aGlzLkdlPWY7dGhpcy5PPWI7dGhpcy5CZD1bXTt0aGlzLlhlPTA7dGhpcy5BZj1uZXcgcWUoYik7dGhpcy5RYT0wO3RoaXMuZihcIkNvbm5lY3Rpb24gY3JlYXRlZFwiKTt2ZSh0aGlzKX1cbmZ1bmN0aW9uIHZlKGEpe3ZhciBiPXRlKGEuQWYpO2EuSj1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLlhlKyssYS5PKTthLktlPWIucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeXx8MDt2YXIgYz13ZShhLGEuSiksZD14ZShhLGEuSik7YS5ZYz1hLko7YS5UYz1hLko7YS5CPW51bGw7YS5yYj0hMTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5KJiZhLkoub3BlbihjLGQpfSxNYXRoLmZsb29yKDApKTtiPWIuaGVhbHRoeVRpbWVvdXR8fDA7MDxiJiYoYS5uZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5uZD1udWxsO2EucmJ8fChhLkomJjEwMjQwMDxhLkouaWI/KGEuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgcmVjZWl2ZWQgXCIrYS5KLmliK1wiIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuXCIpLGEucmI9ITAsYS5KLnNkKCkpOmEuSiYmMTAyNDA8YS5KLmpiP2EuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCBcIitcbmEuSi5qYitcIiBieXRlcy4gIExlYXZpbmcgY29ubmVjdGlvbiBhbGl2ZS5cIik6KGEuZihcIkNsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC5cIiksYS5jbG9zZSgpKSl9LE1hdGguZmxvb3IoYikpKX1mdW5jdGlvbiB4ZShhLGIpe3JldHVybiBmdW5jdGlvbihjKXtiPT09YS5KPyhhLko9bnVsbCxjfHwwIT09YS5RYT8xPT09YS5RYSYmYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBsb3N0LlwiKTooYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuXCIpLFwicy1cIj09PWEuTy5NYS5zdWJzdHIoMCwyKSYmKHphLnJlbW92ZShcImhvc3Q6XCIrYS5PLmhvc3QpLGEuTy5NYT1hLk8uaG9zdCkpLGEuY2xvc2UoKSk6Yj09PWEuQj8oYS5mKFwiU2Vjb25kYXJ5IGNvbm5lY3Rpb24gbG9zdC5cIiksYz1hLkIsYS5CPW51bGwsYS5ZYyE9PWMmJmEuVGMhPT1jfHxhLmNsb3NlKCkpOmEuZihcImNsb3NpbmcgYW4gb2xkIGNvbm5lY3Rpb25cIil9fVxuZnVuY3Rpb24gd2UoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoMiE9YS5RYSlpZihiPT09YS5UYyl7dmFyIGQ9d2IoXCJ0XCIsYyk7Yz13YihcImRcIixjKTtpZihcImNcIj09ZCl7aWYoZD13YihcInRcIixjKSxcImRcImluIGMpaWYoYz1jLmQsXCJoXCI9PT1kKXt2YXIgZD1jLnRzLGU9Yy52LGY9Yy5oO2EuTWQ9Yy5zO0JhKGEuTyxmKTswPT1hLlFhJiYoYS5KLnN0YXJ0KCkseWUoYSxhLkosZCksXCI1XCIhPT1lJiZ6KFwiUHJvdG9jb2wgdmVyc2lvbiBtaXNtYXRjaCBkZXRlY3RlZFwiKSxjPWEuQWYsKGM9MTxjLlhjLmxlbmd0aD9jLlhjWzFdOm51bGwpJiZ6ZShhLGMpKX1lbHNlIGlmKFwiblwiPT09ZCl7YS5mKFwicmVjdmQgZW5kIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5XCIpO2EuVGM9YS5CO2ZvcihjPTA7YzxhLkJkLmxlbmd0aDsrK2MpYS54ZChhLkJkW2NdKTthLkJkPVtdO0FlKGEpfWVsc2VcInNcIj09PWQ/KGEuZihcIkNvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLlwiKSxcbmEuR2UmJihhLkdlKGMpLGEuR2U9bnVsbCksYS5nYT1udWxsLGEuY2xvc2UoKSk6XCJyXCI9PT1kPyhhLmYoXCJSZXNldCBwYWNrZXQgcmVjZWl2ZWQuICBOZXcgaG9zdDogXCIrYyksQmEoYS5PLGMpLDE9PT1hLlFhP2EuY2xvc2UoKTooQmUoYSksdmUoYSkpKTpcImVcIj09PWQ/cGIoXCJTZXJ2ZXIgRXJyb3I6IFwiK2MpOlwib1wiPT09ZD8oYS5mKFwiZ290IHBvbmcgb24gcHJpbWFyeS5cIiksQ2UoYSksRGUoYSkpOnBiKFwiVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiBcIitkKX1lbHNlXCJkXCI9PWQmJmEueGQoYyl9ZWxzZSBpZihiPT09YS5CKWlmKGQ9d2IoXCJ0XCIsYyksYz13YihcImRcIixjKSxcImNcIj09ZClcInRcImluIGMmJihjPWMudCxcImFcIj09PWM/RWUoYSk6XCJyXCI9PT1jPyhhLmYoXCJHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXRcIiksYS5CLmNsb3NlKCksYS5ZYyE9PWEuQiYmYS5UYyE9PWEuQnx8YS5jbG9zZSgpKTpcIm9cIj09PWMmJihhLmYoXCJnb3QgcG9uZyBvbiBzZWNvbmRhcnkuXCIpLFxuYS55Zi0tLEVlKGEpKSk7ZWxzZSBpZihcImRcIj09ZClhLkJkLnB1c2goYyk7ZWxzZSB0aHJvdyBFcnJvcihcIlVua25vd24gcHJvdG9jb2wgbGF5ZXI6IFwiK2QpO2Vsc2UgYS5mKFwibWVzc2FnZSBvbiBvbGQgY29ubmVjdGlvblwiKX19dWUucHJvdG90eXBlLkNhPWZ1bmN0aW9uKGEpe0ZlKHRoaXMse3Q6XCJkXCIsZDphfSl9O2Z1bmN0aW9uIEFlKGEpe2EuWWM9PT1hLkImJmEuVGM9PT1hLkImJihhLmYoXCJjbGVhbmluZyB1cCBhbmQgcHJvbW90aW5nIGEgY29ubmVjdGlvbjogXCIrYS5CLmllKSxhLko9YS5CLGEuQj1udWxsKX1cbmZ1bmN0aW9uIEVlKGEpezA+PWEueWY/KGEuZihcIlNlY29uZGFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXCIpLGEucmI9ITAsYS5CLnNkKCksYS5CLnN0YXJ0KCksYS5mKFwic2VuZGluZyBjbGllbnQgYWNrIG9uIHNlY29uZGFyeVwiKSxhLkIuc2VuZCh7dDpcImNcIixkOnt0OlwiYVwiLGQ6e319fSksYS5mKFwiRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5XCIpLGEuSi5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJuXCIsZDp7fX19KSxhLlljPWEuQixBZShhKSk6KGEuZihcInNlbmRpbmcgcGluZyBvbiBzZWNvbmRhcnkuXCIpLGEuQi5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJwXCIsZDp7fX19KSl9dWUucHJvdG90eXBlLnhkPWZ1bmN0aW9uKGEpe0NlKHRoaXMpO3RoaXMuJGIoYSl9O2Z1bmN0aW9uIENlKGEpe2EucmJ8fChhLktlLS0sMD49YS5LZSYmKGEuZihcIlByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLnJiPSEwLGEuSi5zZCgpKSl9XG5mdW5jdGlvbiB6ZShhLGIpe2EuQj1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLlhlKyssYS5PLGEuTWQpO2EueWY9Yi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5fHwwO2EuQi5vcGVuKHdlKGEsYS5CKSx4ZShhLGEuQikpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLkImJihhLmYoXCJUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuXCIpLGEuQi5jbG9zZSgpKX0sTWF0aC5mbG9vcig2RTQpKX1mdW5jdGlvbiB5ZShhLGIsYyl7YS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC5cIik7YS5KPWI7YS5RYT0xO2EuS2MmJihhLktjKGMpLGEuS2M9bnVsbCk7MD09PWEuS2U/KGEuZihcIlByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLnJiPSEwKTpzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7RGUoYSl9LE1hdGguZmxvb3IoNUUzKSl9XG5mdW5jdGlvbiBEZShhKXthLnJifHwxIT09YS5RYXx8KGEuZihcInNlbmRpbmcgcGluZyBvbiBwcmltYXJ5LlwiKSxGZShhLHt0OlwiY1wiLGQ6e3Q6XCJwXCIsZDp7fX19KSl9ZnVuY3Rpb24gRmUoYSxiKXtpZigxIT09YS5RYSl0aHJvd1wiQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkXCI7YS5ZYy5zZW5kKGIpfXVlLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpezIhPT10aGlzLlFhJiYodGhpcy5mKFwiQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLlwiKSx0aGlzLlFhPTIsQmUodGhpcyksdGhpcy5nYSYmKHRoaXMuZ2EoKSx0aGlzLmdhPW51bGwpKX07ZnVuY3Rpb24gQmUoYSl7YS5mKFwiU2h1dHRpbmcgZG93biBhbGwgY29ubmVjdGlvbnNcIik7YS5KJiYoYS5KLmNsb3NlKCksYS5KPW51bGwpO2EuQiYmKGEuQi5jbG9zZSgpLGEuQj1udWxsKTthLm5kJiYoY2xlYXJUaW1lb3V0KGEubmQpLGEubmQ9bnVsbCl9O2Z1bmN0aW9uIEdlKGEpe3ZhciBiPXt9LGM9e30sZD17fSxlPVwiXCI7dHJ5e3ZhciBmPWEuc3BsaXQoXCIuXCIpLGI9dGEoZ2IoZlswXSl8fFwiXCIpLGM9dGEoZ2IoZlsxXSl8fFwiXCIpLGU9ZlsyXSxkPWMuZHx8e307ZGVsZXRlIGMuZH1jYXRjaChnKXt9cmV0dXJue0dnOmIsZmU6YyxkYXRhOmQseGc6ZX19ZnVuY3Rpb24gSGUoYSl7YT1HZShhKS5mZTtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJmEuaGFzT3duUHJvcGVydHkoXCJpYXRcIik/dChhLFwiaWF0XCIpOm51bGx9ZnVuY3Rpb24gSWUoYSl7YT1HZShhKTt2YXIgYj1hLmZlO3JldHVybiEhYS54ZyYmISFiJiZcIm9iamVjdFwiPT09dHlwZW9mIGImJmIuaGFzT3duUHJvcGVydHkoXCJpYXRcIil9O2Z1bmN0aW9uIEplKGEsYixjLGQpe3RoaXMuaWQ9S2UrKzt0aGlzLmY9b2IoXCJwOlwiK3RoaXMuaWQrXCI6XCIpO3RoaXMuQ2I9ITA7dGhpcy5BYT17fTt0aGlzLmxhPVtdO3RoaXMuTmM9MDt0aGlzLkpjPVtdO3RoaXMuamE9ITE7dGhpcy5XYT0xRTM7dGhpcy50ZD0zRTU7dGhpcy55ZD1iO3RoaXMud2Q9Yzt0aGlzLkhlPWQ7dGhpcy5PPWE7dGhpcy5PZT1udWxsO3RoaXMuU2M9e307dGhpcy5zZz0wO3RoaXMuRGM9dGhpcy53ZT1udWxsO0xlKHRoaXMsMCk7SGQuTmIoKS52YihcInZpc2libGVcIix0aGlzLmtnLHRoaXMpOy0xPT09YS5ob3N0LmluZGV4T2YoXCJmYmxvY2FsXCIpJiZJZC5OYigpLnZiKFwib25saW5lXCIsdGhpcy5pZyx0aGlzKX12YXIgS2U9MCxNZT0wO2g9SmUucHJvdG90eXBlO1xuaC5DYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Kyt0aGlzLnNnO2E9e3I6ZCxhOmEsYjpifTt0aGlzLmYocihhKSk7eSh0aGlzLmphLFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO3RoaXMuT2EuQ2EoYSk7YyYmKHRoaXMuU2NbZF09Yyl9O2Z1bmN0aW9uIE5lKGEsYixjLGQsZSl7dmFyIGY9Yi5GYSgpLGc9Yi5wYXRoLnRvU3RyaW5nKCk7YS5mKFwiTGlzdGVuIGNhbGxlZCBmb3IgXCIrZytcIiBcIitmKTthLkFhW2ddPWEuQWFbZ118fHt9O3koIWEuQWFbZ11bZl0sXCJsaXN0ZW4oKSBjYWxsZWQgdHdpY2UgZm9yIHNhbWUgcGF0aC9xdWVyeUlkLlwiKTtiPXtIOmUsbWQ6YyxwZzpJYyhiLm4pLHRhZzpkfTthLkFhW2ddW2ZdPWI7YS5qYSYmT2UoYSxnLGYsYil9XG5mdW5jdGlvbiBPZShhLGIsYyxkKXthLmYoXCJMaXN0ZW4gb24gXCIrYitcIiBmb3IgXCIrYyk7dmFyIGU9e3A6Yn07ZC50YWcmJihlLnE9ZC5wZyxlLnQ9ZC50YWcpO2UuaD1kLm1kKCk7YS5DYShcInFcIixlLGZ1bmN0aW9uKGUpe2lmKChhLkFhW2JdJiZhLkFhW2JdW2NdKT09PWQpe2EuZihcImxpc3RlbiByZXNwb25zZVwiLGUpO3ZhciBnPWUucztcIm9rXCIhPT1nJiZQZShhLGIsYyk7ZT1lLmQ7ZC5IJiZkLkgoZyxlKX19KX1oLlE9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuSWI9e1JmOmEsY2Y6ITEscWM6YixhZDpjfTt0aGlzLmYoXCJBdXRoZW50aWNhdGluZyB1c2luZyBjcmVkZW50aWFsOiBcIithKTtRZSh0aGlzKTsoYj00MD09YS5sZW5ndGgpfHwoYT1HZShhKS5mZSxiPVwib2JqZWN0XCI9PT10eXBlb2YgYSYmITA9PT10KGEsXCJhZG1pblwiKSk7YiYmKHRoaXMuZihcIkFkbWluIGF1dGggY3JlZGVudGlhbCBkZXRlY3RlZC4gIFJlZHVjaW5nIG1heCByZWNvbm5lY3QgdGltZS5cIiksdGhpcy50ZD0zRTQpfTtcbmguVWU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuSWI7dGhpcy5qYSYmdGhpcy5DYShcInVuYXV0aFwiLHt9LGZ1bmN0aW9uKGIpe2EoYi5zLGIuZCl9KX07ZnVuY3Rpb24gUWUoYSl7dmFyIGI9YS5JYjthLmphJiZiJiZhLkNhKFwiYXV0aFwiLHtjcmVkOmIuUmZ9LGZ1bmN0aW9uKGMpe3ZhciBkPWMucztjPWMuZHx8XCJlcnJvclwiO1wib2tcIiE9PWQmJmEuSWI9PT1iJiZkZWxldGUgYS5JYjtiLmNmP1wib2tcIiE9PWQmJmIuYWQmJmIuYWQoZCxjKTooYi5jZj0hMCxiLnFjJiZiLnFjKGQsYykpfSl9ZnVuY3Rpb24gUmUoYSxiLGMsZCl7YS5qYT9TZShhLFwib1wiLGIsYyxkKTphLkpjLnB1c2goe1BjOmIsYWN0aW9uOlwib1wiLGRhdGE6YyxIOmR9KX1mdW5jdGlvbiBUZShhLGIsYyxkKXthLmphP1NlKGEsXCJvbVwiLGIsYyxkKTphLkpjLnB1c2goe1BjOmIsYWN0aW9uOlwib21cIixkYXRhOmMsSDpkfSl9XG5oLkZlPWZ1bmN0aW9uKGEsYil7dGhpcy5qYT9TZSh0aGlzLFwib2NcIixhLG51bGwsYik6dGhpcy5KYy5wdXNoKHtQYzphLGFjdGlvbjpcIm9jXCIsZGF0YTpudWxsLEg6Yn0pfTtmdW5jdGlvbiBTZShhLGIsYyxkLGUpe2M9e3A6YyxkOmR9O2EuZihcIm9uRGlzY29ubmVjdCBcIitiLGMpO2EuQ2EoYixjLGZ1bmN0aW9uKGEpe2UmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGEucyxhLmQpfSxNYXRoLmZsb29yKDApKX0pfWgucHV0PWZ1bmN0aW9uKGEsYixjLGQpe1VlKHRoaXMsXCJwXCIsYSxiLGMsZCl9O2Z1bmN0aW9uIFZlKGEsYixjLGQpe1VlKGEsXCJtXCIsYixjLGQsdm9pZCAwKX1mdW5jdGlvbiBVZShhLGIsYyxkLGUsZil7ZD17cDpjLGQ6ZH07bShmKSYmKGQuaD1mKTthLmxhLnB1c2goe2FjdGlvbjpiLHVmOmQsSDplfSk7YS5OYysrO2I9YS5sYS5sZW5ndGgtMTthLmphP1dlKGEsYik6YS5mKFwiQnVmZmVyaW5nIHB1dDogXCIrYyl9XG5mdW5jdGlvbiBXZShhLGIpe3ZhciBjPWEubGFbYl0uYWN0aW9uLGQ9YS5sYVtiXS51ZixlPWEubGFbYl0uSDthLmxhW2JdLnFnPWEuamE7YS5DYShjLGQsZnVuY3Rpb24oZCl7YS5mKGMrXCIgcmVzcG9uc2VcIixkKTtkZWxldGUgYS5sYVtiXTthLk5jLS07MD09PWEuTmMmJihhLmxhPVtdKTtlJiZlKGQucyxkLmQpfSl9XG5oLnhkPWZ1bmN0aW9uKGEpe2lmKFwiclwiaW4gYSl7dGhpcy5mKFwiZnJvbSBzZXJ2ZXI6IFwiK3IoYSkpO3ZhciBiPWEucixjPXRoaXMuU2NbYl07YyYmKGRlbGV0ZSB0aGlzLlNjW2JdLGMoYS5iKSl9ZWxzZXtpZihcImVycm9yXCJpbiBhKXRocm93XCJBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogXCIrYS5lcnJvcjtcImFcImluIGEmJihiPWEuYSxjPWEuYix0aGlzLmYoXCJoYW5kbGVTZXJ2ZXJNZXNzYWdlXCIsYixjKSxcImRcIj09PWI/dGhpcy55ZChjLnAsYy5kLCExLGMudCk6XCJtXCI9PT1iP3RoaXMueWQoYy5wLGMuZCwhMCxjLnQpOlwiY1wiPT09Yj9YZSh0aGlzLGMucCxjLnEpOlwiYWNcIj09PWI/KGE9Yy5zLGI9Yy5kLGM9dGhpcy5JYixkZWxldGUgdGhpcy5JYixjJiZjLmFkJiZjLmFkKGEsYikpOlwic2RcIj09PWI/dGhpcy5PZT90aGlzLk9lKGMpOlwibXNnXCJpbiBjJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUubG9nKFwiRklSRUJBU0U6IFwiK2MubXNnLnJlcGxhY2UoXCJcXG5cIixcblwiXFxuRklSRUJBU0U6IFwiKSk6cGIoXCJVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIityKGIpK1wiXFxuQXJlIHlvdSB1c2luZyB0aGUgbGF0ZXN0IGNsaWVudD9cIikpfX07aC5LYz1mdW5jdGlvbihhKXt0aGlzLmYoXCJjb25uZWN0aW9uIHJlYWR5XCIpO3RoaXMuamE9ITA7dGhpcy5EYz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLkhlKHtzZXJ2ZXJUaW1lT2Zmc2V0OmEtKG5ldyBEYXRlKS5nZXRUaW1lKCl9KTtZZSh0aGlzKTt0aGlzLndkKCEwKX07ZnVuY3Rpb24gTGUoYSxiKXt5KCFhLk9hLFwiU2NoZWR1bGluZyBhIGNvbm5lY3Qgd2hlbiB3ZSdyZSBhbHJlYWR5IGNvbm5lY3RlZC9pbmc/XCIpO2EuS2ImJmNsZWFyVGltZW91dChhLktiKTthLktiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthLktiPW51bGw7WmUoYSl9LE1hdGguZmxvb3IoYikpfVxuaC5rZz1mdW5jdGlvbihhKXthJiYhdGhpcy5tYyYmdGhpcy5XYT09PXRoaXMudGQmJih0aGlzLmYoXCJXaW5kb3cgYmVjYW1lIHZpc2libGUuICBSZWR1Y2luZyBkZWxheS5cIiksdGhpcy5XYT0xRTMsdGhpcy5PYXx8TGUodGhpcywwKSk7dGhpcy5tYz1hfTtoLmlnPWZ1bmN0aW9uKGEpe2E/KHRoaXMuZihcIkJyb3dzZXIgd2VudCBvbmxpbmUuICBSZWNvbm5lY3RpbmcuXCIpLHRoaXMuV2E9MUUzLHRoaXMuQ2I9ITAsdGhpcy5PYXx8TGUodGhpcywwKSk6KHRoaXMuZihcIkJyb3dzZXIgd2VudCBvZmZsaW5lLiAgS2lsbGluZyBjb25uZWN0aW9uOyBkb24ndCByZWNvbm5lY3QuXCIpLHRoaXMuQ2I9ITEsdGhpcy5PYSYmdGhpcy5PYS5jbG9zZSgpKX07XG5oLm9mPWZ1bmN0aW9uKCl7dGhpcy5mKFwiZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkXCIpO3RoaXMuamE9ITE7dGhpcy5PYT1udWxsO2Zvcih2YXIgYT0wO2E8dGhpcy5sYS5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLmxhW2FdO2ImJlwiaFwiaW4gYi51ZiYmYi5xZyYmKGIuSCYmYi5IKFwiZGlzY29ubmVjdFwiKSxkZWxldGUgdGhpcy5sYVthXSx0aGlzLk5jLS0pfTA9PT10aGlzLk5jJiYodGhpcy5sYT1bXSk7aWYodGhpcy5DYil0aGlzLm1jP3RoaXMuRGMmJigzRTQ8KG5ldyBEYXRlKS5nZXRUaW1lKCktdGhpcy5EYyYmKHRoaXMuV2E9MUUzKSx0aGlzLkRjPW51bGwpOih0aGlzLmYoXCJXaW5kb3cgaXNuJ3QgdmlzaWJsZS4gIERlbGF5aW5nIHJlY29ubmVjdC5cIiksdGhpcy5XYT10aGlzLnRkLHRoaXMud2U9KG5ldyBEYXRlKS5nZXRUaW1lKCkpLGE9TWF0aC5tYXgoMCx0aGlzLldhLSgobmV3IERhdGUpLmdldFRpbWUoKS10aGlzLndlKSksYSo9TWF0aC5yYW5kb20oKSx0aGlzLmYoXCJUcnlpbmcgdG8gcmVjb25uZWN0IGluIFwiK1xuYStcIm1zXCIpLExlKHRoaXMsYSksdGhpcy5XYT1NYXRoLm1pbih0aGlzLnRkLDEuMyp0aGlzLldhKTtlbHNlIGZvcih2YXIgYyBpbiB0aGlzLlNjKWRlbGV0ZSB0aGlzLlNjW2NdO3RoaXMud2QoITEpfTtmdW5jdGlvbiBaZShhKXtpZihhLkNiKXthLmYoXCJNYWtpbmcgYSBjb25uZWN0aW9uIGF0dGVtcHRcIik7YS53ZT0obmV3IERhdGUpLmdldFRpbWUoKTthLkRjPW51bGw7dmFyIGI9cShhLnhkLGEpLGM9cShhLktjLGEpLGQ9cShhLm9mLGEpLGU9YS5pZCtcIjpcIitNZSsrO2EuT2E9bmV3IHVlKGUsYS5PLGIsYyxkLGZ1bmN0aW9uKGIpe3ooYitcIiAoXCIrYS5PLnRvU3RyaW5nKCkrXCIpXCIpO2EuQ2I9ITF9KX19aC5wYj1mdW5jdGlvbigpe3RoaXMuQ2I9ITE7dGhpcy5PYT90aGlzLk9hLmNsb3NlKCk6KHRoaXMuS2ImJihjbGVhclRpbWVvdXQodGhpcy5LYiksdGhpcy5LYj1udWxsKSx0aGlzLmphJiZ0aGlzLm9mKCkpfTtcbmguaGM9ZnVuY3Rpb24oKXt0aGlzLkNiPSEwO3RoaXMuV2E9MUUzO3RoaXMuT2F8fExlKHRoaXMsMCl9O2Z1bmN0aW9uIFhlKGEsYixjKXtjPWM/SmEoYyxmdW5jdGlvbihhKXtyZXR1cm4geGIoYSl9KS5qb2luKFwiJFwiKTpcImRlZmF1bHRcIjsoYT1QZShhLGIsYykpJiZhLkgmJmEuSChcInBlcm1pc3Npb25fZGVuaWVkXCIpfWZ1bmN0aW9uIFBlKGEsYixjKXtiPShuZXcgUyhiKSkudG9TdHJpbmcoKTt2YXIgZD1hLkFhW2JdW2NdO2RlbGV0ZSBhLkFhW2JdW2NdOzA9PT1KYihhLkFhW2JdKSYmZGVsZXRlIGEuQWFbYl07cmV0dXJuIGR9ZnVuY3Rpb24gWWUoYSl7UWUoYSk7QShhLkFhLGZ1bmN0aW9uKGIsZCl7QShiLGZ1bmN0aW9uKGIsYyl7T2UoYSxkLGMsYil9KX0pO2Zvcih2YXIgYj0wO2I8YS5sYS5sZW5ndGg7YisrKWEubGFbYl0mJldlKGEsYik7Zm9yKDthLkpjLmxlbmd0aDspYj1hLkpjLnNoaWZ0KCksU2UoYSxiLmFjdGlvbixiLlBjLGIuZGF0YSxiLkgpfTtmdW5jdGlvbiAkZSgpe3RoaXMubT10aGlzLkQ9bnVsbH0kZS5wcm90b3R5cGUuZGM9ZnVuY3Rpb24oYSxiKXtpZihhLmUoKSl0aGlzLkQ9Yix0aGlzLm09bnVsbDtlbHNlIGlmKG51bGwhPT10aGlzLkQpdGhpcy5EPXRoaXMuRC5DKGEsYik7ZWxzZXtudWxsPT10aGlzLm0mJih0aGlzLm09bmV3IGdlKTt2YXIgYz1JKGEpO3RoaXMubS5jb250YWlucyhjKXx8dGhpcy5tLmFkZChjLG5ldyAkZSk7Yz10aGlzLm0uZ2V0KGMpO2E9VChhKTtjLmRjKGEsYil9fTtcbmZ1bmN0aW9uIGFmKGEsYil7aWYoYi5lKCkpcmV0dXJuIGEuRD1udWxsLGEubT1udWxsLCEwO2lmKG51bGwhPT1hLkQpe2lmKGEuRC5NKCkpcmV0dXJuITE7dmFyIGM9YS5EO2EuRD1udWxsO2MuVShMLGZ1bmN0aW9uKGIsYyl7YS5kYyhuZXcgUyhiKSxjKX0pO3JldHVybiBhZihhLGIpfXJldHVybiBudWxsIT09YS5tPyhjPUkoYiksYj1UKGIpLGEubS5jb250YWlucyhjKSYmYWYoYS5tLmdldChjKSxiKSYmYS5tLnJlbW92ZShjKSxhLm0uZSgpPyhhLm09bnVsbCwhMCk6ITEpOiEwfWZ1bmN0aW9uIGJmKGEsYixjKXtudWxsIT09YS5EP2MoYixhLkQpOmEuVShmdW5jdGlvbihhLGUpe3ZhciBmPW5ldyBTKGIudG9TdHJpbmcoKStcIi9cIithKTtiZihlLGYsYyl9KX0kZS5wcm90b3R5cGUuVT1mdW5jdGlvbihhKXtudWxsIT09dGhpcy5tJiZoZSh0aGlzLm0sZnVuY3Rpb24oYixjKXthKGIsYyl9KX07ZnVuY3Rpb24gY2YoKXt0aGlzLkpkPU19Y2YucHJvdG90eXBlLmo9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuSmQucmEoYSl9O2NmLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLkpkLnRvU3RyaW5nKCl9O2Z1bmN0aW9uIGRmKCl7dGhpcy5uYj1bXX1mdW5jdGlvbiBlZihhLGIpe2Zvcih2YXIgYz1udWxsLGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXSxmPWUuUWIoKTtudWxsPT09Y3x8Zi5lYShjLlFiKCkpfHwoYS5uYi5wdXNoKGMpLGM9bnVsbCk7bnVsbD09PWMmJihjPW5ldyBmZihmKSk7Yy5hZGQoZSl9YyYmYS5uYi5wdXNoKGMpfWZ1bmN0aW9uIFBjKGEsYixjKXtlZihhLGMpO2dmKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEuZWEoYil9KX1mdW5jdGlvbiBoZihhLGIsYyl7ZWYoYSxjKTtnZihhLGZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnRhaW5zKGIpfHxiLmNvbnRhaW5zKGEpfSl9XG5mdW5jdGlvbiBnZihhLGIpe2Zvcih2YXIgYz0hMCxkPTA7ZDxhLm5iLmxlbmd0aDtkKyspe3ZhciBlPWEubmJbZF07aWYoZSlpZihlPWUuUWIoKSxiKGUpKXtmb3IodmFyIGU9YS5uYltkXSxmPTA7ZjxlLmtkLmxlbmd0aDtmKyspe3ZhciBnPWUua2RbZl07aWYobnVsbCE9PWcpe2Uua2RbZl09bnVsbDt2YXIgaz1nLkxiKCk7bGImJmhiKFwiZXZlbnQ6IFwiK2cudG9TdHJpbmcoKSk7Q2Ioayl9fWEubmJbZF09bnVsbH1lbHNlIGM9ITF9YyYmKGEubmI9W10pfWZ1bmN0aW9uIGZmKGEpe3RoaXMuRWE9YTt0aGlzLmtkPVtdfWZmLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy5rZC5wdXNoKGEpfTtmZi5wcm90b3R5cGUuUWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5FYX07dmFyIGpmPVwiYXV0aC5maXJlYmFzZS5jb21cIjtmdW5jdGlvbiBrZihhLGIsYyl7dGhpcy5jZD1hfHx7fTt0aGlzLlVkPWJ8fHt9O3RoaXMuWGE9Y3x8e307dGhpcy5jZC5yZW1lbWJlcnx8KHRoaXMuY2QucmVtZW1iZXI9XCJkZWZhdWx0XCIpfXZhciBsZj1bXCJyZW1lbWJlclwiLFwicmVkaXJlY3RUb1wiXTtmdW5jdGlvbiBtZihhKXt2YXIgYj17fSxjPXt9O3VhKGF8fHt9LGZ1bmN0aW9uKGEsZSl7MDw9R2EobGYsYSk/YlthXT1lOmNbYV09ZX0pO3JldHVybiBuZXcga2YoYix7fSxjKX07dmFyIG5mPXtORVRXT1JLX0VSUk9SOlwiVW5hYmxlIHRvIGNvbnRhY3QgdGhlIEZpcmViYXNlIHNlcnZlci5cIixTRVJWRVJfRVJST1I6XCJBbiB1bmtub3duIHNlcnZlciBlcnJvciBvY2N1cnJlZC5cIixUUkFOU1BPUlRfVU5BVkFJTEFCTEU6XCJUaGVyZSBhcmUgbm8gbG9naW4gdHJhbnNwb3J0cyBhdmFpbGFibGUgZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kLlwiLFJFUVVFU1RfSU5URVJSVVBURUQ6XCJUaGUgYnJvd3NlciByZWRpcmVjdGVkIHRoZSBwYWdlIGJlZm9yZSB0aGUgbG9naW4gcmVxdWVzdCBjb3VsZCBjb21wbGV0ZS5cIixVU0VSX0NBTkNFTExFRDpcIlRoZSB1c2VyIGNhbmNlbGxlZCBhdXRoZW50aWNhdGlvbi5cIn07ZnVuY3Rpb24gWChhKXt2YXIgYj1FcnJvcih0KG5mLGEpLGEpO2IuY29kZT1hO3JldHVybiBifTtmdW5jdGlvbiBvZigpe3ZhciBhPXdpbmRvdy5vcGVuZXIuZnJhbWVzLGI7Zm9yKGI9YS5sZW5ndGgtMTswPD1iO2ItLSl0cnl7aWYoYVtiXS5sb2NhdGlvbi5wcm90b2NvbD09PXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmYVtiXS5sb2NhdGlvbi5ob3N0PT09d2luZG93LmxvY2F0aW9uLmhvc3QmJlwiX193aW5jaGFuX3JlbGF5X2ZyYW1lXCI9PT1hW2JdLm5hbWUpcmV0dXJuIGFbYl19Y2F0Y2goYyl7fXJldHVybiBudWxsfWZ1bmN0aW9uIHBmKGEsYixjKXthLmF0dGFjaEV2ZW50P2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyk6YS5hZGRFdmVudExpc3RlbmVyJiZhLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKX1mdW5jdGlvbiBxZihhLGIsYyl7YS5kZXRhY2hFdmVudD9hLmRldGFjaEV2ZW50KFwib25cIitiLGMpOmEucmVtb3ZlRXZlbnRMaXN0ZW5lciYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiByZihhKXsvXmh0dHBzPzpcXC9cXC8vLnRlc3QoYSl8fChhPXdpbmRvdy5sb2NhdGlvbi5ocmVmKTt2YXIgYj0vXihodHRwcz86XFwvXFwvW1xcLV9hLXpBLVpcXC4wLTk6XSspLy5leGVjKGEpO3JldHVybiBiP2JbMV06YX1mdW5jdGlvbiBzZihhKXt2YXIgYj1cIlwiO3RyeXthPWEucmVwbGFjZShcIiNcIixcIlwiKTt2YXIgYz17fSxkPWEucmVwbGFjZSgvXlxcPy8sXCJcIikuc3BsaXQoXCImXCIpO2ZvcihhPTA7YTxkLmxlbmd0aDthKyspaWYoZFthXSl7dmFyIGU9ZFthXS5zcGxpdChcIj1cIik7Y1tlWzBdXT1lWzFdfWMmJnMoYyxcIl9fZmlyZWJhc2VfcmVxdWVzdF9rZXlcIikmJihiPXQoYyxcIl9fZmlyZWJhc2VfcmVxdWVzdF9rZXlcIikpfWNhdGNoKGYpe31yZXR1cm4gYn1cbmZ1bmN0aW9uIHRmKGEpe3ZhciBiPVtdLGM7Zm9yKGMgaW4gYSlpZihzKGEsYykpe3ZhciBkPXQoYSxjKTtpZihlYShkKSlmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyliLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChkW2VdKSk7ZWxzZSBiLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudCh0KGEsYykpKX1yZXR1cm4gYj9cIiZcIitiLmpvaW4oXCImXCIpOlwiXCJ9ZnVuY3Rpb24gdWYoKXt2YXIgYT1yYihqZik7cmV0dXJuIGEuc2NoZW1lK1wiOi8vXCIrYS5ob3N0K1wiL3YyXCJ9ZnVuY3Rpb24gdmYoYSl7cmV0dXJuIHVmKCkrXCIvXCIrYStcIi9hdXRoL2NoYW5uZWxcIn07ZnVuY3Rpb24gd2YoKXtyZXR1cm4hISh3aW5kb3cuY29yZG92YXx8d2luZG93LnBob25lZ2FwfHx3aW5kb3cuUGhvbmVHYXApJiYvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KX1mdW5jdGlvbiB4Zigpe3ZhciBhPW5hdmlnYXRvci51c2VyQWdlbnQ7aWYoXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIj09PW5hdmlnYXRvci5hcHBOYW1lKXtpZigoYT1hLm1hdGNoKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLykpJiYxPGEubGVuZ3RoKXJldHVybiA4PD1wYXJzZUZsb2F0KGFbMV0pfWVsc2UgaWYoLTE8YS5pbmRleE9mKFwiVHJpZGVudFwiKSYmKGE9YS5tYXRjaCgvcnY6KFswLTldezIsMn1bXFwuMC05XXswLH0pLykpJiYxPGEubGVuZ3RoKXJldHVybiA4PD1wYXJzZUZsb2F0KGFbMV0pO3JldHVybiExfTtmdW5jdGlvbiB5ZihhKXthLm1ldGhvZHx8KGEubWV0aG9kPVwiR0VUXCIpO2EuaGVhZGVyc3x8KGEuaGVhZGVycz17fSk7YS5oZWFkZXJzLmNvbnRlbnRfdHlwZXx8KGEuaGVhZGVycy5jb250ZW50X3R5cGU9XCJhcHBsaWNhdGlvbi9qc29uXCIpO2EuaGVhZGVycy5jb250ZW50X3R5cGU9YS5oZWFkZXJzLmNvbnRlbnRfdHlwZS50b0xvd2VyQ2FzZSgpO3RoaXMub3B0aW9ucz1hfVxueWYucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoKXtjJiYoYyhYKFwiUkVRVUVTVF9JTlRFUlJVUFRFRFwiKSksYz1udWxsKX12YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3QsZj10aGlzLm9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCksZztwZih3aW5kb3csXCJiZWZvcmV1bmxvYWRcIixkKTtlLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKGMmJjQ9PT1lLnJlYWR5U3RhdGUpe3ZhciBhO2lmKDIwMDw9ZS5zdGF0dXMmJjMwMD5lLnN0YXR1cyl7dHJ5e2E9dGEoZS5yZXNwb25zZVRleHQpfWNhdGNoKGIpe31jKG51bGwsYSl9ZWxzZSA1MDA8PWUuc3RhdHVzJiY2MDA+ZS5zdGF0dXM/YyhYKFwiU0VSVkVSX0VSUk9SXCIpKTpjKFgoXCJORVRXT1JLX0VSUk9SXCIpKTtjPW51bGw7cWYod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCl9fTtpZihcIkdFVFwiPT09ZilhKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt0ZihiKSxnPW51bGw7ZWxzZXt2YXIgaz10aGlzLm9wdGlvbnMuaGVhZGVycy5jb250ZW50X3R5cGU7XG5cImFwcGxpY2F0aW9uL2pzb25cIj09PWsmJihnPXIoYikpO1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI9PT1rJiYoZz10ZihiKSl9ZS5vcGVuKGYsYSwhMCk7YT17XCJYLVJlcXVlc3RlZC1XaXRoXCI6XCJYTUxIdHRwUmVxdWVzdFwiLEFjY2VwdDpcImFwcGxpY2F0aW9uL2pzb247dGV4dC9wbGFpblwifTtRZChhLHRoaXMub3B0aW9ucy5oZWFkZXJzKTtmb3IodmFyIGwgaW4gYSllLnNldFJlcXVlc3RIZWFkZXIobCxhW2xdKTtlLnNlbmQoZyl9O3lmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuISF3aW5kb3cuWE1MSHR0cFJlcXVlc3QmJlwic3RyaW5nXCI9PT10eXBlb2YobmV3IFhNTEh0dHBSZXF1ZXN0KS5yZXNwb25zZVR5cGUmJighKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL01TSUUvKXx8bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudC8pKXx8eGYoKSl9O3lmLnByb3RvdHlwZS5zYz1mdW5jdGlvbigpe3JldHVyblwianNvblwifTtmdW5jdGlvbiB6ZihhKXt0aGlzLmZjPUZhKCkrRmEoKStGYSgpO3RoaXMucGY9YX1cbnpmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoWChcIlVTRVJfQ0FOQ0VMTEVEXCIpKSxjPW51bGwpfXZhciBlPXRoaXMsZj1yYihqZiksZztiLnJlcXVlc3RJZD10aGlzLmZjO2IucmVkaXJlY3RUbz1mLnNjaGVtZStcIjovL1wiK2YuaG9zdCtcIi9ibGFuay9wYWdlLmh0bWxcIjthKz0vXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCI7YSs9dGYoYik7KGc9d2luZG93Lm9wZW4oYSxcIl9ibGFua1wiLFwibG9jYXRpb249bm9cIikpJiZoYShnLmFkZEV2ZW50TGlzdGVuZXIpPyhnLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIixmdW5jdGlvbihhKXt2YXIgYjtpZihiPWEmJmEudXJsKWE6e3ZhciBuPWEudXJsO3RyeXt2YXIgdT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTt1LmhyZWY9bjtiPXUuaG9zdD09PWYuaG9zdCYmXCIvYmxhbmsvcGFnZS5odG1sXCI9PT11LnBhdGhuYW1lO2JyZWFrIGF9Y2F0Y2goeCl7fWI9ITF9YiYmKGE9c2YoYS51cmwpLGcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImV4aXRcIixcbmQpLGcuY2xvc2UoKSxhPW5ldyBrZihudWxsLG51bGwse3JlcXVlc3RJZDplLmZjLHJlcXVlc3RLZXk6YX0pLGUucGYucmVxdWVzdFdpdGhDcmVkZW50aWFsKFwiL2F1dGgvc2Vzc2lvblwiLGEsYyksYz1udWxsKX0pLGcuYWRkRXZlbnRMaXN0ZW5lcihcImV4aXRcIixkKSk6YyhYKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKX07emYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gd2YoKX07emYucHJvdG90eXBlLnNjPWZ1bmN0aW9uKCl7cmV0dXJuXCJyZWRpcmVjdFwifTtmdW5jdGlvbiBBZihhKXtpZighYS53aW5kb3dfZmVhdHVyZXN8fC0xIT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmVubmVjL1wiKXx8LTEhPT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94L1wiKSYmLTEhPT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpKWEud2luZG93X2ZlYXR1cmVzPXZvaWQgMDthLndpbmRvd19uYW1lfHwoYS53aW5kb3dfbmFtZT1cIl9ibGFua1wiKTt0aGlzLm9wdGlvbnM9YX1cbkFmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe2cmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGcpLGc9dm9pZCAwKTt1JiYodT1jbGVhckludGVydmFsKHUpKTtxZih3aW5kb3csXCJtZXNzYWdlXCIsZSk7cWYod2luZG93LFwidW5sb2FkXCIsZCk7aWYobiYmIWEpdHJ5e24uY2xvc2UoKX1jYXRjaChiKXtrLnBvc3RNZXNzYWdlKFwiZGllXCIsbCl9bj1rPXZvaWQgMH1mdW5jdGlvbiBlKGEpe2lmKGEub3JpZ2luPT09bCl0cnl7dmFyIGI9dGEoYS5kYXRhKTtcInJlYWR5XCI9PT1iLmE/ay5wb3N0TWVzc2FnZSh4LGwpOlwiZXJyb3JcIj09PWIuYT8oZCghMSksYyYmKGMoYi5kKSxjPW51bGwpKTpcInJlc3BvbnNlXCI9PT1iLmEmJihkKGIuZm9yY2VLZWVwV2luZG93T3BlbiksYyYmKGMobnVsbCxiLmQpLGM9bnVsbCkpfWNhdGNoKGUpe319dmFyIGY9eGYoKSxnLGs7aWYoIXRoaXMub3B0aW9ucy5yZWxheV91cmwpcmV0dXJuIGMoRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50czogb3JpZ2luIG9mIHVybCBhbmQgcmVsYXlfdXJsIG11c3QgbWF0Y2hcIikpO1xudmFyIGw9cmYoYSk7aWYobCE9PXJmKHRoaXMub3B0aW9ucy5yZWxheV91cmwpKWMmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKEVycm9yKFwiaW52YWxpZCBhcmd1bWVudHM6IG9yaWdpbiBvZiB1cmwgYW5kIHJlbGF5X3VybCBtdXN0IG1hdGNoXCIpKX0sMCk7ZWxzZXtmJiYoZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpLGcuc2V0QXR0cmlidXRlKFwic3JjXCIsdGhpcy5vcHRpb25zLnJlbGF5X3VybCksZy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGcuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwiX193aW5jaGFuX3JlbGF5X2ZyYW1lXCIpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZyksaz1nLmNvbnRlbnRXaW5kb3cpO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK3RmKGIpO3ZhciBuPXdpbmRvdy5vcGVuKGEsdGhpcy5vcHRpb25zLndpbmRvd19uYW1lLHRoaXMub3B0aW9ucy53aW5kb3dfZmVhdHVyZXMpO2t8fChrPW4pO3ZhciB1PXNldEludGVydmFsKGZ1bmN0aW9uKCl7biYmbi5jbG9zZWQmJlxuKGQoITEpLGMmJihjKFgoXCJVU0VSX0NBTkNFTExFRFwiKSksYz1udWxsKSl9LDUwMCkseD1yKHthOlwicmVxdWVzdFwiLGQ6Yn0pO3BmKHdpbmRvdyxcInVubG9hZFwiLGQpO3BmKHdpbmRvdyxcIm1lc3NhZ2VcIixlKX19O1xuQWYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm5cInBvc3RNZXNzYWdlXCJpbiB3aW5kb3cmJiEvXmZpbGU6XFwvLy50ZXN0KGxvY2F0aW9uLmhyZWYpJiYhKHdmKCl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1dpbmRvd3MgUGhvbmUvKXx8d2luZG93LldpbmRvd3MmJi9ebXMtYXBweDovLnRlc3QobG9jYXRpb24uaHJlZil8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaSl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0NyaU9TLyl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1R3aXR0ZXIgZm9yIGlQaG9uZS8pfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GQkFOXFwvRkJJT1MvKXx8d2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lKSYmIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1BoYW50b21KUy8pfTtBZi5wcm90b3R5cGUuc2M9ZnVuY3Rpb24oKXtyZXR1cm5cInBvcHVwXCJ9O2Z1bmN0aW9uIEJmKGEpe2EuY2FsbGJhY2tfcGFyYW1ldGVyfHwoYS5jYWxsYmFja19wYXJhbWV0ZXI9XCJjYWxsYmFja1wiKTt0aGlzLm9wdGlvbnM9YTt3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wPXdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnB8fHt9fVxuQmYucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoKXtjJiYoYyhYKFwiUkVRVUVTVF9JTlRFUlJVUFRFRFwiKSksYz1udWxsKX1mdW5jdGlvbiBlKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnBbZl09dm9pZCAwO05kKHdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnApJiYod2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucD12b2lkIDApO3RyeXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChmKTthJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9Y2F0Y2goYil7fX0sMSk7cWYod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCl9dmFyIGY9XCJmblwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpK01hdGguZmxvb3IoOTk5OTkqTWF0aC5yYW5kb20oKSk7Ylt0aGlzLm9wdGlvbnMuY2FsbGJhY2tfcGFyYW1ldGVyXT1cIl9fZmlyZWJhc2VfYXV0aF9qc29ucC5cIitmO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK3RmKGIpO1xucGYod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCk7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucFtmXT1mdW5jdGlvbihhKXtjJiYoYyhudWxsLGEpLGM9bnVsbCk7ZSgpfTtDZihmLGEsYyl9O1xuZnVuY3Rpb24gQ2YoYSxiLGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0cnl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmlkPWE7ZC5hc3luYz0hMDtkLnNyYz1iO2Qub25lcnJvcj1mdW5jdGlvbigpe3ZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO251bGwhPT1iJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7YyYmYyhYKFwiTkVUV09SS19FUlJPUlwiKSl9O3ZhciBlPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKTsoZSYmMCE9ZS5sZW5ndGg/ZVswXTpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKGQpfWNhdGNoKGYpe2MmJmMoWChcIk5FVFdPUktfRVJST1JcIikpfX0sMCl9QmYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hd2YoKX07QmYucHJvdG90eXBlLnNjPWZ1bmN0aW9uKCl7cmV0dXJuXCJqc29uXCJ9O2Z1bmN0aW9uIERmKGEsYil7dGhpcy5KZT1bXCJzZXNzaW9uXCIsYS5EZCxhLnRiXS5qb2luKFwiOlwiKTt0aGlzLlJkPWJ9RGYucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe2lmKCFiKWlmKHRoaXMuUmQubGVuZ3RoKWI9dGhpcy5SZFswXTtlbHNlIHRocm93IEVycm9yKFwiZmIubG9naW4uU2Vzc2lvbk1hbmFnZXIgOiBObyBzdG9yYWdlIG9wdGlvbnMgYXZhaWxhYmxlIVwiKTtiLnNldCh0aGlzLkplLGEpfTtEZi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7dmFyIGE9SmEodGhpcy5SZCxxKHRoaXMuWmYsdGhpcykpLGE9SWEoYSxmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9PWF9KTtRYShhLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIEhlKGMudG9rZW4pLUhlKGEudG9rZW4pfSk7cmV0dXJuIDA8YS5sZW5ndGg/YS5zaGlmdCgpOm51bGx9O0RmLnByb3RvdHlwZS5aZj1mdW5jdGlvbihhKXt0cnl7dmFyIGI9YS5nZXQodGhpcy5KZSk7aWYoYiYmYi50b2tlbilyZXR1cm4gYn1jYXRjaChjKXt9cmV0dXJuIG51bGx9O1xuRGYucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztIYSh0aGlzLlJkLGZ1bmN0aW9uKGIpe2IucmVtb3ZlKGEuSmUpfSl9O2Z1bmN0aW9uIEVmKGEpe3RoaXMuZmM9RmEoKStGYSgpK0ZhKCk7dGhpcy5wZj1hfUVmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7di5zZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIsdGhpcy5mYyk7di5zZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIsdGhpcy5mYyk7Yi5yZXF1ZXN0SWQ9dGhpcy5mYztiLnJlZGlyZWN0VG89Yi5yZWRpcmVjdFRvfHx3aW5kb3cubG9jYXRpb24uaHJlZjthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt0ZihiKTt3aW5kb3cubG9jYXRpb249YX07RWYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hL15maWxlOlxcLy8udGVzdChsb2NhdGlvbi5ocmVmKSYmIXdmKCl9O0VmLnByb3RvdHlwZS5zYz1mdW5jdGlvbigpe3JldHVyblwicmVkaXJlY3RcIn07ZnVuY3Rpb24gRmYoYSxiLGMsZCl7RmQuY2FsbCh0aGlzLFtcImF1dGhfc3RhdHVzXCJdKTt0aGlzLk89YTt0aGlzLldlPWI7dGhpcy5DZz1jO3RoaXMuRWU9ZDt0aGlzLmljPW5ldyBEZihhLFt6YSx2XSk7dGhpcy5oYj1udWxsO0dmKHRoaXMpfW1hKEZmLEZkKTtoPUZmLnByb3RvdHlwZTtoLm5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGJ8fG51bGx9O2Z1bmN0aW9uIEdmKGEpe3YuZ2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiKSYmSGYoYSk7dmFyIGI9YS5pYy5nZXQoKTtiJiZiLnRva2VuPyhJZihhLGIpLGEuV2UoYi50b2tlbixmdW5jdGlvbihjLGQpe0pmKGEsYyxkLCExLGIudG9rZW4sYil9LGZ1bmN0aW9uKGIsZCl7S2YoYSxcInJlc3VtZVNlc3Npb24oKVwiLGIsZCl9KSk6SWYoYSxudWxsKX1cbmZ1bmN0aW9uIExmKGEsYixjLGQsZSxmKXtcImZpcmViYXNlaW8tZGVtby5jb21cIj09PWEuTy5kb21haW4mJnooXCJGaXJlYmFzZSBhdXRoZW50aWNhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIG9uIGRlbW8gRmlyZWJhc2VzICgqLmZpcmViYXNlaW8tZGVtby5jb20pLiBUbyBzZWN1cmUgeW91ciBGaXJlYmFzZSwgY3JlYXRlIGEgcHJvZHVjdGlvbiBGaXJlYmFzZSBhdCBodHRwczovL3d3dy5maXJlYmFzZS5jb20uXCIpO2EuV2UoYixmdW5jdGlvbihmLGspe0pmKGEsZixrLCEwLGIsYyxkfHx7fSxlKX0sZnVuY3Rpb24oYixjKXtLZihhLFwiYXV0aCgpXCIsYixjLGYpfSl9ZnVuY3Rpb24gTWYoYSxiKXthLmljLmNsZWFyKCk7SWYoYSxudWxsKTthLkNnKGZ1bmN0aW9uKGEsZCl7aWYoXCJva1wiPT09YSlCKGIsbnVsbCk7ZWxzZXt2YXIgZT0oYXx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGY9ZTtkJiYoZis9XCI6IFwiK2QpO2Y9RXJyb3IoZik7Zi5jb2RlPWU7QihiLGYpfX0pfVxuZnVuY3Rpb24gSmYoYSxiLGMsZCxlLGYsZyxrKXtcIm9rXCI9PT1iPyhkJiYoYj1jLmF1dGgsZi5hdXRoPWIsZi5leHBpcmVzPWMuZXhwaXJlcyxmLnRva2VuPUllKGUpP2U6XCJcIixjPW51bGwsYiYmcyhiLFwidWlkXCIpP2M9dChiLFwidWlkXCIpOnMoZixcInVpZFwiKSYmKGM9dChmLFwidWlkXCIpKSxmLnVpZD1jLGM9XCJjdXN0b21cIixiJiZzKGIsXCJwcm92aWRlclwiKT9jPXQoYixcInByb3ZpZGVyXCIpOnMoZixcInByb3ZpZGVyXCIpJiYoYz10KGYsXCJwcm92aWRlclwiKSksZi5wcm92aWRlcj1jLGEuaWMuY2xlYXIoKSxJZShlKSYmKGc9Z3x8e30sYz16YSxcInNlc3Npb25Pbmx5XCI9PT1nLnJlbWVtYmVyJiYoYz12KSxcIm5vbmVcIiE9PWcucmVtZW1iZXImJmEuaWMuc2V0KGYsYykpLElmKGEsZikpLEIoayxudWxsLGYpKTooYS5pYy5jbGVhcigpLElmKGEsbnVsbCksZj1hPShifHxcImVycm9yXCIpLnRvVXBwZXJDYXNlKCksYyYmKGYrPVwiOiBcIitjKSxmPUVycm9yKGYpLGYuY29kZT1hLEIoayxmKSl9XG5mdW5jdGlvbiBLZihhLGIsYyxkLGUpe3ooYitcIiB3YXMgY2FuY2VsZWQ6IFwiK2QpO2EuaWMuY2xlYXIoKTtJZihhLG51bGwpO2E9RXJyb3IoZCk7YS5jb2RlPWMudG9VcHBlckNhc2UoKTtCKGUsYSl9ZnVuY3Rpb24gTmYoYSxiLGMsZCxlKXtPZihhKTtjPW5ldyBrZihkfHx7fSx7fSxjfHx7fSk7UGYoYSxbeWYsQmZdLFwiL2F1dGgvXCIrYixjLGUpfVxuZnVuY3Rpb24gUWYoYSxiLGMsZCl7T2YoYSk7dmFyIGU9W0FmLHpmXTtjPW1mKGMpO1wiYW5vbnltb3VzXCI9PT1ifHxcInBhc3N3b3JkXCI9PT1iP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtCKGQsWChcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9LDApOihjLlVkLndpbmRvd19mZWF0dXJlcz1cIm1lbnViYXI9eWVzLG1vZGFsPXllcyxhbHdheXNSYWlzZWQ9eWVzbG9jYXRpb249eWVzLHJlc2l6YWJsZT15ZXMsc2Nyb2xsYmFycz15ZXMsc3RhdHVzPXllcyxoZWlnaHQ9NjI1LHdpZHRoPTYyNSx0b3A9XCIrKFwib2JqZWN0XCI9PT10eXBlb2Ygc2NyZWVuPy41KihzY3JlZW4uaGVpZ2h0LTYyNSk6MCkrXCIsbGVmdD1cIisoXCJvYmplY3RcIj09PXR5cGVvZiBzY3JlZW4/LjUqKHNjcmVlbi53aWR0aC02MjUpOjApLGMuVWQucmVsYXlfdXJsPXZmKGEuTy50YiksYy5VZC5yZXF1ZXN0V2l0aENyZWRlbnRpYWw9cShhLmdjLGEpLFBmKGEsZSxcIi9hdXRoL1wiK2IsYyxkKSl9XG5mdW5jdGlvbiBIZihhKXt2YXIgYj12LmdldChcInJlZGlyZWN0X3JlcXVlc3RfaWRcIik7aWYoYil7dmFyIGM9di5nZXQoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiKTt2LnJlbW92ZShcInJlZGlyZWN0X3JlcXVlc3RfaWRcIik7di5yZW1vdmUoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiKTt2YXIgZD1beWYsQmZdLGI9e3JlcXVlc3RJZDpiLHJlcXVlc3RLZXk6c2YoZG9jdW1lbnQubG9jYXRpb24uaGFzaCl9LGM9bmV3IGtmKGMse30sYik7dHJ5e2RvY3VtZW50LmxvY2F0aW9uLmhhc2g9ZG9jdW1lbnQubG9jYXRpb24uaGFzaC5yZXBsYWNlKC8mX19maXJlYmFzZV9yZXF1ZXN0X2tleT0oW2EtekEtejAtOV0qKS8sXCJcIil9Y2F0Y2goZSl7fVBmKGEsZCxcIi9hdXRoL3Nlc3Npb25cIixjKX19aC5qZT1mdW5jdGlvbihhLGIpe09mKHRoaXMpO3ZhciBjPW1mKGEpO2MuWGEuX21ldGhvZD1cIlBPU1RcIjt0aGlzLmdjKFwiL3VzZXJzXCIsYyxmdW5jdGlvbihhLGMpe2E/QihiLGEpOkIoYixhLGMpfSl9O1xuaC5MZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7T2YodGhpcyk7dmFyIGQ9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZW1haWwpLGU9bWYoYSk7ZS5YYS5fbWV0aG9kPVwiREVMRVRFXCI7dGhpcy5nYyhkLGUsZnVuY3Rpb24oYSxkKXshYSYmZCYmZC51aWQmJmMuaGImJmMuaGIudWlkJiZjLmhiLnVpZD09PWQudWlkJiZNZihjKTtCKGIsYSl9KX07aC5lZT1mdW5jdGlvbihhLGIpe09mKHRoaXMpO3ZhciBjPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLmVtYWlsKStcIi9wYXNzd29yZFwiLGQ9bWYoYSk7ZC5YYS5fbWV0aG9kPVwiUFVUXCI7ZC5YYS5wYXNzd29yZD1hLm5ld1Bhc3N3b3JkO3RoaXMuZ2MoYyxkLGZ1bmN0aW9uKGEpe0IoYixhKX0pfTtcbmguZGU9ZnVuY3Rpb24oYSxiKXtPZih0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5vbGRFbWFpbCkrXCIvZW1haWxcIixkPW1mKGEpO2QuWGEuX21ldGhvZD1cIlBVVFwiO2QuWGEuZW1haWw9YS5uZXdFbWFpbDtkLlhhLnBhc3N3b3JkPWEucGFzc3dvcmQ7dGhpcy5nYyhjLGQsZnVuY3Rpb24oYSl7QihiLGEpfSl9O2guTWU9ZnVuY3Rpb24oYSxiKXtPZih0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5lbWFpbCkrXCIvcGFzc3dvcmRcIixkPW1mKGEpO2QuWGEuX21ldGhvZD1cIlBPU1RcIjt0aGlzLmdjKGMsZCxmdW5jdGlvbihhKXtCKGIsYSl9KX07aC5nYz1mdW5jdGlvbihhLGIsYyl7UmYodGhpcyxbeWYsQmZdLGEsYixjKX07XG5mdW5jdGlvbiBQZihhLGIsYyxkLGUpe1JmKGEsYixjLGQsZnVuY3Rpb24oYixjKXshYiYmYyYmYy50b2tlbiYmYy51aWQ/TGYoYSxjLnRva2VuLGMsZC5jZCxmdW5jdGlvbihhLGIpe2E/QihlLGEpOkIoZSxudWxsLGIpfSk6QihlLGJ8fFgoXCJVTktOT1dOX0VSUk9SXCIpKX0pfVxuZnVuY3Rpb24gUmYoYSxiLGMsZCxlKXtiPUlhKGIsZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuaXNBdmFpbGFibGUmJmEuaXNBdmFpbGFibGUoKX0pOzA9PT1iLmxlbmd0aD9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7QihlLFgoXCJUUkFOU1BPUlRfVU5BVkFJTEFCTEVcIikpfSwwKTooYj1uZXcgKGIuc2hpZnQoKSkoZC5VZCksZD12YShkLlhhKSxkLnY9XCJqcy0yLjEuMlwiLGQudHJhbnNwb3J0PWIuc2MoKSxkLnN1cHByZXNzX3N0YXR1c19jb2Rlcz0hMCxhPXVmKCkrXCIvXCIrYS5PLnRiK2MsYi5vcGVuKGEsZCxmdW5jdGlvbihhLGIpe2lmKGEpQihlLGEpO2Vsc2UgaWYoYiYmYi5lcnJvcil7dmFyIGM9RXJyb3IoYi5lcnJvci5tZXNzYWdlKTtjLmNvZGU9Yi5lcnJvci5jb2RlO2MuZGV0YWlscz1iLmVycm9yLmRldGFpbHM7QihlLGMpfWVsc2UgQihlLG51bGwsYil9KSl9XG5mdW5jdGlvbiBJZihhLGIpe3ZhciBjPW51bGwhPT1hLmhifHxudWxsIT09YjthLmhiPWI7YyYmYS5WZChcImF1dGhfc3RhdHVzXCIsYik7YS5FZShudWxsIT09Yil9aC5xZT1mdW5jdGlvbihhKXt5KFwiYXV0aF9zdGF0dXNcIj09PWEsJ2luaXRpYWwgZXZlbnQgbXVzdCBiZSBvZiB0eXBlIFwiYXV0aF9zdGF0dXNcIicpO3JldHVyblt0aGlzLmhiXX07ZnVuY3Rpb24gT2YoYSl7dmFyIGI9YS5PO2lmKFwiZmlyZWJhc2Vpby5jb21cIiE9PWIuZG9tYWluJiZcImZpcmViYXNlaW8tZGVtby5jb21cIiE9PWIuZG9tYWluJiZcImF1dGguZmlyZWJhc2UuY29tXCI9PT1qZil0aHJvdyBFcnJvcihcIlRoaXMgY3VzdG9tIEZpcmViYXNlIHNlcnZlciAoJ1wiK2EuTy5kb21haW4rXCInKSBkb2VzIG5vdCBzdXBwb3J0IGRlbGVnYXRlZCBsb2dpbi5cIik7fTtmdW5jdGlvbiBTZihhLGIpe3JldHVybiBhJiZcIm9iamVjdFwiPT09dHlwZW9mIGE/KHkoXCIuc3ZcImluIGEsXCJVbmV4cGVjdGVkIGxlYWYgbm9kZSBvciBwcmlvcml0eSBjb250ZW50c1wiKSxiW2FbXCIuc3ZcIl1dKTphfWZ1bmN0aW9uIFRmKGEsYil7dmFyIGM9bmV3ICRlO2JmKGEsbmV3IFMoXCJcIiksZnVuY3Rpb24oYSxlKXtjLmRjKGEsVWYoZSxiKSl9KTtyZXR1cm4gY31mdW5jdGlvbiBVZihhLGIpe3ZhciBjPWEuTCgpLkkoKSxjPVNmKGMsYiksZDtpZihhLk0oKSl7dmFyIGU9U2YoYS56YSgpLGIpO3JldHVybiBlIT09YS56YSgpfHxjIT09YS5MKCkuSSgpP25ldyBuZChlLE8oYykpOmF9ZD1hO2MhPT1hLkwoKS5JKCkmJihkPWQuWihuZXcgbmQoYykpKTthLlUoTCxmdW5jdGlvbihhLGMpe3ZhciBlPVVmKGMsYik7ZSE9PWMmJihkPWQuUChhLGUpKX0pO3JldHVybiBkfTtmdW5jdGlvbiB3YyhhLGIsYyl7dGhpcy5BPWE7dGhpcy5hYT1iO3RoaXMueWM9Y31mdW5jdGlvbiBWZihhKXtyZXR1cm4gYS5hYX1mdW5jdGlvbiB2YyhhLGIpe3JldHVybiBhLmFhJiYhYS55Y3x8YS5BLkRhKGIpfXdjLnByb3RvdHlwZS5qPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQX07ZnVuY3Rpb24gV2YoYSxiKXt0aGlzLkY9YTt0aGlzLkxkPWJ9ZnVuY3Rpb24gWGYoYSxiLGMsZCl7cmV0dXJuIG5ldyBXZihuZXcgd2MoYixjLGQpLGEuTGQpfWZ1bmN0aW9uIFlmKGEpe3JldHVybiBhLkYuYWE/YS5GLmooKTpudWxsfVdmLnByb3RvdHlwZS51PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuTGR9O2Z1bmN0aW9uIHhjKGEpe3JldHVybiBhLkxkLmFhP2EuTGQuaigpOm51bGx9O2Z1bmN0aW9uIFpmKGEsYil7dGhpcy5ZZD1hO3RoaXMuT2Y9Yn1mdW5jdGlvbiAkZihhKXt0aGlzLkc9YX1cbiRmLnByb3RvdHlwZS5ZYT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgeWMsZjtpZihiLnR5cGU9PT1hZyliLnNvdXJjZS5tZT9jPWJnKHRoaXMsYSxiLnBhdGgsYi5HYSxjLGQsZSk6KHkoYi5zb3VyY2UuZGYsXCJVbmtub3duIHNvdXJjZS5cIiksZj1iLnNvdXJjZS5TZSxjPWNnKHRoaXMsYSxiLnBhdGgsYi5HYSxjLGQsZixlKSk7ZWxzZSBpZihiLnR5cGU9PT1kZyliLnNvdXJjZS5tZT9jPWVnKHRoaXMsYSxiLnBhdGgsYi5jaGlsZHJlbixjLGQsZSk6KHkoYi5zb3VyY2UuZGYsXCJVbmtub3duIHNvdXJjZS5cIiksZj1iLnNvdXJjZS5TZSxjPWZnKHRoaXMsYSxiLnBhdGgsYi5jaGlsZHJlbixjLGQsZixlKSk7ZWxzZSBpZihiLnR5cGU9PT1nZylpZihiLk5lKWlmKGY9Yi5wYXRoLG51bGwhPWMuamMoZikpYz1hO2Vsc2V7Yj1uZXcgdWMoYyxhLGQpO2Q9YS5GLmooKTtpZihmLmUoKXx8XCIucHJpb3JpdHlcIj09PUkoZikpVmYoYS51KCkpP2I9Yy5wYSh4YyhhKSk6KGI9YS51KCkuaigpLFxueShiIGluc3RhbmNlb2YgVyxcInNlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZVwiKSxiPWMucGMoYikpLGI9dGhpcy5HLm9hKGQsYixlKTtlbHNle2Y9SShmKTt2YXIgZz1jLlRhKGYsYS51KCkpO251bGw9PWcmJnZjKGEudSgpLGYpJiYoZz1kLksoZikpO2I9bnVsbCE9Zz90aGlzLkcuQyhkLGYsZyxiLGUpOmEuRi5qKCkuRGEoZik/dGhpcy5HLkMoZCxmLE0sYixlKTpkO2IuZSgpJiZWZihhLnUoKSkmJihkPWMucGEoeGMoYSkpLGQuTSgpJiYoYj10aGlzLkcub2EoYixkLGUpKSl9ZD1WZihhLnUoKSl8fG51bGwhPWMuamMoVSk7Yz1YZihhLGIsZCx0aGlzLkcueWEoKSl9ZWxzZSBjPWhnKHRoaXMsYSxiLnBhdGgsYyxkLGUpO2Vsc2UgaWYoYi50eXBlPT09aWcpZD1iLnBhdGgsYj1hLnUoKSxmPWIuaigpLGc9Yi5hYXx8ZC5lKCksYz1qZyh0aGlzLG5ldyBXZihhLkYsbmV3IHdjKGYsZyxiLnljKSksZCxjLHRjLGUpO2Vsc2UgdGhyb3cgZmIoXCJVbmtub3duIG9wZXJhdGlvbiB0eXBlOiBcIitcbmIudHlwZSk7ZT1KZChlLlphKTtkPWM7Yj1kLkY7Yi5hYSYmKGY9Yi5qKCkuTSgpfHxiLmooKS5lKCksZz1ZZihhKSwoMDxlLmxlbmd0aHx8IWEuRi5hYXx8ZiYmIWIuaigpLmVhKGcpfHwhYi5qKCkuTCgpLmVhKGcuTCgpKSkmJmUucHVzaChGYihZZihkKSkpKTtyZXR1cm4gbmV3IFpmKGMsZSl9O1xuZnVuY3Rpb24gamcoYSxiLGMsZCxlLGYpe3ZhciBnPWIuRjtpZihudWxsIT1kLmpjKGMpKXJldHVybiBiO3ZhciBrO2lmKGMuZSgpKXkoVmYoYi51KCkpLFwiSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YVwiKSxhLkcueWEoKT8oZT14YyhiKSxkPWQucGMoZSBpbnN0YW5jZW9mIFc/ZTpNKSk6ZD1kLnBhKHhjKGIpKSxmPWEuRy5vYShiLkYuaigpLGQsZik7ZWxzZXt2YXIgbD1JKGMpO2lmKFwiLnByaW9yaXR5XCI9PWwpeSgxPT1RYyhjKSxcIkNhbid0IGhhdmUgYSBwcmlvcml0eSB3aXRoIGFkZGl0aW9uYWwgcGF0aCBjb21wb25lbnRzXCIpLGY9Zy5qKCksaz1iLnUoKS5qKCksZD1kLiRjKGMsZixrKSxmPW51bGwhPWQ/YS5HLlooZixkKTpnLmooKTtlbHNle3ZhciBuPVQoYyk7dmMoZyxsKT8oaz1iLnUoKS5qKCksZD1kLiRjKGMsZy5qKCksayksZD1udWxsIT1kP2cuaigpLksobCkuQyhuLGQpOmcuaigpLksobCkpOmQ9ZC5UYShsLGIudSgpKTtcbmY9bnVsbCE9ZD9hLkcuQyhnLmooKSxsLGQsZSxmKTpnLmooKX19cmV0dXJuIFhmKGIsZixnLmFhfHxjLmUoKSxhLkcueWEoKSl9ZnVuY3Rpb24gY2coYSxiLGMsZCxlLGYsZyxrKXt2YXIgbD1iLnUoKTtnPWc/YS5HOmEuRy5NYigpO2lmKGMuZSgpKWQ9Zy5vYShsLmooKSxkLG51bGwpO2Vsc2UgaWYoZy55YSgpJiYhbC55YylkPWwuaigpLkMoYyxkKSxkPWcub2EobC5qKCksZCxudWxsKTtlbHNle3ZhciBuPUkoYyk7aWYoKGMuZSgpPyFsLmFhfHxsLnljOiF2YyhsLEkoYykpKSYmMTxRYyhjKSlyZXR1cm4gYjtkPWwuaigpLksobikuQyhUKGMpLGQpO2Q9XCIucHJpb3JpdHlcIj09bj9nLloobC5qKCksZCk6Zy5DKGwuaigpLG4sZCx0YyxudWxsKX1sPWwuYWF8fGMuZSgpO2I9bmV3IFdmKGIuRixuZXcgd2MoZCxsLGcueWEoKSkpO3JldHVybiBqZyhhLGIsYyxlLG5ldyB1YyhlLGIsZiksayl9XG5mdW5jdGlvbiBiZyhhLGIsYyxkLGUsZixnKXt2YXIgaz1iLkY7ZT1uZXcgdWMoZSxiLGYpO2lmKGMuZSgpKWc9YS5HLm9hKGIuRi5qKCksZCxnKSxhPVhmKGIsZywhMCxhLkcueWEoKSk7ZWxzZSBpZihmPUkoYyksXCIucHJpb3JpdHlcIj09PWYpZz1hLkcuWihiLkYuaigpLGQpLGE9WGYoYixnLGsuYWEsay55Yyk7ZWxzZXt2YXIgbD1UKGMpO2M9ay5qKCkuSyhmKTtpZighbC5lKCkpe3ZhciBuPWUuZWYoZik7ZD1udWxsIT1uP1wiLnByaW9yaXR5XCI9PT1SYyhsKSYmbi5yYShsLnBhcmVudCgpKS5lKCk/bjpuLkMobCxkKTpNfWMuZWEoZCk/YT1iOihnPWEuRy5DKGsuaigpLGYsZCxlLGcpLGE9WGYoYixnLGsuYWEsYS5HLnlhKCkpKX1yZXR1cm4gYX1cbmZ1bmN0aW9uIGVnKGEsYixjLGQsZSxmLGcpe3ZhciBrPWI7a2coZCxmdW5jdGlvbihkLG4pe3ZhciB1PWMubyhkKTt2YyhiLkYsSSh1KSkmJihrPWJnKGEsayx1LG4sZSxmLGcpKX0pO2tnKGQsZnVuY3Rpb24oZCxuKXt2YXIgdT1jLm8oZCk7dmMoYi5GLEkodSkpfHwoaz1iZyhhLGssdSxuLGUsZixnKSl9KTtyZXR1cm4ga31mdW5jdGlvbiBsZyhhLGIpe2tnKGIsZnVuY3Rpb24oYixkKXthPWEuQyhiLGQpfSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBmZyhhLGIsYyxkLGUsZixnLGspe2lmKGIudSgpLmooKS5lKCkmJiFWZihiLnUoKSkpcmV0dXJuIGI7dmFyIGw9YjtjPWMuZSgpP2Q6bWcobmcsYyxkKTt2YXIgbj1iLnUoKS5qKCk7Yy5jaGlsZHJlbi5mYShmdW5jdGlvbihjLGQpe2lmKG4uRGEoYykpe3ZhciBFPWIudSgpLmooKS5LKGMpLEU9bGcoRSxkKTtsPWNnKGEsbCxuZXcgUyhjKSxFLGUsZixnLGspfX0pO2MuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYyxkKXt2YXIgRT0hVmYoYi51KCkpJiZudWxsPT1kLnZhbHVlO24uRGEoYyl8fEV8fChFPWIudSgpLmooKS5LKGMpLEU9bGcoRSxkKSxsPWNnKGEsbCxuZXcgUyhjKSxFLGUsZixnLGspKX0pO3JldHVybiBsfVxuZnVuY3Rpb24gaGcoYSxiLGMsZCxlLGYpe2lmKG51bGwhPWQuamMoYykpcmV0dXJuIGI7dmFyIGc9bmV3IHVjKGQsYixlKSxrPWU9Yi5GLmooKTtpZihWZihiLnUoKSkpe2lmKGMuZSgpKWU9ZC5wYSh4YyhiKSksaz1hLkcub2EoYi5GLmooKSxlLGYpO2Vsc2UgaWYoXCIucHJpb3JpdHlcIj09PUkoYykpe3ZhciBsPWQuVGEoSShjKSxiLnUoKSk7bnVsbD09bHx8ZS5lKCl8fGUuTCgpLmVhKGwpfHwoaz1hLkcuWihlLGwpKX1lbHNlIGw9SShjKSxlPWQuVGEobCxiLnUoKSksbnVsbCE9ZSYmKGs9YS5HLkMoYi5GLmooKSxsLGUsZyxmKSk7ZT0hMH1lbHNlIGIuRi5hYT8oaz1lLGU9WWYoYiksZS5NKCl8fGUuVShMLGZ1bmN0aW9uKGMpe3ZhciBlPWQuVGEoYyxiLnUoKSk7bnVsbCE9ZSYmKGs9YS5HLkMoayxjLGUsZyxmKSl9KSxlPSEwKTooIWMuZSgpJiYobD1JKGMpLDE9PVFjKGMpfHx2YyhiLkYsbCkpJiYoYz1kLlRhKGwsYi51KCkpLG51bGwhPWMmJihrPWEuRy5DKGUsbCxjLGcsZikpKSxcbmU9ITEpO3JldHVybiBYZihiLGssZSxhLkcueWEoKSl9O2Z1bmN0aW9uIG9nKGEpe3RoaXMuVj1hO3RoaXMuZz1hLm4uZ31mdW5jdGlvbiBwZyhhLGIsYyxkKXt2YXIgZT1bXSxmPVtdO0hhKGIsZnVuY3Rpb24oYil7XCJjaGlsZF9jaGFuZ2VkXCI9PT1iLnR5cGUmJmEuZy5qZihiLkRlLGIuSGEpJiZmLnB1c2gobmV3IEMoXCJjaGlsZF9tb3ZlZFwiLGIuSGEsYi5VYSkpfSk7cWcoYSxlLFwiY2hpbGRfcmVtb3ZlZFwiLGIsZCxjKTtxZyhhLGUsXCJjaGlsZF9hZGRlZFwiLGIsZCxjKTtxZyhhLGUsXCJjaGlsZF9tb3ZlZFwiLGYsZCxjKTtxZyhhLGUsXCJjaGlsZF9jaGFuZ2VkXCIsYixkLGMpO3FnKGEsZSxHYixiLGQsYyk7cmV0dXJuIGV9ZnVuY3Rpb24gcWcoYSxiLGMsZCxlLGYpe2Q9SWEoZCxmdW5jdGlvbihhKXtyZXR1cm4gYS50eXBlPT09Y30pO1FhKGQscShhLlFmLGEpKTtIYShkLGZ1bmN0aW9uKGMpe3ZhciBkPXJnKGEsYyxmKTtIYShlLGZ1bmN0aW9uKGUpe2Uud2YoYy50eXBlKSYmYi5wdXNoKGUuY3JlYXRlRXZlbnQoZCxhLlYpKX0pfSl9XG5mdW5jdGlvbiByZyhhLGIsYyl7XCJ2YWx1ZVwiIT09Yi50eXBlJiZcImNoaWxkX3JlbW92ZWRcIiE9PWIudHlwZSYmKGIuRmQ9Yy5mZihiLlVhLGIuSGEsYS5nKSk7cmV0dXJuIGJ9b2cucHJvdG90eXBlLlFmPWZ1bmN0aW9uKGEsYil7aWYobnVsbD09YS5VYXx8bnVsbD09Yi5VYSl0aHJvdyBmYihcIlNob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy5cIik7cmV0dXJuIHRoaXMuZy5jb21wYXJlKG5ldyBOKGEuVWEsYS5IYSksbmV3IE4oYi5VYSxiLkhhKSl9O2Z1bmN0aW9uIHNnKGEsYil7dGhpcy5WPWE7dmFyIGM9YS5uLGQ9bmV3IGJjKGMuZyksYz1KYyhjKT9uZXcgYmMoYy5nKTpjLmthP25ldyBBYyhjKTpuZXcgZGMoYyk7dGhpcy5zZj1uZXcgJGYoYyk7dmFyIGU9Yi51KCksZj1iLkYsZz1kLm9hKE0sZS5qKCksbnVsbCksaz1jLm9hKE0sZi5qKCksbnVsbCk7dGhpcy5JYT1uZXcgV2YobmV3IHdjKGssZi5hYSxjLnlhKCkpLG5ldyB3YyhnLGUuYWEsZC55YSgpKSk7dGhpcy5WYT1bXTt0aGlzLlVmPW5ldyBvZyhhKX1mdW5jdGlvbiB0ZyhhKXtyZXR1cm4gYS5WfWg9c2cucHJvdG90eXBlO2gudT1mdW5jdGlvbigpe3JldHVybiB0aGlzLklhLnUoKS5qKCl9O2guYmI9ZnVuY3Rpb24oYSl7dmFyIGI9eGModGhpcy5JYSk7cmV0dXJuIGImJihKYyh0aGlzLlYubil8fCFhLmUoKSYmIWIuSyhJKGEpKS5lKCkpP2IucmEoYSk6bnVsbH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLlZhLmxlbmd0aH07aC5HYj1mdW5jdGlvbihhKXt0aGlzLlZhLnB1c2goYSl9O1xuaC5nYj1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO2lmKGIpe3kobnVsbD09YSxcIkEgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXCIpO3ZhciBkPXRoaXMuVi5wYXRoO0hhKHRoaXMuVmEsZnVuY3Rpb24oYSl7KGE9YS5ZZShiLGQpKSYmYy5wdXNoKGEpfSl9aWYoYSl7Zm9yKHZhciBlPVtdLGY9MDtmPHRoaXMuVmEubGVuZ3RoOysrZil7dmFyIGc9dGhpcy5WYVtmXTtpZighZy5tYXRjaGVzKGEpKWUucHVzaChnKTtlbHNlIGlmKGEuaGYoKSl7ZT1lLmNvbmNhdCh0aGlzLlZhLnNsaWNlKGYrMSkpO2JyZWFrfX10aGlzLlZhPWV9ZWxzZSB0aGlzLlZhPVtdO3JldHVybiBjfTtcbmguWWE9ZnVuY3Rpb24oYSxiLGMpe2EudHlwZT09PWRnJiZudWxsIT09YS5zb3VyY2UueWImJih5KHhjKHRoaXMuSWEpLFwiV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzXCIpLHkoWWYodGhpcy5JYSksXCJNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlXCIpKTt2YXIgZD10aGlzLklhO2E9dGhpcy5zZi5ZYShkLGEsYixjKTtiPXRoaXMuc2Y7Yz1hLllkO3koYy5GLmooKS5CYyhiLkcuZyksXCJFdmVudCBzbmFwIG5vdCBpbmRleGVkXCIpO3koYy51KCkuaigpLkJjKGIuRy5nKSxcIlNlcnZlciBzbmFwIG5vdCBpbmRleGVkXCIpO3koVmYoYS5ZZC51KCkpfHwhVmYoZC51KCkpLFwiT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFja1wiKTt0aGlzLklhPWEuWWQ7cmV0dXJuIHVnKHRoaXMsYS5PZixhLllkLkYuaigpLG51bGwpfTtcbmZ1bmN0aW9uIHZnKGEsYil7dmFyIGM9YS5JYS5GLGQ9W107Yy5qKCkuTSgpfHxjLmooKS5VKEwsZnVuY3Rpb24oYSxiKXtkLnB1c2gobmV3IEMoXCJjaGlsZF9hZGRlZFwiLGIsYSkpfSk7Yy5hYSYmZC5wdXNoKEZiKGMuaigpKSk7cmV0dXJuIHVnKGEsZCxjLmooKSxiKX1mdW5jdGlvbiB1ZyhhLGIsYyxkKXtyZXR1cm4gcGcoYS5VZixiLGMsZD9bZF06YS5WYSl9O2Z1bmN0aW9uIHdnKGEsYil7dGhpcy52YWx1ZT1hO3RoaXMuY2hpbGRyZW49Ynx8eGd9dmFyIHhnPW5ldyBaYyhmdW5jdGlvbihhLGIpe3JldHVybiBhPT09Yj8wOmE8Yj8tMToxfSksbmc9bmV3IHdnKG51bGwpO2Z1bmN0aW9uIHlnKGEpe3ZhciBiPW5nO0EoYSxmdW5jdGlvbihhLGQpe2I9Yi5zZXQobmV3IFMoZCksYSl9KTtyZXR1cm4gYn1oPXdnLnByb3RvdHlwZTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMudmFsdWUmJnRoaXMuY2hpbGRyZW4uZSgpfTtmdW5jdGlvbiB6ZyhhLGIsYyl7aWYobnVsbCE9YS52YWx1ZSYmYyhhLnZhbHVlKSlyZXR1cm57cGF0aDpVLHZhbHVlOmEudmFsdWV9O2lmKGIuZSgpKXJldHVybiBudWxsO3ZhciBkPUkoYik7YT1hLmNoaWxkcmVuLmdldChkKTtyZXR1cm4gbnVsbCE9PWE/KGI9emcoYSxUKGIpLGMpLG51bGwhPWI/e3BhdGg6KG5ldyBTKGQpKS5vKGIucGF0aCksdmFsdWU6Yi52YWx1ZX06bnVsbCk6bnVsbH1cbmZ1bmN0aW9uIEFnKGEsYil7cmV0dXJuIHpnKGEsYixmdW5jdGlvbigpe3JldHVybiEwfSl9aC5zdWJ0cmVlPWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiB0aGlzO3ZhciBiPXRoaXMuY2hpbGRyZW4uZ2V0KEkoYSkpO3JldHVybiBudWxsIT09Yj9iLnN1YnRyZWUoVChhKSk6bmd9O2guc2V0PWZ1bmN0aW9uKGEsYil7aWYoYS5lKCkpcmV0dXJuIG5ldyB3ZyhiLHRoaXMuY2hpbGRyZW4pO3ZhciBjPUkoYSksZD0odGhpcy5jaGlsZHJlbi5nZXQoYyl8fG5nKS5zZXQoVChhKSxiKSxjPXRoaXMuY2hpbGRyZW4uTGEoYyxkKTtyZXR1cm4gbmV3IHdnKHRoaXMudmFsdWUsYyl9O1xuaC5yZW1vdmU9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXMuY2hpbGRyZW4uZSgpP25nOm5ldyB3ZyhudWxsLHRoaXMuY2hpbGRyZW4pO3ZhciBiPUkoYSksYz10aGlzLmNoaWxkcmVuLmdldChiKTtyZXR1cm4gYz8oYT1jLnJlbW92ZShUKGEpKSxiPWEuZSgpP3RoaXMuY2hpbGRyZW4ucmVtb3ZlKGIpOnRoaXMuY2hpbGRyZW4uTGEoYixhKSxudWxsPT09dGhpcy52YWx1ZSYmYi5lKCk/bmc6bmV3IHdnKHRoaXMudmFsdWUsYikpOnRoaXN9O2guZ2V0PWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiB0aGlzLnZhbHVlO3ZhciBiPXRoaXMuY2hpbGRyZW4uZ2V0KEkoYSkpO3JldHVybiBiP2IuZ2V0KFQoYSkpOm51bGx9O1xuZnVuY3Rpb24gbWcoYSxiLGMpe2lmKGIuZSgpKXJldHVybiBjO3ZhciBkPUkoYik7Yj1tZyhhLmNoaWxkcmVuLmdldChkKXx8bmcsVChiKSxjKTtkPWIuZSgpP2EuY2hpbGRyZW4ucmVtb3ZlKGQpOmEuY2hpbGRyZW4uTGEoZCxiKTtyZXR1cm4gbmV3IHdnKGEudmFsdWUsZCl9ZnVuY3Rpb24gQmcoYSxiKXtyZXR1cm4gQ2coYSxVLGIpfWZ1bmN0aW9uIENnKGEsYixjKXt2YXIgZD17fTthLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsZil7ZFthXT1DZyhmLGIubyhhKSxjKX0pO3JldHVybiBjKGIsYS52YWx1ZSxkKX1mdW5jdGlvbiBEZyhhLGIsYyl7cmV0dXJuIEVnKGEsYixVLGMpfWZ1bmN0aW9uIEVnKGEsYixjLGQpe3ZhciBlPWEudmFsdWU/ZChjLGEudmFsdWUpOiExO2lmKGUpcmV0dXJuIGU7aWYoYi5lKCkpcmV0dXJuIG51bGw7ZT1JKGIpO3JldHVybihhPWEuY2hpbGRyZW4uZ2V0KGUpKT9FZyhhLFQoYiksYy5vKGUpLGQpOm51bGx9XG5mdW5jdGlvbiBGZyhhLGIsYyl7aWYoIWIuZSgpKXt2YXIgZD0hMDthLnZhbHVlJiYoZD1jKFUsYS52YWx1ZSkpOyEwPT09ZCYmKGQ9SShiKSwoYT1hLmNoaWxkcmVuLmdldChkKSkmJkdnKGEsVChiKSxVLm8oZCksYykpfX1mdW5jdGlvbiBHZyhhLGIsYyxkKXtpZihiLmUoKSlyZXR1cm4gYTthLnZhbHVlJiZkKGMsYS52YWx1ZSk7dmFyIGU9SShiKTtyZXR1cm4oYT1hLmNoaWxkcmVuLmdldChlKSk/R2coYSxUKGIpLGMubyhlKSxkKTpuZ31mdW5jdGlvbiBrZyhhLGIpe0hnKGEsVSxiKX1mdW5jdGlvbiBIZyhhLGIsYyl7YS5jaGlsZHJlbi5mYShmdW5jdGlvbihhLGUpe0hnKGUsYi5vKGEpLGMpfSk7YS52YWx1ZSYmYyhiLGEudmFsdWUpfWZ1bmN0aW9uIElnKGEsYil7YS5jaGlsZHJlbi5mYShmdW5jdGlvbihhLGQpe2QudmFsdWUmJmIoYSxkLnZhbHVlKX0pfVxuaC50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPXt9O2tnKHRoaXMsZnVuY3Rpb24oYixjKXthW2IudG9TdHJpbmcoKV09Yy50b1N0cmluZygpfSk7cmV0dXJuIHIoYSl9O2Z1bmN0aW9uIEpnKCl7dGhpcy52YT17fX1oPUpnLnByb3RvdHlwZTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gTmQodGhpcy52YSl9O2guWWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEuc291cmNlLnliO2lmKG51bGwhPT1kKXJldHVybiBkPXQodGhpcy52YSxkKSx5KG51bGwhPWQsXCJTeW5jVHJlZSBnYXZlIHVzIGFuIG9wIGZvciBhbiBpbnZhbGlkIHF1ZXJ5LlwiKSxkLllhKGEsYixjKTt2YXIgZT1bXTtBKHRoaXMudmEsZnVuY3Rpb24oZCl7ZT1lLmNvbmNhdChkLllhKGEsYixjKSl9KTtyZXR1cm4gZX07aC5HYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEuRmEoKSxnPXQodGhpcy52YSxmKTtpZighZyl7dmFyIGc9Yy5wYShlP2Q6bnVsbCksaz0hMTtnP2s9ITA6KGc9ZCBpbnN0YW5jZW9mIFc/Yy5wYyhkKTpNLGs9ITEpO2c9bmV3IHNnKGEsbmV3IFdmKG5ldyB3YyhnLGssITEpLG5ldyB3YyhkLGUsITEpKSk7dGhpcy52YVtmXT1nfWcuR2IoYik7cmV0dXJuIHZnKGcsYil9O1xuaC5nYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5GYSgpLGU9W10sZj1bXSxnPW51bGwhPUtnKHRoaXMpO2lmKFwiZGVmYXVsdFwiPT09ZCl7dmFyIGs9dGhpcztBKHRoaXMudmEsZnVuY3Rpb24oYSxkKXtmPWYuY29uY2F0KGEuZ2IoYixjKSk7YS5lKCkmJihkZWxldGUgay52YVtkXSxKYyhhLlYubil8fGUucHVzaChhLlYpKX0pfWVsc2V7dmFyIGw9dCh0aGlzLnZhLGQpO2wmJihmPWYuY29uY2F0KGwuZ2IoYixjKSksbC5lKCkmJihkZWxldGUgdGhpcy52YVtkXSxKYyhsLlYubil8fGUucHVzaChsLlYpKSl9ZyYmbnVsbD09S2codGhpcykmJmUucHVzaChuZXcgUihhLmssYS5wYXRoKSk7cmV0dXJue3JnOmUsVmY6Zn19O2Z1bmN0aW9uIExnKGEpe3JldHVybiBJYShKZChhLnZhKSxmdW5jdGlvbihhKXtyZXR1cm4hSmMoYS5WLm4pfSl9aC5iYj1mdW5jdGlvbihhKXt2YXIgYj1udWxsO0EodGhpcy52YSxmdW5jdGlvbihjKXtiPWJ8fGMuYmIoYSl9KTtyZXR1cm4gYn07XG5mdW5jdGlvbiBNZyhhLGIpe2lmKEpjKGIubikpcmV0dXJuIEtnKGEpO3ZhciBjPWIuRmEoKTtyZXR1cm4gdChhLnZhLGMpfWZ1bmN0aW9uIEtnKGEpe3JldHVybiBNZChhLnZhLGZ1bmN0aW9uKGEpe3JldHVybiBKYyhhLlYubil9KXx8bnVsbH07ZnVuY3Rpb24gTmcoYSl7dGhpcy5XPWF9dmFyIE9nPW5ldyBOZyhuZXcgd2cobnVsbCkpO2Z1bmN0aW9uIFBnKGEsYixjKXtpZihiLmUoKSlyZXR1cm4gbmV3IE5nKG5ldyB3ZyhjKSk7dmFyIGQ9QWcoYS5XLGIpO2lmKG51bGwhPWQpe3ZhciBlPWQucGF0aCxkPWQudmFsdWU7Yj1WKGUsYik7ZD1kLkMoYixjKTtyZXR1cm4gbmV3IE5nKGEuVy5zZXQoZSxkKSl9YT1tZyhhLlcsYixuZXcgd2coYykpO3JldHVybiBuZXcgTmcoYSl9ZnVuY3Rpb24gUWcoYSxiLGMpe3ZhciBkPWE7dWEoYyxmdW5jdGlvbihhLGMpe2Q9UGcoZCxiLm8oYSksYyl9KTtyZXR1cm4gZH1OZy5wcm90b3R5cGUuR2Q9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIE9nO2E9bWcodGhpcy5XLGEsbmcpO3JldHVybiBuZXcgTmcoYSl9O2Z1bmN0aW9uIFJnKGEsYil7dmFyIGM9QWcoYS5XLGIpO3JldHVybiBudWxsIT1jP2EuVy5nZXQoYy5wYXRoKS5yYShWKGMucGF0aCxiKSk6bnVsbH1cbmZ1bmN0aW9uIFNnKGEpe3ZhciBiPVtdLGM9YS5XLnZhbHVlO251bGwhPWM/Yy5NKCl8fGMuVShMLGZ1bmN0aW9uKGEsYyl7Yi5wdXNoKG5ldyBOKGEsYykpfSk6YS5XLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsYyl7bnVsbCE9Yy52YWx1ZSYmYi5wdXNoKG5ldyBOKGEsYy52YWx1ZSkpfSk7cmV0dXJuIGJ9ZnVuY3Rpb24gVGcoYSxiKXtpZihiLmUoKSlyZXR1cm4gYTt2YXIgYz1SZyhhLGIpO3JldHVybiBudWxsIT1jP25ldyBOZyhuZXcgd2coYykpOm5ldyBOZyhhLlcuc3VidHJlZShiKSl9TmcucHJvdG90eXBlLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5XLmUoKX07TmcucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEpe3JldHVybiBVZyhVLHRoaXMuVyxhKX07XG5mdW5jdGlvbiBVZyhhLGIsYyl7aWYobnVsbCE9Yi52YWx1ZSlyZXR1cm4gYy5DKGEsYi52YWx1ZSk7dmFyIGQ9bnVsbDtiLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGIsZil7XCIucHJpb3JpdHlcIj09PWI/KHkobnVsbCE9PWYudmFsdWUsXCJQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2Rlc1wiKSxkPWYudmFsdWUpOmM9VWcoYS5vKGIpLGYsYyl9KTtjLnJhKGEpLmUoKXx8bnVsbD09PWR8fChjPWMuQyhhLm8oXCIucHJpb3JpdHlcIiksZCkpO3JldHVybiBjfTtmdW5jdGlvbiBWZygpe3RoaXMuVD1PZzt0aGlzLndhPVtdO3RoaXMuRWM9LTF9aD1WZy5wcm90b3R5cGU7XG5oLkdkPWZ1bmN0aW9uKGEpe3ZhciBiPU5hKHRoaXMud2EsZnVuY3Rpb24oYil7cmV0dXJuIGIuWmQ9PT1hfSk7eSgwPD1iLFwicmVtb3ZlV3JpdGUgY2FsbGVkIHdpdGggbm9uZXhpc3RlbnQgd3JpdGVJZC5cIik7dmFyIGM9dGhpcy53YVtiXTt0aGlzLndhLnNwbGljZShiLDEpO2Zvcih2YXIgZD1jLnZpc2libGUsZT0hMSxmPXRoaXMud2EubGVuZ3RoLTE7ZCYmMDw9Zjspe3ZhciBnPXRoaXMud2FbZl07Zy52aXNpYmxlJiYoZj49YiYmV2coZyxjLnBhdGgpP2Q9ITE6Yy5wYXRoLmNvbnRhaW5zKGcucGF0aCkmJihlPSEwKSk7Zi0tfWlmKGQpe2lmKGUpdGhpcy5UPVhnKHRoaXMud2EsWWcsVSksdGhpcy5FYz0wPHRoaXMud2EubGVuZ3RoP3RoaXMud2FbdGhpcy53YS5sZW5ndGgtMV0uWmQ6LTE7ZWxzZSBpZihjLkdhKXRoaXMuVD10aGlzLlQuR2QoYy5wYXRoKTtlbHNle3ZhciBrPXRoaXM7QShjLmNoaWxkcmVuLGZ1bmN0aW9uKGEsYil7ay5UPWsuVC5HZChjLnBhdGgubyhiKSl9KX1yZXR1cm4gYy5wYXRofXJldHVybiBudWxsfTtcbmgucGE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoY3x8ZCl7dmFyIGU9VGcodGhpcy5ULGEpO3JldHVybiFkJiZlLmUoKT9iOmR8fG51bGwhPWJ8fG51bGwhPVJnKGUsVSk/KGU9WGcodGhpcy53YSxmdW5jdGlvbihiKXtyZXR1cm4oYi52aXNpYmxlfHxkKSYmKCFjfHwhKDA8PUdhKGMsYi5aZCkpKSYmKGIucGF0aC5jb250YWlucyhhKXx8YS5jb250YWlucyhiLnBhdGgpKX0sYSksYj1ifHxNLGUuYXBwbHkoYikpOm51bGx9ZT1SZyh0aGlzLlQsYSk7aWYobnVsbCE9ZSlyZXR1cm4gZTtlPVRnKHRoaXMuVCxhKTtyZXR1cm4gZS5lKCk/YjpudWxsIT1ifHxudWxsIT1SZyhlLFUpPyhiPWJ8fE0sZS5hcHBseShiKSk6bnVsbH07XG5oLnBjPWZ1bmN0aW9uKGEsYil7dmFyIGM9TSxkPVJnKHRoaXMuVCxhKTtpZihkKWQuTSgpfHxkLlUoTCxmdW5jdGlvbihhLGIpe2M9Yy5QKGEsYil9KTtlbHNlIGlmKGIpe3ZhciBlPVRnKHRoaXMuVCxhKTtiLlUoTCxmdW5jdGlvbihhLGIpe3ZhciBkPVRnKGUsbmV3IFMoYSkpLmFwcGx5KGIpO2M9Yy5QKGEsZCl9KTtIYShTZyhlKSxmdW5jdGlvbihhKXtjPWMuUChhLm5hbWUsYS5ZKX0pfWVsc2UgZT1UZyh0aGlzLlQsYSksSGEoU2coZSksZnVuY3Rpb24oYSl7Yz1jLlAoYS5uYW1lLGEuWSl9KTtyZXR1cm4gY307aC4kYz1mdW5jdGlvbihhLGIsYyxkKXt5KGN8fGQsXCJFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcIik7YT1hLm8oYik7aWYobnVsbCE9UmcodGhpcy5ULGEpKXJldHVybiBudWxsO2E9VGcodGhpcy5ULGEpO3JldHVybiBhLmUoKT9kLnJhKGIpOmEuYXBwbHkoZC5yYShiKSl9O1xuaC5UYT1mdW5jdGlvbihhLGIsYyl7YT1hLm8oYik7dmFyIGQ9UmcodGhpcy5ULGEpO3JldHVybiBudWxsIT1kP2Q6dmMoYyxiKT9UZyh0aGlzLlQsYSkuYXBwbHkoYy5qKCkuSyhiKSk6bnVsbH07aC5qYz1mdW5jdGlvbihhKXtyZXR1cm4gUmcodGhpcy5ULGEpfTtoLmNlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZzthPVRnKHRoaXMuVCxhKTtnPVJnKGEsVSk7aWYobnVsbD09ZylpZihudWxsIT1iKWc9YS5hcHBseShiKTtlbHNlIHJldHVybltdO2c9Zy5GYihmKTtpZihnLmUoKXx8Zy5NKCkpcmV0dXJuW107Yj1bXTthPW1jKGYpO2U9ZT9nLlJiKGMsZik6Zy5QYihjLGYpO2ZvcihmPVAoZSk7ZiYmYi5sZW5ndGg8ZDspMCE9PWEoZixjKSYmYi5wdXNoKGYpLGY9UChlKTtyZXR1cm4gYn07XG5mdW5jdGlvbiBXZyhhLGIpe3JldHVybiBhLkdhP2EucGF0aC5jb250YWlucyhiKTohIUxkKGEuY2hpbGRyZW4sZnVuY3Rpb24oYyxkKXtyZXR1cm4gYS5wYXRoLm8oZCkuY29udGFpbnMoYil9KX1mdW5jdGlvbiBZZyhhKXtyZXR1cm4gYS52aXNpYmxlfVxuZnVuY3Rpb24gWGcoYSxiLGMpe2Zvcih2YXIgZD1PZyxlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV07aWYoYihmKSl7dmFyIGc9Zi5wYXRoO2lmKGYuR2EpYy5jb250YWlucyhnKT8oZz1WKGMsZyksZD1QZyhkLGcsZi5HYSkpOmcuY29udGFpbnMoYykmJihnPVYoZyxjKSxkPVBnKGQsVSxmLkdhLnJhKGcpKSk7ZWxzZSBpZihmLmNoaWxkcmVuKWlmKGMuY29udGFpbnMoZykpZz1WKGMsZyksZD1RZyhkLGcsZi5jaGlsZHJlbik7ZWxzZXtpZihnLmNvbnRhaW5zKGMpKWlmKGc9VihnLGMpLGcuZSgpKWQ9UWcoZCxVLGYuY2hpbGRyZW4pO2Vsc2UgaWYoZj10KGYuY2hpbGRyZW4sSShnKSkpZj1mLnJhKFQoZykpLGQ9UGcoZCxVLGYpfWVsc2UgdGhyb3cgZmIoXCJXcml0ZVJlY29yZCBzaG91bGQgaGF2ZSAuc25hcCBvciAuY2hpbGRyZW5cIik7fX1yZXR1cm4gZH1mdW5jdGlvbiBaZyhhLGIpe3RoaXMuRGI9YTt0aGlzLlc9Yn1oPVpnLnByb3RvdHlwZTtcbmgucGE9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLlcucGEodGhpcy5EYixhLGIsYyl9O2gucGM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuVy5wYyh0aGlzLkRiLGEpfTtoLiRjPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5XLiRjKHRoaXMuRGIsYSxiLGMpfTtoLmpjPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlcuamModGhpcy5EYi5vKGEpKX07aC5jZT1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiB0aGlzLlcuY2UodGhpcy5EYixhLGIsYyxkLGUpfTtoLlRhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuVy5UYSh0aGlzLkRiLGEsYil9O2gubz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFpnKHRoaXMuRGIubyhhKSx0aGlzLlcpfTtmdW5jdGlvbiAkZyhhLGIsYyl7dGhpcy50eXBlPWFnO3RoaXMuc291cmNlPWE7dGhpcy5wYXRoPWI7dGhpcy5HYT1jfSRnLnByb3RvdHlwZS5NYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wYXRoLmUoKT9uZXcgJGcodGhpcy5zb3VyY2UsVSx0aGlzLkdhLksoYSkpOm5ldyAkZyh0aGlzLnNvdXJjZSxUKHRoaXMucGF0aCksdGhpcy5HYSl9OyRnLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBvdmVyd3JpdGU6IFwiK3RoaXMuR2EudG9TdHJpbmcoKStcIilcIn07ZnVuY3Rpb24gYWgoYSxiKXt0aGlzLnR5cGU9Z2c7dGhpcy5zb3VyY2U9Ymg7dGhpcy5wYXRoPWE7dGhpcy5OZT1ifWFoLnByb3RvdHlwZS5NYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGguZSgpP3RoaXM6bmV3IGFoKFQodGhpcy5wYXRoKSx0aGlzLk5lKX07YWgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIGFjayB3cml0ZSByZXZlcnQ9XCIrdGhpcy5OZStcIilcIn07ZnVuY3Rpb24gY2goYSxiKXt0aGlzLnR5cGU9aWc7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yn1jaC5wcm90b3R5cGUuTWM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRoLmUoKT9uZXcgY2godGhpcy5zb3VyY2UsVSk6bmV3IGNoKHRoaXMuc291cmNlLFQodGhpcy5wYXRoKSl9O2NoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBsaXN0ZW5fY29tcGxldGUpXCJ9O2Z1bmN0aW9uIGRoKGEsYixjKXt0aGlzLnR5cGU9ZGc7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLmNoaWxkcmVuPWN9ZGgucHJvdG90eXBlLk1jPWZ1bmN0aW9uKGEpe2lmKHRoaXMucGF0aC5lKCkpcmV0dXJuIGE9dGhpcy5jaGlsZHJlbi5zdWJ0cmVlKG5ldyBTKGEpKSxhLmUoKT9udWxsOmEudmFsdWU/bmV3ICRnKHRoaXMuc291cmNlLFUsYS52YWx1ZSk6bmV3IGRoKHRoaXMuc291cmNlLFUsYSk7eShJKHRoaXMucGF0aCk9PT1hLFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7cmV0dXJuIG5ldyBkaCh0aGlzLnNvdXJjZSxUKHRoaXMucGF0aCksdGhpcy5jaGlsZHJlbil9O2RoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBtZXJnZTogXCIrdGhpcy5jaGlsZHJlbi50b1N0cmluZygpK1wiKVwifTt2YXIgYWc9MCxkZz0xLGdnPTIsaWc9MztmdW5jdGlvbiBlaChhLGIsYyxkKXt0aGlzLm1lPWE7dGhpcy5kZj1iO3RoaXMueWI9Yzt0aGlzLlNlPWQ7eSghZHx8YixcIlRhZ2dlZCBxdWVyaWVzIG11c3QgYmUgZnJvbSBzZXJ2ZXIuXCIpfXZhciBiaD1uZXcgZWgoITAsITEsbnVsbCwhMSksZmg9bmV3IGVoKCExLCEwLG51bGwsITEpO2VoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1lP1widXNlclwiOnRoaXMuU2U/XCJzZXJ2ZXIocXVlcnlJRD1cIit0aGlzLnliK1wiKVwiOlwic2VydmVyXCJ9O2Z1bmN0aW9uIGdoKGEpe3RoaXMubmE9bmc7dGhpcy54Yj1uZXcgVmc7dGhpcy5XYz17fTt0aGlzLmJjPXt9O3RoaXMuRmM9YX1mdW5jdGlvbiBoaChhLGIsYyxkLGUpe3ZhciBmPWEueGIsZz1lO3koZD5mLkVjLFwiU3RhY2tpbmcgYW4gb2xkZXIgd3JpdGUgb24gdG9wIG9mIG5ld2VyIG9uZXNcIik7bShnKXx8KGc9ITApO2Yud2EucHVzaCh7cGF0aDpiLEdhOmMsWmQ6ZCx2aXNpYmxlOmd9KTtnJiYoZi5UPVBnKGYuVCxiLGMpKTtmLkVjPWQ7cmV0dXJuIGU/aWgoYSxuZXcgJGcoYmgsYixjKSk6W119ZnVuY3Rpb24gamgoYSxiLGMsZCl7dmFyIGU9YS54Yjt5KGQ+ZS5FYyxcIlN0YWNraW5nIGFuIG9sZGVyIG1lcmdlIG9uIHRvcCBvZiBuZXdlciBvbmVzXCIpO2Uud2EucHVzaCh7cGF0aDpiLGNoaWxkcmVuOmMsWmQ6ZCx2aXNpYmxlOiEwfSk7ZS5UPVFnKGUuVCxiLGMpO2UuRWM9ZDtjPXlnKGMpO3JldHVybiBpaChhLG5ldyBkaChiaCxiLGMpKX1cbmZ1bmN0aW9uIGtoKGEsYixjKXtjPWN8fCExO2I9YS54Yi5HZChiKTtyZXR1cm4gbnVsbD09Yj9bXTppaChhLG5ldyBhaChiLGMpKX1mdW5jdGlvbiBsaChhLGIsYyl7Yz15ZyhjKTtyZXR1cm4gaWgoYSxuZXcgZGgoZmgsYixjKSl9ZnVuY3Rpb24gbWgoYSxiLGMsZCl7ZD1PZChhLldjLFwiX1wiK2QpO2lmKG51bGwhPWQpe3ZhciBlPW5oKGQpO2Q9ZS5wYXRoO2U9ZS55YjtiPVYoZCxiKTtjPW5ldyAkZyhuZXcgZWgoITEsITAsZSwhMCksYixjKTtyZXR1cm4gb2goYSxkLGMpfXJldHVybltdfWZ1bmN0aW9uIHBoKGEsYixjLGQpe2lmKGQ9T2QoYS5XYyxcIl9cIitkKSl7dmFyIGU9bmgoZCk7ZD1lLnBhdGg7ZT1lLnliO2I9VihkLGIpO2M9eWcoYyk7Yz1uZXcgZGgobmV3IGVoKCExLCEwLGUsITApLGIsYyk7cmV0dXJuIG9oKGEsZCxjKX1yZXR1cm5bXX1cbmdoLnByb3RvdHlwZS5HYj1mdW5jdGlvbihhLGIpe3ZhciBjPWEucGF0aCxkPW51bGwsZT0hMTtGZyh0aGlzLm5hLGMsZnVuY3Rpb24oYSxiKXt2YXIgZj1WKGEsYyk7ZD1iLmJiKGYpO2U9ZXx8bnVsbCE9S2coYik7cmV0dXJuIWR9KTt2YXIgZj10aGlzLm5hLmdldChjKTtmPyhlPWV8fG51bGwhPUtnKGYpLGQ9ZHx8Zi5iYihVKSk6KGY9bmV3IEpnLHRoaXMubmE9dGhpcy5uYS5zZXQoYyxmKSk7dmFyIGc7bnVsbCE9ZD9nPSEwOihnPSExLGQ9TSxJZyh0aGlzLm5hLnN1YnRyZWUoYyksZnVuY3Rpb24oYSxiKXt2YXIgYz1iLmJiKFUpO2MmJihkPWQuUChhLGMpKX0pKTt2YXIgaz1udWxsIT1NZyhmLGEpO2lmKCFrJiYhSmMoYS5uKSl7dmFyIGw9cWgoYSk7eSghKGwgaW4gdGhpcy5iYyksXCJWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZ1wiKTt2YXIgbj1yaCsrO3RoaXMuYmNbbF09bjt0aGlzLldjW1wiX1wiK25dPWx9Zz1mLkdiKGEsYixuZXcgWmcoYyx0aGlzLnhiKSxcbmQsZyk7a3x8ZXx8KGY9TWcoZixhKSxnPWcuY29uY2F0KHNoKHRoaXMsYSxmKSkpO3JldHVybiBnfTtcbmdoLnByb3RvdHlwZS5nYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5wYXRoLGU9dGhpcy5uYS5nZXQoZCksZj1bXTtpZihlJiYoXCJkZWZhdWx0XCI9PT1hLkZhKCl8fG51bGwhPU1nKGUsYSkpKXtmPWUuZ2IoYSxiLGMpO2UuZSgpJiYodGhpcy5uYT10aGlzLm5hLnJlbW92ZShkKSk7ZT1mLnJnO2Y9Zi5WZjtiPS0xIT09TmEoZSxmdW5jdGlvbihhKXtyZXR1cm4gSmMoYS5uKX0pO3ZhciBnPURnKHRoaXMubmEsZCxmdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1LZyhiKX0pO2lmKGImJiFnJiYoZD10aGlzLm5hLnN1YnRyZWUoZCksIWQuZSgpKSlmb3IodmFyIGQ9dGgoZCksaz0wO2s8ZC5sZW5ndGg7KytrKXt2YXIgbD1kW2tdLG49bC5WLGw9dWgodGhpcyxsKTt0aGlzLkZjLlBlKG4sdmgodGhpcyxuKSxsLm1kLGwuSCl9aWYoIWcmJjA8ZS5sZW5ndGgmJiFjKWlmKGIpdGhpcy5GYy5RZChhLG51bGwpO2Vsc2V7dmFyIHU9dGhpcztIYShlLGZ1bmN0aW9uKGEpe2EuRmEoKTt2YXIgYj11LmJjW3FoKGEpXTtcbnUuRmMuUWQoYSxiKX0pfXdoKHRoaXMsZSl9cmV0dXJuIGZ9O2doLnByb3RvdHlwZS5wYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMueGIsZD1EZyh0aGlzLm5hLGEsZnVuY3Rpb24oYixjKXt2YXIgZD1WKGIsYSk7aWYoZD1jLmJiKGQpKXJldHVybiBkfSk7cmV0dXJuIGMucGEoYSxkLGIsITApfTtmdW5jdGlvbiB0aChhKXtyZXR1cm4gQmcoYSxmdW5jdGlvbihhLGMsZCl7aWYoYyYmbnVsbCE9S2coYykpcmV0dXJuW0tnKGMpXTt2YXIgZT1bXTtjJiYoZT1MZyhjKSk7QShkLGZ1bmN0aW9uKGEpe2U9ZS5jb25jYXQoYSl9KTtyZXR1cm4gZX0pfWZ1bmN0aW9uIHdoKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDsrK2Mpe3ZhciBkPWJbY107aWYoIUpjKGQubikpe3ZhciBkPXFoKGQpLGU9YS5iY1tkXTtkZWxldGUgYS5iY1tkXTtkZWxldGUgYS5XY1tcIl9cIitlXX19fVxuZnVuY3Rpb24gc2goYSxiLGMpe3ZhciBkPWIucGF0aCxlPXZoKGEsYik7Yz11aChhLGMpO2I9YS5GYy5QZShiLGUsYy5tZCxjLkgpO2Q9YS5uYS5zdWJ0cmVlKGQpO2lmKGUpeShudWxsPT1LZyhkLnZhbHVlKSxcIklmIHdlJ3JlIGFkZGluZyBhIHF1ZXJ5LCBpdCBzaG91bGRuJ3QgYmUgc2hhZG93ZWRcIik7ZWxzZSBmb3IoZT1CZyhkLGZ1bmN0aW9uKGEsYixjKXtpZighYS5lKCkmJmImJm51bGwhPUtnKGIpKXJldHVyblt0ZyhLZyhiKSldO3ZhciBkPVtdO2ImJihkPWQuY29uY2F0KEphKExnKGIpLGZ1bmN0aW9uKGEpe3JldHVybiBhLlZ9KSkpO0EoYyxmdW5jdGlvbihhKXtkPWQuY29uY2F0KGEpfSk7cmV0dXJuIGR9KSxkPTA7ZDxlLmxlbmd0aDsrK2QpYz1lW2RdLGEuRmMuUWQoYyx2aChhLGMpKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHVoKGEsYil7dmFyIGM9Yi5WLGQ9dmgoYSxjKTtyZXR1cm57bWQ6ZnVuY3Rpb24oKXtyZXR1cm4oYi51KCl8fE0pLmhhc2goKX0sSDpmdW5jdGlvbihiLGYpe2lmKFwib2tcIj09PWIpe2lmKGYmJlwib2JqZWN0XCI9PT10eXBlb2YgZiYmcyhmLFwid1wiKSl7dmFyIGc9dChmLFwid1wiKTtlYShnKSYmMDw9R2EoZyxcIm5vX2luZGV4XCIpJiZ6KFwiVXNpbmcgYW4gdW5zcGVjaWZpZWQgaW5kZXguIENvbnNpZGVyIGFkZGluZyBcIisoJ1wiLmluZGV4T25cIjogXCInK2Mubi5nLnRvU3RyaW5nKCkrJ1wiJykrXCIgYXQgXCIrYy5wYXRoLnRvU3RyaW5nKCkrXCIgdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXCIpfWlmKGQpe3ZhciBrPWMucGF0aDtpZihnPU9kKGEuV2MsXCJfXCIrZCkpdmFyIGw9bmgoZyksZz1sLnBhdGgsbD1sLnliLGs9VihnLGspLGs9bmV3IGNoKG5ldyBlaCghMSwhMCxsLCEwKSxrKSxnPW9oKGEsZyxrKTtlbHNlIGc9W119ZWxzZSBnPWloKGEsbmV3IGNoKGZoLFxuYy5wYXRoKSk7cmV0dXJuIGd9Zz1cIlVua25vd24gRXJyb3JcIjtcInRvb19iaWdcIj09PWI/Zz1cIlRoZSBkYXRhIHJlcXVlc3RlZCBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgdGhhdCBjYW4gYmUgYWNjZXNzZWQgd2l0aCBhIHNpbmdsZSByZXF1ZXN0LlwiOlwicGVybWlzc2lvbl9kZW5pZWRcIj09Yj9nPVwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiOlwidW5hdmFpbGFibGVcIj09YiYmKGc9XCJUaGUgc2VydmljZSBpcyB1bmF2YWlsYWJsZVwiKTtnPUVycm9yKGIrXCI6IFwiK2cpO2cuY29kZT1iLnRvVXBwZXJDYXNlKCk7cmV0dXJuIGEuZ2IoYyxudWxsLGcpfX19ZnVuY3Rpb24gcWgoYSl7cmV0dXJuIGEucGF0aC50b1N0cmluZygpK1wiJFwiK2EuRmEoKX1cbmZ1bmN0aW9uIG5oKGEpe3ZhciBiPWEuaW5kZXhPZihcIiRcIik7eSgtMSE9PWImJmI8YS5sZW5ndGgtMSxcIkJhZCBxdWVyeUtleS5cIik7cmV0dXJue3liOmEuc3Vic3RyKGIrMSkscGF0aDpuZXcgUyhhLnN1YnN0cigwLGIpKX19ZnVuY3Rpb24gdmgoYSxiKXt2YXIgYz1xaChiKTtyZXR1cm4gdChhLmJjLGMpfXZhciByaD0xO2Z1bmN0aW9uIG9oKGEsYixjKXt2YXIgZD1hLm5hLmdldChiKTt5KGQsXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO3JldHVybiBkLllhKGMsbmV3IFpnKGIsYS54YiksbnVsbCl9ZnVuY3Rpb24gaWgoYSxiKXtyZXR1cm4geGgoYSxiLGEubmEsbnVsbCxuZXcgWmcoVSxhLnhiKSl9XG5mdW5jdGlvbiB4aChhLGIsYyxkLGUpe2lmKGIucGF0aC5lKCkpcmV0dXJuIHloKGEsYixjLGQsZSk7dmFyIGY9Yy5nZXQoVSk7bnVsbD09ZCYmbnVsbCE9ZiYmKGQ9Zi5iYihVKSk7dmFyIGc9W10saz1JKGIucGF0aCksbD1iLk1jKGspO2lmKChjPWMuY2hpbGRyZW4uZ2V0KGspKSYmbCl2YXIgbj1kP2QuSyhrKTpudWxsLGs9ZS5vKGspLGc9Zy5jb25jYXQoeGgoYSxsLGMsbixrKSk7ZiYmKGc9Zy5jb25jYXQoZi5ZYShiLGUsZCkpKTtyZXR1cm4gZ31mdW5jdGlvbiB5aChhLGIsYyxkLGUpe3ZhciBmPWMuZ2V0KFUpO251bGw9PWQmJm51bGwhPWYmJihkPWYuYmIoVSkpO3ZhciBnPVtdO2MuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYyxmKXt2YXIgbj1kP2QuSyhjKTpudWxsLHU9ZS5vKGMpLHg9Yi5NYyhjKTt4JiYoZz1nLmNvbmNhdCh5aChhLHgsZixuLHUpKSl9KTtmJiYoZz1nLmNvbmNhdChmLllhKGIsZSxkKSkpO3JldHVybiBnfTtmdW5jdGlvbiB6aChhKXt0aGlzLk89YTt0aGlzLlJhPVhkKGEpO3RoaXMuJD1uZXcgZGY7dGhpcy52ZD0xO3RoaXMuUz1uZXcgSmUodGhpcy5PLHEodGhpcy55ZCx0aGlzKSxxKHRoaXMud2QsdGhpcykscSh0aGlzLkhlLHRoaXMpKTt0aGlzLnpnPVlkKGEscShmdW5jdGlvbigpe3JldHVybiBuZXcgVWQodGhpcy5SYSx0aGlzLlMpfSx0aGlzKSk7dGhpcy5sYz1uZXcgVGM7dGhpcy5zZT1uZXcgY2Y7dmFyIGI9dGhpczt0aGlzLnFkPW5ldyBnaCh7UGU6ZnVuY3Rpb24oYSxkLGUsZil7ZD1bXTtlPWIuc2UuaihhLnBhdGgpO2UuZSgpfHwoZD1paChiLnFkLG5ldyAkZyhmaCxhLnBhdGgsZSkpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmKFwib2tcIil9LDApKTtyZXR1cm4gZH0sUWQ6YmF9KTtBaCh0aGlzLFwiY29ubmVjdGVkXCIsITEpO3RoaXMuZ2E9bmV3ICRlO3RoaXMuUT1uZXcgRmYoYSxxKHRoaXMuUy5RLHRoaXMuUykscSh0aGlzLlMuVWUsdGhpcy5TKSxxKHRoaXMuRWUsdGhpcykpO3RoaXMuZ2Q9XG4wO3RoaXMudGU9bnVsbDt0aGlzLk49bmV3IGdoKHtQZTpmdW5jdGlvbihhLGQsZSxmKXtOZShiLlMsYSxlLGQsZnVuY3Rpb24oZCxlKXt2YXIgbD1mKGQsZSk7aGYoYi4kLGEucGF0aCxsKX0pO3JldHVybltdfSxRZDpmdW5jdGlvbihhLGQpe3ZhciBlPWIuUyxmPWEucGF0aC50b1N0cmluZygpLGc9YS5GYSgpO2UuZihcIlVubGlzdGVuIGNhbGxlZCBmb3IgXCIrZitcIiBcIitnKTtpZihQZShlLGYsZykmJmUuamEpe3ZhciBrPUljKGEubik7ZS5mKFwiVW5saXN0ZW4gb24gXCIrZitcIiBmb3IgXCIrZyk7Zj17cDpmfTtkJiYoZi5xPWssZi50PWQpO2UuQ2EoXCJuXCIsZil9fX0pfWg9emgucHJvdG90eXBlO2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5PLkFiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrdGhpcy5PLmhvc3R9O2gubmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLk8udGJ9O1xuZnVuY3Rpb24gQmgoYSl7YT1hLnNlLmoobmV3IFMoXCIuaW5mby9zZXJ2ZXJUaW1lT2Zmc2V0XCIpKS5JKCl8fDA7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCkrYX1mdW5jdGlvbiBDaChhKXthPWE9e3RpbWVzdGFtcDpCaChhKX07YS50aW1lc3RhbXA9YS50aW1lc3RhbXB8fChuZXcgRGF0ZSkuZ2V0VGltZSgpO3JldHVybiBhfWgueWQ9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5nZCsrO3ZhciBlPW5ldyBTKGEpO2I9dGhpcy50ZT90aGlzLnRlKGEsYik6YjthPVtdO2Q/Yz8oYj10ZChiLGZ1bmN0aW9uKGEpe3JldHVybiBPKGEpfSksYT1waCh0aGlzLk4sZSxiLGQpKTooYj1PKGIpLGE9bWgodGhpcy5OLGUsYixkKSk6Yz8oZD10ZChiLGZ1bmN0aW9uKGEpe3JldHVybiBPKGEpfSksYT1saCh0aGlzLk4sZSxkKSk6KGQ9TyhiKSxhPWloKHRoaXMuTixuZXcgJGcoZmgsZSxkKSkpO2Q9ZTswPGEubGVuZ3RoJiYoZD1EaCh0aGlzLGUpKTtoZih0aGlzLiQsZCxhKX07XG5oLndkPWZ1bmN0aW9uKGEpe0FoKHRoaXMsXCJjb25uZWN0ZWRcIixhKTshMT09PWEmJkVoKHRoaXMpfTtoLkhlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7emIoYSxmdW5jdGlvbihhLGQpe0FoKGIsZCxhKX0pfTtoLkVlPWZ1bmN0aW9uKGEpe0FoKHRoaXMsXCJhdXRoZW50aWNhdGVkXCIsYSl9O2Z1bmN0aW9uIEFoKGEsYixjKXtiPW5ldyBTKFwiLy5pbmZvL1wiK2IpO2M9TyhjKTt2YXIgZD1hLnNlO2QuSmQ9ZC5KZC5DKGIsYyk7Yz1paChhLnFkLG5ldyAkZyhmaCxiLGMpKTtoZihhLiQsYixjKX1cbmguQmI9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5mKFwic2V0XCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmIsSGc6Y30pO3ZhciBlPUNoKHRoaXMpO2I9TyhiLGMpO3ZhciBlPVVmKGIsZSksZj10aGlzLnZkKyssZT1oaCh0aGlzLk4sYSxlLGYsITApO2VmKHRoaXMuJCxlKTt2YXIgZz10aGlzO3RoaXMuUy5wdXQoYS50b1N0cmluZygpLGIuSSghMCksZnVuY3Rpb24oYixjKXt2YXIgZT1cIm9rXCI9PT1iO2V8fHooXCJzZXQgYXQgXCIrYStcIiBmYWlsZWQ6IFwiK2IpO2U9a2goZy5OLGYsIWUpO2hmKGcuJCxhLGUpO0ZoKGQsYixjKX0pO2U9R2godGhpcyxhKTtEaCh0aGlzLGUpO2hmKHRoaXMuJCxlLFtdKX07XG5oLnVwZGF0ZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5mKFwidXBkYXRlXCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmJ9KTt2YXIgZD0hMCxlPUNoKHRoaXMpLGY9e307QShiLGZ1bmN0aW9uKGEsYil7ZD0hMTt2YXIgYz1PKGEpO2ZbYl09VWYoYyxlKX0pO2lmKGQpaGIoXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpLEZoKGMsXCJva1wiKTtlbHNle3ZhciBnPXRoaXMudmQrKyxrPWpoKHRoaXMuTixhLGYsZyk7ZWYodGhpcy4kLGspO3ZhciBsPXRoaXM7VmUodGhpcy5TLGEudG9TdHJpbmcoKSxiLGZ1bmN0aW9uKGIsZCl7eShcIm9rXCI9PT1ifHxcInBlcm1pc3Npb25fZGVuaWVkXCI9PT1iLFwibWVyZ2UgYXQgXCIrYStcIiBmYWlsZWQuXCIpO3ZhciBlPVwib2tcIj09PWI7ZXx8eihcInVwZGF0ZSBhdCBcIithK1wiIGZhaWxlZDogXCIrYik7dmFyIGU9a2gobC5OLGcsIWUpLGY9YTswPGUubGVuZ3RoJiYoZj1EaChsLGEpKTtoZihsLiQsZixlKTtGaChjLGIsZCl9KTtcbmI9R2godGhpcyxhKTtEaCh0aGlzLGIpO2hmKHRoaXMuJCxhLFtdKX19O2Z1bmN0aW9uIEVoKGEpe2EuZihcIm9uRGlzY29ubmVjdEV2ZW50c1wiKTt2YXIgYj1DaChhKSxjPVtdO2JmKFRmKGEuZ2EsYiksVSxmdW5jdGlvbihiLGUpe2M9Yy5jb25jYXQoaWgoYS5OLG5ldyAkZyhmaCxiLGUpKSk7dmFyIGY9R2goYSxiKTtEaChhLGYpfSk7YS5nYT1uZXcgJGU7aGYoYS4kLFUsYyl9aC5GZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5TLkZlKGEudG9TdHJpbmcoKSxmdW5jdGlvbihkLGUpe1wib2tcIj09PWQmJmFmKGMuZ2EsYSk7RmgoYixkLGUpfSl9O2Z1bmN0aW9uIEhoKGEsYixjLGQpe3ZhciBlPU8oYyk7UmUoYS5TLGIudG9TdHJpbmcoKSxlLkkoITApLGZ1bmN0aW9uKGMsZyl7XCJva1wiPT09YyYmYS5nYS5kYyhiLGUpO0ZoKGQsYyxnKX0pfVxuZnVuY3Rpb24gSWgoYSxiLGMsZCxlKXt2YXIgZj1PKGMsZCk7UmUoYS5TLGIudG9TdHJpbmcoKSxmLkkoITApLGZ1bmN0aW9uKGMsZCl7XCJva1wiPT09YyYmYS5nYS5kYyhiLGYpO0ZoKGUsYyxkKX0pfWZ1bmN0aW9uIEpoKGEsYixjLGQpe3ZhciBlPSEwLGY7Zm9yKGYgaW4gYyllPSExO2U/KGhiKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKSxGaChkLFwib2tcIikpOlRlKGEuUyxiLnRvU3RyaW5nKCksYyxmdW5jdGlvbihlLGYpe2lmKFwib2tcIj09PWUpZm9yKHZhciBsIGluIGMpe3ZhciBuPU8oY1tsXSk7YS5nYS5kYyhiLm8obCksbil9RmgoZCxlLGYpfSl9ZnVuY3Rpb24gT2MoYSxiLGMpe2M9XCIuaW5mb1wiPT09SShiLnBhdGgpP2EucWQuR2IoYixjKTphLk4uR2IoYixjKTtQYyhhLiQsYi5wYXRoLGMpfWgucGI9ZnVuY3Rpb24oKXt0aGlzLlMucGIoKX07aC5oYz1mdW5jdGlvbigpe3RoaXMuUy5oYygpfTtcbmguUWU9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXthPyh0aGlzLlBkfHwodGhpcy5QZD1uZXcgVGQodGhpcy5SYSkpLGE9dGhpcy5QZC5nZXQoKSk6YT10aGlzLlJhLmdldCgpO3ZhciBiPUthKEtkKGEpLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGgubWF4KGIubGVuZ3RoLGEpfSwwKSxjO2ZvcihjIGluIGEpe2Zvcih2YXIgZD1hW2NdLGU9Yy5sZW5ndGg7ZTxiKzI7ZSsrKWMrPVwiIFwiO2NvbnNvbGUubG9nKGMrZCl9fX07aC5SZT1mdW5jdGlvbihhKXtTZCh0aGlzLlJhLGEpO3RoaXMuemcuemZbYV09ITB9O2guZj1mdW5jdGlvbihhKXtoYihcInI6XCIrdGhpcy5TLmlkK1wiOlwiLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIEZoKGEsYixjKXthJiZDYihmdW5jdGlvbigpe2lmKFwib2tcIj09YilhKG51bGwpO2Vsc2V7dmFyIGQ9KGJ8fFwiZXJyb3JcIikudG9VcHBlckNhc2UoKSxlPWQ7YyYmKGUrPVwiOiBcIitjKTtlPUVycm9yKGUpO2UuY29kZT1kO2EoZSl9fSl9O2Z1bmN0aW9uIEtoKGEsYixjLGQsZSl7ZnVuY3Rpb24gZigpe31hLmYoXCJ0cmFuc2FjdGlvbiBvbiBcIitiKTt2YXIgZz1uZXcgUihhLGIpO2cudmIoXCJ2YWx1ZVwiLGYpO2M9e3BhdGg6Yix1cGRhdGU6YyxIOmQsc3RhdHVzOm51bGwscWY6ZWIoKSxWZTplLHhmOjAsWGQ6ZnVuY3Rpb24oKXtnLlpiKFwidmFsdWVcIixmKX0sJGQ6bnVsbCx4YTpudWxsLGRkOm51bGwsZWQ6bnVsbCxmZDpudWxsfTtkPWEuTi5wYShiLHZvaWQgMCl8fE07Yy5kZD1kO2Q9Yy51cGRhdGUoZC5JKCkpO2lmKG0oZCkpe1NiKFwidHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkIFwiLGQpO2Muc3RhdHVzPTE7ZT1VYyhhLmxjLGIpO3ZhciBrPWUuemEoKXx8W107ay5wdXNoKGMpO1ZjKGUsayk7XCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCYmcyhkLFwiLnByaW9yaXR5XCIpPyhrPXQoZCxcIi5wcmlvcml0eVwiKSx5KFFiKGspLFwiSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLlwiKSk6XG5rPShhLk4ucGEoYil8fE0pLkwoKS5JKCk7ZT1DaChhKTtkPU8oZCxrKTtlPVVmKGQsZSk7Yy5lZD1kO2MuZmQ9ZTtjLnhhPWEudmQrKztjPWhoKGEuTixiLGUsYy54YSxjLlZlKTtoZihhLiQsYixjKTtMaChhKX1lbHNlIGMuWGQoKSxjLmVkPW51bGwsYy5mZD1udWxsLGMuSCYmKGE9bmV3IEQoYy5kZCxuZXcgUihhLGMucGF0aCksTCksYy5IKG51bGwsITEsYSkpfWZ1bmN0aW9uIExoKGEsYil7dmFyIGM9Ynx8YS5sYztifHxNaChhLGMpO2lmKG51bGwhPT1jLnphKCkpe3ZhciBkPU5oKGEsYyk7eSgwPGQubGVuZ3RoLFwiU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZVwiKTtMYShkLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5zdGF0dXN9KSYmT2goYSxjLnBhdGgoKSxkKX1lbHNlIGMubGQoKSYmYy5VKGZ1bmN0aW9uKGIpe0xoKGEsYil9KX1cbmZ1bmN0aW9uIE9oKGEsYixjKXtmb3IodmFyIGQ9SmEoYyxmdW5jdGlvbihhKXtyZXR1cm4gYS54YX0pLGU9YS5OLnBhKGIsZCl8fE0sZD1lLGU9ZS5oYXNoKCksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1jW2ZdO3koMT09PWcuc3RhdHVzLFwidHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLlwiKTtnLnN0YXR1cz0yO2cueGYrKzt2YXIgaz1WKGIsZy5wYXRoKSxkPWQuQyhrLGcuZWQpfWQ9ZC5JKCEwKTthLlMucHV0KGIudG9TdHJpbmcoKSxkLGZ1bmN0aW9uKGQpe2EuZihcInRyYW5zYWN0aW9uIHB1dCByZXNwb25zZVwiLHtwYXRoOmIudG9TdHJpbmcoKSxzdGF0dXM6ZH0pO3ZhciBlPVtdO2lmKFwib2tcIj09PWQpe2Q9W107Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKyl7Y1tmXS5zdGF0dXM9MztlPWUuY29uY2F0KGtoKGEuTixjW2ZdLnhhKSk7aWYoY1tmXS5IKXt2YXIgZz1jW2ZdLmZkLGs9bmV3IFIoYSxjW2ZdLnBhdGgpO2QucHVzaChxKGNbZl0uSCxcbm51bGwsbnVsbCwhMCxuZXcgRChnLGssTCkpKX1jW2ZdLlhkKCl9TWgoYSxVYyhhLmxjLGIpKTtMaChhKTtoZihhLiQsYixlKTtmb3IoZj0wO2Y8ZC5sZW5ndGg7ZisrKUNiKGRbZl0pfWVsc2V7aWYoXCJkYXRhc3RhbGVcIj09PWQpZm9yKGY9MDtmPGMubGVuZ3RoO2YrKyljW2ZdLnN0YXR1cz00PT09Y1tmXS5zdGF0dXM/NToxO2Vsc2UgZm9yKHooXCJ0cmFuc2FjdGlvbiBhdCBcIitiLnRvU3RyaW5nKCkrXCIgZmFpbGVkOiBcIitkKSxmPTA7ZjxjLmxlbmd0aDtmKyspY1tmXS5zdGF0dXM9NSxjW2ZdLiRkPWQ7RGgoYSxiKX19LGUpfWZ1bmN0aW9uIERoKGEsYil7dmFyIGM9UGgoYSxiKSxkPWMucGF0aCgpLGM9TmgoYSxjKTtRaChhLGMsZCk7cmV0dXJuIGR9XG5mdW5jdGlvbiBRaChhLGIsYyl7aWYoMCE9PWIubGVuZ3RoKXtmb3IodmFyIGQ9W10sZT1bXSxmPUphKGIsZnVuY3Rpb24oYSl7cmV0dXJuIGEueGF9KSxnPTA7ZzxiLmxlbmd0aDtnKyspe3ZhciBrPWJbZ10sbD1WKGMsay5wYXRoKSxuPSExLHU7eShudWxsIT09bCxcInJlcnVuVHJhbnNhY3Rpb25zVW5kZXJOb2RlXzogcmVsYXRpdmVQYXRoIHNob3VsZCBub3QgYmUgbnVsbC5cIik7aWYoNT09PWsuc3RhdHVzKW49ITAsdT1rLiRkLGU9ZS5jb25jYXQoa2goYS5OLGsueGEsITApKTtlbHNlIGlmKDE9PT1rLnN0YXR1cylpZigyNTw9ay54ZiluPSEwLHU9XCJtYXhyZXRyeVwiLGU9ZS5jb25jYXQoa2goYS5OLGsueGEsITApKTtlbHNle3ZhciB4PWEuTi5wYShrLnBhdGgsZil8fE07ay5kZD14O3ZhciBFPWJbZ10udXBkYXRlKHguSSgpKTttKEUpPyhTYihcInRyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCBcIixFKSxsPU8oRSksXCJvYmplY3RcIj09PXR5cGVvZiBFJiZudWxsIT1FJiZzKEUsXG5cIi5wcmlvcml0eVwiKXx8KGw9bC5aKHguTCgpKSkseD1rLnhhLEU9Q2goYSksRT1VZihsLEUpLGsuZWQ9bCxrLmZkPUUsay54YT1hLnZkKyssT2EoZix4KSxlPWUuY29uY2F0KGhoKGEuTixrLnBhdGgsRSxrLnhhLGsuVmUpKSxlPWUuY29uY2F0KGtoKGEuTix4LCEwKSkpOihuPSEwLHU9XCJub2RhdGFcIixlPWUuY29uY2F0KGtoKGEuTixrLnhhLCEwKSkpfWhmKGEuJCxjLGUpO2U9W107biYmKGJbZ10uc3RhdHVzPTMsc2V0VGltZW91dChiW2ddLlhkLE1hdGguZmxvb3IoMCkpLGJbZ10uSCYmKFwibm9kYXRhXCI9PT11PyhrPW5ldyBSKGEsYltnXS5wYXRoKSxkLnB1c2gocShiW2ddLkgsbnVsbCxudWxsLCExLG5ldyBEKGJbZ10uZGQsayxMKSkpKTpkLnB1c2gocShiW2ddLkgsbnVsbCxFcnJvcih1KSwhMSxudWxsKSkpKX1NaChhLGEubGMpO2ZvcihnPTA7ZzxkLmxlbmd0aDtnKyspQ2IoZFtnXSk7TGgoYSl9fVxuZnVuY3Rpb24gUGgoYSxiKXtmb3IodmFyIGMsZD1hLmxjO251bGwhPT0oYz1JKGIpKSYmbnVsbD09PWQuemEoKTspZD1VYyhkLGMpLGI9VChiKTtyZXR1cm4gZH1mdW5jdGlvbiBOaChhLGIpe3ZhciBjPVtdO1JoKGEsYixjKTtjLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5xZi1iLnFmfSk7cmV0dXJuIGN9ZnVuY3Rpb24gUmgoYSxiLGMpe3ZhciBkPWIuemEoKTtpZihudWxsIT09ZClmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyljLnB1c2goZFtlXSk7Yi5VKGZ1bmN0aW9uKGIpe1JoKGEsYixjKX0pfWZ1bmN0aW9uIE1oKGEsYil7dmFyIGM9Yi56YSgpO2lmKGMpe2Zvcih2YXIgZD0wLGU9MDtlPGMubGVuZ3RoO2UrKykzIT09Y1tlXS5zdGF0dXMmJihjW2RdPWNbZV0sZCsrKTtjLmxlbmd0aD1kO1ZjKGIsMDxjLmxlbmd0aD9jOm51bGwpfWIuVShmdW5jdGlvbihiKXtNaChhLGIpfSl9XG5mdW5jdGlvbiBHaChhLGIpe3ZhciBjPVBoKGEsYikucGF0aCgpLGQ9VWMoYS5sYyxiKTtZYyhkLGZ1bmN0aW9uKGIpe1NoKGEsYil9KTtTaChhLGQpO1hjKGQsZnVuY3Rpb24oYil7U2goYSxiKX0pO3JldHVybiBjfVxuZnVuY3Rpb24gU2goYSxiKXt2YXIgYz1iLnphKCk7aWYobnVsbCE9PWMpe2Zvcih2YXIgZD1bXSxlPVtdLGY9LTEsZz0wO2c8Yy5sZW5ndGg7ZysrKTQhPT1jW2ddLnN0YXR1cyYmKDI9PT1jW2ddLnN0YXR1cz8oeShmPT09Zy0xLFwiQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS5cIiksZj1nLGNbZ10uc3RhdHVzPTQsY1tnXS4kZD1cInNldFwiKTooeSgxPT09Y1tnXS5zdGF0dXMsXCJVbmV4cGVjdGVkIHRyYW5zYWN0aW9uIHN0YXR1cyBpbiBhYm9ydFwiKSxjW2ddLlhkKCksZT1lLmNvbmNhdChraChhLk4sY1tnXS54YSwhMCkpLGNbZ10uSCYmZC5wdXNoKHEoY1tnXS5ILG51bGwsRXJyb3IoXCJzZXRcIiksITEsbnVsbCkpKSk7LTE9PT1mP1ZjKGIsbnVsbCk6Yy5sZW5ndGg9ZisxO2hmKGEuJCxiLnBhdGgoKSxlKTtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKUNiKGRbZ10pfX07ZnVuY3Rpb24gVGgoKXt0aGlzLmVjPXt9fWNhKFRoKTtUaC5wcm90b3R5cGUucGI9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5lYyl0aGlzLmVjW2FdLnBiKCl9O1RoLnByb3RvdHlwZS5pbnRlcnJ1cHQ9VGgucHJvdG90eXBlLnBiO1RoLnByb3RvdHlwZS5oYz1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLmVjKXRoaXMuZWNbYV0uaGMoKX07VGgucHJvdG90eXBlLnJlc3VtZT1UaC5wcm90b3R5cGUuaGM7ZnVuY3Rpb24gVWgoYSl7dmFyIGI9dGhpczt0aGlzLnJjPWE7dGhpcy5TZD1cIipcIjt4ZigpP3RoaXMuSGM9dGhpcy5vZD1vZigpOih0aGlzLkhjPXdpbmRvdy5vcGVuZXIsdGhpcy5vZD13aW5kb3cpO2lmKCFiLkhjKXRocm93XCJVbmFibGUgdG8gZmluZCByZWxheSBmcmFtZVwiO3BmKHRoaXMub2QsXCJtZXNzYWdlXCIscSh0aGlzLiRiLHRoaXMpKTtwZih0aGlzLm9kLFwibWVzc2FnZVwiLHEodGhpcy5uZix0aGlzKSk7dHJ5e1ZoKHRoaXMse2E6XCJyZWFkeVwifSl9Y2F0Y2goYyl7cGYodGhpcy5IYyxcImxvYWRcIixmdW5jdGlvbigpe1ZoKGIse2E6XCJyZWFkeVwifSl9KX1wZih3aW5kb3csXCJ1bmxvYWRcIixxKHRoaXMuamcsdGhpcykpfWZ1bmN0aW9uIFZoKGEsYil7Yj1yKGIpO3hmKCk/YS5IYy5kb1Bvc3QoYixhLlNkKTphLkhjLnBvc3RNZXNzYWdlKGIsYS5TZCl9XG5VaC5wcm90b3R5cGUuJGI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjO3RyeXtjPXRhKGEuZGF0YSl9Y2F0Y2goZCl7fWMmJlwicmVxdWVzdFwiPT09Yy5hJiYocWYod2luZG93LFwibWVzc2FnZVwiLHRoaXMuJGIpLHRoaXMuU2Q9YS5vcmlnaW4sdGhpcy5yYyYmc2V0VGltZW91dChmdW5jdGlvbigpe2IucmMoYi5TZCxjLmQsZnVuY3Rpb24oYSxjKXtiLk1mPSFjO2IucmM9dm9pZCAwO1ZoKGIse2E6XCJyZXNwb25zZVwiLGQ6YSxmb3JjZUtlZXBXaW5kb3dPcGVuOmN9KX0pfSwwKSl9O1VoLnByb3RvdHlwZS5qZz1mdW5jdGlvbigpe3RyeXtxZih0aGlzLm9kLFwibWVzc2FnZVwiLHRoaXMubmYpfWNhdGNoKGEpe310aGlzLnJjJiYoVmgodGhpcyx7YTpcImVycm9yXCIsZDpcInVua25vd24gY2xvc2VkIHdpbmRvd1wifSksdGhpcy5yYz12b2lkIDApO3RyeXt3aW5kb3cuY2xvc2UoKX1jYXRjaChiKXt9fTtVaC5wcm90b3R5cGUubmY9ZnVuY3Rpb24oYSl7aWYodGhpcy5NZiYmXCJkaWVcIj09PWEuZGF0YSl0cnl7d2luZG93LmNsb3NlKCl9Y2F0Y2goYil7fX07dmFyIFk9e1hmOmZ1bmN0aW9uKCl7amU9YWU9ITB9fTtZLmZvcmNlTG9uZ1BvbGxpbmc9WS5YZjtZLllmPWZ1bmN0aW9uKCl7a2U9ITB9O1kuZm9yY2VXZWJTb2NrZXRzPVkuWWY7WS53Zz1mdW5jdGlvbihhLGIpe2Euay5TLk9lPWJ9O1kuc2V0U2VjdXJpdHlEZWJ1Z0NhbGxiYWNrPVkud2c7WS5RZT1mdW5jdGlvbihhLGIpe2Euay5RZShiKX07WS5zdGF0cz1ZLlFlO1kuUmU9ZnVuY3Rpb24oYSxiKXthLmsuUmUoYil9O1kuc3RhdHNJbmNyZW1lbnRDb3VudGVyPVkuUmU7WS5nZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLmdkfTtZLmRhdGFVcGRhdGVDb3VudD1ZLmdkO1kuYWc9ZnVuY3Rpb24oYSxiKXthLmsudGU9Yn07WS5pbnRlcmNlcHRTZXJ2ZXJEYXRhPVkuYWc7WS5nZz1mdW5jdGlvbihhKXtuZXcgVWgoYSl9O1kub25Qb3B1cE9wZW49WS5nZztZLnVnPWZ1bmN0aW9uKGEpe2pmPWF9O1kuc2V0QXV0aGVudGljYXRpb25TZXJ2ZXI9WS51ZztmdW5jdGlvbiBaKGEsYil7dGhpcy5SYz1hO3RoaXMuRWE9Yn1aLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7RihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuY2FuY2VsXCIsMSxhLCEwKTt0aGlzLlJjLkZlKHRoaXMuRWEsYXx8bnVsbCl9O1oucHJvdG90eXBlLmNhbmNlbD1aLnByb3RvdHlwZS5jYW5jZWw7Wi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe0YoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIix0aGlzLkVhKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsMSxhLCEwKTtIaCh0aGlzLlJjLHRoaXMuRWEsbnVsbCxhKX07Wi5wcm90b3R5cGUucmVtb3ZlPVoucHJvdG90eXBlLnJlbW92ZTtcbloucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwyLGIsITApO0hoKHRoaXMuUmMsdGhpcy5FYSxhLGIpfTtaLnByb3RvdHlwZS5zZXQ9Wi5wcm90b3R5cGUuc2V0O1xuWi5wcm90b3R5cGUuQmI9ZnVuY3Rpb24oYSxiLGMpe0YoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLGEsITEpO1ZiKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMixiKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMyxjLCEwKTtJaCh0aGlzLlJjLHRoaXMuRWEsYSxiLGMpfTtaLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9Wi5wcm90b3R5cGUuQmI7XG5aLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsdGhpcy5FYSk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLDIsYiwhMCk7SmgodGhpcy5SYyxcbnRoaXMuRWEsYSxiKX07Wi5wcm90b3R5cGUudXBkYXRlPVoucHJvdG90eXBlLnVwZGF0ZTt2YXIgJD17fTskLm5jPUplOyQuRGF0YUNvbm5lY3Rpb249JC5uYztKZS5wcm90b3R5cGUueWc9ZnVuY3Rpb24oYSxiKXt0aGlzLkNhKFwicVwiLHtwOmF9LGIpfTskLm5jLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW49JC5uYy5wcm90b3R5cGUueWc7SmUucHJvdG90eXBlLlNmPWZ1bmN0aW9uKGEsYil7dGhpcy5DYShcImVjaG9cIix7ZDphfSxiKX07JC5uYy5wcm90b3R5cGUuZWNobz0kLm5jLnByb3RvdHlwZS5TZjtKZS5wcm90b3R5cGUuaW50ZXJydXB0PUplLnByb3RvdHlwZS5wYjskLkRmPXVlOyQuUmVhbFRpbWVDb25uZWN0aW9uPSQuRGY7dWUucHJvdG90eXBlLnNlbmRSZXF1ZXN0PXVlLnByb3RvdHlwZS5DYTt1ZS5wcm90b3R5cGUuY2xvc2U9dWUucHJvdG90eXBlLmNsb3NlO1xuJC4kZj1mdW5jdGlvbihhKXt2YXIgYj1KZS5wcm90b3R5cGUucHV0O0plLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYyxkLGUsZil7bShmKSYmKGY9YSgpKTtiLmNhbGwodGhpcyxjLGQsZSxmKX07cmV0dXJuIGZ1bmN0aW9uKCl7SmUucHJvdG90eXBlLnB1dD1ifX07JC5oaWphY2tIYXNoPSQuJGY7JC5DZj1BYTskLkNvbm5lY3Rpb25UYXJnZXQ9JC5DZjskLkZhPWZ1bmN0aW9uKGEpe3JldHVybiBhLkZhKCl9OyQucXVlcnlJZGVudGlmaWVyPSQuRmE7JC5iZz1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLlMuQWF9OyQubGlzdGVucz0kLmJnO3ZhciBXaD1mdW5jdGlvbigpe3ZhciBhPTAsYj1bXTtyZXR1cm4gZnVuY3Rpb24oYyl7dmFyIGQ9Yz09PWE7YT1jO2Zvcih2YXIgZT1BcnJheSg4KSxmPTc7MDw9ZjtmLS0pZVtmXT1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYyU2NCksYz1NYXRoLmZsb29yKGMvNjQpO3koMD09PWMsXCJDYW5ub3QgcHVzaCBhdCB0aW1lID09IDBcIik7Yz1lLmpvaW4oXCJcIik7aWYoZCl7Zm9yKGY9MTE7MDw9ZiYmNjM9PT1iW2ZdO2YtLSliW2ZdPTA7YltmXSsrfWVsc2UgZm9yKGY9MDsxMj5mO2YrKyliW2ZdPU1hdGguZmxvb3IoNjQqTWF0aC5yYW5kb20oKSk7Zm9yKGY9MDsxMj5mO2YrKyljKz1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYltmXSk7eSgyMD09PWMubGVuZ3RoLFwiTmV4dFB1c2hJZDogTGVuZ3RoIHNob3VsZCBiZSAyMC5cIik7XG5yZXR1cm4gY319KCk7ZnVuY3Rpb24gUihhLGIpe3ZhciBjLGQsZTtpZihhIGluc3RhbmNlb2YgemgpYz1hLGQ9YjtlbHNle0YoXCJuZXcgRmlyZWJhc2VcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7ZD1yYihhcmd1bWVudHNbMF0pO2M9ZC5BZztcImZpcmViYXNlXCI9PT1kLmRvbWFpbiYmcWIoZC5ob3N0K1wiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWRcIik7Y3x8cWIoXCJDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tXCIpO2QuQWJ8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24mJndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmLTEhPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSYmeihcIkluc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuIFBsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuXCIpO1xuYz1uZXcgQWEoZC5ob3N0LGQuQWIsYyxcIndzXCI9PT1kLnNjaGVtZXx8XCJ3c3NcIj09PWQuc2NoZW1lKTtkPW5ldyBTKGQuUGMpO2U9ZC50b1N0cmluZygpO3ZhciBmOyEoZj0hcChjLmhvc3QpfHwwPT09Yy5ob3N0Lmxlbmd0aHx8IVBiKGMudGIpKSYmKGY9MCE9PWUubGVuZ3RoKSYmKGUmJihlPWUucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sXCIvXCIpKSxmPSEocChlKSYmMCE9PWUubGVuZ3RoJiYhT2IudGVzdChlKSkpO2lmKGYpdGhyb3cgRXJyb3IoRyhcIm5ldyBGaXJlYmFzZVwiLDEsITEpKydtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCB0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO2lmKGIpaWYoYiBpbnN0YW5jZW9mIFRoKWU9YjtlbHNlIGlmKHAoYikpZT1UaC5OYigpLGMuRGQ9YjtlbHNlIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgYSB2YWxpZCBGaXJlYmFzZS5Db250ZXh0IGZvciBzZWNvbmQgYXJndW1lbnQgdG8gbmV3IEZpcmViYXNlKClcIik7XG5lbHNlIGU9VGguTmIoKTtmPWMudG9TdHJpbmcoKTt2YXIgZz10KGUuZWMsZik7Z3x8KGc9bmV3IHpoKGMpLGUuZWNbZl09Zyk7Yz1nfVEuY2FsbCh0aGlzLGMsZCxGYywhMSl9bWEoUixRKTt2YXIgWGg9UixZaD1bXCJGaXJlYmFzZVwiXSxaaD1hYTtZaFswXWluIFpofHwhWmguZXhlY1NjcmlwdHx8WmguZXhlY1NjcmlwdChcInZhciBcIitZaFswXSk7Zm9yKHZhciAkaDtZaC5sZW5ndGgmJigkaD1ZaC5zaGlmdCgpKTspIVloLmxlbmd0aCYmbShYaCk/WmhbJGhdPVhoOlpoPVpoWyRoXT9aaFskaF06WmhbJGhdPXt9O1IucHJvdG90eXBlLm5hbWU9ZnVuY3Rpb24oKXt6KFwiRmlyZWJhc2UubmFtZSgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2Uua2V5KCkgaW5zdGVhZC5cIik7RihcIkZpcmViYXNlLm5hbWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMua2V5KCl9O1IucHJvdG90eXBlLm5hbWU9Ui5wcm90b3R5cGUubmFtZTtcblIucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMucGF0aC5lKCk/bnVsbDpSYyh0aGlzLnBhdGgpfTtSLnByb3RvdHlwZS5rZXk9Ui5wcm90b3R5cGUua2V5O1IucHJvdG90eXBlLm89ZnVuY3Rpb24oYSl7RihcIkZpcmViYXNlLmNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKGdhKGEpKWE9U3RyaW5nKGEpO2Vsc2UgaWYoIShhIGluc3RhbmNlb2YgUykpaWYobnVsbD09PUkodGhpcy5wYXRoKSl7dmFyIGI9YTtiJiYoYj1iLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLFwiL1wiKSk7WWIoXCJGaXJlYmFzZS5jaGlsZFwiLGIpfWVsc2UgWWIoXCJGaXJlYmFzZS5jaGlsZFwiLGEpO3JldHVybiBuZXcgUih0aGlzLmssdGhpcy5wYXRoLm8oYSkpfTtSLnByb3RvdHlwZS5jaGlsZD1SLnByb3RvdHlwZS5vO1xuUi5wcm90b3R5cGUucGFyZW50PWZ1bmN0aW9uKCl7RihcIkZpcmViYXNlLnBhcmVudFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt2YXIgYT10aGlzLnBhdGgucGFyZW50KCk7cmV0dXJuIG51bGw9PT1hP251bGw6bmV3IFIodGhpcy5rLGEpfTtSLnByb3RvdHlwZS5wYXJlbnQ9Ui5wcm90b3R5cGUucGFyZW50O1IucHJvdG90eXBlLnJvb3Q9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzO251bGwhPT1hLnBhcmVudCgpOylhPWEucGFyZW50KCk7cmV0dXJuIGF9O1IucHJvdG90eXBlLnJvb3Q9Ui5wcm90b3R5cGUucm9vdDtcblIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7RihcIkZpcmViYXNlLnRvU3RyaW5nXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3ZhciBhO2lmKG51bGw9PT10aGlzLnBhcmVudCgpKWE9dGhpcy5rLnRvU3RyaW5nKCk7ZWxzZXthPXRoaXMucGFyZW50KCkudG9TdHJpbmcoKStcIi9cIjt2YXIgYj10aGlzLmtleSgpO2ErPWVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYikpfXJldHVybiBhfTtSLnByb3RvdHlwZS50b1N0cmluZz1SLnByb3RvdHlwZS50b1N0cmluZztSLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2Uuc2V0XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uuc2V0XCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5zZXRcIiwyLGIsITApO3RoaXMuay5CYih0aGlzLnBhdGgsYSxudWxsLGJ8fG51bGwpfTtSLnByb3RvdHlwZS5zZXQ9Ui5wcm90b3R5cGUuc2V0O1xuUi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLnVwZGF0ZVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnVwZGF0ZVwiLHRoaXMucGF0aCk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2UudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLnVwZGF0ZVwiLDIsYiwhMCk7aWYocyhhLFwiLnByaW9yaXR5XCIpKXRocm93IEVycm9yKFwidXBkYXRlKCkgZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgdXBkYXRpbmcgLnByaW9yaXR5LlwiKTtcbnRoaXMuay51cGRhdGUodGhpcy5wYXRoLGEsYnx8bnVsbCl9O1IucHJvdG90eXBlLnVwZGF0ZT1SLnByb3RvdHlwZS51cGRhdGU7Ui5wcm90b3R5cGUuQmI9ZnVuY3Rpb24oYSxiLGMpe0YoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLnBhdGgpO1JiKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsYSwhMSk7VmIoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwyLGIpO0goXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwzLGMsITApO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5rZXkoKXx8XCIua2V5c1wiPT09dGhpcy5rZXkoKSl0aHJvd1wiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogXCIrdGhpcy5rZXkoKStcIiBpcyBhIHJlYWQtb25seSBvYmplY3QuXCI7dGhpcy5rLkJiKHRoaXMucGF0aCxhLGIsY3x8bnVsbCl9O1IucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eT1SLnByb3RvdHlwZS5CYjtcblIucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXtGKFwiRmlyZWJhc2UucmVtb3ZlXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2UucmVtb3ZlXCIsdGhpcy5wYXRoKTtIKFwiRmlyZWJhc2UucmVtb3ZlXCIsMSxhLCEwKTt0aGlzLnNldChudWxsLGEpfTtSLnByb3RvdHlwZS5yZW1vdmU9Ui5wcm90b3R5cGUucmVtb3ZlO1xuUi5wcm90b3R5cGUudHJhbnNhY3Rpb249ZnVuY3Rpb24oYSxiLGMpe0YoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDEsMyxhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsdGhpcy5wYXRoKTtIKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwxLGEsITEpO0goXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDIsYiwhMCk7aWYobShjKSYmXCJib29sZWFuXCIhPXR5cGVvZiBjKXRocm93IEVycm9yKEcoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDMsITApK1wibXVzdCBiZSBhIGJvb2xlYW4uXCIpO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5rZXkoKXx8XCIua2V5c1wiPT09dGhpcy5rZXkoKSl0aHJvd1wiRmlyZWJhc2UudHJhbnNhY3Rpb24gZmFpbGVkOiBcIit0aGlzLmtleSgpK1wiIGlzIGEgcmVhZC1vbmx5IG9iamVjdC5cIjtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMmJihjPSEwKTtLaCh0aGlzLmssdGhpcy5wYXRoLGEsYnx8bnVsbCxjKX07Ui5wcm90b3R5cGUudHJhbnNhY3Rpb249Ui5wcm90b3R5cGUudHJhbnNhY3Rpb247XG5SLnByb3RvdHlwZS52Zz1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsdGhpcy5wYXRoKTtWYihcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMSxhKTtIKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwyLGIsITApO3RoaXMuay5CYih0aGlzLnBhdGgubyhcIi5wcmlvcml0eVwiKSxhLG51bGwsYil9O1IucHJvdG90eXBlLnNldFByaW9yaXR5PVIucHJvdG90eXBlLnZnO1IucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UucHVzaFwiLDAsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnB1c2hcIix0aGlzLnBhdGgpO1JiKFwiRmlyZWJhc2UucHVzaFwiLGEsITApO0goXCJGaXJlYmFzZS5wdXNoXCIsMixiLCEwKTt2YXIgYz1CaCh0aGlzLmspLGM9V2goYyksYz10aGlzLm8oYyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiZudWxsIT09YSYmYy5zZXQoYSxiKTtyZXR1cm4gY307XG5SLnByb3RvdHlwZS5wdXNoPVIucHJvdG90eXBlLnB1c2g7Ui5wcm90b3R5cGUuZmI9ZnVuY3Rpb24oKXtaYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdFwiLHRoaXMucGF0aCk7cmV0dXJuIG5ldyBaKHRoaXMuayx0aGlzLnBhdGgpfTtSLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3Q9Ui5wcm90b3R5cGUuZmI7Ui5wcm90b3R5cGUuUT1mdW5jdGlvbihhLGIsYyl7eihcIkZpcmViYXNlUmVmLmF1dGgoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZpcmViYXNlUmVmLmF1dGhXaXRoQ3VzdG9tVG9rZW4oKSBpbnN0ZWFkLlwiKTtGKFwiRmlyZWJhc2UuYXV0aFwiLDEsMyxhcmd1bWVudHMubGVuZ3RoKTskYihcIkZpcmViYXNlLmF1dGhcIixhKTtIKFwiRmlyZWJhc2UuYXV0aFwiLDIsYiwhMCk7SChcIkZpcmViYXNlLmF1dGhcIiwzLGIsITApO0xmKHRoaXMuay5RLGEse30se3JlbWVtYmVyOlwibm9uZVwifSxiLGMpfTtSLnByb3RvdHlwZS5hdXRoPVIucHJvdG90eXBlLlE7XG5SLnByb3RvdHlwZS5VZT1mdW5jdGlvbihhKXtGKFwiRmlyZWJhc2UudW5hdXRoXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS51bmF1dGhcIiwxLGEsITApO01mKHRoaXMuay5RLGEpfTtSLnByb3RvdHlwZS51bmF1dGg9Ui5wcm90b3R5cGUuVWU7Ui5wcm90b3R5cGUubmU9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuZ2V0QXV0aFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5rLlEubmUoKX07Ui5wcm90b3R5cGUuZ2V0QXV0aD1SLnByb3RvdHlwZS5uZTtSLnByb3RvdHlwZS5mZz1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5vbkF1dGhcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7SChcIkZpcmViYXNlLm9uQXV0aFwiLDEsYSwhMSk7TWIoXCJGaXJlYmFzZS5vbkF1dGhcIiwyLGIpO3RoaXMuay5RLnZiKFwiYXV0aF9zdGF0dXNcIixhLGIpfTtSLnByb3RvdHlwZS5vbkF1dGg9Ui5wcm90b3R5cGUuZmc7XG5SLnByb3RvdHlwZS5lZz1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5vZmZBdXRoXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS5vZmZBdXRoXCIsMSxhLCExKTtNYihcIkZpcmViYXNlLm9mZkF1dGhcIiwyLGIpO3RoaXMuay5RLlpiKFwiYXV0aF9zdGF0dXNcIixhLGIpfTtSLnByb3RvdHlwZS5vZmZBdXRoPVIucHJvdG90eXBlLmVnO1IucHJvdG90eXBlLkhmPWZ1bmN0aW9uKGEsYixjKXtGKFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTskYihcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIixhKTtIKFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwzLGMsITApO0xmKHRoaXMuay5RLGEse30sY3x8e30sYil9O1IucHJvdG90eXBlLmF1dGhXaXRoQ3VzdG9tVG9rZW49Ui5wcm90b3R5cGUuSGY7XG5SLnByb3RvdHlwZS5JZj1mdW5jdGlvbihhLGIsYyl7RihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTthYyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDEsYSk7SChcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDMsYywhMCk7UWYodGhpcy5rLlEsYSxjLGIpfTtSLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoUG9wdXA9Ui5wcm90b3R5cGUuSWY7XG5SLnByb3RvdHlwZS5KZj1mdW5jdGlvbihhLGIsYyl7RihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTthYyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDEsYSk7SChcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDMsYywhMCk7dmFyIGQ9dGhpcy5rLlE7T2YoZCk7dmFyIGU9W0VmXSxmPW1mKGMpO1wiYW5vbnltb3VzXCI9PT1hfHxcImZpcmViYXNlXCI9PT1hP0IoYixYKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKToodi5zZXQoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiLGYuY2QpLFBmKGQsZSxcIi9hdXRoL1wiK2EsZixiKSl9O1IucHJvdG90eXBlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdD1SLnByb3RvdHlwZS5KZjtcblIucHJvdG90eXBlLktmPWZ1bmN0aW9uKGEsYixjLGQpe0YoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwzLDQsYXJndW1lbnRzLmxlbmd0aCk7YWMoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwxLGEpO0goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwzLGMsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiw0LGQsITApO3AoYik/KGFjKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMixiKSxOZih0aGlzLmsuUSxhK1wiL3Rva2VuXCIse2FjY2Vzc190b2tlbjpifSxkLGMpKTooSihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDIsYiwhMSksTmYodGhpcy5rLlEsYStcIi90b2tlblwiLGIsZCxjKSl9O1IucHJvdG90eXBlLmF1dGhXaXRoT0F1dGhUb2tlbj1SLnByb3RvdHlwZS5LZjtcblIucHJvdG90eXBlLkdmPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2UuYXV0aEFub255bW91c2x5XCIsMSxhLCExKTtKKFwiRmlyZWJhc2UuYXV0aEFub255bW91c2x5XCIsMixiLCEwKTtOZih0aGlzLmsuUSxcImFub255bW91c1wiLHt9LGIsYSl9O1IucHJvdG90eXBlLmF1dGhBbm9ueW1vdXNseT1SLnByb3RvdHlwZS5HZjtcblIucHJvdG90eXBlLkxmPWZ1bmN0aW9uKGEsYixjKXtGKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtKKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIixhLFwiZW1haWxcIik7SyhcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIixhLFwicGFzc3dvcmRcIik7SChcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDMsYywhMCk7TmYodGhpcy5rLlEsXCJwYXNzd29yZFwiLGEsYyxiKX07Ui5wcm90b3R5cGUuYXV0aFdpdGhQYXNzd29yZD1SLnByb3RvdHlwZS5MZjtcblIucHJvdG90eXBlLmplPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0goXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMixiLCExKTt0aGlzLmsuUS5qZShhLGIpfTtSLnByb3RvdHlwZS5jcmVhdGVVc2VyPVIucHJvdG90eXBlLmplO1IucHJvdG90eXBlLkxlPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0goXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMixiLCExKTt0aGlzLmsuUS5MZShhLGIpfTtcblIucHJvdG90eXBlLnJlbW92ZVVzZXI9Ui5wcm90b3R5cGUuTGU7Ui5wcm90b3R5cGUuZWU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIixhLFwiZW1haWxcIik7SyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsYSxcIm9sZFBhc3N3b3JkXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLGEsXCJuZXdQYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIiwyLGIsITEpO3RoaXMuay5RLmVlKGEsYil9O1IucHJvdG90eXBlLmNoYW5nZVBhc3N3b3JkPVIucHJvdG90eXBlLmVlO1xuUi5wcm90b3R5cGUuZGU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIixhLFwib2xkRW1haWxcIik7SyhcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsYSxcIm5ld0VtYWlsXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLGEsXCJwYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIiwyLGIsITEpO3RoaXMuay5RLmRlKGEsYil9O1IucHJvdG90eXBlLmNoYW5nZUVtYWlsPVIucHJvdG90eXBlLmRlO1xuUi5wcm90b3R5cGUuTWU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UucmVzZXRQYXNzd29yZFwiLDIsMixhcmd1bWVudHMubGVuZ3RoKTtKKFwiRmlyZWJhc2UucmVzZXRQYXNzd29yZFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIixhLFwiZW1haWxcIik7SChcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwyLGIsITEpO3RoaXMuay5RLk1lKGEsYil9O1IucHJvdG90eXBlLnJlc2V0UGFzc3dvcmQ9Ui5wcm90b3R5cGUuTWU7Ui5nb09mZmxpbmU9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuZ29PZmZsaW5lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1RoLk5iKCkucGIoKX07Ui5nb09ubGluZT1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5nb09ubGluZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtUaC5OYigpLmhjKCl9O1xuZnVuY3Rpb24gbmIoYSxiKXt5KCFifHwhMD09PWF8fCExPT09YSxcIkNhbid0IHR1cm4gb24gY3VzdG9tIGxvZ2dlcnMgcGVyc2lzdGVudGx5LlwiKTshMD09PWE/KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBjb25zb2xlLmxvZz9sYj1xKGNvbnNvbGUubG9nLGNvbnNvbGUpOlwib2JqZWN0XCI9PT10eXBlb2YgY29uc29sZS5sb2cmJihsYj1mdW5jdGlvbihhKXtjb25zb2xlLmxvZyhhKX0pKSxiJiZ2LnNldChcImxvZ2dpbmdfZW5hYmxlZFwiLCEwKSk6YT9sYj1hOihsYj1udWxsLHYucmVtb3ZlKFwibG9nZ2luZ19lbmFibGVkXCIpKX1SLmVuYWJsZUxvZ2dpbmc9bmI7Ui5TZXJ2ZXJWYWx1ZT17VElNRVNUQU1QOntcIi5zdlwiOlwidGltZXN0YW1wXCJ9fTtSLlNES19WRVJTSU9OPVwiMi4xLjJcIjtSLklOVEVSTkFMPVk7Ui5Db250ZXh0PVRoO1IuVEVTVF9BQ0NFU1M9JDt9KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBGaXJlYmFzZTtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIl1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkXVxuICAnKFtcXFxcLy5dKT8oPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpKFsrKj9dKT8nLFxuICAvLyBNYXRjaCByZWdleHAgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIGFsd2F5cyBlc2NhcGVkLlxuICAnKFsuKyo/PV4hOiR7fSgpW1xcXFxdfFxcXFwvXSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBncm91cFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpO1xufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7UmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSc7XG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICAgICAgaSxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogIGZhbHNlLFxuICAgICAgICByZXBlYXQ6ICAgIGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cyk7XG59XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgc3BlY2lmaWMgdGFncyB3aXRoIHJlZ2V4cCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VQYXRoIChwYXRoLCBrZXlzKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSAoXywgZXNjYXBlZCwgcHJlZml4LCBrZXksIGNhcHR1cmUsIGdyb3VwLCBzdWZmaXgsIGVzY2FwZSkge1xuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG5cbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlO1xuICAgIH1cblxuICAgIHZhciByZXBlYXQgICA9IHN1ZmZpeCA9PT0gJysnIHx8IHN1ZmZpeCA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IHN1ZmZpeCA9PT0gJz8nIHx8IHN1ZmZpeCA9PT0gJyonO1xuXG4gICAga2V5cy5wdXNoKHtcbiAgICAgIG5hbWU6ICAgICAga2V5IHx8IGluZGV4KyssXG4gICAgICBkZWxpbWl0ZXI6IHByZWZpeCB8fCAnLycsXG4gICAgICBvcHRpb25hbDogIG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiAgICByZXBlYXRcbiAgICB9KTtcblxuICAgIHByZWZpeCA9IHByZWZpeCA/ICgnXFxcXCcgKyBwcmVmaXgpIDogJyc7XG4gICAgY2FwdHVyZSA9IGVzY2FwZUdyb3VwKGNhcHR1cmUgfHwgZ3JvdXAgfHwgJ1teJyArIChwcmVmaXggfHwgJ1xcXFwvJykgKyAnXSs/Jyk7XG5cbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICBjYXB0dXJlID0gY2FwdHVyZSArICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgcGFyYW1ldGVyIHN1cHBvcnQuXG4gICAgcmV0dXJuIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gIH1cblxuICByZXR1cm4gcGF0aC5yZXBsYWNlKFBBVEhfUkVHRVhQLCByZXBsYWNlKTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhTdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgICAgICAgICBba2V5c11cbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgICAgW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBrZXlzID0ga2V5cyB8fCBbXTtcblxuICBpZiAoIWlzQXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0ga2V5cztcbiAgICBrZXlzID0gW107XG4gIH0gZWxzZSBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9IHJlcGxhY2VQYXRoKHBhdGgsIGtleXMpO1xuICB2YXIgZW5kc1dpdGhTbGFzaCA9IHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJztcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhTbGFzaCA/IHJvdXRlLnNsaWNlKDAsIC0yKSA6IHJvdXRlKSArICcoPzpcXFxcLyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoU2xhc2ggPyAnJyA6ICcoPz1cXFxcL3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiZGF0ID0gcmVxdWlyZSBcImRhdC1ndWlcIlxucGFnZSA9IHJlcXVpcmUgXCJwYWdlXCJcblxuXG5ndWkgPSB3aW5kb3cuX2d1aSA9IG5ldyBkYXQuR1VJKClcblxub3B0aW9ucyA9XG5cdFwiZGVidWdcIjogZmFsc2Vcblx0XCJpbmRleFwiOiAtPiBwYWdlIFwiL1wiXG5cdFwidGVzdFwiOiAtPiBwYWdlIFwiL3Rlc3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IC0+XG5cdCMgZGVidWdcblx0ZGVidWcgPSBndWkuYWRkKG9wdGlvbnMsIFwiZGVidWdcIilcblxuXHQjIG5hdmlnYXRpb25cblx0Zm9sZGVyID0gZ3VpLmFkZEZvbGRlcihcIm5hdmlnYXRpb25cIilcblx0Zm9sZGVyLmFkZChvcHRpb25zLCBcImluZGV4XCIpLm5hbWUoXCIvaW5kZXhcIilcblx0Zm9sZGVyLmFkZChvcHRpb25zLCBcInRlc3RcIikubmFtZShcIi90ZXN0XCIpXG5cdGZvbGRlci5vcGVuKClcbiIsIm1vZHVsZS5leHBvcnRzID1cblxuICAgIGZpcmViYXNlOiBcImFsaWNlbHVrZVwiXG4iLCJSYWN0aXZlID0gcmVxdWlyZSBcInJhY3RpdmVcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gUmFjdGl2ZS5leHRlbmRcblxuXHRpc29sYXRlZDogdHJ1ZVxuIiwiIyMjXG5cdFRISVMgRklMRSBJUyBHRU5FUkFURUQgQVVUT01BVElDQUxMWSBBTkQgSVQgV0lMTFxuXHRCRSBSRVBMQUNFRCBJRiBBIE5FVyBNT0RVTEUgSVMgQURERUQgT1IgREVMRVRFRC5cbiMjI1xuUmFjdGl2ZSA9IHJlcXVpcmUgXCJyYWN0aXZlXCJcblxucmVnaXN0ZXIgPSAtPlxuXHRSYWN0aXZlLmNvbXBvbmVudHNbXCJ1aS1uYXZcIl0gPSByZXF1aXJlIFwiLi9uYXZcIlxuXHRSYWN0aXZlLmNvbXBvbmVudHNbXCJ1aS10ZXN0XCJdID0gcmVxdWlyZSBcIi4vdGVzdFwiXG5cdFxuXHR0cnVlXG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXIoKSIsIiMjI1xuXHRAbW9kdWxlOiAgIG5hdlxuXHRAYXV0aG9yOiAgIEx1a2UgSGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9uYXYuc3R5bFxuXHRAaHRtbDogICAgIC4vc291cmNlL3RlbXBsYXRlL21vZHVsZS9uYXYuaHRtbFxuIyMjXG5cblxuTW9kdWxlID0gcmVxdWlyZSBcIi4vYWJzdHJhY3QtbW9kdWxlXCJcblxucGFnZSA9IHJlcXVpcmUgXCJwYWdlXCJcblxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGUuZXh0ZW5kXG5cblx0dGVtcGxhdGU6IHJlcXVpcmUgXCJtb2R1bGUvbmF2Lmh0bWxcIlxuXG5cdG9uaW5pdDogLT5cblxuXHRcdEBvbiBcInRvSW5kZXhcIiwgLT4gcGFnZSBcIi9cIlxuXHRcdEBvbiBcInRvVGVzdFwiLCAtPiBwYWdlIFwiL3Rlc3RcIlxuIiwiIyMjXG5cdEBtb2R1bGU6ICAgdGVzdFxuXHRAYXV0aG9yOiAgIEx1a2UgSGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS90ZXN0LnN0eWxcblx0QGh0bWw6ICAgICAuL3NvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvdGVzdC5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1tb2R1bGVcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlLmV4dGVuZFxuXG5cdHRlbXBsYXRlOiByZXF1aXJlIFwibW9kdWxlL3Rlc3QuaHRtbFwiXG5cblx0ZGF0YTpcblx0XHRjbGlja2VkOiBmYWxzZVxuXG5cdG9uaW5pdDogLT5cblx0XHRjb25zb2xlLmxvZyBcInRlc3QgOilcIlxuXG5cdFx0QG9uIFwiaXRlbVRhcFwiLCAoZSkgPT4gQHRvZ2dsZSBcImNsaWNrZWRcIlxuIiwiUmFjdGl2ZSA9IHJlcXVpcmUgXCJyYWN0aXZlXCJcbkZpcmViYXNlID0gcmVxdWlyZSBcImZpcmViYXNlXCJcbnBhZ2UgPSByZXF1aXJlIFwicGFnZVwiXG5cbmNvbmZpZyA9IHJlcXVpcmUgXCIuLi9jb25maWdcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmUuZXh0ZW5kXG5cblx0ZWw6IGRvY3VtZW50LmJvZHlcblxuXHRhcHBlbmQ6IHRydWVcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1haW4tdmlldy5odG1sXCJcblxuXHRkYXRhOlxuXHRcdHZpZXc6IFwibWFwXCJcblx0XHRsb2dnZWRpbjogZmFsc2Vcblx0XHRndWVzdHM6IG51bGxcblxuXHRvbmluaXQ6ICgpIC0+XG5cdFx0Y29uc29sZS5sb2cgXCJbbWFpbi12aWV3XSBpbml0XCJcblxuXHRcdEBnZXREYXRhKClcblxuXHRcdEBzZXRfcm91dGVyKClcblxuXHRnZXREYXRhOiAtPlxuXHRcdCMgVE9ETyAtIGxvYWQgZGF0YS9ndWVzdHMgdG8gZmlyZWJhc2UgdGhlbiBnZXQgZGIuY2hpbGQoXCJndWVzdHNcIikub24oXCJ2YWx1ZVwiLCAuLi4pXG5cdFx0ZGIgPSBuZXcgRmlyZWJhc2UgXCJodHRwczovLyN7Y29uZmlnLmZpcmViYXNlfS5maXJlYmFzZWlvLmNvbS9cIlxuXHRcdGRiLm9uIFwidmFsdWVcIiwgKHNuYXBzaG90KSA9PlxuXHRcdFx0QHNldCBcImd1ZXN0c1wiLCBzbmFwc2hvdC52YWwoKVxuXHRcdFx0Y29uc29sZS5sb2cgXCJvazpcIiwgQGdldChcImd1ZXN0c1wiKVxuXHRcdCwgKGVycikgLT5cblx0XHQgICAgY29uc29sZS5sb2cgXCJlcnI6XCIsIGVyci5jb2RlXG5cblx0c2V0X3JvdXRlcjogLT5cblx0XHRzZWxmID0gQFxuXG5cdFx0cGFnZSBcIi9cIiwgLT5cblx0XHRcdGNvbnNvbGUubG9nIFwiW21haW4tdmlld10gaW5kZXhcIlxuXHRcdFx0c2VsZi5zZXQgXCJ2aWV3XCI6IFwiaW5kZXhcIlxuXG5cdFx0cGFnZSBcIi90ZXN0XCIsIChjdHgpIC0+XG5cdFx0XHRjb25zb2xlLmxvZyBcIlttYWluLXZpZXddIHRlc3RcIlxuXHRcdFx0c2VsZi5zZXQgXCJ2aWV3XCI6IFwidGVzdFwiXG5cblx0XHRwYWdlIGNsaWNrOiBmYWxzZSwgZGlzcGF0Y2g6IHRydWUsIGhhc2hiYW5nOiBmYWxzZVxuIiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIndyYXBwZXJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaGVhZGVyXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIndyYXBwZXJfX3Jvd1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiaXRlbS0tc3F1YXJlXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJpdGVtLS1jaXJjbGVcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIml0ZW0tLXJlY3RcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIml0ZW0tLXRyaWFuZ2xlXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIndyYXBwZXJfX3Jvd1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiaXRlbS0tcmVjdFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiaXRlbS0tY2lyY2xlXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJpdGVtLS1yZWN0XCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIndyYXBwZXJfX3Jvd1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiaXRlbS0tc3F1YXJlXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJpdGVtLS1jaXJjbGVcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIml0ZW0tLXNxdWFyZVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiaXRlbS0tc3F1YXJlXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJpdGVtLS1jaXJjbGVcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJmb290ZXJcIn0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJ1aS1uYXZcIn0sXCIgXCIse1widFwiOjQsXCJ4XCI6e1wiclwiOltcInZpZXdcIl0sXCJzXCI6XCJfMD09XFxcImluZGV4XFxcIlwifSxcImZcIjpbXCJIb21lXCJdfSxcIiBcIix7XCJ0XCI6NCxcInhcIjp7XCJyXCI6W1widmlld1wiXSxcInNcIjpcIl8wPT1cXFwidGVzdFxcXCJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwidWktdGVzdFwifV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJuYXZcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwidlwiOntcInRhcFwiOlwidG9JbmRleFwifSxcImZcIjpbXCJIb21lXCJdfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImFcIixcInZcIjp7XCJ0YXBcIjpcInRvVGVzdFwifSxcImZcIjpbXCJUZXN0XCJdfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVzdFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOltcImNpcmNsZSBcIix7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wiY2xpY2tlZFwiXSxcInNcIjpcIl8wP1xcXCJjbGlja2VkXFxcIjpcXFwiXFxcIlwifX1dfSxcInZcIjp7XCJ0YXBcIjpcIml0ZW1UYXBcIn19XX1dfSIsIi8qIVxuICAqIGRvbXJlYWR5IChjKSBEdXN0aW4gRGlheiAyMDE0IC0gTGljZW5zZSBNSVRcbiAgKi9cbiFmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIHRoaXNbbmFtZV0gPSBkZWZpbml0aW9uKClcblxufSgnZG9tcmVhZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZucyA9IFtdLCBsaXN0ZW5lclxuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIGhhY2sgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsXG4gICAgLCBkb21Db250ZW50TG9hZGVkID0gJ0RPTUNvbnRlbnRMb2FkZWQnXG4gICAgLCBsb2FkZWQgPSAoaGFjayA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChkb2MucmVhZHlTdGF0ZSlcblxuXG4gIGlmICghbG9hZGVkKVxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lcilcbiAgICBsb2FkZWQgPSAxXG4gICAgd2hpbGUgKGxpc3RlbmVyID0gZm5zLnNoaWZ0KCkpIGxpc3RlbmVyKClcbiAgfSlcblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgbG9hZGVkID8gZm4oKSA6IGZucy5wdXNoKGZuKVxuICB9XG5cbn0pO1xuIiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucGFnZT1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgLyogZ2xvYmFscyByZXF1aXJlLCBtb2R1bGUgKi9cblxuLyoqXG4gICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBwYXRodG9SZWdleHAgPSByZXF1aXJlKCdwYXRoLXRvLXJlZ2V4cCcpO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgZXhwb3J0cy5cbiAgICovXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBwYWdlO1xuXG4gIC8qKlxuICAgKiBUbyB3b3JrIHByb3Blcmx5IHdpdGggdGhlIFVSTFxuICAgKiBoaXN0b3J5LmxvY2F0aW9uIGdlbmVyYXRlZCBwb2x5ZmlsbCBpbiBodHRwczovL2dpdGh1Yi5jb20vZGV2b3RlL0hUTUw1LUhpc3RvcnktQVBJXG4gICAqL1xuXG4gIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5oaXN0b3J5LmxvY2F0aW9uIHx8IHdpbmRvdy5sb2NhdGlvbjtcblxuICAvKipcbiAgICogUGVyZm9ybSBpbml0aWFsIGRpc3BhdGNoLlxuICAgKi9cblxuICB2YXIgZGlzcGF0Y2ggPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBCYXNlIHBhdGguXG4gICAqL1xuXG4gIHZhciBiYXNlID0gJyc7XG5cbiAgLyoqXG4gICAqIFJ1bm5pbmcgZmxhZy5cbiAgICovXG5cbiAgdmFyIHJ1bm5pbmc7XG5cbiAgLyoqXG4gICogSGFzaEJhbmcgb3B0aW9uXG4gICovXG5cbiAgdmFyIGhhc2hiYW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIGNvbnRleHQsIGZvciBjYXB0dXJpbmdcbiAgICogcGFnZSBleGl0IGV2ZW50cy5cbiAgICovXG5cbiAgdmFyIHByZXZDb250ZXh0O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBgcGF0aGAgd2l0aCBjYWxsYmFjayBgZm4oKWAsXG4gICAqIG9yIHJvdXRlIGBwYXRoYCwgb3IgcmVkaXJlY3Rpb24sXG4gICAqIG9yIGBwYWdlLnN0YXJ0KClgLlxuICAgKlxuICAgKiAgIHBhZ2UoZm4pO1xuICAgKiAgIHBhZ2UoJyonLCBmbik7XG4gICAqICAgcGFnZSgnL3VzZXIvOmlkJywgbG9hZCwgdXNlcik7XG4gICAqICAgcGFnZSgnL3VzZXIvJyArIHVzZXIuaWQsIHsgc29tZTogJ3RoaW5nJyB9KTtcbiAgICogICBwYWdlKCcvdXNlci8nICsgdXNlci5pZCk7XG4gICAqICAgcGFnZSgnL2Zyb20nLCAnL3RvJylcbiAgICogICBwYWdlKCk7XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBwYXRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuLi4uXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhZ2UocGF0aCwgZm4pIHtcbiAgICAvLyA8Y2FsbGJhY2s+XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBwYXRoKSB7XG4gICAgICByZXR1cm4gcGFnZSgnKicsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIHJvdXRlIDxwYXRoPiB0byA8Y2FsbGJhY2sgLi4uPlxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm4pIHtcbiAgICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZShwYXRoKTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHBhZ2UuY2FsbGJhY2tzLnB1c2gocm91dGUubWlkZGxld2FyZShhcmd1bWVudHNbaV0pKTtcbiAgICAgIH1cbiAgICAvLyBzaG93IDxwYXRoPiB3aXRoIFtzdGF0ZV1cbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBwYXRoKSB7XG4gICAgICAnc3RyaW5nJyA9PT0gdHlwZW9mIGZuXG4gICAgICAgID8gcGFnZS5yZWRpcmVjdChwYXRoLCBmbilcbiAgICAgICAgOiBwYWdlLnNob3cocGF0aCwgZm4pO1xuICAgIC8vIHN0YXJ0IFtvcHRpb25zXVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWdlLnN0YXJ0KHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbnMuXG4gICAqL1xuXG4gIHBhZ2UuY2FsbGJhY2tzID0gW107XG4gIHBhZ2UuZXhpdHMgPSBbXTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCBiYXNlcGF0aCB0byBgcGF0aGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2UuYmFzZSA9IGZ1bmN0aW9uKHBhdGgpe1xuICAgIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmFzZTtcbiAgICBiYXNlID0gcGF0aDtcbiAgfTtcblxuICAvKipcbiAgICogQmluZCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqXG4gICAqICAgIC0gYGNsaWNrYCBiaW5kIHRvIGNsaWNrIGV2ZW50cyBbdHJ1ZV1cbiAgICogICAgLSBgcG9wc3RhdGVgIGJpbmQgdG8gcG9wc3RhdGUgW3RydWVdXG4gICAqICAgIC0gYGRpc3BhdGNoYCBwZXJmb3JtIGluaXRpYWwgZGlzcGF0Y2ggW3RydWVdXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2Uuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAocnVubmluZykgcmV0dXJuO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIGlmIChmYWxzZSA9PT0gb3B0aW9ucy5kaXNwYXRjaCkgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICBpZiAoZmFsc2UgIT09IG9wdGlvbnMucG9wc3RhdGUpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9ucG9wc3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoZmFsc2UgIT09IG9wdGlvbnMuY2xpY2spIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uY2xpY2ssIGZhbHNlKTtcbiAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5oYXNoYmFuZykgaGFzaGJhbmcgPSB0cnVlO1xuICAgIGlmICghZGlzcGF0Y2gpIHJldHVybjtcbiAgICB2YXIgdXJsID0gKGhhc2hiYW5nICYmIH5sb2NhdGlvbi5oYXNoLmluZGV4T2YoJyMhJykpXG4gICAgICA/IGxvY2F0aW9uLmhhc2guc3Vic3RyKDIpICsgbG9jYXRpb24uc2VhcmNoXG4gICAgICA6IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaDtcbiAgICBwYWdlLnJlcGxhY2UodXJsLCBudWxsLCB0cnVlLCBkaXNwYXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuYmluZCBjbGljayBhbmQgcG9wc3RhdGUgZXZlbnQgaGFuZGxlcnMuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2Uuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKCFydW5uaW5nKSByZXR1cm47XG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uY2xpY2ssIGZhbHNlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvbnBvcHN0YXRlLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgYHBhdGhgIHdpdGggb3B0aW9uYWwgYHN0YXRlYCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3BhdGNoXG4gICAqIEByZXR1cm4ge0NvbnRleHR9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2Uuc2hvdyA9IGZ1bmN0aW9uKHBhdGgsIHN0YXRlLCBkaXNwYXRjaCl7XG4gICAgdmFyIGN0eCA9IG5ldyBDb250ZXh0KHBhdGgsIHN0YXRlKTtcbiAgICBpZiAoZmFsc2UgIT09IGRpc3BhdGNoKSBwYWdlLmRpc3BhdGNoKGN0eCk7XG4gICAgaWYgKGZhbHNlICE9PSBjdHguaGFuZGxlZCkgY3R4LnB1c2hTdGF0ZSgpO1xuICAgIHJldHVybiBjdHg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHJvdXRlIHRvIHJlZGlyZWN0IGZyb20gb25lIHBhdGggdG8gb3RoZXJcbiAgICogb3IganVzdCByZWRpcmVjdCB0byBhbm90aGVyIHJvdXRlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tIC0gaWYgcGFyYW0gJ3RvJyBpcyB1bmRlZmluZWQgcmVkaXJlY3RzIHRvICdmcm9tJ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RvXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgcGFnZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgLy8gRGVmaW5lIHJvdXRlIGZyb20gYSBwYXRoIHRvIGFub3RoZXJcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmcm9tICYmICdzdHJpbmcnID09PSB0eXBlb2YgdG8pIHtcbiAgICAgIHBhZ2UoZnJvbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBwYWdlLnJlcGxhY2UodG8pO1xuICAgICAgICB9LDApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2FpdCBmb3IgdGhlIHB1c2ggc3RhdGUgYW5kIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyXG4gICAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBmcm9tICYmICd1bmRlZmluZWQnID09PSB0eXBlb2YgdG8pIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcGFnZS5yZXBsYWNlKGZyb20pO1xuICAgICAgfSwwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYHBhdGhgIHdpdGggb3B0aW9uYWwgYHN0YXRlYCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAcmV0dXJuIHtDb250ZXh0fVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwYWdlLnJlcGxhY2UgPSBmdW5jdGlvbihwYXRoLCBzdGF0ZSwgaW5pdCwgZGlzcGF0Y2gpe1xuICAgIHZhciBjdHggPSBuZXcgQ29udGV4dChwYXRoLCBzdGF0ZSk7XG4gICAgY3R4LmluaXQgPSBpbml0O1xuICAgIGN0eC5zYXZlKCk7IC8vIHNhdmUgYmVmb3JlIGRpc3BhdGNoaW5nLCB3aGljaCBtYXkgcmVkaXJlY3RcbiAgICBpZiAoZmFsc2UgIT09IGRpc3BhdGNoKSBwYWdlLmRpc3BhdGNoKGN0eCk7XG4gICAgcmV0dXJuIGN0eDtcbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2ggdGhlIGdpdmVuIGBjdHhgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBwYWdlLmRpc3BhdGNoID0gZnVuY3Rpb24oY3R4KXtcbiAgICB2YXIgcHJldiA9IHByZXZDb250ZXh0O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICBwcmV2Q29udGV4dCA9IGN0eDtcblxuICAgIGZ1bmN0aW9uIG5leHRFeGl0KCkge1xuICAgICAgdmFyIGZuID0gcGFnZS5leGl0c1tqKytdO1xuICAgICAgaWYgKCFmbikgcmV0dXJuIG5leHRFbnRlcigpO1xuICAgICAgZm4ocHJldiwgbmV4dEV4aXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHRFbnRlcigpIHtcbiAgICAgIHZhciBmbiA9IHBhZ2UuY2FsbGJhY2tzW2krK107XG4gICAgICBpZiAoIWZuKSByZXR1cm4gdW5oYW5kbGVkKGN0eCk7XG4gICAgICBmbihjdHgsIG5leHRFbnRlcik7XG4gICAgfVxuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIG5leHRFeGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRFbnRlcigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5oYW5kbGVkIGBjdHhgLiBXaGVuIGl0J3Mgbm90IHRoZSBpbml0aWFsXG4gICAqIHBvcHN0YXRlIHRoZW4gcmVkaXJlY3QuIElmIHlvdSB3aXNoIHRvIGhhbmRsZVxuICAgKiA0MDRzIG9uIHlvdXIgb3duIHVzZSBgcGFnZSgnKicsIGNhbGxiYWNrKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29udGV4dH0gY3R4XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiB1bmhhbmRsZWQoY3R4KSB7XG4gICAgaWYgKGN0eC5oYW5kbGVkKSByZXR1cm47XG4gICAgdmFyIGN1cnJlbnQ7XG5cbiAgICBpZiAoaGFzaGJhbmcpIHtcbiAgICAgIGN1cnJlbnQgPSBiYXNlICsgbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjIScsJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50ID0gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IGN0eC5jYW5vbmljYWxQYXRoKSByZXR1cm47XG4gICAgcGFnZS5zdG9wKCk7XG4gICAgY3R4LmhhbmRsZWQgPSBmYWxzZTtcbiAgICBsb2NhdGlvbi5ocmVmID0gY3R4LmNhbm9uaWNhbFBhdGg7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXhpdCByb3V0ZSBvbiBgcGF0aGAgd2l0aFxuICAgKiBjYWxsYmFjayBgZm4oKWAsIHdoaWNoIHdpbGwgYmUgY2FsbGVkXG4gICAqIG9uIHRoZSBwcmV2aW91cyBjb250ZXh0IHdoZW4gYSBuZXdcbiAgICogcGFnZSBpcyB2aXNpdGVkLlxuICAgKi9cbiAgcGFnZS5leGl0ID0gZnVuY3Rpb24ocGF0aCwgZm4pIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHBhZ2UuZXhpdCgnKicsIHBhdGgpO1xuICAgIH07XG5cbiAgICB2YXIgcm91dGUgPSBuZXcgUm91dGUocGF0aCk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBhZ2UuZXhpdHMucHVzaChyb3V0ZS5taWRkbGV3YXJlKGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgKiBSZW1vdmUgVVJMIGVuY29kaW5nIGZyb20gdGhlIGdpdmVuIGBzdHJgLlxuICAqIEFjY29tbW9kYXRlcyB3aGl0ZXNwYWNlIGluIGJvdGggeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICogYW5kIHJlZ3VsYXIgcGVyY2VudC1lbmNvZGVkIGZvcm0uXG4gICpcbiAgKiBAcGFyYW0ge3N0cn0gVVJMIGNvbXBvbmVudCB0byBkZWNvZGVcbiAgKi9cbiAgZnVuY3Rpb24gZGVjb2RlVVJMRW5jb2RlZFVSSUNvbXBvbmVudChzdHIpIHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBcInJlcXVlc3RcIiBgQ29udGV4dGBcbiAgICogd2l0aCB0aGUgZ2l2ZW4gYHBhdGhgIGFuZCBvcHRpb25hbCBpbml0aWFsIGBzdGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBDb250ZXh0KHBhdGgsIHN0YXRlKSB7XG4gICAgcGF0aCA9IGRlY29kZVVSTEVuY29kZWRVUklDb21wb25lbnQocGF0aCk7XG4gICAgaWYgKCcvJyA9PT0gcGF0aFswXSAmJiAwICE9PSBwYXRoLmluZGV4T2YoYmFzZSkpIHBhdGggPSBiYXNlICsgcGF0aDtcbiAgICB2YXIgaSA9IHBhdGguaW5kZXhPZignPycpO1xuXG4gICAgdGhpcy5jYW5vbmljYWxQYXRoID0gcGF0aDtcbiAgICB0aGlzLnBhdGggPSBwYXRoLnJlcGxhY2UoYmFzZSwgJycpIHx8ICcvJztcblxuICAgIHRoaXMudGl0bGUgPSBkb2N1bWVudC50aXRsZTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwge307XG4gICAgdGhpcy5zdGF0ZS5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnF1ZXJ5c3RyaW5nID0gfmlcbiAgICAgID8gcGF0aC5zbGljZShpICsgMSlcbiAgICAgIDogJyc7XG4gICAgdGhpcy5wYXRobmFtZSA9IH5pXG4gICAgICA/IHBhdGguc2xpY2UoMCwgaSlcbiAgICAgIDogcGF0aDtcbiAgICB0aGlzLnBhcmFtcyA9IFtdO1xuXG4gICAgLy8gZnJhZ21lbnRcbiAgICB0aGlzLmhhc2ggPSAnJztcbiAgICBpZiAoIX50aGlzLnBhdGguaW5kZXhPZignIycpKSByZXR1cm47XG4gICAgdmFyIHBhcnRzID0gdGhpcy5wYXRoLnNwbGl0KCcjJyk7XG4gICAgdGhpcy5wYXRoID0gcGFydHNbMF07XG4gICAgdGhpcy5oYXNoID0gcGFydHNbMV0gfHwgJyc7XG4gICAgdGhpcy5xdWVyeXN0cmluZyA9IHRoaXMucXVlcnlzdHJpbmcuc3BsaXQoJyMnKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgYENvbnRleHRgLlxuICAgKi9cblxuICBwYWdlLkNvbnRleHQgPSBDb250ZXh0O1xuXG4gIC8qKlxuICAgKiBQdXNoIHN0YXRlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24oKXtcbiAgICBoaXN0b3J5LnB1c2hTdGF0ZSh0aGlzLnN0YXRlXG4gICAgICAsIHRoaXMudGl0bGVcbiAgICAgICwgaGFzaGJhbmcgJiYgdGhpcy5wYXRoICE9PSAnLydcbiAgICAgICAgPyAnIyEnICsgdGhpcy5wYXRoXG4gICAgICAgIDogdGhpcy5jYW5vbmljYWxQYXRoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2F2ZSB0aGUgY29udGV4dCBzdGF0ZS5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ29udGV4dC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUodGhpcy5zdGF0ZVxuICAgICAgLCB0aGlzLnRpdGxlXG4gICAgICAsIGhhc2hiYW5nICYmIHRoaXMucGF0aCAhPT0gJy8nXG4gICAgICAgID8gJyMhJyArIHRoaXMucGF0aFxuICAgICAgICA6IHRoaXMuY2Fub25pY2FsUGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYFJvdXRlYCB3aXRoIHRoZSBnaXZlbiBIVFRQIGBwYXRoYCxcbiAgICogYW5kIGFuIGFycmF5IG9mIGBjYWxsYmFja3NgIGFuZCBgb3B0aW9uc2AuXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqXG4gICAqICAgLSBgc2Vuc2l0aXZlYCAgICBlbmFibGUgY2FzZS1zZW5zaXRpdmUgcm91dGVzXG4gICAqICAgLSBgc3RyaWN0YCAgICAgICBlbmFibGUgc3RyaWN0IG1hdGNoaW5nIGZvciB0cmFpbGluZyBzbGFzaGVzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gUm91dGUocGF0aCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMucGF0aCA9IChwYXRoID09PSAnKicpID8gJyguKiknIDogcGF0aDtcbiAgICB0aGlzLm1ldGhvZCA9ICdHRVQnO1xuICAgIHRoaXMucmVnZXhwID0gcGF0aHRvUmVnZXhwKHRoaXMucGF0aCxcbiAgICAgIHRoaXMua2V5cyA9IFtdLFxuICAgICAgb3B0aW9ucy5zZW5zaXRpdmUsXG4gICAgICBvcHRpb25zLnN0cmljdCk7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlIGBSb3V0ZWAuXG4gICAqL1xuXG4gIHBhZ2UuUm91dGUgPSBSb3V0ZTtcblxuICAvKipcbiAgICogUmV0dXJuIHJvdXRlIG1pZGRsZXdhcmUgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gY2FsbGJhY2sgYGZuKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgUm91dGUucHJvdG90eXBlLm1pZGRsZXdhcmUgPSBmdW5jdGlvbihmbil7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbihjdHgsIG5leHQpe1xuICAgICAgaWYgKHNlbGYubWF0Y2goY3R4LnBhdGgsIGN0eC5wYXJhbXMpKSByZXR1cm4gZm4oY3R4LCBuZXh0KTtcbiAgICAgIG5leHQoKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIHJvdXRlIG1hdGNoZXMgYHBhdGhgLCBpZiBzb1xuICAgKiBwb3B1bGF0ZSBgcGFyYW1zYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBSb3V0ZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXRoLCBwYXJhbXMpe1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICBxc0luZGV4ID0gcGF0aC5pbmRleE9mKCc/JyksXG4gICAgICAgIHBhdGhuYW1lID0gfnFzSW5kZXhcbiAgICAgICAgICA/IHBhdGguc2xpY2UoMCwgcXNJbmRleClcbiAgICAgICAgICA6IHBhdGgsXG4gICAgICAgIG0gPSB0aGlzLnJlZ2V4cC5leGVjKGRlY29kZVVSSUNvbXBvbmVudChwYXRobmFtZSkpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuXG4gICAgICB2YXIgdmFsID0gJ3N0cmluZycgPT09IHR5cGVvZiBtW2ldXG4gICAgICAgID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pXG4gICAgICAgIDogbVtpXTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdW5kZWZpbmVkICE9PSBwYXJhbXNba2V5Lm5hbWVdXG4gICAgICAgICAgPyBwYXJhbXNba2V5Lm5hbWVdXG4gICAgICAgICAgOiB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgXCJwb3B1bGF0ZVwiIGV2ZW50cy5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25wb3BzdGF0ZShlKSB7XG4gICAgaWYgKGUuc3RhdGUpIHtcbiAgICAgIHZhciBwYXRoID0gZS5zdGF0ZS5wYXRoO1xuICAgICAgcGFnZS5yZXBsYWNlKHBhdGgsIGUuc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgXCJjbGlja1wiIGV2ZW50cy5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25jbGljayhlKSB7XG4gICAgaWYgKDEgIT0gd2hpY2goZSkpIHJldHVybjtcbiAgICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSByZXR1cm47XG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgLy8gZW5zdXJlIGxpbmtcbiAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICB3aGlsZSAoZWwgJiYgJ0EnICE9IGVsLm5vZGVOYW1lKSBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgaWYgKCFlbCB8fCAnQScgIT0gZWwubm9kZU5hbWUpIHJldHVybjtcblxuICAgIC8vIElnbm9yZSBpZiB0YWcgaGFzIGEgXCJkb3dubG9hZFwiIGF0dHJpYnV0ZVxuICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiKSkgcmV0dXJuO1xuXG4gICAgLy8gZW5zdXJlIG5vbi1oYXNoIGZvciB0aGUgc2FtZSBwYXRoXG4gICAgdmFyIGxpbmsgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICBpZiAoZWwucGF0aG5hbWUgPT09IGxvY2F0aW9uLnBhdGhuYW1lICYmIChlbC5oYXNoIHx8ICcjJyA9PT0gbGluaykpIHJldHVybjtcblxuICAgIC8vIENoZWNrIGZvciBtYWlsdG86IGluIHRoZSBocmVmXG4gICAgaWYgKGxpbmsgJiYgbGluay5pbmRleE9mKFwibWFpbHRvOlwiKSA+IC0xKSByZXR1cm47XG5cbiAgICAvLyBjaGVjayB0YXJnZXRcbiAgICBpZiAoZWwudGFyZ2V0KSByZXR1cm47XG5cbiAgICAvLyB4LW9yaWdpblxuICAgIGlmICghc2FtZU9yaWdpbihlbC5ocmVmKSkgcmV0dXJuO1xuXG4gICAgLy8gcmVidWlsZCBwYXRoXG4gICAgdmFyIHBhdGggPSBlbC5wYXRobmFtZSArIGVsLnNlYXJjaCArIChlbC5oYXNoIHx8ICcnKTtcblxuICAgIC8vIHNhbWUgcGFnZVxuICAgIHZhciBvcmlnID0gcGF0aDtcblxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoYmFzZSwgJycpO1xuXG4gICAgaWYgKGJhc2UgJiYgb3JpZyA9PT0gcGF0aCkgcmV0dXJuO1xuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHBhZ2Uuc2hvdyhvcmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBidXR0b24uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHdoaWNoKGUpIHtcbiAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgcmV0dXJuIG51bGwgPT09IGUud2hpY2hcbiAgICAgID8gZS5idXR0b25cbiAgICAgIDogZS53aGljaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBgaHJlZmAgaXMgdGhlIHNhbWUgb3JpZ2luLlxuICAgKi9cblxuICBmdW5jdGlvbiBzYW1lT3JpZ2luKGhyZWYpIHtcbiAgICB2YXIgb3JpZ2luID0gbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdG5hbWU7XG4gICAgaWYgKGxvY2F0aW9uLnBvcnQpIG9yaWdpbiArPSAnOicgKyBsb2NhdGlvbi5wb3J0O1xuICAgIHJldHVybiAoaHJlZiAmJiAoMCA9PT0gaHJlZi5pbmRleE9mKG9yaWdpbikpKTtcbiAgfVxuXG4gIHBhZ2Uuc2FtZU9yaWdpbiA9IHNhbWVPcmlnaW47XG5cbn0se1wicGF0aC10by1yZWdleHBcIjoyfV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEV4cG9zZSBgcGF0aHRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRodG9SZWdleHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggYWxyZWFkeSBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgaW5jb3JyZWN0bHkgYXBwZWFyXG4gIC8vIGluIGZ1dHVyZSBtYXRjaGVzLiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXRcbiAgLy8gc2hvdWxkbid0IGJlIHRyYW5zZm9ybWVkLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWRdXG4gICcoW1xcXFwvLl0pPyg/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSkoWysqP10pPycsXG4gIC8vIE1hdGNoIHJlZ2V4cCBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYWx3YXlzIGJlIGVzY2FwZWQuXG4gICcoWy4rKj89XiE6JHt9KClbXFxcXF18XFxcXC9dKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJyk7XG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGtleXNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xudmFyIGF0dGFjaEtleXMgPSBmdW5jdGlvbiAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG5cbiAgcmV0dXJuIHJlO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgc2hvdWxkIGJlIHBhc3NlZCBpbiwgd2hpY2ggd2lsbCBjb250YWluIHRoZSBwbGFjZWhvbGRlciBrZXlcbiAqIG5hbWVzLiBGb3IgZXhhbXBsZSBgL3VzZXIvOmlkYCB3aWxsIHRoZW4gY29udGFpbiBgW1wiaWRcIl1gLlxuICpcbiAqIEBwYXJhbSAgeyhTdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgICAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aHRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmIChrZXlzICYmICFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IGtleXM7XG4gICAga2V5cyA9IG51bGw7XG4gIH1cblxuICBrZXlzID0ga2V5cyB8fCBbXTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgZmxhZ3MgPSBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gTWF0Y2ggYWxsIGNhcHR1cmluZyBncm91cHMgb2YgYSByZWdleHAuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpIHx8IFtdO1xuXG4gICAgLy8gTWFwIGFsbCB0aGUgbWF0Y2hlcyB0byB0aGVpciBudW1lcmljIGtleXMgYW5kIHB1c2ggaW50byB0aGUga2V5cy5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgZ3JvdXBzLm1hcChmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAgICAgIGluZGV4LFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiAgZmFsc2UsXG4gICAgICAgIHJlcGVhdDogICAgZmFsc2VcbiAgICAgIH07XG4gICAgfSkpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBzb3VyY2UgYmFjayB0byB0aGUgdXNlci5cbiAgICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgLy8gTWFwIGFycmF5IHBhcnRzIGludG8gcmVnZXhwcyBhbmQgcmV0dXJuIHRoZWlyIHNvdXJjZS4gV2UgYWxzbyBwYXNzXG4gICAgLy8gdGhlIHNhbWUga2V5cyBhbmQgb3B0aW9ucyBpbnN0YW5jZSBpbnRvIGV2ZXJ5IGdlbmVyYXRpb24gdG8gZ2V0XG4gICAgLy8gY29uc2lzdGVudCBtYXRjaGluZyBncm91cHMgYmVmb3JlIHdlIGpvaW4gdGhlIHNvdXJjZXMgdG9nZXRoZXIuXG4gICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhdGh0b1JlZ2V4cCh2YWx1ZSwga2V5cywgb3B0aW9ucykuc291cmNlO1xuICAgIH0pO1xuXG4gICAgLy8gR2VuZXJhdGUgYSBuZXcgcmVnZXhwIGluc3RhbmNlIGJ5IGpvaW5pbmcgYWxsIHRoZSBwYXJ0cyB0b2dldGhlci5cbiAgICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCcoPzonICsgcGF0aC5qb2luKCd8JykgKyAnKScsIGZsYWdzKSwga2V5cyk7XG4gIH1cblxuICAvLyBBbHRlciB0aGUgcGF0aCBzdHJpbmcgaW50byBhIHVzYWJsZSByZWdleHAuXG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoUEFUSF9SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgcHJlZml4LCBrZXksIGNhcHR1cmUsIGdyb3VwLCBzdWZmaXgsIGVzY2FwZSkge1xuICAgIC8vIEF2b2lkaW5nIHJlLWVzY2FwaW5nIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuXG4gICAgLy8gRXNjYXBlIHJlZ2V4cCBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gICAgaWYgKGVzY2FwZSkge1xuICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVwZWF0ICAgPSBzdWZmaXggPT09ICcrJyB8fCBzdWZmaXggPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBzdWZmaXggPT09ICc/JyB8fCBzdWZmaXggPT09ICcqJztcblxuICAgIGtleXMucHVzaCh7XG4gICAgICBuYW1lOiAgICAgIGtleSB8fCBpbmRleCsrLFxuICAgICAgZGVsaW1pdGVyOiBwcmVmaXggfHwgJy8nLFxuICAgICAgb3B0aW9uYWw6ICBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogICAgcmVwZWF0XG4gICAgfSk7XG5cbiAgICAvLyBFc2NhcGUgdGhlIHByZWZpeCBjaGFyYWN0ZXIuXG4gICAgcHJlZml4ID0gcHJlZml4ID8gJ1xcXFwnICsgcHJlZml4IDogJyc7XG5cbiAgICAvLyBNYXRjaCB1c2luZyB0aGUgY3VzdG9tIGNhcHR1cmluZyBncm91cCwgb3IgZmFsbGJhY2sgdG8gY2FwdHVyaW5nXG4gICAgLy8gZXZlcnl0aGluZyB1cCB0byB0aGUgbmV4dCBzbGFzaCAob3IgbmV4dCBwZXJpb2QgaWYgdGhlIHBhcmFtIHdhc1xuICAgIC8vIHByZWZpeGVkIHdpdGggYSBwZXJpb2QpLlxuICAgIGNhcHR1cmUgPSBlc2NhcGVHcm91cChjYXB0dXJlIHx8IGdyb3VwIHx8ICdbXicgKyAocHJlZml4IHx8ICdcXFxcLycpICsgJ10rPycpO1xuXG4gICAgLy8gQWxsb3cgcGFyYW1ldGVycyB0byBiZSByZXBlYXRlZCBtb3JlIHRoYW4gb25jZS5cbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICBjYXB0dXJlID0gY2FwdHVyZSArICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgYSBwYXJhbWV0ZXIgdG8gYmUgb3B0aW9uYWwuXG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgcGFyYW1ldGVyIHN1cHBvcnQuXG4gICAgcmV0dXJuIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gIH0pO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHBhdGggZW5kcyBpbiBhIHNsYXNoIGFzIGl0IGFsdGVycyBzb21lIG1hdGNoIGJlaGF2aW91ci5cbiAgdmFyIGVuZHNXaXRoU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJztcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYW4gb3B0aW9uYWwgdHJhaWxpbmcgc2xhc2ggaW4gdGhlIG1hdGNoLiBJZlxuICAvLyB0aGUgcGF0aCB0byBtYXRjaCBhbHJlYWR5IGVuZGVkIHdpdGggYSBzbGFzaCwgd2UgbmVlZCB0byByZW1vdmUgaXQgZm9yXG4gIC8vIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2ggaXMgb25seSB2YWxpZCBhdCB0aGUgdmVyeSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3RcbiAgLy8gYW55d2hlcmUgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIG5vbi1lbmRpbmcgbW9kZSwgb3RoZXJ3aXNlXG4gIC8vIFwiL3Rlc3QvXCIgd2lsbCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHBhdGggPSAoZW5kc1dpdGhTbGFzaCA/IHBhdGguc2xpY2UoMCwgLTIpIDogcGF0aCkgKyAnKD86XFxcXC8oPz0kKSk/JztcbiAgfVxuXG4gIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCBwcm9tcHQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaFxuICAvLyBhcyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCBmb3IgdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgaWYgKCFlbmQpIHtcbiAgICBwYXRoICs9IHN0cmljdCAmJiBlbmRzV2l0aFNsYXNoID8gJycgOiAnKD89XFxcXC98JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyBwYXRoICsgKGVuZCA/ICckJyA6ICcnKSwgZmxhZ3MpLCBrZXlzKTtcbn07XG5cbn0se31dfSx7fSxbMV0pKDEpXG59KTsiLCIvKlxuXG5cdHJhY3RpdmUtZXZlbnRzLXRhcFxuXHQ9PT09PT09PT09PT09PT09PT1cblxuXHRWZXJzaW9uIDAuMS4yLlxuXG5cdE9uIG1vYmlsZSBkZXZpY2VzLCB1c2luZyBgb24tY2xpY2tgIGlzbid0IGdvb2QgZW5vdWdoLiBUYXBwaW5nIHRoZVxuXHR0b3VjaHNjcmVlbiB3aWxsIGZpcmUgYSBzaW11bGF0ZWQgY2xpY2sgZXZlbnQsIGJ1dCBvbmx5IGFmdGVyIGEgMzAwXG5cdG1pbGxpc2Vjb25kIGRlbGF5LCB3aGljaCBtYWtlcyB5b3VyIGFwcCBmZWVsIHNsdWdnaXNoLiBJdCBhbHNvXG5cdGNhdXNlcyB0aGUgdGFwcGVkIGFyZWEgdG8gaGlnaGxpZ2h0LCB3aGljaCBpbiBtb3N0IGNhc2VzIGxvb2tzIGFcblx0Yml0IG1lc3N5LlxuXG5cdEluc3RlYWQsIHVzZSBgb24tdGFwYC4gV2hlbiB5b3UgdGFwIGFuIGFyZWEsIHRoZSBzaW11bGF0ZWQgY2xpY2tcblx0ZXZlbnQgd2lsbCBiZSBwcmV2ZW50ZWQsIGFuZCB0aGUgdXNlcidzIGFjdGlvbiBpcyByZXNwb25kZWQgdG9cblx0aW5zdGFudGx5LiBUaGUgYG9uLXRhcGAgZXZlbnQgYWxzbyBkaWZmZXJzIGZyb20gYG9uLWNsaWNrYCBpbiB0aGF0XG5cdHRoZSBjbGljayBldmVudCB3aWxsIChmcmFua2x5IHJhdGhlciBiaXphcnJlbHkpIGZpcmUgZXZlbiBpZiB5b3Vcblx0aG9sZCB0aGUgbW91c2UgZG93biBvdmVyIGEgc2luZ2xlIGVsZW1lbnQgZm9yIHNldmVyYWwgc2Vjb25kcyBhbmRcblx0d2FnZ2xlIGl0IGFib3V0LlxuXG5cdFBvaW50ZXIgZXZlbnRzIGFyZSBhbHNvIHN1cHBvcnRlZCwgYXMgaXMgcHJlc3NpbmcgdGhlIHNwYWNlYmFyIHdoZW5cblx0dGhlIHJlbGV2YW50IGVsZW1lbnQgaXMgZm9jdXNlZCAod2hpY2ggdHJpZ2dlcnMgYSBjbGljayBldmVudCwgYW5kXG5cdGlzIGdvb2QgZm9yIGFjY2Vzc2liaWxpdHkpLlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VHJvdWJsZXNob290aW5nOiBJZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgc3lzdGVtIGluIHlvdXIgYXBwIChBTUQgb3Jcblx0c29tZXRoaW5nIG1vcmUgbm9kZXkpIHRoZW4geW91IG1heSBuZWVkIHRvIGNoYW5nZSB0aGUgcGF0aHMgYmVsb3csXG5cdHdoZXJlIGl0IHNheXMgYHJlcXVpcmUoICdyYWN0aXZlJyApYCBvciBgZGVmaW5lKFsgJ3JhY3RpdmUnIF0uLi4pYC5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFVzYWdlOiBJbmNsdWRlIHRoaXMgZmlsZSBvbiB5b3VyIHBhZ2UgYmVsb3cgUmFjdGl2ZSwgZS5nOlxuXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUuanMnPjwvc2NyaXB0PlxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLWV2ZW50cy10YXAuanMnPjwvc2NyaXB0PlxuXG5cdE9yLCBpZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgbG9hZGVyLCByZXF1aXJlIHRoaXMgbW9kdWxlOlxuXG5cdCAgICAvLyByZXF1aXJpbmcgdGhlIHBsdWdpbiB3aWxsICdhY3RpdmF0ZScgaXQgLSBubyBuZWVkIHRvIHVzZVxuXHQgICAgLy8gdGhlIHJldHVybiB2YWx1ZVxuXHQgICAgcmVxdWlyZSggJ3JhY3RpdmUtZXZlbnRzLXRhcCcgKTtcblxuXHRBZGQgYSB0YXAgZXZlbnQgaW4gdGhlIG5vcm1hbCBmYXNoaW9uOlxuXG5cdCAgICA8ZGl2IG9uLXRhcD0nZm9vJz50YXAgbWUhPC9kaXY+XG5cblx0VGhlbiBhZGQgYSBoYW5kbGVyOlxuXG5cdCAgICByYWN0aXZlLm9uKCAnZm9vJywgZnVuY3Rpb24gKCBldmVudCApIHtcblx0ICAgICAgYWxlcnQoICd0YXBwZWQnICk7XG5cdCAgICB9KTtcblxuKi9cblxuKGZ1bmN0aW9uICggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBDb21tb24gSlMgKGkuZS4gYnJvd3NlcmlmeSkgZW52aXJvbm1lbnRcblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRmYWN0b3J5KCByZXF1aXJlKCBcIi4vLi4vcmFjdGl2ZS9yYWN0aXZlLmpzXCIgKSApO1xuXHR9XG5cblx0Ly8gQU1EP1xuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZShbICdyYWN0aXZlJyBdLCBmYWN0b3J5ICk7XG5cdH1cblxuXHQvLyBicm93c2VyIGdsb2JhbFxuXHRlbHNlIGlmICggZ2xvYmFsLlJhY3RpdmUgKSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsLlJhY3RpdmUgKTtcblx0fVxuXG5cdGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ0NvdWxkIG5vdCBmaW5kIFJhY3RpdmUhIEl0IG11c3QgYmUgbG9hZGVkIGJlZm9yZSB0aGUgcmFjdGl2ZS1ldmVudHMtdGFwIHBsdWdpbicgKTtcblx0fVxuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICggUmFjdGl2ZSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHRhcCA9IGZ1bmN0aW9uICggbm9kZSwgZmlyZSApIHtcblx0XHR2YXIgbW91c2Vkb3duLCB0b3VjaHN0YXJ0LCBmb2N1c0hhbmRsZXIsIGRpc3RhbmNlVGhyZXNob2xkLCB0aW1lVGhyZXNob2xkLCBwcmV2ZW50TW91c2Vkb3duRXZlbnRzLCBwcmV2ZW50TW91c2Vkb3duVGltZW91dDtcblxuXHRcdGRpc3RhbmNlVGhyZXNob2xkID0gNTsgLy8gbWF4aW11bSBwaXhlbHMgcG9pbnRlciBjYW4gbW92ZSBiZWZvcmUgY2FuY2VsXG5cdFx0dGltZVRocmVzaG9sZCA9IDQwMDsgICAvLyBtYXhpbXVtIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIGRvd24gYW5kIHVwIGJlZm9yZSBjYW5jZWxcblxuXHRcdG1vdXNlZG93biA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHR2YXIgY3VycmVudFRhcmdldCwgeCwgeSwgcG9pbnRlcklkLCB1cCwgbW92ZSwgY2FuY2VsO1xuXG5cdFx0XHRpZiAoIHByZXZlbnRNb3VzZWRvd25FdmVudHMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBldmVudC53aGljaCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LndoaWNoICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHggPSBldmVudC5jbGllbnRYO1xuXHRcdFx0eSA9IGV2ZW50LmNsaWVudFk7XG5cdFx0XHRjdXJyZW50VGFyZ2V0ID0gdGhpcztcblx0XHRcdC8vIFRoaXMgd2lsbCBiZSBudWxsIGZvciBtb3VzZSBldmVudHMuXG5cdFx0XHRwb2ludGVySWQgPSBldmVudC5wb2ludGVySWQ7XG5cblx0XHRcdHVwID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBldmVudC5wb2ludGVySWQgIT0gcG9pbnRlcklkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpcmUoe1xuXHRcdFx0XHRcdG5vZGU6IGN1cnJlbnRUYXJnZXQsXG5cdFx0XHRcdFx0b3JpZ2luYWw6IGV2ZW50XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0fTtcblxuXHRcdFx0bW92ZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggZXZlbnQucG9pbnRlcklkICE9IHBvaW50ZXJJZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICggTWF0aC5hYnMoIGV2ZW50LmNsaWVudFggLSB4ICkgPj0gZGlzdGFuY2VUaHJlc2hvbGQgKSB8fCAoIE1hdGguYWJzKCBldmVudC5jbGllbnRZIC0geSApID49IGRpc3RhbmNlVGhyZXNob2xkICkgKSB7XG5cdFx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyVXAnLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlck1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyQ2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJjYW5jZWwnLCBjYW5jZWwsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkICkge1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJjYW5jZWwnLCBjYW5jZWwsIGZhbHNlICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlclVwJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJNb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlckNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRUaW1lb3V0KCBjYW5jZWwsIHRpbWVUaHJlc2hvbGQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkICkge1xuXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcmRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0fSBlbHNlIGlmICggd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkICkge1xuXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyRG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHRcdH1cblxuXG5cdFx0dG91Y2hzdGFydCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHR2YXIgY3VycmVudFRhcmdldCwgeCwgeSwgdG91Y2gsIGZpbmdlciwgbW92ZSwgdXAsIGNhbmNlbDtcblxuXHRcdFx0aWYgKCBldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG5cblx0XHRcdHggPSB0b3VjaC5jbGllbnRYO1xuXHRcdFx0eSA9IHRvdWNoLmNsaWVudFk7XG5cdFx0XHRjdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuXHRcdFx0ZmluZ2VyID0gdG91Y2guaWRlbnRpZmllcjtcblxuXHRcdFx0dXAgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdG91Y2g7XG5cblx0XHRcdFx0dG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblx0XHRcdFx0aWYgKCB0b3VjaC5pZGVudGlmaWVyICE9PSBmaW5nZXIgKSB7XG5cdFx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgLy8gcHJldmVudCBjb21wYXRpYmlsaXR5IG1vdXNlIGV2ZW50XG5cblx0XHRcdFx0Ly8gZm9yIHRoZSBiZW5lZml0IG9mIG1vYmlsZSBGaXJlZm94IGFuZCBvbGQgQW5kcm9pZCBicm93c2Vycywgd2UgbmVlZCB0aGlzIGFic3VyZCBoYWNrLlxuXHRcdFx0XHRwcmV2ZW50TW91c2Vkb3duRXZlbnRzID0gdHJ1ZTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCBwcmV2ZW50TW91c2Vkb3duVGltZW91dCApO1xuXG5cdFx0XHRcdHByZXZlbnRNb3VzZWRvd25UaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHByZXZlbnRNb3VzZWRvd25FdmVudHMgPSBmYWxzZTtcblx0XHRcdFx0fSwgNDAwICk7XG5cblx0XHRcdFx0ZmlyZSh7XG5cdFx0XHRcdFx0bm9kZTogY3VycmVudFRhcmdldCxcblx0XHRcdFx0XHRvcmlnaW5hbDogZXZlbnRcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRtb3ZlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRvdWNoO1xuXG5cdFx0XHRcdGlmICggZXZlbnQudG91Y2hlcy5sZW5ndGggIT09IDEgfHwgZXZlbnQudG91Y2hlc1swXS5pZGVudGlmaWVyICE9PSBmaW5nZXIgKSB7XG5cdFx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG5cdFx0XHRcdGlmICggKCBNYXRoLmFicyggdG91Y2guY2xpZW50WCAtIHggKSA+PSBkaXN0YW5jZVRocmVzaG9sZCApIHx8ICggTWF0aC5hYnMoIHRvdWNoLmNsaWVudFkgLSB5ICkgPj0gZGlzdGFuY2VUaHJlc2hvbGQgKSApIHtcblx0XHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Y2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hjYW5jZWwnLCBjYW5jZWwsIGZhbHNlICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblxuXHRcdFx0c2V0VGltZW91dCggY2FuY2VsLCB0aW1lVGhyZXNob2xkICk7XG5cdFx0fTtcblxuXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSApO1xuXG5cblx0XHQvLyBuYXRpdmUgYnV0dG9ucywgYW5kIDxpbnB1dCB0eXBlPSdidXR0b24nPiBlbGVtZW50cywgc2hvdWxkIGZpcmUgYSB0YXAgZXZlbnRcblx0XHQvLyB3aGVuIHRoZSBzcGFjZSBrZXkgaXMgcHJlc3NlZFxuXHRcdGlmICggbm9kZS50YWdOYW1lID09PSAnQlVUVE9OJyB8fCBub2RlLnR5cGUgPT09ICdidXR0b24nICkge1xuXHRcdFx0Zm9jdXNIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgYmx1ckhhbmRsZXIsIGtleWRvd25IYW5kbGVyO1xuXG5cdFx0XHRcdGtleWRvd25IYW5kbGVyID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LndoaWNoID09PSAzMiApIHsgLy8gc3BhY2Uga2V5XG5cdFx0XHRcdFx0XHRmaXJlKHtcblx0XHRcdFx0XHRcdFx0bm9kZTogbm9kZSxcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWw6IGV2ZW50XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ymx1ckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGtleWRvd25IYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBibHVySGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywga2V5ZG93bkhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBibHVySGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH07XG5cblx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3VzJywgZm9jdXNIYW5kbGVyLCBmYWxzZSApO1xuXHRcdH1cblxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJEb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdmb2N1cycsIGZvY3VzSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdFJhY3RpdmUuZXZlbnRzLnRhcCA9IHRhcDtcblxufSkpO1xuIiwiLypcblx0cmFjdGl2ZS5qcyB2MC42LjFcblx0MjAxNC0xMC0yNSAtIGNvbW1pdCAzYTU3NmViMyBcblxuXHRodHRwOi8vcmFjdGl2ZWpzLm9yZ1xuXHRodHRwOi8vdHdpdHRlci5jb20vUmFjdGl2ZUpTXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbm9Db25mbGljdCA9IGdsb2JhbC5SYWN0aXZlO1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9vcHRpb25zLmpzICovXG5cdHZhciBvcHRpb25zID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0XHQvLyByZW5kZXIgcGxhY2VtZW50OlxuXHRcdFx0ZWw6IHZvaWQgMCxcblx0XHRcdGFwcGVuZDogZmFsc2UsXG5cdFx0XHQvLyB0ZW1wbGF0ZTpcblx0XHRcdHRlbXBsYXRlOiB7XG5cdFx0XHRcdHY6IDEsXG5cdFx0XHRcdHQ6IFtdXG5cdFx0XHR9LFxuXHRcdFx0eWllbGQ6IG51bGwsXG5cdFx0XHQvLyBwYXJzZTpcblx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZTogZmFsc2UsXG5cdFx0XHRzYW5pdGl6ZTogZmFsc2UsXG5cdFx0XHRzdHJpcENvbW1lbnRzOiB0cnVlLFxuXHRcdFx0Ly8gZGF0YSAmIGJpbmRpbmc6XG5cdFx0XHRkYXRhOiB7fSxcblx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdG1hZ2ljOiBmYWxzZSxcblx0XHRcdG1vZGlmeUFycmF5czogdHJ1ZSxcblx0XHRcdGFkYXB0OiBbXSxcblx0XHRcdGlzb2xhdGVkOiBmYWxzZSxcblx0XHRcdHR3b3dheTogdHJ1ZSxcblx0XHRcdGxhenk6IGZhbHNlLFxuXHRcdFx0Ly8gdHJhbnNpdGlvbnM6XG5cdFx0XHRub0ludHJvOiBmYWxzZSxcblx0XHRcdHRyYW5zaXRpb25zRW5hYmxlZDogdHJ1ZSxcblx0XHRcdGNvbXBsZXRlOiB2b2lkIDAsXG5cdFx0XHQvLyBjc3M6XG5cdFx0XHRub0Nzc1RyYW5zZm9ybTogZmFsc2UsXG5cdFx0XHQvLyBkZWJ1Zzpcblx0XHRcdGRlYnVnOiBmYWxzZVxuXHRcdH07XG5cdFx0cmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuXHR9KCk7XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL2Vhc2luZy5qcyAqL1xuXHR2YXIgZWFzaW5nID0ge1xuXHRcdGxpbmVhcjogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBwb3M7XG5cdFx0fSxcblx0XHRlYXNlSW46IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIHBvcywgMyApO1xuXHRcdH0sXG5cdFx0ZWFzZU91dDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyggcG9zIC0gMSwgMyApICsgMTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdGlmICggKCBwb3MgLz0gMC41ICkgPCAxICkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coIHBvcywgMyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICggTWF0aC5wb3coIHBvcyAtIDIsIDMgKSArIDIgKTtcblx0XHR9XG5cdH07XG5cblx0LyogY2lyY3VsYXIuanMgKi9cblx0dmFyIGNpcmN1bGFyID0gW107XG5cblx0LyogdXRpbHMvaGFzT3duUHJvcGVydHkuanMgKi9cblx0dmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0LyogdXRpbHMvaXNBcnJheS5qcyAqL1xuXHR2YXIgaXNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHQvLyB0aGFua3MsIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2luc3RhbmNlb2YtY29uc2lkZXJlZC1oYXJtZnVsLW9yLWhvdy10by13cml0ZS1hLXJvYnVzdC1pc2FycmF5L1xuXHRcdHJldHVybiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvaXNPYmplY3QuanMgKi9cblx0dmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcdHJldHVybiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdGhpbmcgJiYgdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2lzTnVtZXJpYy5qcyAqL1xuXHR2YXIgaXNOdW1lcmljID0gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdHJldHVybiAhaXNOYU4oIHBhcnNlRmxvYXQoIHRoaW5nICkgKSAmJiBpc0Zpbml0ZSggdGhpbmcgKTtcblx0fTtcblxuXHQvKiBjb25maWcvZGVmYXVsdHMvaW50ZXJwb2xhdG9ycy5qcyAqL1xuXHR2YXIgaW50ZXJwb2xhdG9ycyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgaGFzT3duUHJvcGVydHksIGlzQXJyYXksIGlzT2JqZWN0LCBpc051bWVyaWMgKSB7XG5cblx0XHR2YXIgaW50ZXJwb2xhdG9ycywgaW50ZXJwb2xhdGUsIGNzc0xlbmd0aFBhdHRlcm47XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpbnRlcnBvbGF0ZSA9IGNpcmN1bGFyLmludGVycG9sYXRlO1xuXHRcdH0gKTtcblx0XHRjc3NMZW5ndGhQYXR0ZXJuID0gL14oWystXT9bMC05XStcXC4/KD86WzAtOV0rKT8pKHB4fGVtfGV4fCV8aW58Y218bW18cHR8cGMpJC87XG5cdFx0aW50ZXJwb2xhdG9ycyA9IHtcblx0XHRcdG51bWJlcjogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgZGVsdGE7XG5cdFx0XHRcdGlmICggIWlzTnVtZXJpYyggZnJvbSApIHx8ICFpc051bWVyaWMoIHRvICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJvbSA9ICtmcm9tO1xuXHRcdFx0XHR0byA9ICt0bztcblx0XHRcdFx0ZGVsdGEgPSB0byAtIGZyb207XG5cdFx0XHRcdGlmICggIWRlbHRhICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHJldHVybiBmcm9tICsgdCAqIGRlbHRhO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGFycmF5OiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBpbnRlcm1lZGlhdGUsIGludGVycG9sYXRvcnMsIGxlbiwgaTtcblx0XHRcdFx0aWYgKCAhaXNBcnJheSggZnJvbSApIHx8ICFpc0FycmF5KCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IFtdO1xuXHRcdFx0XHRpbnRlcnBvbGF0b3JzID0gW107XG5cdFx0XHRcdGkgPSBsZW4gPSBNYXRoLm1pbiggZnJvbS5sZW5ndGgsIHRvLmxlbmd0aCApO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzWyBpIF0gPSBpbnRlcnBvbGF0ZSggZnJvbVsgaSBdLCB0b1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3VycGx1cyB2YWx1ZXMgLSBkb24ndCBpbnRlcnBvbGF0ZSwgYnV0IGRvbid0IGV4Y2x1ZGUgdGhlbSBlaXRoZXJcblx0XHRcdFx0Zm9yICggaSA9IGxlbjsgaSA8IGZyb20ubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSBmcm9tWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaSA9IGxlbjsgaSA8IHRvLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gdG9bIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBsZW47XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IGludGVycG9sYXRvcnNbIGkgXSggdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdG9iamVjdDogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgcHJvcGVydGllcywgbGVuLCBpbnRlcnBvbGF0b3JzLCBpbnRlcm1lZGlhdGUsIHByb3A7XG5cdFx0XHRcdGlmICggIWlzT2JqZWN0KCBmcm9tICkgfHwgIWlzT2JqZWN0KCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb3BlcnRpZXMgPSBbXTtcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0ge307XG5cdFx0XHRcdGludGVycG9sYXRvcnMgPSB7fTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBmcm9tICkge1xuXHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggZnJvbSwgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCB0bywgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1sgcHJvcCBdID0gaW50ZXJwb2xhdGUoIGZyb21bIHByb3AgXSwgdG9bIHByb3AgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSBmcm9tWyBwcm9wIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gdG8gKSB7XG5cdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCB0bywgcHJvcCApICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKCBmcm9tLCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBsZW4sXG5cdFx0XHRcdFx0XHRwcm9wO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNbIGkgXTtcblx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gaW50ZXJwb2xhdG9yc1sgcHJvcCBdKCB0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gaW50ZXJwb2xhdG9ycztcblx0fSggY2lyY3VsYXIsIGhhc093biwgaXNBcnJheSwgaXNPYmplY3QsIGlzTnVtZXJpYyApO1xuXG5cdC8qIGNvbmZpZy9zdmcuanMgKi9cblx0dmFyIHN2ZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Zztcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRzdmcgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ZnID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSggJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3ZnO1xuXHR9KCk7XG5cblx0LyogdXRpbHMvd2Fybi5qcyAqL1xuXHR2YXIgd2FybiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0LyogZ2xvYmFsIGNvbnNvbGUgKi9cblx0XHR2YXIgd2Fybiwgd2FybmVkID0ge307XG5cdFx0aWYgKCB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29uc29sZS53YXJuLmFwcGx5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0d2FybiA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBhbGxvd0R1cGxpY2F0ZXMgKSB7XG5cdFx0XHRcdGlmICggIWFsbG93RHVwbGljYXRlcyApIHtcblx0XHRcdFx0XHRpZiAoIHdhcm5lZFsgbWVzc2FnZSBdICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3YXJuZWRbIG1lc3NhZ2UgXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnJWNSYWN0aXZlLmpzOiAlYycgKyBtZXNzYWdlLCAnY29sb3I6IHJnYigxMTQsIDE1NywgNTIpOycsICdjb2xvcjogcmdiKDg1LCA4NSwgODUpOycgKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdhcm4gPSBmdW5jdGlvbigpIHt9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2Fybjtcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9lcnJvcnMuanMgKi9cblx0dmFyIGVycm9ycyA9IHtcblx0XHRtaXNzaW5nUGFyc2VyOiAnTWlzc2luZyBSYWN0aXZlLnBhcnNlIC0gY2Fubm90IHBhcnNlIHRlbXBsYXRlLiBFaXRoZXIgcHJlcGFyc2Ugb3IgdXNlIHRoZSB2ZXJzaW9uIHRoYXQgaW5jbHVkZXMgdGhlIHBhcnNlcicsXG5cdFx0bWVyZ2VDb21wYXJpc29uRmFpbDogJ01lcmdlIG9wZXJhdGlvbjogY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZycsXG5cdFx0bm9Db21wb25lbnRFdmVudEFyZ3VtZW50czogJ0NvbXBvbmVudHMgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBzaW1wbGUgZXZlbnRzIC0geW91IGNhbm5vdCBpbmNsdWRlIGFyZ3VtZW50cy4gU29ycnkhJyxcblx0XHRub1RlbXBsYXRlRm9yUGFydGlhbDogJ0NvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFwie25hbWV9XCInLFxuXHRcdG5vTmVzdGVkUGFydGlhbHM6ICdQYXJ0aWFscyAoe3s+e25hbWV9fX0pIGNhbm5vdCBjb250YWluIG5lc3RlZCBpbmxpbmUgcGFydGlhbHMnLFxuXHRcdGV2YWx1YXRpb25FcnJvcjogJ0Vycm9yIGV2YWx1YXRpbmcgXCJ7dW5pcXVlU3RyaW5nfVwiOiB7ZXJyfScsXG5cdFx0YmFkQXJndW1lbnRzOiAnQmFkIGFyZ3VtZW50cyBcInthcmd1bWVudHN9XCIuIElcXCdtIG5vdCBhbGxvd2VkIHRvIGFyZ3VlIHVubGVzcyB5b3VcXCd2ZSBwYWlkLicsXG5cdFx0ZmFpbGVkQ29tcHV0YXRpb246ICdGYWlsZWQgdG8gY29tcHV0ZSBcIntrZXl9XCI6IHtlcnJ9Jyxcblx0XHRtaXNzaW5nUGx1Z2luOiAnTWlzc2luZyBcIntuYW1lfVwiIHtwbHVnaW59IHBsdWdpbi4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEge3BsdWdpbn0gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMje3BsdWdpbn1zJyxcblx0XHRiYWRSYWRpb0lucHV0QmluZGluZzogJ0EgcmFkaW8gaW5wdXQgY2FuIGhhdmUgdHdvLXdheSBiaW5kaW5nIG9uIGl0cyBuYW1lIGF0dHJpYnV0ZSwgb3IgaXRzIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGgnLFxuXHRcdG5vUmVnaXN0cnlGdW5jdGlvblJldHVybjogJ0EgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCBmb3IgXCJ7bmFtZX1cIiB7cmVnaXN0cnl9LCBidXQgbm8ge3JlZ2lzdHJ5fSB3YXMgcmV0dXJuZWQnLFxuXHRcdGRlZmF1bHRFbFNwZWNpZmllZDogJ1RoZSA8e25hbWV9Lz4gY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgYGVsYCBwcm9wZXJ0eTsgaXQgaGFzIGJlZW4gZGlzcmVnYXJkZWQnLFxuXHRcdG5vRWxlbWVudFByb3h5RXZlbnRXaWxkY2FyZHM6ICdPbmx5IGNvbXBvbmVudCBwcm94eS1ldmVudHMgbWF5IGNvbnRhaW4gXCIqXCIgd2lsZGNhcmRzLCA8e2VsZW1lbnR9IG9uLXtldmVudH0vPiBpcyBub3QgdmFsaWQuJyxcblx0XHRtZXRob2REZXByZWNhdGVkOiAnVGhlIG1ldGhvZCBcIntkZXByZWNhdGVkfVwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgXCJ7cmVwbGFjZW1lbnR9XCIgYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nXG5cdH07XG5cblx0LyogdXRpbHMvbG9nLmpzICovXG5cdHZhciBsb2cgPSBmdW5jdGlvbiggY29uc29sZXdhcm4sIGVycm9ycyApIHtcblxuXHRcdHZhciBsb2cgPSB7XG5cdFx0XHR3YXJuOiBmdW5jdGlvbiggb3B0aW9ucywgcGFzc3RocnUgKSB7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMuZGVidWcgJiYgIXBhc3N0aHJ1ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLndhcm5BbHdheXMoIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHR3YXJuQWx3YXlzOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5sb2dnZXIoIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSwgb3B0aW9ucy5hbGxvd0R1cGxpY2F0ZXMgKTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3JPbmx5KCBvcHRpb25zICk7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMuZGVidWcgKSB7XG5cdFx0XHRcdFx0dGhpcy53YXJuKCBvcHRpb25zLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRlcnJvck9ubHk6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGVidWcgKSB7XG5cdFx0XHRcdFx0dGhpcy5jcml0aWNhbCggb3B0aW9ucyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y3JpdGljYWw6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgZXJyID0gb3B0aW9ucy5lcnIgfHwgbmV3IEVycm9yKCBnZXRNZXNzYWdlKCBvcHRpb25zICkgKTtcblx0XHRcdFx0dGhpcy50aHJvd2VyKCBlcnIgKTtcblx0XHRcdH0sXG5cdFx0XHRsb2dnZXI6IGNvbnNvbGV3YXJuLFxuXHRcdFx0dGhyb3dlcjogZnVuY3Rpb24oIGVyciApIHtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRNZXNzYWdlKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSBlcnJvcnNbIG9wdGlvbnMubWVzc2FnZSBdIHx8IG9wdGlvbnMubWVzc2FnZSB8fCAnJztcblx0XHRcdHJldHVybiBpbnRlcnBvbGF0ZSggbWVzc2FnZSwgb3B0aW9ucy5hcmdzICk7XG5cdFx0fVxuXHRcdC8vIHNpbXBsZSBpbnRlcnBvbGF0aW9uLiBwcm9iYWJseSBxdWlja2VyIChhbmQgYmV0dGVyKSBvdXQgdGhlcmUsXG5cdFx0Ly8gYnV0IGxvZyBpcyBub3QgaW4gZ29sZGVuIHBhdGggb2YgZXhlY3V0aW9uLCBvbmx5IGV4Y2VwdGlvbnNcblx0XHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSggbWVzc2FnZSwgYXJncyApIHtcblx0XHRcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoIC97KFtee31dKil9L2csIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRyZXR1cm4gYXJnc1sgYiBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9nO1xuXHR9KCB3YXJuLCBlcnJvcnMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvaG9va3MvSG9vay5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vayA9IGZ1bmN0aW9uKCBsb2cgKSB7XG5cblx0XHR2YXIgZGVwcmVjYXRpb25zID0ge1xuXHRcdFx0Y29uc3RydWN0OiB7XG5cdFx0XHRcdGRlcHJlY2F0ZWQ6ICdiZWZvcmVJbml0Jyxcblx0XHRcdFx0cmVwbGFjZW1lbnQ6ICdvbmNvbnN0cnVjdCdcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IHtcblx0XHRcdFx0ZGVwcmVjYXRlZDogJ2luaXQnLFxuXHRcdFx0XHRtZXNzYWdlOiAnVGhlIFwiaW5pdFwiIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkICcgKyAnYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gJyArICdZb3UgY2FuIGVpdGhlciB1c2UgdGhlIFwib25pbml0XCIgbWV0aG9kIHdoaWNoIHdpbGwgZmlyZSAnICsgJ29ubHkgb25jZSBwcmlvciB0bywgYW5kIHJlZ2FyZGxlc3Mgb2YsIGFueSBldmVudHVhbCByYWN0aXZlICcgKyAnaW5zdGFuY2UgYmVpbmcgcmVuZGVyZWQsIG9yIGlmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgJyArICdyZW5kZXJlZCBET00sIHVzZSBcIm9ucmVuZGVyXCIgaW5zdGVhZC4gJyArICdTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLidcblx0XHRcdH0sXG5cdFx0XHRjb21wbGV0ZToge1xuXHRcdFx0XHRkZXByZWNhdGVkOiAnY29tcGxldGUnLFxuXHRcdFx0XHRyZXBsYWNlbWVudDogJ29uY29tcGxldGUnXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIEhvb2soIGV2ZW50ICkge1xuXHRcdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdFx0dGhpcy5tZXRob2QgPSAnb24nICsgZXZlbnQ7XG5cdFx0XHR0aGlzLmRlcHJlY2F0ZSA9IGRlcHJlY2F0aW9uc1sgZXZlbnQgXTtcblx0XHR9XG5cdFx0SG9vay5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcmcgKSB7XG5cdFx0XHRmdW5jdGlvbiBjYWxsKCBtZXRob2QgKSB7XG5cdFx0XHRcdGlmICggcmFjdGl2ZVsgbWV0aG9kIF0gKSB7XG5cdFx0XHRcdFx0YXJnID8gcmFjdGl2ZVsgbWV0aG9kIF0oIGFyZyApIDogcmFjdGl2ZVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2FsbCggdGhpcy5tZXRob2QgKTtcblx0XHRcdGlmICggIXJhY3RpdmVbIHRoaXMubWV0aG9kIF0gJiYgdGhpcy5kZXByZWNhdGUgJiYgY2FsbCggdGhpcy5kZXByZWNhdGUuZGVwcmVjYXRlZCApICkge1xuXHRcdFx0XHRsb2cud2FybkFsd2F5cygge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UgfHwgJ21ldGhvZERlcHJlY2F0ZWQnLFxuXHRcdFx0XHRcdGFyZ3M6IHRoaXMuZGVwcmVjYXRlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGFyZyA/IHJhY3RpdmUuZmlyZSggdGhpcy5ldmVudCwgYXJnICkgOiByYWN0aXZlLmZpcmUoIHRoaXMuZXZlbnQgKTtcblx0XHR9O1xuXHRcdHJldHVybiBIb29rO1xuXHR9KCBsb2cgKTtcblxuXHQvKiB1dGlscy9yZW1vdmVGcm9tQXJyYXkuanMgKi9cblx0dmFyIHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uKCBhcnJheSwgbWVtYmVyICkge1xuXHRcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoIG1lbWJlciApO1xuXHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0YXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB1dGlscy9Qcm9taXNlLmpzICovXG5cdHZhciBQcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIF9Qcm9taXNlLCBQRU5ESU5HID0ge30sXG5cdFx0XHRGVUxGSUxMRUQgPSB7fSxcblx0XHRcdFJFSkVDVEVEID0ge307XG5cdFx0aWYgKCB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIHVzZSBuYXRpdmUgUHJvbWlzZVxuXHRcdFx0X1Byb21pc2UgPSBQcm9taXNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfUHJvbWlzZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0dmFyIGZ1bGZpbGxlZEhhbmRsZXJzID0gW10sXG5cdFx0XHRcdFx0cmVqZWN0ZWRIYW5kbGVycyA9IFtdLFxuXHRcdFx0XHRcdHN0YXRlID0gUEVORElORyxcblx0XHRcdFx0XHRyZXN1bHQsIGRpc3BhdGNoSGFuZGxlcnMsIG1ha2VSZXNvbHZlciwgZnVsZmlsLCByZWplY3QsIHByb21pc2U7XG5cdFx0XHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBuZXdTdGF0ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gUEVORElORyApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2hIYW5kbGVycyA9IG1ha2VEaXNwYXRjaGVyKCBzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzLCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdC8vIGRpc3BhdGNoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZnVsZmlsID0gbWFrZVJlc29sdmVyKCBGVUxGSUxMRUQgKTtcblx0XHRcdFx0cmVqZWN0ID0gbWFrZVJlc29sdmVyKCBSRUpFQ1RFRCApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0XHQvLyBgdGhlbigpYCByZXR1cm5zIGEgUHJvbWlzZSAtIDIuMi43XG5cdFx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdFx0dmFyIHByb21pc2UyID0gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiggaGFuZGxlciwgaGFuZGxlcnMsIGZvcndhcmQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gMi4yLjEuMVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmdW5jdGlvbiggcDFyZXN1bHQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB4O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHggPSBoYW5kbGVyKCBwMXJlc3VsdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UyLCB4LCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhcmUgbm90IGdpdmVuXG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmb3J3YXJkICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHQvLyAyLjJcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKCBvbkZ1bGZpbGxlZCwgZnVsZmlsbGVkSGFuZGxlcnMsIGZ1bGZpbCApO1xuXHRcdFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcm9taXNlIGhhcyByZXNvbHZlZCBhbHJlYWR5LCBkaXNwYXRjaCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHByb21pc2VbICdjYXRjaCcgXSA9IGZ1bmN0aW9uKCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRoZW4oIG51bGwsIG9uUmVqZWN0ZWQgKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UuYWxsID0gZnVuY3Rpb24oIHByb21pc2VzICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRcdFx0cGVuZGluZywgaSwgcHJvY2Vzc1Byb21pc2U7XG5cdFx0XHRcdFx0aWYgKCAhcHJvbWlzZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRcdHByb21pc2VzWyBpIF0udGhlbiggZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoICEtLXBlbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRwZW5kaW5nID0gaSA9IHByb21pc2VzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb2Nlc3NQcm9taXNlKCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCApIHtcblx0XHRcdFx0XHRmdWxmaWwoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiggcmVhc29uICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCByZWFzb24gKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0X19leHBvcnQgPSBfUHJvbWlzZTtcblx0XHQvLyBUT0RPIHVzZSBNdXRhdGlvbk9ic2VydmVycyBvciBzb21ldGhpbmcgdG8gc2ltdWxhdGUgc2V0SW1tZWRpYXRlXG5cdFx0ZnVuY3Rpb24gd2FpdCggY2FsbGJhY2sgKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCBjYWxsYmFjaywgMCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyKCBoYW5kbGVycywgcmVzdWx0ICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaGFuZGxlcjtcblx0XHRcdFx0d2hpbGUgKCBoYW5kbGVyID0gaGFuZGxlcnMuc2hpZnQoKSApIHtcblx0XHRcdFx0XHRoYW5kbGVyKCByZXN1bHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlKCBwcm9taXNlLCB4LCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcblx0XHRcdHZhciB0aGVuO1xuXHRcdFx0Ly8gMi4zLjFcblx0XHRcdGlmICggeCA9PT0gcHJvbWlzZSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0EgcHJvbWlzZVxcJ3MgZnVsZmlsbG1lbnQgaGFuZGxlciBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyAyLjMuMlxuXHRcdFx0aWYgKCB4IGluc3RhbmNlb2YgX1Byb21pc2UgKSB7XG5cdFx0XHRcdHgudGhlbiggZnVsZmlsLCByZWplY3QgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHggJiYgKCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicgKSApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGVuID0geC50aGVuO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRyZWplY3QoIGUgKTtcblx0XHRcdFx0XHQvLyAyLjMuMy4yXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIDIuMy4zLjNcblx0XHRcdFx0aWYgKCB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHR2YXIgY2FsbGVkLCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZTtcblx0XHRcdFx0XHRyZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uKCB5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCBwcm9taXNlLCB5LCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmVqZWN0UHJvbWlzZSA9IGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZWplY3QoIHIgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR0aGVuLmNhbGwoIHgsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlICk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFjYWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdHJlamVjdCggZSApO1xuXHRcdFx0XHRcdFx0XHQvLyAyLjMuMy4zLjQuMlxuXHRcdFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZ1bGZpbCggeCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmdWxmaWwoIHggKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvbm9ybWFsaXNlUmVmLmpzICovXG5cdHZhciBub3JtYWxpc2VSZWYgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciByZWdleCA9IC9cXFtcXHMqKFxcKnxbMC05XXxbMS05XVswLTldKylcXHMqXFxdL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbGlzZVJlZiggcmVmICkge1xuXHRcdFx0cmV0dXJuICggcmVmIHx8ICcnICkucmVwbGFjZSggcmVnZXgsICcuJDEnICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHNoYXJlZC9nZXRJbm5lckNvbnRleHQuanMgKi9cblx0dmFyIGdldElubmVyQ29udGV4dCA9IGZ1bmN0aW9uKCBmcmFnbWVudCApIHtcblx0XHRkbyB7XG5cdFx0XHRpZiAoIGZyYWdtZW50LmNvbnRleHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LmNvbnRleHQ7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50ICk7XG5cdFx0cmV0dXJuICcnO1xuXHR9O1xuXG5cdC8qIHV0aWxzL2lzRXF1YWwuanMgKi9cblx0dmFyIGlzRXF1YWwgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBhID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBhID09PSBiO1xuXHR9O1xuXG5cdC8qIHNoYXJlZC9jcmVhdGVDb21wb25lbnRCaW5kaW5nLmpzICovXG5cdHZhciBjcmVhdGVDb21wb25lbnRCaW5kaW5nID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIHJ1bmxvb3A7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcnVubG9vcCA9IGNpcmN1bGFyLnJ1bmxvb3A7XG5cdFx0fSApO1xuXHRcdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIG90aGVySW5zdGFuY2UsIG90aGVyS2V5cGF0aCApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLm90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlO1xuXHRcdFx0dGhpcy5vdGhlcktleXBhdGggPSBvdGhlcktleXBhdGg7XG5cdFx0XHR0aGlzLmxvY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGluZyA9IHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy51bmxvY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHR9O1xuXHRcdEJpbmRpbmcucHJvdG90eXBlID0ge1xuXHRcdFx0aXNMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy51cGRhdGluZyB8fCB0aGlzLmNvdW50ZXJwYXJ0ICYmIHRoaXMuY291bnRlcnBhcnQudXBkYXRpbmc7XG5cdFx0XHR9LFxuXHRcdFx0c2h1ZmZsZTogZnVuY3Rpb24oIG5ld0luZGljZXMsIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSggdmFsdWUsIG5ld0luZGljZXMgKTtcblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSggdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHRwcm9wYWdhdGVDaGFuZ2U6IGZ1bmN0aW9uKCB2YWx1ZSwgbmV3SW5kaWNlcyApIHtcblx0XHRcdFx0dmFyIG90aGVyO1xuXHRcdFx0XHQvLyBPbmx5ICp5b3UqIGNhbiBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy5pc0xvY2tlZCgpICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLmxvY2soKTtcblx0XHRcdFx0XHQvLyBUT0RPIG1heWJlIHRoZSBjYXNlIHRoYXQgYHZhbHVlID09PSB0aGlzLnZhbHVlYCAtIHNob3VsZCB0aGF0IHJlc3VsdFxuXHRcdFx0XHRcdC8vIGluIGFuIHVwZGF0ZSByYXRoZXIgdGhhbiBhIHNldD9cblx0XHRcdFx0XHQvLyBpZiB0aGUgb3RoZXIgdmlld21vZGVsIGlzIGFscmVhZHkgbG9ja2VkIHVwLCBuZWVkIHRvIGRvIGEgZGVmZXJyZWQgdXBkYXRlXG5cdFx0XHRcdFx0aWYgKCAhcnVubG9vcC5hZGRWaWV3bW9kZWwoIG90aGVyID0gdGhpcy5vdGhlckluc3RhbmNlLnZpZXdtb2RlbCApICYmIHRoaXMuY291bnRlcnBhcnQudmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcnVubG9vcC5hZGRWaWV3bW9kZWwoIG90aGVyICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbmV3SW5kaWNlcyApIHtcblx0XHRcdFx0XHRcdG90aGVyLnNtYXJ0VXBkYXRlKCB0aGlzLm90aGVyS2V5cGF0aCwgdmFsdWUsIG5ld0luZGljZXMgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCBpc1NldHRhYmxlKCBvdGhlciwgdGhpcy5vdGhlcktleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdFx0b3RoZXIuc2V0KCB0aGlzLm90aGVyS2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdC8vIFRPRE8gd2lsbCB0aGUgY291bnRlcnBhcnQgdXBkYXRlIGFmdGVyIHRoaXMgbGluZSwgZHVyaW5nXG5cdFx0XHRcdFx0Ly8gdGhlIHJ1bmxvb3AgZW5kIGN5Y2xlPyBtYXkgYmUgYSBwcm9ibGVtLi4uXG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIHRoaXMudW5sb2NrICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWZpbmVWYWx1ZTogZnVuY3Rpb24oIGtleXBhdGhzICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIG90aGVyO1xuXHRcdFx0XHRpZiAoIHRoaXMuaXNMb2NrZWQoKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5sb2NrKCk7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBvdGhlciA9IHRoaXMub3RoZXJJbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0a2V5cGF0aHMubWFwKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLm90aGVyS2V5cGF0aCArIGtleXBhdGguc3Vic3RyKCB0aGlzJDAua2V5cGF0aC5sZW5ndGggKTtcblx0XHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBvdGhlci5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIHRoaXMudW5sb2NrICk7XG5cdFx0XHR9LFxuXHRcdFx0YmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMudW5iaW5kKCk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdHRoaXMuY291bnRlcnBhcnQub3RoZXJLZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTZXR0YWJsZSggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGNvbXB1dGVkID0gdmlld21vZGVsLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdO1xuXHRcdFx0cmV0dXJuICFjb21wdXRlZCB8fCBjb21wdXRlZC5zZXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRCaW5kaW5nKCBjb21wb25lbnQsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGggKSB7XG5cdFx0XHR2YXIgaGFzaCwgY2hpbGRJbnN0YW5jZSwgYmluZGluZ3MsIHBhcmVudFRvQ2hpbGRCaW5kaW5nLCBjaGlsZFRvUGFyZW50QmluZGluZztcblx0XHRcdGhhc2ggPSBwYXJlbnRLZXlwYXRoICsgJz0nICsgY2hpbGRLZXlwYXRoO1xuXHRcdFx0YmluZGluZ3MgPSBjb21wb25lbnQuYmluZGluZ3M7XG5cdFx0XHRpZiAoIGJpbmRpbmdzWyBoYXNoIF0gKSB7XG5cdFx0XHRcdC8vIFRPRE8gZG9lcyB0aGlzIGV2ZXIgaGFwcGVuP1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjaGlsZEluc3RhbmNlID0gY29tcG9uZW50Lmluc3RhbmNlO1xuXHRcdFx0cGFyZW50VG9DaGlsZEJpbmRpbmcgPSBuZXcgQmluZGluZyggcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGgsIGNoaWxkSW5zdGFuY2UsIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0YmluZGluZ3MucHVzaCggcGFyZW50VG9DaGlsZEJpbmRpbmcgKTtcblx0XHRcdGlmICggY2hpbGRJbnN0YW5jZS50d293YXkgKSB7XG5cdFx0XHRcdGNoaWxkVG9QYXJlbnRCaW5kaW5nID0gbmV3IEJpbmRpbmcoIGNoaWxkSW5zdGFuY2UsIGNoaWxkS2V5cGF0aCwgcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggY2hpbGRUb1BhcmVudEJpbmRpbmcgKTtcblx0XHRcdFx0cGFyZW50VG9DaGlsZEJpbmRpbmcuY291bnRlcnBhcnQgPSBjaGlsZFRvUGFyZW50QmluZGluZztcblx0XHRcdFx0Y2hpbGRUb1BhcmVudEJpbmRpbmcuY291bnRlcnBhcnQgPSBwYXJlbnRUb0NoaWxkQmluZGluZztcblx0XHRcdH1cblx0XHRcdGJpbmRpbmdzWyBoYXNoIF0gPSBwYXJlbnRUb0NoaWxkQmluZGluZztcblx0XHR9O1xuXHR9KCBjaXJjdWxhciwgaXNFcXVhbCApO1xuXG5cdC8qIHNoYXJlZC9yZXNvbHZlUmVmLmpzICovXG5cdHZhciByZXNvbHZlUmVmID0gZnVuY3Rpb24oIG5vcm1hbGlzZVJlZiwgZ2V0SW5uZXJDb250ZXh0LCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBhbmNlc3RvckVycm9yTWVzc2FnZSwgZ2V0T3B0aW9ucztcblx0XHRhbmNlc3RvckVycm9yTWVzc2FnZSA9ICdDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgLSB0b28gbWFueSBcIi4uL1wiIHByZWZpeGVzJztcblx0XHRnZXRPcHRpb25zID0ge1xuXHRcdFx0ZXZhbHVhdGVXcmFwcGVkOiB0cnVlXG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHJlc29sdmVSZWYoIHJhY3RpdmUsIHJlZiwgZnJhZ21lbnQsIGlzUGFyZW50TG9va3VwICkge1xuXHRcdFx0dmFyIGNvbnRleHQsIGtleSwgaW5kZXgsIGtleXBhdGgsIHBhcmVudFZhbHVlLCBoYXNDb250ZXh0Q2hhaW4sIHBhcmVudEtleXMsIGNoaWxkS2V5cywgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoO1xuXHRcdFx0cmVmID0gbm9ybWFsaXNlUmVmKCByZWYgKTtcblx0XHRcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyAnfi8nLCBpdCdzIGEgdG9wLWxldmVsIHJlZmVyZW5jZVxuXHRcdFx0aWYgKCByZWYuc3Vic3RyKCAwLCAyICkgPT09ICd+LycgKSB7XG5cdFx0XHRcdHJldHVybiByZWYuc3Vic3RyaW5nKCAyICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgd2l0aCAnLicsIGl0J3MgZWl0aGVyIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Ugb3Jcblx0XHRcdC8vIGFuIGFuY2VzdG9yIHJlZmVyZW5jZS4uLlxuXHRcdFx0aWYgKCByZWYuY2hhckF0KCAwICkgPT09ICcuJyApIHtcblx0XHRcdFx0cmV0dXJuIHJlc29sdmVBbmNlc3RvclJlZmVyZW5jZSggZ2V0SW5uZXJDb250ZXh0KCBmcmFnbWVudCApLCByZWYgKTtcblx0XHRcdH1cblx0XHRcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGZpbmQgdGhlIGtleXBhdGhcblx0XHRcdGtleSA9IHJlZi5zcGxpdCggJy4nIClbIDAgXTtcblx0XHRcdC8vIGdldCgpIGluIHZpZXdtb2RlbCBjcmVhdGlvbiBtZWFucyBubyBmcmFnbWVudCAoeWV0KVxuXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudCB8fCB7fTtcblx0XHRcdGRvIHtcblx0XHRcdFx0Y29udGV4dCA9IGZyYWdtZW50LmNvbnRleHQ7XG5cdFx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGNvbnRleHQsIGdldE9wdGlvbnMgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnRWYWx1ZSAmJiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nICkgJiYga2V5IGluIHBhcmVudFZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBjb250ZXh0ICsgJy4nICsgcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRcdC8vIFJvb3QvY29tcHV0ZWQgcHJvcGVydHk/XG5cdFx0XHRpZiAoIGtleSBpbiByYWN0aXZlLmRhdGEgfHwga2V5IGluIHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9ucyApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgYW5kIGl0J3Mgbm90IGlzb2xhdGVkLCB3ZVxuXHRcdFx0Ly8gY2FuIHRyeSBnb2luZyB1cCB0aGUgc2NvcGUgY2hhaW5cblx0XHRcdGlmICggcmFjdGl2ZS5fcGFyZW50ICYmICFyYWN0aXZlLmlzb2xhdGVkICkge1xuXHRcdFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuXHRcdFx0XHRmcmFnbWVudCA9IHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpbmRleCByZWZzXG5cdFx0XHRcdGlmICggZnJhZ21lbnQuaW5kZXhSZWZzICYmICggaW5kZXggPSBmcmFnbWVudC5pbmRleFJlZnNbIHJlZiBdICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBDcmVhdGUgYW4gaW5kZXggcmVmIGJpbmRpbmcsIHNvIHRoYXQgaXQgY2FuIGJlIHJlYm91bmQgbGV0dGVyIGlmIG5lY2Vzc2FyeS5cblx0XHRcdFx0XHQvLyBJdCBkb2Vzbid0IGhhdmUgYW4gYWxpYXMgc2luY2UgaXQncyBhbiBpbXBsaWNpdCBiaW5kaW5nLCBoZW5jZSBgLi4uWyByZWYgXSA9IHJlZmBcblx0XHRcdFx0XHRyYWN0aXZlLmNvbXBvbmVudC5pbmRleFJlZkJpbmRpbmdzWyByZWYgXSA9IHJlZjtcblx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIHJlZiwgaW5kZXgsIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cGF0aCA9IHJlc29sdmVSZWYoIHJhY3RpdmUuX3BhcmVudCwgcmVmLCBmcmFnbWVudCwgdHJ1ZSApO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgYW4gaW50ZXItY29tcG9uZW50IGJpbmRpbmdcblx0XHRcdFx0XHQvLyBJZiBwYXJlbnQga2V5cGF0aCBpcyAnb25lLmZvbycgYW5kIGNoaWxkIGlzICd0d28uZm9vJywgd2UgYmluZFxuXHRcdFx0XHRcdC8vICdvbmUnIHRvICd0d28nIGFzIGl0J3MgbW9yZSBlZmZpY2llbnQgYW5kIGF2b2lkcyBlZGdlIGNhc2VzXG5cdFx0XHRcdFx0cGFyZW50S2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdGNoaWxkS2V5cyA9IHJlZi5zcGxpdCggJy4nICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBwYXJlbnRLZXlzLmxlbmd0aCA+IDEgJiYgY2hpbGRLZXlzLmxlbmd0aCA+IDEgJiYgcGFyZW50S2V5c1sgcGFyZW50S2V5cy5sZW5ndGggLSAxIF0gPT09IGNoaWxkS2V5c1sgY2hpbGRLZXlzLmxlbmd0aCAtIDEgXSApIHtcblx0XHRcdFx0XHRcdHBhcmVudEtleXMucG9wKCk7XG5cdFx0XHRcdFx0XHRjaGlsZEtleXMucG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudEtleXBhdGggPSBwYXJlbnRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdGNoaWxkS2V5cGF0aCA9IGNoaWxkS2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIGNoaWxkS2V5cGF0aCwgcmFjdGl2ZS5fcGFyZW50LnZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKSwgdHJ1ZSApO1xuXHRcdFx0XHRcdGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIHJhY3RpdmUuY29tcG9uZW50LCByYWN0aXZlLl9wYXJlbnQsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZXJlJ3Mgbm8gY29udGV4dCBjaGFpbiwgYW5kIHRoZSBpbnN0YW5jZSBpcyBlaXRoZXIgYSkgaXNvbGF0ZWQgb3Jcblx0XHRcdC8vIGIpIGFuIG9ycGhhbiwgdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGtleXBhdGggaXMgaWRlbnRpY2FsIHRvIHRoZSByZWZlcmVuY2Vcblx0XHRcdGlmICggIWlzUGFyZW50TG9va3VwICYmICFoYXNDb250ZXh0Q2hhaW4gKSB7XG5cdFx0XHRcdC8vIHRoZSBkYXRhIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgcHJvcGVydHkgYnkgdGhpcyBuYW1lLFxuXHRcdFx0XHQvLyB0byBwcmV2ZW50IGZ1dHVyZSBmYWlsZWQgbG9va3Vwc1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIHJlZiwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJhY3RpdmUudmlld21vZGVsLmdldCggcmVmICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZUFuY2VzdG9yUmVmZXJlbmNlKCBiYXNlQ29udGV4dCwgcmVmICkge1xuXHRcdFx0dmFyIGNvbnRleHRLZXlzO1xuXHRcdFx0Ly8ge3sufX0gbWVhbnMgJ2N1cnJlbnQgY29udGV4dCdcblx0XHRcdGlmICggcmVmID09PSAnLicgKVxuXHRcdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQ7XG5cdFx0XHRjb250ZXh0S2V5cyA9IGJhc2VDb250ZXh0ID8gYmFzZUNvbnRleHQuc3BsaXQoICcuJyApIDogW107XG5cdFx0XHQvLyBhbmNlc3RvciByZWZlcmVuY2VzIChzdGFydGluZyBcIi4uL1wiKSBnbyB1cCB0aGUgdHJlZVxuXHRcdFx0aWYgKCByZWYuc3Vic3RyKCAwLCAzICkgPT09ICcuLi8nICkge1xuXHRcdFx0XHR3aGlsZSAoIHJlZi5zdWJzdHIoIDAsIDMgKSA9PT0gJy4uLycgKSB7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dEtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBhbmNlc3RvckVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZXh0S2V5cy5wb3AoKTtcblx0XHRcdFx0XHRyZWYgPSByZWYuc3Vic3RyaW5nKCAzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGV4dEtleXMucHVzaCggcmVmICk7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0S2V5cy5qb2luKCAnLicgKTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdCBhbiBhbmNlc3RvciByZWZlcmVuY2UgLSBtdXN0IGJlIGEgcmVzdHJpY3RlZCByZWZlcmVuY2UgKHByZXBlbmRlZCB3aXRoIFwiLlwiIG9yIFwiLi9cIilcblx0XHRcdGlmICggIWJhc2VDb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmLnJlcGxhY2UoIC9eXFwuXFwvPy8sICcnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQgKyByZWYucmVwbGFjZSggL15cXC5cXC8vLCAnLicgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBub3JtYWxpc2VSZWYsIGdldElubmVyQ29udGV4dCwgY3JlYXRlQ29tcG9uZW50QmluZGluZyApO1xuXG5cdC8qIGdsb2JhbC9UcmFuc2l0aW9uTWFuYWdlci5qcyAqL1xuXHR2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24oIGNhbGxiYWNrLCBwYXJlbnQgKSB7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblx0XHRcdHRoaXMuaW50cm9zID0gW107XG5cdFx0XHR0aGlzLm91dHJvcyA9IFtdO1xuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0dGhpcy50b3RhbENoaWxkcmVuID0gdGhpcy5vdXRyb0NoaWxkcmVuID0gMDtcblx0XHRcdHRoaXMuZGV0YWNoUXVldWUgPSBbXTtcblx0XHRcdHRoaXMub3V0cm9zQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuYWRkQ2hpbGQoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdGFkZENoaWxkOiBmdW5jdGlvbiggY2hpbGQgKSB7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0dGhpcy50b3RhbENoaWxkcmVuICs9IDE7XG5cdFx0XHRcdHRoaXMub3V0cm9DaGlsZHJlbiArPSAxO1xuXHRcdFx0fSxcblx0XHRcdGRlY3JlbWVudE91dHJvczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMub3V0cm9DaGlsZHJlbiAtPSAxO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGRlY3JlbWVudFRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy50b3RhbENoaWxkcmVuIC09IDE7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuXHRcdFx0XHRsaXN0LnB1c2goIHRyYW5zaXRpb24gKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggbGlzdCwgdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRkZXRhY2hOb2RlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZGV0YWNoUXVldWUuZm9yRWFjaCggZGV0YWNoICk7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaCggZGV0YWNoTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZGV0YWNoKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudC5kZXRhY2goKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXRhY2hOb2RlcyggdG0gKSB7XG5cdFx0XHR0bS5kZXRhY2hOb2RlcygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrKCB0bSApIHtcblx0XHRcdGlmICggIXRtLnJlYWR5IHx8IHRtLm91dHJvcy5sZW5ndGggfHwgdG0ub3V0cm9DaGlsZHJlbiApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdC8vIElmIGFsbCBvdXRyb3MgYXJlIGNvbXBsZXRlLCBhbmQgd2UgaGF2ZW4ndCBhbHJlYWR5IGRvbmUgdGhpcyxcblx0XHRcdC8vIHdlIG5vdGlmeSB0aGUgcGFyZW50IGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlXG5cdFx0XHQvLyBzdGFydCBkZXRhY2hpbmcgbm9kZXNcblx0XHRcdGlmICggIXRtLm91dHJvc0NvbXBsZXRlICkge1xuXHRcdFx0XHRpZiAoIHRtLnBhcmVudCApIHtcblx0XHRcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50T3V0cm9zKCB0bSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG0ub3V0cm9zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gT25jZSBldmVyeXRoaW5nIGlzIGRvbmUsIHdlIGNhbiBub3RpZnkgcGFyZW50IHRyYW5zaXRpb25cblx0XHRcdC8vIG1hbmFnZXIgYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG5cdFx0XHRpZiAoICF0bS5pbnRyb3MubGVuZ3RoICYmICF0bS50b3RhbENoaWxkcmVuICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0bS5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHR0bS5jYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdG0ucGFyZW50ICkge1xuXHRcdFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRUb3RhbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBUcmFuc2l0aW9uTWFuYWdlcjtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogZ2xvYmFsL3J1bmxvb3AuanMgKi9cblx0dmFyIHJ1bmxvb3AgPSBmdW5jdGlvbiggY2lyY3VsYXIsIEhvb2ssIHJlbW92ZUZyb21BcnJheSwgUHJvbWlzZSwgcmVzb2x2ZVJlZiwgVHJhbnNpdGlvbk1hbmFnZXIgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGJhdGNoLCBydW5sb29wLCB1bnJlc29sdmVkID0gW10sXG5cdFx0XHRjaGFuZ2VIb29rID0gbmV3IEhvb2soICdjaGFuZ2UnICk7XG5cdFx0cnVubG9vcCA9IHtcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiggaW5zdGFuY2UsIHJldHVyblByb21pc2UgKSB7XG5cdFx0XHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlO1xuXHRcdFx0XHRpZiAoIHJldHVyblByb21pc2UgKSB7XG5cdFx0XHRcdFx0cHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZjtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YmF0Y2ggPSB7XG5cdFx0XHRcdFx0cHJldmlvdXNCYXRjaDogYmF0Y2gsXG5cdFx0XHRcdFx0dHJhbnNpdGlvbk1hbmFnZXI6IG5ldyBUcmFuc2l0aW9uTWFuYWdlciggZnVsZmlsUHJvbWlzZSwgYmF0Y2ggJiYgYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIgKSxcblx0XHRcdFx0XHR2aWV3czogW10sXG5cdFx0XHRcdFx0dGFza3M6IFtdLFxuXHRcdFx0XHRcdHZpZXdtb2RlbHM6IFtdLFxuXHRcdFx0XHRcdGluc3RhbmNlOiBpbnN0YW5jZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGJhdGNoLnZpZXdtb2RlbHMucHVzaCggaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9LFxuXHRcdFx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zmx1c2hDaGFuZ2VzKCk7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmluaXQoKTtcblx0XHRcdFx0aWYgKCAhYmF0Y2gucHJldmlvdXNCYXRjaCAmJiAhIWJhdGNoLmluc3RhbmNlIClcblx0XHRcdFx0XHRiYXRjaC5pbnN0YW5jZS52aWV3bW9kZWwuY2hhbmdlcyA9IFtdO1xuXHRcdFx0XHRiYXRjaCA9IGJhdGNoLnByZXZpb3VzQmF0Y2g7XG5cdFx0XHR9LFxuXHRcdFx0YWRkVmlld21vZGVsOiBmdW5jdGlvbiggdmlld21vZGVsICkge1xuXHRcdFx0XHRpZiAoIGJhdGNoICkge1xuXHRcdFx0XHRcdGlmICggYmF0Y2gudmlld21vZGVscy5pbmRleE9mKCB2aWV3bW9kZWwgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRiYXRjaC52aWV3bW9kZWxzLnB1c2goIHZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlZ2lzdGVyVHJhbnNpdGlvbjogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24uX21hbmFnZXIgPSBiYXRjaC50cmFuc2l0aW9uTWFuYWdlcjtcblx0XHRcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkKCB0cmFuc2l0aW9uICk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkVmlldzogZnVuY3Rpb24oIHZpZXcgKSB7XG5cdFx0XHRcdGJhdGNoLnZpZXdzLnB1c2goIHZpZXcgKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRVbnJlc29sdmVkOiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRcdHVucmVzb2x2ZWQucHVzaCggdGhpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmVVbnJlc29sdmVkOiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdW5yZXNvbHZlZCwgdGhpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBzeW5jaHJvbmlzZSBub2RlIGRldGFjaG1lbnRzIHdpdGggdHJhbnNpdGlvbiBlbmRzXG5cdFx0XHRkZXRhY2hXaGVuUmVhZHk6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuZGV0YWNoUXVldWUucHVzaCggdGhpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHRzY2hlZHVsZVRhc2s6IGZ1bmN0aW9uKCB0YXNrLCBwb3N0UmVuZGVyICkge1xuXHRcdFx0XHR2YXIgX2JhdGNoO1xuXHRcdFx0XHRpZiAoICFiYXRjaCApIHtcblx0XHRcdFx0XHR0YXNrKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2JhdGNoID0gYmF0Y2g7XG5cdFx0XHRcdFx0d2hpbGUgKCBwb3N0UmVuZGVyICYmIF9iYXRjaC5wcmV2aW91c0JhdGNoICkge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyBjYW4ndCBoYXBwZW4gdW50aWwgdGhlIERPTSBoYXMgYmVlbiBmdWxseSB1cGRhdGVkXG5cdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UgaW4gc29tZSBzaXR1YXRpb25zICh3aXRoIGNvbXBvbmVudHMgaW5zaWRlIGVsZW1lbnRzKVxuXHRcdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbnMgYW5kIGRlY29yYXRvcnMgd2lsbCBpbml0aWFsaXNlIHByZW1hdHVyZWx5XG5cdFx0XHRcdFx0XHRfYmF0Y2ggPSBfYmF0Y2gucHJldmlvdXNCYXRjaDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2JhdGNoLnRhc2tzLnB1c2goIHRhc2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y2lyY3VsYXIucnVubG9vcCA9IHJ1bmxvb3A7XG5cdFx0X19leHBvcnQgPSBydW5sb29wO1xuXG5cdFx0ZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIGksIHRoaW5nLCBjaGFuZ2VIYXNoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC52aWV3bW9kZWxzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHR0aGluZyA9IGJhdGNoLnZpZXdtb2RlbHNbIGkgXTtcblx0XHRcdFx0Y2hhbmdlSGFzaCA9IHRoaW5nLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHRpZiAoIGNoYW5nZUhhc2ggKSB7XG5cdFx0XHRcdFx0Y2hhbmdlSG9vay5maXJlKCB0aGluZy5yYWN0aXZlLCBjaGFuZ2VIYXNoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoID0gMDtcblx0XHRcdGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpO1xuXHRcdFx0Ly8gTm93IHRoYXQgY2hhbmdlcyBoYXZlIGJlZW4gZnVsbHkgcHJvcGFnYXRlZCwgd2UgY2FuIHVwZGF0ZSB0aGUgRE9NXG5cdFx0XHQvLyBhbmQgY29tcGxldGUgb3RoZXIgdGFza3Ncblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYmF0Y2gudmlld3MubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGJhdGNoLnZpZXdzWyBpIF0udXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC52aWV3cy5sZW5ndGggPSAwO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC50YXNrcy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0YmF0Y2gudGFza3NbIGkgXSgpO1xuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudGFza3MubGVuZ3RoID0gMDtcblx0XHRcdC8vIElmIHVwZGF0aW5nIHRoZSB2aWV3IGNhdXNlZCBzb21lIG1vZGVsIGJsb3diYWNrIC0gZS5nLiBhIHRyaXBsZVxuXHRcdFx0Ly8gY29udGFpbmluZyA8b3B0aW9uPiBlbGVtZW50cyBjYXVzZWQgdGhlIGJpbmRpbmcgb24gdGhlIDxzZWxlY3Q+XG5cdFx0XHQvLyB0byB1cGRhdGUgLSB0aGVuIHdlIHN0YXJ0IG92ZXJcblx0XHRcdGlmICggYmF0Y2gudmlld21vZGVscy5sZW5ndGggKVxuXHRcdFx0XHRyZXR1cm4gZmx1c2hDaGFuZ2VzKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCkge1xuXHRcdFx0dmFyIGksIGl0ZW0sIGtleXBhdGgsIHJlc29sdmVkO1xuXHRcdFx0aSA9IHVucmVzb2x2ZWQubGVuZ3RoO1xuXHRcdFx0Ly8gc2VlIGlmIHdlIGNhbiByZXNvbHZlIGFueSB1bnJlc29sdmVkIHJlZmVyZW5jZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gdW5yZXNvbHZlZFsgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0ua2V5cGF0aCApIHtcblx0XHRcdFx0XHQvLyBpdCByZXNvbHZlZCBzb21lIG90aGVyIHdheS4gVE9ETyBob3c/IHR3by13YXkgYmluZGluZz8gU2VlbXNcblx0XHRcdFx0XHQvLyB3ZWlyZCB0aGF0IHdlJ2Qgc3RpbGwgZW5kIHVwIGhlcmVcblx0XHRcdFx0XHR1bnJlc29sdmVkLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgga2V5cGF0aCA9IHJlc29sdmVSZWYoIGl0ZW0ucm9vdCwgaXRlbS5yZWYsIGl0ZW0ucGFyZW50RnJhZ21lbnQgKSApIHtcblx0XHRcdFx0XHQoIHJlc29sdmVkIHx8ICggcmVzb2x2ZWQgPSBbXSApICkucHVzaCgge1xuXHRcdFx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0XHRcdGtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXNvbHZlZCApIHtcblx0XHRcdFx0cmVzb2x2ZWQuZm9yRWFjaCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmUoIHJlc29sdmVkICkge1xuXHRcdFx0cmVzb2x2ZWQuaXRlbS5yZXNvbHZlKCByZXNvbHZlZC5rZXlwYXRoICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJlbW92ZUZyb21BcnJheSwgUHJvbWlzZSwgcmVzb2x2ZVJlZiwgVHJhbnNpdGlvbk1hbmFnZXIgKTtcblxuXHQvKiB1dGlscy9jcmVhdGVCcmFuY2guanMgKi9cblx0dmFyIGNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG51bWVyaWMgPSAvXlxccypbMC05XStcXHMqJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gbnVtZXJpYy50ZXN0KCBrZXkgKSA/IFtdIDoge307XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L21hZ2ljQWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IgPSBmdW5jdGlvbiggcnVubG9vcCwgY3JlYXRlQnJhbmNoLCBpc0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBtYWdpY0FkYXB0b3IsIE1hZ2ljV3JhcHBlcjtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9ICk7XG5cdFx0XHRtYWdpY0FkYXB0b3IgPSB7XG5cdFx0XHRcdGZpbHRlcjogZnVuY3Rpb24oIG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSApIHtcblx0XHRcdFx0XHR2YXIga2V5cywga2V5LCBwYXJlbnRLZXlwYXRoLCBwYXJlbnRXcmFwcGVyLCBwYXJlbnRWYWx1ZTtcblx0XHRcdFx0XHRpZiAoICFrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdFx0a2V5ID0ga2V5cy5wb3AoKTtcblx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHQvLyBJZiB0aGUgcGFyZW50IHZhbHVlIGlzIGEgd3JhcHBlciwgb3RoZXIgdGhhbiBhIG1hZ2ljIHdyYXBwZXIsXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkbid0IHdyYXAgdGhpcyBwcm9wZXJ0eVxuXHRcdFx0XHRcdGlmICggKCBwYXJlbnRXcmFwcGVyID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdICkgJiYgIXBhcmVudFdyYXBwZXIubWFnaWMgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0XHQvLyBpZiBwYXJlbnRWYWx1ZSBpcyBhbiBhcnJheSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB0aGlzIG1lbWJlcixcblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlIG90aGVyd2lzZSBsZW5ndGhzIHdpbGwgZ2V0IG1lc3NlZCB1cFxuXHRcdFx0XHRcdGlmICggaXNBcnJheSggcGFyZW50VmFsdWUgKSAmJiAvXlswLTldKyQvLnRlc3QoIGtleSApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50VmFsdWUgJiYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cmFwOiBmdW5jdGlvbiggcmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNYWdpY1dyYXBwZXIoIHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRNYWdpY1dyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBrZXlzLCBvYmpLZXlwYXRoLCB0ZW1wbGF0ZSwgc2libGluZ3M7XG5cdFx0XHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0dGhpcy5wcm9wID0ga2V5cy5wb3AoKTtcblx0XHRcdFx0b2JqS2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdHRoaXMub2JqID0gb2JqS2V5cGF0aCA/IHJhY3RpdmUuZ2V0KCBvYmpLZXlwYXRoICkgOiByYWN0aXZlLmRhdGE7XG5cdFx0XHRcdHRlbXBsYXRlID0gdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB0aGlzLm9iaiwgdGhpcy5wcm9wICk7XG5cdFx0XHRcdC8vIEhhcyB0aGlzIHByb3BlcnR5IGFscmVhZHkgYmVlbiB3cmFwcGVkP1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldCAmJiAoIHNpYmxpbmdzID0gdGVtcGxhdGUuc2V0Ll9yYWN0aXZlV3JhcHBlcnMgKSApIHtcblx0XHRcdFx0XHQvLyBZZXMuIFJlZ2lzdGVyIHRoaXMgd3JhcHBlciB0byB0aGlzIHByb3BlcnR5LCBpZiBpdCBoYXNuJ3QgYmVlbiBhbHJlYWR5XG5cdFx0XHRcdFx0aWYgKCBzaWJsaW5ncy5pbmRleE9mKCB0aGlzICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0c2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTm8sIGl0IGhhc24ndCBiZWVuIHdyYXBwZWRcblx0XHRcdFx0Y3JlYXRlQWNjZXNzb3JzKCB0aGlzLCB2YWx1ZSwgdGVtcGxhdGUgKTtcblx0XHRcdH07XG5cdFx0XHRNYWdpY1dyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0Ly8gdHJpZ2dlciBzZXQoKSBhY2Nlc3NvclxuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJhY3RpdmUudmlld21vZGVsICk7XG5cdFx0XHRcdFx0dGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5tYXJrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICF0aGlzLm9ialsgdGhpcy5wcm9wIF0gKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IGNyZWF0ZUJyYW5jaCgga2V5ICk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXVsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciB0ZW1wbGF0ZSwgc2V0LCB2YWx1ZSwgd3JhcHBlcnMsIGluZGV4O1xuXHRcdFx0XHRcdC8vIElmIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQgYmVjYXVzZSB0aGUgY2FjaGUgd2FzIGJlaW5nIGNsZWFyZWQgYXMgYVxuXHRcdFx0XHRcdC8vIHJlc3VsdCBvZiBhIHNldCgpL3VwZGF0ZSgpIGNhbGwgbWFkZSBieSB0aGlzIHdyYXBwZXIsIHdlIHJldHVybiBmYWxzZVxuXHRcdFx0XHRcdC8vIHNvIHRoYXQgaXQgZG9lc24ndCBnZXQgdG9ybiBkb3duXG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMub2JqLCB0aGlzLnByb3AgKTtcblx0XHRcdFx0XHRzZXQgPSB0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQ7XG5cdFx0XHRcdFx0aWYgKCAhc2V0ICkge1xuXHRcdFx0XHRcdFx0Ly8gbW9zdCBsaWtlbHksIHRoaXMgd2FzIGFuIGFycmF5IG1lbWJlciB0aGF0IHdhcyBzcGxpY2VkIG91dFxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3cmFwcGVycyA9IHNldC5fcmFjdGl2ZVdyYXBwZXJzO1xuXHRcdFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBMYXN0IG9uZSBvdXQsIHR1cm4gb2ZmIHRoZSBsaWdodHNcblx0XHRcdFx0XHRpZiAoICF3cmFwcGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMub2JqWyB0aGlzLnByb3AgXTtcblx0XHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcy5vYmosIHRoaXMucHJvcCwgdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgfHwge1xuXHRcdFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdG1hZ2ljQWRhcHRvciA9IGZhbHNlO1xuXHRcdH1cblx0XHRfX2V4cG9ydCA9IG1hZ2ljQWRhcHRvcjtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc29ycyggb3JpZ2luYWxXcmFwcGVyLCB2YWx1ZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgb2JqZWN0LCBwcm9wZXJ0eSwgb2xkR2V0LCBvbGRTZXQsIGdldCwgc2V0O1xuXHRcdFx0b2JqZWN0ID0gb3JpZ2luYWxXcmFwcGVyLm9iajtcblx0XHRcdHByb3BlcnR5ID0gb3JpZ2luYWxXcmFwcGVyLnByb3A7XG5cdFx0XHQvLyBJcyB0aGlzIHRlbXBsYXRlIGNvbmZpZ3VyYWJsZT9cblx0XHRcdGlmICggdGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbmZpZ3VyYWJsZSApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gYXJyYXkgbGVuZ3RoXG5cdFx0XHRcdGlmICggcHJvcGVydHkgPT09ICdsZW5ndGgnICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3QgdXNlIG1hZ2ljIG1vZGUgd2l0aCBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIiAtIG9iamVjdCBpcyBub3QgY29uZmlndXJhYmxlJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZSB0byB3cmFwIHRoaXMgcHJvcGVydHlcblx0XHRcdGlmICggdGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9sZEdldCA9IHRlbXBsYXRlLmdldDtcblx0XHRcdFx0b2xkU2V0ID0gdGVtcGxhdGUuc2V0O1xuXHRcdFx0fVxuXHRcdFx0Z2V0ID0gb2xkR2V0IHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0c2V0ID0gZnVuY3Rpb24oIHYgKSB7XG5cdFx0XHRcdGlmICggb2xkU2V0ICkge1xuXHRcdFx0XHRcdG9sZFNldCggdiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gb2xkR2V0ID8gb2xkR2V0KCkgOiB2O1xuXHRcdFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycy5mb3JFYWNoKCB1cGRhdGVXcmFwcGVyICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVXcmFwcGVyKCB3cmFwcGVyICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aCwgcmFjdGl2ZTtcblx0XHRcdFx0d3JhcHBlci52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhY3RpdmUgPSB3cmFwcGVyLnJhY3RpdmU7XG5cdFx0XHRcdGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCByYWN0aXZlICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0d3JhcHBlci51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHdyYXBwZXJzLCBpbiBjYXNlIG90aGVyIGtleXBhdGhzL3JhY3RpdmVzIGRlcGVuZCBvbiB0aGlzIHByb3BlcnR5LlxuXHRcdFx0Ly8gSGFuZGlseSwgd2UgY2FuIHN0b3JlIHRoZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgc2V0IGZ1bmN0aW9uLiBZYXkgSmF2YVNjcmlwdC5cblx0XHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzID0gWyBvcmlnaW5hbFdyYXBwZXIgXTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqZWN0LCBwcm9wZXJ0eSwge1xuXHRcdFx0XHRnZXQ6IGdldCxcblx0XHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHJ1bmxvb3AsIGNyZWF0ZUJyYW5jaCwgaXNBcnJheSApO1xuXG5cdC8qIGNvbmZpZy9tYWdpYy5qcyAqL1xuXHR2YXIgbWFnaWMgPSBmdW5jdGlvbiggbWFnaWNBZGFwdG9yICkge1xuXG5cdFx0cmV0dXJuICEhbWFnaWNBZGFwdG9yO1xuXHR9KCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciApO1xuXG5cdC8qIGNvbmZpZy9uYW1lc3BhY2VzLmpzICovXG5cdHZhciBuYW1lc3BhY2VzID0ge1xuXHRcdGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcblx0XHRtYXRobWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcblx0XHRzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHR4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLFxuXHRcdHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG5cdH07XG5cblx0LyogdXRpbHMvY3JlYXRlRWxlbWVudC5qcyAqL1xuXHR2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCBzdmcsIG5hbWVzcGFjZXMgKSB7XG5cblx0XHR2YXIgY3JlYXRlRWxlbWVudDtcblx0XHQvLyBUZXN0IGZvciBTVkcgc3VwcG9ydFxuXHRcdGlmICggIXN2ZyApIHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZSwgbnMgKSB7XG5cdFx0XHRcdGlmICggbnMgJiYgbnMgIT09IG5hbWVzcGFjZXMuaHRtbCApIHtcblx0XHRcdFx0XHR0aHJvdyAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcyBvdGhlciB0aGFuIGh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwuIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBvZiB0aGlzIGVycm9yIGlzIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBTVkcgaW4gYW4gb2xkZXIgYnJvd3Nlci4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3N2Zy1hbmQtb2xkZXItYnJvd3NlcnMgZm9yIG1vcmUgaW5mb3JtYXRpb24nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHR5cGUsIG5zICkge1xuXHRcdFx0XHRpZiAoICFucyB8fCBucyA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggbnMsIHR5cGUgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50O1xuXHR9KCBzdmcsIG5hbWVzcGFjZXMgKTtcblxuXHQvKiBjb25maWcvaXNDbGllbnQuanMgKi9cblx0dmFyIGlzQ2xpZW50ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnO1xuXHRcdHJldHVybiBpc0NsaWVudDtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2RlZmluZVByb3BlcnR5LmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIGlzQ2xpZW50ICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICksICd0ZXN0Jywge1xuXHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cblx0XHRcdC8vIG9ubHkgdXNlIGl0IHdpdGggRE9NIG9iamVjdHMgKHdoYXQgdGhlIGZ1Y2sgd2VyZSB5b3Ugc21va2luZywgTVNGVD8pXG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIHByb3AsIGRlc2MgKSB7XG5cdFx0XHRcdG9ialsgcHJvcCBdID0gZGVzYy52YWx1ZTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0eTtcblx0fSggaXNDbGllbnQgKTtcblxuXHQvKiB1dGlscy9kZWZpbmVQcm9wZXJ0aWVzLmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0aWVzO1xuXHRcdHRyeSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcygge30sIHtcblx0XHRcdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHRcdGlmICggaXNDbGllbnQgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBjcmVhdGVFbGVtZW50KCAnZGl2JyApLCB7XG5cdFx0XHRcdFx0dGVzdDoge1xuXHRcdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBvYmosIHByb3BzICkge1xuXHRcdFx0XHR2YXIgcHJvcDtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHRcdFx0XHRpZiAoIHByb3BzLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCBwcm9wc1sgcHJvcCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZGVmaW5lUHJvcGVydGllcztcblx0fSggY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIGlzQ2xpZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2FkZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfYWRkID0gZnVuY3Rpb24oIGlzTnVtZXJpYyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhZGQoIHJvb3QsIGtleXBhdGgsIGQgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyB8fCAhaXNOdW1lcmljKCBkICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0JhZCBhcmd1bWVudHMnICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICtyb290LmdldCgga2V5cGF0aCApIHx8IDA7XG5cdFx0XHRpZiAoICFpc051bWVyaWMoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCBhZGQgdG8gYSBub24tbnVtZXJpYyB2YWx1ZScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290LnNldCgga2V5cGF0aCwgdmFsdWUgKyBkICk7XG5cdFx0fTtcblx0fSggaXNOdW1lcmljICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYWRkLmpzICovXG5cdHZhciBSYWN0aXZlJGFkZCA9IGZ1bmN0aW9uKCBhZGQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRhZGQoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAxIDogK2QgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9hZGQgKTtcblxuXHQvKiB1dGlscy9ub3JtYWxpc2VLZXlwYXRoLmpzICovXG5cdHZhciBub3JtYWxpc2VLZXlwYXRoID0gZnVuY3Rpb24oIG5vcm1hbGlzZVJlZiApIHtcblxuXHRcdHZhciBsZWFkaW5nRG90ID0gL15cXC4rLztcblx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiBub3JtYWxpc2VSZWYoIGtleXBhdGggKS5yZXBsYWNlKCBsZWFkaW5nRG90LCAnJyApO1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZVJlZiApO1xuXG5cdC8qIGNvbmZpZy92ZW5kb3JzLmpzICovXG5cdHZhciB2ZW5kb3JzID0gW1xuXHRcdCdvJyxcblx0XHQnbXMnLFxuXHRcdCdtb3onLFxuXHRcdCd3ZWJraXQnXG5cdF07XG5cblx0LyogdXRpbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzICovXG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0Ly8gSWYgd2luZG93IGRvZXNuJ3QgZXhpc3QsIHdlIGRvbid0IG5lZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG5cdFx0XHQoIGZ1bmN0aW9uKCB2ZW5kb3JzLCBsYXN0VGltZSwgd2luZG93ICkge1xuXHRcdFx0XHR2YXIgeCwgc2V0VGltZW91dDtcblx0XHRcdFx0aWYgKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3ggKSB7XG5cdFx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1sgdmVuZG9yc1sgeCBdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblx0XHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblx0XHRcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRcdHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xuXHRcdFx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0fSwgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaWQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSggdmVuZG9ycywgMCwgd2luZG93ICkgKTtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB1dGlscy9nZXRUaW1lLmpzICovXG5cdHZhciBnZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZ2V0VGltZTtcblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIERhdGUubm93KCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0VGltZTtcblx0fSgpO1xuXG5cdC8qIHNoYXJlZC9hbmltYXRpb25zLmpzICovXG5cdHZhciBhbmltYXRpb25zID0gZnVuY3Rpb24oIHJBRiwgZ2V0VGltZSwgcnVubG9vcCApIHtcblxuXHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdHZhciBhbmltYXRpb25zID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhbmltYXRpb24sIG5vdztcblx0XHRcdFx0bm93ID0gZ2V0VGltZSgpO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gcXVldWVbIGkgXTtcblx0XHRcdFx0XHRpZiAoICFhbmltYXRpb24udGljayggbm93ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBhbmltYXRpb24gaXMgY29tcGxldGUsIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgYW5kIGRlY3JlbWVudCBpIHNvIHdlIGRvbid0IG1pc3Mgb25lXG5cdFx0XHRcdFx0XHRxdWV1ZS5zcGxpY2UoIGktLSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRpZiAoIHF1ZXVlLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyQUYoIGFuaW1hdGlvbnMudGljayApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xuXHRcdFx0XHRxdWV1ZS5wdXNoKCBhbmltYXRpb24gKTtcblx0XHRcdFx0aWYgKCAhYW5pbWF0aW9ucy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IHRydWU7XG5cdFx0XHRcdFx0ckFGKCBhbmltYXRpb25zLnRpY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gb3B0aW1pc2UgdGhpc1xuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBrZXlwYXRoLCByb290ICkge1xuXHRcdFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdFx0XHRhbmltYXRpb247XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBhbmltYXRpb24ucm9vdCA9PT0gcm9vdCAmJiBhbmltYXRpb24ua2V5cGF0aCA9PT0ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fSggcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBnZXRUaW1lLCBydW5sb29wICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvY3NzL3RyYW5zZm9ybS5qcyAqL1xuXHR2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHNlbGVjdG9yc1BhdHRlcm4gPSAvKD86XnxcXH0pP1xccyooW15cXHtcXH1dKylcXHMqXFx7L2csXG5cdFx0XHRjb21tZW50c1BhdHRlcm4gPSAvXFwvXFwqLio/XFwqXFwvL2csXG5cdFx0XHRzZWxlY3RvclVuaXRQYXR0ZXJuID0gLygoPzooPzpcXFtbXlxcXStdXFxdKXwoPzpbXlxcc1xcK1xcPlxcfjpdKSkrKSgoPzo6W15cXHNcXCtcXD5cXH5dKyk/XFxzKltcXHNcXCtcXD5cXH5dPylcXHMqL2csXG5cdFx0XHRtZWRpYVF1ZXJ5UGF0dGVybiA9IC9eQG1lZGlhLyxcblx0XHRcdGRhdGFSdmNHdWlkUGF0dGVybiA9IC9cXFtkYXRhLXJ2Y2d1aWQ9XCJbYS16MC05LV0rXCJdL2c7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3MoIGNzcywgZ3VpZCApIHtcblx0XHRcdHZhciB0cmFuc2Zvcm1lZCwgYWRkR3VpZDtcblx0XHRcdGFkZEd1aWQgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHZhciBzZWxlY3RvclVuaXRzLCBtYXRjaCwgdW5pdCwgZGF0YUF0dHIsIGJhc2UsIHByZXBlbmRlZCwgYXBwZW5kZWQsIGksIHRyYW5zZm9ybWVkID0gW107XG5cdFx0XHRcdHNlbGVjdG9yVW5pdHMgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRzZWxlY3RvclVuaXRzLnB1c2goIHtcblx0XHRcdFx0XHRcdHN0cjogbWF0Y2hbIDAgXSxcblx0XHRcdFx0XHRcdGJhc2U6IG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRtb2RpZmllcnM6IG1hdGNoWyAyIF1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRm9yIGVhY2ggc2ltcGxlIHNlbGVjdG9yIHdpdGhpbiB0aGUgc2VsZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdmVyc2lvblxuXHRcdFx0XHQvLyB0aGF0IGEpIGNvbWJpbmVzIHdpdGggdGhlIGd1aWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGd1aWRcblx0XHRcdFx0ZGF0YUF0dHIgPSAnW2RhdGEtcnZjZ3VpZD1cIicgKyBndWlkICsgJ1wiXSc7XG5cdFx0XHRcdGJhc2UgPSBzZWxlY3RvclVuaXRzLm1hcCggZXh0cmFjdFN0cmluZyApO1xuXHRcdFx0XHRpID0gc2VsZWN0b3JVbml0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFwcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXHRcdFx0XHRcdC8vIFBzZXVkby1zZWxlY3RvcnMgc2hvdWxkIGdvIGFmdGVyIHRoZSBhdHRyaWJ1dGUgc2VsZWN0b3Jcblx0XHRcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1sgaSBdO1xuXHRcdFx0XHRcdGFwcGVuZGVkWyBpIF0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8ICcnO1xuXHRcdFx0XHRcdHByZXBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcblx0XHRcdFx0XHRwcmVwZW5kZWRbIGkgXSA9IGRhdGFBdHRyICsgJyAnICsgcHJlcGVuZGVkWyBpIF07XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQucHVzaCggYXBwZW5kZWQuam9pbiggJyAnICksIHByZXBlbmRlZC5qb2luKCAnICcgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKCAnLCAnICk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBkYXRhUnZjR3VpZFBhdHRlcm4udGVzdCggY3NzICkgKSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoIGRhdGFSdmNHdWlkUGF0dGVybiwgJ1tkYXRhLXJ2Y2d1aWQ9XCInICsgZ3VpZCArICdcIl0nICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKCBjb21tZW50c1BhdHRlcm4sICcnICkucmVwbGFjZSggc2VsZWN0b3JzUGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0b3JzLCB0cmFuc2Zvcm1lZDtcblx0XHRcdFx0XHQvLyBkb24ndCB0cmFuc2Zvcm0gbWVkaWEgcXVlcmllcyFcblx0XHRcdFx0XHRpZiAoIG1lZGlhUXVlcnlQYXR0ZXJuLnRlc3QoICQxICkgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHRcdHNlbGVjdG9ycyA9ICQxLnNwbGl0KCAnLCcgKS5tYXAoIHRyaW0gKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoIGFkZEd1aWQgKS5qb2luKCAnLCAnICkgKyAnICc7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoICQxLCB0cmFuc2Zvcm1lZCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtZWQ7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyaW0oIHN0ciApIHtcblx0XHRcdGlmICggc3RyLnRyaW0gKSB7XG5cdFx0XHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXlxccysvLCAnJyApLnJlcGxhY2UoIC9cXHMrJC8sICcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFN0cmluZyggdW5pdCApIHtcblx0XHRcdHJldHVybiB1bml0LnN0cjtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvY3NzL2Nzcy5qcyAqL1xuXHR2YXIgY3NzID0gZnVuY3Rpb24oIHRyYW5zZm9ybUNzcyApIHtcblxuXHRcdHZhciBjc3NDb25maWcgPSB7XG5cdFx0XHRuYW1lOiAnY3NzJyxcblx0XHRcdGV4dGVuZDogZXh0ZW5kLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZ3VpZCA9IHByb3RvLmNvbnN0cnVjdG9yLl9ndWlkLFxuXHRcdFx0XHRjc3M7XG5cdFx0XHRpZiAoIGNzcyA9IGdldENzcyggb3B0aW9ucy5jc3MsIG9wdGlvbnMsIGd1aWQgKSB8fCBnZXRDc3MoIFBhcmVudC5jc3MsIFBhcmVudCwgZ3VpZCApICkge1xuXHRcdFx0XHRwcm90by5jb25zdHJ1Y3Rvci5jc3MgPSBjc3M7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3NzKCBjc3MsIHRhcmdldCwgZ3VpZCApIHtcblx0XHRcdGlmICggIWNzcyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRhcmdldC5ub0Nzc1RyYW5zZm9ybSA/IGNzcyA6IHRyYW5zZm9ybUNzcyggY3NzLCBndWlkICk7XG5cdFx0fVxuXHRcdHJldHVybiBjc3NDb25maWc7XG5cdH0oIHRyYW5zZm9ybSApO1xuXG5cdC8qIHV0aWxzL3dyYXBNZXRob2QuanMgKi9cblx0dmFyIHdyYXBNZXRob2QgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSApIHtcblx0XHRcdGlmICggZm9yY2UgfHwgbmVlZHNTdXBlciggbWV0aG9kLCBzdXBlck1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGhhc1N1cGVyID0gJ19zdXBlcicgaW4gdGhpcyxcblx0XHRcdFx0XHRcdF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRpZiAoIGhhc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiAvX3N1cGVyLy50ZXN0KCBtZXRob2QgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZGF0YS5qcyAqL1xuXHR2YXIgZGF0YSA9IGZ1bmN0aW9uKCB3cmFwICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBkYXRhQ29uZmlnID0ge1xuXHRcdFx0bmFtZTogJ2RhdGEnLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmVzZXQ6IHJlc2V0XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IGRhdGFDb25maWc7XG5cblx0XHRmdW5jdGlvbiBjb21iaW5lKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSB8fCB7fSxcblx0XHRcdFx0cGFyZW50VmFsdWUgPSBnZXRBZGRlZEtleXMoIFBhcmVudC5wcm90b3R5cGUuZGF0YSApO1xuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2RhdGEgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIFwiJyArIHZhbHVlICsgJ1wiIGlzIG5vdCB2YWxpZCcgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkaXNwYXRjaCggcGFyZW50VmFsdWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0cHJvdG8uZGF0YSA9IGNvbWJpbmUoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbml0KCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zLmRhdGEsXG5cdFx0XHRcdHJlc3VsdCA9IGNvbWJpbmUoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0aWYgKCB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQuY2FsbCggcmFjdGl2ZSwgdmFsdWUgKSB8fCB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByYWN0aXZlLmRhdGEgPSByZXN1bHQgfHwge307XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzZXQoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5pbml0KCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCByYWN0aXZlICk7XG5cdFx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdFx0cmFjdGl2ZS5kYXRhID0gcmVzdWx0O1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBZGRlZEtleXMoIHBhcmVudCApIHtcblx0XHRcdC8vIG9ubHkgZm9yIGZ1bmN0aW9ucyB0aGF0IGhhZCBrZXlzIGFkZGVkXG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJlbnQgIT09ICdmdW5jdGlvbicgfHwgIU9iamVjdC5rZXlzKCBwYXJlbnQgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBjb3B5IHRoZSBhZGRlZCBrZXlzIHRvIHRlbXAgJ29iamVjdCcsIG90aGVyd2lzZVxuXHRcdFx0Ly8gcGFyZW50IHdvdWxkIGJlIGludGVycHJldGVkIGFzICdmdW5jdGlvbicgYnkgZGlzcGF0Y2hcblx0XHRcdHZhciB0ZW1wID0ge307XG5cdFx0XHRjb3B5KCBwYXJlbnQsIHRlbXAgKTtcblx0XHRcdC8vIHJvbGwgaW4gYWRkZWQga2V5c1xuXHRcdFx0cmV0dXJuIGRpc3BhdGNoKCBwYXJlbnQsIHRlbXAgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkaXNwYXRjaCggcGFyZW50LCBjaGlsZCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gZXh0ZW5kRm4oIGNoaWxkLCBwYXJlbnQgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJlbnQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBmcm9tRm4oIGNoaWxkLCBwYXJlbnQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBmcm9tUHJvcGVydGllcyggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcHkoIGZyb20sIHRvLCBmaWxsT25seSApIHtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gZnJvbSApIHtcblx0XHRcdFx0aWYgKCBmaWxsT25seSAmJiBrZXkgaW4gdG8gKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG9bIGtleSBdID0gZnJvbVsga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZnJvbVByb3BlcnRpZXMoIGNoaWxkLCBwYXJlbnQgKSB7XG5cdFx0XHRjaGlsZCA9IGNoaWxkIHx8IHt9O1xuXHRcdFx0aWYgKCAhcGFyZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRjb3B5KCBwYXJlbnQsIGNoaWxkLCB0cnVlICk7XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZnJvbUZuKCBjaGlsZCwgcGFyZW50Rm4gKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdHZhciBrZXlzO1xuXHRcdFx0XHRpZiAoIGNoaWxkICkge1xuXHRcdFx0XHRcdC8vIFRyYWNrIHRoZSBrZXlzIHRoYXQgb3VyIG9uIHRoZSBjaGlsZCxcblx0XHRcdFx0XHQvLyBidXQgbm90IG9uIHRoZSBkYXRhLiBXZSdsbCBuZWVkIHRvIGFwcGx5IHRoZXNlXG5cdFx0XHRcdFx0Ly8gYWZ0ZXIgdGhlIHBhcmVudCBmdW5jdGlvbiByZXR1cm5zLlxuXHRcdFx0XHRcdGtleXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIGNoaWxkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZGF0YSB8fCAhKCBrZXkgaW4gZGF0YSApICkge1xuXHRcdFx0XHRcdFx0XHRrZXlzLnB1c2goIGtleSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjYWxsIHRoZSBwYXJlbnQgZm4sIHVzZSBkYXRhIGlmIG5vIHJldHVybiB2YWx1ZVxuXHRcdFx0XHRkYXRhID0gcGFyZW50Rm4uY2FsbCggdGhpcywgZGF0YSApIHx8IGRhdGE7XG5cdFx0XHRcdC8vIENvcHkgY2hpbGQga2V5cyBiYWNrIG9udG8gZGF0YS4gVGhlIGNoaWxkIGtleXNcblx0XHRcdFx0Ly8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHdoYXRldmVyIHRoZVxuXHRcdFx0XHQvLyBwYXJlbnQgZGlkIHdpdGggdGhlIGRhdGEuXG5cdFx0XHRcdGlmICgga2V5cyAmJiBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRcdFx0XHRrZXlzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0XHRkYXRhWyBrZXkgXSA9IGNoaWxkWyBrZXkgXTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZEZuKCBjaGlsZEZuLCBwYXJlbnQgKSB7XG5cdFx0XHR2YXIgcGFyZW50Rm47XG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJlbnQgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdC8vIGNvcHkgcHJvcHMgdG8gZGF0YVxuXHRcdFx0XHRwYXJlbnRGbiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdGZyb21Qcm9wZXJ0aWVzKCBkYXRhLCBwYXJlbnQgKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcmVudEZuID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdFx0Ly8gZ2l2ZSBwYXJlbnQgZnVuY3Rpb24gaXQncyBvd24gdGhpcy5fc3VwZXIgY29udGV4dCxcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UgdGhpcy5fc3VwZXIgaXMgZnJvbSBjaGlsZCBhbmRcblx0XHRcdFx0XHQvLyBjYXVzZXMgaW5maW5pdGUgbG9vcFxuXHRcdFx0XHRcdHBhcmVudCA9IHdyYXAoIHBhcmVudCwgZnVuY3Rpb24oKSB7fSwgdHJ1ZSApO1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnQuY2FsbCggdGhpcywgZGF0YSApIHx8IGRhdGE7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gd3JhcCggY2hpbGRGbiwgcGFyZW50Rm4gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB3cmFwTWV0aG9kICk7XG5cblx0LyogY29uZmlnL3R5cGVzLmpzICovXG5cdHZhciB0eXBlcyA9IHtcblx0XHRURVhUOiAxLFxuXHRcdElOVEVSUE9MQVRPUjogMixcblx0XHRUUklQTEU6IDMsXG5cdFx0U0VDVElPTjogNCxcblx0XHRJTlZFUlRFRDogNSxcblx0XHRDTE9TSU5HOiA2LFxuXHRcdEVMRU1FTlQ6IDcsXG5cdFx0UEFSVElBTDogOCxcblx0XHRDT01NRU5UOiA5LFxuXHRcdERFTElNQ0hBTkdFOiAxMCxcblx0XHRNVVNUQUNIRTogMTEsXG5cdFx0VEFHOiAxMixcblx0XHRBVFRSSUJVVEU6IDEzLFxuXHRcdENMT1NJTkdfVEFHOiAxNCxcblx0XHRDT01QT05FTlQ6IDE1LFxuXHRcdE5VTUJFUl9MSVRFUkFMOiAyMCxcblx0XHRTVFJJTkdfTElURVJBTDogMjEsXG5cdFx0QVJSQVlfTElURVJBTDogMjIsXG5cdFx0T0JKRUNUX0xJVEVSQUw6IDIzLFxuXHRcdEJPT0xFQU5fTElURVJBTDogMjQsXG5cdFx0R0xPQkFMOiAyNixcblx0XHRLRVlfVkFMVUVfUEFJUjogMjcsXG5cdFx0UkVGRVJFTkNFOiAzMCxcblx0XHRSRUZJTkVNRU5UOiAzMSxcblx0XHRNRU1CRVI6IDMyLFxuXHRcdFBSRUZJWF9PUEVSQVRPUjogMzMsXG5cdFx0QlJBQ0tFVEVEOiAzNCxcblx0XHRDT05ESVRJT05BTDogMzUsXG5cdFx0SU5GSVhfT1BFUkFUT1I6IDM2LFxuXHRcdElOVk9DQVRJT046IDQwLFxuXHRcdFNFQ1RJT05fSUY6IDUwLFxuXHRcdFNFQ1RJT05fVU5MRVNTOiA1MSxcblx0XHRTRUNUSU9OX0VBQ0g6IDUyLFxuXHRcdFNFQ1RJT05fV0lUSDogNTMsXG5cdFx0U0VDVElPTl9JRl9XSVRIOiA1NFxuXHR9O1xuXG5cdC8qIHV0aWxzL2NyZWF0ZS5qcyAqL1xuXHR2YXIgY3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgY3JlYXRlO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHQvLyBzaWdoXG5cdFx0XHRjcmVhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHByb3RvLCBwcm9wcyApIHtcblx0XHRcdFx0XHR2YXIgb2JqO1xuXHRcdFx0XHRcdGlmICggcHJvdG8gPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRcdFx0b2JqID0gbmV3IEYoKTtcblx0XHRcdFx0XHRpZiAoIHByb3BzICkge1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG9iaiwgcHJvcHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fTtcblx0XHRcdH0oKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvZXJyb3JzLmpzICovXG5cdHZhciBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyA9IHtcblx0XHRleHBlY3RlZEV4cHJlc3Npb246ICdFeHBlY3RlZCBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbicsXG5cdFx0ZXhwZWN0ZWRQYXJlbjogJ0V4cGVjdGVkIGNsb3NpbmcgcGFyZW4nXG5cdH07XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9udW1iZXJMaXRlcmFsLmpzICovXG5cdHZhciBudW1iZXJMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIG51bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdGlmICggcmVzdWx0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbnVtYmVyUGF0dGVybiApICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLk5VTUJFUl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL2Jvb2xlYW5MaXRlcmFsLmpzICovXG5cdHZhciBib29sZWFuTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgNCApID09PSAndHJ1ZScgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5CT09MRUFOX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogJ3RydWUnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlbWFpbmluZy5zdWJzdHIoIDAsIDUgKSA9PT0gJ2ZhbHNlJyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyArPSA1O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkJPT0xFQU5fTElURVJBTCxcblx0XHRcdFx0XHR2OiAnZmFsc2UnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9tYWtlUXVvdGVkU3RyaW5nTWF0Y2hlci5qcyAqL1xuXHR2YXIgbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzdHJpbmdNaWRkbGVQYXR0ZXJuLCBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4sIGxpbmVDb250aW51YXRpb25QYXR0ZXJuO1xuXHRcdC8vIE1hdGNoIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMgdW50aWw6IFwiLCAnLCBcXCwgb3IgRU9ML0VPRi5cblx0XHQvLyBFT0wvRU9GIGlzIHdyaXR0ZW4gYXMgKD8hLikgKG1lYW5pbmcgdGhlcmUncyBubyBub24tbmV3bGluZSBjaGFyIG5leHQpLlxuXHRcdHN0cmluZ01pZGRsZVBhdHRlcm4gPSAvXig/PS4pW15cIidcXFxcXSs/KD86KD8hLil8KD89W1wiJ1xcXFxdKSkvO1xuXHRcdC8vIE1hdGNoIG9uZSBlc2NhcGUgc2VxdWVuY2UsIGluY2x1ZGluZyB0aGUgYmFja3NsYXNoLlxuXHRcdGVzY2FwZVNlcXVlbmNlUGF0dGVybiA9IC9eXFxcXCg/OlsnXCJcXFxcYmZucnRdfDAoPyFbMC05XSl8eFswLTlhLWZBLUZdezJ9fHVbMC05YS1mQS1GXXs0fXwoPz0uKVtedXgwLTldKS87XG5cdFx0Ly8gTWF0Y2ggb25lIEVTNSBsaW5lIGNvbnRpbnVhdGlvbiAoYmFja3NsYXNoICsgbGluZSB0ZXJtaW5hdG9yKS5cblx0XHRsaW5lQ29udGludWF0aW9uUGF0dGVybiA9IC9eXFxcXCg/OlxcclxcbnxbXFx1MDAwQVxcdTAwMERcXHUyMDI4XFx1MjAyOV0pLztcblx0XHQvLyBIZWxwZXIgZm9yIGRlZmluaW5nIGdldERvdWJsZVF1b3RlZFN0cmluZyBhbmQgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLlxuXHRcdHJldHVybiBmdW5jdGlvbiggb2tRdW90ZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgc3RhcnQsIGxpdGVyYWwsIGRvbmUsIG5leHQ7XG5cdFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdFx0bGl0ZXJhbCA9ICdcIic7XG5cdFx0XHRcdGRvbmUgPSBmYWxzZTtcblx0XHRcdFx0d2hpbGUgKCAhZG9uZSApIHtcblx0XHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggc3RyaW5nTWlkZGxlUGF0dGVybiApIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oIGVzY2FwZVNlcXVlbmNlUGF0dGVybiApIHx8IHBhcnNlci5tYXRjaFN0cmluZyggb2tRdW90ZSApO1xuXHRcdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRcdGlmICggbmV4dCA9PT0gJ1wiJyApIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFxcXFwiJztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09ICdcXFxcXFwnJyApIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFwnJztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGxpbmVDb250aW51YXRpb25QYXR0ZXJuICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5leHQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnZlcnQgXFwobmV3bGluZS1saWtlKSBpbnRvIGEgXFx1IGVzY2FwZSwgd2hpY2ggaXMgYWxsb3dlZCBpbiBKU09OXG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gJ1xcXFx1JyArICggJzAwMCcgKyBuZXh0LmNoYXJDb2RlQXQoIDEgKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtNCApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxpdGVyYWwgKz0gJ1wiJztcblx0XHRcdFx0Ly8gdXNlIEpTT04ucGFyc2UgdG8gaW50ZXJwcmV0IGVzY2FwZXNcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoIGxpdGVyYWwgKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9zaW5nbGVRdW90ZWRTdHJpbmcuanMgKi9cblx0dmFyIHNpbmdsZVF1b3RlZFN0cmluZyA9IGZ1bmN0aW9uKCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApIHtcblxuXHRcdHJldHVybiBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciggJ1wiJyApO1xuXHR9KCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9kb3VibGVRdW90ZWRTdHJpbmcuanMgKi9cblx0dmFyIGRvdWJsZVF1b3RlZFN0cmluZyA9IGZ1bmN0aW9uKCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApIHtcblxuXHRcdHJldHVybiBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciggJ1xcJycgKTtcblx0fSggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvX3N0cmluZ0xpdGVyYWwuanMgKi9cblx0dmFyIHN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldFNpbmdsZVF1b3RlZFN0cmluZywgZ2V0RG91YmxlUXVvdGVkU3RyaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHN0cmluZztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXCInICkgKSB7XG5cdFx0XHRcdHN0cmluZyA9IGdldERvdWJsZVF1b3RlZFN0cmluZyggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1wiJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlNUUklOR19MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHN0cmluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdcXCcnICkgKSB7XG5cdFx0XHRcdHN0cmluZyA9IGdldFNpbmdsZVF1b3RlZFN0cmluZyggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1xcJycgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5TVFJJTkdfTElURVJBTCxcblx0XHRcdFx0XHR2OiBzdHJpbmdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBzaW5nbGVRdW90ZWRTdHJpbmcsIGRvdWJsZVF1b3RlZFN0cmluZyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvcGF0dGVybnMuanMgKi9cblx0dmFyIHBhdHRlcm5zID0ge1xuXHRcdG5hbWU6IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qL1xuXHR9O1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQva2V5LmpzICovXG5cdHZhciBrZXkgPSBmdW5jdGlvbiggZ2V0U3RyaW5nTGl0ZXJhbCwgZ2V0TnVtYmVyTGl0ZXJhbCwgcGF0dGVybnMgKSB7XG5cblx0XHR2YXIgaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG5cdFx0Ly8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1wcm9wZXJ0aWVzXG5cdFx0Ly8gY2FuIGJlIGFueSBuYW1lLCBzdHJpbmcgbGl0ZXJhbCwgb3IgbnVtYmVyIGxpdGVyYWxcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciB0b2tlbjtcblx0XHRcdGlmICggdG9rZW4gPSBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGlkZW50aWZpZXIudGVzdCggdG9rZW4udiApID8gdG9rZW4udiA6ICdcIicgKyB0b2tlbi52LnJlcGxhY2UoIC9cIi9nLCAnXFxcXFwiJyApICsgJ1wiJztcblx0XHRcdH1cblx0XHRcdGlmICggdG9rZW4gPSBnZXROdW1iZXJMaXRlcmFsKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRva2VuLnY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRva2VuID0gcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggc3RyaW5nTGl0ZXJhbCwgbnVtYmVyTGl0ZXJhbCwgcGF0dGVybnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwva2V5VmFsdWVQYWlyLmpzICovXG5cdHZhciBrZXlWYWx1ZVBhaXIgPSBmdW5jdGlvbiggdHlwZXMsIGdldEtleSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBrZXksIHZhbHVlO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICd7JyBhbmQga2V5XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRrZXkgPSBnZXRLZXkoIHBhcnNlciApO1xuXHRcdFx0aWYgKCBrZXkgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4ga2V5IGFuZCAnOidcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgJzonXG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc6JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICc6JyBhbmQgdmFsdWVcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIG5leHQgZXhwcmVzc2lvbiBtdXN0IGJlIGEsIHdlbGwuLi4gZXhwcmVzc2lvblxuXHRcdFx0dmFsdWUgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5LRVlfVkFMVUVfUEFJUixcblx0XHRcdFx0azoga2V5LFxuXHRcdFx0XHR2OiB2YWx1ZVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywga2V5ICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9vYmplY3RMaXRlcmFsL2tleVZhbHVlUGFpcnMuanMgKi9cblx0dmFyIGtleVZhbHVlUGFpcnMgPSBmdW5jdGlvbiggZ2V0S2V5VmFsdWVQYWlyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpcnMoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgcGFpcnMsIHBhaXIsIGtleVZhbHVlUGFpcnM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKTtcblx0XHRcdGlmICggcGFpciA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlycyA9IFsgcGFpciBdO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRrZXlWYWx1ZVBhaXJzID0gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIWtleVZhbHVlUGFpcnMgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYWlycy5jb25jYXQoIGtleVZhbHVlUGFpcnMgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYWlycztcblx0XHR9O1xuXHR9KCBrZXlWYWx1ZVBhaXIgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwvX29iamVjdExpdGVyYWwuanMgKi9cblx0dmFyIG9iamVjdExpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldEtleVZhbHVlUGFpcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwga2V5VmFsdWVQYWlycztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2Vcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ3snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRrZXlWYWx1ZVBhaXJzID0gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICk7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZmluYWwgdmFsdWUgYW5kICd9J1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnfScgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLk9CSkVDVF9MSVRFUkFMLFxuXHRcdFx0XHRtOiBrZXlWYWx1ZVBhaXJzXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBrZXlWYWx1ZVBhaXJzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9leHByZXNzaW9uTGlzdC5qcyAqL1xuXHR2YXIgZXhwcmVzc2lvbkxpc3QgPSBmdW5jdGlvbiggZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHJlc3Npb25zLCBleHByLCBuZXh0O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0ZXhwciA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCBleHByID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGV4cHJlc3Npb25zID0gWyBleHByIF07XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZXhwcmVzc2lvbiBhbmQgJywnXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdG5leHQgPSBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggbmV4dCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0LmZvckVhY2goIGFwcGVuZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhcHBlbmQoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdGV4cHJlc3Npb25zLnB1c2goIGV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBleHByZXNzaW9ucztcblx0XHR9O1xuXHR9KCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvYXJyYXlMaXRlcmFsLmpzICovXG5cdHZhciBhcnJheUxpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldEV4cHJlc3Npb25MaXN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHJlc3Npb25MaXN0O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgJ1snXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdbJyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZXhwcmVzc2lvbkxpc3QgPSBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuQVJSQVlfTElURVJBTCxcblx0XHRcdFx0bTogZXhwcmVzc2lvbkxpc3Rcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGV4cHJlc3Npb25MaXN0ICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9fbGl0ZXJhbC5qcyAqL1xuXHR2YXIgbGl0ZXJhbCA9IGZ1bmN0aW9uKCBnZXROdW1iZXJMaXRlcmFsLCBnZXRCb29sZWFuTGl0ZXJhbCwgZ2V0U3RyaW5nTGl0ZXJhbCwgZ2V0T2JqZWN0TGl0ZXJhbCwgZ2V0QXJyYXlMaXRlcmFsICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGdldE51bWJlckxpdGVyYWwoIHBhcnNlciApIHx8IGdldEJvb2xlYW5MaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRPYmplY3RMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRBcnJheUxpdGVyYWwoIHBhcnNlciApO1xuXHRcdFx0cmV0dXJuIGxpdGVyYWw7XG5cdFx0fTtcblx0fSggbnVtYmVyTGl0ZXJhbCwgYm9vbGVhbkxpdGVyYWwsIHN0cmluZ0xpdGVyYWwsIG9iamVjdExpdGVyYWwsIGFycmF5TGl0ZXJhbCApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L3JlZmVyZW5jZS5qcyAqL1xuXHR2YXIgcmVmZXJlbmNlID0gZnVuY3Rpb24oIHR5cGVzLCBwYXR0ZXJucyApIHtcblxuXHRcdHZhciBkb3RSZWZpbmVtZW50UGF0dGVybiwgYXJyYXlNZW1iZXJQYXR0ZXJuLCBnZXRBcnJheVJlZmluZW1lbnQsIGdsb2JhbHMsIGtleXdvcmRzO1xuXHRcdGRvdFJlZmluZW1lbnRQYXR0ZXJuID0gL15cXC5bYS16QS1aXyQwLTldKy87XG5cdFx0Z2V0QXJyYXlSZWZpbmVtZW50ID0gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBudW0gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBhcnJheU1lbWJlclBhdHRlcm4gKTtcblx0XHRcdGlmICggbnVtICkge1xuXHRcdFx0XHRyZXR1cm4gJy4nICsgbnVtO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRhcnJheU1lbWJlclBhdHRlcm4gPSAvXlxcWygwfFsxLTldWzAtOV0qKVxcXS87XG5cdFx0Ly8gaWYgYSByZWZlcmVuY2UgaXMgYSBicm93c2VyIGdsb2JhbCwgd2UgZG9uJ3QgZGVmZXJlbmNlIGl0IGxhdGVyLCBzbyBpdCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuXHRcdGdsb2JhbHMgPSAvXig/OkFycmF5fGNvbnNvbGV8RGF0ZXxSZWdFeHB8ZGVjb2RlVVJJQ29tcG9uZW50fGRlY29kZVVSSXxlbmNvZGVVUklDb21wb25lbnR8ZW5jb2RlVVJJfGlzRmluaXRlfGlzTmFOfHBhcnNlRmxvYXR8cGFyc2VJbnR8SlNPTnxNYXRofE5hTnx1bmRlZmluZWR8bnVsbCkkLztcblx0XHQvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2Bcblx0XHRrZXl3b3JkcyA9IC9eKD86YnJlYWt8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRoKSQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0UG9zLCBhbmNlc3RvciwgbmFtZSwgZG90LCBjb21ibywgcmVmaW5lbWVudCwgbGFzdERvdEluZGV4O1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gd2UgbWlnaHQgaGF2ZSBhIHJvb3QtbGV2ZWwgcmVmZXJlbmNlXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ34vJyApICkge1xuXHRcdFx0XHRhbmNlc3RvciA9ICd+Lyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuY2VzdG9yIHJlZnMuLi5cblx0XHRcdFx0YW5jZXN0b3IgPSAnJztcblx0XHRcdFx0d2hpbGUgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuLi8nICkgKSB7XG5cdFx0XHRcdFx0YW5jZXN0b3IgKz0gJy4uLyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWFuY2VzdG9yICkge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuIGltcGxpY2l0IGl0ZXJhdG9yIG9yIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Vcblx0XHRcdFx0ZG90ID0gcGFyc2VyLm1hdGNoU3RyaW5nKCAnLi8nICkgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSB8fCAnJztcblx0XHRcdH1cblx0XHRcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCAvXkAoPzprZXlwYXRofGluZGV4fGtleSkvICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApIHx8ICcnO1xuXHRcdFx0Ly8gYnVnIG91dCBpZiBpdCdzIGEga2V5d29yZFxuXHRcdFx0aWYgKCBrZXl3b3Jkcy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgYnJvd3NlciBnbG9iYWwsIHN0b3AgaGVyZVxuXHRcdFx0aWYgKCAhYW5jZXN0b3IgJiYgIWRvdCAmJiBnbG9iYWxzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5HTE9CQUwsXG5cdFx0XHRcdFx0djogbmFtZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Y29tYm8gPSAoIGFuY2VzdG9yIHx8IGRvdCApICsgbmFtZTtcblx0XHRcdGlmICggIWNvbWJvICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHdoaWxlICggcmVmaW5lbWVudCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGRvdFJlZmluZW1lbnRQYXR0ZXJuICkgfHwgZ2V0QXJyYXlSZWZpbmVtZW50KCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Y29tYm8gKz0gcmVmaW5lbWVudDtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCBpbnZvY2F0aW9uIChhcyBvcHBvc2VkIHRvIGEgZnVuY3Rpb24pIHdlIG5lZWRcblx0XHRcdFx0Ly8gdG8gc3RyaXAgdGhlIG1ldGhvZCBuYW1lIGZyb20gdGhlIHJlZmVyZW5jZSBjb21ibywgZWxzZSB0aGUgY29udGV4dFxuXHRcdFx0XHQvLyB3aWxsIGJlIHdyb25nXG5cdFx0XHRcdGxhc3REb3RJbmRleCA9IGNvbWJvLmxhc3RJbmRleE9mKCAnLicgKTtcblx0XHRcdFx0aWYgKCBsYXN0RG90SW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdGNvbWJvID0gY29tYm8uc3Vic3RyKCAwLCBsYXN0RG90SW5kZXggKTtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBjb21iby5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5SRUZFUkVOQ0UsXG5cdFx0XHRcdG46IGNvbWJvLnJlcGxhY2UoIC9edGhpc1xcLi8sICcuLycgKS5yZXBsYWNlKCAvXnRoaXMkLywgJy4nIClcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvYnJhY2tldGVkRXhwcmVzc2lvbi5qcyAqL1xuXHR2YXIgYnJhY2tldGVkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHI7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggIWV4cHIgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKScgKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRQYXJlbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuQlJBQ0tFVEVELFxuXHRcdFx0XHR4OiBleHByXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L19wcmltYXJ5LmpzICovXG5cdHZhciBwcmltYXJ5ID0gZnVuY3Rpb24oIGdldExpdGVyYWwsIGdldFJlZmVyZW5jZSwgZ2V0QnJhY2tldGVkRXhwcmVzc2lvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0cmV0dXJuIGdldExpdGVyYWwoIHBhcnNlciApIHx8IGdldFJlZmVyZW5jZSggcGFyc2VyICkgfHwgZ2V0QnJhY2tldGVkRXhwcmVzc2lvbiggcGFyc2VyICk7XG5cdFx0fTtcblx0fSggbGl0ZXJhbCwgcmVmZXJlbmNlLCBicmFja2V0ZWRFeHByZXNzaW9uICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9yZWZpbmVtZW50LmpzICovXG5cdHZhciByZWZpbmVtZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMsIHBhdHRlcm5zICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFJlZmluZW1lbnQoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgbmFtZSwgZXhwcjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIFwiLlwiIG5hbWVcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSApIHtcblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRpZiAoIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLlJFRklORU1FTlQsXG5cdFx0XHRcdFx0XHRuOiBuYW1lXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWUnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBcIltcIiBleHByZXNzaW9uIFwiXVwiXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0ZXhwciA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRpZiAoICFleHByICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBcXCddXFwnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuUkVGSU5FTUVOVCxcblx0XHRcdFx0XHR4OiBleHByXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL21lbWJlck9ySW52b2NhdGlvbi5qcyAqL1xuXHR2YXIgbWVtYmVyT3JJbnZvY2F0aW9uID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRQcmltYXJ5LCBnZXRFeHByZXNzaW9uTGlzdCwgZ2V0UmVmaW5lbWVudCwgZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgY3VycmVudCwgZXhwcmVzc2lvbiwgcmVmaW5lbWVudCwgZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRleHByZXNzaW9uID0gZ2V0UHJpbWFyeSggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHdoaWxlICggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0Y3VycmVudCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudCA9IGdldFJlZmluZW1lbnQoIHBhcnNlciApICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5NRU1CRVIsXG5cdFx0XHRcdFx0XHR4OiBleHByZXNzaW9uLFxuXHRcdFx0XHRcdFx0cjogcmVmaW5lbWVudFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGV4cHJlc3Npb25MaXN0ID0gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApO1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcpJyApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRQYXJlbiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRleHByZXNzaW9uID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuSU5WT0NBVElPTixcblx0XHRcdFx0XHRcdHg6IGV4cHJlc3Npb25cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmICggZXhwcmVzc2lvbkxpc3QgKSB7XG5cdFx0XHRcdFx0XHRleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwcmltYXJ5LCBleHByZXNzaW9uTGlzdCwgcmVmaW5lbWVudCwgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvdHlwZW9mLmpzICovXG5cdHZhciBfdHlwZW9mID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMsIGdldE1lbWJlck9ySW52b2NhdGlvbiApIHtcblxuXHRcdHZhciBnZXRUeXBlb2YsIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXI7XG5cdFx0bWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uKCBzeW1ib2wsIGZhbGx0aHJvdWdoICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBleHByZXNzaW9uO1xuXHRcdFx0XHRpZiAoIGV4cHJlc3Npb24gPSBmYWxsdGhyb3VnaCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBzeW1ib2wgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGV4cHJlc3Npb24gPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHM6IHN5bWJvbCxcblx0XHRcdFx0XHRvOiBleHByZXNzaW9uLFxuXHRcdFx0XHRcdHQ6IHR5cGVzLlBSRUZJWF9PUEVSQVRPUlxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIGNyZWF0ZSBhbGwgcHJlZml4IHNlcXVlbmNlIG1hdGNoZXJzLCByZXR1cm4gZ2V0VHlwZW9mXG5cdFx0KCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpLCBsZW4sIG1hdGNoZXIsIHByZWZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cdFx0XHRwcmVmaXhPcGVyYXRvcnMgPSAnISB+ICsgLSB0eXBlb2YnLnNwbGl0KCAnICcgKTtcblx0XHRcdGZhbGx0aHJvdWdoID0gZ2V0TWVtYmVyT3JJbnZvY2F0aW9uO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbiA9IHByZWZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bWF0Y2hlciA9IG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIoIHByZWZpeE9wZXJhdG9yc1sgaSBdLCBmYWxsdGhyb3VnaCApO1xuXHRcdFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG5cdFx0XHR9XG5cdFx0XHQvLyB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvbiwgc28gcHJvdmlkZXMgdGhlXG5cdFx0XHQvLyBmYWxsdGhyb3VnaCBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIHNlcXVlbmNlIG1hdGNoZXIgd2UncmUgYWJvdXQgdG8gY3JlYXRlXG5cdFx0XHQvLyAod2UncmUgc2tpcHBpbmcgdm9pZCBhbmQgZGVsZXRlKVxuXHRcdFx0Z2V0VHlwZW9mID0gZmFsbHRocm91Z2g7XG5cdFx0fSgpICk7XG5cdFx0cmV0dXJuIGdldFR5cGVvZjtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzLCBtZW1iZXJPckludm9jYXRpb24gKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvbG9naWNhbE9yLmpzICovXG5cdHZhciBsb2dpY2FsT3IgPSBmdW5jdGlvbiggdHlwZXMsIGdldFR5cGVvZiApIHtcblxuXHRcdHZhciBnZXRMb2dpY2FsT3IsIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcjtcblx0XHRtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiggc3ltYm9sLCBmYWxsdGhyb3VnaCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgc3RhcnQsIGxlZnQsIHJpZ2h0O1xuXHRcdFx0XHRsZWZ0ID0gZmFsbHRocm91Z2goIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFsZWZ0ICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIExvb3AgdG8gaGFuZGxlIGxlZnQtcmVjdXJzaW9uIGluIGEgY2FzZSBsaWtlIGBhICogYiAqIGNgIGFuZCBwcm9kdWNlXG5cdFx0XHRcdC8vIGxlZnQgYXNzb2NpYXRpb24sIGkuZS4gYChhICogYikgKiBjYC4gIFRoZSBtYXRjaGVyIGNhbid0IGNhbGwgaXRzZWxmXG5cdFx0XHRcdC8vIHRvIHBhcnNlIGBsZWZ0YCBiZWNhdXNlIHRoYXQgd291bGQgYmUgaW5maW5pdGUgcmVncmVzcy5cblx0XHRcdFx0d2hpbGUgKCB0cnVlICkge1xuXHRcdFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBzeW1ib2wgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbiBvcGVyYXRvciBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBbYS16QS1aXyQwLTldXG5cdFx0XHRcdFx0aWYgKCBzeW1ib2wgPT09ICdpbicgJiYgL1thLXpBLVpfJDAtOV0vLnRlc3QoIHBhcnNlci5yZW1haW5pbmcoKS5jaGFyQXQoIDAgKSApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHQvLyByaWdodCBvcGVyYW5kIG11c3QgYWxzbyBjb25zaXN0IG9mIG9ubHkgaGlnaGVyLXByZWNlZGVuY2Ugb3BlcmF0b3JzXG5cdFx0XHRcdFx0cmlnaHQgPSBmYWxsdGhyb3VnaCggcGFyc2VyICk7XG5cdFx0XHRcdFx0aWYgKCAhcmlnaHQgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVmdCA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLklORklYX09QRVJBVE9SLFxuXHRcdFx0XHRcdFx0czogc3ltYm9sLFxuXHRcdFx0XHRcdFx0bzogW1xuXHRcdFx0XHRcdFx0XHRsZWZ0LFxuXHRcdFx0XHRcdFx0XHRyaWdodFxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIGdldExvZ2ljYWxPclxuXHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBpbmZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cdFx0XHQvLyBBbGwgdGhlIGluZml4IG9wZXJhdG9ycyBvbiBvcmRlciBvZiBwcmVjZWRlbmNlIChzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2UpXG5cdFx0XHQvLyBFYWNoIHNlcXVlbmNlIG1hdGNoZXIgd2lsbCBpbml0aWFsbHkgZmFsbCB0aHJvdWdoIHRvIGl0cyBoaWdoZXIgcHJlY2VkZW5jZVxuXHRcdFx0Ly8gbmVpZ2hib3VyLCBhbmQgb25seSBhdHRlbXB0IHRvIG1hdGNoIGlmIG9uZSBvZiB0aGUgaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzXG5cdFx0XHQvLyAob3IsIHVsdGltYXRlbHksIGEgbGl0ZXJhbCwgcmVmZXJlbmNlLCBvciBicmFja2V0ZWQgZXhwcmVzc2lvbikgYWxyZWFkeSBtYXRjaGVkXG5cdFx0XHRpbmZpeE9wZXJhdG9ycyA9ICcqIC8gJSArIC0gPDwgPj4gPj4+IDwgPD0gPiA+PSBpbiBpbnN0YW5jZW9mID09ICE9ID09PSAhPT0gJiBeIHwgJiYgfHwnLnNwbGl0KCAnICcgKTtcblx0XHRcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cblx0XHRcdGZhbGx0aHJvdWdoID0gZ2V0VHlwZW9mO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbiA9IGluZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRtYXRjaGVyID0gbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyKCBpbmZpeE9wZXJhdG9yc1sgaSBdLCBmYWxsdGhyb3VnaCApO1xuXHRcdFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG5cdFx0XHR9XG5cdFx0XHQvLyBMb2dpY2FsIE9SIGlzIHRoZSBmYWxsdGhyb3VnaCBmb3IgdGhlIGNvbmRpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGdldExvZ2ljYWxPciA9IGZhbGx0aHJvdWdoO1xuXHRcdH0oKSApO1xuXHRcdHJldHVybiBnZXRMb2dpY2FsT3I7XG5cdH0oIHR5cGVzLCBfdHlwZW9mICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL2NvbmRpdGlvbmFsLmpzICovXG5cdHZhciBjb25kaXRpb25hbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0TG9naWNhbE9yLCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaWZUcnVlLCBpZkZhbHNlO1xuXHRcdFx0ZXhwcmVzc2lvbiA9IGdldExvZ2ljYWxPciggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz8nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZlRydWUgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggIWlmVHJ1ZSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc6JyApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBcIjpcIicgKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmRmFsc2UgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggIWlmRmFsc2UgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuQ09ORElUSU9OQUwsXG5cdFx0XHRcdG86IFtcblx0XHRcdFx0XHRleHByZXNzaW9uLFxuXHRcdFx0XHRcdGlmVHJ1ZSxcblx0XHRcdFx0XHRpZkZhbHNlXG5cdFx0XHRcdF1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGxvZ2ljYWxPciwgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvdXRpbHMvZmxhdHRlbkV4cHJlc3Npb24uanMgKi9cblx0dmFyIGZsYXR0ZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oIHR5cGVzLCBpc09iamVjdCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIHJlZnMgPSBbXSxcblx0XHRcdFx0ZmxhdHRlbmVkO1xuXHRcdFx0ZXh0cmFjdFJlZnMoIGV4cHJlc3Npb24sIHJlZnMgKTtcblx0XHRcdGZsYXR0ZW5lZCA9IHtcblx0XHRcdFx0cjogcmVmcyxcblx0XHRcdFx0czogc3RyaW5naWZ5KCB0aGlzLCBleHByZXNzaW9uLCByZWZzIClcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZmxhdHRlbmVkO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBxdW90ZVN0cmluZ0xpdGVyYWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggU3RyaW5nKCBzdHIgKSApO1xuXHRcdH1cblx0XHQvLyBUT0RPIG1heWJlIHJlZmFjdG9yIHRoaXM/XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFJlZnMoIG5vZGUsIHJlZnMgKSB7XG5cdFx0XHR2YXIgaSwgbGlzdDtcblx0XHRcdGlmICggbm9kZS50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdGlmICggcmVmcy5pbmRleE9mKCBub2RlLm4gKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0cmVmcy51bnNoaWZ0KCBub2RlLm4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggaXNPYmplY3QoIGxpc3QgKSApIHtcblx0XHRcdFx0XHRleHRyYWN0UmVmcyggbGlzdCwgcmVmcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGV4dHJhY3RSZWZzKCBsaXN0WyBpIF0sIHJlZnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS54ICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS54LCByZWZzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUuciApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUuciwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnYgKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZSwgcmVmcyApIHtcblx0XHRcdHZhciBzdHJpbmdpZnlBbGwgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBpdGVtLCByZWZzICk7XG5cdFx0XHR9O1xuXHRcdFx0c3dpdGNoICggbm9kZS50ICkge1xuXHRcdFx0XHRjYXNlIHR5cGVzLkJPT0xFQU5fTElURVJBTDpcblx0XHRcdFx0Y2FzZSB0eXBlcy5HTE9CQUw6XG5cdFx0XHRcdGNhc2UgdHlwZXMuTlVNQkVSX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUudjtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TVFJJTkdfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gcXVvdGVTdHJpbmdMaXRlcmFsKCBub2RlLnYgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5BUlJBWV9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiAnWycgKyAoIG5vZGUubSA/IG5vZGUubS5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICddJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5PQkpFQ1RfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gJ3snICsgKCBub2RlLm0gPyBub2RlLm0ubWFwKCBzdHJpbmdpZnlBbGwgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnfSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuS0VZX1ZBTFVFX1BBSVI6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuayArICc6JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5QUkVGSVhfT1BFUkFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuICggbm9kZS5zID09PSAndHlwZW9mJyA/ICd0eXBlb2YgJyA6IG5vZGUucyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUubywgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLklORklYX09QRVJBVE9SOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAwIF0sIHJlZnMgKSArICggbm9kZS5zLnN1YnN0ciggMCwgMiApID09PSAnaW4nID8gJyAnICsgbm9kZS5zICsgJyAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAxIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlZPQ0FUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnKCcgKyAoIG5vZGUubyA/IG5vZGUuby5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5CUkFDS0VURUQ6XG5cdFx0XHRcdFx0cmV0dXJuICcoJyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5NRU1CRVI6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnIsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZJTkVNRU5UOlxuXHRcdFx0XHRcdHJldHVybiBub2RlLm4gPyAnLicgKyBub2RlLm4gOiAnWycgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnXSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQ09ORElUSU9OQUw6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDAgXSwgcmVmcyApICsgJz8nICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMSBdLCByZWZzICkgKyAnOicgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAyIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZFUkVOQ0U6XG5cdFx0XHRcdFx0cmV0dXJuICdfJyArIHJlZnMuaW5kZXhPZiggbm9kZS5uICk7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgbGVnYWwgSmF2YVNjcmlwdCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgaXNPYmplY3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvX1BhcnNlci5qcyAqL1xuXHR2YXIgUGFyc2VyID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093blByb3BlcnR5LCBnZXRDb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24gKSB7XG5cblx0XHR2YXIgUGFyc2VyLCBQYXJzZUVycm9yLCBsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG5cdFx0UGFyc2VFcnJvciA9IGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuXHRcdFx0dGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuXHRcdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFx0UGFyc2VyID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBpdGVtcywgaXRlbSwgbGluZVN0YXJ0ID0gMDtcblx0XHRcdHRoaXMuc3RyID0gc3RyO1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdHRoaXMucG9zID0gMDtcblx0XHRcdHRoaXMubGluZXMgPSB0aGlzLnN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdHRoaXMubGluZUVuZHMgPSB0aGlzLmxpbmVzLm1hcCggZnVuY3Rpb24oIGxpbmUgKSB7XG5cdFx0XHRcdHZhciBsaW5lRW5kID0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGggKyAxO1xuXHRcdFx0XHQvLyArMSBmb3IgdGhlIG5ld2xpbmVcblx0XHRcdFx0bGluZVN0YXJ0ID0gbGluZUVuZDtcblx0XHRcdFx0cmV0dXJuIGxpbmVFbmQ7XG5cdFx0XHR9LCAwICk7XG5cdFx0XHQvLyBDdXN0b20gaW5pdCBsb2dpY1xuXHRcdFx0aWYgKCB0aGlzLmluaXQgKVxuXHRcdFx0XHR0aGlzLmluaXQoIHN0ciwgb3B0aW9ucyApO1xuXHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdHdoaWxlICggdGhpcy5wb3MgPCB0aGlzLnN0ci5sZW5ndGggJiYgKCBpdGVtID0gdGhpcy5yZWFkKCkgKSApIHtcblx0XHRcdFx0aXRlbXMucHVzaCggaXRlbSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sZWZ0b3ZlciA9IHRoaXMucmVtYWluaW5nKCk7XG5cdFx0XHR0aGlzLnJlc3VsdCA9IHRoaXMucG9zdFByb2Nlc3MgPyB0aGlzLnBvc3RQcm9jZXNzKCBpdGVtcywgb3B0aW9ucyApIDogaXRlbXM7XG5cdFx0fTtcblx0XHRQYXJzZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmVhZDogZnVuY3Rpb24oIGNvbnZlcnRlcnMgKSB7XG5cdFx0XHRcdHZhciBwb3MsIGksIGxlbiwgaXRlbTtcblx0XHRcdFx0aWYgKCAhY29udmVydGVycyApXG5cdFx0XHRcdFx0Y29udmVydGVycyA9IHRoaXMuY29udmVydGVycztcblx0XHRcdFx0cG9zID0gdGhpcy5wb3M7XG5cdFx0XHRcdGxlbiA9IGNvbnZlcnRlcnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMucG9zID0gcG9zO1xuXHRcdFx0XHRcdC8vIHJlc2V0IGZvciBlYWNoIGF0dGVtcHRcblx0XHRcdFx0XHRpZiAoIGl0ZW0gPSBjb252ZXJ0ZXJzWyBpIF0oIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRyZWFkRXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IgKGV4Y2VwdCB5aWVsZCxcblx0XHRcdFx0Ly8gYXNzaWdubWVudCBvcGVyYXRvcnMsIGFuZCBjb21tYXMsIG5vbmUgb2Ygd2hpY2ggYXJlIHN1cHBvcnRlZCksIHNvIHdlXG5cdFx0XHRcdC8vIHN0YXJ0IHRoZXJlLiBJZiBpdCBkb2Vzbid0IG1hdGNoLCBpdCAnZmFsbHMgdGhyb3VnaCcgdG8gcHJvZ3Jlc3NpdmVseVxuXHRcdFx0XHQvLyBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnMsIHVudGlsIGl0IGV2ZW50dWFsbHkgbWF0Y2hlcyAob3IgZmFpbHMgdG9cblx0XHRcdFx0Ly8gbWF0Y2gpIGEgJ3ByaW1hcnknIC0gYSBsaXRlcmFsIG9yIGEgcmVmZXJlbmNlLiBUaGlzIHdheSwgdGhlIGFic3RyYWN0IHN5bnRheFxuXHRcdFx0XHQvLyB0cmVlIGhhcyBldmVyeXRoaW5nIGluIGl0cyBwcm9wZXIgcGxhY2UsIGkuZS4gMiArIDMgKiA0ID09PSAxNCwgbm90IDIwLlxuXHRcdFx0XHRyZXR1cm4gZ2V0Q29uZGl0aW9uYWwoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRmbGF0dGVuRXhwcmVzc2lvbjogZmxhdHRlbkV4cHJlc3Npb24sXG5cdFx0XHRnZXRMaW5lUG9zOiBmdW5jdGlvbiggY2hhciApIHtcblx0XHRcdFx0dmFyIGxpbmVOdW0gPSAwLFxuXHRcdFx0XHRcdGxpbmVTdGFydCA9IDAsXG5cdFx0XHRcdFx0Y29sdW1uTnVtO1xuXHRcdFx0XHR3aGlsZSAoIGNoYXIgPj0gdGhpcy5saW5lRW5kc1sgbGluZU51bSBdICkge1xuXHRcdFx0XHRcdGxpbmVTdGFydCA9IHRoaXMubGluZUVuZHNbIGxpbmVOdW0gXTtcblx0XHRcdFx0XHRsaW5lTnVtICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sdW1uTnVtID0gY2hhciAtIGxpbmVTdGFydDtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRsaW5lTnVtICsgMSxcblx0XHRcdFx0XHRjb2x1bW5OdW0gKyAxLFxuXHRcdFx0XHRcdGNoYXJcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG5cdFx0XHRcdHZhciBwb3MsIGxpbmVOdW0sIGNvbHVtbk51bSwgbGluZSwgYW5ub3RhdGlvbiwgZXJyb3I7XG5cdFx0XHRcdHBvcyA9IHRoaXMuZ2V0TGluZVBvcyggdGhpcy5wb3MgKTtcblx0XHRcdFx0bGluZU51bSA9IHBvc1sgMCBdO1xuXHRcdFx0XHRjb2x1bW5OdW0gPSBwb3NbIDEgXTtcblx0XHRcdFx0bGluZSA9IHRoaXMubGluZXNbIHBvc1sgMCBdIC0gMSBdO1xuXHRcdFx0XHRhbm5vdGF0aW9uID0gbGluZSArICdcXG4nICsgbmV3IEFycmF5KCBwb3NbIDEgXSApLmpvaW4oICcgJyApICsgJ14tLS0tJztcblx0XHRcdFx0ZXJyb3IgPSBuZXcgUGFyc2VFcnJvciggbWVzc2FnZSArICcgYXQgbGluZSAnICsgbGluZU51bSArICcgY2hhcmFjdGVyICcgKyBjb2x1bW5OdW0gKyAnOlxcbicgKyBhbm5vdGF0aW9uICk7XG5cdFx0XHRcdGVycm9yLmxpbmUgPSBwb3NbIDAgXTtcblx0XHRcdFx0ZXJyb3IuY2hhcmFjdGVyID0gcG9zWyAxIF07XG5cdFx0XHRcdGVycm9yLnNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSxcblx0XHRcdG1hdGNoU3RyaW5nOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RyLnN1YnN0ciggdGhpcy5wb3MsIHN0cmluZy5sZW5ndGggKSA9PT0gc3RyaW5nICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1hdGNoUGF0dGVybjogZnVuY3Rpb24oIHBhdHRlcm4gKSB7XG5cdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IHBhdHRlcm4uZXhlYyggdGhpcy5yZW1haW5pbmcoKSApICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWyAwIF0ubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaFsgMSBdIHx8IG1hdGNoWyAwIF07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhbGxvd1doaXRlc3BhY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1hdGNoUGF0dGVybiggbGVhZGluZ1doaXRlc3BhY2UgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1haW5pbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIuc3Vic3RyaW5nKCB0aGlzLnBvcyApO1xuXHRcdFx0fSxcblx0XHRcdG5leHRDaGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyLmNoYXJBdCggdGhpcy5wb3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiggcHJvdG8gKSB7XG5cdFx0XHR2YXIgUGFyZW50ID0gdGhpcyxcblx0XHRcdFx0Q2hpbGQsIGtleTtcblx0XHRcdENoaWxkID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0UGFyc2VyLmNhbGwoIHRoaXMsIHN0ciwgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0Zm9yICgga2V5IGluIHByb3RvICkge1xuXHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHByb3RvLCBrZXkgKSApIHtcblx0XHRcdFx0XHRDaGlsZC5wcm90b3R5cGVbIGtleSBdID0gcHJvdG9bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuXHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdH07XG5cdFx0Y2lyY3VsYXIuUGFyc2VyID0gUGFyc2VyO1xuXHRcdHJldHVybiBQYXJzZXI7XG5cdH0oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093biwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJDaGFuZ2UuanMgKi9cblx0dmFyIGRlbGltaXRlckNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcblx0XHRcdHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgb3BlbmluZywgY2xvc2luZztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgbmV3IG9wZW5pbmcgZGVsaW1pdGVyXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRvcGVuaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhb3BlbmluZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgKGluIGZhY3QsIGl0J3MgbmVjZXNzYXJ5Li4uKVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoUGF0dGVybiggd2hpdGVzcGFjZVBhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRjbG9zaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhY2xvc2luZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgJz0nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0b3BlbmluZyxcblx0XHRcdFx0Y2xvc2luZ1xuXHRcdFx0XTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJUeXBlcy5qcyAqL1xuXHR2YXIgZGVsaW1pdGVyVHlwZXMgPSBbIHtcblx0XHRkZWxpbWl0ZXJzOiAnZGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IGZhbHNlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY0RlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiBmYWxzZSxcblx0XHRpc1N0YXRpYzogdHJ1ZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY1RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiB0cnVlXG5cdH0gXTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL3R5cGUuanMgKi9cblx0dmFyIHR5cGUgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgbXVzdGFjaGVUeXBlcyA9IHtcblx0XHRcdCcjJzogdHlwZXMuU0VDVElPTixcblx0XHRcdCdeJzogdHlwZXMuSU5WRVJURUQsXG5cdFx0XHQnLyc6IHR5cGVzLkNMT1NJTkcsXG5cdFx0XHQnPic6IHR5cGVzLlBBUlRJQUwsXG5cdFx0XHQnISc6IHR5cGVzLkNPTU1FTlQsXG5cdFx0XHQnJic6IHR5cGVzLlRSSVBMRVxuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdHlwZSA9IG11c3RhY2hlVHlwZXNbIHBhcnNlci5zdHIuY2hhckF0KCBwYXJzZXIucG9zICkgXTtcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSAxO1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2hhbmRsZWJhcnNCbG9ja0NvZGVzLmpzICovXG5cdHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQnZWFjaCc6IHR5cGVzLlNFQ1RJT05fRUFDSCxcblx0XHRcdCdpZic6IHR5cGVzLlNFQ1RJT05fSUYsXG5cdFx0XHQnaWYtd2l0aCc6IHR5cGVzLlNFQ1RJT05fSUZfV0lUSCxcblx0XHRcdCd3aXRoJzogdHlwZXMuU0VDVElPTl9XSVRILFxuXHRcdFx0J3VubGVzcyc6IHR5cGVzLlNFQ1RJT05fVU5MRVNTXG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBlbXB0eS9sZWdhY3kuanMgKi9cblx0dmFyIGxlZ2FjeSA9IG51bGw7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9jb250ZW50LmpzICovXG5cdHZhciBjb250ZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBtdXN0YWNoZVR5cGUsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBpbmRleFJlZlBhdHRlcm4gPSAvXlxccyo6XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcblx0XHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eWzAtOV1bMS05XSokLyxcblx0XHRcdGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXignICsgT2JqZWN0LmtleXMoIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkuam9pbiggJ3wnICkgKyAnKVxcXFxiJyApLFxuXHRcdFx0bGVnYWxSZWZlcmVuY2U7XG5cdFx0bGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KFxcLlthLXpBLVokXzAtOV0rKXwoXFxbW2EtekEtWiRfMC05XStcXF0pKSokLztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBwYXJzZXIsIGRlbGltaXRlclR5cGUgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHBvcywgbXVzdGFjaGUsIHR5cGUsIGJsb2NrLCBleHByZXNzaW9uLCBpLCByZW1haW5pbmcsIGluZGV4LCBkZWxpbWl0ZXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0bXVzdGFjaGUgPSB7fTtcblx0XHRcdGRlbGltaXRlcnMgPSBwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdO1xuXHRcdFx0aWYgKCBkZWxpbWl0ZXJUeXBlLmlzU3RhdGljICkge1xuXHRcdFx0XHRtdXN0YWNoZS5zID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIERldGVybWluZSBtdXN0YWNoZSB0eXBlXG5cdFx0XHRpZiAoIGRlbGltaXRlclR5cGUuaXNUcmlwbGUgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5UUklQTEU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgZm9yIGV4cHJlc3Npb25zIGJlZm9yZSB3ZSB0ZXN0IGZvciBtdXN0YWNoZSB0eXBlLCBiZWNhdXNlXG5cdFx0XHRcdC8vIGFuIGV4cHJlc3Npb24gdGhhdCBiZWdpbnMgJyEnIGxvb2tzIGEgbG90IGxpa2UgYSBjb21tZW50XG5cdFx0XHRcdGlmICggcGFyc2VyLnJlbWFpbmluZygpWyAwIF0gPT09ICchJyApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRcdFx0Ly8gV2FzIGl0IGFjdHVhbGx5IGFuIGV4cHJlc3Npb24sIG9yIGEgY29tbWVudCBibG9jayBpbiBkaXNndWlzZT9cblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcdGlmICggcGFyc2VyLnJlbWFpbmluZygpLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRcdFx0XHRleHByZXNzaW9uID0gbnVsbDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHt9XG5cdFx0XHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gcGFyc2VyLnJlbWFpbmluZygpLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdFx0aWYgKCB+aW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAoXFwnJyArIGRlbGltaXRlcnNbIDEgXSArICdcXCcpJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dDogdHlwZXMuQ09NTUVOVFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0XHR0eXBlID0gbXVzdGFjaGVUeXBlKCBwYXJzZXIgKTtcblx0XHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZSB8fCB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRcdFx0Ly8gZGVmYXVsdFxuXHRcdFx0XHRcdC8vIFNlZSBpZiB0aGVyZSdzIGFuIGV4cGxpY2l0IHNlY3Rpb24gdHlwZSBlLmcuIHt7I3dpdGh9fS4uLnt7L3dpdGh9fVxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gdHlwZXMuU0VDVElPTiApIHtcblx0XHRcdFx0XHRcdGlmICggYmxvY2sgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBoYW5kbGViYXJzQmxvY2tQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLm4gPSBibG9jaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSB0eXBlcy5DT01NRU5UIHx8IHR5cGUgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBkZWxpbWl0ZXJzWyAxIF0gKTtcblx0XHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKS5zcGxpdCggJyAnIClbIDAgXTtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdC8vIGdldCBleHByZXNzaW9uXG5cdFx0XHRcdGV4cHJlc3Npb24gPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBhcnRpYWwsIGl0IG1heSBoYXZlIGEgY29udGV4dCAoZS5nLiBge3s+aXRlbSBmb299fWApLiBUaGVzZVxuXHRcdFx0XHQvLyBjYXNlcyBpbnZvbHZlIGEgYml0IG9mIGEgaGFjayAtIHdlIHdhbnQgdG8gdHVybiBpdCBpbnRvIHRoZSBlcXVpdmFsZW50IG9mXG5cdFx0XHRcdC8vIGB7eyN3aXRoIGZvb319e3s+aXRlbX19e3svd2l0aH19YCwgYnV0IHRvIGdldCB0aGVyZSB3ZSB0ZW1wb3JhcmlseSBhcHBlbmRcblx0XHRcdFx0Ly8gYSAnY29udGV4dFBhcnRpYWxFeHByZXNzaW9uJyB0byB0aGUgbXVzdGFjaGUsIGFuZCBwcm9jZXNzIHRoZSBjb250ZXh0IGluc3RlYWQgb2Zcblx0XHRcdFx0Ly8gdGhlIHJlZmVyZW5jZVxuXHRcdFx0XHR2YXIgdGVtcDtcblx0XHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5QQVJUSUFMICYmIGV4cHJlc3Npb24gJiYgKCB0ZW1wID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCkgKSApIHtcblx0XHRcdFx0XHRtdXN0YWNoZSA9IHtcblx0XHRcdFx0XHRcdGNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbjogZXhwcmVzc2lvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHRlbXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gV2l0aCBjZXJ0YWluIHZhbGlkIHJlZmVyZW5jZXMgdGhhdCBhcmVuJ3QgdmFsaWQgZXhwcmVzc2lvbnMsXG5cdFx0XHRcdC8vIGUuZy4ge3sxLmZvb319LCB3ZSBoYXZlIGEgcHJvYmxlbTogaXQgbG9va3MgbGlrZSB3ZSd2ZSBnb3QgYW5cblx0XHRcdFx0Ly8gZXhwcmVzc2lvbiwgYnV0IHRoZSBleHByZXNzaW9uIGRpZG4ndCBjb25zdW1lIHRoZSBlbnRpcmVcblx0XHRcdFx0Ly8gcmVmZXJlbmNlLiBTbyB3ZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlIG11c3RhY2hlIGRlbGltaXRlcnNcblx0XHRcdFx0Ly8gYXBwZWFyIG5leHQsIHVubGVzcyB0aGVyZSdzIGFuIGluZGV4IHJlZmVyZW5jZSAoaS5lLiBhIGNvbG9uKVxuXHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgZGVsaW1pdGVyc1sgMSBdLmxlbmd0aCApICE9PSBkZWxpbWl0ZXJzWyAxIF0gJiYgcmVtYWluaW5nLmNoYXJBdCggMCApICE9PSAnOicgKSB7XG5cdFx0XHRcdFx0cG9zID0gcGFyc2VyLnBvcztcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuciA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkudHJpbSgpO1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaXQncyBhIGxlZ2FsIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0aWYgKCAhbGVnYWxSZWZlcmVuY2UudGVzdCggbXVzdGFjaGUuciApICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBhIGxlZ2FsIE11c3RhY2hlIHJlZmVyZW5jZScgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlZmluZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiwgbXVzdGFjaGUgKTtcblx0XHRcdC8vIGlmIHRoZXJlIHdhcyBjb250ZXh0LCBwcm9jZXNzIHRoZSBleHByZXNzaW9uIG5vdyBhbmQgc2F2ZSBpdCBmb3IgbGF0ZXJcblx0XHRcdGlmICggbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uICkge1xuXHRcdFx0XHRtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24gPSBbIHJlZmluZUV4cHJlc3Npb24oIHBhcnNlciwgbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uLCB7XG5cdFx0XHRcdFx0dDogdHlwZXMuUEFSVElBTFxuXHRcdFx0XHR9ICkgXTtcblx0XHRcdH1cblx0XHRcdC8vIG9wdGlvbmFsIGluZGV4IHJlZmVyZW5jZVxuXHRcdFx0aWYgKCBpID0gcGFyc2VyLm1hdGNoUGF0dGVybiggaW5kZXhSZWZQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdG11c3RhY2hlLmkgPSBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWZpbmVFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24sIG11c3RhY2hlICkge1xuXHRcdFx0dmFyIHJlZmVyZW5jZUV4cHJlc3Npb247XG5cdFx0XHRpZiAoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5CUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54ICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW50ZWdlcnMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXJyYXkgbWVtYmVycyByZWZlcmVuY2VzLFxuXHRcdFx0XHQvLyByYXRoZXIgdGhhbiBhcyBleHByZXNzaW9ucyBpbiB0aGVpciBvd24gcmlnaHRcblx0XHRcdFx0aWYgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi5uO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5OVU1CRVJfTElURVJBTCAmJiBhcnJheU1lbWJlclBhdHRlcm4udGVzdCggZXhwcmVzc2lvbi52ICkgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi52O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHJlZmVyZW5jZUV4cHJlc3Npb24gPSBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24gKSApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUueCA9IHBhcnNlci5mbGF0dGVuRXhwcmVzc2lvbiggZXhwcmVzc2lvbiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdGhpcyEgaXQncyBiZXdpbGRlcmluZ1xuXHRcdGZ1bmN0aW9uIGdldFJlZmVyZW5jZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiApIHtcblx0XHRcdHZhciBtZW1iZXJzID0gW10sXG5cdFx0XHRcdHJlZmluZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuTUVNQkVSICYmIGV4cHJlc3Npb24uci50ID09PSB0eXBlcy5SRUZJTkVNRU5UICkge1xuXHRcdFx0XHRyZWZpbmVtZW50ID0gZXhwcmVzc2lvbi5yO1xuXHRcdFx0XHRpZiAoIHJlZmluZW1lbnQueCApIHtcblx0XHRcdFx0XHRpZiAoIHJlZmluZW1lbnQueC50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHJlZmluZW1lbnQueCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHBhcnNlci5mbGF0dGVuRXhwcmVzc2lvbiggcmVmaW5lbWVudC54ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KCByZWZpbmVtZW50Lm4gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBleHByZXNzaW9uLnQgIT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyOiBleHByZXNzaW9uLm4sXG5cdFx0XHRcdG06IG1lbWJlcnNcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIHR5cGUsIGhhbmRsZWJhcnNCbG9ja0NvZGVzLCBsZWdhY3kgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlLmpzICovXG5cdHZhciBtdXN0YWNoZSA9IGZ1bmN0aW9uKCB0eXBlcywgZGVsaW1pdGVyQ2hhbmdlLCBkZWxpbWl0ZXJUeXBlcywgbXVzdGFjaGVDb250ZW50LCBoYW5kbGViYXJzQmxvY2tDb2RlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZGVsaW1pdGVyQ2hhbmdlVG9rZW4gPSB7XG5cdFx0XHR0OiB0eXBlcy5ERUxJTUNIQU5HRSxcblx0XHRcdGV4Y2x1ZGU6IHRydWVcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZ2V0TXVzdGFjaGU7XG5cblx0XHRmdW5jdGlvbiBnZXRNdXN0YWNoZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHR5cGVzO1xuXHRcdFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWcsIGFuZCB3ZSdyZSBub3Rcblx0XHRcdC8vIGludGVycG9sYXRpbmcsIGJ1ZyBvdXRcblx0XHRcdGlmICggcGFyc2VyLmludGVycG9sYXRlWyBwYXJzZXIuaW5zaWRlIF0gPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHR5cGVzID0gZGVsaW1pdGVyVHlwZXMuc2xpY2UoKS5zb3J0KCBmdW5jdGlvbiBjb21wYXJlKCBhLCBiICkge1xuXHRcdFx0XHQvLyBTb3J0IGluIG9yZGVyIG9mIGRlc2NlbmRpbmcgb3BlbmluZyBkZWxpbWl0ZXIgbGVuZ3RoIChsb25nZXIgZmlyc3QpLFxuXHRcdFx0XHQvLyB0byBwcm90ZWN0IGFnYWluc3Qgb3BlbmluZyBkZWxpbWl0ZXJzIGJlaW5nIHN1YnN0cmluZ3Mgb2YgZWFjaCBvdGhlclxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyWyBiLmRlbGltaXRlcnMgXVsgMCBdLmxlbmd0aCAtIHBhcnNlclsgYS5kZWxpbWl0ZXJzIF1bIDAgXS5sZW5ndGg7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gciggdHlwZSApIHtcblx0XHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0TXVzdGFjaGVPZlR5cGUoIHBhcnNlciwgdHlwZSApIHx8IHIoIHR5cGVzLnNoaWZ0KCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSggdHlwZXMuc2hpZnQoKSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE11c3RhY2hlT2ZUeXBlKCBwYXJzZXIsIGRlbGltaXRlclR5cGUgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIG11c3RhY2hlLCBkZWxpbWl0ZXJzLCBjaGlsZHJlbiwgZXhwZWN0ZWRDbG9zZSwgZWxzZUNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIGNoaWxkO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0ZGVsaW1pdGVycyA9IHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF07XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGRlbGltaXRlciBjaGFuZ2U/XG5cdFx0XHRpZiAoIG11c3RhY2hlID0gZGVsaW1pdGVyQ2hhbmdlKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Ly8gZmluZCBjbG9zaW5nIGRlbGltaXRlciBvciBhYm9ydC4uLlxuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG5cdFx0XHRcdHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF0gPSBtdXN0YWNoZTtcblx0XHRcdFx0cmV0dXJuIGRlbGltaXRlckNoYW5nZVRva2VuO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0bXVzdGFjaGUgPSBtdXN0YWNoZUNvbnRlbnQoIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApO1xuXHRcdFx0aWYgKCBtdXN0YWNoZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgZGVsaW1pdGVyXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciBcXCcnICsgZGVsaW1pdGVyc1sgMSBdICsgJ1xcJyBhZnRlciByZWZlcmVuY2UnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLkNPTU1FTlQgKSB7XG5cdFx0XHRcdG11c3RhY2hlLmV4Y2x1ZGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRwYXJzZXIuc2VjdGlvbkRlcHRoIC09IDE7XG5cdFx0XHRcdGlmICggcGFyc2VyLnNlY3Rpb25EZXB0aCA8IDAgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0F0dGVtcHRlZCB0byBjbG9zZSBhIHNlY3Rpb24gdGhhdCB3YXNuXFwndCBvcGVuJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBwYXJ0aWFscyB3aXRoIGNvbnRleHRcblx0XHRcdGlmICggbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uICkge1xuXHRcdFx0XHRtdXN0YWNoZS5mID0gbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uO1xuXHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdFx0bXVzdGFjaGUubiA9ICd3aXRoJztcblx0XHRcdFx0ZGVsZXRlIG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbjtcblx0XHRcdH0gZWxzZSBpZiAoIGlzU2VjdGlvbiggbXVzdGFjaGUgKSApIHtcblx0XHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuXHRcdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0XHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IG11c3RhY2hlLm47XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBwYXJzZXIucmVhZCgpICkge1xuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdGlmICggZXhwZWN0ZWRDbG9zZSAmJiBjaGlsZC5yICE9PSBleHBlY3RlZENsb3NlICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCB7ey8nICsgZXhwZWN0ZWRDbG9zZSArICd9fScgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB7e2Vsc2V9fSB0YWdzIHJlcXVpcmUgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLklOVEVSUE9MQVRPUiAmJiBjaGlsZC5yID09PSAnZWxzZScgKSB7XG5cdFx0XHRcdFx0XHQvLyBubyB7e2Vsc2V9fSBhbGxvd2VkIGluIHt7I3VubGVzc319XG5cdFx0XHRcdFx0XHRpZiAoIG11c3RhY2hlLm4gPT09ICd1bmxlc3MnICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICd7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fScgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRDaGlsZHJlbiA9IGVsc2VDaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VycmVudENoaWxkcmVuLnB1c2goIGNoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjaGlsZHJlbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUuZiA9IGNoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxzZUNoaWxkcmVuICYmIGVsc2VDaGlsZHJlbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUubCA9IGVsc2VDaGlsZHJlbjtcblx0XHRcdFx0XHRpZiAoIG11c3RhY2hlLm4gPT09ICd3aXRoJyApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLm4gPSAnaWYtd2l0aCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucyApIHtcblx0XHRcdFx0bXVzdGFjaGUucCA9IHBhcnNlci5nZXRMaW5lUG9zKCBzdGFydCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVwbGFjZSBibG9jayBuYW1lIHdpdGggY29kZVxuXHRcdFx0aWYgKCBtdXN0YWNoZS5uICkge1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gaGFuZGxlYmFyc0Jsb2NrQ29kZXNbIG11c3RhY2hlLm4gXTtcblx0XHRcdH0gZWxzZSBpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLklOVkVSVEVEICkge1xuXHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdFx0bXVzdGFjaGUubiA9IHR5cGVzLlNFQ1RJT05fVU5MRVNTO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU2VjdGlvbiggbXVzdGFjaGUgKSB7XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGUudCA9PT0gdHlwZXMuU0VDVElPTiB8fCBtdXN0YWNoZS50ID09PSB0eXBlcy5JTlZFUlRFRDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgZGVsaW1pdGVyQ2hhbmdlLCBkZWxpbWl0ZXJUeXBlcywgY29udGVudCwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2NvbW1lbnQuanMgKi9cblx0dmFyIGNvbW1lbnQgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgT1BFTl9DT01NRU5UID0gJzwhLS0nLFxuXHRcdFx0Q0xPU0VfQ09NTUVOVCA9ICctLT4nO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBjb250ZW50LCByZW1haW5pbmcsIGVuZEluZGV4LCBjb21tZW50O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBPUEVOX0NPTU1FTlQgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRlbmRJbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBDTE9TRV9DT01NRU5UICk7XG5cdFx0XHRpZiAoIGVuZEluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCBIVE1MIC0gZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50IHNlcXVlbmNlIChcXCctLT5cXCcpJyApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGVudCA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGVuZEluZGV4ICk7XG5cdFx0XHRwYXJzZXIucG9zICs9IGVuZEluZGV4ICsgMztcblx0XHRcdGNvbW1lbnQgPSB7XG5cdFx0XHRcdHQ6IHR5cGVzLkNPTU1FTlQsXG5cdFx0XHRcdGM6IGNvbnRlbnRcblx0XHRcdH07XG5cdFx0XHRpZiAoIHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucyApIHtcblx0XHRcdFx0Y29tbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3MoIHN0YXJ0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29tbWVudDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIGNvbmZpZy92b2lkRWxlbWVudE5hbWVzLmpzICovXG5cdHZhciB2b2lkRWxlbWVudE5hbWVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdm9pZEVsZW1lbnROYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGRvY3R5cGV8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkL2k7XG5cdFx0cmV0dXJuIHZvaWRFbGVtZW50TmFtZXM7XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3V0aWxzL2dldExvd2VzdEluZGV4LmpzICovXG5cdHZhciBnZXRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uKCBoYXlzdGFjaywgbmVlZGxlcyApIHtcblx0XHR2YXIgaSwgaW5kZXgsIGxvd2VzdDtcblx0XHRpID0gbmVlZGxlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRpbmRleCA9IGhheXN0YWNrLmluZGV4T2YoIG5lZWRsZXNbIGkgXSApO1xuXHRcdFx0Ly8gc2hvcnQgY2lyY3VpdFxuXHRcdFx0aWYgKCAhaW5kZXggKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhbG93ZXN0IHx8IGluZGV4IDwgbG93ZXN0ICkge1xuXHRcdFx0XHRsb3dlc3QgPSBpbmRleDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGxvd2VzdCB8fCAtMTtcblx0fTtcblxuXHQvKiBzaGFyZWQvZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcy5qcyAqL1xuXHR2YXIgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBodG1sRW50aXRpZXMsIGNvbnRyb2xDaGFyYWN0ZXJzLCBlbnRpdHlQYXR0ZXJuO1xuXHRcdGh0bWxFbnRpdGllcyA9IHtcblx0XHRcdHF1b3Q6IDM0LFxuXHRcdFx0YW1wOiAzOCxcblx0XHRcdGFwb3M6IDM5LFxuXHRcdFx0bHQ6IDYwLFxuXHRcdFx0Z3Q6IDYyLFxuXHRcdFx0bmJzcDogMTYwLFxuXHRcdFx0aWV4Y2w6IDE2MSxcblx0XHRcdGNlbnQ6IDE2Mixcblx0XHRcdHBvdW5kOiAxNjMsXG5cdFx0XHRjdXJyZW46IDE2NCxcblx0XHRcdHllbjogMTY1LFxuXHRcdFx0YnJ2YmFyOiAxNjYsXG5cdFx0XHRzZWN0OiAxNjcsXG5cdFx0XHR1bWw6IDE2OCxcblx0XHRcdGNvcHk6IDE2OSxcblx0XHRcdG9yZGY6IDE3MCxcblx0XHRcdGxhcXVvOiAxNzEsXG5cdFx0XHRub3Q6IDE3Mixcblx0XHRcdHNoeTogMTczLFxuXHRcdFx0cmVnOiAxNzQsXG5cdFx0XHRtYWNyOiAxNzUsXG5cdFx0XHRkZWc6IDE3Nixcblx0XHRcdHBsdXNtbjogMTc3LFxuXHRcdFx0c3VwMjogMTc4LFxuXHRcdFx0c3VwMzogMTc5LFxuXHRcdFx0YWN1dGU6IDE4MCxcblx0XHRcdG1pY3JvOiAxODEsXG5cdFx0XHRwYXJhOiAxODIsXG5cdFx0XHRtaWRkb3Q6IDE4Myxcblx0XHRcdGNlZGlsOiAxODQsXG5cdFx0XHRzdXAxOiAxODUsXG5cdFx0XHRvcmRtOiAxODYsXG5cdFx0XHRyYXF1bzogMTg3LFxuXHRcdFx0ZnJhYzE0OiAxODgsXG5cdFx0XHRmcmFjMTI6IDE4OSxcblx0XHRcdGZyYWMzNDogMTkwLFxuXHRcdFx0aXF1ZXN0OiAxOTEsXG5cdFx0XHRBZ3JhdmU6IDE5Mixcblx0XHRcdEFhY3V0ZTogMTkzLFxuXHRcdFx0QWNpcmM6IDE5NCxcblx0XHRcdEF0aWxkZTogMTk1LFxuXHRcdFx0QXVtbDogMTk2LFxuXHRcdFx0QXJpbmc6IDE5Nyxcblx0XHRcdEFFbGlnOiAxOTgsXG5cdFx0XHRDY2VkaWw6IDE5OSxcblx0XHRcdEVncmF2ZTogMjAwLFxuXHRcdFx0RWFjdXRlOiAyMDEsXG5cdFx0XHRFY2lyYzogMjAyLFxuXHRcdFx0RXVtbDogMjAzLFxuXHRcdFx0SWdyYXZlOiAyMDQsXG5cdFx0XHRJYWN1dGU6IDIwNSxcblx0XHRcdEljaXJjOiAyMDYsXG5cdFx0XHRJdW1sOiAyMDcsXG5cdFx0XHRFVEg6IDIwOCxcblx0XHRcdE50aWxkZTogMjA5LFxuXHRcdFx0T2dyYXZlOiAyMTAsXG5cdFx0XHRPYWN1dGU6IDIxMSxcblx0XHRcdE9jaXJjOiAyMTIsXG5cdFx0XHRPdGlsZGU6IDIxMyxcblx0XHRcdE91bWw6IDIxNCxcblx0XHRcdHRpbWVzOiAyMTUsXG5cdFx0XHRPc2xhc2g6IDIxNixcblx0XHRcdFVncmF2ZTogMjE3LFxuXHRcdFx0VWFjdXRlOiAyMTgsXG5cdFx0XHRVY2lyYzogMjE5LFxuXHRcdFx0VXVtbDogMjIwLFxuXHRcdFx0WWFjdXRlOiAyMjEsXG5cdFx0XHRUSE9STjogMjIyLFxuXHRcdFx0c3psaWc6IDIyMyxcblx0XHRcdGFncmF2ZTogMjI0LFxuXHRcdFx0YWFjdXRlOiAyMjUsXG5cdFx0XHRhY2lyYzogMjI2LFxuXHRcdFx0YXRpbGRlOiAyMjcsXG5cdFx0XHRhdW1sOiAyMjgsXG5cdFx0XHRhcmluZzogMjI5LFxuXHRcdFx0YWVsaWc6IDIzMCxcblx0XHRcdGNjZWRpbDogMjMxLFxuXHRcdFx0ZWdyYXZlOiAyMzIsXG5cdFx0XHRlYWN1dGU6IDIzMyxcblx0XHRcdGVjaXJjOiAyMzQsXG5cdFx0XHRldW1sOiAyMzUsXG5cdFx0XHRpZ3JhdmU6IDIzNixcblx0XHRcdGlhY3V0ZTogMjM3LFxuXHRcdFx0aWNpcmM6IDIzOCxcblx0XHRcdGl1bWw6IDIzOSxcblx0XHRcdGV0aDogMjQwLFxuXHRcdFx0bnRpbGRlOiAyNDEsXG5cdFx0XHRvZ3JhdmU6IDI0Mixcblx0XHRcdG9hY3V0ZTogMjQzLFxuXHRcdFx0b2NpcmM6IDI0NCxcblx0XHRcdG90aWxkZTogMjQ1LFxuXHRcdFx0b3VtbDogMjQ2LFxuXHRcdFx0ZGl2aWRlOiAyNDcsXG5cdFx0XHRvc2xhc2g6IDI0OCxcblx0XHRcdHVncmF2ZTogMjQ5LFxuXHRcdFx0dWFjdXRlOiAyNTAsXG5cdFx0XHR1Y2lyYzogMjUxLFxuXHRcdFx0dXVtbDogMjUyLFxuXHRcdFx0eWFjdXRlOiAyNTMsXG5cdFx0XHR0aG9ybjogMjU0LFxuXHRcdFx0eXVtbDogMjU1LFxuXHRcdFx0T0VsaWc6IDMzOCxcblx0XHRcdG9lbGlnOiAzMzksXG5cdFx0XHRTY2Fyb246IDM1Mixcblx0XHRcdHNjYXJvbjogMzUzLFxuXHRcdFx0WXVtbDogMzc2LFxuXHRcdFx0Zm5vZjogNDAyLFxuXHRcdFx0Y2lyYzogNzEwLFxuXHRcdFx0dGlsZGU6IDczMixcblx0XHRcdEFscGhhOiA5MTMsXG5cdFx0XHRCZXRhOiA5MTQsXG5cdFx0XHRHYW1tYTogOTE1LFxuXHRcdFx0RGVsdGE6IDkxNixcblx0XHRcdEVwc2lsb246IDkxNyxcblx0XHRcdFpldGE6IDkxOCxcblx0XHRcdEV0YTogOTE5LFxuXHRcdFx0VGhldGE6IDkyMCxcblx0XHRcdElvdGE6IDkyMSxcblx0XHRcdEthcHBhOiA5MjIsXG5cdFx0XHRMYW1iZGE6IDkyMyxcblx0XHRcdE11OiA5MjQsXG5cdFx0XHROdTogOTI1LFxuXHRcdFx0WGk6IDkyNixcblx0XHRcdE9taWNyb246IDkyNyxcblx0XHRcdFBpOiA5MjgsXG5cdFx0XHRSaG86IDkyOSxcblx0XHRcdFNpZ21hOiA5MzEsXG5cdFx0XHRUYXU6IDkzMixcblx0XHRcdFVwc2lsb246IDkzMyxcblx0XHRcdFBoaTogOTM0LFxuXHRcdFx0Q2hpOiA5MzUsXG5cdFx0XHRQc2k6IDkzNixcblx0XHRcdE9tZWdhOiA5MzcsXG5cdFx0XHRhbHBoYTogOTQ1LFxuXHRcdFx0YmV0YTogOTQ2LFxuXHRcdFx0Z2FtbWE6IDk0Nyxcblx0XHRcdGRlbHRhOiA5NDgsXG5cdFx0XHRlcHNpbG9uOiA5NDksXG5cdFx0XHR6ZXRhOiA5NTAsXG5cdFx0XHRldGE6IDk1MSxcblx0XHRcdHRoZXRhOiA5NTIsXG5cdFx0XHRpb3RhOiA5NTMsXG5cdFx0XHRrYXBwYTogOTU0LFxuXHRcdFx0bGFtYmRhOiA5NTUsXG5cdFx0XHRtdTogOTU2LFxuXHRcdFx0bnU6IDk1Nyxcblx0XHRcdHhpOiA5NTgsXG5cdFx0XHRvbWljcm9uOiA5NTksXG5cdFx0XHRwaTogOTYwLFxuXHRcdFx0cmhvOiA5NjEsXG5cdFx0XHRzaWdtYWY6IDk2Mixcblx0XHRcdHNpZ21hOiA5NjMsXG5cdFx0XHR0YXU6IDk2NCxcblx0XHRcdHVwc2lsb246IDk2NSxcblx0XHRcdHBoaTogOTY2LFxuXHRcdFx0Y2hpOiA5NjcsXG5cdFx0XHRwc2k6IDk2OCxcblx0XHRcdG9tZWdhOiA5NjksXG5cdFx0XHR0aGV0YXN5bTogOTc3LFxuXHRcdFx0dXBzaWg6IDk3OCxcblx0XHRcdHBpdjogOTgyLFxuXHRcdFx0ZW5zcDogODE5NCxcblx0XHRcdGVtc3A6IDgxOTUsXG5cdFx0XHR0aGluc3A6IDgyMDEsXG5cdFx0XHR6d25qOiA4MjA0LFxuXHRcdFx0endqOiA4MjA1LFxuXHRcdFx0bHJtOiA4MjA2LFxuXHRcdFx0cmxtOiA4MjA3LFxuXHRcdFx0bmRhc2g6IDgyMTEsXG5cdFx0XHRtZGFzaDogODIxMixcblx0XHRcdGxzcXVvOiA4MjE2LFxuXHRcdFx0cnNxdW86IDgyMTcsXG5cdFx0XHRzYnF1bzogODIxOCxcblx0XHRcdGxkcXVvOiA4MjIwLFxuXHRcdFx0cmRxdW86IDgyMjEsXG5cdFx0XHRiZHF1bzogODIyMixcblx0XHRcdGRhZ2dlcjogODIyNCxcblx0XHRcdERhZ2dlcjogODIyNSxcblx0XHRcdGJ1bGw6IDgyMjYsXG5cdFx0XHRoZWxsaXA6IDgyMzAsXG5cdFx0XHRwZXJtaWw6IDgyNDAsXG5cdFx0XHRwcmltZTogODI0Mixcblx0XHRcdFByaW1lOiA4MjQzLFxuXHRcdFx0bHNhcXVvOiA4MjQ5LFxuXHRcdFx0cnNhcXVvOiA4MjUwLFxuXHRcdFx0b2xpbmU6IDgyNTQsXG5cdFx0XHRmcmFzbDogODI2MCxcblx0XHRcdGV1cm86IDgzNjQsXG5cdFx0XHRpbWFnZTogODQ2NSxcblx0XHRcdHdlaWVycDogODQ3Mixcblx0XHRcdHJlYWw6IDg0NzYsXG5cdFx0XHR0cmFkZTogODQ4Mixcblx0XHRcdGFsZWZzeW06IDg1MDEsXG5cdFx0XHRsYXJyOiA4NTkyLFxuXHRcdFx0dWFycjogODU5Myxcblx0XHRcdHJhcnI6IDg1OTQsXG5cdFx0XHRkYXJyOiA4NTk1LFxuXHRcdFx0aGFycjogODU5Nixcblx0XHRcdGNyYXJyOiA4NjI5LFxuXHRcdFx0bEFycjogODY1Nixcblx0XHRcdHVBcnI6IDg2NTcsXG5cdFx0XHRyQXJyOiA4NjU4LFxuXHRcdFx0ZEFycjogODY1OSxcblx0XHRcdGhBcnI6IDg2NjAsXG5cdFx0XHRmb3JhbGw6IDg3MDQsXG5cdFx0XHRwYXJ0OiA4NzA2LFxuXHRcdFx0ZXhpc3Q6IDg3MDcsXG5cdFx0XHRlbXB0eTogODcwOSxcblx0XHRcdG5hYmxhOiA4NzExLFxuXHRcdFx0aXNpbjogODcxMixcblx0XHRcdG5vdGluOiA4NzEzLFxuXHRcdFx0bmk6IDg3MTUsXG5cdFx0XHRwcm9kOiA4NzE5LFxuXHRcdFx0c3VtOiA4NzIxLFxuXHRcdFx0bWludXM6IDg3MjIsXG5cdFx0XHRsb3dhc3Q6IDg3MjcsXG5cdFx0XHRyYWRpYzogODczMCxcblx0XHRcdHByb3A6IDg3MzMsXG5cdFx0XHRpbmZpbjogODczNCxcblx0XHRcdGFuZzogODczNixcblx0XHRcdGFuZDogODc0Myxcblx0XHRcdG9yOiA4NzQ0LFxuXHRcdFx0Y2FwOiA4NzQ1LFxuXHRcdFx0Y3VwOiA4NzQ2LFxuXHRcdFx0J2ludCc6IDg3NDcsXG5cdFx0XHR0aGVyZTQ6IDg3NTYsXG5cdFx0XHRzaW06IDg3NjQsXG5cdFx0XHRjb25nOiA4NzczLFxuXHRcdFx0YXN5bXA6IDg3NzYsXG5cdFx0XHRuZTogODgwMCxcblx0XHRcdGVxdWl2OiA4ODAxLFxuXHRcdFx0bGU6IDg4MDQsXG5cdFx0XHRnZTogODgwNSxcblx0XHRcdHN1YjogODgzNCxcblx0XHRcdHN1cDogODgzNSxcblx0XHRcdG5zdWI6IDg4MzYsXG5cdFx0XHRzdWJlOiA4ODM4LFxuXHRcdFx0c3VwZTogODgzOSxcblx0XHRcdG9wbHVzOiA4ODUzLFxuXHRcdFx0b3RpbWVzOiA4ODU1LFxuXHRcdFx0cGVycDogODg2OSxcblx0XHRcdHNkb3Q6IDg5MDEsXG5cdFx0XHRsY2VpbDogODk2OCxcblx0XHRcdHJjZWlsOiA4OTY5LFxuXHRcdFx0bGZsb29yOiA4OTcwLFxuXHRcdFx0cmZsb29yOiA4OTcxLFxuXHRcdFx0bGFuZzogOTAwMSxcblx0XHRcdHJhbmc6IDkwMDIsXG5cdFx0XHRsb3o6IDk2NzQsXG5cdFx0XHRzcGFkZXM6IDk4MjQsXG5cdFx0XHRjbHViczogOTgyNyxcblx0XHRcdGhlYXJ0czogOTgyOSxcblx0XHRcdGRpYW1zOiA5ODMwXG5cdFx0fTtcblx0XHRjb250cm9sQ2hhcmFjdGVycyA9IFtcblx0XHRcdDgzNjQsXG5cdFx0XHQxMjksXG5cdFx0XHQ4MjE4LFxuXHRcdFx0NDAyLFxuXHRcdFx0ODIyMixcblx0XHRcdDgyMzAsXG5cdFx0XHQ4MjI0LFxuXHRcdFx0ODIyNSxcblx0XHRcdDcxMCxcblx0XHRcdDgyNDAsXG5cdFx0XHQzNTIsXG5cdFx0XHQ4MjQ5LFxuXHRcdFx0MzM4LFxuXHRcdFx0MTQxLFxuXHRcdFx0MzgxLFxuXHRcdFx0MTQzLFxuXHRcdFx0MTQ0LFxuXHRcdFx0ODIxNixcblx0XHRcdDgyMTcsXG5cdFx0XHQ4MjIwLFxuXHRcdFx0ODIyMSxcblx0XHRcdDgyMjYsXG5cdFx0XHQ4MjExLFxuXHRcdFx0ODIxMixcblx0XHRcdDczMixcblx0XHRcdDg0ODIsXG5cdFx0XHQzNTMsXG5cdFx0XHQ4MjUwLFxuXHRcdFx0MzM5LFxuXHRcdFx0MTU3LFxuXHRcdFx0MzgyLFxuXHRcdFx0Mzc2XG5cdFx0XTtcblx0XHRlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJyYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8JyArIE9iamVjdC5rZXlzKCBodG1sRW50aXRpZXMgKS5qb2luKCAnfCcgKSArICcpKTs/JywgJ2cnICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCBodG1sICkge1xuXHRcdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggZW50aXR5UGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCBlbnRpdHkgKSB7XG5cdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHQvLyBIYW5kbGUgbmFtZWQgZW50aXRpZXNcblx0XHRcdFx0aWYgKCBlbnRpdHlbIDAgXSAhPT0gJyMnICkge1xuXHRcdFx0XHRcdGNvZGUgPSBodG1sRW50aXRpZXNbIGVudGl0eSBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbnRpdHlbIDEgXSA9PT0gJ3gnICkge1xuXHRcdFx0XHRcdGNvZGUgPSBwYXJzZUludCggZW50aXR5LnN1YnN0cmluZyggMiApLCAxNiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvZGUgPSBwYXJzZUludCggZW50aXR5LnN1YnN0cmluZyggMSApLCAxMCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWNvZGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCB2YWxpZGF0ZUNvZGUoIGNvZGUgKSApO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0Ly8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcblx0XHQvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG5cdFx0Ly8gdG8gcmVwbGFjZSB0aGVtIG91cnNlbHZlc1xuXHRcdC8vXG5cdFx0Ly8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcblx0XHRmdW5jdGlvbiB2YWxpZGF0ZUNvZGUoIGNvZGUgKSB7XG5cdFx0XHRpZiAoICFjb2RlICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2Vcblx0XHRcdGlmICggY29kZSA9PT0gMTAgKSB7XG5cdFx0XHRcdHJldHVybiAzMjtcblx0XHRcdH1cblx0XHRcdC8vIEFTQ0lJIHJhbmdlLiAoV2h5IHNvbWVvbmUgd291bGQgdXNlIEhUTUwgZW50aXRpZXMgZm9yIEFTQ0lJIGNoYXJhY3RlcnMgSSBkb24ndCBrbm93LCBidXQuLi4pXG5cdFx0XHRpZiAoIGNvZGUgPCAxMjggKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29kZSBwb2ludHMgMTI4LTE1OSBhcmUgZGVhbHQgd2l0aCBsZW5pZW50bHkgYnkgYnJvd3NlcnMsIGJ1dCB0aGV5J3JlIGluY29ycmVjdC4gV2UgbmVlZFxuXHRcdFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cblx0XHRcdGlmICggY29kZSA8PSAxNTkgKSB7XG5cdFx0XHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1sgY29kZSAtIDEyOCBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG5cdFx0XHRpZiAoIGNvZGUgPCA1NTI5NiApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuXHRcdFx0aWYgKCBjb2RlIDw9IDU3MzQzICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXN0IG9mIHRoZSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblx0XHRcdGlmICggY29kZSA8PSA2NTUzNSApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbGVnYWN5ICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy90ZXh0LmpzICovXG5cdHZhciB0ZXh0ID0gZnVuY3Rpb24oIGdldExvd2VzdEluZGV4LCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgaW5kZXgsIHJlbWFpbmluZywgZGlzYWxsb3dlZCwgYmFycmllcjtcblx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGJhcnJpZXIgPSBwYXJzZXIuaW5zaWRlID8gJzwvJyArIHBhcnNlci5pbnNpZGUgOiAnPCc7XG5cdFx0XHRpZiAoIHBhcnNlci5pbnNpZGUgJiYgIXBhcnNlci5pbnRlcnBvbGF0ZVsgcGFyc2VyLmluc2lkZSBdICkge1xuXHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBiYXJyaWVyICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhbGxvd2VkID0gW1xuXHRcdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnRyaXBsZURlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIuc3RhdGljRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWyAwIF1cblx0XHRcdFx0XTtcblx0XHRcdFx0Ly8gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIHBhcnNlci5pbkF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHQvLyB3ZSdyZSBpbnNpZGUgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXG5cdFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCAnXCInLCAnXFwnJywgJz0nLCAnPCcsICc+JywgJ2AnICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcnNlci5pbkF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHQvLyBxdW90ZWQgYXR0cmlidXRlIHZhbHVlXG5cdFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCBwYXJzZXIuaW5BdHRyaWJ1dGUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkaXNhbGxvd2VkLnB1c2goIGJhcnJpZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCA9IGdldExvd2VzdEluZGV4KCByZW1haW5pbmcsIGRpc2FsbG93ZWQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0cmV0dXJuIHBhcnNlci5pbnNpZGUgPyByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApIDogZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKSApO1xuXHRcdH07XG5cdH0oIGdldExvd2VzdEluZGV4LCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50L2Nsb3NpbmdUYWcuanMgKi9cblx0dmFyIGNsb3NpbmdUYWcgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgY2xvc2luZ1RhZ1BhdHRlcm4gPSAvXihbYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKilcXHMqXFw+Lztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciB0YWc7XG5cdFx0XHQvLyBhcmUgd2UgbG9va2luZyBhdCBhIGNsb3NpbmcgdGFnP1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPC8nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0YWcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBjbG9zaW5nVGFnUGF0dGVybiApICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkNMT1NJTkdfVEFHLFxuXHRcdFx0XHRcdGU6IHRhZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gV2UgaGF2ZSBhbiBpbGxlZ2FsIGNsb3NpbmcgdGFnLCByZXBvcnQgaXRcblx0XHRcdHBhcnNlci5wb3MgLT0gMjtcblx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgY2xvc2luZyB0YWcnICk7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvYXR0cmlidXRlLmpzICovXG5cdHZhciBhdHRyaWJ1dGUgPSBmdW5jdGlvbiggZ2V0TG93ZXN0SW5kZXgsIGdldE11c3RhY2hlLCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBhdHRyaWJ1dGVOYW1lUGF0dGVybiA9IC9eW15cXHNcIic+XFwvPV0rLyxcblx0XHRcdHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybiA9IC9eW15cXHNcIic9PD5gXSsvO1xuXHRcdF9fZXhwb3J0ID0gZ2V0QXR0cmlidXRlO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgYXR0ciwgbmFtZSwgdmFsdWU7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggYXR0cmlidXRlTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIW5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0YXR0ciA9IHtcblx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0fTtcblx0XHRcdHZhbHVlID0gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApO1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0YXR0ci52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGF0dHI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdmFsdWVTdGFydCwgc3RhcnREZXB0aCwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVTdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRzdGFydERlcHRoID0gcGFyc2VyLnNlY3Rpb25EZXB0aDtcblx0XHRcdHZhbHVlID0gZ2V0UXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgJ1xcJycgKSB8fCBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCAnXCInICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHBhcnNlci5zZWN0aW9uRGVwdGggIT09IHN0YXJ0RGVwdGggKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSB2YWx1ZVN0YXJ0O1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3MnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdmFsdWUubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiB2YWx1ZVsgMCBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoIHZhbHVlWyAwIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdGV4dCwgaGF5c3RhY2ssIG5lZWRsZXMsIGluZGV4O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0dGV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybiApO1xuXHRcdFx0aWYgKCAhdGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRoYXlzdGFjayA9IHRleHQ7XG5cdFx0XHRuZWVkbGVzID0gW1xuXHRcdFx0XHRwYXJzZXIuZGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIudHJpcGxlRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sgMCBdXG5cdFx0XHRdO1xuXHRcdFx0aWYgKCAoIGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIGhheXN0YWNrLCBuZWVkbGVzICkgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0ciggMCwgaW5kZXggKTtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdG9rZW5zLCB0b2tlbjtcblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cdFx0XHR0b2tlbnMgPSBbXTtcblx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICk7XG5cdFx0XHR3aGlsZSAoIHRva2VuICE9PSBudWxsICkge1xuXHRcdFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKCBwYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXRva2Vucy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsIHF1b3RlTWFyayApIHtcblx0XHRcdHZhciBzdGFydCwgdG9rZW5zLCB0b2tlbjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggcXVvdGVNYXJrICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gcXVvdGVNYXJrO1xuXHRcdFx0dG9rZW5zID0gW107XG5cdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKTtcblx0XHRcdHdoaWxlICggdG9rZW4gIT09IG51bGwgKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggcXVvdGVNYXJrICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0b2tlbnM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBpbmRleCwgaGF5c3RhY2ssIG5lZWRsZXM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRoYXlzdGFjayA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdG5lZWRsZXMgPSBbXG5cdFx0XHRcdHF1b3RlTWFyayxcblx0XHRcdFx0cGFyc2VyLmRlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnRyaXBsZURlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnN0YXRpY0RlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnN0YXRpY1RyaXBsZURlbGltaXRlcnNbIDAgXVxuXHRcdFx0XTtcblx0XHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIGhheXN0YWNrLCBuZWVkbGVzICk7XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnUXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGhhdmUgYSBjbG9zaW5nIHF1b3RlJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhaW5kZXggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdHJldHVybiBoYXlzdGFjay5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZ2V0TG93ZXN0SW5kZXgsIG11c3RhY2hlLCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICk7XG5cblx0LyogdXRpbHMvcGFyc2VKU09OLmpzICovXG5cdHZhciBwYXJzZUpTT04gPSBmdW5jdGlvbiggUGFyc2VyLCBnZXRTdHJpbmdMaXRlcmFsLCBnZXRLZXkgKSB7XG5cblx0XHR2YXIgSnNvblBhcnNlciwgc3BlY2lhbHMsIHNwZWNpYWxzUGF0dGVybiwgbnVtYmVyUGF0dGVybiwgcGxhY2Vob2xkZXJQYXR0ZXJuLCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuLCBvbmx5V2hpdGVzcGFjZTtcblx0XHRzcGVjaWFscyA9IHtcblx0XHRcdCd0cnVlJzogdHJ1ZSxcblx0XHRcdCdmYWxzZSc6IGZhbHNlLFxuXHRcdFx0J3VuZGVmaW5lZCc6IHVuZGVmaW5lZCxcblx0XHRcdCdudWxsJzogbnVsbFxuXHRcdH07XG5cdFx0c3BlY2lhbHNQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14oPzonICsgT2JqZWN0LmtleXMoIHNwZWNpYWxzICkuam9pbiggJ3wnICkgKyAnKScgKTtcblx0XHRudW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/Lztcblx0XHRwbGFjZWhvbGRlclBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG5cdFx0cGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiA9IC9eXFwkXFx7KFteXFx9XSspXFx9Lztcblx0XHRvbmx5V2hpdGVzcGFjZSA9IC9eXFxzKiQvO1xuXHRcdEpzb25QYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuXHRcdFx0XHR0aGlzLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0fSxcblx0XHRcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0XHRpZiAoIHJlc3VsdC5sZW5ndGggIT09IDEgfHwgIW9ubHlXaGl0ZXNwYWNlLnRlc3QoIHRoaXMubGVmdG92ZXIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZhbHVlOiByZXN1bHRbIDAgXS52XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVyczogW1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGdldFBsYWNlaG9sZGVyKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHBsYWNlaG9sZGVyO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci52YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGxhY2Vob2xkZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuICk7XG5cdFx0XHRcdFx0aWYgKCBwbGFjZWhvbGRlciAmJiBwYXJzZXIudmFsdWVzLmhhc093blByb3BlcnR5KCBwbGFjZWhvbGRlciApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcGFyc2VyLnZhbHVlc1sgcGxhY2Vob2xkZXIgXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldFNwZWNpYWwoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgc3BlY2lhbDtcblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzcGVjaWFsc1BhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHNwZWNpYWxzWyBzcGVjaWFsIF1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXROdW1iZXIoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgbnVtYmVyO1xuXHRcdFx0XHRcdGlmICggbnVtYmVyID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbnVtYmVyUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogK251bWJlclxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldFN0cmluZyggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBzdHJpbmdMaXRlcmFsID0gZ2V0U3RyaW5nTGl0ZXJhbCggcGFyc2VyICksXG5cdFx0XHRcdFx0XHR2YWx1ZXM7XG5cdFx0XHRcdFx0aWYgKCBzdHJpbmdMaXRlcmFsICYmICggdmFsdWVzID0gcGFyc2VyLnZhbHVlcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogc3RyaW5nTGl0ZXJhbC52LnJlcGxhY2UoIHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJDEgaW4gdmFsdWVzID8gdmFsdWVzWyAkMSBdIDogJDE7XG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ0xpdGVyYWw7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldE9iamVjdCggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQsIHBhaXI7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAneycgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIHBhaXIgPSBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0WyBwYWlyLmtleSBdID0gcGFpci52YWx1ZTtcblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnfScgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0QXJyYXkoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0LCB2YWx1ZVRva2VuO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCB2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCB2YWx1ZVRva2VuLnYgKTtcblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0gKTtcblxuXHRcdGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpciggcGFyc2VyICkge1xuXHRcdFx0dmFyIGtleSwgdmFsdWVUb2tlbiwgcGFpcjtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGtleSA9IGdldEtleSggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFpciA9IHtcblx0XHRcdFx0a2V5OiBrZXlcblx0XHRcdH07XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc6JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpO1xuXHRcdFx0aWYgKCAhdmFsdWVUb2tlbiApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlyLnZhbHVlID0gdmFsdWVUb2tlbi52O1xuXHRcdFx0cmV0dXJuIHBhaXI7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiggc3RyLCB2YWx1ZXMgKSB7XG5cdFx0XHR2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoIHN0ciwge1xuXHRcdFx0XHR2YWx1ZXM6IHZhbHVlc1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHBhcnNlci5yZXN1bHQ7XG5cdFx0fTtcblx0fSggUGFyc2VyLCBzdHJpbmdMaXRlcmFsLCBrZXkgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvcHJvY2Vzc0RpcmVjdGl2ZS5qcyAqL1xuXHR2YXIgcHJvY2Vzc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uKCBQYXJzZXIsIGNvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiwgcGFyc2VKU09OICkge1xuXG5cdFx0dmFyIG1ldGhvZENhbGxQYXR0ZXJuID0gL14oW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKVxcKC8sXG5cdFx0XHRFeHByZXNzaW9uUGFyc2VyO1xuXHRcdEV4cHJlc3Npb25QYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRjb252ZXJ0ZXJzOiBbIGNvbmRpdGlvbmFsIF1cblx0XHR9ICk7XG5cdFx0Ly8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCB0b2tlbnMgKSB7XG5cdFx0XHR2YXIgcmVzdWx0LCBtYXRjaCwgcGFyc2VyLCBhcmdzLCB0b2tlbiwgY29sb25JbmRleCwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncywgcGFyc2VkO1xuXHRcdFx0aWYgKCB0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IG1ldGhvZENhbGxQYXR0ZXJuLmV4ZWMoIHRva2VucyApICkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHRcdG06IG1hdGNoWyAxIF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGFyZ3MgPSAnWycgKyB0b2tlbnMuc2xpY2UoIHJlc3VsdC5tLmxlbmd0aCArIDEsIC0xICkgKyAnXSc7XG5cdFx0XHRcdFx0cGFyc2VyID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoIGFyZ3MgKTtcblx0XHRcdFx0XHRyZXN1bHQuYSA9IGZsYXR0ZW5FeHByZXNzaW9uKCBwYXJzZXIucmVzdWx0WyAwIF0gKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdG9rZW5zLmluZGV4T2YoICc6JyApID09PSAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnRyaW0oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b2tlbnMgPSBbIHRva2VucyBdO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRkaXJlY3RpdmVOYW1lID0gW107XG5cdFx0XHRkaXJlY3RpdmVBcmdzID0gW107XG5cdFx0XHRpZiAoIHRva2VucyApIHtcblx0XHRcdFx0d2hpbGUgKCB0b2tlbnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0Y29sb25JbmRleCA9IHRva2VuLmluZGV4T2YoICc6JyApO1xuXHRcdFx0XHRcdFx0aWYgKCBjb2xvbkluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gaXMgdGhlIGNvbG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXI/XG5cdFx0XHRcdFx0XHRcdGlmICggY29sb25JbmRleCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBub1xuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4uc3Vic3RyKCAwLCBjb2xvbkluZGV4ICkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBhZnRlciB0aGUgY29sb24gaW4gdGhpcyB0b2tlbiwgdHJlYXRcblx0XHRcdFx0XHRcdFx0Ly8gaXQgYXMgdGhlIGZpcnN0IHRva2VuIG9mIHRoZSBkaXJlY3RpdmVBcmdzIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRcdGlmICggdG9rZW4ubGVuZ3RoID4gY29sb25JbmRleCArIDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aXZlQXJnc1sgMCBdID0gdG9rZW4uc3Vic3RyaW5nKCBjb2xvbkluZGV4ICsgMSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRpcmVjdGl2ZUFyZ3MgPSBkaXJlY3RpdmVBcmdzLmNvbmNhdCggdG9rZW5zICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFkaXJlY3RpdmVOYW1lLmxlbmd0aCApIHtcblx0XHRcdFx0cmVzdWx0ID0gJyc7XG5cdFx0XHR9IGVsc2UgaWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8ganVzdCB1c2UgdGhlIGFycmF5XG5cdFx0XHRcdFx0bjogZGlyZWN0aXZlTmFtZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZU5hbWVbIDAgXSA9PT0gJ3N0cmluZycgPyBkaXJlY3RpdmVOYW1lWyAwIF0gOiBkaXJlY3RpdmVOYW1lXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbIDAgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCAnWycgKyBkaXJlY3RpdmVBcmdzWyAwIF0gKyAnXScgKTtcblx0XHRcdFx0XHRyZXN1bHQuYSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGRpcmVjdGl2ZUFyZ3NbIDAgXS50cmltKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBQYXJzZXIsIGNvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiwgcGFyc2VKU09OICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50LmpzICovXG5cdHZhciBlbGVtZW50ID0gZnVuY3Rpb24oIHR5cGVzLCB2b2lkRWxlbWVudE5hbWVzLCBnZXRNdXN0YWNoZSwgZ2V0Q29tbWVudCwgZ2V0VGV4dCwgZ2V0Q2xvc2luZ1RhZywgZ2V0QXR0cmlidXRlLCBwcm9jZXNzRGlyZWN0aXZlICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciB0YWdOYW1lUGF0dGVybiA9IC9eW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSovLFxuXHRcdFx0dmFsaWRUYWdOYW1lRm9sbG93ZXIgPSAvXltcXHNcXG5cXC8+XS8sXG5cdFx0XHRvblBhdHRlcm4gPSAvXm9uLyxcblx0XHRcdHByb3h5RXZlbnRQYXR0ZXJuID0gL15vbi0oW2EtekEtWlxcXFwqXFxcXC4kX11bYS16QS1aXFxcXCpcXFxcLiRfMC05XFwtXSspJC8sXG5cdFx0XHRyZXNlcnZlZEV2ZW50TmFtZXMgPSAvXig/OmNoYW5nZXxyZXNldHx0ZWFyZG93bnx1cGRhdGV8Y29uc3RydWN0fGNvbmZpZ3xpbml0fHJlbmRlcnx1bnJlbmRlcnxkZXRhY2h8aW5zZXJ0KSQvLFxuXHRcdFx0ZGlyZWN0aXZlcyA9IHtcblx0XHRcdFx0J2ludHJvLW91dHJvJzogJ3QwJyxcblx0XHRcdFx0aW50cm86ICd0MScsXG5cdFx0XHRcdG91dHJvOiAndDInLFxuXHRcdFx0XHRkZWNvcmF0b3I6ICdvJ1xuXHRcdFx0fSxcblx0XHRcdGV4Y2x1ZGUgPSB7XG5cdFx0XHRcdGV4Y2x1ZGU6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzLCBkaXNhbGxvd2VkQ29udGVudHM7XG5cdFx0Ly8gRGlmZmVyZW50IHNldCBvZiBjb252ZXJ0ZXJzLCBiZWNhdXNlIHRoaXMgdGltZSB3ZSdyZSBsb29raW5nIGZvciBjbG9zaW5nIHRhZ3Ncblx0XHRjb252ZXJ0ZXJzID0gW1xuXHRcdFx0Z2V0TXVzdGFjaGUsXG5cdFx0XHRnZXRDb21tZW50LFxuXHRcdFx0Z2V0RWxlbWVudCxcblx0XHRcdGdldFRleHQsXG5cdFx0XHRnZXRDbG9zaW5nVGFnXG5cdFx0XTtcblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC10YWctb21pc3Npb25cblx0XHRkaXNhbGxvd2VkQ29udGVudHMgPSB7XG5cdFx0XHRsaTogWyAnbGknIF0sXG5cdFx0XHRkdDogW1xuXHRcdFx0XHQnZHQnLFxuXHRcdFx0XHQnZGQnXG5cdFx0XHRdLFxuXHRcdFx0ZGQ6IFtcblx0XHRcdFx0J2R0Jyxcblx0XHRcdFx0J2RkJ1xuXHRcdFx0XSxcblx0XHRcdHA6ICdhZGRyZXNzIGFydGljbGUgYXNpZGUgYmxvY2txdW90ZSBkaXYgZGwgZmllbGRzZXQgZm9vdGVyIGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaGVhZGVyIGhncm91cCBociBtYWluIG1lbnUgbmF2IG9sIHAgcHJlIHNlY3Rpb24gdGFibGUgdWwnLnNwbGl0KCAnICcgKSxcblx0XHRcdHJ0OiBbXG5cdFx0XHRcdCdydCcsXG5cdFx0XHRcdCdycCdcblx0XHRcdF0sXG5cdFx0XHRycDogW1xuXHRcdFx0XHQncnQnLFxuXHRcdFx0XHQncnAnXG5cdFx0XHRdLFxuXHRcdFx0b3B0Z3JvdXA6IFsgJ29wdGdyb3VwJyBdLFxuXHRcdFx0b3B0aW9uOiBbXG5cdFx0XHRcdCdvcHRpb24nLFxuXHRcdFx0XHQnb3B0Z3JvdXAnXG5cdFx0XHRdLFxuXHRcdFx0dGhlYWQ6IFtcblx0XHRcdFx0J3Rib2R5Jyxcblx0XHRcdFx0J3Rmb290J1xuXHRcdFx0XSxcblx0XHRcdHRib2R5OiBbXG5cdFx0XHRcdCd0Ym9keScsXG5cdFx0XHRcdCd0Zm9vdCdcblx0XHRcdF0sXG5cdFx0XHR0Zm9vdDogWyAndGJvZHknIF0sXG5cdFx0XHR0cjogW1xuXHRcdFx0XHQndHInLFxuXHRcdFx0XHQndGJvZHknXG5cdFx0XHRdLFxuXHRcdFx0dGQ6IFtcblx0XHRcdFx0J3RkJyxcblx0XHRcdFx0J3RoJyxcblx0XHRcdFx0J3RyJ1xuXHRcdFx0XSxcblx0XHRcdHRoOiBbXG5cdFx0XHRcdCd0ZCcsXG5cdFx0XHRcdCd0aCcsXG5cdFx0XHRcdCd0cidcblx0XHRcdF1cblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZ2V0RWxlbWVudDtcblxuXHRcdGZ1bmN0aW9uIGdldEVsZW1lbnQoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZWxlbWVudCwgbG93ZXJDYXNlTmFtZSwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIGNoaWxkO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5zaWRlIHx8IHBhcnNlci5pbkF0dHJpYnV0ZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc8JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBjbG9zaW5nIHRhZywgYWJvcnQgc3RyYWlnaHQgYXdheVxuXHRcdFx0aWYgKCBwYXJzZXIubmV4dENoYXIoKSA9PT0gJy8nICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQgPSB7XG5cdFx0XHRcdHQ6IHR5cGVzLkVMRU1FTlRcblx0XHRcdH07XG5cdFx0XHRpZiAoIHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucyApIHtcblx0XHRcdFx0ZWxlbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3MoIHN0YXJ0ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJyEnICkgKSB7XG5cdFx0XHRcdGVsZW1lbnQueSA9IDE7XG5cdFx0XHR9XG5cdFx0XHQvLyBlbGVtZW50IG5hbWVcblx0XHRcdGVsZW1lbnQuZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHRhZ05hbWVQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFlbGVtZW50LmUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSB3aGl0ZXNwYWNlLCBjbG9zaW5nIHNvbGlkdXMgb3IgJz4nXG5cdFx0XHRpZiAoICF2YWxpZFRhZ05hbWVGb2xsb3dlci50ZXN0KCBwYXJzZXIubmV4dENoYXIoKSApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIHRhZyBuYW1lJyApO1xuXHRcdFx0fVxuXHRcdFx0YWRkUHJveHlFdmVudCA9IGZ1bmN0aW9uKCBuYW1lLCBkaXJlY3RpdmUgKSB7XG5cdFx0XHRcdHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm4gfHwgZGlyZWN0aXZlO1xuXHRcdFx0XHRpZiAoIHJlc2VydmVkRXZlbnROYW1lcy50ZXN0KCBkaXJlY3RpdmVOYW1lICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyAtPSBkaXJlY3RpdmVOYW1lLmxlbmd0aDtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdDYW5ub3QgdXNlIHJlc2VydmVkIGV2ZW50IG5hbWVzIChjaGFuZ2UsIHJlc2V0LCB0ZWFyZG93biwgdXBkYXRlLCBjb25zdHJ1Y3QsIGNvbmZpZywgaW5pdCwgcmVuZGVyLCB1bnJlbmRlciwgZGV0YWNoLCBpbnNlcnQpJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQudlsgbmFtZSBdID0gZGlyZWN0aXZlO1xuXHRcdFx0fTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIGRpcmVjdGl2ZXMgYW5kIGF0dHJpYnV0ZXNcblx0XHRcdHdoaWxlICggYXR0cmlidXRlID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldEF0dHJpYnV0ZSggcGFyc2VyICkgKSB7XG5cdFx0XHRcdC8vIHJlZ3VsYXIgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5uYW1lICkge1xuXHRcdFx0XHRcdC8vIGludHJvLCBvdXRybywgZGVjb3JhdG9yXG5cdFx0XHRcdFx0aWYgKCBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlc1sgYXR0cmlidXRlLm5hbWUgXSApIHtcblx0XHRcdFx0XHRcdGVsZW1lbnRbIGRpcmVjdGl2ZU5hbWUgXSA9IHByb2Nlc3NEaXJlY3RpdmUoIGF0dHJpYnV0ZS52YWx1ZSApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoID0gcHJveHlFdmVudFBhdHRlcm4uZXhlYyggYXR0cmlidXRlLm5hbWUgKSApIHtcblx0XHRcdFx0XHRcdGlmICggIWVsZW1lbnQudiApXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQudiA9IHt9O1xuXHRcdFx0XHRcdFx0ZGlyZWN0aXZlID0gcHJvY2Vzc0RpcmVjdGl2ZSggYXR0cmlidXRlLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRhZGRQcm94eUV2ZW50KCBtYXRjaFsgMSBdLCBkaXJlY3RpdmUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLnNhbml0aXplRXZlbnRBdHRyaWJ1dGVzIHx8ICFvblBhdHRlcm4udGVzdCggYXR0cmlidXRlLm5hbWUgKSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhZWxlbWVudC5hIClcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LmEgPSB7fTtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5hWyBhdHRyaWJ1dGUubmFtZSBdID0gYXR0cmlidXRlLnZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggIWVsZW1lbnQubSApXG5cdFx0XHRcdFx0XHRlbGVtZW50Lm0gPSBbXTtcblx0XHRcdFx0XHRlbGVtZW50Lm0ucHVzaCggYXR0cmlidXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBzb2xpZHVzXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBzZWxmLWNsb3Npbmcgc29saWR1cz9cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLycgKSApIHtcblx0XHRcdFx0c2VsZkNsb3NpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2xvc2luZyBhbmdsZSBicmFja2V0XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc+JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGxvd2VyQ2FzZU5hbWUgPSBlbGVtZW50LmUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICggIXNlbGZDbG9zaW5nICYmICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoIGVsZW1lbnQuZSApICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpZiB3ZSBvcGVuIGEgc2NyaXB0IGVsZW1lbnQsIGZ1cnRoZXIgdGFncyBzaG91bGRcblx0XHRcdFx0Ly8gYmUgaWdub3JlZCB1bmxlc3MgdGhleSdyZSBhIGNsb3Npbmcgc2NyaXB0IGVsZW1lbnRcblx0XHRcdFx0aWYgKCBsb3dlckNhc2VOYW1lID09PSAnc2NyaXB0JyB8fCBsb3dlckNhc2VOYW1lID09PSAnc3R5bGUnICkge1xuXHRcdFx0XHRcdHBhcnNlci5pbnNpZGUgPSBsb3dlckNhc2VOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0XHRcdHdoaWxlICggY2FuQ29udGFpbiggbG93ZXJDYXNlTmFtZSwgcGFyc2VyLnJlbWFpbmluZygpICkgJiYgKCBjaGlsZCA9IHBhcnNlci5yZWFkKCBjb252ZXJ0ZXJzICkgKSApIHtcblx0XHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjbG9zaW5nIHNlY3Rpb24gdGFnXG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lOR19UQUcgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cdFx0XHRpZiAoIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YoIGxvd2VyQ2FzZU5hbWUgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybiBleGNsdWRlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FuQ29udGFpbiggbmFtZSwgcmVtYWluaW5nICkge1xuXHRcdFx0dmFyIG1hdGNoLCBkaXNhbGxvd2VkO1xuXHRcdFx0bWF0Y2ggPSAvXjwoW2EtekEtWl1bYS16QS1aMC05XSopLy5leGVjKCByZW1haW5pbmcgKTtcblx0XHRcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkQ29udGVudHNbIG5hbWUgXTtcblx0XHRcdGlmICggIW1hdGNoIHx8ICFkaXNhbGxvd2VkICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhfmRpc2FsbG93ZWQuaW5kZXhPZiggbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIHZvaWRFbGVtZW50TmFtZXMsIG11c3RhY2hlLCBjb21tZW50LCB0ZXh0LCBjbG9zaW5nVGFnLCBhdHRyaWJ1dGUsIHByb2Nlc3NEaXJlY3RpdmUgKTtcblxuXHQvKiBwYXJzZS91dGlscy90cmltV2hpdGVzcGFjZS5qcyAqL1xuXHR2YXIgdHJpbVdoaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IC9eWyBcXHRcXGZcXHJcXG5dKy8sXG5cdFx0XHR0cmFpbGluZ1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKyQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbXMsIGxlYWRpbmcsIHRyYWlsaW5nICkge1xuXHRcdFx0dmFyIGl0ZW07XG5cdFx0XHRpZiAoIGxlYWRpbmcgKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgMCBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKCBsZWFkaW5nV2hpdGVzcGFjZSwgJycgKTtcblx0XHRcdFx0XHRpZiAoICFpdGVtICkge1xuXHRcdFx0XHRcdFx0aXRlbXMuc2hpZnQoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aXRlbXNbIDAgXSA9IGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRyYWlsaW5nICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGl0ZW1zLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSggdHJhaWxpbmdXaGl0ZXNwYWNlLCAnJyApO1xuXHRcdFx0XHRcdGlmICggIWl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5wb3AoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGl0ZW1zLmxlbmd0aCAtIDEgXSA9IGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL3V0aWxzL3N0cmlwU3RhbmRhbG9uZXMuanMgKi9cblx0dmFyIHN0cmlwU3RhbmRhbG9uZXMgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGxlYWRpbmdMaW5lYnJlYWsgPSAvXlxccypcXHI/XFxuLyxcblx0XHRcdHRyYWlsaW5nTGluZWJyZWFrID0gL1xccj9cXG5cXHMqJC87XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0XHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXHRcdFx0Zm9yICggaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0Y3VycmVudCA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdGJhY2tPbmUgPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0YmFja1R3byA9IGl0ZW1zWyBpIC0gMiBdO1xuXHRcdFx0XHQvLyBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIGEgW3RleHRdW2NvbW1lbnRdW3RleHRdIHNlcXVlbmNlLi4uXG5cdFx0XHRcdGlmICggaXNTdHJpbmcoIGN1cnJlbnQgKSAmJiBpc0NvbW1lbnQoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggYmFja1R3byApICkge1xuXHRcdFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuXHRcdFx0XHRcdGlmICggdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggYmFja1R3byApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uIHRoZW4gd2Ugd2FudCB0byByZW1vdmUgdGhlIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUgYnJlYWtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIC0gMiBdID0gYmFja1R3by5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBwcmVjZWRlZCBieSBhIGxpbmVicmVhaywgYW5kXG5cdFx0XHRcdC8vIGl0cyBmaXJzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG5cdFx0XHRcdGlmICggaXNTZWN0aW9uKCBjdXJyZW50ICkgJiYgaXNTdHJpbmcoIGJhY2tPbmUgKSApIHtcblx0XHRcdFx0XHRpZiAoIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggY3VycmVudC5mWyAwIF0gKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoIGN1cnJlbnQuZlsgMCBdICkgKSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSAtIDEgXSA9IGJhY2tPbmUucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50LmZbIDAgXSA9IGN1cnJlbnQuZlsgMCBdLnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBsYXN0IGl0ZW0gd2FzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbGluZWJyZWFrLCBhbmRcblx0XHRcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuXHRcdFx0XHRpZiAoIGlzU3RyaW5nKCBjdXJyZW50ICkgJiYgaXNTZWN0aW9uKCBiYWNrT25lICkgKSB7XG5cdFx0XHRcdFx0bGFzdFNlY3Rpb25JdGVtID0gYmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdGlmICggaXNTdHJpbmcoIGxhc3RTZWN0aW9uSXRlbSApICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGxhc3RTZWN0aW9uSXRlbSApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0YmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTdHJpbmcoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ29tbWVudCggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgfHwgaXRlbS50ID09PSB0eXBlcy5ERUxJTUNIQU5HRTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1NlY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpdGVtLnQgPT09IHR5cGVzLlNFQ1RJT04gfHwgaXRlbS50ID09PSB0eXBlcy5JTlZFUlRFRCApICYmIGl0ZW0uZjtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHV0aWxzL2VzY2FwZVJlZ0V4cC5qcyAqL1xuXHR2YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcGF0dGVybiA9IC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoIHN0ciApIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggcGF0dGVybiwgJ1xcXFwkJicgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvX3BhcnNlLmpzICovXG5cdHZhciBwYXJzZSA9IGZ1bmN0aW9uKCB0eXBlcywgUGFyc2VyLCBtdXN0YWNoZSwgY29tbWVudCwgZWxlbWVudCwgdGV4dCwgdHJpbVdoaXRlc3BhY2UsIHN0cmlwU3RhbmRhbG9uZXMsIGVzY2FwZVJlZ0V4cCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgU3RhbmRhcmRQYXJzZXIsIHBhcnNlLCBjb250aWd1b3VzV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rL2csXG5cdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cyA9IC9eKD86cHJlfHNjcmlwdHxzdHlsZXx0ZXh0YXJlYSkkL2ksXG5cdFx0XHRsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy8sXG5cdFx0XHR0cmFpbGluZ1doaXRlc3BhY2UgPSAvXFxzKyQvO1xuXHRcdFN0YW5kYXJkUGFyc2VyID0gUGFyc2VyLmV4dGVuZCgge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0Ly8gY29uZmlnXG5cdFx0XHRcdHNldERlbGltaXRlcnMoIG9wdGlvbnMsIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5zZWN0aW9uRGVwdGggPSAwO1xuXHRcdFx0XHR0aGlzLmludGVycG9sYXRlID0ge1xuXHRcdFx0XHRcdHNjcmlwdDogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zY3JpcHQgIT09IGZhbHNlLFxuXHRcdFx0XHRcdHN0eWxlOiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnN0eWxlICE9PSBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zYW5pdGl6ZSA9IHtcblx0XHRcdFx0XHRcdC8vIGJsYWNrbGlzdCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWNhamEvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9jYWphL2xhbmcvaHRtbC9odG1sNC1lbGVtZW50cy13aGl0ZWxpc3QuanNvblxuXHRcdFx0XHRcdFx0ZWxlbWVudHM6ICdhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlJy5zcGxpdCggJyAnICksXG5cdFx0XHRcdFx0XHRldmVudEF0dHJpYnV0ZXM6IHRydWVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2FuaXRpemVFbGVtZW50cyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5lbGVtZW50cztcblx0XHRcdFx0dGhpcy5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5ldmVudEF0dHJpYnV0ZXM7XG5cdFx0XHRcdHRoaXMuaW5jbHVkZUxpbmVQb3NpdGlvbnMgPSBvcHRpb25zLmluY2x1ZGVMaW5lUG9zaXRpb25zO1xuXHRcdFx0fSxcblx0XHRcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiggaXRlbXMsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zZWN0aW9uRGVwdGggPiAwICkge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3IoICdBIHNlY3Rpb24gd2FzIGxlZnQgb3BlbicgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGVhbnVwKCBpdGVtcywgb3B0aW9ucy5zdHJpcENvbW1lbnRzICE9PSBmYWxzZSwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICFvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgIW9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCBvcHRpb25zLnJld3JpdGVFbHNlICE9PSBmYWxzZSApO1xuXHRcdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVyczogW1xuXHRcdFx0XHRtdXN0YWNoZSxcblx0XHRcdFx0Y29tbWVudCxcblx0XHRcdFx0ZWxlbWVudCxcblx0XHRcdFx0dGV4dFxuXHRcdFx0XVxuXHRcdH0gKTtcblx0XHRwYXJzZSA9IGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciByZXN1bHQsIHJlbWFpbmluZywgcGFydGlhbHMsIG5hbWUsIHN0YXJ0TWF0Y2gsIGVuZE1hdGNoLCBpbmxpbmVQYXJ0aWFsU3RhcnQsIGlubGluZVBhcnRpYWxFbmQ7XG5cdFx0XHRzZXREZWxpbWl0ZXJzKCBvcHRpb25zICk7XG5cdFx0XHRpbmxpbmVQYXJ0aWFsU3RhcnQgPSBuZXcgUmVnRXhwKCAnPCEtLVxcXFxzKicgKyBlc2NhcGVSZWdFeHAoIG9wdGlvbnMuZGVsaW1pdGVyc1sgMCBdICkgKyAnXFxcXHMqPlxcXFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggb3B0aW9ucy5kZWxpbWl0ZXJzWyAxIF0gKSArICdcXFxccyotLT4nICk7XG5cdFx0XHRpbmxpbmVQYXJ0aWFsRW5kID0gbmV3IFJlZ0V4cCggJzwhLS1cXFxccyonICsgZXNjYXBlUmVnRXhwKCBvcHRpb25zLmRlbGltaXRlcnNbIDAgXSApICsgJ1xcXFxzKlxcXFwvXFxcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXFxccyonICsgZXNjYXBlUmVnRXhwKCBvcHRpb25zLmRlbGltaXRlcnNbIDEgXSApICsgJ1xcXFxzKi0tPicgKTtcblx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0djogMVxuXHRcdFx0fTtcblx0XHRcdGlmICggaW5saW5lUGFydGlhbFN0YXJ0LnRlc3QoIHRlbXBsYXRlICkgKSB7XG5cdFx0XHRcdHJlbWFpbmluZyA9IHRlbXBsYXRlO1xuXHRcdFx0XHR0ZW1wbGF0ZSA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoIHN0YXJ0TWF0Y2ggPSBpbmxpbmVQYXJ0aWFsU3RhcnQuZXhlYyggcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IHN0YXJ0TWF0Y2hbIDEgXTtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSByZW1haW5pbmcuc3Vic3RyKCAwLCBzdGFydE1hdGNoLmluZGV4ICk7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggc3RhcnRNYXRjaC5pbmRleCArIHN0YXJ0TWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0XHRlbmRNYXRjaCA9IGlubGluZVBhcnRpYWxFbmQuZXhlYyggcmVtYWluaW5nICk7XG5cdFx0XHRcdFx0aWYgKCAhZW5kTWF0Y2ggfHwgZW5kTWF0Y2hbIDEgXSAhPT0gbmFtZSApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0lubGluZSBwYXJ0aWFscyBtdXN0IGhhdmUgYSBjbG9zaW5nIGRlbGltaXRlciwgYW5kIGNhbm5vdCBiZSBuZXN0ZWQuIEV4cGVjdGVkIGNsb3NpbmcgZm9yIFwiJyArIG5hbWUgKyAnXCIsIGJ1dCAnICsgKCBlbmRNYXRjaCA/ICdpbnN0ZWFkIGZvdW5kIFwiJyArIGVuZE1hdGNoWyAxIF0gKyAnXCInIDogJyBubyBjbG9zaW5nIGZvdW5kJyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCggcGFydGlhbHMgfHwgKCBwYXJ0aWFscyA9IHt9ICkgKVsgbmFtZSBdID0gbmV3IFN0YW5kYXJkUGFyc2VyKCByZW1haW5pbmcuc3Vic3RyKCAwLCBlbmRNYXRjaC5pbmRleCApLCBvcHRpb25zICkucmVzdWx0O1xuXHRcdFx0XHRcdHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGVuZE1hdGNoLmluZGV4ICsgZW5kTWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSArPSByZW1haW5pbmc7XG5cdFx0XHRcdHJlc3VsdC5wID0gcGFydGlhbHM7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQudCA9IG5ldyBTdGFuZGFyZFBhcnNlciggdGVtcGxhdGUsIG9wdGlvbnMgKS5yZXN1bHQ7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0X19leHBvcnQgPSBwYXJzZTtcblxuXHRcdGZ1bmN0aW9uIGNsZWFudXAoIGl0ZW1zLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UsIHJld3JpdGVFbHNlICkge1xuXHRcdFx0dmFyIGksIGl0ZW0sIHByZXZpb3VzSXRlbSwgbmV4dEl0ZW0sIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgdW5sZXNzQmxvY2ssIGtleTtcblx0XHRcdC8vIEZpcnN0IHBhc3MgLSByZW1vdmUgc3RhbmRhbG9uZXMgYW5kIGNvbW1lbnRzIGV0Y1xuXHRcdFx0c3RyaXBTdGFuZGFsb25lcyggaXRlbXMgKTtcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuXHRcdFx0XHRpZiAoIGl0ZW0uZXhjbHVkZSApIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggc3RyaXBDb21tZW50cyAmJiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIG5lY2Vzc2FyeSwgcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Vcblx0XHRcdHRyaW1XaGl0ZXNwYWNlKCBpdGVtcywgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSApO1xuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0Ly8gUmVjdXJzZVxuXHRcdFx0XHRpZiAoIGl0ZW0uZiApIHtcblx0XHRcdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHByZXNlcnZlV2hpdGVzcGFjZSB8fCBpdGVtLnQgPT09IHR5cGVzLkVMRU1FTlQgJiYgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMudGVzdCggaXRlbS5lICk7XG5cdFx0XHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRwcmV2aW91c0l0ZW0gPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSB3YXMgYSB0ZXh0IGl0ZW0gd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZSBpbnNpZGUgdGhlIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRpZiAoICFwcmV2aW91c0l0ZW0gfHwgdHlwZW9mIHByZXZpb3VzSXRlbSA9PT0gJ3N0cmluZycgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QoIHByZXZpb3VzSXRlbSApICkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG5cdFx0XHRcdFx0XHRpZiAoICFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09ICdzdHJpbmcnICYmIGxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIG5leHRJdGVtICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuXHRcdFx0XHRpZiAoIGl0ZW0ubCApIHtcblx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmwsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0aWYgKCByZXdyaXRlRWxzZSApIHtcblx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrID0ge1xuXHRcdFx0XHRcdFx0XHR0OiA0LFxuXHRcdFx0XHRcdFx0XHRuOiB0eXBlcy5TRUNUSU9OX1VOTEVTUyxcblx0XHRcdFx0XHRcdFx0ZjogaXRlbS5sXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Ly8gY29weSB0aGUgY29uZGl0aW9uYWwgYmFzZWQgb24gaXRzIHR5cGVcblx0XHRcdFx0XHRcdGlmICggaXRlbS5yICkge1xuXHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay5yID0gaXRlbS5yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLnggKSB7XG5cdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnggPSBpdGVtLng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0ucnggKSB7XG5cdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnJ4ID0gaXRlbS5yeDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSArIDEsIDAsIHVubGVzc0Jsb2NrICk7XG5cdFx0XHRcdFx0XHRkZWxldGUgaXRlbS5sO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDbGVhbiB1cCBlbGVtZW50IGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCBpdGVtLmEgKSB7XG5cdFx0XHRcdFx0Zm9yICgga2V5IGluIGl0ZW0uYSApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbS5hLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB0eXBlb2YgaXRlbS5hWyBrZXkgXSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFudXAoIGl0ZW0uYVsga2V5IF0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBmaW5hbCBwYXNzIC0gZnVzZSB0ZXh0IG5vZGVzIHRvZ2V0aGVyXG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpICsgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdICsgaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGkgKyAxLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXByZXNlcnZlV2hpdGVzcGFjZSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdLnJlcGxhY2UoIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCAnICcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpdGVtc1sgaSBdID09PSAnJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldERlbGltaXRlcnMoIHNvdXJjZSApIHtcblx0XHRcdHZhciB0YXJnZXQgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggdGFyZ2V0ID09PSB2b2lkIDAgKVxuXHRcdFx0XHR0YXJnZXQgPSBzb3VyY2U7XG5cdFx0XHR0YXJnZXQuZGVsaW1pdGVycyA9IHNvdXJjZS5kZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0J3t7Jyxcblx0XHRcdFx0J319J1xuXHRcdFx0XTtcblx0XHRcdHRhcmdldC50cmlwbGVEZWxpbWl0ZXJzID0gc291cmNlLnRyaXBsZURlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQne3t7Jyxcblx0XHRcdFx0J319fSdcblx0XHRcdF07XG5cdFx0XHR0YXJnZXQuc3RhdGljRGVsaW1pdGVycyA9IHNvdXJjZS5zdGF0aWNEZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0J1tbJyxcblx0XHRcdFx0J11dJ1xuXHRcdFx0XTtcblx0XHRcdHRhcmdldC5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzID0gc291cmNlLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQnW1tbJyxcblx0XHRcdFx0J11dXSdcblx0XHRcdF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIFBhcnNlciwgbXVzdGFjaGUsIGNvbW1lbnQsIGVsZW1lbnQsIHRleHQsIHRyaW1XaGl0ZXNwYWNlLCBzdHJpcFN0YW5kYWxvbmVzLCBlc2NhcGVSZWdFeHAgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvb3B0aW9uR3JvdXAuanMgKi9cblx0dmFyIG9wdGlvbkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlT3B0aW9uR3JvdXAoIGtleXMsIGNvbmZpZyApIHtcblx0XHRcdHZhciBncm91cCA9IGtleXMubWFwKCBjb25maWcgKTtcblx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSwgaSApIHtcblx0XHRcdFx0Z3JvdXBbIGtleSBdID0gZ3JvdXBbIGkgXTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBncm91cDtcblx0XHR9O1xuXHR9KCBsZWdhY3kgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvcGFyc2VPcHRpb25zLmpzICovXG5cdHZhciBwYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiggb3B0aW9uR3JvdXAgKSB7XG5cblx0XHR2YXIga2V5cywgcGFyc2VPcHRpb25zO1xuXHRcdGtleXMgPSBbXG5cdFx0XHQncHJlc2VydmVXaGl0ZXNwYWNlJyxcblx0XHRcdCdzYW5pdGl6ZScsXG5cdFx0XHQnc3RyaXBDb21tZW50cycsXG5cdFx0XHQnZGVsaW1pdGVycycsXG5cdFx0XHQndHJpcGxlRGVsaW1pdGVycycsXG5cdFx0XHQnaW50ZXJwb2xhdGUnXG5cdFx0XTtcblx0XHRwYXJzZU9wdGlvbnMgPSBvcHRpb25Hcm91cCgga2V5cywgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fSApO1xuXHRcdHJldHVybiBwYXJzZU9wdGlvbnM7XG5cdH0oIG9wdGlvbkdyb3VwICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvdGVtcGxhdGUvcGFyc2VyLmpzICovXG5cdHZhciBwYXJzZXIgPSBmdW5jdGlvbiggZXJyb3JzLCBpc0NsaWVudCwgcGFyc2UsIGNyZWF0ZSwgcGFyc2VPcHRpb25zICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHtcblx0XHRcdHBhcnNlOiBkb1BhcnNlLFxuXHRcdFx0ZnJvbUlkOiBmcm9tSWQsXG5cdFx0XHRpc0hhc2hlZElkOiBpc0hhc2hlZElkLFxuXHRcdFx0aXNQYXJzZWQ6IGlzUGFyc2VkLFxuXHRcdFx0Z2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsXG5cdFx0XHRjcmVhdGVIZWxwZXI6IGNyZWF0ZUhlbHBlclxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVIZWxwZXIoIHBhcnNlT3B0aW9ucyApIHtcblx0XHRcdHZhciBoZWxwZXIgPSBjcmVhdGUoIHBhcnNlciApO1xuXHRcdFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24oIHRlbXBsYXRlLCBvcHRpb25zICkge1xuXHRcdFx0XHRyZXR1cm4gZG9QYXJzZSggdGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhlbHBlcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb1BhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zICkge1xuXHRcdFx0aWYgKCAhcGFyc2UgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JzLm1pc3NpbmdQYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJzZSggdGVtcGxhdGUsIHBhcnNlT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tSWQoIGlkLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjJyArIGlkICsgJyBhcyBSYWN0aXZlIGlzIG5vdCBydW5uaW5nIGluIGEgYnJvd3Nlci4nICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGlzSGFzaGVkSWQoIGlkICkgKSB7XG5cdFx0XHRcdGlkID0gaWQuc3Vic3RyaW5nKCAxICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEoIHRlbXBsYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlkICkgKSApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICMnICsgaWQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGVtcGxhdGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnU0NSSVBUJyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICMnICsgaWQgKyAnLCBtdXN0IGJlIGEgPHNjcmlwdD4gZWxlbWVudCcgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNIYXNoZWRJZCggaWQgKSB7XG5cdFx0XHRyZXR1cm4gaWQgJiYgaWQuY2hhckF0KCAwICkgPT09ICcjJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1BhcnNlZCggdGVtcGxhdGUgKSB7XG5cdFx0XHRyZXR1cm4gISggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApIHtcblx0XHRcdC8vIENvdWxkIGJlIFJhY3RpdmUgb3IgYSBDb21wb25lbnRcblx0XHRcdGlmICggcmFjdGl2ZS5kZWZhdWx0cyApIHtcblx0XHRcdFx0cmFjdGl2ZSA9IHJhY3RpdmUuZGVmYXVsdHM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyc2VPcHRpb25zLnJlZHVjZSggZnVuY3Rpb24oIHZhbCwga2V5ICkge1xuXHRcdFx0XHR2YWxbIGtleSBdID0gcmFjdGl2ZVsga2V5IF07XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9LCB7fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyc2VyO1xuXHR9KCBlcnJvcnMsIGlzQ2xpZW50LCBwYXJzZSwgY3JlYXRlLCBwYXJzZU9wdGlvbnMgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy90ZW1wbGF0ZS90ZW1wbGF0ZS5qcyAqL1xuXHR2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbiggcGFyc2VyLCBwYXJzZSApIHtcblxuXHRcdHZhciB0ZW1wbGF0ZUNvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICd0ZW1wbGF0ZScsXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBleGlzdHNcblx0XHRcdFx0aWYgKCAndGVtcGxhdGUnIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcHJvdG8gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiBpbml0KCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZSwgZm47XG5cdFx0XHRcdC8vIFRPRE8gYmVjYXVzZSBvZiBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB3ZSBtaWdodCBqdXN0IGJlIGFibGUgdG8gdXNlXG5cdFx0XHRcdC8vIHJhY3RpdmUudGVtcGxhdGUsIGFuZCBub3QgYm90aGVyIHBhc3NpbmcgdGhyb3VnaCB0aGUgUGFyZW50IG9iamVjdC5cblx0XHRcdFx0Ly8gQXQgcHJlc2VudCB0aGF0IGJyZWFrcyB0aGUgdGVzdCBtb2NrcycgZXhwZWN0YXRpb25zXG5cdFx0XHRcdHRlbXBsYXRlID0gJ3RlbXBsYXRlJyBpbiBvcHRpb25zID8gb3B0aW9ucy50ZW1wbGF0ZSA6IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGZuID0gdGVtcGxhdGU7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGZuICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuXHRcdFx0XHRcdFx0Zm46IGZuLFxuXHRcdFx0XHRcdFx0cmVzdWx0OiB0ZW1wbGF0ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcmFjdGl2ZSApO1xuXHRcdFx0XHQvLyBUT0RPIHRoZSBuYW1pbmcgb2YgdGhpcyBpcyBjb25mdXNpbmcgLSByYWN0aXZlLnRlbXBsYXRlIHJlZmVycyB0byBbLi4uXSxcblx0XHRcdFx0Ly8gYnV0IENvbXBvbmVudC5wcm90b3R5cGUudGVtcGxhdGUgcmVmZXJzIHRvIHt2OjEsdDpbXSxwOltdfS4uLlxuXHRcdFx0XHQvLyBpdCdzIHVubmVjZXNzYXJ5LCBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgbmV2ZXIgbmVlZHMgdG8gYWNjZXNzXG5cdFx0XHRcdC8vIHJhY3RpdmUudGVtcGxhdGVcblx0XHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHRlbXBsYXRlLnQ7XG5cdFx0XHRcdGlmICggdGVtcGxhdGUucCApIHtcblx0XHRcdFx0XHRleHRlbmRQYXJ0aWFscyggcmFjdGl2ZS5wYXJ0aWFscywgdGVtcGxhdGUucCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gcmVzZXRWYWx1ZSggcmFjdGl2ZSApLFxuXHRcdFx0XHRcdHBhcnNlZDtcblx0XHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gcGFyc2VJZlN0cmluZyggcmVzdWx0LCByYWN0aXZlICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHBhcnNlZC50O1xuXHRcdFx0XHRcdGV4dGVuZFBhcnRpYWxzKCByYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc2V0VmFsdWUoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgaW5pdGlhbCA9IHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSxcblx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0Ly8gSWYgdGhpcyBpc24ndCBhIGR5bmFtaWMgdGVtcGxhdGUsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuXHRcdFx0aWYgKCAhaW5pdGlhbCB8fCAhaW5pdGlhbC5mbiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBpbml0aWFsLmZuICk7XG5cdFx0XHQvLyBUT0RPIGRlZXAgZXF1YWxpdHkgY2hlY2sgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJpbmdcblx0XHRcdC8vIGluIHRoZSBjYXNlIG9mIGFscmVhZHktcGFyc2VkIHRlbXBsYXRlc1xuXHRcdFx0aWYgKCByZXN1bHQgIT09IGluaXRpYWwucmVzdWx0ICkge1xuXHRcdFx0XHRpbml0aWFsLnJlc3VsdCA9IHJlc3VsdDtcblx0XHRcdFx0cmVzdWx0ID0gcGFyc2VJZlN0cmluZyggcmVzdWx0LCByYWN0aXZlICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBmbiApIHtcblx0XHRcdHZhciBoZWxwZXIgPSBwYXJzZXIuY3JlYXRlSGVscGVyKCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdHJldHVybiBmbi5jYWxsKCByYWN0aXZlLCByYWN0aXZlLmRhdGEsIGhlbHBlciApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSWZTdHJpbmcoIHRlbXBsYXRlLCByYWN0aXZlICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHQvLyBJRCBvZiBhbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlP1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlWyAwIF0gPT09ICcjJyApIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlci5mcm9tSWQoIHRlbXBsYXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZSggdGVtcGxhdGUsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUudiAhPT0gMSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWlzbWF0Y2hlZCB0ZW1wbGF0ZSB2ZXJzaW9uISBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIFJhY3RpdmUuanMgaW4geW91ciBidWlsZCBwcm9jZXNzIGFzIHdlbGwgYXMgaW4geW91ciBhcHAnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGVtcGxhdGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kUGFydGlhbHMoIGV4aXN0aW5nUGFydGlhbHMsIG5ld1BhcnRpYWxzLCBvdmVyd3JpdGUgKSB7XG5cdFx0XHRpZiAoICFuZXdQYXJ0aWFscyApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdC8vIFRPRE8gdGhlcmUncyBhbiBhbWJpZ3VpdHkgaGVyZSAtIHdlIG5lZWQgdG8gb3ZlcndyaXRlIGluIHRoZSBgcmVzZXQoKWBcblx0XHRcdC8vIGNhc2UsIGJ1dCBub3QgaW5pdGlhbGx5Li4uXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIG5ld1BhcnRpYWxzICkge1xuXHRcdFx0XHRpZiAoIG92ZXJ3cml0ZSB8fCAhZXhpc3RpbmdQYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0ZXhpc3RpbmdQYXJ0aWFsc1sga2V5IF0gPSBuZXdQYXJ0aWFsc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRlbXBsYXRlQ29uZmlnO1xuXHR9KCBwYXJzZXIsIHBhcnNlICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvUmVnaXN0cnkuanMgKi9cblx0dmFyIFJlZ2lzdHJ5ID0gZnVuY3Rpb24oIGNyZWF0ZSApIHtcblxuXHRcdGZ1bmN0aW9uIFJlZ2lzdHJ5KCBuYW1lLCB1c2VEZWZhdWx0cyApIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnVzZURlZmF1bHRzID0gdXNlRGVmYXVsdHM7XG5cdFx0fVxuXHRcdFJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcblx0XHRcdGNvbnN0cnVjdG9yOiBSZWdpc3RyeSxcblx0XHRcdGV4dGVuZDogZnVuY3Rpb24oIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJlKCB0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCB0aGlzLnVzZURlZmF1bHRzID8gcHJvdG8gOiBwcm90by5jb25zdHJ1Y3Rvciwgb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJlKCB0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0Y29uZmlndXJlOiBmdW5jdGlvbiggUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdGhpcy5uYW1lLFxuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIG5hbWUgXSxcblx0XHRcdFx0XHRyZWdpc3RyeTtcblx0XHRcdFx0cmVnaXN0cnkgPSBjcmVhdGUoIFBhcmVudFsgbmFtZSBdICk7XG5cdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9uICkge1xuXHRcdFx0XHRcdHJlZ2lzdHJ5WyBrZXkgXSA9IG9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSByZWdpc3RyeTtcblx0XHRcdH0sXG5cdFx0XHRyZXNldDogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHZhciByZWdpc3RyeSA9IHJhY3RpdmVbIHRoaXMubmFtZSBdO1xuXHRcdFx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRPYmplY3Qua2V5cyggcmVnaXN0cnkgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gcmVnaXN0cnlbIGtleSBdO1xuXHRcdFx0XHRcdGlmICggaXRlbS5fZm4gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0uX2ZuLmlzT3duZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHJlZ2lzdHJ5WyBrZXkgXSA9IGl0ZW0uX2ZuO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHJlZ2lzdHJ5WyBrZXkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdH0sXG5cdFx0XHRmaW5kT3duZXI6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiByYWN0aXZlWyB0aGlzLm5hbWUgXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgPyByYWN0aXZlIDogdGhpcy5maW5kQ29uc3RydWN0b3IoIHJhY3RpdmUuY29uc3RydWN0b3IsIGtleSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGNvbnN0cnVjdG9yLCBrZXkgKSB7XG5cdFx0XHRcdGlmICggIWNvbnN0cnVjdG9yICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29uc3RydWN0b3JbIHRoaXMubmFtZSBdLmhhc093blByb3BlcnR5KCBrZXkgKSA/IGNvbnN0cnVjdG9yIDogdGhpcy5maW5kQ29uc3RydWN0b3IoIGNvbnN0cnVjdG9yLl9wYXJlbnQsIGtleSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmQ6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdHJldHVybiByWyB0aGlzJDAubmFtZSBdWyBrZXkgXTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRJbnN0YW5jZTogZnVuY3Rpb24oIHJhY3RpdmUsIGtleSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJbIHRoaXMkMC5uYW1lIF1bIGtleSBdID8gciA6IHZvaWQgMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZm4gKSB7XG5cdFx0XHR2YXIgZmluZCwgcGFyZW50O1xuXHRcdFx0aWYgKCBmaW5kID0gZm4oIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZpbmQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFyYWN0aXZlLmlzb2xhdGVkICYmICggcGFyZW50ID0gcmFjdGl2ZS5fcGFyZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcGFyZW50LCBmbiApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gUmVnaXN0cnk7XG5cdH0oIGNyZWF0ZSwgbGVnYWN5ICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL3JlZ2lzdHJpZXMuanMgKi9cblx0dmFyIHJlZ2lzdHJpZXMgPSBmdW5jdGlvbiggb3B0aW9uR3JvdXAsIFJlZ2lzdHJ5ICkge1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHRcdCdhZGFwdG9ycycsXG5cdFx0XHRcdCdjb21wb25lbnRzJyxcblx0XHRcdFx0J2NvbXB1dGVkJyxcblx0XHRcdFx0J2RlY29yYXRvcnMnLFxuXHRcdFx0XHQnZWFzaW5nJyxcblx0XHRcdFx0J2V2ZW50cycsXG5cdFx0XHRcdCdpbnRlcnBvbGF0b3JzJyxcblx0XHRcdFx0J3BhcnRpYWxzJyxcblx0XHRcdFx0J3RyYW5zaXRpb25zJ1xuXHRcdFx0XSxcblx0XHRcdHJlZ2lzdHJpZXMgPSBvcHRpb25Hcm91cCgga2V5cywgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdpc3RyeSgga2V5LCBrZXkgPT09ICdjb21wdXRlZCcgKTtcblx0XHRcdH0gKTtcblx0XHRyZXR1cm4gcmVnaXN0cmllcztcblx0fSggb3B0aW9uR3JvdXAsIFJlZ2lzdHJ5ICk7XG5cblx0LyogdXRpbHMvbm9vcC5qcyAqL1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyogdXRpbHMvd3JhcFByb3RvdHlwZU1ldGhvZC5qcyAqL1xuXHR2YXIgd3JhcFByb3RvdHlwZU1ldGhvZCA9IGZ1bmN0aW9uKCBub29wICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gd3JhcCggcGFyZW50LCBuYW1lLCBtZXRob2QgKSB7XG5cdFx0XHRpZiAoICEvX3N1cGVyLy50ZXN0KCBtZXRob2QgKSApIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZDtcblx0XHRcdH1cblx0XHRcdHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcFN1cGVyKCkge1xuXHRcdFx0XHR2YXIgc3VwZXJNZXRob2QgPSBnZXRTdXBlck1ldGhvZCggd3JhcHBlci5fcGFyZW50LCBuYW1lICksXG5cdFx0XHRcdFx0aGFzU3VwZXIgPSAnX3N1cGVyJyBpbiB0aGlzLFxuXHRcdFx0XHRcdG9sZFN1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXHRcdFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRpZiAoIGhhc1N1cGVyICkge1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gb2xkU3VwZXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3N1cGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5fcGFyZW50ID0gcGFyZW50O1xuXHRcdFx0d3JhcHBlci5fbWV0aG9kID0gbWV0aG9kO1xuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFN1cGVyTWV0aG9kKCBwYXJlbnQsIG5hbWUgKSB7XG5cdFx0XHR2YXIgbWV0aG9kO1xuXHRcdFx0aWYgKCBuYW1lIGluIHBhcmVudCApIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyZW50WyBuYW1lIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdG1ldGhvZCA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1ldGhvZCA9IGZ1bmN0aW9uIHJldHVyblZhbHVlKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1ldGhvZCA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIG5vb3AgKTtcblxuXHQvKiBjb25maWcvZGVwcmVjYXRlLmpzICovXG5cdHZhciBkZXByZWNhdGUgPSBmdW5jdGlvbiggd2FybiwgaXNBcnJheSApIHtcblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZSggb3B0aW9ucywgZGVwcmVjYXRlZCwgY29ycmVjdCApIHtcblx0XHRcdGlmICggZGVwcmVjYXRlZCBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoICEoIGNvcnJlY3QgaW4gb3B0aW9ucyApICkge1xuXHRcdFx0XHRcdHdhcm4oIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QgKSApO1xuXHRcdFx0XHRcdG9wdGlvbnNbIGNvcnJlY3QgXSA9IG9wdGlvbnNbIGRlcHJlY2F0ZWQgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QsIHRydWUgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCwgaXNFcnJvciApIHtcblx0XHRcdHJldHVybiAnb3B0aW9ucy4nICsgZGVwcmVjYXRlZCArICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0aW9ucy4nICsgY29ycmVjdCArICcuJyArICggaXNFcnJvciA/ICcgWW91IGNhbm5vdCBzcGVjaWZ5IGJvdGggb3B0aW9ucywgcGxlYXNlIHVzZSBvcHRpb25zLicgKyBjb3JyZWN0ICsgJy4nIDogJycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGVFdmVudERlZmluaXRpb25zKCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnZXZlbnREZWZpbml0aW9ucycsICdldmVudHMnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlQWRhcHRvcnMoIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBVc2luZyBleHRlbmQgd2l0aCBDb21wb25lbnQgaW5zdGVhZCBvZiBvcHRpb25zLFxuXHRcdFx0Ly8gbGlrZSBIdW1hbi5leHRlbmQoIFNwaWRlciApIG1lYW5zIGFkYXB0b3JzIGFzIGEgcmVnaXN0cnlcblx0XHRcdC8vIGdldHMgY29waWVkIHRvIG9wdGlvbnMuIFNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgYWN0dWFsbHkgYW4gYXJyYXlcblx0XHRcdGlmICggaXNBcnJheSggb3B0aW9ucy5hZGFwdG9ycyApICkge1xuXHRcdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdhZGFwdG9ycycsICdhZGFwdCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdiZWZvcmVJbml0JywgJ29uY29uc3RydWN0JyApO1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnaW5pdCcsICdvbnJlbmRlcicgKTtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2NvbXBsZXRlJywgJ29uY29tcGxldGUnICk7XG5cdFx0XHRkZXByZWNhdGVFdmVudERlZmluaXRpb25zKCBvcHRpb25zICk7XG5cdFx0XHRkZXByZWNhdGVBZGFwdG9ycyggb3B0aW9ucyApO1xuXHRcdH07XG5cdH0oIHdhcm4sIGlzQXJyYXkgKTtcblxuXHQvKiBjb25maWcvY29uZmlnLmpzICovXG5cdHZhciBjb25maWcgPSBmdW5jdGlvbiggY3NzLCBkYXRhLCBkZWZhdWx0cywgdGVtcGxhdGUsIHBhcnNlT3B0aW9ucywgcmVnaXN0cmllcywgd3JhcFByb3RvdHlwZSwgZGVwcmVjYXRlICkge1xuXG5cdFx0dmFyIGN1c3RvbSwgb3B0aW9ucywgY29uZmlnLCBibGFja2xpc3RlZDtcblx0XHQvLyB3b3VsZCBiZSBuaWNlIHRvIG5vdCBoYXZlIHRoZXNlIGhlcmUsXG5cdFx0Ly8gdGhleSBnZXQgYWRkZWQgZHVyaW5nIGluaXRpYWxpc2UsIHNvIGZvciBub3cgd2UgaGF2ZVxuXHRcdC8vIHRvIG1ha2Ugc3VyZSBub3QgdG8gdHJ5IGFuZCBleHRlbmQgdGhlbS5cblx0XHQvLyBQb3NzaWJseSwgd2UgY291bGQgcmUtb3JkZXIgYW5kIG5vdCBhZGQgdGlsbCBsYXRlclxuXHRcdC8vIGluIHByb2Nlc3MuXG5cdFx0YmxhY2tsaXN0ZWQgPSB7XG5cdFx0XHQnX3BhcmVudCc6IHRydWUsXG5cdFx0XHQnX2NvbXBvbmVudCc6IHRydWVcblx0XHR9O1xuXHRcdGN1c3RvbSA9IHtcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRjc3M6IGNzc1xuXHRcdH07XG5cdFx0b3B0aW9ucyA9IE9iamVjdC5rZXlzKCBkZWZhdWx0cyApLmZpbHRlciggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiAhcmVnaXN0cmllc1sga2V5IF0gJiYgIWN1c3RvbVsga2V5IF0gJiYgIXBhcnNlT3B0aW9uc1sga2V5IF07XG5cdFx0fSApO1xuXHRcdC8vIHRoaXMgZGVmaW5lcyB0aGUgb3JkZXI6XG5cdFx0Y29uZmlnID0gW10uY29uY2F0KCBjdXN0b20uZGF0YSwgcGFyc2VPcHRpb25zLCBvcHRpb25zLCByZWdpc3RyaWVzLCBjdXN0b20udGVtcGxhdGUsIGN1c3RvbS5jc3MgKTtcblx0XHRmb3IgKCB2YXIga2V5IGluIGN1c3RvbSApIHtcblx0XHRcdGNvbmZpZ1sga2V5IF0gPSBjdXN0b21bIGtleSBdO1xuXHRcdH1cblx0XHQvLyBmb3IgaXRlcmF0aW9uXG5cdFx0Y29uZmlnLmtleXMgPSBPYmplY3Qua2V5cyggZGVmYXVsdHMgKS5jb25jYXQoIHJlZ2lzdHJpZXMubWFwKCBmdW5jdGlvbiggciApIHtcblx0XHRcdHJldHVybiByLm5hbWU7XG5cdFx0fSApICkuY29uY2F0KCBbICdjc3MnIF0gKTtcblx0XHQvLyBhZGQgdGhlc2UgdG8gYmxhY2tsaXN0ZWQga2V5J3MgdGhhdCB3ZSBkb24ndCBkb3VibGUgZXh0ZW5kXG5cdFx0Y29uZmlnLmtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBibGFja2xpc3RlZFsga2V5IF0gPSB0cnVlO1xuXHRcdH0gKTtcblx0XHRjb25maWcucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuXHRcdGNvbmZpZy5yZWdpc3RyaWVzID0gcmVnaXN0cmllcztcblxuXHRcdGZ1bmN0aW9uIGN1c3RvbUNvbmZpZyggbWV0aG9kLCBrZXksIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRjdXN0b21bIGtleSBdWyBtZXRob2QgXSggUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0XHRjb25maWcuZXh0ZW5kID0gZnVuY3Rpb24oIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRjb25maWd1cmUoICdleHRlbmQnLCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRjb25maWcuaW5pdCA9IGZ1bmN0aW9uKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRjb25maWd1cmUoICdpbml0JywgUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzU3RhbmRhcmREZWZhdWx0S2V5KCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4ga2V5IGluIGRlZmF1bHRzICYmICEoIGtleSBpbiBjb25maWcucGFyc2VPcHRpb25zICkgJiYgISgga2V5IGluIGN1c3RvbSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbmZpZ3VyZSggbWV0aG9kLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ2RhdGEnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRjb25maWcucGFyc2VPcHRpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdGlmICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2VbIGtleSBdID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBpc1N0YW5kYXJkRGVmYXVsdEtleSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdFx0aW5zdGFuY2VbIGtleSBdID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcFByb3RvdHlwZSggUGFyZW50LnByb3RvdHlwZSwga2V5LCB2YWx1ZSApIDogdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbmZpZy5yZWdpc3RyaWVzLmZvckVhY2goIGZ1bmN0aW9uKCByZWdpc3RyeSApIHtcblx0XHRcdFx0cmVnaXN0cnlbIG1ldGhvZCBdKCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ3RlbXBsYXRlJywgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdFx0Y3VzdG9tQ29uZmlnKCBtZXRob2QsICdjc3MnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRleHRlbmRPdGhlck1ldGhvZHMoIFBhcmVudC5wcm90b3R5cGUsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kT3RoZXJNZXRob2RzKCBwYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoICEoIGtleSBpbiBibGFja2xpc3RlZCApICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHZhciBtZW1iZXIgPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIHRoYXQgb3ZlcndyaXRlcyBhIG1ldGhvZCwgd3JhcCBpdDpcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBtZW1iZXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRtZW1iZXIgPSB3cmFwUHJvdG90eXBlKCBwYXJlbnQsIGtleSwgbWVtYmVyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc3RhbmNlWyBrZXkgXSA9IG1lbWJlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25maWcucmVzZXQgPSBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdHJldHVybiBjb25maWcuZmlsdGVyKCBmdW5jdGlvbiggYyApIHtcblx0XHRcdFx0cmV0dXJuIGMucmVzZXQgJiYgYy5yZXNldCggcmFjdGl2ZSApO1xuXHRcdFx0fSApLm1hcCggZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHRcdHJldHVybiBjLm5hbWU7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRjb25maWcuZ2V0Q29uc3RydWN0VGFyZ2V0ID0gZnVuY3Rpb24oIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMub25jb25zdHJ1Y3QgKSB7XG5cdFx0XHRcdC8vIHByZXRlbmQgdGhpcyBvYmplY3QgbGl0ZXJhbCBpcyB0aGUgcmFjdGl2ZSBpbnN0YW5jZVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG9uY29uc3RydWN0OiB3cmFwUHJvdG90eXBlKCByYWN0aXZlLCAnb25jb25zdHJ1Y3QnLCBvcHRpb25zLm9uY29uc3RydWN0ICkuYmluZCggcmFjdGl2ZSApLFxuXHRcdFx0XHRcdGZpcmU6IHJhY3RpdmUuZmlyZS5iaW5kKCByYWN0aXZlIClcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByYWN0aXZlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIGNvbmZpZztcblx0fSggY3NzLCBkYXRhLCBvcHRpb25zLCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zLCByZWdpc3RyaWVzLCB3cmFwUHJvdG90eXBlTWV0aG9kLCBkZXByZWNhdGUgKTtcblxuXHQvKiBzaGFyZWQvaW50ZXJwb2xhdGUuanMgKi9cblx0dmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oIGNpcmN1bGFyLCB3YXJuLCBpbnRlcnBvbGF0b3JzLCBjb25maWcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oIGZyb20sIHRvLCByYWN0aXZlLCB0eXBlICkge1xuXHRcdFx0aWYgKCBmcm9tID09PSB0byApIHtcblx0XHRcdFx0cmV0dXJuIHNuYXAoIHRvICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGUgKSB7XG5cdFx0XHRcdHZhciBpbnRlcnBvbCA9IGNvbmZpZy5yZWdpc3RyaWVzLmludGVycG9sYXRvcnMuZmluZCggcmFjdGl2ZSwgdHlwZSApO1xuXHRcdFx0XHRpZiAoIGludGVycG9sICkge1xuXHRcdFx0XHRcdHJldHVybiBpbnRlcnBvbCggZnJvbSwgdG8gKSB8fCBzbmFwKCB0byApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdhcm4oICdNaXNzaW5nIFwiJyArIHR5cGUgKyAnXCIgaW50ZXJwb2xhdG9yLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gZnJvbSBbVE9ET10nICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW50ZXJwb2xhdG9ycy5udW1iZXIoIGZyb20sIHRvICkgfHwgaW50ZXJwb2xhdG9ycy5hcnJheSggZnJvbSwgdG8gKSB8fCBpbnRlcnBvbGF0b3JzLm9iamVjdCggZnJvbSwgdG8gKSB8fCBzbmFwKCB0byApO1xuXHRcdH07XG5cdFx0Y2lyY3VsYXIuaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcblx0XHRfX2V4cG9ydCA9IGludGVycG9sYXRlO1xuXG5cdFx0ZnVuY3Rpb24gc25hcCggdG8gKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0bztcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIHdhcm4sIGludGVycG9sYXRvcnMsIGNvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2FuaW1hdGUvQW5pbWF0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJGFuaW1hdGVfQW5pbWF0aW9uID0gZnVuY3Rpb24oIHdhcm4sIHJ1bmxvb3AsIGludGVycG9sYXRlICkge1xuXG5cdFx0dmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGtleTtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdC8vIGZyb20gYW5kIHRvXG5cdFx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmludGVycG9sYXRvciA9IGludGVycG9sYXRlKCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMucm9vdCwgdGhpcy5pbnRlcnBvbGF0b3IgKTtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0XHR0aGlzLnRpY2soKTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHR0aWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsYXBzZWQsIHQsIHZhbHVlLCB0aW1lTm93LCBpbmRleCwga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblx0XHRcdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0dGltZU5vdyA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0ZWxhcHNlZCA9IHRpbWVOb3cgLSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdFx0XHRpZiAoIGVsYXBzZWQgPj0gdGhpcy5kdXJhdGlvbiApIHtcblx0XHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGVwKCAxLCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlKCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHR3YXJuKCAnQW5pbWF0aW9uIHdhcyBub3QgZm91bmQnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHQgPSB0aGlzLmVhc2luZyA/IHRoaXMuZWFzaW5nKCBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbiApIDogZWxhcHNlZCAvIHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmludGVycG9sYXRvciggdCApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGVwKCB0LCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHdhcm4oICdBbmltYXRpb24gd2FzIG5vdCBmb3VuZCcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIEFuaW1hdGlvbjtcblx0fSggd2FybiwgcnVubG9vcCwgaW50ZXJwb2xhdGUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9hbmltYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJGFuaW1hdGUgPSBmdW5jdGlvbiggaXNFcXVhbCwgUHJvbWlzZSwgbm9ybWFsaXNlS2V5cGF0aCwgYW5pbWF0aW9ucywgQW5pbWF0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdG5vQW5pbWF0aW9uID0ge1xuXHRcdFx0XHRzdG9wOiBub29wXG5cdFx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gUmFjdGl2ZSRhbmltYXRlKCBrZXlwYXRoLCB0bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlLCBrLCBhbmltYXRpb24sIGFuaW1hdGlvbnMsIGVhc2luZywgZHVyYXRpb24sIHN0ZXAsIGNvbXBsZXRlLCBtYWtlVmFsdWVDb2xsZWN0b3IsIGN1cnJlbnRWYWx1ZXMsIGNvbGxlY3RWYWx1ZSwgZHVtbXksIGR1bW15T3B0aW9ucztcblx0XHRcdHByb21pc2UgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCApIHtcblx0XHRcdFx0ZnVsZmlsUHJvbWlzZSA9IGZ1bGZpbDtcblx0XHRcdH0gKTtcblx0XHRcdC8vIGFuaW1hdGUgbXVsdGlwbGUga2V5cGF0aHNcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRvcHRpb25zID0gdG8gfHwge307XG5cdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHRcdGFuaW1hdGlvbnMgPSBbXTtcblx0XHRcdFx0Ly8gd2UgZG9uJ3Qgd2FudCB0byBwYXNzIHRoZSBgc3RlcGAgYW5kIGBjb21wbGV0ZWAgaGFuZGxlcnMsIGFzIHRoZXkgd2lsbFxuXHRcdFx0XHQvLyBydW4gZm9yIGVhY2ggYW5pbWF0aW9uISBTbyBpbnN0ZWFkIHdlJ2xsIHN0b3JlIHRoZSBoYW5kbGVycyBhbmQgY3JlYXRlXG5cdFx0XHRcdC8vIG91ciBvd24uLi5cblx0XHRcdFx0c3RlcCA9IG9wdGlvbnMuc3RlcDtcblx0XHRcdFx0Y29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXHRcdFx0XHRpZiAoIHN0ZXAgfHwgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0Y3VycmVudFZhbHVlcyA9IHt9O1xuXHRcdFx0XHRcdG9wdGlvbnMuc3RlcCA9IG51bGw7XG5cdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IG51bGw7XG5cdFx0XHRcdFx0bWFrZVZhbHVlQ29sbGVjdG9yID0gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQsIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50VmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBrIGluIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoLmhhc093blByb3BlcnR5KCBrICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0ZXAgfHwgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbGxlY3RWYWx1ZSA9IG1ha2VWYWx1ZUNvbGxlY3RvciggayApO1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRcdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvblxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRpZiAoIHN0ZXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gY29sbGVjdFZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gY29tcGxldGUgPyBjb2xsZWN0VmFsdWUgOiBub29wO1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBhbmltYXRlKCB0aGlzLCBrLCBrZXlwYXRoWyBrIF0sIG9wdGlvbnMgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDcmVhdGUgYSBkdW1teSBhbmltYXRpb24sIHRvIGZhY2lsaXRhdGUgc3RlcC9jb21wbGV0ZVxuXHRcdFx0XHQvLyBjYWxsYmFja3MsIGFuZCBQcm9taXNlIGZ1bGZpbG1lbnRcblx0XHRcdFx0ZHVtbXlPcHRpb25zID0ge1xuXHRcdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuXHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIHN0ZXAgKSB7XG5cdFx0XHRcdFx0ZHVtbXlPcHRpb25zLnN0ZXAgPSBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRcdHN0ZXAoIHQsIGN1cnJlbnRWYWx1ZXMgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRcdGNvbXBsZXRlKCB0LCBjdXJyZW50VmFsdWVzICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGR1bW15T3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cdFx0XHRcdGR1bW15ID0gYW5pbWF0ZSggdGhpcywgbnVsbCwgbnVsbCwgZHVtbXlPcHRpb25zICk7XG5cdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggZHVtbXkgKTtcblx0XHRcdFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGFuaW1hdGlvbjtcblx0XHRcdFx0XHR3aGlsZSAoIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGR1bW15ICkge1xuXHRcdFx0XHRcdFx0ZHVtbXkuc3RvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbmltYXRlIGEgc2luZ2xlIGtleXBhdGhcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0aWYgKCBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0ZSggdGhpcywga2V5cGF0aCwgdG8sIG9wdGlvbnMgKTtcblx0XHRcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhbmltYXRlKCByb290LCBrZXlwYXRoLCB0bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBlYXNpbmcsIGR1cmF0aW9uLCBhbmltYXRpb24sIGZyb207XG5cdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGZyb20gPSByb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdC8vIGNhbmNlbCBhbnkgZXhpc3RpbmcgYW5pbWF0aW9uXG5cdFx0XHQvLyBUT0RPIHdoYXQgYWJvdXQgdXBzdHJlYW0vZG93bnN0cmVhbSBrZXlwYXRocz9cblx0XHRcdGFuaW1hdGlvbnMuYWJvcnQoIGtleXBhdGgsIHJvb3QgKTtcblx0XHRcdC8vIGRvbid0IGJvdGhlciBhbmltYXRpbmcgdmFsdWVzIHRoYXQgc3RheSB0aGUgc2FtZVxuXHRcdFx0aWYgKCBpc0VxdWFsKCBmcm9tLCB0byApICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSggb3B0aW9ucy50byApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub0FuaW1hdGlvbjtcblx0XHRcdH1cblx0XHRcdC8vIGVhc2luZyBmdW5jdGlvblxuXHRcdFx0aWYgKCBvcHRpb25zLmVhc2luZyApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gcm9vdC5lYXNpbmdbIG9wdGlvbnMuZWFzaW5nIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0eXBlb2YgZWFzaW5nICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGVhc2luZyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGR1cmF0aW9uXG5cdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDQwMCA6IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHQvLyBUT0RPIHN0b3JlIGtleXMsIHVzZSBhbiBpbnRlcm5hbCBzZXQgbWV0aG9kXG5cdFx0XHRhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCB7XG5cdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG5cdFx0XHRcdGZyb206IGZyb20sXG5cdFx0XHRcdHRvOiB0byxcblx0XHRcdFx0cm9vdDogcm9vdCxcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0aW50ZXJwb2xhdG9yOiBvcHRpb25zLmludGVycG9sYXRvcixcblx0XHRcdFx0Ly8gVE9ETyB3cmFwIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnksIHRvIHVzZSBpbnN0YW5jZSBhcyBjb250ZXh0XG5cdFx0XHRcdHN0ZXA6IG9wdGlvbnMuc3RlcCxcblx0XHRcdFx0Y29tcGxldGU6IG9wdGlvbnMuY29tcGxldGVcblx0XHRcdH0gKTtcblx0XHRcdGFuaW1hdGlvbnMuYWRkKCBhbmltYXRpb24gKTtcblx0XHRcdHJvb3QuX2FuaW1hdGlvbnMucHVzaCggYW5pbWF0aW9uICk7XG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGlzRXF1YWwsIFByb21pc2UsIG5vcm1hbGlzZUtleXBhdGgsIGFuaW1hdGlvbnMsIFJhY3RpdmUkYW5pbWF0ZV9BbmltYXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIFJhY3RpdmUkZGV0YWNoID0gZnVuY3Rpb24oIEhvb2ssIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBkZXRhY2hIb29rID0gbmV3IEhvb2soICdkZXRhY2gnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZGV0YWNoKCkge1xuXHRcdFx0aWYgKCB0aGlzLmRldGFjaGVkICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5lbCApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5kZXRhY2hlZCA9IHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHRkZXRhY2hIb29rLmZpcmUoIHRoaXMgKTtcblx0XHRcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZCA9IGZ1bmN0aW9uIFJhY3RpdmUkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0aWYgKCAhdGhpcy5lbCApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHR9O1xuXG5cdC8qIHV0aWxzL21hdGNoZXMuanMgKi9cblx0dmFyIG1hdGNoZXMgPSBmdW5jdGlvbiggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQgKSB7XG5cblx0XHR2YXIgbWF0Y2hlcywgZGl2LCBtZXRob2ROYW1lcywgdW5wcmVmaXhlZCwgcHJlZml4ZWQsIGksIGosIG1ha2VGdW5jdGlvbjtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdG1hdGNoZXMgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdFx0bWV0aG9kTmFtZXMgPSBbXG5cdFx0XHRcdCdtYXRjaGVzJyxcblx0XHRcdFx0J21hdGNoZXNTZWxlY3Rvcidcblx0XHRcdF07XG5cdFx0XHRtYWtlRnVuY3Rpb24gPSBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBub2RlLCBzZWxlY3RvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZVsgbWV0aG9kTmFtZSBdKCBzZWxlY3RvciApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdGkgPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSAmJiAhbWF0Y2hlcyApIHtcblx0XHRcdFx0dW5wcmVmaXhlZCA9IG1ldGhvZE5hbWVzWyBpIF07XG5cdFx0XHRcdGlmICggZGl2WyB1bnByZWZpeGVkIF0gKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbiggdW5wcmVmaXhlZCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGogPSB2ZW5kb3JzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHByZWZpeGVkID0gdmVuZG9yc1sgaSBdICsgdW5wcmVmaXhlZC5zdWJzdHIoIDAsIDEgKS50b1VwcGVyQ2FzZSgpICsgdW5wcmVmaXhlZC5zdWJzdHJpbmcoIDEgKTtcblx0XHRcdFx0XHRcdGlmICggZGl2WyBwcmVmaXhlZCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKCBwcmVmaXhlZCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElFOC4uLlxuXHRcdFx0aWYgKCAhbWF0Y2hlcyApIHtcblx0XHRcdFx0bWF0Y2hlcyA9IGZ1bmN0aW9uKCBub2RlLCBzZWxlY3RvciApIHtcblx0XHRcdFx0XHR2YXIgbm9kZXMsIHBhcmVudE5vZGUsIGk7XG5cdFx0XHRcdFx0cGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRpZiAoICFwYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gZW1wdHkgZHVtbXkgPGRpdj5cblx0XHRcdFx0XHRcdGRpdi5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0XHRcdHBhcmVudE5vZGUgPSBkaXY7XG5cdFx0XHRcdFx0XHRub2RlID0gbm9kZS5jbG9uZU5vZGUoKTtcblx0XHRcdFx0XHRcdGRpdi5hcHBlbmRDaGlsZCggbm9kZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlcyA9IHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCBub2Rlc1sgaSBdID09PSBub2RlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3Rlc3QuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV90ZXN0ID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGl0ZW0sIG5vRGlydHkgKSB7XG5cdFx0XHR2YXIgaXRlbU1hdGNoZXMgPSB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gIXRoaXMuc2VsZWN0b3IgfHwgaXRlbS5uYW1lID09PSB0aGlzLnNlbGVjdG9yIDogbWF0Y2hlcyggaXRlbS5ub2RlLCB0aGlzLnNlbGVjdG9yICk7XG5cdFx0XHRpZiAoIGl0ZW1NYXRjaGVzICkge1xuXHRcdFx0XHR0aGlzLnB1c2goIGl0ZW0ubm9kZSB8fCBpdGVtLmluc3RhbmNlICk7XG5cdFx0XHRcdGlmICggIW5vRGlydHkgKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFrZURpcnR5KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvY2FuY2VsLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfY2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxpdmVRdWVyaWVzLCBzZWxlY3RvciwgaW5kZXg7XG5cdFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9yb290WyB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gJ2xpdmVDb21wb25lbnRRdWVyaWVzJyA6ICdsaXZlUXVlcmllcycgXTtcblx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cdFx0aW5kZXggPSBsaXZlUXVlcmllcy5pbmRleE9mKCBzZWxlY3RvciApO1xuXHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0bGl2ZVF1ZXJpZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0bGl2ZVF1ZXJpZXNbIHNlbGVjdG9yIF0gPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnRCeUl0ZW1Qb3NpdGlvbi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeUl0ZW1Qb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnlBLCBhbmNlc3RyeUIsIG9sZGVzdEEsIG9sZGVzdEIsIG11dHVhbEFuY2VzdG9yLCBpbmRleEEsIGluZGV4QiwgZnJhZ21lbnRzLCBmcmFnbWVudEEsIGZyYWdtZW50Qjtcblx0XHRcdGFuY2VzdHJ5QSA9IGdldEFuY2VzdHJ5KCBhLmNvbXBvbmVudCB8fCBhLl9yYWN0aXZlLnByb3h5ICk7XG5cdFx0XHRhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeSggYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSApO1xuXHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdG9sZGVzdEIgPSBhbmNlc3RyeUJbIGFuY2VzdHJ5Qi5sZW5ndGggLSAxIF07XG5cdFx0XHQvLyByZW1vdmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIGJvdGggYW5jZXN0cmllcyBhcyBsb25nIGFzIHRoZXkgYXJlIGlkZW50aWNhbFxuXHRcdFx0Ly8gLSB0aGUgZmluYWwgb25lIHJlbW92ZWQgaXMgdGhlIGNsb3Nlc3QgbXV0dWFsIGFuY2VzdG9yXG5cdFx0XHR3aGlsZSAoIG9sZGVzdEEgJiYgb2xkZXN0QSA9PT0gb2xkZXN0QiApIHtcblx0XHRcdFx0YW5jZXN0cnlBLnBvcCgpO1xuXHRcdFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cdFx0XHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblx0XHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0b2xkZXN0QiA9IGFuY2VzdHJ5QlsgYW5jZXN0cnlCLmxlbmd0aCAtIDEgXTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIG11dHVhbCBhbmNlc3Rvciwgd2UgY2FuIGZpbmQgd2hpY2ggaXMgZWFybGllc3Rcblx0XHRcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuXHRcdFx0b2xkZXN0QiA9IG9sZGVzdEIuY29tcG9uZW50IHx8IG9sZGVzdEI7XG5cdFx0XHRmcmFnbWVudEEgPSBvbGRlc3RBLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0ZnJhZ21lbnRCID0gb2xkZXN0Qi5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIGlmIGJvdGggaXRlbXMgc2hhcmUgYSBwYXJlbnQgZnJhZ21lbnQsIG91ciBqb2IgaXMgZWFzeVxuXHRcdFx0aWYgKCBmcmFnbWVudEEgPT09IGZyYWdtZW50QiApIHtcblx0XHRcdFx0aW5kZXhBID0gZnJhZ21lbnRBLml0ZW1zLmluZGV4T2YoIG9sZGVzdEEgKTtcblx0XHRcdFx0aW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2YoIG9sZGVzdEIgKTtcblx0XHRcdFx0Ly8gaWYgaXQncyB0aGUgc2FtZSBpbmRleCwgaXQgbWVhbnMgb25lIGNvbnRhaW5zIHRoZSBvdGhlcixcblx0XHRcdFx0Ly8gc28gd2Ugc2VlIHdoaWNoIGhhcyB0aGUgbG9uZ2VzdCBhbmNlc3RyeVxuXHRcdFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgbXV0dWFsIGFuY2VzdG9yIGlzIGEgc2VjdGlvbiwgd2UgZmlyc3QgdGVzdCB0byBzZWUgd2hpY2ggc2VjdGlvblxuXHRcdFx0Ly8gZnJhZ21lbnQgY29tZXMgZmlyc3Rcblx0XHRcdGlmICggZnJhZ21lbnRzID0gbXV0dWFsQW5jZXN0b3IuZnJhZ21lbnRzICkge1xuXHRcdFx0XHRpbmRleEEgPSBmcmFnbWVudHMuaW5kZXhPZiggZnJhZ21lbnRBICk7XG5cdFx0XHRcdGluZGV4QiA9IGZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudEIgKTtcblx0XHRcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0FuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHdhcyBtZXQgd2hpbGUgY29tcGFyaW5nIHRoZSBwb3NpdGlvbiBvZiB0d28gY29tcG9uZW50cy4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyEnICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFBhcmVudCggaXRlbSApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudDtcblx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLnBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGl0ZW0uY29tcG9uZW50ICYmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5jZXN0cnkoIGl0ZW0gKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnksIGFuY2VzdG9yO1xuXHRcdFx0YW5jZXN0cnkgPSBbIGl0ZW0gXTtcblx0XHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KCBpdGVtICk7XG5cdFx0XHR3aGlsZSAoIGFuY2VzdG9yICkge1xuXHRcdFx0XHRhbmNlc3RyeS5wdXNoKCBhbmNlc3RvciApO1xuXHRcdFx0XHRhbmNlc3RvciA9IGdldFBhcmVudCggYW5jZXN0b3IgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhbmNlc3RyeTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9zb3J0QnlEb2N1bWVudFBvc2l0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBzb3J0QnlJdGVtUG9zaXRpb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIG5vZGUsIG90aGVyTm9kZSApIHtcblx0XHRcdHZhciBiaXRtYXNrO1xuXHRcdFx0aWYgKCBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICkge1xuXHRcdFx0XHRiaXRtYXNrID0gbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggb3RoZXJOb2RlICk7XG5cdFx0XHRcdHJldHVybiBiaXRtYXNrICYgMiA/IDEgOiAtMTtcblx0XHRcdH1cblx0XHRcdC8vIEluIG9sZCBJRSwgd2UgY2FuIHBpZ2d5IGJhY2sgb24gdGhlIG1lY2hhbmlzbSBmb3Jcblx0XHRcdC8vIGNvbXBhcmluZyBjb21wb25lbnQgcG9zaXRpb25zXG5cdFx0XHRyZXR1cm4gc29ydEJ5SXRlbVBvc2l0aW9uKCBub2RlLCBvdGhlck5vZGUgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9zb3J0LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydCA9IGZ1bmN0aW9uKCBzb3J0QnlEb2N1bWVudFBvc2l0aW9uLCBzb3J0QnlJdGVtUG9zaXRpb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNvcnQoIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBzb3J0QnlJdGVtUG9zaXRpb24gOiBzb3J0QnlEb2N1bWVudFBvc2l0aW9uICk7XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlEb2N1bWVudFBvc2l0aW9uLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9kaXJ0eS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2RpcnR5ID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdGlmICggIXRoaXMuX2RpcnR5ICkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdC8vIE9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLCBlbnN1cmUgdGhlIHF1ZXJ5XG5cdFx0XHRcdC8vIGlzIGNvcnJlY3RseSBvcmRlcmVkXG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzJDAuX3NvcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3JlbW92ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3JlbW92ZSA9IGZ1bmN0aW9uKCBub2RlT3JDb21wb25lbnQgKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKCB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gbm9kZU9yQ29tcG9uZW50Lmluc3RhbmNlIDogbm9kZU9yQ29tcG9uZW50ICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHR0aGlzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9fbWFrZVF1ZXJ5LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSA9IGZ1bmN0aW9uKCBkZWZpbmVQcm9wZXJ0aWVzLCB0ZXN0LCBjYW5jZWwsIHNvcnQsIGRpcnR5LCByZW1vdmUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gbWFrZVF1ZXJ5KCByYWN0aXZlLCBzZWxlY3RvciwgbGl2ZSwgaXNDb21wb25lbnRRdWVyeSApIHtcblx0XHRcdHZhciBxdWVyeSA9IFtdO1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggcXVlcnksIHtcblx0XHRcdFx0c2VsZWN0b3I6IHtcblx0XHRcdFx0XHR2YWx1ZTogc2VsZWN0b3Jcblx0XHRcdFx0fSxcblx0XHRcdFx0bGl2ZToge1xuXHRcdFx0XHRcdHZhbHVlOiBsaXZlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9pc0NvbXBvbmVudFF1ZXJ5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGlzQ29tcG9uZW50UXVlcnlcblx0XHRcdFx0fSxcblx0XHRcdFx0X3Rlc3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogdGVzdFxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoICFsaXZlICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBxdWVyeSwge1xuXHRcdFx0XHRjYW5jZWw6IHtcblx0XHRcdFx0XHR2YWx1ZTogY2FuY2VsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9yb290OiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJhY3RpdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X3NvcnQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogc29ydFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfbWFrZURpcnR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGRpcnR5XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9yZW1vdmU6IHtcblx0XHRcdFx0XHR2YWx1ZTogcmVtb3ZlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9kaXJ0eToge1xuXHRcdFx0XHRcdHZhbHVlOiBmYWxzZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0fTtcblx0fSggZGVmaW5lUHJvcGVydGllcywgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3Rlc3QsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9jYW5jZWwsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0LCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfZGlydHksIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9yZW1vdmUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRBbGwgPSBmdW5jdGlvbiggbWFrZVF1ZXJ5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbCggc2VsZWN0b3IsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXHRcdFx0aWYgKCAhdGhpcy5lbCApIHtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVRdWVyaWVzO1xuXHRcdFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcblx0XHRcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cblx0XHRcdGlmICggcXVlcnkgPSBsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSApIHtcblx0XHRcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG5cdFx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdHF1ZXJ5ID0gbWFrZVF1ZXJ5KCB0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIGZhbHNlICk7XG5cdFx0XHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcblx0XHRcdC8vIGlmIGFwcGxpY2FibGVcblx0XHRcdGlmICggcXVlcnkubGl2ZSApIHtcblx0XHRcdFx0bGl2ZVF1ZXJpZXMucHVzaCggc2VsZWN0b3IgKTtcblx0XHRcdFx0bGl2ZVF1ZXJpZXNbICdfJyArIHNlbGVjdG9yIF0gPSBxdWVyeTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X19tYWtlUXVlcnkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uKCBtYWtlUXVlcnkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVDb21wb25lbnRRdWVyaWVzO1xuXHRcdFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcblx0XHRcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cblx0XHRcdGlmICggcXVlcnkgPSBsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSApIHtcblx0XHRcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG5cdFx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdHF1ZXJ5ID0gbWFrZVF1ZXJ5KCB0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIHRydWUgKTtcblx0XHRcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuXHRcdFx0Ly8gaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCBxdWVyeS5saXZlICkge1xuXHRcdFx0XHRsaXZlUXVlcmllcy5wdXNoKCBzZWxlY3RvciApO1xuXHRcdFx0XHRsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXSA9IHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X19tYWtlUXVlcnkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdXRpbHMvZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmpzICovXG5cdHZhciBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgc3Rhck1hcHMgPSB7fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEga2V5cGF0aCBzdWNoIGFzICdmb28uYmFyLmJheicsIGFuZCByZXR1cm5zXG5cdFx0Ly8gYWxsIHRoZSB2YXJpYW50cyBvZiB0aGF0IGtleXBhdGggdGhhdCBpbmNsdWRlIGEgd2lsZGNhcmQgaW4gcGxhY2Vcblx0XHQvLyBvZiBhIGtleSwgc3VjaCBhcyAnZm9vLmJhci4qJywgJ2Zvby4qLmJheicsICdmb28uKi4qJyBhbmQgc28gb24uXG5cdFx0Ly8gVGhlc2UgYXJlIHRoZW4gY2hlY2tlZCBhZ2FpbnN0IHRoZSBkZXBlbmRhbnRzIG1hcCAocmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcClcblx0XHQvLyB0byBzZWUgaWYgYW55IHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBkb3duc3RyZWFtIG9mIG9uZSBvciBtb3JlIG9mXG5cdFx0Ly8gdGhlc2Ugd2lsZGNhcmQga2V5cGF0aHMgKGUuZy4gJ2Zvby5iYXIuKi5zdGF0dXMnKVxuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgaSwgcmVzdWx0LCB3aWxkY2FyZEtleXBhdGg7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRpZiAoICEoIHN0YXJNYXAgPSBzdGFyTWFwc1sga2V5cy5sZW5ndGggXSApICkge1xuXHRcdFx0XHRzdGFyTWFwID0gZ2V0U3Rhck1hcCgga2V5cy5sZW5ndGggKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIHN0YXIsIGkgKSB7XG5cdFx0XHRcdHJldHVybiBzdGFyID8gJyonIDoga2V5c1sgaSBdO1xuXHRcdFx0fTtcblx0XHRcdGkgPSBzdGFyTWFwLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHR3aWxkY2FyZEtleXBhdGggPSBzdGFyTWFwWyBpIF0ubWFwKCBtYXBwZXIgKS5qb2luKCAnLicgKTtcblx0XHRcdFx0aWYgKCAhcmVzdWx0Lmhhc093blByb3BlcnR5KCB3aWxkY2FyZEtleXBhdGggKSApIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCggd2lsZGNhcmRLZXlwYXRoICk7XG5cdFx0XHRcdFx0cmVzdWx0WyB3aWxkY2FyZEtleXBhdGggXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHRoZSBwb3NzaWJsZSB0cnVlL2ZhbHNlIGNvbWJpbmF0aW9ucyBmb3Jcblx0XHQvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcblx0XHQvLyBbIHRydWUsIHRydWUgXSwgWyB0cnVlLCBmYWxzZSBdLCBbIGZhbHNlLCB0cnVlIF0sIFsgZmFsc2UsIGZhbHNlIF0uXG5cdFx0Ly8gSXQgZG9lcyBzbyBieSBnZXR0aW5nIGFsbCB0aGUgYmluYXJ5IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGUuZy4gMTFcblx0XHRmdW5jdGlvbiBnZXRTdGFyTWFwKCBudW0gKSB7XG5cdFx0XHR2YXIgb25lcyA9ICcnLFxuXHRcdFx0XHRtYXgsIGJpbmFyeSwgc3Rhck1hcCwgbWFwcGVyLCBpO1xuXHRcdFx0aWYgKCAhc3Rhck1hcHNbIG51bSBdICkge1xuXHRcdFx0XHRzdGFyTWFwID0gW107XG5cdFx0XHRcdHdoaWxlICggb25lcy5sZW5ndGggPCBudW0gKSB7XG5cdFx0XHRcdFx0b25lcyArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heCA9IHBhcnNlSW50KCBvbmVzLCAyICk7XG5cdFx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBkaWdpdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGlnaXQgPT09ICcxJztcblx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPD0gbWF4OyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YmluYXJ5ID0gaS50b1N0cmluZyggMiApO1xuXHRcdFx0XHRcdHdoaWxlICggYmluYXJ5Lmxlbmd0aCA8IG51bSApIHtcblx0XHRcdFx0XHRcdGJpbmFyeSA9ICcwJyArIGJpbmFyeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Rhck1hcFsgaSBdID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKCBiaW5hcnksIG1hcHBlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJNYXBzWyBudW0gXSA9IHN0YXJNYXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3Rhck1hcHNbIG51bSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvZmlyZUV2ZW50LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQgPSBmdW5jdGlvbiggZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZmlyZUV2ZW50KCByYWN0aXZlLCBldmVudE5hbWUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRpZiAoICFldmVudE5hbWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggIW9wdGlvbnMuZXZlbnQgKSB7XG5cdFx0XHRcdG9wdGlvbnMuZXZlbnQgPSB7XG5cdFx0XHRcdFx0bmFtZTogZXZlbnROYW1lLFxuXHRcdFx0XHRcdGNvbnRleHQ6IHJhY3RpdmUuZGF0YSxcblx0XHRcdFx0XHRrZXlwYXRoOiAnJyxcblx0XHRcdFx0XHQvLyB1bnRpbCBldmVudCBub3QgaW5jbHVkZWQgYXMgYXJndW1lbnQgZGVmYXVsdFxuXHRcdFx0XHRcdF9ub0FyZzogdHJ1ZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9ucy5ldmVudC5uYW1lID0gZXZlbnROYW1lO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGV2ZW50TmFtZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGV2ZW50TmFtZSApO1xuXHRcdFx0ZmlyZUV2ZW50QXMoIHJhY3RpdmUsIGV2ZW50TmFtZXMsIG9wdGlvbnMuZXZlbnQsIG9wdGlvbnMuYXJncywgdHJ1ZSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRBcyggcmFjdGl2ZSwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgaW5pdGlhbEZpcmUgPSBhcmd1bWVudHNbIDQgXTtcblx0XHRcdGlmICggaW5pdGlhbEZpcmUgPT09IHZvaWQgMCApXG5cdFx0XHRcdGluaXRpYWxGaXJlID0gZmFsc2U7XG5cdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGksIGJ1YmJsZSA9IHRydWU7XG5cdFx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0XHRyYWN0aXZlLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBpID0gZXZlbnROYW1lcy5sZW5ndGg7IGkgPj0gMDsgaS0tICkge1xuXHRcdFx0XHRzdWJzY3JpYmVycyA9IHJhY3RpdmUuX3N1YnNbIGV2ZW50TmFtZXNbIGkgXSBdO1xuXHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzICkge1xuXHRcdFx0XHRcdGJ1YmJsZSA9IG5vdGlmeVN1YnNjcmliZXJzKCByYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MgKSAmJiBidWJibGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHRcdGRlbGV0ZSByYWN0aXZlLmV2ZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCByYWN0aXZlLl9wYXJlbnQgJiYgYnViYmxlICkge1xuXHRcdFx0XHRpZiAoIGluaXRpYWxGaXJlICYmIHJhY3RpdmUuY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdHZhciBmdWxsTmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUgKyAnLicgKyBldmVudE5hbWVzWyBldmVudE5hbWVzLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0XHRldmVudE5hbWVzID0gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBmdWxsTmFtZSApO1xuXHRcdFx0XHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5jb21wb25lbnQgPSByYWN0aXZlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmaXJlRXZlbnRBcyggcmFjdGl2ZS5fcGFyZW50LCBldmVudE5hbWVzLCBldmVudCwgYXJncyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeVN1YnNjcmliZXJzKCByYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxFdmVudCA9IG51bGwsXG5cdFx0XHRcdHN0b3BFdmVudCA9IGZhbHNlO1xuXHRcdFx0aWYgKCBldmVudCAmJiAhZXZlbnQuX25vQXJnICkge1xuXHRcdFx0XHRhcmdzID0gWyBldmVudCBdLmNvbmNhdCggYXJncyApO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aWYgKCBzdWJzY3JpYmVyc1sgaSBdLmFwcGx5KCByYWN0aXZlLCBhcmdzICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHN0b3BFdmVudCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZyAmJiBzdG9wRXZlbnQgJiYgKCBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWwgKSApIHtcblx0XHRcdFx0b3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uICYmIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIXN0b3BFdmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maXJlLmpzICovXG5cdHZhciBSYWN0aXZlJGZpcmUgPSBmdW5jdGlvbiggZmlyZUV2ZW50ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZmlyZSggZXZlbnROYW1lICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRcdGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKVxuXHRcdFx0fTtcblx0XHRcdGZpcmVFdmVudCggdGhpcywgZXZlbnROYW1lLCBvcHRpb25zICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfZmlyZUV2ZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciBSYWN0aXZlJGdldCA9IGZ1bmN0aW9uKCBub3JtYWxpc2VLZXlwYXRoLCByZXNvbHZlUmVmICkge1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRjYXB0dXJlOiB0cnVlXG5cdFx0fTtcblx0XHQvLyB0b3AtbGV2ZWwgY2FsbHMgc2hvdWxkIGJlIGludGVyY2VwdGVkXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0KCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoLCBvcHRpb25zICk7XG5cdFx0XHQvLyBDcmVhdGUgaW50ZXItY29tcG9uZW50IGJpbmRpbmcsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3BhcmVudCAmJiAhdGhpcy5pc29sYXRlZCApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlUmVmKCB0aGlzLCBrZXlwYXRoLCB0aGlzLmZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdFx0Ly8gY3JlYXRlcyBiaW5kaW5nIGFzIHNpZGUtZWZmZWN0LCBpZiBhcHByb3ByaWF0ZVxuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoLCByZXNvbHZlUmVmICk7XG5cblx0LyogdXRpbHMvZ2V0RWxlbWVudC5qcyAqL1xuXHR2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoIGlucHV0ICkge1xuXHRcdHZhciBvdXRwdXQ7XG5cdFx0aWYgKCAhaW5wdXQgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRvY3VtZW50IHx8ICFpbnB1dCApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHQvLyBXZSBhbHJlYWR5IGhhdmUgYSBET00gbm9kZSAtIG5vIHdvcmsgdG8gZG8uIChEdWNrIHR5cGluZyBhbGVydCEpXG5cdFx0aWYgKCBpbnB1dC5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dDtcblx0XHR9XG5cdFx0Ly8gR2V0IG5vZGUgZnJvbSBzdHJpbmdcblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyB0cnkgSUQgZmlyc3Rcblx0XHRcdG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpbnB1dCApO1xuXHRcdFx0Ly8gdGhlbiBhcyBzZWxlY3RvciwgaWYgcG9zc2libGVcblx0XHRcdGlmICggIW91dHB1dCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICkge1xuXHRcdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBpbnB1dCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGlkIGl0IHdvcms/XG5cdFx0XHRpZiAoIG91dHB1dCAmJiBvdXRwdXQubm9kZVR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjb2xsZWN0aW9uIChqUXVlcnksIFplcHRvIGV0YyksIGV4dHJhY3QgdGhlIGZpcnN0IGl0ZW1cblx0XHRpZiAoIGlucHV0WyAwIF0gJiYgaW5wdXRbIDAgXS5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dFsgMCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9pbnNlcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkaW5zZXJ0ID0gZnVuY3Rpb24oIEhvb2ssIGdldEVsZW1lbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGluc2VydEhvb2sgPSBuZXcgSG9vayggJ2luc2VydCcgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFJhY3RpdmUkaW5zZXJ0KCB0YXJnZXQsIGFuY2hvciApIHtcblx0XHRcdGlmICggIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gY3JlYXRlLCBhbmQgbGluayB0bywgZG9jdW1lbnRhdGlvbiBleHBsYWluaW5nIHRoaXNcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIEFQSSBoYXMgY2hhbmdlZCAtIHlvdSBtdXN0IGNhbGwgYHJhY3RpdmUucmVuZGVyKHRhcmdldFssIGFuY2hvcl0pYCB0byByZW5kZXIgeW91ciBSYWN0aXZlIGluc3RhbmNlLiBPbmNlIHJlbmRlcmVkIHlvdSBjYW4gdXNlIGByYWN0aXZlLmluc2VydCgpYC4nICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKTtcblx0XHRcdGFuY2hvciA9IGdldEVsZW1lbnQoIGFuY2hvciApIHx8IG51bGw7XG5cdFx0XHRpZiAoICF0YXJnZXQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1lvdSBtdXN0IHNwZWNpZnkgYSB2YWxpZCB0YXJnZXQgdG8gaW5zZXJ0IGludG8nICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRldGFjaCgpLCBhbmNob3IgKTtcblx0XHRcdHRoaXMuZWwgPSB0YXJnZXQ7XG5cdFx0XHQoIHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gfHwgKCB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gW10gKSApLnB1c2goIHRoaXMgKTtcblx0XHRcdHRoaXMuZGV0YWNoZWQgPSBudWxsO1xuXHRcdFx0ZmlyZUluc2VydEhvb2soIHRoaXMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZmlyZUluc2VydEhvb2soIHJhY3RpdmUgKSB7XG5cdFx0XHRpbnNlcnRIb29rLmZpcmUoIHJhY3RpdmUgKTtcblx0XHRcdHJhY3RpdmUuZmluZEFsbENvbXBvbmVudHMoICcqJyApLmZvckVhY2goIGZ1bmN0aW9uKCBjaGlsZCApIHtcblx0XHRcdFx0ZmlyZUluc2VydEhvb2soIGNoaWxkLmluc3RhbmNlICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgZ2V0RWxlbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL21lcmdlLmpzICovXG5cdHZhciBSYWN0aXZlJG1lcmdlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzQXJyYXksIG5vcm1hbGlzZUtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRtZXJnZSgga2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgY3VycmVudEFycmF5LCBwcm9taXNlO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdGN1cnJlbnRBcnJheSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0Ly8gSWYgZWl0aGVyIHRoZSBleGlzdGluZyB2YWx1ZSBvciB0aGUgbmV3IHZhbHVlIGlzbid0IGFuXG5cdFx0XHQvLyBhcnJheSwganVzdCBkbyBhIHJlZ3VsYXIgc2V0XG5cdFx0XHRpZiAoICFpc0FycmF5KCBjdXJyZW50QXJyYXkgKSB8fCAhaXNBcnJheSggYXJyYXkgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KCBrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBNYW5hZ2UgdHJhbnNpdGlvbnNcblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbC5tZXJnZSgga2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdC8vIGF0dGFjaCBjYWxsYmFjayBhcyBmdWxmaWxtZW50IGhhbmRsZXIsIGlmIHNwZWNpZmllZFxuXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNBcnJheSwgbm9ybWFsaXNlS2V5cGF0aCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvT2JzZXJ2ZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9PYnNlcnZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIE9ic2VydmVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblx0XHRcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuXHRcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuXHRcdH07XG5cdFx0T2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oIGltbWVkaWF0ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMucm9vdC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGUoKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2suY2FsbCggdGhpcy5jb250ZXh0LCB0aGlzLnZhbHVlLCB0aGlzLm9sZFZhbHVlLCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBPYnNlcnZlcjtcblx0fSggcnVubG9vcCwgaXNFcXVhbCApO1xuXG5cdC8qIHNoYXJlZC9nZXRNYXRjaGluZ0tleXBhdGhzLmpzICovXG5cdHZhciBnZXRNYXRjaGluZ0tleXBhdGhzID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIG1hdGNoaW5nS2V5cGF0aHM7XG5cdFx0XHRrZXlzID0gcGF0dGVybi5zcGxpdCggJy4nICk7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gWyAnJyBdO1xuXHRcdFx0d2hpbGUgKCBrZXkgPSBrZXlzLnNoaWZ0KCkgKSB7XG5cdFx0XHRcdGlmICgga2V5ID09PSAnKicgKSB7XG5cdFx0XHRcdFx0Ly8gZXhwYW5kIHRvIGZpbmQgYWxsIHZhbGlkIGNoaWxkIGtleXBhdGhzXG5cdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMucmVkdWNlKCBleHBhbmQsIFtdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGluZ0tleXBhdGhzWyAwIF0gPT09ICcnICkge1xuXHRcdFx0XHRcdFx0Ly8gZmlyc3Qga2V5XG5cdFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzWyAwIF0gPSBrZXk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLm1hcCggY29uY2F0ZW5hdGUoIGtleSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcblxuXHRcdFx0ZnVuY3Rpb24gZXhwYW5kKCBtYXRjaGluZ0tleXBhdGhzLCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleSwgY2hpbGRLZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXSA/IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXS5nZXQoKSA6IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGZvciAoIGtleSBpbiB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAoIGtleSAhPT0gJ19yYWN0aXZlJyB8fCAhaXNBcnJheSggdmFsdWUgKSApICkge1xuXHRcdFx0XHRcdFx0Ly8gZm9yIGJlbmVmaXQgb2YgSUU4XG5cdFx0XHRcdFx0XHRjaGlsZEtleXBhdGggPSBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMucHVzaCggY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb25jYXRlbmF0ZSgga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL2dldFBhdHRlcm4uanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuID0gZnVuY3Rpb24oIGdldE1hdGNoaW5nS2V5cGF0aHMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UGF0dGVybiggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBtYXRjaGluZ0tleXBhdGhzLCB2YWx1ZXM7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApO1xuXHRcdFx0dmFsdWVzID0ge307XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdH07XG5cdH0oIGdldE1hdGNoaW5nS2V5cGF0aHMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL1BhdHRlcm5PYnNlcnZlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsLCBnZXRQYXR0ZXJuICkge1xuXG5cdFx0dmFyIFBhdHRlcm5PYnNlcnZlciwgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnJlZ2V4ID0gbmV3IFJlZ0V4cCggJ14nICsga2V5cGF0aC5yZXBsYWNlKCAvXFwuL2csICdcXFxcLicgKS5yZXBsYWNlKCAvXFwqL2csICcoW15cXFxcLl0rKScgKSArICckJyApO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSB7fTtcblx0XHRcdGlmICggdGhpcy5kZWZlciApIHtcblx0XHRcdFx0dGhpcy5wcm94aWVzID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcblx0XHR9O1xuXHRcdFBhdHRlcm5PYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR2YXIgdmFsdWVzLCBrZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZXMgPSBnZXRQYXR0ZXJuKCB0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiB2YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlcy5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWVzO1xuXHRcdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBnZXRQYXR0ZXJuKCB0aGlzLnJvb3QsIGtleXBhdGggKTtcblx0XHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIHZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGlmICggdmFsdWVzLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBhcnJheSBtdXRhdGlvbiBzaG91bGQgbm90IHRyaWdnZXIgYGFycmF5LipgXG5cdFx0XHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXIgd2l0aCBgYXJyYXkubGVuZ3RoYFxuXHRcdFx0XHRpZiAoIHRoaXMucm9vdC52aWV3bW9kZWwuaW1wbGljaXRDaGFuZ2VzWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzJDAuZ2V0UHJveHkoIGtleXBhdGggKS51cGRhdGUoKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVhbGx5VXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVhbGx5VXBkYXRlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBrZXlzLCBhcmdzO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlc1sga2V5cGF0aCBdICkgfHwgIXRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0a2V5cyA9IHNsaWNlLmNhbGwoIHRoaXMucmVnZXguZXhlYygga2V5cGF0aCApLCAxICk7XG5cdFx0XHRcdFx0YXJncyA9IFtcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSxcblx0XHRcdFx0XHRcdGtleXBhdGhcblx0XHRcdFx0XHRdLmNvbmNhdCgga2V5cyApO1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2suYXBwbHkoIHRoaXMuY29udGV4dCwgYXJncyApO1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0UHJveHk6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdGlmICggIXRoaXMucHJveGllc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHRoaXMucHJveGllc1sga2V5cGF0aCBdID0ge1xuXHRcdFx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5yZWFsbHlVcGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLnByb3hpZXNbIGtleXBhdGggXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBQYXR0ZXJuT2JzZXJ2ZXI7XG5cdH0oIHJ1bmxvb3AsIGlzRXF1YWwsIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9nZXRPYnNlcnZlckZhY2FkZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlID0gZnVuY3Rpb24oIG5vcm1hbGlzZUtleXBhdGgsIE9ic2VydmVyLCBQYXR0ZXJuT2JzZXJ2ZXIgKSB7XG5cblx0XHR2YXIgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdGVtcHR5T2JqZWN0ID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldE9ic2VydmVyRmFjYWRlKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIsIGNhbmNlbGxlZDtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCBlbXB0eU9iamVjdDtcblx0XHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5XG5cdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b2JzZXJ2ZXIgPSBuZXcgUGF0dGVybk9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnB1c2goIG9ic2VydmVyICk7XG5cdFx0XHRcdGlzUGF0dGVybk9ic2VydmVyID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ic2VydmVyID0gbmV3IE9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciA/ICdwYXR0ZXJuT2JzZXJ2ZXJzJyA6ICdvYnNlcnZlcnMnICk7XG5cdFx0XHRvYnNlcnZlci5pbml0KCBvcHRpb25zLmluaXQgKTtcblx0XHRcdC8vIFRoaXMgZmxhZyBhbGxvd3Mgb2JzZXJ2ZXJzIHRvIGluaXRpYWxpc2UgZXZlbiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdG9ic2VydmVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdGlmICggY2FuY2VsbGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGlzUGF0dGVybk9ic2VydmVyICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSByYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmluZGV4T2YoIG9ic2VydmVyICk7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCAncGF0dGVybk9ic2VydmVycycgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsICdvYnNlcnZlcnMnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbmNlbGxlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggbm9ybWFsaXNlS2V5cGF0aCwgUmFjdGl2ZSRvYnNlcnZlX09ic2VydmVyLCBSYWN0aXZlJG9ic2VydmVfUGF0dGVybk9ic2VydmVyICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlID0gZnVuY3Rpb24oIGlzT2JqZWN0LCBnZXRPYnNlcnZlckZhY2FkZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9ic2VydmUoIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG9ic2VydmVycywgbWFwLCBrZXlwYXRocywgaTtcblx0XHRcdC8vIEFsbG93IGEgbWFwIG9mIGtleXBhdGhzIHRvIGhhbmRsZXJzXG5cdFx0XHRpZiAoIGlzT2JqZWN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcblx0XHRcdFx0bWFwID0ga2V5cGF0aDtcblx0XHRcdFx0b2JzZXJ2ZXJzID0gW107XG5cdFx0XHRcdGZvciAoIGtleXBhdGggaW4gbWFwICkge1xuXHRcdFx0XHRcdGlmICggbWFwLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG1hcFsga2V5cGF0aCBdO1xuXHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnB1c2goIHRoaXMub2JzZXJ2ZSgga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIG9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBBbGxvdyBgcmFjdGl2ZS5vYnNlcnZlKCBjYWxsYmFjayApYCAtIGkuZS4gb2JzZXJ2ZSBlbnRpcmUgbW9kZWxcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcblx0XHRcdFx0Y2FsbGJhY2sgPSBrZXlwYXRoO1xuXHRcdFx0XHRrZXlwYXRoID0gJyc7XG5cdFx0XHRcdHJldHVybiBnZXRPYnNlcnZlckZhY2FkZSggdGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdGtleXBhdGhzID0ga2V5cGF0aC5zcGxpdCggJyAnICk7XG5cdFx0XHQvLyBTaW5nbGUga2V5cGF0aFxuXHRcdFx0aWYgKCBrZXlwYXRocy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBnZXRPYnNlcnZlckZhY2FkZSggdGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIE11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBrZXlwYXRoc1xuXHRcdFx0b2JzZXJ2ZXJzID0gW107XG5cdFx0XHRpID0ga2V5cGF0aHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXJzLnB1c2goIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBvYnNlcnZlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBpc09iamVjdCwgUmFjdGl2ZSRvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL3RyaW0uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX3RyaW0gPSBmdW5jdGlvbiggc3RyICkge1xuXHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9ub3RFbXB0eVN0cmluZy5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbm90RW1wdHlTdHJpbmcgPSBmdW5jdGlvbiggc3RyICkge1xuXHRcdHJldHVybiBzdHIgIT09ICcnO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29mZi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvZmYgPSBmdW5jdGlvbiggdHJpbSwgbm90RW1wdHlTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvZmYoIGV2ZW50TmFtZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBldmVudE5hbWVzO1xuXHRcdFx0Ly8gaWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBjYWxsYmFja3Ncblx0XHRcdGlmICggIWV2ZW50TmFtZSApIHtcblx0XHRcdFx0Ly8gVE9ETyB1c2UgdGhpcyBjb2RlIGluc3RlYWQsIG9uY2UgdGhlIGZvbGxvd2luZyBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZFxuXHRcdFx0XHQvLyBpbiBQaGFudG9tSlMgKHRlc3RzIGFyZSB1bnBhc3NhYmxlIG90aGVyd2lzZSEpXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExODU2XG5cdFx0XHRcdC8vIGRlZmluZVByb3BlcnR5KCB0aGlzLCAnX3N1YnMnLCB7IHZhbHVlOiBjcmVhdGUoIG51bGwgKSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0XHRmb3IgKCBldmVudE5hbWUgaW4gdGhpcy5fc3VicyApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fc3Vic1sgZXZlbnROYW1lIF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcblx0XHRcdFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdCggJyAnICkubWFwKCB0cmltICkuZmlsdGVyKCBub3RFbXB0eVN0cmluZyApO1xuXHRcdFx0XHRldmVudE5hbWVzLmZvckVhY2goIGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdFx0dmFyIHN1YnNjcmliZXJzLCBpbmRleDtcblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIHN1YnNjcmliZXJzIGZvciB0aGlzIGV2ZW50Li4uXG5cdFx0XHRcdFx0aWYgKCBzdWJzY3JpYmVycyA9IHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5pZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIG9ubHkgcmVtb3ZlIHRoYXRcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZiggY2FsbGJhY2sgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3Vic2NyaWJlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdID0gW107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF90cmltLCBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29uLmpzICovXG5cdHZhciBSYWN0aXZlJG9uID0gZnVuY3Rpb24oIHRyaW0sIG5vdEVtcHR5U3RyaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb24oIGV2ZW50TmFtZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0bGlzdGVuZXJzLCBuLCBldmVudE5hbWVzO1xuXHRcdFx0Ly8gYWxsb3cgbXV0bGlwbGUgbGlzdGVuZXJzIHRvIGJlIGJvdW5kIGluIG9uZSBnb1xuXHRcdFx0aWYgKCB0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0bGlzdGVuZXJzID0gW107XG5cdFx0XHRcdGZvciAoIG4gaW4gZXZlbnROYW1lICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnROYW1lLmhhc093blByb3BlcnR5KCBuICkgKSB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lcnMucHVzaCggdGhpcy5vbiggbiwgZXZlbnROYW1lWyBuIF0gKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGlzdGVuZXI7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGxpc3RlbmVyID0gbGlzdGVuZXJzLnBvcCgpICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG5cdFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KCAnICcgKS5tYXAoIHRyaW0gKS5maWx0ZXIoIG5vdEVtcHR5U3RyaW5nICk7XG5cdFx0XHRldmVudE5hbWVzLmZvckVhY2goIGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdCggdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSB8fCAoIHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gPSBbXSApICkucHVzaCggY2FsbGJhY2sgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5vZmYoIGV2ZW50TmFtZSwgY2FsbGJhY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF90cmltLCBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyApO1xuXG5cdC8qIHNoYXJlZC9nZXROZXdJbmRpY2VzLmpzICovXG5cdHZhciBnZXROZXdJbmRpY2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSwgdGhlIG5hbWUgb2YgYSBtdXRhdG9yIG1ldGhvZCwgYW5kIHRoZVxuXHRcdC8vIGFyZ3VtZW50cyB0byBjYWxsIHRoYXQgbXV0YXRvciBtZXRob2Qgd2l0aCwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdFxuXHRcdC8vIG1hcHMgdGhlIG9sZCBpbmRpY2VzIHRvIHRoZWlyIG5ldyBpbmRpY2VzLlxuXHRcdC8vIFNvIGlmIHlvdSBoYWQgc29tZXRoaW5nIGxpa2UgdGhpcy4uLlxuXHRcdC8vXG5cdFx0Ly8gICAgIGFycmF5ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcblx0XHQvLyAgICAgYXJyYXkucHVzaCggJ2UnICk7XG5cdFx0Ly9cblx0XHQvLyAuLi55b3UnZCBnZXQgYFsgMCwgMSwgMiwgMyBdYCAtIGluIG90aGVyIHdvcmRzLCBub25lIG9mIHRoZSBvbGQgaW5kaWNlc1xuXHRcdC8vIGhhdmUgY2hhbmdlZC4gSWYgeW91IHRoZW4gZGlkIHRoaXMuLi5cblx0XHQvL1xuXHRcdC8vICAgICBhcnJheS51bnNoaWZ0KCAneicgKTtcblx0XHQvL1xuXHRcdC8vIC4uLnRoZSBpbmRpY2VzIHdvdWxkIGJlIGBbIDEsIDIsIDMsIDQsIDUgXWAgLSBldmVyeSBpdGVtIGhhcyBiZWVuIG1vdmVkXG5cdFx0Ly8gb25lIGhpZ2hlciB0byBtYWtlIHJvb20gZm9yIHRoZSAneicuIElmIHlvdSByZW1vdmVkIGFuIGl0ZW0sIHRoZSBuZXcgaW5kZXhcblx0XHQvLyB3b3VsZCBiZSAtMS4uLlxuXHRcdC8vXG5cdFx0Ly8gICAgIGFycmF5LnNwbGljZSggMiwgMiApO1xuXHRcdC8vXG5cdFx0Ly8gLi4udGhpcyB3b3VsZCByZXN1bHQgaW4gWyAwLCAxLCAtMSwgLTEsIDIsIDMgXS5cblx0XHQvL1xuXHRcdC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBlbmFibGUgZmFzdCwgbm9uLWRlc3RydWN0aXZlIHNodWZmbGluZyBvZiBsaXN0XG5cdFx0Ly8gc2VjdGlvbnMgd2hlbiB5b3UgZG8gZS5nLiBgcmFjdGl2ZS5zcGxpY2UoICdpdGVtcycsIDIsIDIgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGdldE5ld0luZGljZXMoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICkge1xuXHRcdFx0dmFyIHNwbGljZUFyZ3VtZW50cywgbGVuLCBuZXdJbmRpY2VzID0gW10sXG5cdFx0XHRcdHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQsIGJhbGFuY2UsIGk7XG5cdFx0XHRzcGxpY2VBcmd1bWVudHMgPSBnZXRTcGxpY2VFcXVpdmFsZW50KCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApO1xuXHRcdFx0aWYgKCAhc3BsaWNlQXJndW1lbnRzICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGxlbiA9IGFycmF5Lmxlbmd0aDtcblx0XHRcdGJhbGFuY2UgPSBzcGxpY2VBcmd1bWVudHMubGVuZ3RoIC0gMiAtIHNwbGljZUFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0cmVtb3ZlU3RhcnQgPSBNYXRoLm1pbiggbGVuLCBzcGxpY2VBcmd1bWVudHNbIDAgXSApO1xuXHRcdFx0cmVtb3ZlRW5kID0gcmVtb3ZlU3RhcnQgKyBzcGxpY2VBcmd1bWVudHNbIDEgXTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcmVtb3ZlU3RhcnQ7IGkgKz0gMSApIHtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGkgPCByZW1vdmVFbmQ7IGkgKz0gMSApIHtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCAtMSApO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaSArIGJhbGFuY2UgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXdJbmRpY2VzO1xuXHRcdH07XG5cdFx0Ly8gVGhlIHBvcCwgcHVzaCwgc2hpZnQgYW4gdW5zaGlmdCBtZXRob2RzIGNhbiBhbGwgYmUgcmVwcmVzZW50ZWRcblx0XHQvLyBhcyBhbiBlcXVpdmFsZW50IHNwbGljZVxuXHRcdGZ1bmN0aW9uIGdldFNwbGljZUVxdWl2YWxlbnQoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICkge1xuXHRcdFx0c3dpdGNoICggbWV0aG9kTmFtZSApIHtcblx0XHRcdFx0Y2FzZSAnc3BsaWNlJzpcblx0XHRcdFx0XHRpZiAoIGFyZ3NbIDAgXSAhPT0gdW5kZWZpbmVkICYmIGFyZ3NbIDAgXSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRhcmdzWyAwIF0gPSBhcnJheS5sZW5ndGggKyBNYXRoLm1heCggYXJnc1sgMCBdLCAtYXJyYXkubGVuZ3RoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggYXJncy5sZW5ndGggPCAyICkge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKCAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGVuc3VyZSB3ZSBvbmx5IHJlbW92ZSBlbGVtZW50cyB0aGF0IGV4aXN0XG5cdFx0XHRcdFx0YXJnc1sgMSBdID0gTWF0aC5taW4oIGFyZ3NbIDEgXSwgYXJyYXkubGVuZ3RoIC0gYXJnc1sgMCBdICk7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0XHRcdGNhc2UgJ3NvcnQnOlxuXHRcdFx0XHRjYXNlICdyZXZlcnNlJzpcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0Y2FzZSAncG9wJzpcblx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdGFycmF5Lmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0XHRcdDFcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRjYXNlICdwdXNoJzpcblx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0YXJyYXkubGVuZ3RoLFxuXHRcdFx0XHRcdFx0MFxuXHRcdFx0XHRcdF0uY29uY2F0KCBhcmdzICk7XG5cdFx0XHRcdGNhc2UgJ3NoaWZ0Jzpcblx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDFcblx0XHRcdFx0XHRdO1xuXHRcdFx0XHRjYXNlICd1bnNoaWZ0Jzpcblx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDBcblx0XHRcdFx0XHRdLmNvbmNhdCggYXJncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZUFycmF5TWV0aG9kLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgPSBmdW5jdGlvbiggaXNBcnJheSwgcnVubG9vcCwgZ2V0TmV3SW5kaWNlcyApIHtcblxuXHRcdHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXHRcdHJldHVybiBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0XHRcdHZhciBhcmdzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHRcdFx0dmFyIGFycmF5LCBuZXdJbmRpY2VzID0gW10sXG5cdFx0XHRcdFx0bGVuLCBwcm9taXNlLCByZXN1bHQ7XG5cdFx0XHRcdGFycmF5ID0gdGhpcy5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBhcnJheSApICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NhbGxlZCByYWN0aXZlLicgKyBtZXRob2ROYW1lICsgJyhcXCcnICsga2V5cGF0aCArICdcXCcpLCBidXQgXFwnJyArIGtleXBhdGggKyAnXFwnIGRvZXMgbm90IHJlZmVyIHRvIGFuIGFycmF5JyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0luZGljZXMgPSBnZXROZXdJbmRpY2VzKCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApO1xuXHRcdFx0XHRyZXN1bHQgPSBhcnJheVByb3RvWyBtZXRob2ROYW1lIF0uYXBwbHkoIGFycmF5LCBhcmdzICk7XG5cdFx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICkudGhlbiggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoICEhbmV3SW5kaWNlcyApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzQXJyYXksIHJ1bmxvb3AsIGdldE5ld0luZGljZXMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9wb3AuanMgKi9cblx0dmFyIFJhY3RpdmUkcG9wID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdwb3AnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3B1c2guanMgKi9cblx0dmFyIFJhY3RpdmUkcHVzaCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAncHVzaCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogZ2xvYmFsL2Nzcy5qcyAqL1xuXHR2YXIgZ2xvYmFsX2NzcyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgaXNDbGllbnQsIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBjc3MsIHVwZGF0ZSwgcnVubG9vcCwgc3R5bGVFbGVtZW50LCBoZWFkLCBzdHlsZVNoZWV0LCBpbkRvbSwgcHJlZml4ID0gJy8qIFJhY3RpdmUuanMgY29tcG9uZW50IHN0eWxlcyAqL1xcbicsXG5cdFx0XHRjb21wb25lbnRzSW5QYWdlID0ge30sXG5cdFx0XHRzdHlsZXMgPSBbXTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGNzcyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wID0gY2lyY3VsYXIucnVubG9vcDtcblx0XHRcdH0gKTtcblx0XHRcdHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzdHlsZScgKTtcblx0XHRcdHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJztcblx0XHRcdGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2hlYWQnIClbIDAgXTtcblx0XHRcdGluRG9tID0gZmFsc2U7XG5cdFx0XHQvLyBJbnRlcm5ldCBFeHBsb2RlciB3b24ndCBsZXQgeW91IHVzZSBzdHlsZVNoZWV0LmlubmVySFRNTCAtIHdlIGhhdmUgdG9cblx0XHRcdC8vIHVzZSBzdHlsZVNoZWV0LmNzc1RleHQgaW5zdGVhZFxuXHRcdFx0c3R5bGVTaGVldCA9IHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0O1xuXHRcdFx0dXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBjc3M7XG5cdFx0XHRcdGlmICggc3R5bGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRjc3MgPSBwcmVmaXggKyBzdHlsZXMuam9pbiggJyAnICk7XG5cdFx0XHRcdFx0aWYgKCBzdHlsZVNoZWV0ICkge1xuXHRcdFx0XHRcdFx0c3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gY3NzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFpbkRvbSApIHtcblx0XHRcdFx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoIHN0eWxlRWxlbWVudCApO1xuXHRcdFx0XHRcdFx0aW5Eb20gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggaW5Eb20gKSB7XG5cdFx0XHRcdFx0aGVhZC5yZW1vdmVDaGlsZCggc3R5bGVFbGVtZW50ICk7XG5cdFx0XHRcdFx0aW5Eb20gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGNzcyA9IHtcblx0XHRcdFx0YWRkOiBmdW5jdGlvbiggQ29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGlmICggIUNvbXBvbmVudC5jc3MgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0Ly8gd2UgY3JlYXRlIHRoaXMgY291bnRlciBzbyB0aGF0IHdlIGNhbiBpbi9kZWNyZW1lbnQgaXQgYXNcblx0XHRcdFx0XHRcdC8vIGluc3RhbmNlcyBhcmUgYWRkZWQgYW5kIHJlbW92ZWQuIFdoZW4gYWxsIGNvbXBvbmVudHMgYXJlXG5cdFx0XHRcdFx0XHQvLyByZW1vdmVkLCB0aGUgc3R5bGUgaXMgdG9vXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSA9IDA7XG5cdFx0XHRcdFx0XHRzdHlsZXMucHVzaCggQ29tcG9uZW50LmNzcyApO1xuXHRcdFx0XHRcdFx0dXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICs9IDE7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIENvbXBvbmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFDb21wb25lbnQuY3NzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSAtPSAxO1xuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBzdHlsZXMsIENvbXBvbmVudC5jc3MgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCB1cGRhdGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjc3M7XG5cdH0oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciBSYWN0aXZlJHJlbmRlciA9IGZ1bmN0aW9uKCBjc3MsIEhvb2ssIGdldEVsZW1lbnQsIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgcmVuZGVySG9vayA9IG5ldyBIb29rKCAncmVuZGVyJyApLFxuXHRcdFx0Y29tcGxldGVIb29rID0gbmV3IEhvb2soICdjb21wbGV0ZScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZW5kZXIoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzLCB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHQvLyBpZiBgbm9JbnRyb2AgaXMgYHRydWVgLCB0ZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zXG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdGlmICggdGhpcy5ub0ludHJvICkge1xuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHJlbmRlckhvb2suZmlyZSggdGhpcyQwICk7XG5cdFx0XHR9LCB0cnVlICk7XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1lvdSBjYW5ub3QgY2FsbCByYWN0aXZlLnJlbmRlcigpIG9uIGFuIGFscmVhZHkgcmVuZGVyZWQgaW5zdGFuY2UhIENhbGwgcmFjdGl2ZS51bnJlbmRlcigpIGZpcnN0JyApO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCggdGFyZ2V0ICkgfHwgdGhpcy5lbDtcblx0XHRcdGFuY2hvciA9IGdldEVsZW1lbnQoIGFuY2hvciApIHx8IHRoaXMuYW5jaG9yO1xuXHRcdFx0dGhpcy5lbCA9IHRhcmdldDtcblx0XHRcdHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuXHRcdFx0Ly8gQWRkIENTUywgaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCB0aGlzLmNvbnN0cnVjdG9yLmNzcyApIHtcblx0XHRcdFx0Y3NzLmFkZCggdGhpcy5jb25zdHJ1Y3RvciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cdFx0XHRcdGlmICggISggaW5zdGFuY2VzID0gdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApICkge1xuXHRcdFx0XHRcdHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbIHRoaXMgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbnN0YW5jZXMucHVzaCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYW5jaG9yICkge1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZnJhZ21lbnQucmVuZGVyKCksIGFuY2hvciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHQvLyBJdCBpcyBub3cgbW9yZSBwcm9ibGVtYXRpYyB0byBrbm93IGlmIHRoZSBjb21wbGV0ZSBob29rXG5cdFx0XHQvLyB3b3VsZCBmaXJlLiBNZXRob2QgY2hlY2tpbmcgaXMgc3RyYWlnaHQtZm9yd2FyZCwgYnV0IHdvdWxkXG5cdFx0XHQvLyBhbHNvIHJlcXVpcmUgcHJlZmxpZ2h0aW5nIGV2ZW50IHN1YnNjcmlwdGlvbnMuIFdoaWNoIHNlZW1zXG5cdFx0XHQvLyBsaWtlIG1vcmUgd29yayB0aGVuIGp1c3QgbGV0dGluZyB0aGUgcHJvbWlzZSBoYXBwZW4uXG5cdFx0XHQvLyBCdXQgcGVyaGFwcyBJJ20gd3JvbmcgYWJvdXQgdGhhdC4uLlxuXHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlSG9vay5maXJlKCB0aGlzJDAgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIGdsb2JhbF9jc3MsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIGdldEVsZW1lbnQsIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkYnViYmxlID0gZnVuY3Rpb24gRnJhZ21lbnQkYnViYmxlKCkge1xuXHRcdHRoaXMuZGlydHlWYWx1ZSA9IHRoaXMuZGlydHlBcmdzID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMuYm91bmQgJiYgdHlwZW9mIHRoaXMub3duZXIuYnViYmxlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dGhpcy5vd25lci5idWJibGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGRldGFjaCA9IGZ1bmN0aW9uIEZyYWdtZW50JGRldGFjaCgpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRpZiAoIHRoaXMuaXRlbXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXNbIDAgXS5kZXRhY2goKTtcblx0XHR9XG5cdFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0dmFyIG5vZGUgPSBpdGVtLmRldGFjaCgpO1xuXHRcdFx0Ly8gVE9ETyBUaGUgaWYgey4uLn0gd2Fzbid0IHByZXZpb3VzbHkgcmVxdWlyZWQgLSBpdCBpcyBub3csIGJlY2F1c2Ugd2UncmVcblx0XHRcdC8vIGZvcmNpYmx5IGRldGFjaGluZyBldmVyeXRoaW5nIHRvIHJlb3JkZXIgc2VjdGlvbnMgYWZ0ZXIgYW4gdXBkYXRlLiBUaGF0J3Ncblx0XHRcdC8vIGEgbm9uLWlkZWFsIGJydXRlIGZvcmNlIGFwcHJvYWNoLCBpbXBsZW1lbnRlZCB0byBnZXQgYWxsIHRoZSB0ZXN0cyB0byBwYXNzXG5cdFx0XHQvLyAtIGFzIHNvb24gYXMgaXQncyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBtb3JlIGVsZWdhbnQsIHRoaXMgc2hvdWxkXG5cdFx0XHQvLyByZXZlcnQgdG8gYGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKWBcblx0XHRcdGlmICggbm9kZSApIHtcblx0XHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gZG9jRnJhZztcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmQgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtLCBxdWVyeVJlc3VsdDtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kICYmICggcXVlcnlSZXN1bHQgPSBpdGVtLmZpbmQoIHNlbGVjdG9yICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGwgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbiwgaXRlbTtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kQWxsICkge1xuXHRcdFx0XHRcdGl0ZW0uZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRBbGxDb21wb25lbnRzICkge1xuXHRcdFx0XHRcdGl0ZW0uZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBxdWVyeTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHR2YXIgbGVuLCBpLCBpdGVtLCBxdWVyeVJlc3VsdDtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kQ29tcG9uZW50ICYmICggcXVlcnlSZXN1bHQgPSBpdGVtLmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZE5leHROb2RlKCBpdGVtICkge1xuXHRcdHZhciBpbmRleCA9IGl0ZW0uaW5kZXgsXG5cdFx0XHRub2RlO1xuXHRcdGlmICggdGhpcy5pdGVtc1sgaW5kZXggKyAxIF0gKSB7XG5cdFx0XHRub2RlID0gdGhpcy5pdGVtc1sgaW5kZXggKyAxIF0uZmlyc3ROb2RlKCk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5vd25lciA9PT0gdGhpcy5yb290ICkge1xuXHRcdFx0aWYgKCAhdGhpcy5vd25lci5jb21wb25lbnQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gYnV0IHNvbWV0aGluZyBlbHNlIGNvdWxkIGhhdmUgYmVlbiBhcHBlbmRlZCB0b1xuXHRcdFx0XHQvLyB0aGlzLnJvb3QuZWwsIG5vP1xuXHRcdFx0XHRub2RlID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm93bmVyLmNvbXBvbmVudC5maW5kTmV4dE5vZGUoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZSA9IHRoaXMub3duZXIuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRmaXJzdE5vZGUoKSB7XG5cdFx0aWYgKCB0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXNbIDAgXSApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zWyAwIF0uZmlyc3ROb2RlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2dldE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGdldE5vZGUoKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gdGhpcztcblx0XHRkbyB7XG5cdFx0XHRpZiAoIGZyYWdtZW50LnBFbGVtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQucEVsZW1lbnQubm9kZTtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRyZXR1cm4gdGhpcy5yb290LmRldGFjaGVkIHx8IHRoaXMucm9vdC5lbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9nZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRnZXRWYWx1ZSA9IGZ1bmN0aW9uKCBwYXJzZUpTT04gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGVtcHR5ID0ge307XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBGcmFnbWVudCRnZXRWYWx1ZSgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAwIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSBlbXB0eTtcblx0XHRcdHZhciBhc0FyZ3MsIHZhbHVlcywgc291cmNlLCBwYXJzZWQsIGNhY2hlZFJlc3VsdCwgZGlydHlGbGFnLCByZXN1bHQ7XG5cdFx0XHRhc0FyZ3MgPSBvcHRpb25zLmFyZ3M7XG5cdFx0XHRjYWNoZWRSZXN1bHQgPSBhc0FyZ3MgPyAnYXJnc0xpc3QnIDogJ3ZhbHVlJztcblx0XHRcdGRpcnR5RmxhZyA9IGFzQXJncyA/ICdkaXJ0eUFyZ3MnIDogJ2RpcnR5VmFsdWUnO1xuXHRcdFx0aWYgKCB0aGlzWyBkaXJ0eUZsYWcgXSApIHtcblx0XHRcdFx0c291cmNlID0gcHJvY2Vzc0l0ZW1zKCB0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkICk7XG5cdFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTiggYXNBcmdzID8gJ1snICsgc291cmNlICsgJ10nIDogc291cmNlLCB2YWx1ZXMgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VkICkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGFzQXJncyA/IFsgdGhpcy50b1N0cmluZygpIF0gOiB0aGlzLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXNbIGNhY2hlZFJlc3VsdCBdID0gcmVzdWx0O1xuXHRcdFx0XHR0aGlzWyBkaXJ0eUZsYWcgXSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXNbIGNhY2hlZFJlc3VsdCBdO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzSXRlbXMoIGl0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIgKSB7XG5cdFx0XHRjb3VudGVyID0gY291bnRlciB8fCAwO1xuXHRcdFx0cmV0dXJuIGl0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdHZhciBwbGFjZWhvbGRlcklkLCB3cmFwcGVkLCB2YWx1ZTtcblx0XHRcdFx0aWYgKCBpdGVtLnRleHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0udGV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGl0ZW0uZnJhZ21lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtLmZyYWdtZW50cy5tYXAoIGZ1bmN0aW9uKCBmcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzSXRlbXMoIGZyYWdtZW50Lml0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIgKTtcblx0XHRcdFx0XHR9ICkuam9pbiggJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbGFjZWhvbGRlcklkID0gZ3VpZCArICctJyArIGNvdW50ZXIrKztcblx0XHRcdFx0aWYgKCB3cmFwcGVkID0gaXRlbS5yb290LnZpZXdtb2RlbC53cmFwcGVkWyBpdGVtLmtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBpdGVtLmdldFZhbHVlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWVzWyBwbGFjZWhvbGRlcklkIF0gPSB2YWx1ZTtcblx0XHRcdFx0cmV0dXJuICckeycgKyBwbGFjZWhvbGRlcklkICsgJ30nO1xuXHRcdFx0fSApLmpvaW4oICcnICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggcGFyc2VKU09OICk7XG5cblx0LyogdXRpbHMvZXNjYXBlSHRtbC5qcyAqL1xuXHR2YXIgZXNjYXBlSHRtbCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGxlc3NUaGFuID0gLzwvZztcblx0XHR2YXIgZ3JlYXRlclRoYW4gPSAvPi9nO1xuXHRcdHZhciBhbXAgPSAvJi9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBlc2NhcGVIdG1sKCBzdHIgKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIGFtcCwgJyZhbXA7JyApLnJlcGxhY2UoIGxlc3NUaGFuLCAnJmx0OycgKS5yZXBsYWNlKCBncmVhdGVyVGhhbiwgJyZndDsnICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2RldGFjaE5vZGUuanMgKi9cblx0dmFyIGRldGFjaE5vZGUgPSBmdW5jdGlvbiBkZXRhY2hOb2RlKCBub2RlICkge1xuXHRcdGlmICggbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvZGV0YWNoLmpzICovXG5cdHZhciBkZXRhY2ggPSBmdW5jdGlvbiggZGV0YWNoTm9kZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBkZXRhY2hOb2RlKCB0aGlzLm5vZGUgKTtcblx0XHR9O1xuXHR9KCBkZXRhY2hOb2RlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UZXh0LmpzICovXG5cdHZhciBUZXh0ID0gZnVuY3Rpb24oIHR5cGVzLCBlc2NhcGVIdG1sLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgVGV4dCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuVEVYVDtcblx0XHRcdHRoaXMudGV4dCA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0fTtcblx0XHRUZXh0LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRoaXMudGV4dCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCBlc2NhcGUgKSB7XG5cdFx0XHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKCB0aGlzLnRleHQgKSA6IHRoaXMudGV4dDtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2goKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFRleHQ7XG5cdH0oIHR5cGVzLCBlc2NhcGVIdG1sLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91bmJpbmQuanMgKi9cblx0dmFyIHVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCgpIHtcblx0XHRpZiAoIHRoaXMucmVnaXN0ZXJlZCApIHtcblx0XHRcdC8vIHRoaXMgd2FzIHJlZ2lzdGVyZWQgYXMgYSBkZXBlbmRhbnRcblx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5yZXNvbHZlciApIHtcblx0XHRcdHRoaXMucmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL2dldFZhbHVlLmpzICovXG5cdHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIE11c3RhY2hlJGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL3N0YXJ0c1dpdGhLZXlwYXRoLmpzICovXG5cdHZhciBzdGFydHNXaXRoS2V5cGF0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0cmV0dXJuIHRhcmdldCAmJiBrZXlwYXRoICYmIHRhcmdldC5zdWJzdHIoIDAsIGtleXBhdGgubGVuZ3RoICsgMSApID09PSBrZXlwYXRoICsgJy4nO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2dldE5ld0tleXBhdGguanMgKi9cblx0dmFyIGdldE5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aEtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TmV3S2V5cGF0aCggdGFyZ2V0S2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdC8vIGV4YWN0IG1hdGNoXG5cdFx0XHRpZiAoIHRhcmdldEtleXBhdGggPT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiBuZXdLZXlwYXRoICE9PSB1bmRlZmluZWQgPyBuZXdLZXlwYXRoIDogbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIHBhcnRpYWwgbWF0Y2ggYmFzZWQgb24gbGVhZGluZyBrZXlwYXRoIHNlZ21lbnRzXG5cdFx0XHRpZiAoIHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXRLZXlwYXRoLCBvbGRLZXlwYXRoICkgKSB7XG5cdFx0XHRcdHJldHVybiBuZXdLZXlwYXRoID09PSBudWxsID8gbmV3S2V5cGF0aCA6IHRhcmdldEtleXBhdGgucmVwbGFjZSggb2xkS2V5cGF0aCArICcuJywgbmV3S2V5cGF0aCArICcuJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGhLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1JlZmVyZW5jZVJlc29sdmVyLmpzICovXG5cdHZhciBSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCByZXNvbHZlUmVmLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCByZWYsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGtleXBhdGg7XG5cdFx0XHR0aGlzLnJlZiA9IHJlZjtcblx0XHRcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMucm9vdCA9IG93bmVyLnJvb3Q7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggb3duZXIucm9vdCwgcmVmLCBvd25lci5wYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0aWYgKCBrZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIGtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmUoIHRoaXMucmVmICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aDtcblx0XHRcdFx0aWYgKCB0aGlzLmtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRrZXlwYXRoID0gZ2V0TmV3S2V5cGF0aCggdGhpcy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdFx0Ly8gd2FzIGEgbmV3IGtleXBhdGggY3JlYXRlZD9cblx0XHRcdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdC8vIHJlc29sdmUgaXRcblx0XHRcdFx0XHRcdHRoaXMucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVzb2x2ZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBSZWZlcmVuY2VSZXNvbHZlcjtcblx0fSggcnVubG9vcCwgcmVzb2x2ZVJlZiwgZ2V0TmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9TcGVjaWFsUmVzb2x2ZXIuanMgKi9cblx0dmFyIFNwZWNpYWxSZXNvbHZlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIFNwZWNpYWxSZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcmVmLCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVmID0gcmVmO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5yZWJpbmQoKTtcblx0XHR9O1xuXHRcdFNwZWNpYWxSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVmID0gdGhpcy5yZWYsXG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0XHRpZiAoIHJlZiA9PT0gJ0BrZXlwYXRoJyApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhIWZyYWdtZW50LmNvbnRleHQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKCAnQCcgKyBmcmFnbWVudC5jb250ZXh0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCByZWYgPT09ICdAaW5kZXgnIHx8IHJlZiA9PT0gJ0BrZXknICkge1xuXHRcdFx0XHRcdHdoaWxlICggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGZyYWdtZW50LmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKCAnQCcgKyBmcmFnbWVudC5pbmRleCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gc3BlY2lhbCByZWZlcmVuY2UgXCInICsgcmVmICsgJ1wiIC0gdmFsaWQgcmVmZXJlbmNlcyBhcmUgQGluZGV4LCBAa2V5IGFuZCBAa2V5cGF0aCcgKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge31cblx0XHR9O1xuXHRcdHJldHVybiBTcGVjaWFsUmVzb2x2ZXI7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvSW5kZXhSZXNvbHZlci5qcyAqL1xuXHR2YXIgSW5kZXhSZXNvbHZlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIEluZGV4UmVzb2x2ZXIgPSBmdW5jdGlvbiggb3duZXIsIHJlZiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnJlZiA9IHJlZjtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMucmViaW5kKCk7XG5cdFx0fTtcblx0XHRJbmRleFJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZWYgPSB0aGlzLnJlZixcblx0XHRcdFx0XHRpbmRleFJlZnMgPSB0aGlzLnBhcmVudEZyYWdtZW50LmluZGV4UmVmcyxcblx0XHRcdFx0XHRpbmRleCA9IGluZGV4UmVmc1sgcmVmIF07XG5cdFx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmNhbGxiYWNrKCAnQCcgKyBpbmRleCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblx0XHRyZXR1cm4gSW5kZXhSZXNvbHZlcjtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9jcmVhdGVSZWZlcmVuY2VSZXNvbHZlci5qcyAqL1xuXHR2YXIgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiggUmVmZXJlbmNlUmVzb2x2ZXIsIFNwZWNpYWxSZXNvbHZlciwgSW5kZXhSZXNvbHZlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggb3duZXIsIHJlZiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgaW5kZXhSZWZzLCBpbmRleDtcblx0XHRcdGlmICggcmVmLmNoYXJBdCggMCApID09PSAnQCcgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgU3BlY2lhbFJlc29sdmVyKCBvd25lciwgcmVmLCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdFx0aW5kZXhSZWZzID0gb3duZXIucGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0aWYgKCBpbmRleFJlZnMgJiYgKCBpbmRleCA9IGluZGV4UmVmc1sgcmVmIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEluZGV4UmVzb2x2ZXIoIG93bmVyLCByZWYsIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFJlZmVyZW5jZVJlc29sdmVyKCBvd25lciwgcmVmLCBjYWxsYmFjayApO1xuXHRcdH07XG5cdH0oIFJlZmVyZW5jZVJlc29sdmVyLCBTcGVjaWFsUmVzb2x2ZXIsIEluZGV4UmVzb2x2ZXIgKTtcblxuXHQvKiBzaGFyZWQvZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nLmpzICovXG5cdHZhciBnZXRGdW5jdGlvbkZyb21TdHJpbmcgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjYWNoZSA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRGdW5jdGlvbkZyb21TdHJpbmcoIHN0ciwgaSApIHtcblx0XHRcdHZhciBmbiwgYXJncztcblx0XHRcdGlmICggY2FjaGVbIHN0ciBdICkge1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVbIHN0ciBdO1xuXHRcdFx0fVxuXHRcdFx0YXJncyA9IFtdO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGFyZ3NbIGkgXSA9ICdfJyArIGk7XG5cdFx0XHR9XG5cdFx0XHRmbiA9IG5ldyBGdW5jdGlvbiggYXJncy5qb2luKCAnLCcgKSwgJ3JldHVybignICsgc3RyICsgJyknICk7XG5cdFx0XHRjYWNoZVsgc3RyIF0gPSBmbjtcblx0XHRcdHJldHVybiBmbjtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL0V4cHJlc3Npb25SZXNvbHZlci5qcyAqL1xuXHR2YXIgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnR5LCBpc051bWVyaWMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBnZXRGdW5jdGlvbkZyb21TdHJpbmcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEV4cHJlc3Npb25SZXNvbHZlciwgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXHRcdEV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcGFyZW50RnJhZ21lbnQsIGV4cHJlc3Npb24sIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHJlc29sdmVyID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgaW5kZXhSZWZzO1xuXHRcdFx0cmFjdGl2ZSA9IG93bmVyLnJvb3Q7XG5cdFx0XHRyZXNvbHZlci5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHJlc29sdmVyLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZXNvbHZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0cmVzb2x2ZXIub3duZXIgPSBvd25lcjtcblx0XHRcdHJlc29sdmVyLnN0ciA9IGV4cHJlc3Npb24ucztcblx0XHRcdHJlc29sdmVyLmtleXBhdGhzID0gW107XG5cdFx0XHRpbmRleFJlZnMgPSBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnM7XG5cdFx0XHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuXHRcdFx0cmVzb2x2ZXIucGVuZGluZyA9IGV4cHJlc3Npb24uci5sZW5ndGg7XG5cdFx0XHRyZXNvbHZlci5yZWZSZXNvbHZlcnMgPSBleHByZXNzaW9uLnIubWFwKCBmdW5jdGlvbiggcmVmLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIHJlc29sdmVyLCByZWYsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJlc29sdmVyLnJlc29sdmUoIGksIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmVzb2x2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0fTtcblx0XHRFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51bmlxdWVTdHJpbmcgPSBnZXRVbmlxdWVTdHJpbmcoIHRoaXMuc3RyLCB0aGlzLmtleXBhdGhzICk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGdldEtleXBhdGgoIHRoaXMudW5pcXVlU3RyaW5nICk7XG5cdFx0XHRcdHRoaXMuY3JlYXRlRXZhbHVhdG9yKCk7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZXNvbHZlcjtcblx0XHRcdFx0d2hpbGUgKCByZXNvbHZlciA9IHRoaXMucmVmUmVzb2x2ZXJzLnBvcCgpICkge1xuXHRcdFx0XHRcdHJlc29sdmVyLnVuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oIGluZGV4LCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmtleXBhdGhzWyBpbmRleCBdID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRjcmVhdGVFdmFsdWF0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRcdGNvbXB1dGF0aW9uLCB2YWx1ZUdldHRlcnMsIHNpZ25hdHVyZSwga2V5cGF0aCwgZm47XG5cdFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRhdGlvbnNbIHRoaXMua2V5cGF0aCBdO1xuXHRcdFx0XHQvLyBvbmx5IGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0IVxuXHRcdFx0XHRpZiAoICFjb21wdXRhdGlvbiApIHtcblx0XHRcdFx0XHRmbiA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZyggdGhpcy5zdHIsIHRoaXMucmVmUmVzb2x2ZXJzLmxlbmd0aCApO1xuXHRcdFx0XHRcdHZhbHVlR2V0dGVycyA9IHRoaXMua2V5cGF0aHMubWFwKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdFx0XHRcdGlmICgga2V5cGF0aCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gJ3NwZWNpYWwnIGtleXBhdGhzIGVuY29kZSBhIHZhbHVlXG5cdFx0XHRcdFx0XHRpZiAoIGtleXBhdGhbIDAgXSA9PT0gJ0AnICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGtleXBhdGguc2xpY2UoIDEgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGlzTnVtZXJpYyggdmFsdWUgKSA/IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiArdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH0gOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMkMC5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB3cmFwRnVuY3Rpb24oIHZhbHVlLCBzZWxmLnJvb3QgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRzaWduYXR1cmUgPSB7XG5cdFx0XHRcdFx0XHRkZXBzOiB0aGlzLmtleXBhdGhzLmZpbHRlciggaXNWYWxpZERlcGVuZGVuY3kgKSxcblx0XHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhcmdzID0gdmFsdWVHZXR0ZXJzLm1hcCggY2FsbCApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkoIG51bGwsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRlKCB0aGlzLmtleXBhdGgsIHNpZ25hdHVyZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwubWFyayggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdC8vIFRPRE8gb25seSBidWJibGUgb25jZSwgbm8gbWF0dGVyIGhvdyBtYW55IHJlZmVyZW5jZXMgYXJlIGFmZmVjdGVkIGJ5IHRoZSByZWJpbmRcblx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHIucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBFeHByZXNzaW9uUmVzb2x2ZXI7XG5cblx0XHRmdW5jdGlvbiBjYWxsKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5jYWxsKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VW5pcXVlU3RyaW5nKCBzdHIsIGtleXBhdGhzICkge1xuXHRcdFx0Ly8gZ2V0IHN0cmluZyB0aGF0IGlzIHVuaXF1ZSB0byB0aGlzIGV4cHJlc3Npb25cblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggL18oWzAtOV0rKS9nLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWU7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoc1sgJDEgXTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICd1bmRlZmluZWQnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnNsaWNlKCAxICk7XG5cdFx0XHRcdFx0cmV0dXJuIGlzTnVtZXJpYyggdmFsdWUgKSA/IHZhbHVlIDogJ1wiJyArIHZhbHVlICsgJ1wiJztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ga2V5cGF0aDtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLZXlwYXRoKCB1bmlxdWVTdHJpbmcgKSB7XG5cdFx0XHQvLyBTYW5pdGl6ZSBieSByZW1vdmluZyBhbnkgcGVyaW9kcyBvciBzcXVhcmUgYnJhY2tldHMuIE90aGVyd2lzZVxuXHRcdFx0Ly8gd2UgY2FuJ3Qgc3BsaXQgdGhlIGtleXBhdGggaW50byBrZXlzIVxuXHRcdFx0cmV0dXJuICckeycgKyB1bmlxdWVTdHJpbmcucmVwbGFjZSggL1tcXC5cXFtcXF1dL2csICctJyApICsgJ30nO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzVmFsaWREZXBlbmRlbmN5KCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIGtleXBhdGggIT09IHVuZGVmaW5lZCAmJiBrZXlwYXRoWyAwIF0gIT09ICdAJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cmFwRnVuY3Rpb24oIGZuLCByYWN0aXZlICkge1xuXHRcdFx0dmFyIHdyYXBwZWQsIHByb3AsIGtleTtcblx0XHRcdGlmICggZm4uX25vV3JhcCApIHtcblx0XHRcdFx0cmV0dXJuIGZuO1xuXHRcdFx0fVxuXHRcdFx0cHJvcCA9ICdfX3JhY3RpdmVfJyArIHJhY3RpdmUuX2d1aWQ7XG5cdFx0XHR3cmFwcGVkID0gZm5bIHByb3AgXTtcblx0XHRcdGlmICggd3JhcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIHdyYXBwZWQ7XG5cdFx0XHR9IGVsc2UgaWYgKCAvdGhpcy8udGVzdCggZm4udG9TdHJpbmcoKSApICkge1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggZm4sIHByb3AsIHtcblx0XHRcdFx0XHR2YWx1ZTogYmluZC5jYWxsKCBmbiwgcmFjdGl2ZSApXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Ly8gQWRkIHByb3BlcnRpZXMvbWV0aG9kcyB0byB3cmFwcGVkIGZ1bmN0aW9uXG5cdFx0XHRcdGZvciAoIGtleSBpbiBmbiApIHtcblx0XHRcdFx0XHRpZiAoIGZuLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHRcdGZuWyBwcm9wIF1bIGtleSBdID0gZm5bIGtleSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm5bIHByb3AgXTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnR5KCBmbiwgJ19fcmFjdGl2ZV9ub3dyYXAnLCB7XG5cdFx0XHRcdHZhbHVlOiBmblxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGZuLl9fcmFjdGl2ZV9ub3dyYXA7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZGVmaW5lUHJvcGVydHksIGlzTnVtZXJpYywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGdldEZ1bmN0aW9uRnJvbVN0cmluZywgbGVnYWN5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci9NZW1iZXJSZXNvbHZlci5qcyAqL1xuXHR2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiggdHlwZXMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKSB7XG5cblx0XHR2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiggdGVtcGxhdGUsIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdHZhciBtZW1iZXIgPSB0aGlzLFxuXHRcdFx0XHRrZXlwYXRoO1xuXHRcdFx0bWVtYmVyLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0XHRtZW1iZXIucm9vdCA9IHJlc29sdmVyLnJvb3Q7XG5cdFx0XHRtZW1iZXIucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdG1lbWJlci52aWV3bW9kZWwgPSByZXNvbHZlci5yb290LnZpZXdtb2RlbDtcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bWVtYmVyLnZhbHVlID0gdGVtcGxhdGU7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdG1lbWJlci5yZWZSZXNvbHZlciA9IGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCB0aGlzLCB0ZW1wbGF0ZS5uLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRtZW1iZXIucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXcgRXhwcmVzc2lvblJlc29sdmVyKCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRtZW1iZXIucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRNZW1iZXJSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlZlJlc29sdmVyICkge1xuXHRcdFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMua2V5cGF0aCApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMudW5yZXNvbHZlZCApIHtcblx0XHRcdFx0XHR0aGlzLnVucmVzb2x2ZWQudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMucmVmUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIE1lbWJlclJlc29sdmVyO1xuXHR9KCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLmpzICovXG5cdHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggcmVzb2x2ZVJlZiwgUmVmZXJlbmNlUmVzb2x2ZXIsIE1lbWJlclJlc29sdmVyICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBtdXN0YWNoZSwgdGVtcGxhdGUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCByZWYsIGtleXBhdGgsIHBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVzb2x2ZXIucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudCA9IG11c3RhY2hlLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVzb2x2ZXIucm9vdCA9IHJhY3RpdmUgPSBtdXN0YWNoZS5yb290O1xuXHRcdFx0cmVzb2x2ZXIubXVzdGFjaGUgPSBtdXN0YWNoZTtcblx0XHRcdHJlc29sdmVyLnJlZiA9IHJlZiA9IHRlbXBsYXRlLnI7XG5cdFx0XHRyZXNvbHZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0cmVzb2x2ZXIudW5yZXNvbHZlZCA9IFtdO1xuXHRcdFx0Ly8gRmluZCBiYXNlIGtleXBhdGhcblx0XHRcdGlmICgga2V5cGF0aCA9IHJlc29sdmVSZWYoIHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQgKSApIHtcblx0XHRcdFx0cmVzb2x2ZXIuYmFzZSA9IGtleXBhdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNvbHZlci5iYXNlUmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlUmVzb2x2ZXIoIHRoaXMsIHJlZiwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYmFzZSA9IGtleXBhdGg7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYmFzZVJlc29sdmVyID0gbnVsbDtcblx0XHRcdFx0XHRyZXNvbHZlci5idWJibGUoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmluZCB2YWx1ZXMgZm9yIG1lbWJlcnMsIG9yIG1hcmsgdGhlbSBhcyB1bnJlc29sdmVkXG5cdFx0XHRyZXNvbHZlci5tZW1iZXJzID0gdGVtcGxhdGUubS5tYXAoIGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBNZW1iZXJSZXNvbHZlciggdGVtcGxhdGUsIHRoaXMkMCwgcGFyZW50RnJhZ21lbnQgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJlc29sdmVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdHJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdH07XG5cdFx0UmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGdldEtleXBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5tZW1iZXJzLm1hcCggZ2V0VmFsdWUgKTtcblx0XHRcdFx0aWYgKCAhdmFsdWVzLmV2ZXJ5KCBpc0RlZmluZWQgKSB8fCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlICsgJy4nICsgdmFsdWVzLmpvaW4oICcuJyApO1xuXHRcdFx0fSxcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVhZHkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIHRoaXMuZ2V0S2V5cGF0aCgpICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGNoYW5nZWQ7XG5cdFx0XHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKCBmdW5jdGlvbiggbWVtYmVycyApIHtcblx0XHRcdFx0XHRpZiAoIG1lbWJlcnMucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5iYXNlID0gdGhpcy5yZWY7XG5cdFx0XHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0XHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKCBmdW5jdGlvbiggbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbS5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZSggbWVtYmVyICkge1xuXHRcdFx0cmV0dXJuIG1lbWJlci52YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0RlZmluZWQoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlICE9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIG1lbWJlciApIHtcblx0XHRcdG1lbWJlci51bmJpbmQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcjtcblx0fSggcmVzb2x2ZVJlZiwgUmVmZXJlbmNlUmVzb2x2ZXIsIE1lbWJlclJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvaW5pdGlhbGlzZS5qcyAqL1xuXHR2YXIgaW5pdGlhbGlzZSA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciwgRXhwcmVzc2lvblJlc29sdmVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIE11c3RhY2hlJGluaXQoIG11c3RhY2hlLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHJlZiwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0bXVzdGFjaGUucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHRtdXN0YWNoZS5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuXHRcdFx0bXVzdGFjaGUucEVsZW1lbnQgPSBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblx0XHRcdG11c3RhY2hlLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdG11c3RhY2hlLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuXHRcdFx0bXVzdGFjaGUuaXNTdGF0aWMgPSBvcHRpb25zLnRlbXBsYXRlLnM7XG5cdFx0XHRtdXN0YWNoZS50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXHRcdFx0bXVzdGFjaGUucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIHNpbXBsZSBtdXN0YWNoZSwgd2l0aCBhIHJlZmVyZW5jZSwgd2UganVzdCBuZWVkIHRvIHJlc29sdmVcblx0XHRcdC8vIHRoZSByZWZlcmVuY2UgdG8gYSBrZXlwYXRoXG5cdFx0XHRpZiAoIHJlZiA9IHRlbXBsYXRlLnIgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCBtdXN0YWNoZSwgcmVmLCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBpdCdzIGFuIGV4cHJlc3Npb24sIHdlIGhhdmUgYSBiaXQgbW9yZSB3b3JrIHRvIGRvXG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUueCApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgRXhwcmVzc2lvblJlc29sdmVyKCBtdXN0YWNoZSwgcGFyZW50RnJhZ21lbnQsIG9wdGlvbnMudGVtcGxhdGUueCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUucnggKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciggbXVzdGFjaGUsIG9wdGlvbnMudGVtcGxhdGUucngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW52ZXJ0ZWQgc2VjdGlvbnNcblx0XHRcdGlmICggbXVzdGFjaGUudGVtcGxhdGUubiA9PT0gdHlwZXMuU0VDVElPTl9VTkxFU1MgJiYgIW11c3RhY2hlLmhhc093blByb3BlcnR5KCAndmFsdWUnICkgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnNldFZhbHVlKCB1bmRlZmluZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSgga2V5cGF0aCApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4oIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBvbGRLZXlwYXRoID0gbXVzdGFjaGUua2V5cGF0aDtcblx0XHRcdFx0aWYgKCBuZXdLZXlwYXRoICE9PSBvbGRLZXlwYXRoICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLnJlc29sdmUoIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHRpZiAoIG9sZEtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLmZyYWdtZW50cyAmJiBtdXN0YWNoZS5mcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdFx0XHRcdGYucmViaW5kKCBudWxsLCBudWxsLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL3Jlc29sdmUuanMgKi9cblx0dmFyIHJlc29sdmUgPSBmdW5jdGlvbiggaXNOdW1lcmljICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIE11c3RhY2hlJHJlc29sdmUoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgd2FzUmVzb2x2ZWQsIHZhbHVlLCB0d293YXlCaW5kaW5nO1xuXHRcdFx0Ly8gJ1NwZWNpYWwnIGtleXBhdGhzLCBlLmcuIEBmb28gb3IgQDcsIGVuY29kZSBhIHZhbHVlXG5cdFx0XHRpZiAoIGtleXBhdGggJiYga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdHZhbHVlID0ga2V5cGF0aC5zbGljZSggMSApO1xuXHRcdFx0XHRpZiAoIGlzTnVtZXJpYyggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9ICt2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB3ZSByZXNvbHZlZCBwcmV2aW91c2x5LCB3ZSBuZWVkIHRvIHVucmVnaXN0ZXJcblx0XHRcdGlmICggdGhpcy5yZWdpc3RlcmVkICkge1xuXHRcdFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblx0XHRcdFx0d2FzUmVzb2x2ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdC8vIElmIHRoZSBuZXcga2V5cGF0aCBleGlzdHMsIHdlIG5lZWQgdG8gcmVnaXN0ZXJcblx0XHRcdC8vIHdpdGggdGhlIHZpZXdtb2RlbFxuXHRcdFx0aWYgKCBrZXlwYXRoICE9IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKCBrZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBFaXRoZXIgd2F5IHdlIG5lZWQgdG8gcXVldWUgdXAgYSByZW5kZXIgKGB2YWx1ZWBcblx0XHRcdC8vIHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlcmUncyBubyBrZXlwYXRoKVxuXHRcdFx0dGhpcy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdC8vIFR3by13YXkgYmluZGluZ3MgbmVlZCB0byBwb2ludCB0byB0aGVpciBuZXcgdGFyZ2V0IGtleXBhdGhcblx0XHRcdGlmICggd2FzUmVzb2x2ZWQgJiYgKCB0d293YXlCaW5kaW5nID0gdGhpcy50d293YXlCaW5kaW5nICkgKSB7XG5cdFx0XHRcdHR3b3dheUJpbmRpbmcucmVib3VuZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzTnVtZXJpYyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL3JlYmluZC5qcyAqL1xuXHR2YXIgcmViaW5kID0gZnVuY3Rpb24gTXVzdGFjaGUkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gZmlyc3Rcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdHJldHVybiBmLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdC8vIEV4cHJlc3Npb24gbXVzdGFjaGU/XG5cdFx0aWYgKCB0aGlzLnJlc29sdmVyICkge1xuXHRcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9fTXVzdGFjaGUuanMgKi9cblx0dmFyIE11c3RhY2hlID0gZnVuY3Rpb24oIGdldFZhbHVlLCBpbml0LCByZXNvbHZlLCByZWJpbmQgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZFxuXHRcdH07XG5cdH0oIGdldFZhbHVlLCBpbml0aWFsaXNlLCByZXNvbHZlLCByZWJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0ludGVycG9sYXRvci5qcyAqL1xuXHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIHR5cGVzLCBydW5sb29wLCBlc2NhcGVIdG1sLCBkZXRhY2hOb2RlLCBpc0VxdWFsLCB1bmJpbmQsIE11c3RhY2hlLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRJbnRlcnBvbGF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLnZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0ZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHQvLyBURU1QXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgd3JhcHBlcjtcblx0XHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCBlc2NhcGUgKSB7XG5cdFx0XHRcdHZhciBzdHJpbmcgPSB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/ICcnICsgdGhpcy52YWx1ZSA6ICcnO1xuXHRcdFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCggc3RyaW5nICkgOiBzdHJpbmc7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gSW50ZXJwb2xhdG9yO1xuXHR9KCB0eXBlcywgcnVubG9vcCwgZXNjYXBlSHRtbCwgZGV0YWNoTm9kZSwgaXNFcXVhbCwgdW5iaW5kLCBNdXN0YWNoZSwgZGV0YWNoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUgPSBmdW5jdGlvbiBTZWN0aW9uJGJ1YmJsZSgpIHtcblx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZGV0YWNoID0gZnVuY3Rpb24gU2VjdGlvbiRkZXRhY2goKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbIDAgXS5kZXRhY2goKTtcblx0XHR9XG5cdFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGwgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuO1xuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW47XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZE5leHROb2RlID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kTmV4dE5vZGUoIGZyYWdtZW50ICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzWyBmcmFnbWVudC5pbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaXJzdE5vZGUgPSBmdW5jdGlvbiBTZWN0aW9uJGZpcnN0Tm9kZSgpIHtcblx0XHR2YXIgbGVuLCBpLCBub2RlO1xuXHRcdGlmICggbGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aWYgKCBub2RlID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maXJzdE5vZGUoKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3NodWZmbGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzaHVmZmxlID0gZnVuY3Rpb24oIHR5cGVzLCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBTZWN0aW9uJHNodWZmbGUoIG5ld0luZGljZXMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBzZWN0aW9uID0gdGhpcyxcblx0XHRcdFx0cGFyZW50RnJhZ21lbnQsIGZpcnN0Q2hhbmdlLCBpLCBuZXdMZW5ndGgsIHJlYm91bmRGcmFnbWVudHMsIGZyYWdtZW50T3B0aW9ucywgZnJhZ21lbnQ7XG5cdFx0XHQvLyBzaG9ydCBjaXJjdWl0IGFueSBkb3VibGUtdXBkYXRlcywgYW5kIGVuc3VyZSB0aGF0IHRoaXMgaXNuJ3QgYXBwbGllZCB0b1xuXHRcdFx0Ly8gbm9uLWxpc3Qgc2VjdGlvbnNcblx0XHRcdGlmICggdGhpcy5zaHVmZmxpbmcgfHwgdGhpcy51bmJvdW5kIHx8IHRoaXMuc3VidHlwZSAmJiB0aGlzLnN1YnR5cGUgIT09IHR5cGVzLlNFQ1RJT05fRUFDSCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zaHVmZmxpbmcgPSB0cnVlO1xuXHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcyQwLnNodWZmbGluZyA9IGZhbHNlO1xuXHRcdFx0fSApO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVib3VuZEZyYWdtZW50cyA9IFtdO1xuXHRcdFx0Ly8gZmlyc3QsIHJlYmluZCBleGlzdGluZyBmcmFnbWVudHNcblx0XHRcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gcmViaW5kSWZOZWNlc3NhcnkoIG5ld0luZGV4LCBvbGRJbmRleCApIHtcblx0XHRcdFx0dmFyIGZyYWdtZW50LCBieSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gb2xkSW5kZXggKSB7XG5cdFx0XHRcdFx0cmVib3VuZEZyYWdtZW50c1sgbmV3SW5kZXggXSA9IHNlY3Rpb24uZnJhZ21lbnRzWyBvbGRJbmRleCBdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBvbGRJbmRleCBdO1xuXHRcdFx0XHRpZiAoIGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Zmlyc3RDaGFuZ2UgPSBvbGRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkb2VzIHRoaXMgZnJhZ21lbnQgbmVlZCB0byBiZSB0b3JuIGRvd24/XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGl0IG5lZWRzIHRvIGJlIHJlYm91bmQgdG8gYSBuZXcgaW5kZXhcblx0XHRcdFx0YnkgPSBuZXdJbmRleCAtIG9sZEluZGV4O1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgb2xkSW5kZXg7XG5cdFx0XHRcdG5ld0tleXBhdGggPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBuZXdJbmRleDtcblx0XHRcdFx0ZnJhZ21lbnQucmViaW5kKCBzZWN0aW9uLnRlbXBsYXRlLmksIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGZyYWdtZW50LmluZGV4ID0gbmV3SW5kZXg7XG5cdFx0XHRcdHJlYm91bmRGcmFnbWVudHNbIG5ld0luZGV4IF0gPSBmcmFnbWVudDtcblx0XHRcdH0gKTtcblx0XHRcdG5ld0xlbmd0aCA9IHRoaXMucm9vdC5nZXQoIHRoaXMua2V5cGF0aCApLmxlbmd0aDtcblx0XHRcdC8vIElmIG5vdGhpbmcgY2hhbmdlZCB3aXRoIHRoZSBleGlzdGluZyBmcmFnbWVudHMsIHRoZW4gd2Ugc3RhcnQgYWRkaW5nXG5cdFx0XHQvLyBuZXcgZnJhZ21lbnRzIGF0IHRoZSBlbmQuLi5cblx0XHRcdGlmICggZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gLi4udW5sZXNzIHRoZXJlIGFyZSBubyBuZXcgZnJhZ21lbnRzIHRvIGFkZFxuXHRcdFx0XHRpZiAoIHRoaXMubGVuZ3RoID09PSBuZXdMZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpcnN0Q2hhbmdlID0gdGhpcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlbmd0aCA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9IG5ld0xlbmd0aDtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBQcmVwYXJlIG5ldyBmcmFnbWVudCBvcHRpb25zXG5cdFx0XHRmcmFnbWVudE9wdGlvbnMgPSB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG5cdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH07XG5cdFx0XHRpZiAoIHRoaXMudGVtcGxhdGUuaSApIHtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gdGhpcy50ZW1wbGF0ZS5pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIGFzIG1hbnkgbmV3IGZyYWdtZW50cyBhcyB3ZSBuZWVkIHRvLCBvciBhZGQgYmFjayBleGlzdGluZ1xuXHRcdFx0Ly8gKGRldGFjaGVkKSBmcmFnbWVudHNcblx0XHRcdGZvciAoIGkgPSBmaXJzdENoYW5nZTsgaSA8IG5ld0xlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHJlYm91bmRGcmFnbWVudHNbIGkgXTtcblx0XHRcdFx0aWYgKCAhZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5mcmFnbWVudHNbIGkgXSA9IGZyYWdtZW50O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzLCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kcmVuZGVyID0gZnVuY3Rpb24gU2VjdGlvbiRyZW5kZXIoKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0ZG9jRnJhZyA9IHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiBkb2NGcmFnO1xuXHR9O1xuXG5cdC8qIHV0aWxzL2lzQXJyYXlMaWtlLmpzICovXG5cdHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvXlxcW29iamVjdCAoPzpBcnJheXxGaWxlTGlzdClcXF0kLyxcblx0XHRcdHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHRvU3RyaW5nLmNhbGwoIG9iaiApICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvc2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzZXRWYWx1ZSA9IGZ1bmN0aW9uKCB0eXBlcywgaXNBcnJheUxpa2UsIGlzT2JqZWN0LCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFNlY3Rpb24kc2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgd3JhcHBlciwgZnJhZ21lbnRPcHRpb25zO1xuXHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHQvLyBJZiBhIGNoaWxkIG9mIHRoaXMgc2VjdGlvbiBjYXVzZXMgYSByZS1ldmFsdWF0aW9uIC0gZm9yIGV4YW1wbGUsIGFuXG5cdFx0XHRcdC8vIGV4cHJlc3Npb24gcmVmZXJzIHRvIGEgZnVuY3Rpb24gdGhhdCBtdXRhdGVzIHRoZSBhcnJheSB0aGF0IHRoaXNcblx0XHRcdFx0Ly8gc2VjdGlvbiBkZXBlbmRzIG9uIC0gd2UnbGwgZW5kIHVwIHdpdGggYSBkb3VibGUgcmVuZGVyaW5nIGJ1ZyAoc2VlXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvNzQ4KS4gVGhpcyBwcmV2ZW50cyBpdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHQvLyB3aXRoIHNlY3Rpb25zLCB3ZSBuZWVkIHRvIGdldCB0aGUgZmFrZSB2YWx1ZSBpZiB3ZSBoYXZlIGEgd3JhcHBlZCBvYmplY3Rcblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgdGhpcy5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGFueSBmcmFnbWVudHMgYXJlIGF3YWl0aW5nIGNyZWF0aW9uIGFmdGVyIGEgc3BsaWNlLFxuXHRcdFx0Ly8gdGhpcyBpcyB0aGUgcGxhY2UgdG8gZG8gaXRcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGggKSB7XG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mLFxuXHRcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0XHRwRWxlbWVudDogdGhpcy5wRWxlbWVudCxcblx0XHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0XHRpbmRleFJlZjogdGhpcy50ZW1wbGF0ZS5pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUuZm9yRWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHRcdHZhciBmcmFnbWVudDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHRoaXMkMC5rZXlwYXRoICsgJy4nICsgaW5kZXg7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdHRoaXMkMC5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCB0aGlzJDAuZnJhZ21lbnRzWyBpbmRleCBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCByZWV2YWx1YXRlU2VjdGlvbiggdGhpcywgdmFsdWUgKSApIHtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSApIHtcblx0XHRcdHZhciBmcmFnbWVudE9wdGlvbnMgPSB7XG5cdFx0XHRcdHRlbXBsYXRlOiBzZWN0aW9uLnRlbXBsYXRlLmYsXG5cdFx0XHRcdHJvb3Q6IHNlY3Rpb24ucm9vdCxcblx0XHRcdFx0cEVsZW1lbnQ6IHNlY3Rpb24ucGFyZW50RnJhZ21lbnQucEVsZW1lbnQsXG5cdFx0XHRcdG93bmVyOiBzZWN0aW9uXG5cdFx0XHR9O1xuXHRcdFx0Ly8gSWYgd2UgYWxyZWFkeSBrbm93IHRoZSBzZWN0aW9uIHR5cGUsIGdyZWF0XG5cdFx0XHQvLyBUT0RPIGNhbiB0aGlzIGJlIG9wdGltaXNlZD8gaS5lLiBwaWNrIGFuIHJlZXZhbHVhdGVTZWN0aW9uIGZ1bmN0aW9uIGR1cmluZyBpbml0XG5cdFx0XHQvLyBhbmQgYXZvaWQgZG9pbmcgdGhpcyBlYWNoIHRpbWU/XG5cdFx0XHRpZiAoIHNlY3Rpb24uc3VidHlwZSApIHtcblx0XHRcdFx0c3dpdGNoICggc2VjdGlvbi5zdWJ0eXBlICkge1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9JRjpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9VTkxFU1M6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIHRydWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9XSVRIOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX0lGX1dJVEg6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fRUFDSDpcblx0XHRcdFx0XHRcdGlmICggaXNPYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gd29yayBvdXQgd2hhdCBzb3J0IG9mIHNlY3Rpb24gd2UncmUgZGVhbGluZyB3aXRoXG5cdFx0XHRzZWN0aW9uLm9yZGVyZWQgPSAhIWlzQXJyYXlMaWtlKCB2YWx1ZSApO1xuXHRcdFx0Ly8gT3JkZXJlZCBsaXN0IHNlY3Rpb25cblx0XHRcdGlmICggc2VjdGlvbi5vcmRlcmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBVbm9yZGVyZWQgbGlzdCwgb3IgY29udGV4dFxuXHRcdFx0aWYgKCBpc09iamVjdCggdmFsdWUgKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdC8vIEluZGV4IHJlZmVyZW5jZSBpbmRpY2F0ZXMgc2VjdGlvbiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxpc3Rcblx0XHRcdFx0aWYgKCBzZWN0aW9uLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgb2JqZWN0IHByb3ZpZGVzIGNvbnRleHQgZm9yIGNvbnRlbnRzXG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ29uZGl0aW9uYWwgc2VjdGlvblxuXHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGksIGxlbmd0aCwgZnJhZ21lbnQ7XG5cdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIE5vdGhpbmcgdG8gZG9cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhlIGFycmF5IGlzIHNob3J0ZXIgdGhhbiBpdCB3YXMgcHJldmlvdXNseSwgcmVtb3ZlIGl0ZW1zXG5cdFx0XHRpZiAoIGxlbmd0aCA8IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIGxlbmd0aCwgc2VjdGlvbi5sZW5ndGggLSBsZW5ndGggKTtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBsZW5ndGggPiBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBhZGQgYW55IG5ldyBvbmVzXG5cdFx0XHRcdFx0Zm9yICggaSA9IHNlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0XHQvLyBhcHBlbmQgbGlzdCBpdGVtIHRvIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgaTtcblx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gc2VjdGlvbi50ZW1wbGF0ZS5pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBzZWN0aW9uLmZyYWdtZW50c1sgaSBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gbGVuZ3RoO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGlkLCBpLCBoYXNLZXksIGZyYWdtZW50LCBjaGFuZ2VkO1xuXHRcdFx0aGFzS2V5ID0gc2VjdGlvbi5oYXNLZXkgfHwgKCBzZWN0aW9uLmhhc0tleSA9IHt9ICk7XG5cdFx0XHQvLyByZW1vdmUgYW55IGZyYWdtZW50cyB0aGF0IHNob3VsZCBubyBsb25nZXIgZXhpc3Rcblx0XHRcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1sgaSBdO1xuXHRcdFx0XHRpZiAoICEoIGZyYWdtZW50LmluZGV4IGluIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0aGFzS2V5WyBmcmFnbWVudC5pbmRleCBdID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFkZCBhbnkgdGhhdCBoYXZlbid0IGJlZW4gY3JlYXRlZCB5ZXRcblx0XHRcdGZvciAoIGlkIGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFoYXNLZXlbIGlkIF0gKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBpZDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpZDtcblx0XHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleFJlZiA9IHNlY3Rpb24udGVtcGxhdGUuaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdGhhc0tleVsgaWQgXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKCBzZWN0aW9uICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQ7XG5cdFx0XHQvLyAuLi50aGVuIGlmIGl0IGlzbid0IHJlbmRlcmVkLCByZW5kZXIgaXQsIGFkZGluZyBzZWN0aW9uLmtleXBhdGggdG8gdGhlIGNvbnRleHQgc3RhY2tcblx0XHRcdC8vIChpZiBpdCBpcyBhbHJlYWR5IHJlbmRlcmVkLCB0aGVuIGFueSBjaGlsZHJlbiBkZXBlbmRlbnQgb24gdGhlIGNvbnRleHQgc3RhY2tcblx0XHRcdC8vIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMgd2l0aG91dCBhbnkgcHJvbXB0aW5nKVxuXHRcdFx0aWYgKCAhc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIGFwcGVuZCB0aGlzIHNlY3Rpb24gdG8gdGhlIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGg7XG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBzZWN0aW9uLmZyYWdtZW50c1sgMCBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgaW52ZXJ0ZWQsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBkb1JlbmRlciwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIGZyYWdtZW50LCBuYW1lO1xuXHRcdFx0ZW1wdHlBcnJheSA9IGlzQXJyYXlMaWtlKCB2YWx1ZSApICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcblx0XHRcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG5cdFx0XHRpZiAoICFpc0FycmF5TGlrZSggdmFsdWUgKSAmJiBpc09iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0ZW1wdHlPYmplY3QgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCBuYW1lIGluIHZhbHVlICkge1xuXHRcdFx0XHRcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggaW52ZXJ0ZWQgKSB7XG5cdFx0XHRcdGRvUmVuZGVyID0gZW1wdHlBcnJheSB8fCBlbXB0eU9iamVjdCB8fCAhdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb1JlbmRlciA9IHZhbHVlICYmICFlbXB0eUFycmF5ICYmICFlbXB0eU9iamVjdDtcblx0XHRcdH1cblx0XHRcdGlmICggZG9SZW5kZXIgKSB7XG5cdFx0XHRcdGlmICggIXNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIG5vIGNoYW5nZSB0byBjb250ZXh0IHN0YWNrXG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBzZWN0aW9uLmZyYWdtZW50c1sgMCBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzZWN0aW9uLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKCAxICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyggc2VjdGlvbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoIHNlY3Rpb24gKSB7XG5cdFx0XHRpZiAoIHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDAsIHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aCApLmZpbHRlciggaXNSZW5kZXJlZCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5sZW5ndGggPSAwO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNSZW5kZXJlZCggZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnQucmVuZGVyZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIGlzQXJyYXlMaWtlLCBpc09iamVjdCwgcnVubG9vcCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdG9TdHJpbmcgPSBmdW5jdGlvbiBTZWN0aW9uJHRvU3RyaW5nKCBlc2NhcGUgKSB7XG5cdFx0dmFyIHN0ciwgaSwgbGVuO1xuXHRcdHN0ciA9ICcnO1xuXHRcdGkgPSAwO1xuXHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudHNbIGkgXS50b1N0cmluZyggZXNjYXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHI7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bmJpbmQgPSBmdW5jdGlvbiggdW5iaW5kICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gU2VjdGlvbiR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCB1bmJpbmRGcmFnbWVudCApO1xuXHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdHRoaXMubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMudW5ib3VuZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZEZyYWdtZW50KCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHVuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gU2VjdGlvbiR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIHNob3VsZERlc3Ryb3kgPyB1bnJlbmRlckFuZERlc3Ryb3kgOiB1bnJlbmRlciApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3koIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5yZW5kZXIoIHRydWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlciggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggZmFsc2UgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1cGRhdGUgPSBmdW5jdGlvbiBTZWN0aW9uJHVwZGF0ZSgpIHtcblx0XHR2YXIgZnJhZ21lbnQsIHJlbmRlckluZGV4LCByZW5kZXJlZEZyYWdtZW50cywgYW5jaG9yLCB0YXJnZXQsIGksIGxlbjtcblx0XHQvLyBgdGhpcy5yZW5kZXJlZEZyYWdtZW50c2AgaXMgaW4gdGhlIG9yZGVyIG9mIHRoZSBwcmV2aW91cyByZW5kZXIuXG5cdFx0Ly8gSWYgZnJhZ21lbnRzIGhhdmUgc2h1ZmZsZWQgYWJvdXQsIHRoaXMgYWxsb3dzIHVzIHRvIHF1aWNrbHlcblx0XHQvLyByZWluc2VydCB0aGVtIGluIHRoZSBjb3JyZWN0IHBsYWNlXG5cdFx0cmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzO1xuXHRcdC8vIFJlbW92ZSBmcmFnbWVudHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciBkZXN0cnVjdGlvblxuXHRcdHdoaWxlICggZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIucG9wKCkgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggdHJ1ZSApO1xuXHRcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKCByZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudCApLCAxICk7XG5cdFx0fVxuXHRcdC8vIFJlbmRlciBuZXcgZnJhZ21lbnRzIChidXQgZG9uJ3QgaW5zZXJ0IHRoZW0geWV0KVxuXHRcdHdoaWxlICggZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvUmVuZGVyLnNoaWZ0KCkgKSB7XG5cdFx0XHRmcmFnbWVudC5yZW5kZXIoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0fVxuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1sgaSBdO1xuXHRcdFx0cmVuZGVySW5kZXggPSByZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudCwgaSApO1xuXHRcdFx0Ly8gc2VhcmNoIGZyb20gY3VycmVudCBpbmRleCAtIGl0J3MgZ3VhcmFudGVlZCB0byBiZSB0aGUgc2FtZSBvciBoaWdoZXJcblx0XHRcdGlmICggcmVuZGVySW5kZXggPT09IGkgKSB7XG5cdFx0XHRcdC8vIGFscmVhZHkgaW4gdGhlIHJpZ2h0IHBsYWNlLiBpbnNlcnQgYWNjdW11bGF0ZWQgbm9kZXMgKGlmIGFueSkgYW5kIGNhcnJ5IG9uXG5cdFx0XHRcdGlmICggdGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGFuY2hvciA9IGZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgYW5jaG9yICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGZyYWdtZW50LmRldGFjaCgpICk7XG5cdFx0XHQvLyB1cGRhdGUgcmVuZGVyZWRGcmFnbWVudHNcblx0XHRcdGlmICggcmVuZGVySW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoIHJlbmRlckluZGV4LCAxICk7XG5cdFx0XHR9XG5cdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoIGksIDAsIGZyYWdtZW50ICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBhbmNob3IgKTtcblx0XHR9XG5cdFx0Ly8gU2F2ZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGZvciBuZXh0IHRpbWVcblx0XHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vX1NlY3Rpb24uanMgKi9cblx0dmFyIFNlY3Rpb24gPSBmdW5jdGlvbiggdHlwZXMsIE11c3RhY2hlLCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBzaHVmZmxlLCByZW5kZXIsIHNldFZhbHVlLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciwgdXBkYXRlICkge1xuXG5cdFx0dmFyIFNlY3Rpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlNFQ1RJT047XG5cdFx0XHR0aGlzLnN1YnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLm47XG5cdFx0XHR0aGlzLmludmVydGVkID0gdGhpcy5zdWJ0eXBlID09PSB0eXBlcy5TRUNUSU9OX1VOTEVTUztcblx0XHRcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuXHRcdFx0dGhpcy5mcmFnbWVudHMgPSBbXTtcblx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUgPSBbXTtcblx0XHRcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcblx0XHRcdHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlciA9IFtdO1xuXHRcdFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdFx0Ly8gbnVtYmVyIG9mIHRpbWVzIHRoaXMgc2VjdGlvbiBpcyByZW5kZXJlZFxuXHRcdFx0TXVzdGFjaGUuaW5pdCggdGhpcywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0U2VjdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblx0XHRcdHNodWZmbGU6IHNodWZmbGUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBzZXRWYWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBTZWN0aW9uO1xuXHR9KCB0eXBlcywgTXVzdGFjaGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNodWZmbGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzZXRWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5yZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1cGRhdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRkZXRhY2ggPSBmdW5jdGlvbiBUcmlwbGUkZGV0YWNoKCkge1xuXHRcdHZhciBsZW4sIGk7XG5cdFx0aWYgKCB0aGlzLmRvY0ZyYWcgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggdGhpcy5ub2Rlc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXRjaGVzKCBub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmRBbGwgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5UmVzdWx0ICkge1xuXHRcdFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlBbGxSZXN1bHQsIG51bU5vZGVzLCBqO1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXRjaGVzKCBub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2goIG5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHF1ZXJ5QWxsUmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdG51bU5vZGVzID0gcXVlcnlBbGxSZXN1bHQubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgbnVtTm9kZXM7IGogKz0gMSApIHtcblx0XHRcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2goIHF1ZXJ5QWxsUmVzdWx0WyBqIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmlyc3ROb2RlID0gZnVuY3Rpb24gVHJpcGxlJGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5ub2Rlc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZXNbIDAgXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvaGVscGVycy9pbnNlcnRIdG1sLmpzICovXG5cdHZhciBpbnNlcnRIdG1sID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGNyZWF0ZUVsZW1lbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGVsZW1lbnRDYWNoZSA9IHt9LFxuXHRcdFx0aWVCdWcsIGllQmxhY2tsaXN0O1xuXHRcdHRyeSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50KCAndGFibGUnICkuaW5uZXJIVE1MID0gJ2Zvbyc7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdGllQnVnID0gdHJ1ZTtcblx0XHRcdGllQmxhY2tsaXN0ID0ge1xuXHRcdFx0XHRUQUJMRTogW1xuXHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRIRUFEOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dGhlYWQgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90aGVhZD48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VEJPRFk6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0Ym9keSBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3Rib2R5PjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUUjogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRyIGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdHI+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFNFTEVDVDogW1xuXHRcdFx0XHRcdCc8c2VsZWN0IGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0Jzwvc2VsZWN0Pidcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggaHRtbCwgbm9kZSwgZG9jRnJhZyApIHtcblx0XHRcdHZhciBjb250YWluZXIsIG5vZGVzID0gW10sXG5cdFx0XHRcdHdyYXBwZXIsIHNlbGVjdGVkT3B0aW9uLCBjaGlsZCwgaTtcblx0XHRcdC8vIHJlbmRlciAwIGFuZCBmYWxzZVxuXHRcdFx0aWYgKCBodG1sICE9IG51bGwgJiYgaHRtbCAhPT0gJycgKSB7XG5cdFx0XHRcdGlmICggaWVCdWcgJiYgKCB3cmFwcGVyID0gaWVCbGFja2xpc3RbIG5vZGUudGFnTmFtZSBdICkgKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggJ0RJVicgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gd3JhcHBlclsgMCBdICsgaHRtbCArIHdyYXBwZXJbIDEgXTtcblx0XHRcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvciggJy54JyApO1xuXHRcdFx0XHRcdGlmICggY29udGFpbmVyLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1sgY29udGFpbmVyLnNlbGVjdGVkSW5kZXggXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2ZyApIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KCAnRElWJyApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2ZyBjbGFzcz1cInhcIj4nICsgaHRtbCArICc8L3N2Zz4nO1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCAnLngnICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggbm9kZS50YWdOYW1lICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHRcdFx0aWYgKCBjb250YWluZXIudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zWyBjb250YWluZXIuc2VsZWN0ZWRJbmRleCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoIGNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRoaXMgaXMgcmVhbGx5IGFubm95aW5nLiBFeHRyYWN0aW5nIDxvcHRpb24+IG5vZGVzIGZyb20gdGhlXG5cdFx0XHRcdC8vIHRlbXBvcmFyeSBjb250YWluZXIgPHNlbGVjdD4gY2F1c2VzIHRoZSByZW1haW5pbmcgb25lcyB0b1xuXHRcdFx0XHQvLyBiZWNvbWUgc2VsZWN0ZWQuIFNvIG5vdyB3ZSBoYXZlIHRvIGRlc2VsZWN0IHRoZW0uIElFOCwgeW91XG5cdFx0XHRcdC8vIGFtYXplIG1lLiBZb3UgcmVhbGx5IGRvXG5cdFx0XHRcdC8vIC4uLmFuZCBub3cgQ2hyb21lIHRvb1xuXHRcdFx0XHRpZiAoIG5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG5cdFx0XHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggbm9kZXNbIGkgXSAhPT0gc2VsZWN0ZWRPcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdG5vZGVzWyBpIF0uc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBub2Rlcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZWxlbWVudCggdGFnTmFtZSApIHtcblx0XHRcdHJldHVybiBlbGVtZW50Q2FjaGVbIHRhZ05hbWUgXSB8fCAoIGVsZW1lbnRDYWNoZVsgdGFnTmFtZSBdID0gY3JlYXRlRWxlbWVudCggdGFnTmFtZSApICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIHV0aWxzL3RvQXJyYXkuanMgKi9cblx0dmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCBhcnJheUxpa2UgKSB7XG5cdFx0dmFyIGFycmF5ID0gW10sXG5cdFx0XHRpID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFycmF5WyBpIF0gPSBhcnJheUxpa2VbIGkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL2hlbHBlcnMvdXBkYXRlU2VsZWN0LmpzICovXG5cdHZhciB1cGRhdGVTZWxlY3QgPSBmdW5jdGlvbiggdG9BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdCggcGFyZW50RWxlbWVudCApIHtcblx0XHRcdHZhciBzZWxlY3RlZE9wdGlvbnMsIG9wdGlvbiwgdmFsdWU7XG5cdFx0XHRpZiAoICFwYXJlbnRFbGVtZW50IHx8IHBhcmVudEVsZW1lbnQubmFtZSAhPT0gJ3NlbGVjdCcgfHwgIXBhcmVudEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0ZWRPcHRpb25zID0gdG9BcnJheSggcGFyZW50RWxlbWVudC5ub2RlLm9wdGlvbnMgKS5maWx0ZXIoIGlzU2VsZWN0ZWQgKTtcblx0XHRcdC8vIElmIG9uZSBvZiB0aGVtIGhhZCBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCB3ZSBuZWVkIHRvIHN5bmNcblx0XHRcdC8vIHRoZSBtb2RlbCB0byB0aGUgdmlld1xuXHRcdFx0aWYgKCBwYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHNlbGVjdGVkT3B0aW9ucy5tYXAoIGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0XHRcdHJldHVybiBvLnZhbHVlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbIDAgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBvcHRpb24udmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHBhcmVudEVsZW1lbnQuYmluZGluZy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdHBhcmVudEVsZW1lbnQuYnViYmxlKCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzU2VsZWN0ZWQoIG9wdGlvbiApIHtcblx0XHRcdHJldHVybiBvcHRpb24uc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciA9IGZ1bmN0aW9uKCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbmRlciBhbiBpdGVtIHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWQnICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCggdGhpcy52YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCksIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvc2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHNldFZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHRcdHZhciB3cmFwcGVyO1xuXHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgdGhpcy5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgIT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdG9TdHJpbmcgPSBmdW5jdGlvbiggZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdG9TdHJpbmcoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSAhPSB1bmRlZmluZWQgPyBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCAnJyArIHRoaXMudmFsdWUgKSA6ICcnO1xuXHRcdH07XG5cdH0oIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVucmVuZGVyID0gZnVuY3Rpb24oIGRldGFjaE5vZGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHRoaXMubm9kZXMuZm9yRWFjaCggZGV0YWNoTm9kZSApO1xuXHRcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZGV0YWNoTm9kZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVwZGF0ZSA9IGZ1bmN0aW9uKCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHVwZGF0ZSgpIHtcblx0XHRcdHZhciBub2RlLCBwYXJlbnROb2RlO1xuXHRcdFx0aWYgKCAhdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIGV4aXN0aW5nIG5vZGVzXG5cdFx0XHR3aGlsZSAoIHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm5vZGVzLnBvcCgpO1xuXHRcdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIEluc2VydCBuZXcgbm9kZXNcblx0XHRcdHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblx0XHRcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKCB0aGlzLnZhbHVlLCBwYXJlbnROb2RlLCB0aGlzLmRvY0ZyYWcgKTtcblx0XHRcdHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICkgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuXHRcdFx0dXBkYXRlU2VsZWN0KCB0aGlzLnBFbGVtZW50ICk7XG5cdFx0fTtcblx0fSggaW5zZXJ0SHRtbCwgdXBkYXRlU2VsZWN0ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvX1RyaXBsZS5qcyAqL1xuXHR2YXIgVHJpcGxlID0gZnVuY3Rpb24oIHR5cGVzLCBNdXN0YWNoZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaXJzdE5vZGUsIHJlbmRlciwgc2V0VmFsdWUsIHRvU3RyaW5nLCB1bnJlbmRlciwgdXBkYXRlLCB1bmJpbmQgKSB7XG5cblx0XHR2YXIgVHJpcGxlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5UUklQTEU7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRUcmlwbGUucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRzZXRWYWx1ZTogc2V0VmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlcixcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0XHRyZXR1cm4gVHJpcGxlO1xuXHR9KCB0eXBlcywgTXVzdGFjaGUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZCwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHNldFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdW5yZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVwZGF0ZSwgdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRidWJibGUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZGV0YWNoID0gZnVuY3Rpb24gRWxlbWVudCRkZXRhY2goKSB7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG5cdFx0XHRwYXJlbnROb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdC8vIG5lZWQgdG8gY2hlY2sgZm9yIHBhcmVudCBub2RlIC0gRE9NIG1heSBoYXZlIGJlZW4gYWx0ZXJlZFxuXHRcdFx0Ly8gYnkgc29tZXRoaW5nIG90aGVyIHRoYW4gUmFjdGl2ZSEgZS5nLiBqUXVlcnkgVUkuLi5cblx0XHRcdGlmICggcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmQgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRpZiAoIG1hdGNoZXMoIHRoaXMubm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCAmJiB0aGlzLmZyYWdtZW50LmZpbmQgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGwgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdC8vIEFkZCB0aGlzIG5vZGUgdG8gdGhlIHF1ZXJ5LCBpZiBhcHBsaWNhYmxlLCBhbmQgcmVnaXN0ZXIgdGhlXG5cdFx0Ly8gcXVlcnkgb24gdGhpcyBlbGVtZW50XG5cdFx0aWYgKCBxdWVyeS5fdGVzdCggdGhpcywgdHJ1ZSApICYmIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHQoIHRoaXMubGl2ZVF1ZXJpZXMgfHwgKCB0aGlzLmxpdmVRdWVyaWVzID0gW10gKSApLnB1c2goIHF1ZXJ5ICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBFbGVtZW50JGZpbmROZXh0Tm9kZSgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZmlyc3ROb2RlKCkge1xuXHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9nZXRBdHRyaWJ1dGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRnZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBFbGVtZW50JGdldEF0dHJpYnV0ZSggbmFtZSApIHtcblx0XHRpZiAoICF0aGlzLmF0dHJpYnV0ZXMgfHwgIXRoaXMuYXR0cmlidXRlc1sgbmFtZSBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0udmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NoYXJlZC9lbmZvcmNlQ2FzZS5qcyAqL1xuXHR2YXIgZW5mb3JjZUNhc2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzdmdDYW1lbENhc2VFbGVtZW50cywgc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcywgY3JlYXRlTWFwLCBtYXA7XG5cdFx0c3ZnQ2FtZWxDYXNlRWxlbWVudHMgPSAnYWx0R2x5cGggYWx0R2x5cGhEZWYgYWx0R2x5cGhJdGVtIGFuaW1hdGVDb2xvciBhbmltYXRlTW90aW9uIGFuaW1hdGVUcmFuc2Zvcm0gY2xpcFBhdGggZmVCbGVuZCBmZUNvbG9yTWF0cml4IGZlQ29tcG9uZW50VHJhbnNmZXIgZmVDb21wb3NpdGUgZmVDb252b2x2ZU1hdHJpeCBmZURpZmZ1c2VMaWdodGluZyBmZURpc3BsYWNlbWVudE1hcCBmZURpc3RhbnRMaWdodCBmZUZsb29kIGZlRnVuY0EgZmVGdW5jQiBmZUZ1bmNHIGZlRnVuY1IgZmVHYXVzc2lhbkJsdXIgZmVJbWFnZSBmZU1lcmdlIGZlTWVyZ2VOb2RlIGZlTW9ycGhvbG9neSBmZU9mZnNldCBmZVBvaW50TGlnaHQgZmVTcGVjdWxhckxpZ2h0aW5nIGZlU3BvdExpZ2h0IGZlVGlsZSBmZVR1cmJ1bGVuY2UgZm9yZWlnbk9iamVjdCBnbHlwaFJlZiBsaW5lYXJHcmFkaWVudCByYWRpYWxHcmFkaWVudCB0ZXh0UGF0aCB2a2Vybicuc3BsaXQoICcgJyApO1xuXHRcdHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMgPSAnYXR0cmlidXRlTmFtZSBhdHRyaWJ1dGVUeXBlIGJhc2VGcmVxdWVuY3kgYmFzZVByb2ZpbGUgY2FsY01vZGUgY2xpcFBhdGhVbml0cyBjb250ZW50U2NyaXB0VHlwZSBjb250ZW50U3R5bGVUeXBlIGRpZmZ1c2VDb25zdGFudCBlZGdlTW9kZSBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIGZpbHRlclJlcyBmaWx0ZXJVbml0cyBnbHlwaFJlZiBncmFkaWVudFRyYW5zZm9ybSBncmFkaWVudFVuaXRzIGtlcm5lbE1hdHJpeCBrZXJuZWxVbml0TGVuZ3RoIGtleVBvaW50cyBrZXlTcGxpbmVzIGtleVRpbWVzIGxlbmd0aEFkanVzdCBsaW1pdGluZ0NvbmVBbmdsZSBtYXJrZXJIZWlnaHQgbWFya2VyVW5pdHMgbWFya2VyV2lkdGggbWFza0NvbnRlbnRVbml0cyBtYXNrVW5pdHMgbnVtT2N0YXZlcyBwYXRoTGVuZ3RoIHBhdHRlcm5Db250ZW50VW5pdHMgcGF0dGVyblRyYW5zZm9ybSBwYXR0ZXJuVW5pdHMgcG9pbnRzQXRYIHBvaW50c0F0WSBwb2ludHNBdFogcHJlc2VydmVBbHBoYSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHByaW1pdGl2ZVVuaXRzIHJlZlggcmVmWSByZXBlYXRDb3VudCByZXBlYXREdXIgcmVxdWlyZWRFeHRlbnNpb25zIHJlcXVpcmVkRmVhdHVyZXMgc3BlY3VsYXJDb25zdGFudCBzcGVjdWxhckV4cG9uZW50IHNwcmVhZE1ldGhvZCBzdGFydE9mZnNldCBzdGREZXZpYXRpb24gc3RpdGNoVGlsZXMgc3VyZmFjZVNjYWxlIHN5c3RlbUxhbmd1YWdlIHRhYmxlVmFsdWVzIHRhcmdldFggdGFyZ2V0WSB0ZXh0TGVuZ3RoIHZpZXdCb3ggdmlld1RhcmdldCB4Q2hhbm5lbFNlbGVjdG9yIHlDaGFubmVsU2VsZWN0b3Igem9vbUFuZFBhbicuc3BsaXQoICcgJyApO1xuXHRcdGNyZWF0ZU1hcCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcblx0XHRcdHZhciBtYXAgPSB7fSxcblx0XHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRtYXBbIGl0ZW1zWyBpIF0udG9Mb3dlckNhc2UoKSBdID0gaXRlbXNbIGkgXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXA7XG5cdFx0fTtcblx0XHRtYXAgPSBjcmVhdGVNYXAoIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLmNvbmNhdCggc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyApICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50TmFtZSApIHtcblx0XHRcdHZhciBsb3dlckNhc2VFbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbWFwWyBsb3dlckNhc2VFbGVtZW50TmFtZSBdIHx8IGxvd2VyQ2FzZUVsZW1lbnROYW1lO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkYnViYmxlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzRXF1YWwgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJGJ1YmJsZSgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdC8vIFRPRE8gdGhpcyBjYW4gcmVnaXN0ZXIgdGhlIGF0dHJpYnV0ZSBtdWx0aXBsZSB0aW1lcyAoc2VlIHJlbmRlciB0ZXN0XG5cdFx0XHQvLyAnQXR0cmlidXRlIHdpdGggbmVzdGVkIG11c3RhY2hlcycpXG5cdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHQvLyBOZWVkIHRvIGNsZWFyIG9sZCBpZCBmcm9tIHJhY3RpdmUubm9kZXNcblx0XHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpZCcgJiYgdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzWyB0aGlzLnZhbHVlIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3ZhbHVlJyAmJiB0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBzdG9yZSB0aGUgdmFsdWUgb24gdGhlIERPTSBsaWtlIHRoaXMgc28gd2Vcblx0XHRcdFx0XHQvLyBjYW4gcmV0cmlldmUgaXQgbGF0ZXIgd2l0aG91dCBpdCBiZWluZyBjb2VyY2VkIHRvIGEgc3RyaW5nXG5cdFx0XHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNFcXVhbCApO1xuXG5cdC8qIGNvbmZpZy9ib29sZWFuQXR0cmlidXRlcy5qcyAqL1xuXHR2YXIgYm9vbGVhbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvaHRtbC1taW5pZmllci9pc3N1ZXMvNjMjaXNzdWVjb21tZW50LTM3NzYzMzE2XG5cdFx0dmFyIGJvb2xlYW5BdHRyaWJ1dGVzID0gL14oYWxsb3dGdWxsc2NyZWVufGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbXBhY3R8Y29udHJvbHN8ZGVjbGFyZXxkZWZhdWx0fGRlZmF1bHRDaGVja2VkfGRlZmF1bHRNdXRlZHxkZWZhdWx0U2VsZWN0ZWR8ZGVmZXJ8ZGlzYWJsZWR8ZHJhZ2dhYmxlfGVuYWJsZWR8Zm9ybU5vVmFsaWRhdGV8aGlkZGVufGluZGV0ZXJtaW5hdGV8aW5lcnR8aXNNYXB8aXRlbVNjb3BlfGxvb3B8bXVsdGlwbGV8bXV0ZWR8bm9IcmVmfG5vUmVzaXplfG5vU2hhZGV8bm9WYWxpZGF0ZXxub1dyYXB8b3BlbnxwYXVzZU9uRXhpdHxyZWFkT25seXxyZXF1aXJlZHxyZXZlcnNlZHxzY29wZWR8c2VhbWxlc3N8c2VsZWN0ZWR8c29ydGFibGV8dHJhbnNsYXRlfHRydWVTcGVlZHx0eXBlTXVzdE1hdGNofHZpc2libGUpJC9pO1xuXHRcdHJldHVybiBib29sZWFuQXR0cmlidXRlcztcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvaGVscGVycy9kZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlLmpzICovXG5cdHZhciBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGVuZm9yY2VDYXNlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgY29sb25JbmRleCwgbmFtZXNwYWNlUHJlZml4O1xuXHRcdFx0Ly8gYXJlIHdlIGRlYWxpbmcgd2l0aCBhIG5hbWVzcGFjZWQgYXR0cmlidXRlLCBlLmcuIHhsaW5rOmhyZWY/XG5cdFx0XHRjb2xvbkluZGV4ID0gbmFtZS5pbmRleE9mKCAnOicgKTtcblx0XHRcdGlmICggY29sb25JbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdC8vIGxvb2tzIGxpa2Ugd2UgYXJlLCB5ZXMuLi5cblx0XHRcdFx0bmFtZXNwYWNlUHJlZml4ID0gbmFtZS5zdWJzdHIoIDAsIGNvbG9uSW5kZXggKTtcblx0XHRcdFx0Ly8gLi4udW5sZXNzIGl0J3MgYSBuYW1lc3BhY2UgKmRlY2xhcmF0aW9uKiwgd2hpY2ggd2UgaWdub3JlIChvbiB0aGUgYXNzdW1wdGlvblxuXHRcdFx0XHQvLyB0aGF0IG9ubHkgdmFsaWQgbmFtZXNwYWNlcyB3aWxsIGJlIHVzZWQpXG5cdFx0XHRcdGlmICggbmFtZXNwYWNlUHJlZml4ICE9PSAneG1sbnMnICkge1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnN1YnN0cmluZyggY29sb25JbmRleCArIDEgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGVuZm9yY2VDYXNlKCBuYW1lICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbIG5hbWVzcGFjZVByZWZpeC50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZVByZWZpeCA9IG5hbWVzcGFjZVByZWZpeDtcblx0XHRcdFx0XHRpZiAoICFhdHRyaWJ1dGUubmFtZXNwYWNlICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgJ1Vua25vd24gbmFtZXNwYWNlIChcIicgKyBuYW1lc3BhY2VQcmVmaXggKyAnXCIpJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBTVkcgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlIHNlbnNpdGl2ZVxuXHRcdFx0YXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUuZWxlbWVudC5uYW1lc3BhY2UgIT09IG5hbWVzcGFjZXMuaHRtbCA/IGVuZm9yY2VDYXNlKCBuYW1lICkgOiBuYW1lO1xuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIGVuZm9yY2VDYXNlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9oZWxwZXJzL2dldEludGVycG9sYXRvci5qcyAqL1xuXHR2YXIgZ2V0SW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEludGVycG9sYXRvciggYXR0cmlidXRlICkge1xuXHRcdFx0dmFyIGl0ZW1zID0gYXR0cmlidXRlLmZyYWdtZW50Lml0ZW1zO1xuXHRcdFx0aWYgKCBpdGVtcy5sZW5ndGggIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggaXRlbXNbIDAgXS50eXBlID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgKSB7XG5cdFx0XHRcdHJldHVybiBpdGVtc1sgMCBdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9oZWxwZXJzL2RldGVybWluZVByb3BlcnR5TmFtZS5qcyAqL1xuXHR2YXIgZGV0ZXJtaW5lUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICkge1xuXG5cdFx0dmFyIHByb3BlcnR5TmFtZXMgPSB7XG5cdFx0XHQnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG5cdFx0XHRhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuXHRcdFx0Ymdjb2xvcjogJ2JnQ29sb3InLFxuXHRcdFx0J2NsYXNzJzogJ2NsYXNzTmFtZScsXG5cdFx0XHRjb2RlYmFzZTogJ2NvZGVCYXNlJyxcblx0XHRcdGNvbHNwYW46ICdjb2xTcGFuJyxcblx0XHRcdGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG5cdFx0XHRkYXRldGltZTogJ2RhdGVUaW1lJyxcblx0XHRcdGRpcm5hbWU6ICdkaXJOYW1lJyxcblx0XHRcdCdmb3InOiAnaHRtbEZvcicsXG5cdFx0XHQnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuXHRcdFx0aXNtYXA6ICdpc01hcCcsXG5cdFx0XHRtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuXHRcdFx0bm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuXHRcdFx0cHViZGF0ZTogJ3B1YkRhdGUnLFxuXHRcdFx0cmVhZG9ubHk6ICdyZWFkT25seScsXG5cdFx0XHRyb3dzcGFuOiAncm93U3BhbicsXG5cdFx0XHR0YWJpbmRleDogJ3RhYkluZGV4Jyxcblx0XHRcdHVzZW1hcDogJ3VzZU1hcCdcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiggYXR0cmlidXRlLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHByb3BlcnR5TmFtZTtcblx0XHRcdGlmICggYXR0cmlidXRlLnBOb2RlICYmICFhdHRyaWJ1dGUubmFtZXNwYWNlICYmICggIW9wdGlvbnMucE5vZGUubmFtZXNwYWNlVVJJIHx8IG9wdGlvbnMucE5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSApIHtcblx0XHRcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1sgYXR0cmlidXRlLm5hbWUgXSB8fCBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLnBOb2RlWyBwcm9wZXJ0eU5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaXMgYXR0cmlidXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUgb3IgJ3ZhbHVlJz8gSWYgc28gd2UncmUgYmV0dGVyIG9mZiBkb2luZyBlLmcuXG5cdFx0XHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG5cdFx0XHRcdGlmICggYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggcHJvcGVydHlOYW1lICkgfHwgcHJvcGVydHlOYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBib29sZWFuQXR0cmlidXRlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgYm9vbGVhbkF0dHJpYnV0ZXMsIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UsIGdldEludGVycG9sYXRvciwgZGV0ZXJtaW5lUHJvcGVydHlOYW1lLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkaW5pdCggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkFUVFJJQlVURTtcblx0XHRcdHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcblx0XHRcdGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UoIHRoaXMsIG9wdGlvbnMubmFtZSApO1xuXHRcdFx0Ly8gaWYgaXQncyBhbiBlbXB0eSBhdHRyaWJ1dGUsIG9yIGp1c3QgYSBzdHJhaWdodCBrZXktdmFsdWUgcGFpciwgd2l0aCBub1xuXHRcdFx0Ly8gbXVzdGFjaGUgc2hlbmFuaWdhbnMsIHNldCB0aGUgYXR0cmlidXRlIGFjY29yZGluZ2x5IGFuZCBnbyBob21lXG5cdFx0XHRpZiAoICFvcHRpb25zLnZhbHVlIHx8IHR5cGVvZiBvcHRpb25zLnZhbHVlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIHRoaXMubmFtZSApID8gdHJ1ZSA6IG9wdGlvbnMudmFsdWUgfHwgJyc7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGRvIHNvbWUgd29ya1xuXHRcdFx0Ly8gc2hhcmUgcGFyZW50RnJhZ21lbnQgd2l0aCBwYXJlbnQgZWxlbWVudFxuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IG9wdGlvbnMudmFsdWUsXG5cdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGlzIGF0dHJpYnV0ZSdzIGludGVycG9sYXRvciwgaWYgaXRzIGZyYWdtZW50XG5cdFx0XHQvLyB0YWtlcyB0aGUgZm9ybSBge3tmb299fWAuIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0d28td2F5IGJpbmRpbmcgYW5kXG5cdFx0XHQvLyBmb3IgY29ycmVjdGx5IHJlbmRlcmluZyBIVE1MIGxhdGVyXG5cdFx0XHR0aGlzLmludGVycG9sYXRvciA9IGdldEludGVycG9sYXRvciggdGhpcyApO1xuXHRcdFx0dGhpcy5pc0JpbmRhYmxlID0gISF0aGlzLmludGVycG9sYXRvciAmJiAhdGhpcy5pbnRlcnBvbGF0b3IuaXNTdGF0aWM7XG5cdFx0XHQvLyBjYW4gd2UgZXN0YWJsaXNoIHRoaXMgYXR0cmlidXRlJ3MgcHJvcGVydHkgbmFtZSBlcXVpdmFsZW50P1xuXHRcdFx0ZGV0ZXJtaW5lUHJvcGVydHlOYW1lKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHQvLyBtYXJrIGFzIHJlYWR5XG5cdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHR9O1xuXHR9KCB0eXBlcywgYm9vbGVhbkF0dHJpYnV0ZXMsIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UsIGdldEludGVycG9sYXRvciwgZGV0ZXJtaW5lUHJvcGVydHlOYW1lLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZWJpbmQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmVuZGVyID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICkge1xuXG5cdFx0dmFyIHByb3BlcnR5TmFtZXMgPSB7XG5cdFx0XHQnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG5cdFx0XHQnYWNjZXNza2V5JzogJ2FjY2Vzc0tleScsXG5cdFx0XHQnYmdjb2xvcic6ICdiZ0NvbG9yJyxcblx0XHRcdCdjbGFzcyc6ICdjbGFzc05hbWUnLFxuXHRcdFx0J2NvZGViYXNlJzogJ2NvZGVCYXNlJyxcblx0XHRcdCdjb2xzcGFuJzogJ2NvbFNwYW4nLFxuXHRcdFx0J2NvbnRlbnRlZGl0YWJsZSc6ICdjb250ZW50RWRpdGFibGUnLFxuXHRcdFx0J2RhdGV0aW1lJzogJ2RhdGVUaW1lJyxcblx0XHRcdCdkaXJuYW1lJzogJ2Rpck5hbWUnLFxuXHRcdFx0J2Zvcic6ICdodG1sRm9yJyxcblx0XHRcdCdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG5cdFx0XHQnaXNtYXAnOiAnaXNNYXAnLFxuXHRcdFx0J21heGxlbmd0aCc6ICdtYXhMZW5ndGgnLFxuXHRcdFx0J25vdmFsaWRhdGUnOiAnbm9WYWxpZGF0ZScsXG5cdFx0XHQncHViZGF0ZSc6ICdwdWJEYXRlJyxcblx0XHRcdCdyZWFkb25seSc6ICdyZWFkT25seScsXG5cdFx0XHQncm93c3Bhbic6ICdyb3dTcGFuJyxcblx0XHRcdCd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG5cdFx0XHQndXNlbWFwJzogJ3VzZU1hcCdcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkcmVuZGVyKCBub2RlICkge1xuXHRcdFx0dmFyIHByb3BlcnR5TmFtZTtcblx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0XHQvLyBzaG91bGQgd2UgdXNlIGRpcmVjdCBwcm9wZXJ0eSBhY2Nlc3MsIG9yIHNldEF0dHJpYnV0ZT9cblx0XHRcdGlmICggIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSB7XG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbIHRoaXMubmFtZSBdIHx8IHRoaXMubmFtZTtcblx0XHRcdFx0aWYgKCBub2RlWyBwcm9wZXJ0eU5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuXHRcdFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuXHRcdFx0XHRpZiAoIGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIHByb3BlcnR5TmFtZSApIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdG9TdHJpbmcgPSBmdW5jdGlvbiggYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdG9TdHJpbmcoKSB7XG5cdFx0XHR2YXIgbmFtZSA9ICggZnJhZ21lbnQgPSB0aGlzICkubmFtZSxcblx0XHRcdFx0bmFtZXNwYWNlUHJlZml4ID0gZnJhZ21lbnQubmFtZXNwYWNlUHJlZml4LFxuXHRcdFx0XHR2YWx1ZSA9IGZyYWdtZW50LnZhbHVlLFxuXHRcdFx0XHRpbnRlcnBvbGF0b3IgPSBmcmFnbWVudC5pbnRlcnBvbGF0b3IsXG5cdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQuZnJhZ21lbnQ7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3QgYW5kIHRleHRhcmVhIHZhbHVlcyAoc2hvdWxkIG5vdCBiZSBzdHJpbmdpZmllZClcblx0XHRcdGlmICggbmFtZSA9PT0gJ3ZhbHVlJyAmJiAoIHRoaXMuZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyB8fCB0aGlzLmVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50IGVkaXRhYmxlXG5cdFx0XHRpZiAoIG5hbWUgPT09ICd2YWx1ZScgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lc1xuXHRcdFx0aWYgKCBuYW1lID09PSAnbmFtZScgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgJiYgaW50ZXJwb2xhdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gJ25hbWU9e3snICsgKCBpbnRlcnBvbGF0b3Iua2V5cGF0aCB8fCBpbnRlcnBvbGF0b3IucmVmICkgKyAnfX0nO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzXG5cdFx0XHRpZiAoIGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSA6ICcnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBmcmFnbWVudCApIHtcblx0XHRcdFx0dmFsdWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBuYW1lc3BhY2VQcmVmaXggKSB7XG5cdFx0XHRcdG5hbWUgPSBuYW1lc3BhY2VQcmVmaXggKyAnOicgKyBuYW1lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSArICc9XCInICsgZXNjYXBlKCB2YWx1ZSApICsgJ1wiJyA6IG5hbWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGVzY2FwZSggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSggLyYvZywgJyZhbXA7JyApLnJlcGxhY2UoIC9cIi9nLCAnJnF1b3Q7JyApLnJlcGxhY2UoIC8nL2csICcmIzM5OycgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBib29sZWFuQXR0cmlidXRlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1bmJpbmQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdW5iaW5kKCkge1xuXHRcdC8vIGlnbm9yZSBub24tZHluYW1pYyBhdHRyaWJ1dGVzXG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpZCcgKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzWyB0aGlzLnZhbHVlIF07XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVTZWxlY3RWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlU2VsZWN0VmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlU2VsZWN0KCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG5cdFx0XHRvcHRpb25zLCBvcHRpb24sIG9wdGlvblZhbHVlLCBpO1xuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG5cdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0Ly8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuXHRcdFx0XHRpZiAoIG9wdGlvblZhbHVlID09IHZhbHVlICkge1xuXHRcdFx0XHRcdC8vIGRvdWJsZSBlcXVhbHMgYXMgd2UgbWF5IGJlIGNvbXBhcmluZyBudW1iZXJzIHdpdGggc3RyaW5nc1xuXHRcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyogdXRpbHMvYXJyYXlDb250YWlucy5qcyAqL1xuXHR2YXIgYXJyYXlDb250YWlucyA9IGZ1bmN0aW9uIGFycmF5Q29udGFpbnMoIGFycmF5LCB2YWx1ZSApIHtcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGMgPSBhcnJheS5sZW5ndGg7IGkgPCBjOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFycmF5WyBpIF0gPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgPSBmdW5jdGlvbiggYXJyYXlDb250YWlucywgaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3QoKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuXHRcdFx0XHRvcHRpb25zLCBpLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXHRcdFx0aWYgKCAhaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0dmFsdWUgPSBbIHZhbHVlIF07XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG5cdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0Ly8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuXHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBhcnJheUNvbnRhaW5zKCB2YWx1ZSwgb3B0aW9uVmFsdWUgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBhcnJheUNvbnRhaW5zLCBpc0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVJhZGlvTmFtZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9OYW1lID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZSgpIHtcblx0XHR2YXIgbm9kZSA9ICggdmFsdWUgPSB0aGlzICkubm9kZSxcblx0XHRcdHZhbHVlID0gdmFsdWUudmFsdWU7XG5cdFx0bm9kZS5jaGVja2VkID0gdmFsdWUgPT0gbm9kZS5fcmFjdGl2ZS52YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlUmFkaW9WYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9WYWx1ZSA9IGZ1bmN0aW9uKCBydW5sb29wICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb1ZhbHVlKCkge1xuXHRcdFx0dmFyIHdhc0NoZWNrZWQsIG5vZGUgPSB0aGlzLm5vZGUsXG5cdFx0XHRcdGJpbmRpbmcsIGJpbmRpbmdzLCBpO1xuXHRcdFx0d2FzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZDtcblx0XHRcdG5vZGUudmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgPT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXHRcdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIGlmIHRoZSBpbnB1dCB3YXMgY2hlY2tlZCwgYW5kIHRoZSB2YWx1ZVxuXHRcdFx0Ly8gY2hhbmdlZCBzbyB0aGF0IGl0J3Mgbm8gbG9uZ2VyIGNoZWNrZWQsIHRoZSB0d293YXkgYmluZGluZyBpc1xuXHRcdFx0Ly8gbW9zdCBsaWtlbHkgb3V0IG9mIGRhdGUuIFRvIGZpeCBpdCB3ZSBoYXZlIHRvIGp1bXAgdGhyb3VnaCBzb21lXG5cdFx0XHQvLyBob29wcy4uLiB0aGlzIGlzIGEgbGl0dGxlIGtsdWRneSBidXQgaXQgd29ya3Ncblx0XHRcdGlmICggd2FzQ2hlY2tlZCAmJiAhbm9kZS5jaGVja2VkICYmIHRoaXMuZWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuZWxlbWVudC5iaW5kaW5nLnNpYmxpbmdzO1xuXHRcdFx0XHRpZiAoIGkgPSBiaW5kaW5ncy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggIWJpbmRpbmcuZWxlbWVudC5ub2RlICkge1xuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBpbml0aWFsIHJlbmRlciwgc2libGluZ3MgYXJlIHN0aWxsIHJlbmRlcmluZyFcblx0XHRcdFx0XHRcdFx0Ly8gd2UnbGwgY29tZSBiYWNrIGxhdGVyLi4uXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggYmluZGluZy5lbGVtZW50Lm5vZGUuY2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGJpbmRpbmcucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBiaW5kaW5nLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGJpbmRpbmcua2V5cGF0aCwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUNoZWNrYm94TmFtZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ2hlY2tib3hOYW1lID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZSgpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gKCB2YWx1ZSA9IHRoaXMgKS5lbGVtZW50LFxuXHRcdFx0XHRub2RlID0gdmFsdWUubm9kZSxcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZSxcblx0XHRcdFx0dmFsdWVBdHRyaWJ1dGUsIGk7XG5cdFx0XHR2YWx1ZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoICFpc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSB2YWx1ZUF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggdmFsdWVBdHRyaWJ1dGUgPT0gdmFsdWVbIGkgXSApIHtcblx0XHRcdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2xhc3NOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRub2RlLmNsYXNzTmFtZSA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVJZEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGUoKSB7XG5cdFx0dmFyIG5vZGUgPSAoIHZhbHVlID0gdGhpcyApLm5vZGUsXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuXHRcdHRoaXMucm9vdC5ub2Rlc1sgdmFsdWUgXSA9IG5vZGU7XG5cdFx0bm9kZS5pZCA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVJRVN0eWxlQXR0cmlidXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJRVN0eWxlQXR0cmlidXRlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKCAnY3NzVGV4dCcsIHZhbHVlICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSgpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0dGhpcy5ub2RlLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVZhbHVlKCkge1xuXHRcdHZhciBub2RlID0gKCB2YWx1ZSA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZTtcblx0XHQvLyBzdG9yZSBhY3R1YWwgdmFsdWUsIHNvIGl0IGRvZXNuJ3QgZ2V0IGNvZXJjZWQgdG8gYSBzdHJpbmdcblx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cdFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuXHRcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2Vcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdG5vZGUudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQm9vbGVhbi5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQm9vbGVhbiA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlKCkge1xuXHRcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcblx0XHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSB0aGlzLnZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlRXZlcnl0aGluZ0Vsc2UuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUV2ZXJ5dGhpbmdFbHNlID0gZnVuY3Rpb24oIGJvb2xlYW5BdHRyaWJ1dGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZSgpIHtcblx0XHRcdHZhciBub2RlID0gKCBmcmFnbWVudCA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBmcmFnbWVudC5uYW1lc3BhY2UsXG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGZyYWdtZW50LnZhbHVlLFxuXHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LmZyYWdtZW50O1xuXHRcdFx0aWYgKCBuYW1lc3BhY2UgKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMoIG5hbWVzcGFjZSwgbmFtZSwgKCBmcmFnbWVudCB8fCB2YWx1ZSApLnRvU3RyaW5nKCkgKTtcblx0XHRcdH0gZWxzZSBpZiAoICFib29sZWFuQXR0cmlidXRlcy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCBuYW1lLCAoIGZyYWdtZW50IHx8IHZhbHVlICkudG9TdHJpbmcoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggbmFtZSwgJycgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggYm9vbGVhbkF0dHJpYnV0ZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIG5vb3AsIHVwZGF0ZVNlbGVjdFZhbHVlLCB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlLCB1cGRhdGVSYWRpb05hbWUsIHVwZGF0ZVJhZGlvVmFsdWUsIHVwZGF0ZUNoZWNrYm94TmFtZSwgdXBkYXRlQ2xhc3NOYW1lLCB1cGRhdGVJZEF0dHJpYnV0ZSwgdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSwgdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUsIHVwZGF0ZVZhbHVlLCB1cGRhdGVCb29sZWFuLCB1cGRhdGVFdmVyeXRoaW5nRWxzZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5hbWUgPSAoIG5vZGUgPSB0aGlzICkubmFtZSxcblx0XHRcdFx0ZWxlbWVudCA9IG5vZGUuZWxlbWVudCxcblx0XHRcdFx0bm9kZSA9IG5vZGUubm9kZSxcblx0XHRcdFx0dHlwZSwgdXBkYXRlTWV0aG9kO1xuXHRcdFx0aWYgKCBuYW1lID09PSAnaWQnICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJZEF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHNlbGVjdHNcblx0XHRcdFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICYmIG5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSA/IHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgOiB1cGRhdGVTZWxlY3RWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgKSB7XG5cdFx0XHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndHlwZScgKTtcblx0XHRcdFx0XHQvLyB0eXBlPSdmaWxlJyB2YWx1ZT0ne3tmaWxlTGlzdH19Jz5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdmaWxlJyApIHtcblx0XHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IG5vb3A7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ3JhZGlvJyAmJiBlbGVtZW50LmJpbmRpbmcgJiYgZWxlbWVudC5iaW5kaW5nLm5hbWUgPT09ICduYW1lJyApIHtcblx0XHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvVmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy50d293YXkgJiYgbmFtZSA9PT0gJ25hbWUnICkge1xuXHRcdFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ3JhZGlvJyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb05hbWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGUudHlwZSA9PT0gJ2NoZWNrYm94JyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDaGVja2JveE5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdzdHlsZScgJiYgbm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGU7XG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAnY2xhc3MnICYmICggIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2xhc3NOYW1lO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy51c2VQcm9wZXJ0eSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQm9vbGVhbjtcblx0XHRcdH1cblx0XHRcdGlmICggIXVwZGF0ZU1ldGhvZCApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlRXZlcnl0aGluZ0Vsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0ZSA9IHVwZGF0ZU1ldGhvZDtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgbm9vcCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlU2VsZWN0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvTmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9WYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ2hlY2tib3hOYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDbGFzc05hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlkQXR0cmlidXRlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJRVN0eWxlQXR0cmlidXRlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlVmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUJvb2xlYW4sIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUV2ZXJ5dGhpbmdFbHNlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9fQXR0cmlidXRlLmpzICovXG5cdHZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYnViYmxlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdXBkYXRlICkge1xuXG5cdFx0dmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBBdHRyaWJ1dGU7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUF0dHJpYnV0ZXMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiggQXR0cmlidXRlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50LCBhdHRyaWJ1dGVzICkge1xuXHRcdFx0dmFyIG5hbWUsIGF0dHJpYnV0ZSwgcmVzdWx0ID0gW107XG5cdFx0XHRmb3IgKCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJpYnV0ZXNbIG5hbWUgXSxcblx0XHRcdFx0XHRcdHJvb3Q6IGVsZW1lbnQucm9vdFxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCggcmVzdWx0WyBuYW1lIF0gPSBhdHRyaWJ1dGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBBdHRyaWJ1dGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQ29uZGl0aW9uYWxBdHRyaWJ1dGUvX0NvbmRpdGlvbmFsQXR0cmlidXRlLmpzICovXG5cdHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCwgdG9BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQsIGRpdjtcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRkaXYgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdH1cblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBlbGVtZW50LCB0ZW1wbGF0ZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRyb290OiBlbGVtZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHR0ZW1wbGF0ZTogWyB0ZW1wbGF0ZSBdXG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRDb25kaXRpb25hbEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCBub2RlICkge1xuXHRcdFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdFx0XHR0aGlzLmlzU3ZnID0gbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciBzdHIsIGF0dHJzO1xuXHRcdFx0XHRzdHIgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGF0dHJzID0gcGFyc2VBdHRyaWJ1dGVzKCBzdHIsIHRoaXMuaXNTdmcgKTtcblx0XHRcdFx0Ly8gYW55IGF0dHJpYnV0ZXMgdGhhdCBwcmV2aW91c2x5IGV4aXN0ZWQgYnV0IG5vIGxvbmdlciBkb1xuXHRcdFx0XHQvLyBtdXN0IGJlIHJlbW92ZWRcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZpbHRlciggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdEluKCBhdHRycywgYSApO1xuXHRcdFx0XHR9ICkuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0dGhpcyQwLm5vZGUucmVtb3ZlQXR0cmlidXRlKCBhLm5hbWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRhdHRycy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHR0aGlzJDAubm9kZS5zZXRBdHRyaWJ1dGUoIGEubmFtZSwgYS52YWx1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJzO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gQ29uZGl0aW9uYWxBdHRyaWJ1dGU7XG5cblx0XHRmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoIHN0ciwgaXNTdmcgKSB7XG5cdFx0XHR2YXIgdGFnID0gaXNTdmcgPyAnc3ZnJyA6ICdkaXYnO1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9ICc8JyArIHRhZyArICcgJyArIHN0ciArICc+PC8nICsgdGFnICsgJz4nO1xuXHRcdFx0cmV0dXJuIHRvQXJyYXkoIGRpdi5jaGlsZE5vZGVzWyAwIF0uYXR0cmlidXRlcyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdEluKCBoYXlzdGFjaywgbmVlZGxlICkge1xuXHRcdFx0dmFyIGkgPSBoYXlzdGFjay5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBoYXlzdGFja1sgaSBdLm5hbWUgPT09IG5lZWRsZS5uYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIG5hbWVzcGFjZXMsIGNyZWF0ZUVsZW1lbnQsIHRvQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiggQ29uZGl0aW9uYWxBdHRyaWJ1dGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRpZiAoICFhdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlcy5tYXAoIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbmRpdGlvbmFsQXR0cmlidXRlKCBlbGVtZW50LCBhICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggQ29uZGl0aW9uYWxBdHRyaWJ1dGUgKTtcblxuXHQvKiB1dGlscy9leHRlbmQuanMgKi9cblx0dmFyIGV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0dmFyIHNvdXJjZXMgPSBTTElDRSQwLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHZhciBwcm9wLCBzb3VyY2U7XG5cdFx0d2hpbGUgKCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCkgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIHNvdXJjZSApIHtcblx0XHRcdFx0aWYgKCBzb3VyY2UuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIHByb3AgXSA9IHNvdXJjZVsgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvQmluZGluZy5qcyAqL1xuXHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCB3YXJuLCBjcmVhdGUsIGV4dGVuZCwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHZhciBpbnRlcnBvbGF0b3IsIGtleXBhdGgsIHZhbHVlO1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcblx0XHRcdHRoaXMuYXR0cmlidXRlID0gZWxlbWVudC5hdHRyaWJ1dGVzWyB0aGlzLm5hbWUgfHwgJ3ZhbHVlJyBdO1xuXHRcdFx0aW50ZXJwb2xhdG9yID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yO1xuXHRcdFx0aW50ZXJwb2xhdG9yLnR3b3dheUJpbmRpbmcgPSB0aGlzO1xuXHRcdFx0aWYgKCBpbnRlcnBvbGF0b3Iua2V5cGF0aCAmJiBpbnRlcnBvbGF0b3Iua2V5cGF0aC5zdWJzdHIoIDAsIDIgKSA9PT0gJyR7JyApIHtcblx0XHRcdFx0d2FybiggJ1R3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggZXhwcmVzc2lvbnMgKGAnICsgaW50ZXJwb2xhdG9yLmtleXBhdGguc2xpY2UoIDIsIC0xICkgKyAnYCknICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIEEgbXVzdGFjaGUgbWF5IGJlICphbWJpZ3VvdXMqLiBMZXQncyBzYXkgd2Ugd2VyZSBnaXZlblxuXHRcdFx0Ly8gYHZhbHVlPVwie3tiYXJ9fVwiYC4gSWYgdGhlIGNvbnRleHQgd2FzIGBmb29gLCBhbmQgYGZvby5iYXJgXG5cdFx0XHQvLyAqd2Fzbid0KiBgdW5kZWZpbmVkYCwgdGhlIGtleXBhdGggd291bGQgYmUgYGZvby5iYXJgLlxuXHRcdFx0Ly8gVGhlbiwgYW55IHVzZXIgaW5wdXQgd291bGQgcmVzdWx0IGluIGBmb28uYmFyYCBiZWluZyB1cGRhdGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIElmLCBob3dldmVyLCBgZm9vLmJhcmAgKndhcyogdW5kZWZpbmVkLCBhbmQgc28gd2FzIGBiYXJgLCB3ZSB3b3VsZCBiZVxuXHRcdFx0Ly8gbGVmdCB3aXRoIGFuIHVucmVzb2x2ZWQgcGFydGlhbCBrZXlwYXRoIC0gc28gd2UgYXJlIGZvcmNlZCB0byBtYWtlIGFuXG5cdFx0XHQvLyBhc3N1bXB0aW9uLiBUaGF0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgaW5wdXQgaW4gcXVlc3Rpb24gc2hvdWxkXG5cdFx0XHQvLyBiZSBmb3JjZWQgdG8gcmVzb2x2ZSB0byBgYmFyYCwgYW5kIGFueSB1c2VyIGlucHV0IHdvdWxkIGFmZmVjdCBgYmFyYFxuXHRcdFx0Ly8gYW5kIG5vdCBgZm9vLmJhcmAuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gRGlkIHRoYXQgbWFrZSBhbnkgc2Vuc2U/IE5vPyBPaC4gU29ycnkuIFdlbGwgdGhlIG1vcmFsIG9mIHRoZSBzdG9yeSBpc1xuXHRcdFx0Ly8gYmUgZXhwbGljaXQgd2hlbiB1c2luZyB0d28td2F5IGRhdGEtYmluZGluZyBhYm91dCB3aGF0IGtleXBhdGggeW91J3JlXG5cdFx0XHQvLyB1cGRhdGluZy4gVXNpbmcgaXQgaW4gbGlzdHMgaXMgcHJvYmFibHkgYSByZWNpcGUgZm9yIGNvbmZ1c2lvbi4uLlxuXHRcdFx0aWYgKCAhaW50ZXJwb2xhdG9yLmtleXBhdGggKSB7XG5cdFx0XHRcdGludGVycG9sYXRvci5yZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aDtcblx0XHRcdC8vIGluaXRpYWxpc2UgdmFsdWUsIGlmIGl0J3MgdW5kZWZpbmVkXG5cdFx0XHRpZiAoIHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICkgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdEJpbmRpbmcucHJvdG90eXBlID0ge1xuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVib3VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBiaW5kaW5ncywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblx0XHRcdFx0b2xkS2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvci5rZXlwYXRoO1xuXHRcdFx0XHQvLyBUaGUgYXR0cmlidXRlIHRoaXMgYmluZGluZyBpcyBsaW5rZWQgdG8gaGFzIGFscmVhZHkgZG9uZSB0aGUgd29ya1xuXHRcdFx0XHRpZiAoIG9sZEtleXBhdGggPT09IG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgb2xkS2V5cGF0aCBdLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdIHx8ICggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cdFx0QmluZGluZy5leHRlbmQgPSBmdW5jdGlvbiggcHJvcGVydGllcyApIHtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmc7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdFx0QmluZGluZy5jYWxsKCB0aGlzLCBlbGVtZW50ICk7XG5cdFx0XHRcdGlmICggdGhpcy5pbml0ICkge1xuXHRcdFx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0U3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0ZXh0ZW5kKCBTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlLCBwcm9wZXJ0aWVzICk7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcuZXh0ZW5kID0gQmluZGluZy5leHRlbmQ7XG5cdFx0XHRyZXR1cm4gU3BlY2lhbGlzZWRCaW5kaW5nO1xuXHRcdH07XG5cdFx0cmV0dXJuIEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9zaGFyZWQvaGFuZGxlRG9tRXZlbnQuanMgKi9cblx0dmFyIGhhbmRsZURvbUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuXHRcdHRoaXMuX3JhY3RpdmUuYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9Db250ZW50RWRpdGFibGVCaW5kaW5nLmpzICovXG5cdHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogJyc7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggIXRoaXMucm9vdC5sYXp5ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmlubmVySFRNTDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvc2hhcmVkL2dldFNpYmxpbmdzLmpzICovXG5cdHZhciBnZXRTaWJsaW5ncyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHNldHMgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0U2libGluZ3MoIGlkLCBncm91cCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG5cdFx0XHRyZXR1cm4gc2V0c1sgaGFzaCBdIHx8ICggc2V0c1sgaGFzaCBdID0gW10gKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9CaW5kaW5nLmpzICovXG5cdHZhciBSYWRpb0JpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICdjaGVja2VkJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICkgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBSYWRpb0JpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9OYW1lQmluZGluZy5qcyAqL1xuXHR2YXIgUmFkaW9OYW1lQmluZGluZyA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50LCBnZXRTaWJsaW5ncyApIHtcblxuXHRcdHZhciBSYWRpb05hbWVCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICduYW1lJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvbmFtZScsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5yYWRpb05hbWUgPSB0cnVlO1xuXHRcdFx0XHQvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS50d293YXkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0cmV0dXJuIG5vZGUuX3JhY3RpdmUgPyBub2RlLl9yYWN0aXZlLnZhbHVlIDogbm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIDxpbnB1dD4gaXMgdGhlIG9uZSB0aGF0J3MgY2hlY2tlZCwgdGhlbiB0aGUgdmFsdWUgb2YgaXRzXG5cdFx0XHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYm91bmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBub2RlO1xuXHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5yZWJvdW5kLmNhbGwoIHRoaXMsIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSApIHtcblx0XHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gUmFkaW9OYW1lQmluZGluZztcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCwgZ2V0U2libGluZ3MgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveE5hbWVCaW5kaW5nLmpzICovXG5cdHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gZnVuY3Rpb24oIGlzQXJyYXksIGFycmF5Q29udGFpbnMsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ25hbWUnLFxuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhpcyBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIGdyb3VwIChvZiBpbnB1dHMgdGhhdFxuXHRcdFx0XHQvLyBzaGFyZSBhIG5hbWUpLCBiZWNhdXNlIGl0IG9ubHkgZ2V0cyBjYWxsZWQgaWYgdGhlcmVcblx0XHRcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG5cdFx0XHRcdC8vIGEgbm90ZSBvZiB0aGF0IGZhY3QgdGhhdCB0aGVyZSB3YXMgbm8gaW5pdGlhbCB2YWx1ZSxcblx0XHRcdFx0Ly8gYW5kIHBvcHVsYXRlIGl0IHVzaW5nIGFueSBgY2hlY2tlZGAgYXR0cmlidXRlcyB0aGF0XG5cdFx0XHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcblx0XHRcdFx0Ly8gc3VwcG9ydCBhbnl3YXkgdG8gYXZvaWQgYnJlYWtpbmcgZXhwZWN0YXRpb25zKVxuXHRcdFx0XHR0aGlzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXHRcdFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7XG5cdFx0XHRcdC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLnR3b3dheSA9IHRydWU7XG5cdFx0XHRcdC8vIHdlIHNldCB0aGlzIHByb3BlcnR5IHNvIHRoYXQgdGhlIGF0dHJpYnV0ZSBnZXRzIHRoZSBjb3JyZWN0IHVwZGF0ZSBtZXRob2Rcblx0XHRcdFx0Ly8gRWFjaCBpbnB1dCBoYXMgYSByZWZlcmVuY2UgdG8gYW4gYXJyYXkgY29udGFpbmluZyBpdCBhbmQgaXRzXG5cdFx0XHRcdC8vIHNpYmxpbmdzLCBhcyB0d28td2F5IGJpbmRpbmcgZGVwZW5kcyBvbiBiZWluZyBhYmxlIHRvIGFzY2VydGFpblxuXHRcdFx0XHQvLyB0aGUgc3RhdHVzIG9mIGFsbCBpbnB1dHMgd2l0aGluIHRoZSBncm91cFxuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ2NoZWNrYm94ZXMnLCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdGlmICggdGhpcy5ub0luaXRpYWxWYWx1ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBubyBpbml0aWFsIHZhbHVlIHdhcyBzZXQsIGFuZCB0aGlzIGlucHV0IGlzIGNoZWNrZWQsIHdlXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgbW9kZWxcblx0XHRcdFx0aWYgKCB0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjaGVja2VkJyApICkge1xuXHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUucHVzaCggYmluZGluZ1ZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlLFxuXHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZTtcblx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRpZiAoIGlzQXJyYXkoIGV4aXN0aW5nVmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGFycmF5Q29udGFpbnMoIGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gZXhpc3RpbmdWYWx1ZSA9PSBiaW5kaW5nVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5uYW1lID0gJ3t7JyArIHRoaXMua2V5cGF0aCArICd9fSc7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0Ly8gaW4gY2FzZSBvZiBJRSBlbWVyZ2VuY3ksIGJpbmQgdG8gY2xpY2sgZXZlbnQgYXMgd2VsbFxuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Y2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB3YXNDaGVja2VkID0gISF0aGlzLmlzQ2hlY2tlZDtcblx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pc0NoZWNrZWQgPT09IHdhc0NoZWNrZWQ7XG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2libGluZ3MuZmlsdGVyKCBpc0NoZWNrZWQgKS5tYXAoIGdldFZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0ZnVuY3Rpb24gaXNDaGVja2VkKCBiaW5kaW5nICkge1xuXHRcdFx0cmV0dXJuIGJpbmRpbmcuaXNDaGVja2VkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlKCBiaW5kaW5nICkge1xuXHRcdFx0cmV0dXJuIGJpbmRpbmcuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHR9XG5cdFx0cmV0dXJuIENoZWNrYm94TmFtZUJpbmRpbmc7XG5cdH0oIGlzQXJyYXksIGFycmF5Q29udGFpbnMsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvQ2hlY2tib3hCaW5kaW5nLmpzICovXG5cdHZhciBDaGVja2JveEJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ2hlY2tib3hCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICdjaGVja2VkJyxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIENoZWNrYm94QmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9TZWxlY3RCaW5kaW5nLmpzICovXG5cdHZhciBTZWxlY3RCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIFNlbGVjdEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQub3B0aW9ucyxcblx0XHRcdFx0XHRsZW4sIGksIHZhbHVlLCBvcHRpb25XYXNTZWxlY3RlZDtcblx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRpZiAoICFsZW4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHRha2UgdGhlIGZpbmFsIHNlbGVjdGVkIG9wdGlvbi4uLlxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG9yIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLCBpZiBub25lIGFyZSBzZWxlY3RlZFxuXHRcdFx0XHRpZiAoICFvcHRpb25XYXNTZWxlY3RlZCApIHtcblx0XHRcdFx0XHR3aGlsZSAoICsraSA8IGxlbiApIHtcblx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICdkaXNhYmxlZCcgKSApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUaGlzIGlzIGFuIG9wdGltaXNhdGlvbiAoYWthIGhhY2spIHRoYXQgYWxsb3dzIHVzIHRvIGZvcmdvIHNvbWVcblx0XHRcdFx0Ly8gb3RoZXIgbW9yZSBleHBlbnNpdmUgd29ya1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMudmFsdWUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gdGhpcyBtZXRob2QgaXMgYW4gYW5vbWFseS4uLiBpcyBpdCBuZWNlc3Nhcnk/XG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG5cdFx0XHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIGkgXS5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gU2VsZWN0QmluZGluZztcblx0fSggcnVubG9vcCwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB1dGlscy9hcnJheUNvbnRlbnRzTWF0Y2guanMgKi9cblx0dmFyIGFycmF5Q29udGVudHNNYXRjaCA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHRpZiAoICFpc0FycmF5KCBhICkgfHwgIWlzQXJyYXkoIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBhLmxlbmd0aCAhPT0gYi5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIGFbIGkgXSAhPT0gYlsgaSBdICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL011bHRpcGxlU2VsZWN0QmluZGluZy5qcyAqL1xuXHR2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGFycmF5Q29udGVudHNNYXRjaCwgU2VsZWN0QmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gU2VsZWN0QmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQub3B0aW9ucy5maWx0ZXIoIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcgKTtcblx0XHRcdFx0fSApLm1hcCggZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlRnJvbU1vZGVsO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdHZhbHVlRnJvbU1vZGVsID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIHZhbHVlRnJvbU1vZGVsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0IHZhbHVlIGZyb20gRE9NLCBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RPRE8gbm90IGltcGxlbWVudGVkIHlldCcgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxlY3RlZFZhbHVlcywgb3B0aW9ucywgaSwgbGVuLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRzZWxlY3RlZFZhbHVlcyA9IFtdO1xuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcblx0XHRcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZFZhbHVlcy5wdXNoKCBvcHRpb25WYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSwgcHJldmlvdXNWYWx1ZSwgdmFsdWU7XG5cdFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuXHRcdFx0XHRwcmV2aW91c1ZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCBwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWFycmF5Q29udGVudHNNYXRjaCggdmFsdWUsIHByZXZpb3VzVmFsdWUgKSApIHtcblx0XHRcdFx0XHRTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZU1vZGVsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdGhpcy5pbml0aWFsVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gTXVsdGlwbGVTZWxlY3RCaW5kaW5nO1xuXHR9KCBydW5sb29wLCBhcnJheUNvbnRlbnRzTWF0Y2gsIFNlbGVjdEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvRmlsZUxpc3RCaW5kaW5nLmpzICovXG5cdHZhciBGaWxlTGlzdEJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgRmlsZUxpc3RCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5maWxlcztcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIEZpbGVMaXN0QmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9HZW5lcmljQmluZGluZy5qcyAqL1xuXHR2YXIgR2VuZXJpY0JpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEdlbmVyaWNCaW5kaW5nLCBnZXRPcHRpb25zO1xuXHRcdGdldE9wdGlvbnMgPSB7XG5cdFx0XHRldmFsdWF0ZVdyYXBwZWQ6IHRydWVcblx0XHR9O1xuXHRcdEdlbmVyaWNCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5yb290LmxhenkgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0X19leHBvcnQgPSBHZW5lcmljQmluZGluZztcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRoYW5kbGVEb21FdmVudC5jYWxsKCB0aGlzICk7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX3JhY3RpdmUucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLl9yYWN0aXZlLmJpbmRpbmcua2V5cGF0aCwgZ2V0T3B0aW9ucyApO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9OdW1lcmljQmluZGluZy5qcyAqL1xuXHR2YXIgTnVtZXJpY0JpbmRpbmcgPSBmdW5jdGlvbiggR2VuZXJpY0JpbmRpbmcgKSB7XG5cblx0XHRyZXR1cm4gR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdCggdGhpcy5lbGVtZW50Lm5vZGUudmFsdWUgKTtcblx0XHRcdFx0cmV0dXJuIGlzTmFOKCB2YWx1ZSApID8gdW5kZWZpbmVkIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9KCBHZW5lcmljQmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVUd293YXlCaW5kaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nID0gZnVuY3Rpb24oIGxvZywgQ29udGVudEVkaXRhYmxlQmluZGluZywgUmFkaW9CaW5kaW5nLCBSYWRpb05hbWVCaW5kaW5nLCBDaGVja2JveE5hbWVCaW5kaW5nLCBDaGVja2JveEJpbmRpbmcsIFNlbGVjdEJpbmRpbmcsIE11bHRpcGxlU2VsZWN0QmluZGluZywgRmlsZUxpc3RCaW5kaW5nLCBOdW1lcmljQmluZGluZywgR2VuZXJpY0JpbmRpbmcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUd293YXlCaW5kaW5nKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMsXG5cdFx0XHRcdHR5cGUsIEJpbmRpbmcsIGJpbmROYW1lLCBiaW5kQ2hlY2tlZDtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBsYXRlIGJpbmRpbmcsIGFuZCB0aGVyZSdzIGFscmVhZHkgb25lLCBpdFxuXHRcdFx0Ly8gbmVlZHMgdG8gYmUgdG9ybiBkb3duXG5cdFx0XHRpZiAoIGVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0ZWxlbWVudC5iaW5kaW5nLnRlYXJkb3duKCk7XG5cdFx0XHRcdGVsZW1lbnQuYmluZGluZyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBjb250ZW50ZWRpdGFibGVcblx0XHRcdGlmICggLy8gaWYgdGhlIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGUgaXMgdHJ1ZSBvciBpcyBiaW5kYWJsZSBhbmQgbWF5IHRodXMgYmVjb21lIHRydWVcblx0XHRcdFx0KCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSB8fCAhIWF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlICkgKSAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICkge1xuXHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94JyApIHtcblx0XHRcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoIGF0dHJpYnV0ZXMubmFtZSApO1xuXHRcdFx0XHRcdGJpbmRDaGVja2VkID0gaXNCaW5kYWJsZSggYXR0cmlidXRlcy5jaGVja2VkICk7XG5cdFx0XHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcblx0XHRcdFx0XHRpZiAoIGJpbmROYW1lICYmIGJpbmRDaGVja2VkICkge1xuXHRcdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdiYWRSYWRpb0lucHV0QmluZGluZydcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBiaW5kTmFtZSApIHtcblx0XHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAncmFkaW8nID8gUmFkaW9OYW1lQmluZGluZyA6IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYmluZENoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gJ3JhZGlvJyA/IFJhZGlvQmluZGluZyA6IENoZWNrYm94QmluZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdmaWxlJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0QmluZGluZyA9IEZpbGVMaXN0QmluZGluZztcblx0XHRcdFx0fSBlbHNlIGlmICggaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAncmFuZ2UnID8gTnVtZXJpY0JpbmRpbmcgOiBHZW5lcmljQmluZGluZztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApID8gTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogU2VsZWN0QmluZGluZztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBHZW5lcmljQmluZGluZztcblx0XHRcdH1cblx0XHRcdGlmICggQmluZGluZyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBCaW5kaW5nKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzQmluZGFibGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQmluZGFibGU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbG9nLCBDb250ZW50RWRpdGFibGVCaW5kaW5nLCBSYWRpb0JpbmRpbmcsIFJhZGlvTmFtZUJpbmRpbmcsIENoZWNrYm94TmFtZUJpbmRpbmcsIENoZWNrYm94QmluZGluZywgU2VsZWN0QmluZGluZywgTXVsdGlwbGVTZWxlY3RCaW5kaW5nLCBGaWxlTGlzdEJpbmRpbmcsIE51bWVyaWNCaW5kaW5nLCBHZW5lcmljQmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRidWJibGUgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkYnViYmxlKCkge1xuXHRcdHZhciBoYXNBY3Rpb24gPSB0aGlzLmdldEFjdGlvbigpO1xuXHRcdGlmICggaGFzQWN0aW9uICYmICF0aGlzLmhhc0xpc3RlbmVyICkge1xuXHRcdFx0dGhpcy5saXN0ZW4oKTtcblx0XHR9IGVsc2UgaWYgKCAhaGFzQWN0aW9uICYmIHRoaXMuaGFzTGlzdGVuZXIgKSB7XG5cdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2ZpcmUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkZmlyZSA9IGZ1bmN0aW9uKCBmaXJlRXZlbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoIGV2ZW50ICkge1xuXHRcdFx0ZmlyZUV2ZW50KCB0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHtcblx0XHRcdFx0ZXZlbnQ6IGV2ZW50XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfZmlyZUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvZ2V0QWN0aW9uLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGdldEFjdGlvbiA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRnZXRBY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkaW5pdCA9IGZ1bmN0aW9uKCBnZXRGdW5jdGlvbkZyb21TdHJpbmcsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBjaXJjdWxhciwgZmlyZUV2ZW50LCBsb2cgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEZyYWdtZW50LCBnZXRWYWx1ZU9wdGlvbnMgPSB7XG5cdFx0XHRcdGFyZ3M6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRldmVudFBhdHRlcm4gPSAvXmV2ZW50KD86XFwuKC4rKSk/Lztcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGluaXQoIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB0aGlzLFxuXHRcdFx0XHRhY3Rpb24sIHJlZnMsIHJhY3RpdmU7XG5cdFx0XHRoYW5kbGVyLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0aGFuZGxlci5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0aGFuZGxlci5uYW1lID0gbmFtZTtcblx0XHRcdGlmICggbmFtZS5pbmRleE9mKCAnKicgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiB0aGlzLnJvb3QuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vRWxlbWVudFByb3h5RXZlbnRXaWxkY2FyZHMnLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQudGFnTmFtZSxcblx0XHRcdFx0XHRcdGV2ZW50OiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRlbXBsYXRlLm0gKSB7XG5cdFx0XHRcdHJlZnMgPSB0ZW1wbGF0ZS5hLnI7XG5cdFx0XHRcdC8vIFRoaXMgaXMgYSBtZXRob2QgY2FsbFxuXHRcdFx0XHRoYW5kbGVyLm1ldGhvZCA9IHRlbXBsYXRlLm07XG5cdFx0XHRcdGhhbmRsZXIua2V5cGF0aHMgPSBbXTtcblx0XHRcdFx0aGFuZGxlci5mbiA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZyggdGVtcGxhdGUuYS5zLCByZWZzLmxlbmd0aCApO1xuXHRcdFx0XHRoYW5kbGVyLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdFx0cmFjdGl2ZSA9IGhhbmRsZXIucm9vdDtcblx0XHRcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2Vcblx0XHRcdFx0aGFuZGxlci5yZWZSZXNvbHZlcnMgPSByZWZzLm1hcCggZnVuY3Rpb24oIHJlZiwgaSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhlIGBldmVudGAgb2JqZWN0XG5cdFx0XHRcdFx0aWYgKCBtYXRjaCA9IGV2ZW50UGF0dGVybi5leGVjKCByZWYgKSApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIua2V5cGF0aHNbIGkgXSA9IHtcblx0XHRcdFx0XHRcdFx0ZXZlbnRPYmplY3Q6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHJlZmluZW1lbnRzOiBtYXRjaFsgMSBdID8gbWF0Y2hbIDEgXS5zcGxpdCggJy4nICkgOiBbXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIGhhbmRsZXIsIHJlZiwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyLnJlc29sdmUoIGksIGtleXBhdGggKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5maXJlID0gZmlyZU1ldGhvZENhbGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBHZXQgYWN0aW9uICgnZm9vJyBpbiAnb24tY2xpY2s9J2ZvbycpXG5cdFx0XHRcdGFjdGlvbiA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRcdGlmICggdHlwZW9mIGFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0YWN0aW9uID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogYWN0aW9uLFxuXHRcdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XG5cdFx0XHRcdC8vIEdldCBwYXJhbWV0ZXJzXG5cdFx0XHRcdGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdFx0b3duZXI6IHRoaXMuZWxlbWVudFxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcztcblx0XHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG5cdFx0XHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aFBhcmFtcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlTWV0aG9kQ2FsbCggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmFjdGl2ZSwgdmFsdWVzLCBhcmdzO1xuXHRcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblx0XHRcdGlmICggdHlwZW9mIHJhY3RpdmVbIHRoaXMubWV0aG9kIF0gIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0F0dGVtcHRlZCB0byBjYWxsIGEgbm9uLWV4aXN0ZW50IG1ldGhvZCAoXCInICsgdGhpcy5tZXRob2QgKyAnXCIpJyApO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWVzID0gdGhpcy5rZXlwYXRocy5tYXAoIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGxlbiwgaTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gbm90IHlldCByZXNvbHZlZFxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVE9ETyB0aGUgcmVmaW5lbWVudHMgc3R1ZmYgd291bGQgYmUgYmV0dGVyIGhhbmRsZWQgYXQgcGFyc2UgdGltZVxuXHRcdFx0XHRpZiAoIGtleXBhdGguZXZlbnRPYmplY3QgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBldmVudDtcblx0XHRcdFx0XHRpZiAoIGxlbiA9IGtleXBhdGgucmVmaW5lbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVsga2V5cGF0aC5yZWZpbmVtZW50c1sgaSBdIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSApO1xuXHRcdFx0cmFjdGl2ZS5ldmVudCA9IGV2ZW50O1xuXHRcdFx0YXJncyA9IHRoaXMuZm4uYXBwbHkoIG51bGwsIHZhbHVlcyApO1xuXHRcdFx0cmFjdGl2ZVsgdGhpcy5tZXRob2QgXS5hcHBseSggcmFjdGl2ZSwgYXJncyApO1xuXHRcdFx0ZGVsZXRlIHJhY3RpdmUuZXZlbnQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlyZUV2ZW50V2l0aFBhcmFtcyggZXZlbnQgKSB7XG5cdFx0XHRmaXJlRXZlbnQoIHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwge1xuXHRcdFx0XHRldmVudDogZXZlbnQsXG5cdFx0XHRcdGFyZ3M6IHRoaXMucGFyYW1zXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXMoIGV2ZW50ICkge1xuXHRcdFx0dmFyIGFyZ3MgPSB0aGlzLmR5bmFtaWNQYXJhbXMuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0Ly8gbmVlZCB0byBzdHJpcCBbXSBmcm9tIGVuZHMgaWYgYSBzdHJpbmchXG5cdFx0XHRpZiAoIHR5cGVvZiBhcmdzID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YXJncyA9IGFyZ3Muc3Vic3RyKCAxLCBhcmdzLmxlbmd0aCAtIDIgKTtcblx0XHRcdH1cblx0XHRcdGZpcmVFdmVudCggdGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7XG5cdFx0XHRcdGV2ZW50OiBldmVudCxcblx0XHRcdFx0YXJnczogYXJnc1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGdldEZ1bmN0aW9uRnJvbVN0cmluZywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGNpcmN1bGFyLCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQsIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvc2hhcmVkL2dlbmVyaWNIYW5kbGVyLmpzICovXG5cdHZhciBnZW5lcmljSGFuZGxlciA9IGZ1bmN0aW9uIGdlbmVyaWNIYW5kbGVyKCBldmVudCApIHtcblx0XHR2YXIgc3RvcmFnZSwgaGFuZGxlcjtcblx0XHRzdG9yYWdlID0gdGhpcy5fcmFjdGl2ZTtcblx0XHRoYW5kbGVyID0gc3RvcmFnZS5ldmVudHNbIGV2ZW50LnR5cGUgXTtcblx0XHRoYW5kbGVyLmZpcmUoIHtcblx0XHRcdG5vZGU6IHRoaXMsXG5cdFx0XHRvcmlnaW5hbDogZXZlbnQsXG5cdFx0XHRpbmRleDogc3RvcmFnZS5pbmRleCxcblx0XHRcdGtleXBhdGg6IHN0b3JhZ2Uua2V5cGF0aCxcblx0XHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC5nZXQoIHN0b3JhZ2Uua2V5cGF0aCApXG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2xpc3Rlbi5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRsaXN0ZW4gPSBmdW5jdGlvbiggY29uZmlnLCBnZW5lcmljSGFuZGxlciwgbG9nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBjdXN0b21IYW5kbGVycyA9IHt9LFxuXHRcdFx0dG91Y2hFdmVudHMgPSB7XG5cdFx0XHRcdHRvdWNoc3RhcnQ6IHRydWUsXG5cdFx0XHRcdHRvdWNobW92ZTogdHJ1ZSxcblx0XHRcdFx0dG91Y2hlbmQ6IHRydWUsXG5cdFx0XHRcdHRvdWNoY2FuY2VsOiB0cnVlLFxuXHRcdFx0XHQvL25vdCB3M2MsIGJ1dCBzdXBwb3J0ZWQgaW4gc29tZSBicm93c2Vyc1xuXHRcdFx0XHR0b3VjaGxlYXZlOiB0cnVlXG5cdFx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGxpc3RlbigpIHtcblx0XHRcdHZhciBkZWZpbml0aW9uLCBuYW1lID0gdGhpcy5uYW1lO1xuXHRcdFx0aWYgKCB0aGlzLmludmFsaWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggZGVmaW5pdGlvbiA9IGNvbmZpZy5yZWdpc3RyaWVzLmV2ZW50cy5maW5kKCB0aGlzLnJvb3QsIG5hbWUgKSApIHtcblx0XHRcdFx0dGhpcy5jdXN0b20gPSBkZWZpbml0aW9uKCB0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIoIG5hbWUgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTG9va3MgbGlrZSB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdGFuZGFyZCBET00gZXZlbnQuLi4gYnV0IGxldCdzIGNoZWNrXG5cdFx0XHRcdGlmICggISggJ29uJyArIG5hbWUgaW4gdGhpcy5ub2RlICkgJiYgISggd2luZG93ICYmICdvbicgKyBuYW1lIGluIHdpbmRvdyApICkge1xuXHRcdFx0XHRcdC8vIG9rYXkgdG8gdXNlIHRvdWNoIGV2ZW50cyBpZiB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZW1cblx0XHRcdFx0XHRpZiAoICF0b3VjaEV2ZW50c1sgbmFtZSBdICkge1xuXHRcdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRcdGRlYnVnOiB0aGlzLnJvb3QuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHBsdWdpbjogJ2V2ZW50Jyxcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCBuYW1lLCBnZW5lcmljSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFzTGlzdGVuZXIgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRDdXN0b21IYW5kbGVyKCBuYW1lICkge1xuXHRcdFx0aWYgKCAhY3VzdG9tSGFuZGxlcnNbIG5hbWUgXSApIHtcblx0XHRcdFx0Y3VzdG9tSGFuZGxlcnNbIG5hbWUgXSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHR2YXIgc3RvcmFnZSA9IGV2ZW50Lm5vZGUuX3JhY3RpdmU7XG5cdFx0XHRcdFx0ZXZlbnQuaW5kZXggPSBzdG9yYWdlLmluZGV4O1xuXHRcdFx0XHRcdGV2ZW50LmtleXBhdGggPSBzdG9yYWdlLmtleXBhdGg7XG5cdFx0XHRcdFx0ZXZlbnQuY29udGV4dCA9IHN0b3JhZ2Uucm9vdC5nZXQoIHN0b3JhZ2Uua2V5cGF0aCApO1xuXHRcdFx0XHRcdHN0b3JhZ2UuZXZlbnRzWyBuYW1lIF0uZmlyZSggZXZlbnQgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjdXN0b21IYW5kbGVyc1sgbmFtZSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNvbmZpZywgZ2VuZXJpY0hhbmRsZXIsIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZWJpbmQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0dmFyIGZyYWdtZW50O1xuXHRcdGlmICggdGhpcy5tZXRob2QgKSB7XG5cdFx0XHRmcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRyZWJpbmQoIHRoaXMuYWN0aW9uICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0cmViaW5kKCB0aGlzLmR5bmFtaWNQYXJhbXMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWJpbmQoIHRoaW5nICkge1xuXHRcdFx0dGhpbmcgJiYgdGhpbmcucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlbmRlciA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZW5kZXIoKSB7XG5cdFx0dGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0Ly8gc3RvcmUgdGhpcyBvbiB0aGUgbm9kZSBpdHNlbGYsIHNvIGl0IGNhbiBiZSByZXRyaWV2ZWQgYnkgYVxuXHRcdC8vIHVuaXZlcnNhbCBoYW5kbGVyXG5cdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmV2ZW50c1sgdGhpcy5uYW1lIF0gPSB0aGlzO1xuXHRcdGlmICggdGhpcy5tZXRob2QgfHwgdGhpcy5nZXRBY3Rpb24oKSApIHtcblx0XHRcdHRoaXMubGlzdGVuKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3Jlc29sdmUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVzb2x2ZSA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZXNvbHZlKCBpbmRleCwga2V5cGF0aCApIHtcblx0XHR0aGlzLmtleXBhdGhzWyBpbmRleCBdID0ga2V5cGF0aDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5iaW5kID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5iaW5kKCkge1xuXHRcdFx0aWYgKCB0aGlzLm1ldGhvZCApIHtcblx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFRlYXIgZG93biBkeW5hbWljIG5hbWVcblx0XHRcdGlmICggdHlwZW9mIHRoaXMuYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy5hY3Rpb24udW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUZWFyIGRvd24gZHluYW1pYyBwYXJhbWV0ZXJzXG5cdFx0XHRpZiAoIHRoaXMuZHluYW1pY1BhcmFtcyApIHtcblx0XHRcdFx0dGhpcy5keW5hbWljUGFyYW1zLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIHggKSB7XG5cdFx0XHR4LnVuYmluZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bnJlbmRlciA9IGZ1bmN0aW9uKCBnZW5lcmljSGFuZGxlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5yZW5kZXIoKSB7XG5cdFx0XHRpZiAoIHRoaXMuY3VzdG9tICkge1xuXHRcdFx0XHR0aGlzLmN1c3RvbS50ZWFyZG93bigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRoaXMubmFtZSwgZ2VuZXJpY0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhhc0xpc3RlbmVyID0gZmFsc2U7XG5cdFx0fTtcblx0fSggZ2VuZXJpY0hhbmRsZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL19FdmVudEhhbmRsZXIuanMgKi9cblx0dmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKCBidWJibGUsIGZpcmUsIGdldEFjdGlvbiwgaW5pdCwgbGlzdGVuLCByZWJpbmQsIHJlbmRlciwgcmVzb2x2ZSwgdW5iaW5kLCB1bnJlbmRlciApIHtcblxuXHRcdHZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiggZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR0aGlzLmluaXQoIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICk7XG5cdFx0fTtcblx0XHRFdmVudEhhbmRsZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRmaXJlOiBmaXJlLFxuXHRcdFx0Z2V0QWN0aW9uOiBnZXRBY3Rpb24sXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0bGlzdGVuOiBsaXN0ZW4sXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gRXZlbnRIYW5kbGVyO1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGdldEFjdGlvbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGxpc3RlbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlc29sdmUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUV2ZW50SGFuZGxlcnMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiggRXZlbnRIYW5kbGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50LCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBpLCBuYW1lLCBuYW1lcywgaGFuZGxlciwgcmVzdWx0ID0gW107XG5cdFx0XHRmb3IgKCBuYW1lIGluIHRlbXBsYXRlICkge1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0bmFtZXMgPSBuYW1lLnNwbGl0KCAnLScgKTtcblx0XHRcdFx0XHRpID0gbmFtZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXIoIGVsZW1lbnQsIG5hbWVzWyBpIF0sIHRlbXBsYXRlWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBoYW5kbGVyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIEV2ZW50SGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9EZWNvcmF0b3IvX0RlY29yYXRvci5qcyAqL1xuXHR2YXIgRGVjb3JhdG9yID0gZnVuY3Rpb24oIGxvZywgY2lyY3VsYXIsIGNvbmZpZyApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zLCBEZWNvcmF0b3I7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRnZXRWYWx1ZU9wdGlvbnMgPSB7XG5cdFx0XHRhcmdzOiB0cnVlXG5cdFx0fTtcblx0XHREZWNvcmF0b3IgPSBmdW5jdGlvbiggZWxlbWVudCwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgZGVjb3JhdG9yID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgbmFtZSwgZnJhZ21lbnQ7XG5cdFx0XHRkZWNvcmF0b3IuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRkZWNvcmF0b3Iucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdGlmICggdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0ZGVjb3JhdG9yLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSBkZWNvcmF0b3IuZnJhZ21lbnQuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRkZWNvcmF0b3IuZnJhZ21lbnQuYnViYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSB0aGlzLmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0XHRpZiAoIGRlY29yYXRvci5yZWFkeSApIHtcblx0XHRcdFx0XHRcdGRlY29yYXRvci51cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRkZWNvcmF0b3IuZm4gPSBjb25maWcucmVnaXN0cmllcy5kZWNvcmF0b3JzLmZpbmQoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIWRlY29yYXRvci5mbiApIHtcblx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ21pc3NpbmdQbHVnaW4nLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdHBsdWdpbjogJ2RlY29yYXRvcicsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHREZWNvcmF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkZWNvcmF0b3IgPSB0aGlzLFxuXHRcdFx0XHRcdG5vZGUsIHJlc3VsdCwgYXJncztcblx0XHRcdFx0bm9kZSA9IGRlY29yYXRvci5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdGlmICggZGVjb3JhdG9yLnBhcmFtcyApIHtcblx0XHRcdFx0XHRhcmdzID0gWyBub2RlIF0uY29uY2F0KCBkZWNvcmF0b3IucGFyYW1zICk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGVjb3JhdG9yLmZuLmFwcGx5KCBkZWNvcmF0b3Iucm9vdCwgYXJncyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRlY29yYXRvci5mbi5jYWxsKCBkZWNvcmF0b3Iucm9vdCwgbm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXJlc3VsdCB8fCAhcmVzdWx0LnRlYXJkb3duICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlY29yYXRvciBkZWZpbml0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgdGVhcmRvd24gbWV0aG9kJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRPRE8gZG9lcyB0aGlzIG1ha2Ugc2Vuc2U/XG5cdFx0XHRcdGRlY29yYXRvci5hY3R1YWwgPSByZXN1bHQ7XG5cdFx0XHRcdGRlY29yYXRvci5yZWFkeSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmFjdHVhbC51cGRhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5hY3R1YWwudXBkYXRlLmFwcGx5KCB0aGlzLnJvb3QsIHRoaXMucGFyYW1zICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oIHRydWUgKTtcblx0XHRcdFx0XHR0aGlzLmluaXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbiggdXBkYXRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCk7XG5cdFx0XHRcdGlmICggIXVwZGF0aW5nICYmIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIERlY29yYXRvcjtcblx0fSggbG9nLCBjaXJjdWxhciwgY29uZmlnICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvc2VsZWN0L3N5bmMuanMgKi9cblx0dmFyIHN5bmMgPSBmdW5jdGlvbiggdG9BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHN5bmNTZWxlY3QoIHNlbGVjdEVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgc2VsZWN0Tm9kZSwgc2VsZWN0VmFsdWUsIGlzTXVsdGlwbGUsIG9wdGlvbnMsIG9wdGlvbldhc1NlbGVjdGVkO1xuXHRcdFx0c2VsZWN0Tm9kZSA9IHNlbGVjdEVsZW1lbnQubm9kZTtcblx0XHRcdGlmICggIXNlbGVjdE5vZGUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSB0b0FycmF5KCBzZWxlY3ROb2RlLm9wdGlvbnMgKTtcblx0XHRcdHNlbGVjdFZhbHVlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlzTXVsdGlwbGUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApO1xuXHRcdFx0Ly8gSWYgdGhlIDxzZWxlY3Q+IGhhcyBhIHNwZWNpZmllZCB2YWx1ZSwgdGhhdCBzaG91bGQgb3ZlcnJpZGVcblx0XHRcdC8vIHRoZXNlIG9wdGlvbnNcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0b3B0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiggbyApIHtcblx0XHRcdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNob3VsZFNlbGVjdDtcblx0XHRcdFx0XHRvcHRpb25WYWx1ZSA9IG8uX3JhY3RpdmUgPyBvLl9yYWN0aXZlLnZhbHVlIDogby52YWx1ZTtcblx0XHRcdFx0XHRzaG91bGRTZWxlY3QgPSBpc011bHRpcGxlID8gdmFsdWVDb250YWlucyggc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlICkgOiBzZWxlY3RWYWx1ZSA9PSBvcHRpb25WYWx1ZTtcblx0XHRcdFx0XHRpZiAoIHNob3VsZFNlbGVjdCApIHtcblx0XHRcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0by5zZWxlY3RlZCA9IHNob3VsZFNlbGVjdDtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoICFvcHRpb25XYXNTZWxlY3RlZCApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIDAgXSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNbIDAgXS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2VsZWN0RWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWxlY3RFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB2YWx1ZUNvbnRhaW5zKCBzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlbGVjdFZhbHVlWyBpIF0gPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0b0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvc2VsZWN0L2J1YmJsZS5qcyAqL1xuXHR2YXIgYnViYmxlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHN5bmNTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYnViYmxlU2VsZWN0KCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuXHRcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHN5bmNTZWxlY3QoIHRoaXMkMCApO1xuXHRcdFx0XHRcdHRoaXMkMC5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIHN5bmMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9vcHRpb24vZmluZFBhcmVudFNlbGVjdC5qcyAqL1xuXHR2YXIgZmluZFBhcmVudFNlbGVjdCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnRTZWxlY3QoIGVsZW1lbnQgKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZWxlbWVudCA9IGVsZW1lbnQucGFyZW50ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL2luaXQuanMgKi9cblx0dmFyIGluaXQgPSBmdW5jdGlvbiggZmluZFBhcmVudFNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbml0T3B0aW9uKCBvcHRpb24sIHRlbXBsYXRlICkge1xuXHRcdFx0b3B0aW9uLnNlbGVjdCA9IGZpbmRQYXJlbnRTZWxlY3QoIG9wdGlvbi5wYXJlbnQgKTtcblx0XHRcdC8vIHdlIG1pZ2h0IGJlIGluc2lkZSBhIDxkYXRhbGlzdD4gZWxlbWVudFxuXHRcdFx0aWYgKCAhb3B0aW9uLnNlbGVjdCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9uLnNlbGVjdC5vcHRpb25zLnB1c2goIG9wdGlvbiApO1xuXHRcdFx0Ly8gSWYgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLCB1c2UgdGhlIGVsZW1lbnQncyBjb250ZW50XG5cdFx0XHRpZiAoICF0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHR0ZW1wbGF0ZS5hID0ge307XG5cdFx0XHR9XG5cdFx0XHQvLyAuLi5hcyBsb25nIGFzIGl0IGlzbid0IGRpc2FibGVkXG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEudmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdGVtcGxhdGUuYS5oYXNPd25Qcm9wZXJ0eSggJ2Rpc2FibGVkJyApICkge1xuXHRcdFx0XHR0ZW1wbGF0ZS5hLnZhbHVlID0gdGVtcGxhdGUuZjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZXJlIGlzIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIGJ1dCB0aGUgPHNlbGVjdD5cblx0XHRcdC8vIGFscmVhZHkgaGFzIGEgdmFsdWUsIGRlbGV0ZSBpdFxuXHRcdFx0aWYgKCAnc2VsZWN0ZWQnIGluIHRlbXBsYXRlLmEgJiYgb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgdGVtcGxhdGUuYS5zZWxlY3RlZDtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBmaW5kUGFyZW50U2VsZWN0ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgZW5mb3JjZUNhc2UsIGNyZWF0ZUF0dHJpYnV0ZXMsIGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcywgY3JlYXRlVHdvd2F5QmluZGluZywgY3JlYXRlRXZlbnRIYW5kbGVycywgRGVjb3JhdG9yLCBidWJibGVTZWxlY3QsIGluaXRPcHRpb24sIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkaW5pdCggb3B0aW9ucyApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIHJhY3RpdmUsIGJpbmRpbmcsIGJpbmRpbmdzO1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuRUxFTUVOVDtcblx0XHRcdC8vIHN0dWZmIHdlJ2xsIG5lZWQgbGF0ZXJcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0dGhpcy5wYXJlbnQgPSBvcHRpb25zLnBFbGVtZW50IHx8IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdHRoaXMubmFtZSA9IGVuZm9yY2VDYXNlKCB0ZW1wbGF0ZS5lICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPiBlbGVtZW50c1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHRpbml0T3B0aW9uKCB0aGlzLCB0ZW1wbGF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNlbGVjdD4gZWxlbWVudHNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gW107XG5cdFx0XHRcdHRoaXMuYnViYmxlID0gYnViYmxlU2VsZWN0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGF0dHJpYnV0ZXNcblx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZXMoIHRoaXMsIHRlbXBsYXRlLmEgKTtcblx0XHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzKCB0aGlzLCB0ZW1wbGF0ZS5tICk7XG5cdFx0XHQvLyBhcHBlbmQgY2hpbGRyZW4sIGlmIHRoZXJlIGFyZSBhbnlcblx0XHRcdGlmICggdGVtcGxhdGUuZiApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5mLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IHRoaXNcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIHR3b3dheSBiaW5kaW5nXG5cdFx0XHRpZiAoIHJhY3RpdmUudHdvd2F5ICYmICggYmluZGluZyA9IGNyZWF0ZVR3b3dheUJpbmRpbmcoIHRoaXMsIHRlbXBsYXRlLmEgKSApICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXHRcdFx0XHQvLyByZWdpc3RlciB0aGlzIHdpdGggdGhlIHJvb3QsIHNvIHRoYXQgd2UgY2FuIGRvIHJhY3RpdmUudXBkYXRlTW9kZWwoKVxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdIHx8ICggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgZXZlbnQgcHJveGllc1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS52ICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMgPSBjcmVhdGVFdmVudEhhbmRsZXJzKCB0aGlzLCB0ZW1wbGF0ZS52ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgZGVjb3JhdG9yXG5cdFx0XHRpZiAoIHRlbXBsYXRlLm8gKSB7XG5cdFx0XHRcdHRoaXMuZGVjb3JhdG9yID0gbmV3IERlY29yYXRvciggdGhpcywgdGVtcGxhdGUubyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIHRyYW5zaXRpb25zXG5cdFx0XHR0aGlzLmludHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDE7XG5cdFx0XHR0aGlzLm91dHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDI7XG5cdFx0fTtcblx0fSggdHlwZXMsIGVuZm9yY2VDYXNlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVBdHRyaWJ1dGVzLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUV2ZW50SGFuZGxlcnMsIERlY29yYXRvciwgYnViYmxlLCBpbml0LCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL3N0YXJ0c1dpdGguanMgKi9cblx0dmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aEtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc3RhcnRzV2l0aCggdGFyZ2V0LCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIHRhcmdldCA9PT0ga2V5cGF0aCB8fCBzdGFydHNXaXRoS2V5cGF0aCggdGFyZ2V0LCBrZXlwYXRoICk7XG5cdFx0fTtcblx0fSggc3RhcnRzV2l0aEtleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91dGlscy9hc3NpZ25OZXdLZXlwYXRoLmpzICovXG5cdHZhciBhc3NpZ25OZXdLZXlwYXRoID0gZnVuY3Rpb24oIHN0YXJ0c1dpdGgsIGdldE5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYXNzaWduTmV3S2V5cGF0aCggdGFyZ2V0LCBwcm9wZXJ0eSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHZhciBleGlzdGluZ0tleXBhdGggPSB0YXJnZXRbIHByb3BlcnR5IF07XG5cdFx0XHRpZiAoICFleGlzdGluZ0tleXBhdGggfHwgc3RhcnRzV2l0aCggZXhpc3RpbmdLZXlwYXRoLCBuZXdLZXlwYXRoICkgfHwgIXN0YXJ0c1dpdGgoIGV4aXN0aW5nS2V5cGF0aCwgb2xkS2V5cGF0aCApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbIHByb3BlcnR5IF0gPSBnZXROZXdLZXlwYXRoKCBleGlzdGluZ0tleXBhdGgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9O1xuXHR9KCBzdGFydHNXaXRoLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZWJpbmQgPSBmdW5jdGlvbiggYXNzaWduTmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGksIHN0b3JhZ2UsIGxpdmVRdWVyaWVzLCByYWN0aXZlO1xuXHRcdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZWNvcmF0b3IgKSB7XG5cdFx0XHRcdHJlYmluZCggdGhpcy5kZWNvcmF0b3IgKTtcblx0XHRcdH1cblx0XHRcdC8vIHJlYmluZCBjaGlsZHJlblxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRyZWJpbmQoIHRoaXMuZnJhZ21lbnQgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVwZGF0ZSBsaXZlIHF1ZXJpZXMsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCBsaXZlUXVlcmllcyA9IHRoaXMubGl2ZVF1ZXJpZXMgKSB7XG5cdFx0XHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cdFx0XHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGxpdmVRdWVyaWVzWyBpIF0uX21ha2VEaXJ0eSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubm9kZSAmJiAoIHN0b3JhZ2UgPSB0aGlzLm5vZGUuX3JhY3RpdmUgKSApIHtcblx0XHRcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG5cdFx0XHRcdGFzc2lnbk5ld0tleXBhdGgoIHN0b3JhZ2UsICdrZXlwYXRoJywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGluZGV4UmVmICE9IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRzdG9yYWdlLmluZGV4WyBpbmRleFJlZiBdID0gbmV3SW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmViaW5kKCB0aGluZyApIHtcblx0XHRcdFx0dGhpbmcucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBhc3NpZ25OZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvaW1nL3JlbmRlci5qcyAqL1xuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVySW1hZ2UoIGltZyApIHtcblx0XHR2YXIgbG9hZEhhbmRsZXI7XG5cdFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXkgbmVlZCB0byBwcmV2ZW50IGl0XG5cdFx0Ly8gZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG5cdFx0aWYgKCBpbWcuYXR0cmlidXRlcy53aWR0aCB8fCBpbWcuYXR0cmlidXRlcy5oZWlnaHQgKSB7XG5cdFx0XHRpbWcubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB3aWR0aCA9IGltZy5nZXRBdHRyaWJ1dGUoICd3aWR0aCcgKSxcblx0XHRcdFx0XHRoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKCAnaGVpZ2h0JyApO1xuXHRcdFx0XHRpZiAoIHdpZHRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKCAnd2lkdGgnLCB3aWR0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKCAnaGVpZ2h0JywgaGVpZ2h0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW1nLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBsb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH0sIGZhbHNlICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRpbml0ID0gZnVuY3Rpb24oIGxvZywgY29uZmlnLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zID0ge307XG5cdFx0Ly8gVE9ETyB3aGF0IGFyZSB0aGUgb3B0aW9ucz9cblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBUcmFuc2l0aW9uJGluaXQoIGVsZW1lbnQsIHRlbXBsYXRlLCBpc0ludHJvICkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblx0XHRcdHQuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0LnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXHRcdFx0dC5pc0ludHJvID0gaXNJbnRybztcblx0XHRcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IG5hbWUsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdHQubmFtZSA9IG5hbWU7XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHQucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuXHRcdFx0XHQvLyAnZGVwZW5kZW5jeSB0aHJhc2hpbmcnP1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0LnBhcmFtcyA9IGZyYWdtZW50LmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbiA9IGNvbmZpZy5yZWdpc3RyaWVzLnRyYW5zaXRpb25zLmZpbmQoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIXQuX2ZuICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cGx1Z2luOiAndHJhbnNpdGlvbicsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBsb2csIGNvbmZpZywgY2lyY3VsYXIgKTtcblxuXHQvKiB1dGlscy9jYW1lbENhc2UuanMgKi9cblx0dmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBoeXBoZW5hdGVkU3RyICkge1xuXHRcdHJldHVybiBoeXBoZW5hdGVkU3RyLnJlcGxhY2UoIC8tKFthLXpBLVpdKS9nLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvcHJlZml4LmpzICovXG5cdHZhciBwcmVmaXggPSBmdW5jdGlvbiggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSApIHtcblxuXHRcdHZhciBwcmVmaXgsIHByZWZpeENhY2hlLCB0ZXN0U3R5bGU7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRwcmVmaXggPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmVmaXhDYWNoZSA9IHt9O1xuXHRcdFx0dGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKS5zdHlsZTtcblx0XHRcdHByZWZpeCA9IGZ1bmN0aW9uKCBwcm9wICkge1xuXHRcdFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cdFx0XHRcdHByb3AgPSBjYW1lbENhc2UoIHByb3AgKTtcblx0XHRcdFx0aWYgKCAhcHJlZml4Q2FjaGVbIHByb3AgXSApIHtcblx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVsgcHJvcCBdID0gcHJvcDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdGVzdCB2ZW5kb3JzLi4uXG5cdFx0XHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXN0U3R5bGVbIHZlbmRvciArIGNhcHBlZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbIHByb3AgXSA9IHZlbmRvciArIGNhcHBlZDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJlZml4Q2FjaGVbIHByb3AgXTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBwcmVmaXg7XG5cdH0oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvZ2V0U3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGdldFN0eWxlID0gZnVuY3Rpb24oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApIHtcblxuXHRcdHZhciBnZXRTdHlsZSwgZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGdldFN0eWxlID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXHRcdFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXHRcdFx0XHRjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIHByb3BzID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcHMgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNBcnJheSggcHJvcHMgKSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUcmFuc2l0aW9uJGdldFN0eWxlIG11c3QgYmUgcGFzc2VkIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBDU1MgcHJvcGVydGllcycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZXMgPSB7fTtcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0cHJvcCA9IHByb3BzWyBpIF07XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgoIHByb3AgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHlsZXNbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdHlsZXM7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0U3R5bGU7XG5cdH0oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9zZXRTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc2V0U3R5bGUgPSBmdW5jdGlvbiggcHJlZml4ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHlsZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGlmICggdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlWyBwcmVmaXgoIHN0eWxlICkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBzdHlsZSApIHtcblx0XHRcdFx0XHRpZiAoIHN0eWxlLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBzdHlsZVsgcHJvcCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSggcHJlZml4ICk7XG5cblx0Lyogc2hhcmVkL1RpY2tlci5qcyAqL1xuXHR2YXIgVGlja2VyID0gZnVuY3Rpb24oIHdhcm4sIGdldFRpbWUsIGFuaW1hdGlvbnMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIFRpY2tlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGVhc2luZztcblx0XHRcdHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0dGhpcy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHQvLyBlYXNpbmdcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1sgb3B0aW9ucy5lYXNpbmcgXTtcblx0XHRcdFx0aWYgKCAhZWFzaW5nICkge1xuXHRcdFx0XHRcdHdhcm4oICdNaXNzaW5nIGVhc2luZyBmdW5jdGlvbiAoXCInICsgb3B0aW9ucy5lYXNpbmcgKyAnXCIpLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gZnJvbSBbVE9ET10nICk7XG5cdFx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmc7XG5cdFx0XHR0aGlzLnN0YXJ0ID0gZ2V0VGltZSgpO1xuXHRcdFx0dGhpcy5lbmQgPSB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0XHRhbmltYXRpb25zLmFkZCggdGhpcyApO1xuXHRcdH07XG5cdFx0VGlja2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdHRpY2s6IGZ1bmN0aW9uKCBub3cgKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkLCBlYXNlZDtcblx0XHRcdFx0aWYgKCAhdGhpcy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG5vdyA+IHRoaXMuZW5kICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGVwKCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdGhpcy5jb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuY29tcGxldGUoIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuXHRcdFx0XHRlYXNlZCA9IHRoaXMuZWFzaW5nKCBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbiApO1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHR0aGlzLnN0ZXAoIGVhc2VkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hYm9ydCApIHtcblx0XHRcdFx0XHR0aGlzLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IFRpY2tlcjtcblxuXHRcdGZ1bmN0aW9uIGxpbmVhciggdCApIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdhcm4sIGdldFRpbWUsIGFuaW1hdGlvbnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9oZWxwZXJzL3VucHJlZml4LmpzICovXG5cdHZhciB1bnByZWZpeCA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoICdeLSg/OicgKyB2ZW5kb3JzLmpvaW4oICd8JyApICsgJyktJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcHJvcCApIHtcblx0XHRcdHJldHVybiBwcm9wLnJlcGxhY2UoIHVucHJlZml4UGF0dGVybiwgJycgKTtcblx0XHR9O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy9oeXBoZW5hdGUuanMgKi9cblx0dmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHZlbmRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXig/OicgKyB2ZW5kb3JzLmpvaW4oICd8JyApICsgJykoW0EtWl0pJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0dmFyIGh5cGhlbmF0ZWQ7XG5cdFx0XHRpZiAoICFzdHIgKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblx0XHRcdGlmICggdmVuZG9yUGF0dGVybi50ZXN0KCBzdHIgKSApIHtcblx0XHRcdFx0c3RyID0gJy0nICsgc3RyO1xuXHRcdFx0fVxuXHRcdFx0aHlwaGVuYXRlZCA9IHN0ci5yZXBsYWNlKCAvW0EtWl0vZywgZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHRyZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBoeXBoZW5hdGVkO1xuXHRcdH07XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL2NyZWF0ZVRyYW5zaXRpb25zLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiggaXNDbGllbnQsIHdhcm4sIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSwgaW50ZXJwb2xhdGUsIFRpY2tlciwgcHJlZml4LCB1bnByZWZpeCwgaHlwaGVuYXRlICkge1xuXG5cdFx0dmFyIGNyZWF0ZVRyYW5zaXRpb25zLCB0ZXN0U3R5bGUsIFRSQU5TSVRJT04sIFRSQU5TSVRJT05FTkQsIENTU19UUkFOU0lUSU9OU19FTkFCTEVELCBUUkFOU0lUSU9OX0RVUkFUSU9OLCBUUkFOU0lUSU9OX1BST1BFUlRZLCBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiwgY2FuVXNlQ3NzVHJhbnNpdGlvbnMgPSB7fSxcblx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zID0ge307XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICkuc3R5bGU7XG5cdFx0XHQvLyBkZXRlcm1pbmUgc29tZSBmYWN0cyBhYm91dCBvdXIgZW52aXJvbm1lbnRcblx0XHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGVzdFN0eWxlLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuXHRcdFx0XHRcdFRSQU5TSVRJT05FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXN0U3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFRSQU5TSVRJT04gPSAnd2Via2l0VHJhbnNpdGlvbic7XG5cdFx0XHRcdFx0VFJBTlNJVElPTkVORCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcblx0XHRcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSgpICk7XG5cdFx0XHRpZiAoIFRSQU5TSVRJT04gKSB7XG5cdFx0XHRcdFRSQU5TSVRJT05fRFVSQVRJT04gPSBUUkFOU0lUSU9OICsgJ0R1cmF0aW9uJztcblx0XHRcdFx0VFJBTlNJVElPTl9QUk9QRVJUWSA9IFRSQU5TSVRJT04gKyAnUHJvcGVydHknO1xuXHRcdFx0XHRUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiA9IFRSQU5TSVRJT04gKyAnVGltaW5nRnVuY3Rpb24nO1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiggdCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlICkge1xuXHRcdFx0XHQvLyBXYWl0IGEgYmVhdCAob3RoZXJ3aXNlIHRoZSB0YXJnZXQgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBpbW1lZGlhdGVseSlcblx0XHRcdFx0Ly8gVE9ETyB1c2UgYSBmYXN0ZG9tLXN0eWxlIG1lY2hhbmlzbT9cblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGhhc2hQcmVmaXgsIGpzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY2hlY2tDb21wbGV0ZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXI7XG5cdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBqc1RyYW5zaXRpb25zQ29tcGxldGUgJiYgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2lsbCBjaGFuZ2VzIHRvIGV2ZW50cyBhbmQgZmlyZSBoYXZlIGFuIHVuZXhwZWN0ZWQgY29uc2VxdWVuY2UgaGVyZT9cblx0XHRcdFx0XHRcdFx0dC5yb290LmZpcmUoIHQubmFtZSArICc6ZW5kJywgdC5ub2RlLCB0LmlzSW50cm8gKTtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgY2FuIHVzZSBDU1MgdG8gYW5pbWF0ZVxuXHRcdFx0XHRcdC8vIHdoaWNoIHByb3BlcnRpZXNcblx0XHRcdFx0XHRoYXNoUHJlZml4ID0gKCB0Lm5vZGUubmFtZXNwYWNlVVJJIHx8ICcnICkgKyB0Lm5vZGUudGFnTmFtZTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fUFJPUEVSVFkgXSA9IGNoYW5nZWRQcm9wZXJ0aWVzLm1hcCggcHJlZml4ICkubWFwKCBoeXBoZW5hdGUgKS5qb2luKCAnLCcgKTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OIF0gPSBoeXBoZW5hdGUoIG9wdGlvbnMuZWFzaW5nIHx8ICdsaW5lYXInICk7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX0RVUkFUSU9OIF0gPSBvcHRpb25zLmR1cmF0aW9uIC8gMTAwMCArICdzJztcblx0XHRcdFx0XHR0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZiggY2FtZWxDYXNlKCB1bnByZWZpeCggZXZlbnQucHJvcGVydHlOYW1lICkgKSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBzdGlsbCB0cmFuc2l0aW9uaW5nLi4uXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGhhc2gsIG9yaWdpbmFsVmFsdWUsIGluZGV4LCBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdLFxuXHRcdFx0XHRcdFx0XHRwcm9wLCBzdWZmaXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0cHJvcCA9IGNoYW5nZWRQcm9wZXJ0aWVzWyBpIF07XG5cdFx0XHRcdFx0XHRcdGhhc2ggPSBoYXNoUHJlZml4ICsgcHJvcDtcblx0XHRcdFx0XHRcdFx0aWYgKCBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCAmJiAhY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBzdXJlIGlmIENTUyB0cmFuc2l0aW9ucyBhcmUgc3VwcG9ydGVkIGZvclxuXHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMgdGFnL3Byb3BlcnR5IGNvbWJvLCBmaW5kIG91dCBub3dcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgcHJvcGVydHkgaXMgdHJhbnNpdGlvbmFibGUgaW4gdGhpcyBicm93c2VyLFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgc3R5bGUgd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgdGFyZ2V0IHN0eWxlXG5cdFx0XHRcdFx0XHRcdFx0XHRjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdID0gdC5nZXRTdHlsZSggcHJvcCApICE9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdID0gIWNhblVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF07XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXNldCwgaWYgd2UncmUgZ29pbmcgdG8gdXNlIHRpbWVycyBhZnRlciBhbGxcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gb3JpZ2luYWxWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCAhQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgfHwgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aW1lci1iYXNlZCBzdHVmZlxuXHRcdFx0XHRcdFx0XHRcdGlmICggb3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcblx0XHRcdFx0XHRcdFx0XHQvLyB3aWxsIGdldCBjb25mdXNlZFxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZiggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0d2FybiggJ1NvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQgd2l0aCB0cmFuc2l0aW9ucy4gSWYgeW91IHNlZSB0aGlzIG1lc3NhZ2UsIHBsZWFzZSBsZXQgQFJhY3RpdmVKUyBrbm93LiBUaGFua3MhJyApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhbmltYXRhYmxlIGF0IGFsbFxuXHRcdFx0XHRcdFx0XHRcdHN1ZmZpeCA9IC9bXlxcZF0qJC8uZXhlYyggdG9bIHByb3AgXSApWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4udGhlbiBraWNrIG9mZiBhIHRpbWVyLWJhc2VkIHRyYW5zaXRpb25cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiBwcmVmaXgoIHByb3AgKSxcblx0XHRcdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcjogaW50ZXJwb2xhdGUoIHBhcnNlRmxvYXQoIG9yaWdpbmFsVmFsdWUgKSwgcGFyc2VGbG9hdCggdG9bIHByb3AgXSApICksXG5cdFx0XHRcdFx0XHRcdFx0XHRzdWZmaXg6IHN1ZmZpeFxuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gamF2YXNjcmlwdCB0cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBUaWNrZXIoIHtcblx0XHRcdFx0XHRcdFx0XHRyb290OiB0LnJvb3QsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBjYW1lbENhc2UoIG9wdGlvbnMuZWFzaW5nIHx8ICcnICksXG5cdFx0XHRcdFx0XHRcdFx0c3RlcDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wLCBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aSA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3AuaW50ZXJwb2xhdG9yKCBwb3MgKSArIHByb3Auc3VmZml4O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uRW5kSGFuZGxlciwgYW5kIGRlYWwgd2l0aFxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgZmFjdCB0aGF0IGl0IHdpbGwgbmV2ZXIgZmlyZVxuXHRcdFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMCApO1xuXHRcdFx0XHR9LCBvcHRpb25zLmRlbGF5IHx8IDAgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVUcmFuc2l0aW9ucztcblx0fSggaXNDbGllbnQsIHdhcm4sIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSwgaW50ZXJwb2xhdGUsIFRpY2tlciwgcHJlZml4LCB1bnByZWZpeCwgaHlwaGVuYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS92aXNpYmlsaXR5LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIGhpZGRlbiwgdmVuZG9yLCBwcmVmaXgsIGksIHZpc2liaWxpdHk7XG5cdFx0aWYgKCB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0aGlkZGVuID0gJ2hpZGRlbic7XG5cdFx0XHR2aXNpYmlsaXR5ID0ge307XG5cdFx0XHRpZiAoIGhpZGRlbiBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0cHJlZml4ID0gJyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbIGkgXTtcblx0XHRcdFx0XHRoaWRkZW4gPSB2ZW5kb3IgKyAnSGlkZGVuJztcblx0XHRcdFx0XHRpZiAoIGhpZGRlbiBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHByZWZpeCA9IHZlbmRvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcHJlZml4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHByZWZpeCArICd2aXNpYmlsaXR5Y2hhbmdlJywgb25DaGFuZ2UgKTtcblx0XHRcdFx0Ly8gaW5pdGlhbGlzZVxuXHRcdFx0XHRvbkNoYW5nZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZ2FoLCB3ZSdyZSBpbiBhbiBvbGQgYnJvd3NlclxuXHRcdFx0XHRpZiAoICdvbmZvY3Vzb3V0JyBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXNvdXQnLCBvbkhpZGUgKTtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXNpbicsIG9uU2hvdyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncGFnZWhpZGUnLCBvbkhpZGUgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBvbkhpZGUgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3BhZ2VzaG93Jywgb25TaG93ICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsIG9uU2hvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGRvY3VtZW50WyBoaWRkZW4gXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkhpZGUoKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25TaG93KCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZpc2liaWxpdHk7XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL19hbmltYXRlU3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9fYW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24oIGxlZ2FjeSwgaXNDbGllbnQsIHdhcm4sIFByb21pc2UsIHByZWZpeCwgY3JlYXRlVHJhbnNpdGlvbnMsIHZpc2liaWxpdHkgKSB7XG5cblx0XHR2YXIgYW5pbWF0ZVN0eWxlLCBnZXRDb21wdXRlZFN0eWxlLCByZXNvbHZlZDtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGFuaW1hdGVTdHlsZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRcdGFuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uKCBzdHlsZSwgdmFsdWUsIG9wdGlvbnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdFx0dG87XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHBhZ2UgaXNuJ3QgdmlzaWJsZS4gRG9uJ3QgYW5pbWF0ZSBhbnl0aGluZywgYmVjYXVzZVxuXHRcdFx0XHQvLyB0aGF0IHdheSB5b3UnbGwgbmV2ZXIgZ2V0IENTUyB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdFx0XHRpZiAoIHZpc2liaWxpdHkuaGlkZGVuICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0U3R5bGUoIHN0eWxlLCB2YWx1ZSApO1xuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlZCB8fCAoIHJlc29sdmVkID0gUHJvbWlzZS5yZXNvbHZlKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dG8gPSB7fTtcblx0XHRcdFx0XHR0b1sgc3R5bGUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvID0gc3R5bGU7XG5cdFx0XHRcdFx0Ly8gc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnM7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEFzIG9mIDAuMy45LCB0cmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIHN1cHBseSBhbiBgb3B0aW9uYCBvYmplY3Qgd2l0aFxuXHRcdFx0XHQvLyBgZHVyYXRpb25gIGFuZCBgZWFzaW5nYCBwcm9wZXJ0aWVzIChhbmQgb3B0aW9uYWwgYGRlbGF5YCksIHBsdXMgYVxuXHRcdFx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG5cdFx0XHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gYSBmdXR1cmUgdmVyc2lvblxuXHRcdFx0XHRpZiAoICFvcHRpb25zICkge1xuXHRcdFx0XHRcdHdhcm4oICdUaGUgXCInICsgdC5uYW1lICsgJ1wiIHRyYW5zaXRpb24gZG9lcyBub3Qgc3VwcGx5IGFuIG9wdGlvbnMgb2JqZWN0IHRvIGB0LmFuaW1hdGVTdHlsZSgpYC4gVGhpcyB3aWxsIGJyZWFrIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3Vlcy8zNDAnICk7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHQ7XG5cdFx0XHRcdFx0Y29tcGxldGUgPSB0LmNvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCByZXNvbHZlICkge1xuXHRcdFx0XHRcdHZhciBwcm9wZXJ0eU5hbWVzLCBjaGFuZ2VkUHJvcGVydGllcywgY29tcHV0ZWRTdHlsZSwgY3VycmVudCwgZnJvbSwgaSwgcHJvcDtcblx0XHRcdFx0XHQvLyBFZGdlIGNhc2UgLSBpZiBkdXJhdGlvbiBpcyB6ZXJvLCBzZXQgc3R5bGUgc3luY2hyb25vdXNseSBhbmQgY29tcGxldGVcblx0XHRcdFx0XHRpZiAoICFvcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0XHRcdFx0dC5zZXRTdHlsZSggdG8gKTtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcblx0XHRcdFx0XHRwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMoIHRvICk7XG5cdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBzdHlsZXNcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdC5ub2RlICk7XG5cdFx0XHRcdFx0ZnJvbSA9IHt9O1xuXHRcdFx0XHRcdGkgPSBwcm9wZXJ0eU5hbWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0eU5hbWVzWyBpIF07XG5cdFx0XHRcdFx0XHRjdXJyZW50ID0gY29tcHV0ZWRTdHlsZVsgcHJlZml4KCBwcm9wICkgXTtcblx0XHRcdFx0XHRcdGlmICggY3VycmVudCA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnQgIT0gdG9bIHByb3AgXSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlICE9IGluc3RlYWQgb2YgIT09LCBzbyB3ZSBjYW4gY29tcGFyZSBzdHJpbmdzIHdpdGggbnVtYmVyc1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5wdXNoKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbXB1dGVkIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSBjYW4gYW5pbWF0ZSB3aGVyZVxuXHRcdFx0XHRcdFx0XHQvLyBlLmcuIGhlaWdodD0nYXV0bydcblx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gY3VycmVudDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuXHRcdFx0XHRcdC8vIHdpbGwgbmV2ZXIgZmlyZSEgU28gd2UgY29tcGxldGUgZWFybHlcblx0XHRcdFx0XHRpZiAoICFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zKCB0LCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHQvLyBJZiBhIGNhbGxiYWNrIHdhcyBzdXBwbGllZCwgZG8gdGhlIGhvbm91cnNcblx0XHRcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBmdXR1cmVcblx0XHRcdFx0aWYgKCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHR3YXJuKCAndC5hbmltYXRlU3R5bGUgcmV0dXJucyBhIFByb21pc2UgYXMgb2YgMC40LjAuIFRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgZG8gdC5hbmltYXRlU3R5bGUoLi4uKS50aGVuKGNhbGxiYWNrKScgKTtcblx0XHRcdFx0XHRwcm9taXNlLnRoZW4oIGNvbXBsZXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gYW5pbWF0ZVN0eWxlO1xuXHR9KCBsZWdhY3ksIGlzQ2xpZW50LCB3YXJuLCBQcm9taXNlLCBwcmVmaXgsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgKTtcblxuXHQvKiB1dGlscy9maWxsR2Fwcy5qcyAqL1xuXHR2YXIgZmlsbEdhcHMgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdHZhciBzb3VyY2VzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHRzb3VyY2VzLmZvckVhY2goIGZ1bmN0aW9uKCBzICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBzICkge1xuXHRcdFx0XHRpZiAoIHMuaGFzT3duUHJvcGVydHkoIGtleSApICYmICEoIGtleSBpbiB0YXJnZXQgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvcHJvY2Vzc1BhcmFtcy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kcHJvY2Vzc1BhcmFtcyA9IGZ1bmN0aW9uKCBmaWxsR2FwcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyYW1zLCBkZWZhdWx0cyApIHtcblx0XHRcdGlmICggdHlwZW9mIHBhcmFtcyA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRkdXJhdGlvbjogcGFyYW1zXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0aWYgKCBwYXJhbXMgPT09ICdzbG93JyApIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogNjAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyYW1zID09PSAnZmFzdCcgKSB7XG5cdFx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDIwMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDQwMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoICFwYXJhbXMgKSB7XG5cdFx0XHRcdHBhcmFtcyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZpbGxHYXBzKCB7fSwgcGFyYW1zLCBkZWZhdWx0cyApO1xuXHRcdH07XG5cdH0oIGZpbGxHYXBzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3N0YXJ0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzdGFydCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVHJhbnNpdGlvbiRzdGFydCgpIHtcblx0XHRcdHZhciB0ID0gdGhpcyxcblx0XHRcdFx0bm9kZSwgb3JpZ2luYWxTdHlsZSwgY29tcGxldGVkO1xuXHRcdFx0bm9kZSA9IHQubm9kZSA9IHQuZWxlbWVudC5ub2RlO1xuXHRcdFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG5cdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYHRoaXNgIHNpbGxpbmVzcyB3aGVuIHBhc3NpbmcgaXQgYXNcblx0XHRcdC8vIGFuIGFyZ3VtZW50XG5cdFx0XHR0LmNvbXBsZXRlID0gZnVuY3Rpb24oIG5vUmVzZXQgKSB7XG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFub1Jlc2V0ICYmIHQuaXNJbnRybyApIHtcblx0XHRcdFx0XHRyZXNldFN0eWxlKCBub2RlLCBvcmlnaW5hbFN0eWxlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5fcmFjdGl2ZS50cmFuc2l0aW9uID0gbnVsbDtcblx0XHRcdFx0dC5fbWFuYWdlci5yZW1vdmUoIHQgKTtcblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHQvLyBJZiB0aGUgdHJhbnNpdGlvbiBmdW5jdGlvbiBkb2Vzbid0IGV4aXN0LCBhYm9ydFxuXHRcdFx0aWYgKCAhdC5fZm4gKSB7XG5cdFx0XHRcdHQuY29tcGxldGUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dC5fZm4uYXBwbHkoIHQucm9vdCwgWyB0IF0uY29uY2F0KCB0LnBhcmFtcyApICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc2V0U3R5bGUoIG5vZGUsIHN0eWxlICkge1xuXHRcdFx0aWYgKCBzdHlsZSApIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoICdzdHlsZScsIHN0eWxlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBOZXh0IGxpbmUgaXMgbmVjZXNzYXJ5LCB0byByZW1vdmUgZW1wdHkgc3R5bGUgYXR0cmlidXRlIVxuXHRcdFx0XHQvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE2NzU1M1xuXHRcdFx0XHRub2RlLmdldEF0dHJpYnV0ZSggJ3N0eWxlJyApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZSggJ3N0eWxlJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9fVHJhbnNpdGlvbi5qcyAqL1xuXHR2YXIgVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBpbml0LCBnZXRTdHlsZSwgc2V0U3R5bGUsIGFuaW1hdGVTdHlsZSwgcHJvY2Vzc1BhcmFtcywgc3RhcnQsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBUcmFuc2l0aW9uO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBvd25lciwgdGVtcGxhdGUsIGlzSW50cm8gKSB7XG5cdFx0XHR0aGlzLmluaXQoIG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybyApO1xuXHRcdH07XG5cdFx0VHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0Z2V0U3R5bGU6IGdldFN0eWxlLFxuXHRcdFx0c2V0U3R5bGU6IHNldFN0eWxlLFxuXHRcdFx0YW5pbWF0ZVN0eWxlOiBhbmltYXRlU3R5bGUsXG5cdFx0XHRwcm9jZXNzUGFyYW1zOiBwcm9jZXNzUGFyYW1zXG5cdFx0fTtcblx0XHRyZXR1cm4gVHJhbnNpdGlvbjtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kZ2V0U3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHNldFN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfX2FuaW1hdGVTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kcHJvY2Vzc1BhcmFtcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc3RhcnQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZW5kZXIgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgaXNBcnJheSwgd2FybiwgY3JlYXRlLCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgbm9vcCwgcnVubG9vcCwgZ2V0SW5uZXJDb250ZXh0LCByZW5kZXJJbWFnZSwgVHJhbnNpdGlvbiApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgdXBkYXRlQ3NzLCB1cGRhdGVTY3JpcHQ7XG5cdFx0dXBkYXRlQ3NzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0Y29udGVudCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGZhbHNlICk7XG5cdFx0XHQvLyBJRTggaGFzIG5vIHN0eWxlU2hlZXQgdW5sZXNzIHRoZXJlJ3MgYSB0eXBlIHRleHQvY3NzXG5cdFx0XHRpZiAoIHdpbmRvdyAmJiB3aW5kb3cuYXBwZWFyc1RvQmVJRUxlc3NFcXVhbDggKSB7XG5cdFx0XHRcdG5vZGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUuc3R5bGVTaGVldCApIHtcblx0XHRcdFx0bm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCBub2RlLmhhc0NoaWxkTm9kZXMoKSApIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKCBub2RlLmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggY29udGVudCApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR1cGRhdGVTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMubm9kZS50eXBlIHx8IHRoaXMubm9kZS50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0JyApIHtcblx0XHRcdFx0d2FybiggJ1NjcmlwdCB0YWcgd2FzIHVwZGF0ZWQuIFRoaXMgZG9lcyBub3QgY2F1c2UgdGhlIGNvZGUgdG8gYmUgcmUtZXZhbHVhdGVkIScgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRWxlbWVudCRyZW5kZXIoKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciByb290ID0gdGhpcy5yb290LFxuXHRcdFx0XHRuYW1lc3BhY2UsIG5vZGU7XG5cdFx0XHRuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UoIHRoaXMgKTtcblx0XHRcdG5vZGUgPSB0aGlzLm5vZGUgPSBjcmVhdGVFbGVtZW50KCB0aGlzLm5hbWUsIG5hbWVzcGFjZSApO1xuXHRcdFx0Ly8gSXMgdGhpcyBhIHRvcC1sZXZlbCBub2RlIG9mIGEgY29tcG9uZW50PyBJZiBzbywgd2UgbWF5IG5lZWQgdG8gYWRkXG5cdFx0XHQvLyBhIGRhdGEtcnZjZ3VpZCBhdHRyaWJ1dGUsIGZvciBDU1MgZW5jYXBzdWxhdGlvblxuXHRcdFx0Ly8gTk9URTogY3NzIG5vIGxvbmdlciBjb3BpZWQgdG8gaW5zdGFuY2UsIHNvIHdlIGNoZWNrIGNvbnN0cnVjdG9yLmNzcyAtXG5cdFx0XHQvLyB3ZSBjYW4gZW5oYW5jZSB0byBoYW5kbGUgaW5zdGFuY2UsIGJ1dCB0aGlzIGlzIG1vcmUgXCJjb3JyZWN0XCIgd2l0aCBjdXJyZW50XG5cdFx0XHQvLyBmdW5jdGlvbmFsaXR5XG5cdFx0XHRpZiAoIHJvb3QuY29uc3RydWN0b3IuY3NzICYmIHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpID09PSByb290LmVsICkge1xuXHRcdFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCAnZGF0YS1ydmNndWlkJywgcm9vdC5jb25zdHJ1Y3Rvci5fZ3VpZCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIF9yYWN0aXZlIHByb3BlcnR5IHRvIHRoZSBub2RlIC0gd2UgdXNlIHRoaXMgb2JqZWN0IHRvIHN0b3JlIHN0dWZmXG5cdFx0XHQvLyByZWxhdGVkIHRvIHByb3h5IGV2ZW50cywgdHdvLXdheSBiaW5kaW5ncyBldGNcblx0XHRcdGRlZmluZVByb3BlcnR5KCB0aGlzLm5vZGUsICdfcmFjdGl2ZScsIHtcblx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRwcm94eTogdGhpcyxcblx0XHRcdFx0XHRrZXlwYXRoOiBnZXRJbm5lckNvbnRleHQoIHRoaXMucGFyZW50RnJhZ21lbnQgKSxcblx0XHRcdFx0XHRpbmRleDogdGhpcy5wYXJlbnRGcmFnbWVudC5pbmRleFJlZnMsXG5cdFx0XHRcdFx0ZXZlbnRzOiBjcmVhdGUoIG51bGwgKSxcblx0XHRcdFx0XHRyb290OiByb290XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdC8vIFJlbmRlciBhdHRyaWJ1dGVzXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdHJldHVybiBhLnJlbmRlciggbm9kZSApO1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdHJldHVybiBhLnJlbmRlciggbm9kZSApO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gUmVuZGVyIGNoaWxkcmVuXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzY3JpcHQ+IGVsZW1lbnRcblx0XHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdzY3JpcHQnICkge1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlU2NyaXB0O1xuXHRcdFx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHRcdFx0XHQvLyBieXBhc3Mgd2FybmluZyBpbml0aWFsbHlcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5uYW1lID09PSAnc3R5bGUnICkge1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlQ3NzO1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuYmluZGluZyAmJiB0aGlzLmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoIHRoaXMuZnJhZ21lbnQucmVuZGVyKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIHByb3h5IGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBoICkge1xuXHRcdFx0XHRcdHJldHVybiBoLnJlbmRlcigpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWFsIHdpdGggdHdvLXdheSBiaW5kaW5nc1xuXHRcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy5yZW5kZXIoKTtcblx0XHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2U6IGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5XG5cdFx0XHQvLyBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2ltZycgKSB7XG5cdFx0XHRcdHJlbmRlckltYWdlKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhcHBseSBkZWNvcmF0b3Iocylcblx0XHRcdGlmICggdGhpcy5kZWNvcmF0b3IgJiYgdGhpcy5kZWNvcmF0b3IuZm4gKSB7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmRlY29yYXRvci5pbml0KCk7XG5cdFx0XHRcdH0sIHRydWUgKTtcblx0XHRcdH1cblx0XHRcdC8vIHRyaWdnZXIgaW50cm8gdHJhbnNpdGlvblxuXHRcdFx0aWYgKCByb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLmludHJvICkge1xuXHRcdFx0XHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKCB0aGlzLCB0aGlzLmludHJvLCB0cnVlICk7XG5cdFx0XHRcdHJ1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuXHRcdFx0XHR9LCB0cnVlICk7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdHByb2Nlc3NPcHRpb24oIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ub2RlLmF1dG9mb2N1cyApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlLiBTb21lIGJyb3dzZXJzICgqY291Z2gqIEZpcmVmaXggKmNvdWdoKikgaGF2ZSBhIHByb2JsZW1cblx0XHRcdFx0Ly8gd2l0aCBkeW5hbWljYWxseS1nZW5lcmF0ZWQgZWxlbWVudHMgaGF2aW5nIGF1dG9mb2N1cywgYW5kIHRoZXkgd29uJ3Rcblx0XHRcdFx0Ly8gYWxsb3cgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgZm9jdXMgdGhlIGVsZW1lbnQgdW50aWwgaXQncyBpbiB0aGUgRE9NXG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLm5vZGUuZm9jdXMoKTtcblx0XHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldE5hbWVzcGFjZSggZWxlbWVudCApIHtcblx0XHRcdHZhciBuYW1lc3BhY2UsIHhtbG5zLCBwYXJlbnQ7XG5cdFx0XHQvLyBVc2Ugc3BlY2lmaWVkIG5hbWVzcGFjZS4uLlxuXHRcdFx0aWYgKCB4bWxucyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAneG1sbnMnICkgKSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IHhtbG5zO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnc3ZnJyApIHtcblx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5zdmc7XG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCApIHtcblx0XHRcdFx0Ly8gLi4ub3IgSFRNTCwgaWYgdGhlIHBhcmVudCBpcyBhIDxmb3JlaWduT2JqZWN0PlxuXHRcdFx0XHRpZiAoIHBhcmVudC5uYW1lID09PSAnZm9yZWlnbk9iamVjdCcgKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5odG1sO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmFtZXNwYWNlID0gZWxlbWVudC5yb290LmVsLm5hbWVzcGFjZVVSSTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYW1lc3BhY2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc09wdGlvbiggb3B0aW9uICkge1xuXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblx0XHRcdGlmICggIW9wdGlvbi5zZWxlY3QgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGVjdFZhbHVlID0gb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3Qubm9kZS5tdWx0aXBsZSAmJiBpc0FycmF5KCBzZWxlY3RWYWx1ZSApICkge1xuXHRcdFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gb3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlTGl2ZVF1ZXJpZXMoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UsIGxpdmVRdWVyaWVzLCBpLCBzZWxlY3RvciwgcXVlcnk7XG5cdFx0XHQvLyBEb2VzIHRoaXMgbmVlZCB0byBiZSBhZGRlZCB0byBhbnkgbGl2ZSBxdWVyaWVzP1xuXHRcdFx0aW5zdGFuY2UgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXHRcdFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRzZWxlY3RvciA9IGxpdmVRdWVyaWVzWyBpIF07XG5cdFx0XHRcdFx0cXVlcnkgPSBsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXTtcblx0XHRcdFx0XHRpZiAoIHF1ZXJ5Ll90ZXN0KCBlbGVtZW50ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBrZWVwIHJlZ2lzdGVyIG9mIGFwcGxpY2FibGUgc2VsZWN0b3JzLCBmb3Igd2hlbiB3ZSB0ZWFyZG93blxuXHRcdFx0XHRcdFx0KCBlbGVtZW50LmxpdmVRdWVyaWVzIHx8ICggZWxlbWVudC5saXZlUXVlcmllcyA9IFtdICkgKS5wdXNoKCBxdWVyeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGluc3RhbmNlID0gaW5zdGFuY2UuX3BhcmVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIG5hbWVzcGFjZXMsIGlzQXJyYXksIHdhcm4sIGNyZWF0ZSwgY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIG5vb3AsIHJ1bmxvb3AsIGdldElubmVyQ29udGV4dCwgcmVuZGVyLCBUcmFuc2l0aW9uICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHRvU3RyaW5nID0gZnVuY3Rpb24oIHZvaWRFbGVtZW50TmFtZXMsIGlzQXJyYXksIGVzY2FwZUh0bWwgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdHIsIGVzY2FwZTtcblx0XHRcdHN0ciA9ICc8JyArICggdGhpcy50ZW1wbGF0ZS55ID8gJyFET0NUWVBFJyA6IHRoaXMudGVtcGxhdGUuZSApO1xuXHRcdFx0c3RyICs9IHRoaXMuYXR0cmlidXRlcy5tYXAoIHN0cmluZ2lmeUF0dHJpYnV0ZSApLmpvaW4oICcnICkgKyB0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5tYXAoIHN0cmluZ2lmeUF0dHJpYnV0ZSApLmpvaW4oICcnICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgJiYgb3B0aW9uSXNTZWxlY3RlZCggdGhpcyApICkge1xuXHRcdFx0XHRzdHIgKz0gJyBzZWxlY3RlZCc7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB0d28td2F5IHJhZGlvIG5hbWUgYmluZGluZ3Ncblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaW5wdXQnICYmIGlucHV0SXNDaGVja2VkUmFkaW8oIHRoaXMgKSApIHtcblx0XHRcdFx0c3RyICs9ICcgY2hlY2tlZCc7XG5cdFx0XHR9XG5cdFx0XHRzdHIgKz0gJz4nO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gdGV4dGFyZWFcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAndGV4dGFyZWEnICYmIHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c3RyICs9IGVzY2FwZUh0bWwoIHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHN0ciArPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRlc2NhcGUgPSB0aGlzLm5hbWUgIT09ICdzY3JpcHQnICYmIHRoaXMubmFtZSAhPT0gJ3N0eWxlJztcblx0XHRcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGEgY2xvc2luZyB0YWcgaWYgdGhpcyBpc24ndCBhIHZvaWQgZWxlbWVudFxuXHRcdFx0aWYgKCAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KCB0aGlzLnRlbXBsYXRlLmUgKSApIHtcblx0XHRcdFx0c3RyICs9ICc8LycgKyB0aGlzLnRlbXBsYXRlLmUgKyAnPic7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBvcHRpb25Jc1NlbGVjdGVkKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblx0XHRcdG9wdGlvblZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhZWxlbWVudC5zZWxlY3QgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgJiYgaXNBcnJheSggc2VsZWN0VmFsdWUgKSApIHtcblx0XHRcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RWYWx1ZVsgaSBdID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5wdXRJc0NoZWNrZWRSYWRpbyggZWxlbWVudCApIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzLCB0eXBlQXR0cmlidXRlLCB2YWx1ZUF0dHJpYnV0ZSwgbmFtZUF0dHJpYnV0ZTtcblx0XHRcdGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cdFx0XHR0eXBlQXR0cmlidXRlID0gYXR0cmlidXRlcy50eXBlO1xuXHRcdFx0dmFsdWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnZhbHVlO1xuXHRcdFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblx0XHRcdGlmICggIXR5cGVBdHRyaWJ1dGUgfHwgdHlwZUF0dHJpYnV0ZS52YWx1ZSAhPT0gJ3JhZGlvJyB8fCAhdmFsdWVBdHRyaWJ1dGUgfHwgIW5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlQXR0cmlidXRlLnZhbHVlID09PSBuYW1lQXR0cmlidXRlLmludGVycG9sYXRvci52YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gc3RyID8gJyAnICsgc3RyIDogJyc7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdm9pZEVsZW1lbnROYW1lcywgaXNBcnJheSwgZXNjYXBlSHRtbCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL29wdGlvbi91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9zcGVjaWFsX29wdGlvbl91bmJpbmQgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVuYmluZE9wdGlvbiggb3B0aW9uICkge1xuXHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIG9wdGlvbi5zZWxlY3Qub3B0aW9ucywgb3B0aW9uICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bmJpbmQgPSBmdW5jdGlvbiggdW5iaW5kT3B0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRWxlbWVudCR1bmJpbmQoKSB7XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+XG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdHVuYmluZE9wdGlvbiggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggeCApIHtcblx0XHRcdHgudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X3NwZWNpYWxfb3B0aW9uX3VuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bnJlbmRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBUcmFuc2l0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRWxlbWVudCR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdHZhciBiaW5kaW5nLCBiaW5kaW5ncztcblx0XHRcdGlmICggdGhpcy50cmFuc2l0aW9uICkge1xuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb24uY29tcGxldGUoKTtcblx0XHRcdH1cblx0XHRcdC8vIERldGFjaCBhcyBzb29uIGFzIHdlIGNhblxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHQvLyA8b3B0aW9uPiBlbGVtZW50cyBkZXRhY2ggaW1tZWRpYXRlbHksIHNvIHRoYXRcblx0XHRcdFx0Ly8gdGhlaXIgcGFyZW50IDxzZWxlY3Q+IGVsZW1lbnQgc3luY3MgY29ycmVjdGx5LCBhbmRcblx0XHRcdFx0Ly8gc2luY2Ugb3B0aW9uIGVsZW1lbnRzIGNhbid0IGhhdmUgdHJhbnNpdGlvbnMgYW55d2F5XG5cdFx0XHRcdHRoaXMuZGV0YWNoKCk7XG5cdFx0XHR9IGVsc2UgaWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRydW5sb29wLmRldGFjaFdoZW5SZWFkeSggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2hpbGRyZW4gZmlyc3QuIHRoYXQgd2F5LCBhbnkgdHJhbnNpdGlvbnMgb24gY2hpbGQgZWxlbWVudHMgd2lsbCBiZVxuXHRcdFx0Ly8gaGFuZGxlZCBieSB0aGUgY3VycmVudCB0cmFuc2l0aW9uTWFuYWdlclxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcudW5yZW5kZXIoKTtcblx0XHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSBudWxsO1xuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdO1xuXHRcdFx0XHRiaW5kaW5ncy5zcGxpY2UoIGJpbmRpbmdzLmluZGV4T2YoIGJpbmRpbmcgKSwgMSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBoICkge1xuXHRcdFx0XHRcdHJldHVybiBoLnVucmVuZGVyKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZWNvcmF0b3IgKSB7XG5cdFx0XHRcdHRoaXMuZGVjb3JhdG9yLnRlYXJkb3duKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0cmlnZ2VyIG91dHJvIHRyYW5zaXRpb24gaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoIHRoaXMucm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5vdXRybyApIHtcblx0XHRcdFx0dmFyIHRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbiggdGhpcywgdGhpcy5vdXRybywgZmFsc2UgKTtcblx0XHRcdFx0cnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24oIHRyYW5zaXRpb24gKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBhbnkgbGl2ZSBxdWVyaWVzXG5cdFx0XHRpZiAoIHRoaXMubGl2ZVF1ZXJpZXMgKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21MaXZlUXVlcmllcyggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZVF1ZXJpZXMoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgcXVlcnksIHNlbGVjdG9yLCBpO1xuXHRcdFx0aSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdHF1ZXJ5ID0gZWxlbWVudC5saXZlUXVlcmllc1sgaSBdO1xuXHRcdFx0XHRzZWxlY3RvciA9IHF1ZXJ5LnNlbGVjdG9yO1xuXHRcdFx0XHRxdWVyeS5fcmVtb3ZlKCBlbGVtZW50Lm5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBydW5sb29wLCBUcmFuc2l0aW9uICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L19FbGVtZW50LmpzICovXG5cdHZhciBFbGVtZW50ID0gZnVuY3Rpb24oIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIGdldEF0dHJpYnV0ZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIEVsZW1lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0RWxlbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0cmV0dXJuIEVsZW1lbnQ7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGdldEF0dHJpYnV0ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2RlSW5kZW50LmpzICovXG5cdHZhciBkZUluZGVudCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBlbXB0eSA9IC9eXFxzKiQvLFxuXHRcdFx0bGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBsaW5lcywgZmlyc3RMaW5lLCBsYXN0TGluZSwgbWluSW5kZW50O1xuXHRcdFx0bGluZXMgPSBzdHIuc3BsaXQoICdcXG4nICk7XG5cdFx0XHQvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbGluZSwgaWYgdGhleSBvbmx5IGNvbnRhaW4gd2hpdGVzcGFjZVxuXHRcdFx0Zmlyc3RMaW5lID0gbGluZXNbIDAgXTtcblx0XHRcdGlmICggZmlyc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZW1wdHkudGVzdCggZmlyc3RMaW5lICkgKSB7XG5cdFx0XHRcdGxpbmVzLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0XHRsYXN0TGluZSA9IGxpbmVzWyBsaW5lcy5sZW5ndGggLSAxIF07XG5cdFx0XHRpZiAoIGxhc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZW1wdHkudGVzdCggbGFzdExpbmUgKSApIHtcblx0XHRcdFx0bGluZXMucG9wKCk7XG5cdFx0XHR9XG5cdFx0XHRtaW5JbmRlbnQgPSBsaW5lcy5yZWR1Y2UoIHJlZHVjZXIsIG51bGwgKTtcblx0XHRcdGlmICggbWluSW5kZW50ICkge1xuXHRcdFx0XHRzdHIgPSBsaW5lcy5tYXAoIGZ1bmN0aW9uKCBsaW5lICkge1xuXHRcdFx0XHRcdHJldHVybiBsaW5lLnJlcGxhY2UoIG1pbkluZGVudCwgJycgKTtcblx0XHRcdFx0fSApLmpvaW4oICdcXG4nICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2VyKCBwcmV2aW91cywgbGluZSApIHtcblx0XHRcdHZhciBsaW5lSW5kZW50ID0gbGVhZGluZ1doaXRlc3BhY2UuZXhlYyggbGluZSApWyAwIF07XG5cdFx0XHRpZiAoIHByZXZpb3VzID09PSBudWxsIHx8IGxpbmVJbmRlbnQubGVuZ3RoIDwgcHJldmlvdXMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gbGluZUluZGVudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcmV2aW91cztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2dldFBhcnRpYWxUZW1wbGF0ZS5qcyAqL1xuXHR2YXIgZ2V0UGFydGlhbFRlbXBsYXRlID0gZnVuY3Rpb24oIGxvZywgY29uZmlnLCBwYXJzZXIsIGRlSW5kZW50ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZ2V0UGFydGlhbFRlbXBsYXRlKCByYWN0aXZlLCBuYW1lICkge1xuXHRcdFx0dmFyIHBhcnRpYWw7XG5cdFx0XHQvLyBJZiB0aGUgcGFydGlhbCBpbiBpbnN0YW5jZSBvciB2aWV3IGhlaXJhcmNoeSBpbnN0YW5jZXMsIGdyZWF0XG5cdFx0XHRpZiAoIHBhcnRpYWwgPSBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KCByYWN0aXZlLCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJ0aWFsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRG9lcyBpdCBleGlzdCBvbiB0aGUgcGFnZSBhcyBhIHNjcmlwdCB0YWc/XG5cdFx0XHRwYXJ0aWFsID0gcGFyc2VyLmZyb21JZCggbmFtZSwge1xuXHRcdFx0XHRub1Rocm93OiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIHBhcnRpYWwgKSB7XG5cdFx0XHRcdC8vIGlzIHRoaXMgbmVjZXNzYXJ5P1xuXHRcdFx0XHRwYXJ0aWFsID0gZGVJbmRlbnQoIHBhcnRpYWwgKTtcblx0XHRcdFx0Ly8gcGFyc2UgYW5kIHJlZ2lzdGVyIHRvIHRoaXMgcmFjdGl2ZSBpbnN0YW5jZVxuXHRcdFx0XHR2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKCBwYXJ0aWFsLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdFx0Ly8gcmVnaXN0ZXIgKGFuZCByZXR1cm4gbWFpbiBwYXJ0aWFsIGlmIHRoZXJlIGFyZSBvdGhlcnMgaW4gdGhlIHRlbXBsYXRlKVxuXHRcdFx0XHRyZXR1cm4gcmFjdGl2ZS5wYXJ0aWFsc1sgbmFtZSBdID0gcGFyc2VkLnQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcGFydGlhbHMgPSBjb25maWcucmVnaXN0cmllcy5wYXJ0aWFscztcblx0XHRcdC8vIGZpbmQgZmlyc3QgaW5zdGFuY2UgaW4gdGhlIHJhY3RpdmUgb3IgdmlldyBoaWVyYXJjaHkgdGhhdCBoYXMgdGhpcyBwYXJ0aWFsXG5cdFx0XHR2YXIgaW5zdGFuY2UgPSBwYXJ0aWFscy5maW5kSW5zdGFuY2UoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFydGlhbCA9IGluc3RhbmNlLnBhcnRpYWxzWyBuYW1lIF0sXG5cdFx0XHRcdGZuO1xuXHRcdFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Zm4gPSBwYXJ0aWFsLmJpbmQoIGluc3RhbmNlICk7XG5cdFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApO1xuXHRcdFx0XHRwYXJ0aWFsID0gZm4oIGluc3RhbmNlLmRhdGEsIHBhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcGFydGlhbCApIHtcblx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRyZWdpc3RyeTogJ3BhcnRpYWwnLFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhZGRlZCBtYW51YWxseSB0byB0aGUgcmVnaXN0cnksXG5cdFx0XHQvLyBidXQgaGFzbid0IGJlZW4gcGFyc2VkLCBwYXJzZSBpdCBub3dcblx0XHRcdGlmICggIXBhcnNlci5pc1BhcnNlZCggcGFydGlhbCApICkge1xuXHRcdFx0XHQvLyB1c2UgdGhlIHBhcnNlT3B0aW9ucyBvZiB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBvbiB3aGljaCBpdCB3YXMgZm91bmRcblx0XHRcdFx0dmFyIHBhcnNlZCA9IHBhcnNlci5wYXJzZSggcGFydGlhbCwgcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggaW5zdGFuY2UgKSApO1xuXHRcdFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG5cdFx0XHRcdC8vIFRPRE8gYWRkIGEgdGVzdCBmb3IgdGhpc1xuXHRcdFx0XHRpZiAoIHBhcnNlZC5wICkge1xuXHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub05lc3RlZFBhcnRpYWxzJyxcblx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0cm5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgZm4sIHVzZSBpbnN0YW5jZSB0byBzdG9yZSByZXN1bHQsIG90aGVyd2lzZSBuZWVkcyB0byBnb1xuXHRcdFx0XHQvLyBpbiB0aGUgY29ycmVjdCBwb2ludCBpbiBwcm90b3R5cGUgY2hhaW4gb24gaW5zdGFuY2Ugb3IgY29uc3RydWN0b3Jcblx0XHRcdFx0dmFyIHRhcmdldCA9IGZuID8gaW5zdGFuY2UgOiBwYXJ0aWFscy5maW5kT3duZXIoIGluc3RhbmNlLCBuYW1lICk7XG5cdFx0XHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcblx0XHRcdFx0dGFyZ2V0LnBhcnRpYWxzWyBuYW1lIF0gPSBwYXJ0aWFsID0gcGFyc2VkLnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSBmb3IgcmVzZXRcblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdHBhcnRpYWwuX2ZuID0gZm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFydGlhbC52ID8gcGFydGlhbC50IDogcGFydGlhbDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBsb2csIGNvbmZpZywgcGFyc2VyLCBkZUluZGVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9hcHBseUluZGVudC5qcyAqL1xuXHR2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiggc3RyaW5nLCBpbmRlbnQgKSB7XG5cdFx0dmFyIGluZGVudGVkO1xuXHRcdGlmICggIWluZGVudCApIHtcblx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0fVxuXHRcdGluZGVudGVkID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApLm1hcCggZnVuY3Rpb24oIGxpbmUsIG5vdEZpcnN0TGluZSApIHtcblx0XHRcdHJldHVybiBub3RGaXJzdExpbmUgPyBpbmRlbnQgKyBsaW5lIDogbGluZTtcblx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRyZXR1cm4gaW5kZW50ZWQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL19QYXJ0aWFsLmpzICovXG5cdHZhciBQYXJ0aWFsID0gZnVuY3Rpb24oIGxvZywgdHlwZXMsIGdldFBhcnRpYWxUZW1wbGF0ZSwgYXBwbHlJbmRlbnQsIGNpcmN1bGFyLCBydW5sb29wLCBNdXN0YWNoZSwgcmViaW5kLCB1bmJpbmQgKSB7XG5cblx0XHR2YXIgUGFydGlhbCwgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRQYXJ0aWFsID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5QQVJUSUFMO1xuXHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLnI7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuXHRcdFx0TXVzdGFjaGUuaW5pdCggdGhpcywgb3B0aW9ucyApO1xuXHRcdFx0Ly8gSWYgdGhpcyBkaWRuJ3QgcmVzb2x2ZSwgaXQgbW9zdCBsaWtlbHkgbWVhbnMgd2UgaGF2ZSBhIG5hbWVkIHBhcnRpYWxcblx0XHRcdC8vIChpLmUuIGB7ez5mb299fWAgbWVhbnMgJ3VzZSB0aGUgZm9vIHBhcnRpYWwnLCBub3QgJ3VzZSB0aGUgcGFydGlhbFxuXHRcdFx0Ly8gd2hvc2UgbmFtZSBpcyB0aGUgdmFsdWUgb2YgYGZvb2AnKVxuXHRcdFx0aWYgKCAhdGhpcy5rZXlwYXRoICYmICggdGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGUoIHRoaXMucm9vdCwgdGhpcy5uYW1lICkgKSApIHtcblx0XHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0Ly8gcHJldmVudCBhbnkgZnVydGhlciBjaGFuZ2VzXG5cdFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUoIHRlbXBsYXRlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXJ0aWFsLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZGV0YWNoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGw6IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdFx0fSxcblx0XHRcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHJlYmluZC5jYWxsKCB0aGlzLCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG5cdFx0XHR9LFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID09PSB0aGlzLnZhbHVlICkge1xuXHRcdFx0XHRcdC8vIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHNvIG5vIHdvcmsgdG8gYmUgZG9uZVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yb290LCAnJyArIHZhbHVlICk7XG5cdFx0XHRcdC8vIHdlIG1heSBiZSBoZXJlIGlmIHdlIGhhdmUgYSBwYXJ0aWFsIGxpa2UgYHt7PmZvb319YCBhbmQgYGZvb2AgaXMgdGhlXG5cdFx0XHRcdC8vIG5hbWUgb2YgYm90aCBhIGRhdGEgcHJvcGVydHkgKHdob3NlIHZhbHVlIElTTidUIHRoZSBuYW1lIG9mIGEgcGFydGlhbClcblx0XHRcdFx0Ly8gYW5kIGEgcGFydGlhbC4gSW4gdGhvc2UgY2FzZXMsIHRoaXMgYmVjb21lcyBhIG5hbWVkIHBhcnRpYWxcblx0XHRcdFx0aWYgKCAhdGVtcGxhdGUgJiYgdGhpcy5uYW1lICYmICggdGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGUoIHRoaXMucm9vdCwgdGhpcy5uYW1lICkgKSApIHtcblx0XHRcdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhdGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5yb290LmRlYnVnLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogJ25vVGVtcGxhdGVGb3JQYXJ0aWFsJyxcblx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0bmFtZTogdGhpcy5uYW1lXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUoIHRlbXBsYXRlIHx8IFtdICk7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VGVtcGxhdGU6IGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzLnBhcmVudEZyYWdtZW50LnBFbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudDtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIHRvU3RyaW5nICkge1xuXHRcdFx0XHR2YXIgc3RyaW5nLCBwcmV2aW91c0l0ZW0sIGxhc3RMaW5lLCBtYXRjaDtcblx0XHRcdFx0c3RyaW5nID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggdG9TdHJpbmcgKTtcblx0XHRcdFx0cHJldmlvdXNJdGVtID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtc1sgdGhpcy5pbmRleCAtIDEgXTtcblx0XHRcdFx0aWYgKCAhcHJldmlvdXNJdGVtIHx8IHByZXZpb3VzSXRlbS50eXBlICE9PSB0eXBlcy5URVhUICkge1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGV4dC5zcGxpdCggJ1xcbicgKS5wb3AoKTtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IC9eXFxzKyQvLmV4ZWMoIGxhc3RMaW5lICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFwcGx5SW5kZW50KCBzdHJpbmcsIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuaXNOYW1lZCApIHtcblx0XHRcdFx0XHQvLyBkeW5hbWljIHBhcnRpYWwgLSBuZWVkIHRvIHVuYmluZCBzZWxmXG5cdFx0XHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRhcmdldCwgYW5jaG9yO1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyLnVucmVuZGVyKCB0cnVlICk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudFRvUmVuZGVyICkge1xuXHRcdFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudFRvUmVuZGVyLnJlbmRlcigpICk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0XHRcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIGFuY2hvciApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gUGFydGlhbDtcblx0fSggbG9nLCB0eXBlcywgZ2V0UGFydGlhbFRlbXBsYXRlLCBhcHBseUluZGVudCwgY2lyY3VsYXIsIHJ1bmxvb3AsIE11c3RhY2hlLCByZWJpbmQsIHVuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2dldENvbXBvbmVudC5qcyAqL1xuXHR2YXIgZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24oIGNvbmZpZywgbG9nLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBSYWN0aXZlO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0UmFjdGl2ZSA9IGNpcmN1bGFyLlJhY3RpdmU7XG5cdFx0fSApO1xuXHRcdC8vIGZpbmRzIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgaW4gdGhlIHJlZ2lzdHJ5IG9yIHZpZXcgaGllcmFyY2h5IHJlZ2lzdHJpZXNcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0Q29tcG9uZW50KCByYWN0aXZlLCBuYW1lICkge1xuXHRcdFx0dmFyIGNvbXBvbmVudCwgaW5zdGFuY2UgPSBjb25maWcucmVnaXN0cmllcy5jb21wb25lbnRzLmZpbmRJbnN0YW5jZSggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0Y29tcG9uZW50ID0gaW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdO1xuXHRcdFx0XHQvLyBiZXN0IHRlc3Qgd2UgaGF2ZSBmb3Igbm90IFJhY3RpdmUuZXh0ZW5kXG5cdFx0XHRcdGlmICggIWNvbXBvbmVudC5fcGFyZW50ICkge1xuXHRcdFx0XHRcdC8vIGZ1bmN0aW9uIG9wdGlvbiwgZXhlY3V0ZSBhbmQgc3RvcmUgZm9yIHJlc2V0XG5cdFx0XHRcdFx0dmFyIGZuID0gY29tcG9uZW50LmJpbmQoIGluc3RhbmNlICk7XG5cdFx0XHRcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkoIG5hbWUgKTtcblx0XHRcdFx0XHRjb21wb25lbnQgPSBmbiggaW5zdGFuY2UuZGF0YSApO1xuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHJlZ2lzdHJ5OiAnY29tcG9uZW50Jyxcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdC8vYWxsb3cgc3RyaW5nIGxvb2t1cFxuXHRcdFx0XHRcdFx0Y29tcG9uZW50ID0gZ2V0Q29tcG9uZW50KCByYWN0aXZlLCBjb21wb25lbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tcG9uZW50Ll9mbiA9IGZuO1xuXHRcdFx0XHRcdGluc3RhbmNlLmNvbXBvbmVudHNbIG5hbWUgXSA9IGNvbXBvbmVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbXBvbmVudDtcblx0XHR9O1xuXHR9KCBjb25maWcsIGxvZywgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRkZXRhY2ggPSBmdW5jdGlvbiggSG9vayApIHtcblxuXHRcdHZhciBkZXRhY2hIb29rID0gbmV3IEhvb2soICdkZXRhY2gnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRkZXRhY2goKSB7XG5cdFx0XHR2YXIgZGV0YWNoZWQgPSB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuXHRcdFx0ZGV0YWNoSG9vay5maXJlKCB0aGlzLmluc3RhbmNlICk7XG5cdFx0XHRyZXR1cm4gZGV0YWNoZWQ7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vayApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGwgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRxdWVyeS5fdGVzdCggdGhpcywgdHJ1ZSApO1xuXHRcdGlmICggdGhpcy5pbnN0YW5jZS5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHRpZiAoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gdGhpcy5uYW1lICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pbnN0YW5jZS5mcmFnbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kTmV4dE5vZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVNb2RlbC9Db21wb25lbnRQYXJhbWV0ZXIuanMgKi9cblx0dmFyIENvbXBvbmVudFBhcmFtZXRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgQ29tcG9uZW50UGFyYW1ldGVyO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0Q29tcG9uZW50UGFyYW1ldGVyID0gZnVuY3Rpb24oIGNvbXBvbmVudCwga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0XHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdmFsdWUsXG5cdFx0XHRcdHJvb3Q6IGNvbXBvbmVudC5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHR9O1xuXHRcdENvbXBvbmVudFBhcmFtZXRlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuXHRcdFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0XHR0aGlzLmNvbXBvbmVudC5pbnN0YW5jZS52aWV3bW9kZWwuc2V0KCB0aGlzLmtleSwgdmFsdWUgKTtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbXBvbmVudFBhcmFtZXRlcjtcblx0fSggcnVubG9vcCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL1JlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIuanMgKi9cblx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIgPSBmdW5jdGlvbiggUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIgPSBmdW5jdGlvbiggY29tcG9uZW50LCBjaGlsZEtleXBhdGgsIHRlbXBsYXRlLCB0b0JpbmQgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHRoaXMucm9vdCA9IGNvbXBvbmVudC5yb290O1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVhZHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuaGFzaCA9IG51bGw7XG5cdFx0XHR0aGlzLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciggdGhpcywgdGVtcGxhdGUsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHQvLyBBcmUgd2UgdXBkYXRpbmcgYW4gZXhpc3RpbmcgYmluZGluZz9cblx0XHRcdFx0aWYgKCB0aGlzJDAuYmluZGluZyB8fCAoIHRoaXMkMC5iaW5kaW5nID0gY29tcG9uZW50LmJpbmRpbmdzWyB0aGlzJDAuaGFzaCBdICkgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmJpbmRpbmdzWyB0aGlzJDAuaGFzaCBdID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzJDAuYmluZGluZy5yZWJpbmQoIGtleXBhdGggKTtcblx0XHRcdFx0XHR0aGlzJDAuaGFzaCA9IGtleXBhdGggKyAnPScgKyBjaGlsZEtleXBhdGg7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmJpbmRpbmdzWyB0aGlzJDAuaGFzaCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggIXRoaXMkMC5yZWFkeSApIHtcblx0XHRcdFx0XHRcdC8vIFRoZSBjaGlsZCBpbnN0YW5jZSBpc24ndCBjcmVhdGVkIHlldCwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIGJpbmRpbmcgbGF0ZXJcblx0XHRcdFx0XHRcdHRvQmluZC5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkS2V5cGF0aDogY2hpbGRLZXlwYXRoLFxuXHRcdFx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoOiBrZXlwYXRoXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIGNvbXBvbmVudCwgY29tcG9uZW50LnJvb3QsIGtleXBhdGgsIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzJDAudmFsdWUgPSBjb21wb25lbnQucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlcjtcblx0fSggUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVNb2RlbC9fY3JlYXRlTW9kZWwuanMgKi9cblx0dmFyIGNyZWF0ZU1vZGVsID0gZnVuY3Rpb24oIHR5cGVzLCBwYXJzZUpTT04sIHJlc29sdmVSZWYsIENvbXBvbmVudFBhcmFtZXRlciwgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBjb21wb25lbnQsIGRlZmF1bHREYXRhLCBhdHRyaWJ1dGVzLCB0b0JpbmQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHt9LFxuXHRcdFx0XHRrZXksIHZhbHVlO1xuXHRcdFx0Ly8gc29tZSBwYXJhbWV0ZXJzLCBlLmcuIGZvbz1cIlRoZSB2YWx1ZSBpcyB7e2Jhcn19XCIsIGFyZSAnY29tcGxleCcgLSBpblxuXHRcdFx0Ly8gb3RoZXIgd29yZHMsIHdlIG5lZWQgdG8gY29uc3RydWN0IGEgc3RyaW5nIGZyYWdtZW50IHRvIHdhdGNoXG5cdFx0XHQvLyB3aGVuIHRoZXkgY2hhbmdlLiBXZSBzdG9yZSB0aGVzZSBzbyB0aGV5IGNhbiBiZSB0b3JuIGRvd24gbGF0ZXJcblx0XHRcdGNvbXBvbmVudC5jb21wbGV4UGFyYW1ldGVycyA9IFtdO1xuXHRcdFx0Zm9yICgga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBnZXRWYWx1ZSggY29tcG9uZW50LCBrZXksIGF0dHJpYnV0ZXNbIGtleSBdLCB0b0JpbmQgKTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgfHwgZGVmYXVsdERhdGFbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRkYXRhWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlKCBjb21wb25lbnQsIGtleSwgdGVtcGxhdGUsIHRvQmluZCApIHtcblx0XHRcdHZhciBwYXJhbWV0ZXIsIHBhcnNlZCwgcGFyZW50SW5zdGFuY2UsIHBhcmVudEZyYWdtZW50LCBrZXlwYXRoLCBpbmRleFJlZjtcblx0XHRcdHBhcmVudEluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBzdGF0aWMgdmFsdWUsIGdyZWF0XG5cdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTiggdGVtcGxhdGUgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VkICkge1xuXHRcdFx0XHRcdHJldHVybiB0ZW1wbGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcGFyc2VkLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgbnVsbCwgd2UgdHJlYXQgaXQgYXMgYSBib29sZWFuIGF0dHJpYnV0ZSAoaS5lLiB0cnVlKVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBTaW5nbGUgaW50ZXJwb2xhdG9yP1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5sZW5ndGggPT09IDEgJiYgdGVtcGxhdGVbIDAgXS50ID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgKSB7XG5cdFx0XHRcdC8vIElmIGl0J3MgYSByZWd1bGFyIGludGVycG9sYXRvciwgd2UgYmluZCB0byBpdFxuXHRcdFx0XHRpZiAoIHRlbXBsYXRlWyAwIF0uciApIHtcblx0XHRcdFx0XHQvLyBJcyBpdCBhbiBpbmRleCByZWZlcmVuY2U/XG5cdFx0XHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnMgJiYgcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzWyBpbmRleFJlZiA9IHRlbXBsYXRlWyAwIF0uciBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRjb21wb25lbnQuaW5kZXhSZWZCaW5kaW5nc1sgaW5kZXhSZWYgXSA9IGtleTtcblx0XHRcdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnNbIGluZGV4UmVmIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFRPRE8gd2hhdCBhYm91dCByZWZlcmVuY2VzIHRoYXQgcmVzb2x2ZSBsYXRlPyBTaG91bGQgdGhlc2UgYmUgY29uc2lkZXJlZD9cblx0XHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggcGFyZW50SW5zdGFuY2UsIHRlbXBsYXRlWyAwIF0uciwgcGFyZW50RnJhZ21lbnQgKSB8fCB0ZW1wbGF0ZVsgMCBdLnI7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdXAgYmluZGluZ3MgYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkLCBidXRcblx0XHRcdFx0XHQvLyB3ZSBjYW4ndCBkbyBpdCB5ZXQgYmVjYXVzZSB0aGUgY2hpbGQgaW5zdGFuY2UgZG9lc24ndCBleGlzdFxuXHRcdFx0XHRcdC8vIHlldCAtIHNvIHdlIG1ha2UgYSBub3RlIGluc3RlYWRcblx0XHRcdFx0XHR0b0JpbmQucHVzaCgge1xuXHRcdFx0XHRcdFx0Y2hpbGRLZXlwYXRoOiBrZXksXG5cdFx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoOiBrZXlwYXRoXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnRJbnN0YW5jZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgaXQncyBhIHJlZmVyZW5jZSBleHByZXNzaW9uIChlLmcuIGB7e2Zvb1tiYXJdfX1gKSwgd2UgbmVlZFxuXHRcdFx0XHQvLyB0byB3YXRjaCB0aGUga2V5cGF0aCBhbmQgY3JlYXRlL2Rlc3Ryb3kgYmluZGluZ3Ncblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZVsgMCBdLnJ4ICkge1xuXHRcdFx0XHRcdHBhcmFtZXRlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyKCBjb21wb25lbnQsIGtleSwgdGVtcGxhdGVbIDAgXS5yeCwgdG9CaW5kICk7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzLnB1c2goIHBhcmFtZXRlciApO1xuXHRcdFx0XHRcdHBhcmFtZXRlci5yZWFkeSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmFtZXRlci52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gV2UgaGF2ZSBhICdjb21wbGV4IHBhcmFtZXRlcicgLSB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGZ1bGwtYmxvd24gc3RyaW5nXG5cdFx0XHQvLyBmcmFnbWVudCBpbiBvcmRlciB0byBldmFsdWF0ZSBhbmQgb2JzZXJ2ZSBpdHMgdmFsdWVcblx0XHRcdHBhcmFtZXRlciA9IG5ldyBDb21wb25lbnRQYXJhbWV0ZXIoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZSApO1xuXHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzLnB1c2goIHBhcmFtZXRlciApO1xuXHRcdFx0cmV0dXJuIHBhcmFtZXRlci52YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgcGFyc2VKU09OLCByZXNvbHZlUmVmLCBDb21wb25lbnRQYXJhbWV0ZXIsIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZUluc3RhbmNlLmpzICovXG5cdHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKCBsb2cgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNvbXBvbmVudCwgQ29tcG9uZW50LCBkYXRhLCBjb250ZW50RGVzY3JpcHRvciApIHtcblx0XHRcdHZhciBpbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIHBhcnRpYWxzLCByYWN0aXZlO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyYWN0aXZlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHQvLyBNYWtlIGNvbnRlbnRzIGF2YWlsYWJsZSBhcyBhIHt7PmNvbnRlbnR9fSBwYXJ0aWFsXG5cdFx0XHRwYXJ0aWFscyA9IHtcblx0XHRcdFx0Y29udGVudDogY29udGVudERlc2NyaXB0b3IgfHwgW11cblx0XHRcdH07XG5cdFx0XHRpZiAoIENvbXBvbmVudC5kZWZhdWx0cy5lbCApIHtcblx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnZGVmYXVsdEVsU3BlY2lmaWVkJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRuYW1lOiBjb21wb25lbnQubmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KCB7XG5cdFx0XHRcdGVsOiBudWxsLFxuXHRcdFx0XHRhcHBlbmQ6IHRydWUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdHBhcnRpYWxzOiBwYXJ0aWFscyxcblx0XHRcdFx0bWFnaWM6IHJhY3RpdmUubWFnaWMgfHwgQ29tcG9uZW50LmRlZmF1bHRzLm1hZ2ljLFxuXHRcdFx0XHRtb2RpZnlBcnJheXM6IHJhY3RpdmUubW9kaWZ5QXJyYXlzLFxuXHRcdFx0XHRfcGFyZW50OiByYWN0aXZlLFxuXHRcdFx0XHRfY29tcG9uZW50OiBjb21wb25lbnQsXG5cdFx0XHRcdC8vIG5lZWQgdG8gaW5oZXJpdCBydW50aW1lIHBhcmVudCBhZGFwdG9yc1xuXHRcdFx0XHRhZGFwdDogcmFjdGl2ZS5hZGFwdCxcblx0XHRcdFx0eWllbGQ6IHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogY29udGVudERlc2NyaXB0b3IsXG5cdFx0XHRcdFx0aW5zdGFuY2U6IHJhY3RpdmVcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGluc3RhbmNlO1xuXHRcdH07XG5cdH0oIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlQmluZGluZ3MuanMgKi9cblx0dmFyIGNyZWF0ZUJpbmRpbmdzID0gZnVuY3Rpb24oIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlSW5pdGlhbENvbXBvbmVudEJpbmRpbmdzKCBjb21wb25lbnQsIHRvQmluZCApIHtcblx0XHRcdHRvQmluZC5mb3JFYWNoKCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsQ29tcG9uZW50QmluZGluZyggcGFpciApIHtcblx0XHRcdFx0dmFyIGNoaWxkVmFsdWUsIHBhcmVudFZhbHVlO1xuXHRcdFx0XHRjcmVhdGVDb21wb25lbnRCaW5kaW5nKCBjb21wb25lbnQsIGNvbXBvbmVudC5yb290LCBwYWlyLnBhcmVudEtleXBhdGgsIHBhaXIuY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdGNoaWxkVmFsdWUgPSBjb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsLmdldCggcGFpci5jaGlsZEtleXBhdGggKTtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSBjb21wb25lbnQucm9vdC52aWV3bW9kZWwuZ2V0KCBwYWlyLnBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0aWYgKCBjaGlsZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQucm9vdC52aWV3bW9kZWwuc2V0KCBwYWlyLnBhcmVudEtleXBhdGgsIGNoaWxkVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL3Byb3BhZ2F0ZUV2ZW50cy5qcyAqL1xuXHR2YXIgcHJvcGFnYXRlRXZlbnRzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBmaXJlRXZlbnQsIGxvZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50cyggY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0dmFyIGV2ZW50TmFtZTtcblx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50c0Rlc2NyaXB0b3IuaGFzT3duUHJvcGVydHkoIGV2ZW50TmFtZSApICkge1xuXHRcdFx0XHRcdHByb3BhZ2F0ZUV2ZW50KCBjb21wb25lbnQuaW5zdGFuY2UsIGNvbXBvbmVudC5yb290LCBldmVudE5hbWUsIGV2ZW50c0Rlc2NyaXB0b3JbIGV2ZW50TmFtZSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnQoIGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJveHlFdmVudE5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcGFyZW50SW5zdGFuY2UuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vQ29tcG9uZW50RXZlbnRBcmd1bWVudHMnXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkSW5zdGFuY2Uub24oIGV2ZW50TmFtZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBldmVudCwgYXJncztcblx0XHRcdFx0Ly8gc2VtaS13ZWFrIHRlc3QsIGJ1dCB3aGF0IGVsc2U/IHRhZyB0aGUgZXZlbnQgb2JqIC5faXNFdmVudCA/XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbIDAgXSAmJiBhcmd1bWVudHNbIDAgXS5ub2RlICkge1xuXHRcdFx0XHRcdGV2ZW50ID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdGZpcmVFdmVudCggcGFyZW50SW5zdGFuY2UsIHByb3h5RXZlbnROYW1lLCB7XG5cdFx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3Ncblx0XHRcdFx0fSApO1xuXHRcdFx0XHQvLyBjYW5jZWwgYnViYmxpbmdcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNpcmN1bGFyLCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQsIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvdXBkYXRlTGl2ZVF1ZXJpZXMuanMgKi9cblx0dmFyIHVwZGF0ZUxpdmVRdWVyaWVzID0gZnVuY3Rpb24oIGNvbXBvbmVudCApIHtcblx0XHR2YXIgYW5jZXN0b3IsIHF1ZXJ5O1xuXHRcdC8vIElmIHRoZXJlJ3MgYSBsaXZlIHF1ZXJ5IGZvciB0aGlzIGNvbXBvbmVudCB0eXBlLCBhZGQgaXRcblx0XHRhbmNlc3RvciA9IGNvbXBvbmVudC5yb290O1xuXHRcdHdoaWxlICggYW5jZXN0b3IgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5ID0gYW5jZXN0b3IuX2xpdmVDb21wb25lbnRRdWVyaWVzWyAnXycgKyBjb21wb25lbnQubmFtZSBdICkge1xuXHRcdFx0XHRxdWVyeS5wdXNoKCBjb21wb25lbnQuaW5zdGFuY2UgKTtcblx0XHRcdH1cblx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IuX3BhcmVudDtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIHdhcm4sIGNyZWF0ZU1vZGVsLCBjcmVhdGVJbnN0YW5jZSwgY3JlYXRlQmluZGluZ3MsIHByb3BhZ2F0ZUV2ZW50cywgdXBkYXRlTGl2ZVF1ZXJpZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQ29tcG9uZW50JGluaXQoIG9wdGlvbnMsIENvbXBvbmVudCApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgcm9vdCwgZGF0YSwgdG9CaW5kO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy5yb290ID0gcm9vdDtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkNPTVBPTkVOVDtcblx0XHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUuZTtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5pbmRleFJlZkJpbmRpbmdzID0ge307XG5cdFx0XHR0aGlzLmJpbmRpbmdzID0gW107XG5cdFx0XHQvLyBldmVuIHRob3VnaCBvbmx5IG9uZSB5aWVsZGVyIGlzIGFsbG93ZWQsIHdlIG5lZWQgdG8gaGF2ZSBhbiBhcnJheSBvZiB0aGVtXG5cdFx0XHQvLyBhcyBpdCdzIHBvc3NpYmxlIHRvIGNhdXNlIGEgeWllbGRlciB0byBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgbGFzdCBvbmVcblx0XHRcdC8vIHdhcyBkZXN0cm95ZWQgaW4gdGhlIHNhbWUgdHVybiBvZiB0aGUgcnVubG9vcFxuXHRcdFx0dGhpcy55aWVsZGVycyA9IFtdO1xuXHRcdFx0aWYgKCAhQ29tcG9uZW50ICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb21wb25lbnQgXCInICsgdGhpcy5uYW1lICsgJ1wiIG5vdCBmb3VuZCcgKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcnN0LCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG1vZGVsIGZvciB0aGUgY29tcG9uZW50IC0gZS5nLiBpZiB3ZVxuXHRcdFx0Ly8gZW5jb3VudGVyIDx3aWRnZXQgZm9vPSdiYXInLz4gdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdpZGdldFxuXHRcdFx0Ly8gd2l0aCBgZGF0YTogeyBmb286ICdiYXInIH1gLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoaXMgbWF5IGludm9sdmUgc2V0dGluZyB1cCBzb21lIGJpbmRpbmdzLCBidXQgd2UgY2FuJ3QgZG8gaXRcblx0XHRcdC8vIHlldCBzbyB3ZSB0YWtlIHNvbWUgbm90ZXMgaW5zdGVhZFxuXHRcdFx0dG9CaW5kID0gW107XG5cdFx0XHRkYXRhID0gY3JlYXRlTW9kZWwoIHRoaXMsIENvbXBvbmVudC5kZWZhdWx0cy5kYXRhIHx8IHt9LCBvcHRpb25zLnRlbXBsYXRlLmEsIHRvQmluZCApO1xuXHRcdFx0Y3JlYXRlSW5zdGFuY2UoIHRoaXMsIENvbXBvbmVudCwgZGF0YSwgb3B0aW9ucy50ZW1wbGF0ZS5mICk7XG5cdFx0XHRjcmVhdGVCaW5kaW5ncyggdGhpcywgdG9CaW5kICk7XG5cdFx0XHRwcm9wYWdhdGVFdmVudHMoIHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudiApO1xuXHRcdFx0Ly8gaW50cm8sIG91dHJvIGFuZCBkZWNvcmF0b3IgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnQxIHx8IG9wdGlvbnMudGVtcGxhdGUudDIgfHwgb3B0aW9ucy50ZW1wbGF0ZS5vICkge1xuXHRcdFx0XHR3YXJuKCAnVGhlIFwiaW50cm9cIiwgXCJvdXRyb1wiIGFuZCBcImRlY29yYXRvclwiIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3Qgb24gY29tcG9uZW50cycgKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0fTtcblx0fSggdHlwZXMsIHdhcm4sIGNyZWF0ZU1vZGVsLCBjcmVhdGVJbnN0YW5jZSwgY3JlYXRlQmluZGluZ3MsIHByb3BhZ2F0ZUV2ZW50cywgdXBkYXRlTGl2ZVF1ZXJpZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZWJpbmQgPSBmdW5jdGlvbiggcnVubG9vcCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgY2hpbGRJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2UsXG5cdFx0XHRcdHBhcmVudEluc3RhbmNlID0gY2hpbGRJbnN0YW5jZS5fcGFyZW50LFxuXHRcdFx0XHRpbmRleFJlZkFsaWFzLCBxdWVyeTtcblx0XHRcdHRoaXMuYmluZGluZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cdFx0XHRcdHZhciB1cGRhdGVkO1xuXHRcdFx0XHRpZiAoIGJpbmRpbmcucm9vdCAhPT0gcGFyZW50SW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdXBkYXRlZCA9IGdldE5ld0tleXBhdGgoIGJpbmRpbmcua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucmViaW5kKCB1cGRhdGVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuY29tcGxleFBhcmFtZXRlcnMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHRpZiAoIHRoaXMueWllbGRlcnNbIDAgXSApIHtcblx0XHRcdFx0cmViaW5kKCB0aGlzLnlpZWxkZXJzWyAwIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXhSZWZBbGlhcyA9IHRoaXMuaW5kZXhSZWZCaW5kaW5nc1sgaW5kZXhSZWYgXSApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGNoaWxkSW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdGNoaWxkSW5zdGFuY2Uudmlld21vZGVsLnNldCggaW5kZXhSZWZBbGlhcywgbmV3SW5kZXggKTtcblx0XHRcdH1cblx0XHRcdGlmICggcXVlcnkgPSB0aGlzLnJvb3QuX2xpdmVDb21wb25lbnRRdWVyaWVzWyAnXycgKyB0aGlzLm5hbWUgXSApIHtcblx0XHRcdFx0cXVlcnkuX21ha2VEaXJ0eSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZWJpbmQoIHggKSB7XG5cdFx0XHRcdHgucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHJlbmRlcigpIHtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXHRcdGluc3RhbmNlLnJlbmRlciggdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR0b1N0cmluZyA9IGZ1bmN0aW9uIENvbXBvbmVudCR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC50b1N0cmluZygpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVuYmluZCA9IGZ1bmN0aW9uKCBIb29rLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHRlYXJkb3duSG9vayA9IG5ldyBIb29rKCAndGVhcmRvd24nICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBDb21wb25lbnQkdW5iaW5kKCkge1xuXHRcdFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblx0XHRcdHRoaXMuY29tcGxleFBhcmFtZXRlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR0aGlzLmJpbmRpbmdzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0cmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHQvLyB0ZWFyZG93biB0aGUgaW5zdGFuY2Vcblx0XHRcdGluc3RhbmNlLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0aW5zdGFuY2Uudmlld21vZGVsLnRlYXJkb3duKCk7XG5cdFx0XHRpZiAoIGluc3RhbmNlLmZyYWdtZW50LnJlbmRlcmVkICYmIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIGluc3RhbmNlICk7XG5cdFx0XHR9XG5cdFx0XHR0ZWFyZG93bkhvb2suZmlyZSggaW5zdGFuY2UgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCB0aGluZyApIHtcblx0XHRcdHRoaW5nLnVuYmluZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyggY29tcG9uZW50ICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblx0XHRcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmICggcXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIGNvbXBvbmVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdFx0cXVlcnkuX3JlbW92ZSggY29tcG9uZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLl9wYXJlbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHNob3VsZERlc3Ryb3k7XG5cdFx0dGhpcy5pbnN0YW5jZS51bnJlbmRlcigpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L19Db21wb25lbnQuanMgKi9cblx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBvcHRpb25zLCBDb25zdHJ1Y3RvciApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucywgQ29uc3RydWN0b3IgKTtcblx0XHR9O1xuXHRcdENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21tZW50LmpzICovXG5cdHZhciBDb21tZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgQ29tbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQ09NTUVOVDtcblx0XHRcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG5cdFx0fTtcblx0XHRDb21tZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggdGhpcy52YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJzwhLS0nICsgdGhpcy52YWx1ZSArICctLT4nO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbW1lbnQ7XG5cdH0oIHR5cGVzLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1lpZWxkZXIuanMgKi9cblx0dmFyIFlpZWxkZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHZhciBZaWVsZGVyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50SW5zdGFuY2UsIGNvbXBvbmVudDtcblx0XHRcdGNvbXBvbmVudEluc3RhbmNlID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQgPSBjb21wb25lbnRJbnN0YW5jZS5jb21wb25lbnQ7XG5cdFx0XHR0aGlzLnN1cnJvZ2F0ZVBhcmVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0cm9vdDogY29tcG9uZW50SW5zdGFuY2UueWllbGQuaW5zdGFuY2UsXG5cdFx0XHRcdHRlbXBsYXRlOiBjb21wb25lbnRJbnN0YW5jZS55aWVsZC50ZW1wbGF0ZSxcblx0XHRcdFx0cEVsZW1lbnQ6IHRoaXMuc3Vycm9nYXRlUGFyZW50LnBFbGVtZW50XG5cdFx0XHR9ICk7XG5cdFx0XHRjb21wb25lbnQueWllbGRlcnMucHVzaCggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudC55aWVsZGVycy5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0EgY29tcG9uZW50IHRlbXBsYXRlIGNhbiBvbmx5IGhhdmUgb25lIHt7eWllbGR9fSBkZWNsYXJhdGlvbiBhdCBhIHRpbWUnICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdFlpZWxkZXIucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGw6IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN1cnJvZ2F0ZVBhcmVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQucmVuZGVyKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmNvbXBvbmVudC55aWVsZGVycywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBZaWVsZGVyO1xuXHR9KCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVJdGVtLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXRfY3JlYXRlSXRlbSA9IGZ1bmN0aW9uKCB0eXBlcywgVGV4dCwgSW50ZXJwb2xhdG9yLCBTZWN0aW9uLCBUcmlwbGUsIEVsZW1lbnQsIFBhcnRpYWwsIGdldENvbXBvbmVudCwgQ29tcG9uZW50LCBDb21tZW50LCBZaWVsZGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUl0ZW0oIG9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXh0KCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKCBvcHRpb25zLnRlbXBsYXRlLnQgKSB7XG5cdFx0XHRcdGNhc2UgdHlwZXMuSU5URVJQT0xBVE9SOlxuXHRcdFx0XHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS5yID09PSAneWllbGQnICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBZaWVsZGVyKCBvcHRpb25zICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgSW50ZXJwb2xhdG9yKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTjpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFNlY3Rpb24oIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5UUklQTEU6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUcmlwbGUoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5FTEVNRU5UOlxuXHRcdFx0XHRcdHZhciBjb25zdHJ1Y3Rvcjtcblx0XHRcdFx0XHRpZiAoIGNvbnN0cnVjdG9yID0gZ2V0Q29tcG9uZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3QsIG9wdGlvbnMudGVtcGxhdGUuZSApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBDb21wb25lbnQoIG9wdGlvbnMsIGNvbnN0cnVjdG9yICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgRWxlbWVudCggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlBBUlRJQUw6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQYXJ0aWFsKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQ09NTUVOVDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IENvbW1lbnQoIG9wdGlvbnMgKTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLiBUaGFua3MhJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzLCBUZXh0LCBJbnRlcnBvbGF0b3IsIFNlY3Rpb24sIFRyaXBsZSwgRWxlbWVudCwgUGFydGlhbCwgZ2V0Q29tcG9uZW50LCBDb21wb25lbnQsIENvbW1lbnQsIFlpZWxkZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIGNyZWF0ZSwgY3JlYXRlSXRlbSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBGcmFnbWVudCRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHBhcmVudFJlZnMsIHJlZjtcblx0XHRcdC8vIFRoZSBpdGVtIHRoYXQgb3ducyB0aGlzIGZyYWdtZW50IC0gYW4gZWxlbWVudCwgc2VjdGlvbiwgcGFydGlhbCwgb3IgYXR0cmlidXRlXG5cdFx0XHR0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lcjtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnQgPSB0aGlzLm93bmVyLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gaW5oZXJpdGVkIHByb3BlcnRpZXNcblx0XHRcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcblx0XHRcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuXHRcdFx0Ly8gSWYgcGFyZW50IGl0ZW0gaXMgYSBzZWN0aW9uLCB0aGlzIG1heSBub3QgYmUgdGhlIG9ubHkgZnJhZ21lbnRcblx0XHRcdC8vIHRoYXQgYmVsb25ncyB0byBpdCAtIHdlIG5lZWQgdG8gbWFrZSBhIG5vdGUgb2YgdGhlIGluZGV4XG5cdFx0XHRpZiAoIHRoaXMub3duZXIudHlwZSA9PT0gdHlwZXMuU0VDVElPTiApIHtcblx0XHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbmRleCByZWZlcmVuY2VzICh0aGUgJ2knIGluIHt7I3NlY3Rpb246aX19Li4ue3svc2VjdGlvbn19KSBuZWVkIHRvIGNhc2NhZGVcblx0XHRcdC8vIGRvd24gdGhlIHRyZWVcblx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHRcdHBhcmVudFJlZnMgPSBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnM7XG5cdFx0XHRcdGlmICggcGFyZW50UmVmcyApIHtcblx0XHRcdFx0XHR0aGlzLmluZGV4UmVmcyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0XHRcdC8vIGF2b2lkcyBuZWVkIGZvciBoYXNPd25Qcm9wZXJ0eVxuXHRcdFx0XHRcdGZvciAoIHJlZiBpbiBwYXJlbnRSZWZzICkge1xuXHRcdFx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIHJlZiBdID0gcGFyZW50UmVmc1sgcmVmIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMuaW5kZXhSZWYgKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuaW5kZXhSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIG9wdGlvbnMuaW5kZXhSZWYgXSA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lIHRvIGNyZWF0ZSB0aGlzIGZyYWdtZW50J3MgY2hpbGQgaXRlbXNcblx0XHRcdC8vIFRFTVAgc2hvdWxkIHRoaXMgYmUgaGFwcGVuaW5nP1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdG9wdGlvbnMudGVtcGxhdGUgPSBbIG9wdGlvbnMudGVtcGxhdGUgXTtcblx0XHRcdH0gZWxzZSBpZiAoICFvcHRpb25zLnRlbXBsYXRlICkge1xuXHRcdFx0XHRvcHRpb25zLnRlbXBsYXRlID0gW107XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zID0gb3B0aW9ucy50ZW1wbGF0ZS5tYXAoIGZ1bmN0aW9uKCB0ZW1wbGF0ZSwgaSApIHtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUl0ZW0oIHtcblx0XHRcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcyQwLFxuXHRcdFx0XHRcdHBFbGVtZW50OiBvcHRpb25zLnBFbGVtZW50LFxuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmJvdW5kID0gdHJ1ZTtcblx0XHR9O1xuXHR9KCB0eXBlcywgY3JlYXRlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXRfY3JlYXRlSXRlbSApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRyZWJpbmQgPSBmdW5jdGlvbiggYXNzaWduTmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBGcmFnbWVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHRoaXMuaW5kZXggPSBuZXdJbmRleDtcblx0XHRcdC8vIGFzc2lnbiBuZXcgY29udGV4dCBrZXlwYXRoIGlmIG5lZWRlZFxuXHRcdFx0YXNzaWduTmV3S2V5cGF0aCggdGhpcywgJ2NvbnRleHQnLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRpZiAoIHRoaXMuaW5kZXhSZWZzICYmIHRoaXMuaW5kZXhSZWZzWyBpbmRleFJlZiBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMuaW5kZXhSZWZzWyBpbmRleFJlZiBdID0gbmV3SW5kZXg7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRpZiAoIGl0ZW0ucmViaW5kICkge1xuXHRcdFx0XHRcdGl0ZW0ucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIGFzc2lnbk5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkcmVuZGVyID0gZnVuY3Rpb24gRnJhZ21lbnQkcmVuZGVyKCkge1xuXHRcdHZhciByZXN1bHQ7XG5cdFx0aWYgKCB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJlc3VsdCA9IHRoaXMuaXRlbXNbIDAgXS5yZW5kZXIoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0cmVzdWx0LmFwcGVuZENoaWxkKCBpdGVtLnJlbmRlcigpICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdG9TdHJpbmcgPSBmdW5jdGlvbiBGcmFnbWVudCR0b1N0cmluZyggZXNjYXBlICkge1xuXHRcdGlmICggIXRoaXMuaXRlbXMgKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLml0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS50b1N0cmluZyggZXNjYXBlICk7XG5cdFx0fSApLmpvaW4oICcnICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVuYmluZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRnJhZ21lbnQkdW5iaW5kKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5ib3VuZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCB1bmJpbmRJdGVtICk7XG5cdFx0XHR0aGlzLmJvdW5kID0gZmFsc2U7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZEl0ZW0oIGl0ZW0gKSB7XG5cdFx0XHRpZiAoIGl0ZW0udW5iaW5kICkge1xuXHRcdFx0XHRpdGVtLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR1bnJlbmRlciA9IGZ1bmN0aW9uIEZyYWdtZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gdW5yZW5kZXIgYSBmcmFnbWVudCB0aGF0IHdhcyBub3QgcmVuZGVyZWQnICk7XG5cdFx0fVxuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRyZXR1cm4gaS51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdH0gKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC5qcyAqL1xuXHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgZ2V0Tm9kZSwgZ2V0VmFsdWUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0RnJhZ21lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXROb2RlOiBnZXROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0Y2lyY3VsYXIuRnJhZ21lbnQgPSBGcmFnbWVudDtcblx0XHRyZXR1cm4gRnJhZ21lbnQ7XG5cdH0oIHZpcnR1YWxkb21fRnJhZ21lbnQkYnViYmxlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGRldGFjaCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGwsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0VmFsdWUsIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCwgdmlydHVhbGRvbV9GcmFnbWVudCRyZWJpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVuYmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCR1bnJlbmRlciwgY2lyY3VsYXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXNldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldCA9IGZ1bmN0aW9uKCBIb29rLCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICkge1xuXG5cdFx0dmFyIHNob3VsZFJlcmVuZGVyID0gW1xuXHRcdFx0XHQndGVtcGxhdGUnLFxuXHRcdFx0XHQncGFydGlhbHMnLFxuXHRcdFx0XHQnY29tcG9uZW50cycsXG5cdFx0XHRcdCdkZWNvcmF0b3JzJyxcblx0XHRcdFx0J2V2ZW50cydcblx0XHRcdF0sXG5cdFx0XHRyZXNldEhvb2sgPSBuZXcgSG9vayggJ3Jlc2V0JyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0KCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBwcm9taXNlLCB3cmFwcGVyLCBjaGFuZ2VzLCBpLCByZXJlbmRlcjtcblx0XHRcdGlmICggdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrICkge1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSB7fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RoZSByZXNldCBtZXRob2QgdGFrZXMgZWl0aGVyIG5vIGFyZ3VtZW50cywgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmV3IGRhdGEnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGUgcm9vdCBvYmplY3QgaXMgd3JhcHBlZCwgdHJ5IGFuZCB1c2UgdGhlIHdyYXBwZXIncyByZXNldCB2YWx1ZVxuXHRcdFx0aWYgKCAoIHdyYXBwZXIgPSB0aGlzLnZpZXdtb2RlbC53cmFwcGVkWyAnJyBdICkgJiYgd3JhcHBlci5yZXNldCApIHtcblx0XHRcdFx0aWYgKCB3cmFwcGVyLnJlc2V0KCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdC8vIHJlc2V0IHdhcyByZWplY3RlZCwgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBvYmplY3Rcblx0XHRcdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVzZXQgY29uZmlnIGl0ZW1zIGFuZCB0cmFjayBpZiBuZWVkIHRvIHJlcmVuZGVyXG5cdFx0XHRjaGFuZ2VzID0gY29uZmlnLnJlc2V0KCB0aGlzICk7XG5cdFx0XHRpID0gY2hhbmdlcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGRSZXJlbmRlci5pbmRleE9mKCBjaGFuZ2VzWyBpIF0gKSA+IC0xICkge1xuXHRcdFx0XHRcdHJlcmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXJlbmRlciApIHtcblx0XHRcdFx0dmFyIGNvbXBvbmVudDtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayggJycgKTtcblx0XHRcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuXHRcdFx0XHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcblx0XHRcdFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG5cdFx0XHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG5cdFx0XHRcdGlmICggY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudW5yZW5kZXIoKTtcblx0XHRcdFx0aWYgKCBjb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiB0aGUgdGVtcGxhdGUgY2hhbmdlZCwgd2UgbmVlZCB0byBkZXN0cm95IHRoZSBwYXJhbGxlbCBET01cblx0XHRcdFx0Ly8gVE9ETyBpZiB3ZSdyZSBoZXJlLCBwcmVzdW1hYmx5IGl0IGRpZD9cblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50LnRlbXBsYXRlICE9PSB0aGlzLnRlbXBsYXRlICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG5cdFx0XHRcdFx0XHRyb290OiB0aGlzLFxuXHRcdFx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvbWlzZSA9IHRoaXMucmVuZGVyKCB0aGlzLmVsLCB0aGlzLmFuY2hvciApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayggJycgKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdH1cblx0XHRcdHJlc2V0SG9vay5maXJlKCB0aGlzLCBkYXRhICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVzZXRUZW1wbGF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldFRlbXBsYXRlID0gZnVuY3Rpb24oIGNvbmZpZywgRnJhZ21lbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZXNldFRlbXBsYXRlKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciB0cmFuc2l0aW9uc0VuYWJsZWQsIGNvbXBvbmVudDtcblx0XHRcdGNvbmZpZy50ZW1wbGF0ZS5pbml0KCBudWxsLCB0aGlzLCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZVxuXHRcdFx0fSApO1xuXHRcdFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuXHRcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG5cdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG5cdFx0XHRpZiAoIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50ICkge1xuXHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIHJlbW92ZSBleGlzdGluZyBmcmFnbWVudCBhbmQgY3JlYXRlIG5ldyBvbmVcblx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuXHRcdFx0XHRyb290OiB0aGlzLFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHR9O1xuXHR9KCBjb25maWcsIEZyYWdtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmV2ZXJzZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXZlcnNlID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdyZXZlcnNlJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2V0ID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICkge1xuXG5cdFx0dmFyIHdpbGRjYXJkID0gL1xcKi87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBtYXAsIHByb21pc2U7XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuXHRcdFx0aWYgKCBpc09iamVjdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRjYWxsYmFjayA9IHZhbHVlO1xuXHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIG1hcCApIHtcblx0XHRcdFx0XHRpZiAoIG1hcC5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBtYXBbIGtleXBhdGggXTtcblx0XHRcdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKCB0aGlzLCBrZXlwYXRoICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHR0aGlzJDAudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hpZnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hpZnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zb3J0LmpzICovXG5cdHZhciBSYWN0aXZlJHNvcnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NvcnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NwbGljZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzcGxpY2UgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NwbGljZScgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc3VidHJhY3QuanMgKi9cblx0dmFyIFJhY3RpdmUkc3VidHJhY3QgPSBmdW5jdGlvbiggYWRkICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc3VidHJhY3QoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfYWRkICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdGVhcmRvd24uanMgKi9cblx0dmFyIFJhY3RpdmUkdGVhcmRvd24gPSBmdW5jdGlvbiggSG9vaywgUHJvbWlzZSwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIHRlYXJkb3duSG9vayA9IG5ldyBIb29rKCAndGVhcmRvd24nICk7XG5cdFx0Ly8gVGVhcmRvd24uIFRoaXMgZ29lcyB0aHJvdWdoIHRoZSByb290IGZyYWdtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLCByZW1vdmluZyBvYnNlcnZlcnNcblx0XHQvLyBhbmQgZ2VuZXJhbGx5IGNsZWFuaW5nIHVwIGFmdGVyIGl0c2VsZlxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHRlYXJkb3duKCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBwcm9taXNlO1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgJiYgdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHRwcm9taXNlID0gdGhpcy5mcmFnbWVudC5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0dGVhcmRvd25Ib29rLmZpcmUoIHRoaXMgKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdC8vIFRPRE8gZGVwcmVjYXRlIHRoaXM/XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2suYmluZCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBQcm9taXNlLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90b2dnbGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdG9nZ2xlID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHRvZ2dsZSgga2V5cGF0aCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bG9nLmVycm9yT25seSgge1xuXHRcdFx0XHRcdGRlYnVnOiB0aGlzLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NzYWdlOiAnYmFkQXJndW1lbnRzJyxcblx0XHRcdFx0XHRhcmc6IHtcblx0XHRcdFx0XHRcdGFyZ3VtZW50czoga2V5cGF0aFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCBrZXlwYXRoLCAhdmFsdWUsIGNhbGxiYWNrICk7XG5cdFx0fTtcblx0fSggbG9nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdG9IVE1MLmpzICovXG5cdHZhciBSYWN0aXZlJHRvSFRNTCA9IGZ1bmN0aW9uIFJhY3RpdmUkdG9IVE1MKCkge1xuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0cnVlICk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkdW5yZW5kZXIgPSBmdW5jdGlvbiggY3NzLCBIb29rLCBsb2csIFByb21pc2UsIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApIHtcblxuXHRcdHZhciB1bnJlbmRlckhvb2sgPSBuZXcgSG9vayggJ3VucmVuZGVyJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJvbWlzZSwgc2hvdWxkRGVzdHJveTtcblx0XHRcdGlmICggIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQgKSB7XG5cdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHRoaXMuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ3JhY3RpdmUudW5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBub3QgcmVuZGVyZWQnXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGlzbid0IG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb24sXG5cdFx0XHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcblx0XHRcdHNob3VsZERlc3Ryb3kgPSAhdGhpcy5jb21wb25lbnQgfHwgdGhpcy5jb21wb25lbnQuc2hvdWxkRGVzdHJveSB8fCB0aGlzLnNob3VsZERlc3Ryb3k7XG5cdFx0XHRpZiAoIHRoaXMuY29uc3RydWN0b3IuY3NzICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNzcy5yZW1vdmUoIHRoaXMkMC5jb25zdHJ1Y3RvciApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDYW5jZWwgYW55IGFuaW1hdGlvbnMgaW4gcHJvZ3Jlc3Ncblx0XHRcdHdoaWxlICggdGhpcy5fYW5pbWF0aW9uc1sgMCBdICkge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25zWyAwIF0uc3RvcCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0dW5yZW5kZXJIb29rLmZpcmUoIHRoaXMgKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBnbG9iYWxfY3NzLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBsb2csIFByb21pc2UsIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3Vuc2hpZnQuanMgKi9cblx0dmFyIFJhY3RpdmUkdW5zaGlmdCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAndW5zaGlmdCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJHVwZGF0ZSA9IGZ1bmN0aW9uKCBIb29rLCBydW5sb29wICkge1xuXG5cdFx0dmFyIHVwZGF0ZUhvb2sgPSBuZXcgSG9vayggJ3VwZGF0ZScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGUoIGtleXBhdGgsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2U7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR1cGRhdGVIb29rLmZpcmUoIHRoaXMsIGtleXBhdGggKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2suYmluZCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBydW5sb29wICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdXBkYXRlTW9kZWwuanMgKi9cblx0dmFyIFJhY3RpdmUkdXBkYXRlTW9kZWwgPSBmdW5jdGlvbiggYXJyYXlDb250ZW50c01hdGNoLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGVNb2RlbCgga2V5cGF0aCwgY2FzY2FkZSApIHtcblx0XHRcdHZhciB2YWx1ZXM7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0a2V5cGF0aCA9ICcnO1xuXHRcdFx0XHRjYXNjYWRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGlkYXRlQ2hhbmdlZFZhbHVlcyggdGhpcywga2V5cGF0aCwgdmFsdWVzID0ge30sIGNhc2NhZGUgKTtcblx0XHRcdHJldHVybiB0aGlzLnNldCggdmFsdWVzICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNvbnNvbGlkYXRlQ2hhbmdlZFZhbHVlcyggcmFjdGl2ZSwga2V5cGF0aCwgdmFsdWVzLCBjYXNjYWRlICkge1xuXHRcdFx0dmFyIGJpbmRpbmdzLCBjaGlsZERlcHMsIGksIGJpbmRpbmcsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY2hlY2tib3hHcm91cHMgPSBbXTtcblx0XHRcdGJpbmRpbmdzID0gcmFjdGl2ZS5fdHdvd2F5QmluZGluZ3NbIGtleXBhdGggXTtcblx0XHRcdGlmICggYmluZGluZ3MgJiYgKCBpID0gYmluZGluZ3MubGVuZ3RoICkgKSB7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWUgYmluZGluZ3Ncblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcucmFkaW9OYW1lICYmICFiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNoZWNrYm94IG5hbWUgYmluZGluZ3MgY29tZSBpbiBncm91cHMsIHNvXG5cdFx0XHRcdFx0Ly8gd2Ugd2FudCB0byBnZXQgdGhlIHZhbHVlIG9uY2UgYXQgbW9zdFxuXHRcdFx0XHRcdGlmICggYmluZGluZy5jaGVja2JveE5hbWUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFjaGVja2JveEdyb3Vwc1sgYmluZGluZy5rZXlwYXRoIF0gJiYgIWJpbmRpbmcuY2hhbmdlZCgpICkge1xuXHRcdFx0XHRcdFx0XHRjaGVja2JveEdyb3Vwcy5wdXNoKCBiaW5kaW5nLmtleXBhdGggKTtcblx0XHRcdFx0XHRcdFx0Y2hlY2tib3hHcm91cHNbIGJpbmRpbmcua2V5cGF0aCBdID0gYmluZGluZztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuXHRcdFx0XHRcdG5ld1ZhbHVlID0gYmluZGluZy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdGlmICggYXJyYXlDb250ZW50c01hdGNoKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFpc0VxdWFsKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gbmV3VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBIYW5kbGUgZ3JvdXBzIG9mIGA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3t7Zm9vfX0nIC4uLj5gXG5cdFx0XHRpZiAoIGNoZWNrYm94R3JvdXBzLmxlbmd0aCApIHtcblx0XHRcdFx0Y2hlY2tib3hHcm91cHMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0dmFyIGJpbmRpbmcsIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblx0XHRcdFx0XHRiaW5kaW5nID0gY2hlY2tib3hHcm91cHNbIGtleXBhdGggXTtcblx0XHRcdFx0XHQvLyBvbmUgdG8gcmVwcmVzZW50IHRoZSBlbnRpcmUgZ3JvdXBcblx0XHRcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuXHRcdFx0XHRcdG5ld1ZhbHVlID0gYmluZGluZy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdGlmICggIWFycmF5Q29udGVudHNNYXRjaCggb2xkVmFsdWUsIG5ld1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IG5ld1ZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhY2FzY2FkZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2FzY2FkZVxuXHRcdFx0Y2hpbGREZXBzID0gcmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcFsgJ2RlZmF1bHQnIF1bIGtleXBhdGggXTtcblx0XHRcdGlmICggY2hpbGREZXBzICkge1xuXHRcdFx0XHRpID0gY2hpbGREZXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Y29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCByYWN0aXZlLCBjaGlsZERlcHNbIGkgXSwgdmFsdWVzLCBjYXNjYWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBhcnJheUNvbnRlbnRzTWF0Y2gsIGlzRXF1YWwgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS5qcyAqL1xuXHR2YXIgcHJvdG90eXBlID0gZnVuY3Rpb24oIGFkZCwgYW5pbWF0ZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmlyZSwgZ2V0LCBpbnNlcnQsIG1lcmdlLCBvYnNlcnZlLCBvZmYsIG9uLCBwb3AsIHB1c2gsIHJlbmRlciwgcmVzZXQsIHJlc2V0VGVtcGxhdGUsIHJldmVyc2UsIHNldCwgc2hpZnQsIHNvcnQsIHNwbGljZSwgc3VidHJhY3QsIHRlYXJkb3duLCB0b2dnbGUsIHRvSFRNTCwgdW5yZW5kZXIsIHVuc2hpZnQsIHVwZGF0ZSwgdXBkYXRlTW9kZWwgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWRkOiBhZGQsXG5cdFx0XHRhbmltYXRlOiBhbmltYXRlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaXJlOiBmaXJlLFxuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRpbnNlcnQ6IGluc2VydCxcblx0XHRcdG1lcmdlOiBtZXJnZSxcblx0XHRcdG9ic2VydmU6IG9ic2VydmUsXG5cdFx0XHRvZmY6IG9mZixcblx0XHRcdG9uOiBvbixcblx0XHRcdHBvcDogcG9wLFxuXHRcdFx0cHVzaDogcHVzaCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzZXQ6IHJlc2V0LFxuXHRcdFx0cmVzZXRUZW1wbGF0ZTogcmVzZXRUZW1wbGF0ZSxcblx0XHRcdHJldmVyc2U6IHJldmVyc2UsXG5cdFx0XHRzZXQ6IHNldCxcblx0XHRcdHNoaWZ0OiBzaGlmdCxcblx0XHRcdHNvcnQ6IHNvcnQsXG5cdFx0XHRzcGxpY2U6IHNwbGljZSxcblx0XHRcdHN1YnRyYWN0OiBzdWJ0cmFjdCxcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHRvZ2dsZTogdG9nZ2xlLFxuXHRcdFx0dG9IVE1MOiB0b0hUTUwsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1bnNoaWZ0OiB1bnNoaWZ0LFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0XHR1cGRhdGVNb2RlbDogdXBkYXRlTW9kZWxcblx0XHR9O1xuXHR9KCBSYWN0aXZlJGFkZCwgUmFjdGl2ZSRhbmltYXRlLCBSYWN0aXZlJGRldGFjaCwgUmFjdGl2ZSRmaW5kLCBSYWN0aXZlJGZpbmRBbGwsIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMsIFJhY3RpdmUkZmluZENvbXBvbmVudCwgUmFjdGl2ZSRmaXJlLCBSYWN0aXZlJGdldCwgUmFjdGl2ZSRpbnNlcnQsIFJhY3RpdmUkbWVyZ2UsIFJhY3RpdmUkb2JzZXJ2ZSwgUmFjdGl2ZSRvZmYsIFJhY3RpdmUkb24sIFJhY3RpdmUkcG9wLCBSYWN0aXZlJHB1c2gsIFJhY3RpdmUkcmVuZGVyLCBSYWN0aXZlJHJlc2V0LCBSYWN0aXZlJHJlc2V0VGVtcGxhdGUsIFJhY3RpdmUkcmV2ZXJzZSwgUmFjdGl2ZSRzZXQsIFJhY3RpdmUkc2hpZnQsIFJhY3RpdmUkc29ydCwgUmFjdGl2ZSRzcGxpY2UsIFJhY3RpdmUkc3VidHJhY3QsIFJhY3RpdmUkdGVhcmRvd24sIFJhY3RpdmUkdG9nZ2xlLCBSYWN0aXZlJHRvSFRNTCwgUmFjdGl2ZSR1bnJlbmRlciwgUmFjdGl2ZSR1bnNoaWZ0LCBSYWN0aXZlJHVwZGF0ZSwgUmFjdGl2ZSR1cGRhdGVNb2RlbCApO1xuXG5cdC8qIHV0aWxzL2dldEd1aWQuanMgKi9cblx0dmFyIGdldEd1aWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSggL1t4eV0vZywgZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgciwgdjtcblx0XHRcdHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuXHRcdFx0diA9IGMgPT0gJ3gnID8gciA6IHIgJiAzIHwgODtcblx0XHRcdHJldHVybiB2LnRvU3RyaW5nKCAxNiApO1xuXHRcdH0gKTtcblx0fTtcblxuXHQvKiB1dGlscy9nZXROZXh0TnVtYmVyLmpzICovXG5cdHZhciBnZXROZXh0TnVtYmVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICdyLScgKyBpKys7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9ob29rcy9Ib29rUXVldWUuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2tRdWV1ZSA9IGZ1bmN0aW9uKCBIb29rICkge1xuXG5cdFx0ZnVuY3Rpb24gSG9va1F1ZXVlKCBldmVudCApIHtcblx0XHRcdHRoaXMuaG9vayA9IG5ldyBIb29rKCBldmVudCApO1xuXHRcdFx0dGhpcy5pblByb2Nlc3MgPSB7fTtcblx0XHRcdHRoaXMucXVldWUgPSB7fTtcblx0XHR9XG5cdFx0SG9va1F1ZXVlLnByb3RvdHlwZSA9IHtcblx0XHRcdGNvbnN0cnVjdG9yOiBIb29rUXVldWUsXG5cdFx0XHRiZWdpbjogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHRoaXMuaW5Qcm9jZXNzWyByYWN0aXZlLl9ndWlkIF0gPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGVuZDogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSByYWN0aXZlLl9wYXJlbnQ7XG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiBwcm9jZXNzLFxuXHRcdFx0XHQvLyBpdCBzaG91bGQgY2FsbCBtZXRob2RzIG9yIGZpcmUgYXQgdGhpcyBwb2ludFxuXHRcdFx0XHRpZiAoICFwYXJlbnQgfHwgIXRoaXMuaW5Qcm9jZXNzWyBwYXJlbnQuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRmaXJlKCB0aGlzLCByYWN0aXZlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2V0Q2hpbGRRdWV1ZSggdGhpcy5xdWV1ZSwgcGFyZW50ICkucHVzaCggcmFjdGl2ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmluUHJvY2Vzc1sgcmFjdGl2ZS5fZ3VpZCBdO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRDaGlsZFF1ZXVlKCBxdWV1ZSwgcmFjdGl2ZSApIHtcblx0XHRcdHJldHVybiBxdWV1ZVsgcmFjdGl2ZS5fZ3VpZCBdIHx8ICggcXVldWVbIHJhY3RpdmUuX2d1aWQgXSA9IFtdICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlyZSggaG9va1F1ZXVlLCByYWN0aXZlICkge1xuXHRcdFx0dmFyIGNoaWxkUXVldWUgPSBnZXRDaGlsZFF1ZXVlKCBob29rUXVldWUucXVldWUsIHJhY3RpdmUgKTtcblx0XHRcdGhvb2tRdWV1ZS5ob29rLmZpcmUoIHJhY3RpdmUgKTtcblx0XHRcdC8vIHF1ZXVlIGlzIFwibGl2ZVwiIGJlY2F1c2UgY29tcG9uZW50cyBjYW4gZW5kIHVwIGJlaW5nXG5cdFx0XHQvLyBhZGRlZCB3aGlsZSBob29rcyBmaXJlIG9uIHBhcmVudHMgdGhhdCBtb2RpZnkgZGF0YSB2YWx1ZXMuXG5cdFx0XHR3aGlsZSAoIGNoaWxkUXVldWUubGVuZ3RoICkge1xuXHRcdFx0XHRmaXJlKCBob29rUXVldWUsIGNoaWxkUXVldWUuc2hpZnQoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIGhvb2tRdWV1ZS5xdWV1ZVsgcmFjdGl2ZS5fZ3VpZCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gSG9va1F1ZXVlO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvYXJyYXlBZGFwdG9yL3Byb2Nlc3NXcmFwcGVyLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvcl9wcm9jZXNzV3JhcHBlciA9IGZ1bmN0aW9uKCB3cmFwcGVyLCBhcnJheSwgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyApIHtcblx0XHR2YXIgcm9vdCA9IHdyYXBwZXIucm9vdCxcblx0XHRcdGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cdFx0Ly8gSWYgdGhpcyBpcyBhIHNvcnQgb3IgcmV2ZXJzZSwgd2UganVzdCBkbyByb290LnNldCgpLi4uXG5cdFx0Ly8gVE9ETyB1c2UgbWVyZ2UgbG9naWM/XG5cdFx0aWYgKCBtZXRob2ROYW1lID09PSAnc29ydCcgfHwgbWV0aG9kTmFtZSA9PT0gJ3JldmVyc2UnICkge1xuXHRcdFx0cm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCBhcnJheSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyb290LnZpZXdtb2RlbC5zbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMgKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcGF0Y2guanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3BhdGNoID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGRlZmluZVByb3BlcnR5LCBnZXROZXdJbmRpY2VzLCBwcm9jZXNzV3JhcHBlciApIHtcblxuXHRcdHZhciBwYXRjaGVkQXJyYXlQcm90byA9IFtdLFxuXHRcdFx0bXV0YXRvck1ldGhvZHMgPSBbXG5cdFx0XHRcdCdwb3AnLFxuXHRcdFx0XHQncHVzaCcsXG5cdFx0XHRcdCdyZXZlcnNlJyxcblx0XHRcdFx0J3NoaWZ0Jyxcblx0XHRcdFx0J3NvcnQnLFxuXHRcdFx0XHQnc3BsaWNlJyxcblx0XHRcdFx0J3Vuc2hpZnQnXG5cdFx0XHRdLFxuXHRcdFx0dGVzdE9iaiwgcGF0Y2hBcnJheU1ldGhvZHMsIHVucGF0Y2hBcnJheU1ldGhvZHM7XG5cdFx0bXV0YXRvck1ldGhvZHMuZm9yRWFjaCggZnVuY3Rpb24oIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHR2YXIgbWV0aG9kID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFx0XHR2YXIgYXJncyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAwICk7XG5cdFx0XHRcdHZhciBuZXdJbmRpY2VzLCByZXN1bHQsIHdyYXBwZXIsIGk7XG5cdFx0XHRcdG5ld0luZGljZXMgPSBnZXROZXdJbmRpY2VzKCB0aGlzLCBtZXRob2ROYW1lLCBhcmdzICk7XG5cdFx0XHRcdC8vIGFwcGx5IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuXHRcdFx0XHRyZXN1bHQgPSBBcnJheS5wcm90b3R5cGVbIG1ldGhvZE5hbWUgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdC8vIHRyaWdnZXIgY2hhbmdlc1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCk7XG5cdFx0XHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG5cdFx0XHRcdGkgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0d3JhcHBlciA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnNbIGkgXTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggd3JhcHBlci5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHByb2Nlc3NXcmFwcGVyKCB3cmFwcGVyLCB0aGlzLCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG5cdFx0XHRcdHZhbHVlOiBtZXRob2Rcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdFx0Ly8gY2FuIHdlIHVzZSBwcm90b3R5cGUgY2hhaW4gaW5qZWN0aW9uP1xuXHRcdC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2hvdy1lY21hc2NyaXB0LTUtc3RpbGwtZG9lcy1ub3QtYWxsb3ctdG8tc3ViY2xhc3MtYW4tYXJyYXkvI3dyYXBwZXJzX3Byb3RvdHlwZV9jaGFpbl9pbmplY3Rpb25cblx0XHR0ZXN0T2JqID0ge307XG5cdFx0aWYgKCB0ZXN0T2JqLl9fcHJvdG9fXyApIHtcblx0XHRcdC8vIHllcywgd2UgY2FuXG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG5cdFx0XHR9O1xuXHRcdFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gQXJyYXkucHJvdG90eXBlO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbm8sIHdlIGNhbid0XG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0dmFyIGksIG1ldGhvZE5hbWU7XG5cdFx0XHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG1ldGhvZE5hbWUgPSBtdXRhdG9yTWV0aG9kc1sgaSBdO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBhcnJheSwgbWV0aG9kTmFtZSwge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHBhdGNoZWRBcnJheVByb3RvWyBtZXRob2ROYW1lIF0sXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5WyBtdXRhdG9yTWV0aG9kc1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHBhdGNoQXJyYXlNZXRob2RzLnVucGF0Y2ggPSB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXHRcdHJldHVybiBwYXRjaEFycmF5TWV0aG9kcztcblx0fSggcnVubG9vcCwgZGVmaW5lUHJvcGVydHksIGdldE5ld0luZGljZXMsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3Byb2Nlc3NXcmFwcGVyICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvYXJyYXlBZGFwdG9yLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciA9IGZ1bmN0aW9uKCBkZWZpbmVQcm9wZXJ0eSwgaXNBcnJheSwgcGF0Y2ggKSB7XG5cblx0XHR2YXIgYXJyYXlBZGFwdG9yLFxuXHRcdFx0Ly8gaGVscGVyc1xuXHRcdFx0QXJyYXlXcmFwcGVyLCBlcnJvck1lc3NhZ2U7XG5cdFx0YXJyYXlBZGFwdG9yID0ge1xuXHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXHRcdFx0XHQvLyB3cmFwIHRoZSBhcnJheSBpZiBhKSBiKSBpdCdzIGFuIGFycmF5LCBhbmQgYikgZWl0aGVyIGl0IGhhc24ndCBiZWVuIHdyYXBwZWQgYWxyZWFkeSxcblx0XHRcdFx0Ly8gb3IgdGhlIGFycmF5IGRpZG4ndCB0cmlnZ2VyIHRoZSBnZXQoKSBpdHNlbGZcblx0XHRcdFx0cmV0dXJuIGlzQXJyYXkoIG9iamVjdCApICYmICggIW9iamVjdC5fcmFjdGl2ZSB8fCAhb2JqZWN0Ll9yYWN0aXZlLnNldHRpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHR3cmFwOiBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQXJyYXlXcmFwcGVyKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0QXJyYXlXcmFwcGVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMudmFsdWUgPSBhcnJheTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHQvLyBpZiB0aGlzIGFycmF5IGhhc24ndCBhbHJlYWR5IGJlZW4gcmFjdGlmaWVkLCByYWN0aWZ5IGl0XG5cdFx0XHRpZiAoICFhcnJheS5fcmFjdGl2ZSApIHtcblx0XHRcdFx0Ly8gZGVmaW5lIGEgbm9uLWVudW1lcmFibGUgX3JhY3RpdmUgcHJvcGVydHkgdG8gc3RvcmUgdGhlIHdyYXBwZXJzXG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KCBhcnJheSwgJ19yYWN0aXZlJywge1xuXHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHR3cmFwcGVyczogW10sXG5cdFx0XHRcdFx0XHRpbnN0YW5jZXM6IFtdLFxuXHRcdFx0XHRcdFx0c2V0dGluZzogZmFsc2Vcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHBhdGNoKCBhcnJheSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3RvcmUgdGhlIHJhY3RpdmUgaW5zdGFuY2UsIHNvIHdlIGNhbiBoYW5kbGUgdHJhbnNpdGlvbnMgbGF0ZXJcblx0XHRcdGlmICggIWFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdICkge1xuXHRcdFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbIHJhY3RpdmUuX2d1aWQgXSA9IDA7XG5cdFx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlcy5wdXNoKCByYWN0aXZlICk7XG5cdFx0XHR9XG5cdFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbIHJhY3RpdmUuX2d1aWQgXSArPSAxO1xuXHRcdFx0YXJyYXkuX3JhY3RpdmUud3JhcHBlcnMucHVzaCggdGhpcyApO1xuXHRcdH07XG5cdFx0QXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFycmF5LCBzdG9yYWdlLCB3cmFwcGVycywgaW5zdGFuY2VzLCBpbmRleDtcblx0XHRcdFx0YXJyYXkgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHRzdG9yYWdlID0gYXJyYXkuX3JhY3RpdmU7XG5cdFx0XHRcdHdyYXBwZXJzID0gc3RvcmFnZS53cmFwcGVycztcblx0XHRcdFx0aW5zdGFuY2VzID0gc3RvcmFnZS5pbnN0YW5jZXM7XG5cdFx0XHRcdC8vIGlmIHRlYXJkb3duKCkgd2FzIGludm9rZWQgYmVjYXVzZSB3ZSdyZSBjbGVhcmluZyB0aGUgY2FjaGUgYXMgYSByZXN1bHQgb2Zcblx0XHRcdFx0Ly8gYSBjaGFuZ2UgdGhhdCB0aGUgYXJyYXkgaXRzZWxmIHRyaWdnZXJlZCwgd2UgY2FuIHNhdmUgb3Vyc2VsdmVzIHRoZSB0ZWFyZG93blxuXHRcdFx0XHQvLyBhbmQgaW1tZWRpYXRlIHNldHVwXG5cdFx0XHRcdGlmICggc3RvcmFnZS5zZXR0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdC8vIGlmIG5vdGhpbmcgZWxzZSBkZXBlbmRzIG9uIHRoaXMgYXJyYXksIHdlIGNhbiByZXZlcnQgaXQgdG8gaXRzXG5cdFx0XHRcdC8vIG5hdHVyYWwgc3RhdGVcblx0XHRcdFx0aWYgKCAhd3JhcHBlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGRlbGV0ZSBhcnJheS5fcmFjdGl2ZTtcblx0XHRcdFx0XHRwYXRjaC51bnBhdGNoKCB0aGlzLnZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHJhY3RpdmUgaW5zdGFuY2UgaWYgcG9zc2libGVcblx0XHRcdFx0XHRpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdIC09IDE7XG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2VzWyB0aGlzLnJvb3QuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gaW5zdGFuY2VzLmluZGV4T2YoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbnN0YW5jZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0ZXJyb3JNZXNzYWdlID0gJ1NvbWV0aGluZyB3ZW50IHdyb25nIGluIGEgcmF0aGVyIGludGVyZXN0aW5nIHdheSc7XG5cdFx0cmV0dXJuIGFycmF5QWRhcHRvcjtcblx0fSggZGVmaW5lUHJvcGVydHksIGlzQXJyYXksIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3BhdGNoICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvbWFnaWNBcnJheUFkYXB0b3IuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfbWFnaWNBcnJheUFkYXB0b3IgPSBmdW5jdGlvbiggbWFnaWNBZGFwdG9yLCBhcnJheUFkYXB0b3IgKSB7XG5cblx0XHR2YXIgbWFnaWNBcnJheUFkYXB0b3IsIE1hZ2ljQXJyYXlXcmFwcGVyO1xuXHRcdGlmICggbWFnaWNBZGFwdG9yICkge1xuXHRcdFx0bWFnaWNBcnJheUFkYXB0b3IgPSB7XG5cdFx0XHRcdGZpbHRlcjogZnVuY3Rpb24oIG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWFnaWNBZGFwdG9yLmZpbHRlciggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkgJiYgYXJyYXlBZGFwdG9yLmZpbHRlciggb2JqZWN0ICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljQXJyYXlXcmFwcGVyKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSBhcnJheTtcblx0XHRcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyID0gbWFnaWNBZGFwdG9yLndyYXAoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuYXJyYXlXcmFwcGVyID0gYXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5hcnJheVdyYXBwZXIudGVhcmRvd24oKTtcblx0XHRcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlci50ZWFyZG93bigpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm1hZ2ljV3JhcHBlci5yZXNldCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hZ2ljQXJyYXlBZGFwdG9yO1xuXHR9KCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3IgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FkYXB0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkYWRhcHQgPSBmdW5jdGlvbiggY29uZmlnLCBhcnJheUFkYXB0b3IsIGxvZywgbWFnaWNBZGFwdG9yLCBtYWdpY0FycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgcHJlZml4ZXJzID0ge307XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkYWRhcHQoIGtleXBhdGgsIHZhbHVlICkge1xuXHRcdFx0dmFyIHJhY3RpdmUgPSB0aGlzLnJhY3RpdmUsXG5cdFx0XHRcdGxlbiwgaSwgYWRhcHRvciwgd3JhcHBlZDtcblx0XHRcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cblx0XHRcdGxlbiA9IHJhY3RpdmUuYWRhcHQubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0YWRhcHRvciA9IHJhY3RpdmUuYWRhcHRbIGkgXTtcblx0XHRcdFx0Ly8gQWRhcHRvcnMgY2FuIGJlIHNwZWNpZmllZCBhcyBlLmcuIFsgJ0JhY2tib25lLk1vZGVsJywgJ0JhY2tib25lLkNvbGxlY3Rpb24nIF0gLVxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGdldCB0aGUgYWN0dWFsIGFkYXB0b3IgaWYgdGhhdCdzIHRoZSBjYXNlXG5cdFx0XHRcdGlmICggdHlwZW9mIGFkYXB0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHZhciBmb3VuZCA9IGNvbmZpZy5yZWdpc3RyaWVzLmFkYXB0b3JzLmZpbmQoIHJhY3RpdmUsIGFkYXB0b3IgKTtcblx0XHRcdFx0XHRpZiAoICFmb3VuZCApIHtcblx0XHRcdFx0XHRcdC8vIHdpbGwgdGhyb3cuIFwicmV0dXJuXCIgZm9yIHNhZmV0eSwgaWYgd2UgZG93bmdyYWRlIDopXG5cdFx0XHRcdFx0XHRyZXR1cm4gbG9nLmNyaXRpY2FsKCB7XG5cdFx0XHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRwbHVnaW46ICdhZGFwdG9yJyxcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBhZGFwdG9yXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YWRhcHRvciA9IHJhY3RpdmUuYWRhcHRbIGkgXSA9IGZvdW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0d3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCwgZ2V0UHJlZml4ZXIoIGtleXBhdGggKSApO1xuXHRcdFx0XHRcdHdyYXBwZWQudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS5tYWdpYyApIHtcblx0XHRcdFx0aWYgKCBtYWdpY0FycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBtYWdpY0FycmF5QWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYWdpY0FkYXB0b3IuZmlsdGVyKCB2YWx1ZSwga2V5cGF0aCwgcmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbWFnaWNBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHJhY3RpdmUubW9kaWZ5QXJyYXlzICYmIGFycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByZWZpeEtleXBhdGgoIG9iaiwgcHJlZml4ICkge1xuXHRcdFx0dmFyIHByZWZpeGVkID0ge30sXG5cdFx0XHRcdGtleTtcblx0XHRcdGlmICggIXByZWZpeCApIHtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdHByZWZpeCArPSAnLic7XG5cdFx0XHRmb3IgKCBrZXkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0cHJlZml4ZWRbIHByZWZpeCArIGtleSBdID0gb2JqWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWZpeGVkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByZWZpeGVyKCByb290S2V5cGF0aCApIHtcblx0XHRcdHZhciByb290RG90O1xuXHRcdFx0aWYgKCAhcHJlZml4ZXJzWyByb290S2V5cGF0aCBdICkge1xuXHRcdFx0XHRyb290RG90ID0gcm9vdEtleXBhdGggPyByb290S2V5cGF0aCArICcuJyA6ICcnO1xuXHRcdFx0XHRwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF0gPSBmdW5jdGlvbiggcmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgb2JqO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRvYmogPSB7fTtcblx0XHRcdFx0XHRcdG9ialsgcm9vdERvdCArIHJlbGF0aXZlS2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcblx0XHRcdFx0XHRcdHJldHVybiByb290RG90ID8gcHJlZml4S2V5cGF0aCggcmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCApIDogcmVsYXRpdmVLZXlwYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY29uZmlnLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciwgbG9nLCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciwgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9oZWxwZXJzL2dldFVwc3RyZWFtQ2hhbmdlcy5qcyAqL1xuXHR2YXIgZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZnVuY3Rpb24gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICkge1xuXHRcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbICcnIF0sXG5cdFx0XHRpLCBrZXlwYXRoLCBrZXlzLCB1cHN0cmVhbUtleXBhdGg7XG5cdFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0a2V5cGF0aCA9IGNoYW5nZXNbIGkgXTtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHR1cHN0cmVhbUtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRpZiAoIHVwc3RyZWFtQ2hhbmdlcy5pbmRleE9mKCB1cHN0cmVhbUtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLnB1c2goIHVwc3RyZWFtS2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cHN0cmVhbUNoYW5nZXM7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBzdGFyTWFwcyA9IHt9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBrZXlwYXRoIHN1Y2ggYXMgJ2Zvby5iYXIuYmF6JywgYW5kIHJldHVybnNcblx0XHQvLyBhbGwgdGhlIHZhcmlhbnRzIG9mIHRoYXQga2V5cGF0aCB0aGF0IGluY2x1ZGUgYSB3aWxkY2FyZCBpbiBwbGFjZVxuXHRcdC8vIG9mIGEga2V5LCBzdWNoIGFzICdmb28uYmFyLionLCAnZm9vLiouYmF6JywgJ2Zvby4qLionIGFuZCBzbyBvbi5cblx0XHQvLyBUaGVzZSBhcmUgdGhlbiBjaGVja2VkIGFnYWluc3QgdGhlIGRlcGVuZGFudHMgbWFwIChyYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwKVxuXHRcdC8vIHRvIHNlZSBpZiBhbnkgcGF0dGVybiBvYnNlcnZlcnMgYXJlIGRvd25zdHJlYW0gb2Ygb25lIG9yIG1vcmUgb2Zcblx0XHQvLyB0aGVzZSB3aWxkY2FyZCBrZXlwYXRocyAoZS5nLiAnZm9vLmJhci4qLnN0YXR1cycpXG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCByZXN1bHQ7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRzdGFyTWFwID0gZ2V0U3Rhck1hcCgga2V5cy5sZW5ndGggKTtcblx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBzdGFyLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gc3RhciA/ICcqJyA6IGtleXNbIGkgXTtcblx0XHRcdH07XG5cdFx0XHRyZXN1bHQgPSBzdGFyTWFwLm1hcCggZnVuY3Rpb24oIG1hc2sgKSB7XG5cdFx0XHRcdHJldHVybiBtYXNrLm1hcCggbWFwcGVyICkuam9pbiggJy4nICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCB0aGUgcG9zc2libGUgdHJ1ZS9mYWxzZSBjb21iaW5hdGlvbnMgZm9yXG5cdFx0Ly8gYSBnaXZlbiBudW1iZXIgLSBlLmcuIGZvciB0d28sIHRoZSBwb3NzaWJsZSBjb21iaW5hdGlvbnMgYXJlXG5cdFx0Ly8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuXHRcdC8vIEl0IGRvZXMgc28gYnkgZ2V0dGluZyBhbGwgdGhlIGJpbmFyeSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCBlLmcuIDExXG5cdFx0ZnVuY3Rpb24gZ2V0U3Rhck1hcCggbGVuZ3RoICkge1xuXHRcdFx0dmFyIG9uZXMgPSAnJyxcblx0XHRcdFx0bWF4LCBiaW5hcnksIHN0YXJNYXAsIG1hcHBlciwgaTtcblx0XHRcdGlmICggIXN0YXJNYXBzWyBsZW5ndGggXSApIHtcblx0XHRcdFx0c3Rhck1hcCA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIG9uZXMubGVuZ3RoIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdG9uZXMgKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXggPSBwYXJzZUludCggb25lcywgMiApO1xuXHRcdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggZGlnaXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRpZ2l0ID09PSAnMSc7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IG1heDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGJpbmFyeSA9IGkudG9TdHJpbmcoIDIgKTtcblx0XHRcdFx0XHR3aGlsZSAoIGJpbmFyeS5sZW5ndGggPCBsZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRiaW5hcnkgPSAnMCcgKyBiaW5hcnk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YXJNYXBbIGkgXSA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCggYmluYXJ5LCBtYXBwZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFyTWFwc1sgbGVuZ3RoIF0gPSBzdGFyTWFwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0YXJNYXBzWyBsZW5ndGggXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvbm90aWZ5UGF0dGVybk9ic2VydmVycy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gZnVuY3Rpb24oIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgbGFzdEtleSA9IC9bXlxcLl0rJC87XG5cdFx0X19leHBvcnQgPSBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzO1xuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoLCBvbmx5RGlyZWN0ICkge1xuXHRcdFx0dmFyIHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblx0XHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIG9ubHlEaXJlY3QgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcygga2V5cGF0aCApO1xuXHRcdFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmZvckVhY2goIGZ1bmN0aW9uKCB1cHN0cmVhbVBhdHRlcm4gKSB7XG5cdFx0XHRcdGNhc2NhZGUoIHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FzY2FkZSggdmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgZ3JvdXAsIG1hcCwgYWN0dWFsQ2hpbGRLZXlwYXRoO1xuXHRcdFx0Z3JvdXAgPSB2aWV3bW9kZWwuZGVwc01hcC5wYXR0ZXJuT2JzZXJ2ZXJzO1xuXHRcdFx0bWFwID0gZ3JvdXBbIHVwc3RyZWFtUGF0dGVybiBdO1xuXHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdG1hcC5mb3JFYWNoKCBmdW5jdGlvbiggY2hpbGRLZXlwYXRoICkge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBsYXN0S2V5LmV4ZWMoIGNoaWxkS2V5cGF0aCApWyAwIF07XG5cdFx0XHRcdFx0Ly8gJ2Jheidcblx0XHRcdFx0XHRhY3R1YWxDaGlsZEtleXBhdGggPSBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0XHQvLyAnZm9vLmJhci5iYXonXG5cdFx0XHRcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGFjdHVhbENoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdGNhc2NhZGUoIHZpZXdtb2RlbCwgY2hpbGRLZXlwYXRoLCBhY3R1YWxDaGlsZEtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG9ic2VydmVyICkge1xuXHRcdFx0XHRpZiAoIG9ic2VydmVyLnJlZ2V4LnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRvYnNlcnZlci51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXMgPSBmdW5jdGlvbiggZ2V0VXBzdHJlYW1DaGFuZ2VzLCBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJGFwcGx5Q2hhbmdlcygpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRjaGFuZ2VzLCB1cHN0cmVhbUNoYW5nZXMsIGhhc2ggPSB7fTtcblx0XHRcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cdFx0XHRpZiAoICFjaGFuZ2VzLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gVE9ETyB3ZSBlbmQgdXAgaGVyZSBvbiBpbml0aWFsIHJlbmRlci4gUGVyaGFwcyB3ZSBzaG91bGRuJ3Q/XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FzY2FkZSgga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG1hcCwgZGVwZW5kYW50cywga2V5cztcblx0XHRcdFx0aWYgKCBzZWxmLm5vQ2FzY2FkZS5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGRlcGVuZGFudHMgPSBzZWxmLmRlcHMuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRkZXBlbmRhbnRzLmZvckVhY2goIGludmFsaWRhdGUgKTtcblx0XHRcdFx0XHRrZXlzID0gZGVwZW5kYW50cy5tYXAoIGdldEtleSApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggbWFyayApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0bWFwLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBtYXJrKCBrZXlwYXRoICkge1xuXHRcdFx0XHRzZWxmLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdGNoYW5nZXMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0dXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICk7XG5cdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBkZXBlbmRhbnRzLCBrZXlzO1xuXHRcdFx0XHRpZiAoIGRlcGVuZGFudHMgPSBzZWxmLmRlcHMuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRkZXBlbmRhbnRzLmZvckVhY2goIGludmFsaWRhdGUgKTtcblx0XHRcdFx0XHRrZXlzID0gZGVwZW5kYW50cy5tYXAoIGdldEtleSApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggbWFyayApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmNoYW5nZXMgPSBbXTtcblx0XHRcdC8vIFBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBhIHdlaXJkIHNwZWNpYWwgY2FzZVxuXHRcdFx0aWYgKCB0aGlzLnBhdHRlcm5PYnNlcnZlcnMubGVuZ3RoICkge1xuXHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMoIHRoaXMkMCwga2V5cGF0aCwgdHJ1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMoIHRoaXMkMCwga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZGVwcy5vYnNlcnZlcnMgKSB7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB0aGlzJDAsIG51bGwsIGtleXBhdGgsICdvYnNlcnZlcnMnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyggdGhpcywgY2hhbmdlcywgJ29ic2VydmVycycgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZXBzWyAnZGVmYXVsdCcgXSApIHtcblx0XHRcdFx0dmFyIGJpbmRpbmdzID0gW107XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB0aGlzJDAsIGJpbmRpbmdzLCBrZXlwYXRoLCAnZGVmYXVsdCcgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGJpbmRpbmdzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRub3RpZnlCaW5kaW5ncyggdGhpcywgYmluZGluZ3MsIGNoYW5nZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKCB0aGlzLCBjaGFuZ2VzLCAnZGVmYXVsdCcgKTtcblx0XHRcdH1cblx0XHRcdC8vIFJldHVybiBhIGhhc2ggb2Yga2V5cGF0aHMgdG8gdXBkYXRlZCB2YWx1ZXNcblx0XHRcdGNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdGhhc2hbIGtleXBhdGggXSA9IHRoaXMkMC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG5cdFx0XHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGludmFsaWRhdGUoIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEtleSggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0YXRpb24ua2V5O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyggdmlld21vZGVsLCBiaW5kaW5ncywga2V5cGF0aCwgZ3JvdXBOYW1lICkge1xuXHRcdFx0dmFyIGRlcGVuZGFudHMsIHZhbHVlO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gZmluZERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gdmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRkZXBlbmRhbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBkICkge1xuXHRcdFx0XHRcdC8vIGRvbid0IFwic2V0XCIgdGhlIHBhcmVudCB2YWx1ZSwgcmVmaW5lIGl0XG5cdFx0XHRcdFx0Ly8gaS5lLiBub3QgZGF0YSA9IHZhbHVlLCBidXQgZGF0YVtmb29dID0gZm9vVmFsdWVcblx0XHRcdFx0XHRpZiAoIGJpbmRpbmdzICYmIGQucmVmaW5lVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBkICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGQuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5QmluZGluZ3MoIHZpZXdtb2RlbCwgYmluZGluZ3MsIGNoYW5nZXMgKSB7XG5cdFx0XHRiaW5kaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0dmFyIHVzZVNldCA9IGZhbHNlLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdGxlbmd0aCA9IGNoYW5nZXMubGVuZ3RoLFxuXHRcdFx0XHRcdHJlZmluZW1lbnRzID0gW107XG5cdFx0XHRcdHdoaWxlICggaSA8IGxlbmd0aCApIHtcblx0XHRcdFx0XHR2YXIga2V5cGF0aCA9IGNoYW5nZXNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGggPT09IGJpbmRpbmcua2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHVzZVNldCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoLnNsaWNlKCAwLCBiaW5kaW5nLmtleXBhdGgubGVuZ3RoICkgPT09IGJpbmRpbmcua2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJlZmluZW1lbnRzLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdXNlU2V0ICkge1xuXHRcdFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUoIHZpZXdtb2RlbC5nZXQoIGJpbmRpbmcua2V5cGF0aCApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCByZWZpbmVtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0YmluZGluZy5yZWZpbmVWYWx1ZSggcmVmaW5lbWVudHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeUFsbERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdFx0YWRkS2V5cGF0aHMoIGtleXBhdGhzICk7XG5cdFx0XHRxdWV1ZS5mb3JFYWNoKCBkaXNwYXRjaCApO1xuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRocygga2V5cGF0aHMgKSB7XG5cdFx0XHRcdGtleXBhdGhzLmZvckVhY2goIGFkZEtleXBhdGggKTtcblx0XHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRoKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgZGVwcyA9IGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApO1xuXHRcdFx0XHRpZiAoIGRlcHMgKSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCgge1xuXHRcdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcblx0XHRcdFx0XHRcdGRlcHM6IGRlcHNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FzY2FkZSgga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGNoaWxkRGVwcztcblx0XHRcdFx0aWYgKCBjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXBOYW1lIF1bIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRhZGRLZXlwYXRocyggY2hpbGREZXBzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZGlzcGF0Y2goIHNldCApIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldCggc2V0LmtleXBhdGggKTtcblx0XHRcdFx0c2V0LmRlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5kRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB2aWV3bW9kZWwuZGVwc1sgZ3JvdXBOYW1lIF07XG5cdFx0XHRyZXR1cm4gZ3JvdXAgPyBncm91cFsga2V5cGF0aCBdIDogbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBnZXRVcHN0cmVhbUNoYW5nZXMsIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvY2FwdHVyZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGNhcHR1cmUgPSBmdW5jdGlvbiBWaWV3bW9kZWwkY2FwdHVyZSgpIHtcblx0XHR0aGlzLmNhcHR1cmVHcm91cHMucHVzaCggW10gKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2NsZWFyQ2FjaGUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRjbGVhckNhY2hlID0gZnVuY3Rpb24gVmlld21vZGVsJGNsZWFyQ2FjaGUoIGtleXBhdGgsIGRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0dmFyIGNhY2hlTWFwLCB3cmFwcGVyO1xuXHRcdGlmICggIWRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0XHQvLyBJcyB0aGVyZSBhIHdyYXBwZWQgcHJvcGVydHkgYXQgdGhpcyBrZXlwYXRoP1xuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdC8vIERpZCB3ZSB1bndyYXAgaXQ/XG5cdFx0XHRcdGlmICggd3JhcHBlci50ZWFyZG93bigpICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHQvLyBJcyB0aGlzIHJpZ2h0P1xuXHRcdFx0XHRcdC8vIFdoYXQncyB0aGUgbWVhbmluZyBvZiByZXR1cm5pbmcgZmFsc2UgZnJvbSB0ZWFyZG93bj9cblx0XHRcdFx0XHQvLyBDb3VsZCB0aGVyZSBiZSBhIEdDIHJhbWlmaWNhdGlvbiBpZiB0aGlzIGlzIGEgXCJyZWFsXCIgcmFjdGl2ZS50ZWFyZG93bigpP1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmNhY2hlWyBrZXlwYXRoIF0gPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCBjYWNoZU1hcCA9IHRoaXMuY2FjaGVNYXBbIGtleXBhdGggXSApIHtcblx0XHRcdHdoaWxlICggY2FjaGVNYXAubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoIGNhY2hlTWFwLnBvcCgpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9nZXRDb21wdXRhdGlvblNpZ25hdHVyZS5qcyAqL1xuXHR2YXIgZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgcGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBzaWduYXR1cmUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBzaWduYXR1cmVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0c2lnbmF0dXJlID0ge1xuXHRcdFx0XHRcdGdldDogY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKCBzaWduYXR1cmUuZ2V0ICksXG5cdFx0XHRcdFx0c2V0OiBzaWduYXR1cmUuc2V0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2lnbmF0dXJlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApIHtcblx0XHRcdHZhciBmdW5jdGlvbkJvZHkgPSAndmFyIF9fcmFjdGl2ZT10aGlzO3JldHVybignICsgc2lnbmF0dXJlLnJlcGxhY2UoIHBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuICdfX3JhY3RpdmUuZ2V0KFwiJyArIGtleXBhdGggKyAnXCIpJztcblx0XHRcdH0gKSArICcpJztcblx0XHRcdHJldHVybiBuZXcgRnVuY3Rpb24oIGZ1bmN0aW9uQm9keSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvQ29tcHV0YXRpb24vQ29tcHV0YXRpb24uanMgKi9cblx0dmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24oIGxvZywgaXNFcXVhbCApIHtcblxuXHRcdHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXksIHNpZ25hdHVyZSApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMudmlld21vZGVsID0gcmFjdGl2ZS52aWV3bW9kZWw7XG5cdFx0XHR0aGlzLmtleSA9IGtleTtcblx0XHRcdHRoaXMuZ2V0dGVyID0gc2lnbmF0dXJlLmdldDtcblx0XHRcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldDtcblx0XHRcdHRoaXMuaGFyZERlcHMgPSBzaWduYXR1cmUuZGVwcyB8fCBbXTtcblx0XHRcdHRoaXMuc29mdERlcHMgPSBbXTtcblx0XHRcdHRoaXMuZGVwVmFsdWVzID0ge307XG5cdFx0XHRpZiAoIHRoaXMuaGFyZERlcHMgKSB7XG5cdFx0XHRcdHRoaXMuaGFyZERlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJhY3RpdmUudmlld21vZGVsLnJlZ2lzdGVyKCBkLCB0aGlzJDAsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGlydHkgPSB0aGlzLl9maXJzdFJ1biA9IHRydWU7XG5cdFx0fTtcblx0XHRDb21wdXRhdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRjb25zdHJ1Y3RvcjogQ29tcHV0YXRpb24sXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluaXRpYWw7XG5cdFx0XHRcdHRoaXMuYnlwYXNzID0gdHJ1ZTtcblx0XHRcdFx0aW5pdGlhbCA9IHRoaXMucmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleSApO1xuXHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLmNsZWFyQ2FjaGUoIHRoaXMua2V5ICk7XG5cdFx0XHRcdHRoaXMuYnlwYXNzID0gZmFsc2U7XG5cdFx0XHRcdGlmICggdGhpcy5zZXR0ZXIgJiYgaW5pdGlhbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0KCBpbml0aWFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgcmFjdGl2ZSwgbmV3RGVwcywgZGVwZW5kZW5jaWVzQ2hhbmdlZCwgZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCB0aGlzLmdldHRpbmcgKSB7XG5cdFx0XHRcdFx0Ly8gcHJldmVudCBkb3VibGUtY29tcHV0YXRpb24gKGUuZy4gY2F1c2VkIGJ5IGFycmF5IG11dGF0aW9uIGluc2lkZSBjb21wdXRhdGlvbilcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5nZXR0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB0aGlzLl9kaXJ0eSApIHtcblx0XHRcdFx0XHRyYWN0aXZlID0gdGhpcy5yYWN0aXZlO1xuXHRcdFx0XHRcdC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBpbnB1dHMgaGF2ZSBjaGFuZ2VkLCBpbiBjYXNlIHRoaXMgZGVwZW5kcyBvblxuXHRcdFx0XHRcdC8vIG90aGVyIGNvbXB1dGVkIHZhbHVlc1xuXHRcdFx0XHRcdGlmICggdGhpcy5fZmlyc3RSdW4gfHwgIXRoaXMuaGFyZERlcHMubGVuZ3RoICYmICF0aGlzLnNvZnREZXBzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHR0aGlzLmhhcmREZXBzLFxuXHRcdFx0XHRcdFx0XHR0aGlzLnNvZnREZXBzXG5cdFx0XHRcdFx0XHRdLmZvckVhY2goIGZ1bmN0aW9uKCBkZXBzICkge1xuXHRcdFx0XHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWUsIGk7XG5cdFx0XHRcdFx0XHRcdGlmICggZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGkgPSBkZXBzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0a2V5cGF0aCA9IGRlcHNbIGkgXTtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzJDAuZGVwVmFsdWVzWyBrZXlwYXRoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMkMC5kZXBWYWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkICkge1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuY2FwdHVyZSgpO1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwoIHJhY3RpdmUgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ2ZhaWxlZENvbXB1dGF0aW9uJyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRrZXk6IHRoaXMua2V5LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyOiBlcnIubWVzc2FnZSB8fCBlcnJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZvaWQgMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5ld0RlcHMgPSByYWN0aXZlLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG5cdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdGhpcy51cGRhdGVEZXBlbmRlbmNpZXMoIG5ld0RlcHMgKTtcblx0XHRcdFx0XHRcdGlmICggZGVwZW5kZW5jaWVzQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuaGFyZERlcHMsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zb2Z0RGVwc1xuXHRcdFx0XHRcdFx0XHRdLmZvckVhY2goIGZ1bmN0aW9uKCBkZXBzICkge1xuXHRcdFx0XHRcdFx0XHRcdGRlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzJDAuZGVwVmFsdWVzWyBrZXlwYXRoIF0gPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmdldHRpbmcgPSB0aGlzLl9maXJzdFJ1biA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF0aGlzLnNldHRlciApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb21wdXRlZCBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVycyBhcmUgcmVhZC1vbmx5LiAoVGhpcyBtYXkgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZSEpJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2V0dGVyLmNhbGwoIHRoaXMucmFjdGl2ZSwgdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGVEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uKCBuZXdEZXBzICkge1xuXHRcdFx0XHR2YXIgaSwgb2xkRGVwcywga2V5cGF0aCwgZGVwZW5kZW5jaWVzQ2hhbmdlZDtcblx0XHRcdFx0b2xkRGVwcyA9IHRoaXMuc29mdERlcHM7XG5cdFx0XHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcblx0XHRcdFx0aSA9IG9sZERlcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRrZXlwYXRoID0gb2xkRGVwc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggbmV3RGVwcy5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCB0aGlzLCAnY29tcHV0ZWQnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNyZWF0ZSByZWZlcmVuY2VzIGZvciBhbnkgbmV3IGRlcGVuZGVuY2llc1xuXHRcdFx0XHRpID0gbmV3RGVwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGtleXBhdGggPSBuZXdEZXBzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvbGREZXBzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgJiYgKCAhdGhpcy5oYXJkRGVwcyB8fCB0aGlzLmhhcmREZXBzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSApIHtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBkZXBlbmRlbmNpZXNDaGFuZ2VkICkge1xuXHRcdFx0XHRcdHRoaXMuc29mdERlcHMgPSBuZXdEZXBzLnNsaWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRlcGVuZGVuY2llc0NoYW5nZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcHV0YXRpb247XG5cdH0oIGxvZywgaXNFcXVhbCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvY29tcHV0ZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGNvbXB1dGUgPSBmdW5jdGlvbiggZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUsIENvbXB1dGF0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFZpZXdtb2RlbCRjb21wdXRlKCBrZXksIHNpZ25hdHVyZSApIHtcblx0XHRcdHNpZ25hdHVyZSA9IGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKCBzaWduYXR1cmUgKTtcblx0XHRcdHJldHVybiB0aGlzLmNvbXB1dGF0aW9uc1sga2V5IF0gPSBuZXcgQ29tcHV0YXRpb24oIHRoaXMucmFjdGl2ZSwga2V5LCBzaWduYXR1cmUgKTtcblx0XHR9O1xuXHR9KCBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSwgQ29tcHV0YXRpb24gKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9GQUlMRURfTE9PS1VQLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X0ZBSUxFRF9MT09LVVAgPSB7XG5cdFx0RkFJTEVEX0xPT0tVUDogdHJ1ZVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHR2YXIgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblx0XHRcdHRoaXMucm9vdCA9IHZpZXdtb2RlbC5yYWN0aXZlO1xuXHRcdFx0Ly8gVE9ETyBlbGltaW5hdGUgdGhpc1xuXHRcdFx0dGhpcy5yZWYgPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVtcHR5O1xuXHRcdFx0dmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdHZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucHVzaCggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCB0aGlzLnJlZiApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIHRoaXMucmVmIF0gPSBmYWxzZTtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cdH0oIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0ID0gZnVuY3Rpb24oIGlzTnVtZXJpYywgRkFJTEVEX0xPT0tVUCwgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRnZXQoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0gZW1wdHk7XG5cdFx0XHR2YXIgcmFjdGl2ZSA9IHRoaXMucmFjdGl2ZSxcblx0XHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlLFxuXHRcdFx0XHR2YWx1ZSwgY29tcHV0YXRpb24sIHdyYXBwZWQsIGNhcHR1cmVHcm91cDtcblx0XHRcdGlmICgga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdHZhbHVlID0ga2V5cGF0aC5zbGljZSggMSApO1xuXHRcdFx0XHRyZXR1cm4gaXNOdW1lcmljKCB2YWx1ZSApID8gK3ZhbHVlIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGNhY2hlWyBrZXlwYXRoIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gSXMgdGhpcyBhIGNvbXB1dGVkIHByb3BlcnR5P1xuXHRcdFx0XHRpZiAoICggY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdICkgJiYgIWNvbXB1dGF0aW9uLmJ5cGFzcyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuXHRcdFx0XHRcdHRoaXMuYWRhcHQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHdyYXBwZWQgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoICFrZXlwYXRoICkge1xuXHRcdFx0XHRcdHRoaXMuYWRhcHQoICcnLCByYWN0aXZlLmRhdGEgKTtcblx0XHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUuZGF0YTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJldHJpZXZlKCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSBjYWNoZVsga2V5cGF0aCBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLmV2YWx1YXRlV3JhcHBlZCAmJiAoIHdyYXBwZWQgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXB0dXJlIHRoZSBrZXlwYXRoLCBpZiB3ZSdyZSBpbnNpZGUgYSBjb21wdXRhdGlvblxuXHRcdFx0aWYgKCBvcHRpb25zLmNhcHR1cmUgJiYgKCBjYXB0dXJlR3JvdXAgPSB0aGlzLmNhcHR1cmVHcm91cHNbIHRoaXMuY2FwdHVyZUdyb3Vwcy5sZW5ndGggLSAxIF0gKSApIHtcblx0XHRcdFx0aWYgKCAhfmNhcHR1cmVHcm91cC5pbmRleE9mKCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0Y2FwdHVyZUdyb3VwLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0XHQvLyBpZiB3ZSBjb3VsZG4ndCByZXNvbHZlIHRoZSBrZXlwYXRoLCB3ZSBuZWVkIHRvIG1ha2UgaXQgYXMgYSBmYWlsZWRcblx0XHRcdFx0XHQvLyBsb29rdXAsIHNvIHRoYXQgdGhlIGNvbXB1dGF0aW9uIHVwZGF0ZXMgY29ycmVjdGx5IG9uY2Ugd2UgQ0FOXG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZSB0aGUga2V5cGF0aFxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgJiYgdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIGtleXBhdGggXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdG5ldyBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5KCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmV0cmlldmUoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdGlmICggd3JhcHBlZCA9IHZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlZC5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyZW50VmFsdWUgPT09IG51bGwgfHwgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGNhY2hlIG1hcFxuXHRcdFx0aWYgKCAhKCBjYWNoZU1hcCA9IHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdID0gWyBrZXlwYXRoIF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGNhY2hlTWFwLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVNYXAucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG5cdFx0XHQvLyBzbyB0aGF0IHdlIGtub3cgdG8gcXVlcnkgcGFyZW50IHNjb3BlIChpZiBzdWNoIHRoZXJlIGJlKVxuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnICYmICEoIGtleSBpbiBwYXJlbnRWYWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdmlld21vZGVsLmNhY2hlWyBrZXlwYXRoIF0gPSBGQUlMRURfTE9PS1VQO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSBwYXJlbnRWYWx1ZVsga2V5IF07XG5cdFx0XHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG5cdFx0XHR2aWV3bW9kZWwuYWRhcHQoIGtleXBhdGgsIHZhbHVlLCBmYWxzZSApO1xuXHRcdFx0Ly8gVXBkYXRlIGNhY2hlXG5cdFx0XHR2aWV3bW9kZWwuY2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGlzTnVtZXJpYywgdmlld21vZGVsJGdldF9GQUlMRURfTE9PS1VQLCB2aWV3bW9kZWwkZ2V0X1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRpbml0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkaW5pdCgpIHtcblx0XHRcdHZhciBrZXksIGNvbXB1dGF0aW9uLCBjb21wdXRhdGlvbnMgPSBbXTtcblx0XHRcdGZvciAoIGtleSBpbiB0aGlzLnJhY3RpdmUuY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRlKCBrZXksIHRoaXMucmFjdGl2ZS5jb21wdXRlZFsga2V5IF0gKTtcblx0XHRcdFx0Y29tcHV0YXRpb25zLnB1c2goIGNvbXB1dGF0aW9uICk7XG5cdFx0XHR9XG5cdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaCggaW5pdCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0KCBjb21wdXRhdGlvbiApIHtcblx0XHRcdGNvbXB1dGF0aW9uLmluaXQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tYXJrLmpzICovXG5cdHZhciB2aWV3bW9kZWwkbWFyayA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRtYXJrKCBrZXlwYXRoLCBvcHRpb25zICkge1xuXHRcdHZhciBjb21wdXRhdGlvbjtcblx0XHQvLyBpbXBsaWNpdCBjaGFuZ2VzIChpLmUuIGBmb28ubGVuZ3RoYCBvbiBgcmFjdGl2ZS5wdXNoKCdmb28nLDQyKWApXG5cdFx0Ly8gc2hvdWxkIG5vdCBiZSBwaWNrZWQgdXAgYnkgcGF0dGVybiBvYnNlcnZlcnNcblx0XHRpZiAoIG9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMuaW1wbGljaXQgKSB7XG5cdFx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzWyBrZXlwYXRoIF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLm5vQ2FzY2FkZSApIHtcblx0XHRcdFx0dGhpcy5ub0Nhc2NhZGVbIGtleXBhdGggXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdICkge1xuXHRcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuY2hhbmdlcy5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICkge1xuXHRcdFx0dGhpcy5jaGFuZ2VzLnB1c2goIGtleXBhdGggKTtcblx0XHR9XG5cdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tZXJnZS9tYXBPbGRUb05ld0luZGV4LmpzICovXG5cdHZhciB2aWV3bW9kZWwkbWVyZ2VfbWFwT2xkVG9OZXdJbmRleCA9IGZ1bmN0aW9uKCBvbGRBcnJheSwgbmV3QXJyYXkgKSB7XG5cdFx0dmFyIHVzZWRJbmRpY2VzLCBmaXJzdFVudXNlZEluZGV4LCBuZXdJbmRpY2VzLCBjaGFuZ2VkO1xuXHRcdHVzZWRJbmRpY2VzID0ge307XG5cdFx0Zmlyc3RVbnVzZWRJbmRleCA9IDA7XG5cdFx0bmV3SW5kaWNlcyA9IG9sZEFycmF5Lm1hcCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG5cdFx0XHR2YXIgaW5kZXgsIHN0YXJ0LCBsZW47XG5cdFx0XHRzdGFydCA9IGZpcnN0VW51c2VkSW5kZXg7XG5cdFx0XHRsZW4gPSBuZXdBcnJheS5sZW5ndGg7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGluZGV4ID0gbmV3QXJyYXkuaW5kZXhPZiggaXRlbSwgc3RhcnQgKTtcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0ID0gaW5kZXggKyAxO1xuXHRcdFx0fSB3aGlsZSAoIHVzZWRJbmRpY2VzWyBpbmRleCBdICYmIHN0YXJ0IDwgbGVuICk7XG5cdFx0XHQvLyBrZWVwIHRyYWNrIG9mIHRoZSBmaXJzdCB1bnVzZWQgaW5kZXgsIHNvIHdlIGRvbid0IHNlYXJjaFxuXHRcdFx0Ly8gdGhlIHdob2xlIG9mIG5ld0FycmF5IGZvciBlYWNoIGl0ZW0gaW4gb2xkQXJyYXkgdW5uZWNlc3NhcmlseVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gZmlyc3RVbnVzZWRJbmRleCApIHtcblx0XHRcdFx0Zmlyc3RVbnVzZWRJbmRleCArPSAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCAhPT0gaSApIHtcblx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR1c2VkSW5kaWNlc1sgaW5kZXggXSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fSApO1xuXHRcdHJldHVybiBuZXdJbmRpY2VzO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWVyZ2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtZXJnZSA9IGZ1bmN0aW9uKCB3YXJuLCBtYXBPbGRUb05ld0luZGV4ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBjb21wYXJhdG9ycyA9IHt9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJG1lcmdlKCBrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG9sZEFycmF5LCBuZXdBcnJheSwgY29tcGFyYXRvciwgbmV3SW5kaWNlcztcblx0XHRcdHRoaXMubWFyaygga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyZSApIHtcblx0XHRcdFx0Y29tcGFyYXRvciA9IGdldENvbXBhcmF0b3JGdW5jdGlvbiggb3B0aW9ucy5jb21wYXJlICk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXkubWFwKCBjb21wYXJhdG9yICk7XG5cdFx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheS5tYXAoIGNvbXBhcmF0b3IgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHQvLyBmYWxsYmFjayB0byBhbiBpZGVudGl0eSBjaGVjayAtIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2UgaGF2ZVxuXHRcdFx0XHRcdC8vIHRvIGRvIG1vcmUgRE9NIG1hbmlwdWxhdGlvbiB0aGFuIHdlIHRob3VnaHQuLi5cblx0XHRcdFx0XHQvLyAuLi51bmxlc3Mgd2UncmUgaW4gZGVidWcgbW9kZSBvZiBjb3Vyc2Vcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGVidWcgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHdhcm4oICdNZXJnZSBvcGVyYXRpb246IGNvbXBhcmlzb24gZmFpbGVkLiBGYWxsaW5nIGJhY2sgdG8gaWRlbnRpdHkgY2hlY2tpbmcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuXHRcdFx0XHRcdG5ld0FycmF5ID0gYXJyYXk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuXHRcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuXHRcdFx0fVxuXHRcdFx0Ly8gZmluZCBuZXcgaW5kaWNlcyBmb3IgbWVtYmVycyBvZiBvbGRBcnJheVxuXHRcdFx0bmV3SW5kaWNlcyA9IG1hcE9sZFRvTmV3SW5kZXgoIG9sZEFycmF5LCBuZXdBcnJheSApO1xuXHRcdFx0dGhpcy5zbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMsIGN1cnJlbnRBcnJheS5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnkoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoIGl0ZW0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb21wYXJhdG9yRnVuY3Rpb24oIGNvbXBhcmF0b3IgKSB7XG5cdFx0XHQvLyBJZiBgY29tcGFyZWAgaXMgYHRydWVgLCB3ZSB1c2UgSlNPTi5zdHJpbmdpZnkgdG8gY29tcGFyZVxuXHRcdFx0Ly8gb2JqZWN0cyB0aGF0IGFyZSB0aGUgc2FtZSBzaGFwZSwgYnV0IG5vbi1pZGVudGljYWwgLSBpLmUuXG5cdFx0XHQvLyB7IGZvbzogJ2JhcicgfSAhPT0geyBmb286ICdiYXInIH1cblx0XHRcdGlmICggY29tcGFyYXRvciA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoICFjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdICkge1xuXHRcdFx0XHRcdGNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF0gPSBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtWyBjb21wYXJhdG9yIF07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBjb21wYXJhdG9yO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIGBjb21wYXJlYCBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaWRlbnRpZnlpbmcgZmllbGQgKG9yIGB0cnVlYCB0byB1c2UgSlNPTi5zdHJpbmdpZnkpJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdhcm4sIHZpZXdtb2RlbCRtZXJnZV9tYXBPbGRUb05ld0luZGV4ICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9yZWdpc3Rlci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHJlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkcmVnaXN0ZXIoIGtleXBhdGgsIGRlcGVuZGFudCApIHtcblx0XHRcdHZhciBncm91cCA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBncm91cCA9PT0gdm9pZCAwIClcblx0XHRcdFx0Z3JvdXAgPSAnZGVmYXVsdCc7XG5cdFx0XHR2YXIgZGVwc0J5S2V5cGF0aCwgZGVwcztcblx0XHRcdGlmICggZGVwZW5kYW50LmlzU3RhdGljICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZXBzQnlLZXlwYXRoID0gdGhpcy5kZXBzWyBncm91cCBdIHx8ICggdGhpcy5kZXBzWyBncm91cCBdID0ge30gKTtcblx0XHRcdGRlcHMgPSBkZXBzQnlLZXlwYXRoWyBrZXlwYXRoIF0gfHwgKCBkZXBzQnlLZXlwYXRoWyBrZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0ZGVwcy5wdXNoKCBkZXBlbmRhbnQgKTtcblx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZURlcGVuZGFudHNNYXAoIHRoaXMsIGtleXBhdGgsIGdyb3VwICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZURlcGVuZGFudHNNYXAoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXAgKSB7XG5cdFx0XHR2YXIga2V5cywgcGFyZW50S2V5cGF0aCwgbWFwLCBwYXJlbnQ7XG5cdFx0XHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXAgXSB8fCAoIHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdID0ge30gKTtcblx0XHRcdFx0cGFyZW50ID0gbWFwWyBwYXJlbnRLZXlwYXRoIF0gfHwgKCBtYXBbIHBhcmVudEtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRcdGlmICggcGFyZW50WyBrZXlwYXRoIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSA9IDA7XG5cdFx0XHRcdFx0cGFyZW50LnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSArPSAxO1xuXHRcdFx0XHRrZXlwYXRoID0gcGFyZW50S2V5cGF0aDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9yZWxlYXNlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkcmVsZWFzZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWxlYXNlKCkge1xuXHRcdHJldHVybiB0aGlzLmNhcHR1cmVHcm91cHMucG9wKCk7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9zZXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRzZXQgPSBmdW5jdGlvbiggaXNFcXVhbCwgY3JlYXRlQnJhbmNoICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJHNldCgga2V5cGF0aCwgdmFsdWUsIHNpbGVudCApIHtcblx0XHRcdHZhciBjb21wdXRhdGlvbiwgd3JhcHBlciwgZG9udFRlYXJkb3duV3JhcHBlcjtcblx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXTtcblx0XHRcdGlmICggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRcdGlmICggY29tcHV0YXRpb24uc2V0dGluZyApIHtcblx0XHRcdFx0XHQvLyBsZXQgdGhlIG90aGVyIGNvbXB1dGF0aW9uIHNldCgpIGhhbmRsZSB0aGluZ3MuLi5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29tcHV0YXRpb24uc2V0KCB2YWx1ZSApO1xuXHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpc0VxdWFsKCB0aGlzLmNhY2hlWyBrZXlwYXRoIF0sIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXTtcblx0XHRcdC8vIElmIHdlIGhhdmUgYSB3cmFwcGVyIHdpdGggYSBgcmVzZXQoKWAgbWV0aG9kLCB3ZSB0cnkgYW5kIHVzZSBpdC4gSWYgdGhlXG5cdFx0XHQvLyBgcmVzZXQoKWAgbWV0aG9kIHJldHVybnMgZmFsc2UsIHRoZSB3cmFwcGVyIHNob3VsZCBiZSB0b3JuIGRvd24sIGFuZFxuXHRcdFx0Ly8gKG1vc3QgbGlrZWx5KSBhIG5ldyBvbmUgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXJcblx0XHRcdGlmICggd3JhcHBlciAmJiB3cmFwcGVyLnJlc2V0ICkge1xuXHRcdFx0XHRkb250VGVhcmRvd25XcmFwcGVyID0gd3JhcHBlci5yZXNldCggdmFsdWUgKSAhPT0gZmFsc2U7XG5cdFx0XHRcdGlmICggZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWNvbXB1dGF0aW9uICYmICFkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRyZXNvbHZlU2V0KCB0aGlzLCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhc2lsZW50ICkge1xuXHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlJ3JlIHNldHRpbmcgYSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHRhcmdldCBrZXlwYXRoIChpLmUuXG5cdFx0XHRcdC8vIGNyZWF0aW5nIGEgZnJlc2ggYnJhbmNoKSAtIHdlIG5lZWQgdG8gY2xlYXIgdGhlIGNhY2hlLCBidXRcblx0XHRcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2Vcblx0XHRcdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVTZXQoIHZpZXdtb2RlbCwga2V5cGF0aCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIga2V5cywgbGFzdEtleSwgcGFyZW50S2V5cGF0aCwgd3JhcHBlciwgcGFyZW50VmFsdWUsIHdyYXBwZXJTZXQsIHZhbHVlU2V0O1xuXHRcdFx0d3JhcHBlclNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIuc2V0ICkge1xuXHRcdFx0XHRcdHdyYXBwZXIuc2V0KCBsYXN0S2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0XHR2YWx1ZVNldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0dmFsdWVTZXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhcGFyZW50VmFsdWUgKSB7XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSBjcmVhdGVCcmFuY2goIGxhc3RLZXkgKTtcblx0XHRcdFx0XHR2aWV3bW9kZWwuc2V0KCBwYXJlbnRLZXlwYXRoLCBwYXJlbnRWYWx1ZSwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudFZhbHVlWyBsYXN0S2V5IF0gPSB2YWx1ZTtcblx0XHRcdH07XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRsYXN0S2V5ID0ga2V5cy5wb3AoKTtcblx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0d3JhcHBlciA9IHZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF07XG5cdFx0XHRpZiAoIHdyYXBwZXIgKSB7XG5cdFx0XHRcdHdyYXBwZXJTZXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHQvLyBtYXkgaGF2ZSBiZWVuIHdyYXBwZWQgdmlhIHRoZSBhYm92ZSAuZ2V0KClcblx0XHRcdFx0Ly8gY2FsbCBvbiB2aWV3bW9kZWwgaWYgdGhpcyBpcyBmaXJzdCBhY2Nlc3MgdmlhIC5zZXQoKSFcblx0XHRcdFx0aWYgKCB3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXSApIHtcblx0XHRcdFx0XHR3cmFwcGVyU2V0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWVTZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGlzRXF1YWwsIGNyZWF0ZUJyYW5jaCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvc21hcnRVcGRhdGUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRzbWFydFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBpbXBsaWNpdE9wdGlvbiA9IHtcblx0XHRcdFx0aW1wbGljaXQ6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRub0Nhc2NhZGVPcHRpb24gPSB7XG5cdFx0XHRcdG5vQ2FzY2FkZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRzbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBkZXBlbmRhbnRzLCBvbGRMZW5ndGg7XG5cdFx0XHRvbGRMZW5ndGggPSBuZXdJbmRpY2VzLmxlbmd0aDtcblx0XHRcdC8vIEluZGljZXMgdGhhdCBhcmUgYmVpbmcgcmVtb3ZlZCBzaG91bGQgYmUgbWFya2VkIGFzIGRpcnR5XG5cdFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uKCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHRoaXMkMC5tYXJrKCBrZXlwYXRoICsgJy4nICsgb2xkSW5kZXgsIG5vQ2FzY2FkZU9wdGlvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBVcGRhdGUgdGhlIG1vZGVsXG5cdFx0XHQvLyBUT0RPIGFsbG93IGV4aXN0aW5nIGFycmF5IHRvIGJlIHVwZGF0ZWQgaW4gcGxhY2UsIHJhdGhlciB0aGFuIHJlcGxhY2VkP1xuXHRcdFx0dGhpcy5zZXQoIGtleXBhdGgsIGFycmF5LCB0cnVlICk7XG5cdFx0XHRpZiAoIGRlcGVuZGFudHMgPSB0aGlzLmRlcHNbICdkZWZhdWx0JyBdWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdGRlcGVuZGFudHMuZmlsdGVyKCBjYW5TaHVmZmxlICkuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQuc2h1ZmZsZSggbmV3SW5kaWNlcywgYXJyYXkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvbGRMZW5ndGggIT09IGFycmF5Lmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICsgJy5sZW5ndGgnLCBpbXBsaWNpdE9wdGlvbiApO1xuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IG9sZExlbmd0aDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCArICcuJyArIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkb24ndCBhbGxvdyByZW1vdmVkIGluZGV4ZXMgYmV5b25kIGVuZCBvZiBuZXcgYXJyYXkgdG8gdHJpZ2dlciByZWNvbXB1dGF0aW9uc1xuXHRcdFx0XHRmb3IgKCB2YXIgaSQwID0gYXJyYXkubGVuZ3RoOyBpJDAgPCBvbGRMZW5ndGg7IGkkMCArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCArICcuJyArIGkkMCwgbm9DYXNjYWRlT3B0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY2FuU2h1ZmZsZSggZGVwZW5kYW50ICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBkZXBlbmRhbnQuc2h1ZmZsZSA9PT0gJ2Z1bmN0aW9uJztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHRlYXJkb3duID0gZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuXHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdHZhciB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5O1xuXHRcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG5cdFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG5cdFx0T2JqZWN0LmtleXMoIHRoaXMuY2FjaGUgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiB0aGlzJDAuY2xlYXJDYWNoZSgga2V5cGF0aCApO1xuXHRcdH0gKTtcblx0XHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuXHRcdHdoaWxlICggdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLnBvcCgpICkge1xuXHRcdFx0dW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS50ZWFyZG93bigpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3VucmVnaXN0ZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCR1bnJlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkdW5yZWdpc3Rlcigga2V5cGF0aCwgZGVwZW5kYW50ICkge1xuXHRcdFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIGdyb3VwID09PSB2b2lkIDAgKVxuXHRcdFx0XHRncm91cCA9ICdkZWZhdWx0Jztcblx0XHRcdHZhciBkZXBzLCBpbmRleDtcblx0XHRcdGlmICggZGVwZW5kYW50LmlzU3RhdGljICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZXBzID0gdGhpcy5kZXBzWyBncm91cCBdWyBrZXlwYXRoIF07XG5cdFx0XHRpbmRleCA9IGRlcHMuaW5kZXhPZiggZGVwZW5kYW50ICk7XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MnICk7XG5cdFx0XHR9XG5cdFx0XHRkZXBzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZURlcGVuZGFudHNNYXAoIHRoaXMsIGtleXBhdGgsIGdyb3VwICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZURlcGVuZGFudHNNYXAoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXAgKSB7XG5cdFx0XHR2YXIga2V5cywgcGFyZW50S2V5cGF0aCwgbWFwLCBwYXJlbnQ7XG5cdFx0XHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXAgXTtcblx0XHRcdFx0cGFyZW50ID0gbWFwWyBwYXJlbnRLZXlwYXRoIF07XG5cdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdIC09IDE7XG5cdFx0XHRcdGlmICggIXBhcmVudFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSBmcm9tIHBhcmVudCBkZXBzIG1hcFxuXHRcdFx0XHRcdHBhcmVudC5zcGxpY2UoIHBhcmVudC5pbmRleE9mKCBrZXlwYXRoICksIDEgKTtcblx0XHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcGFyZW50S2V5cGF0aDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL2FkYXB0Q29uZmlnLmpzICovXG5cdHZhciBhZGFwdENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gc2hvdWxkIHRoaXMgYmUgY29tYmluZWQgd2l0aCBwcm90b3R5cGUvYWRhcHQuanM/XG5cdFx0dmFyIGNvbmZpZ3VyZSA9IHtcblx0XHRcdGxvb2t1cDogZnVuY3Rpb24oIHRhcmdldCwgYWRhcHRvcnMgKSB7XG5cdFx0XHRcdHZhciBpLCBhZGFwdCA9IHRhcmdldC5hZGFwdDtcblx0XHRcdFx0aWYgKCAhYWRhcHQgfHwgIWFkYXB0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhZGFwdG9ycyAmJiBPYmplY3Qua2V5cyggYWRhcHRvcnMgKS5sZW5ndGggJiYgKCBpID0gYWRhcHQubGVuZ3RoICkgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHR2YXIgYWRhcHRvciA9IGFkYXB0WyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBhZGFwdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdFx0YWRhcHRbIGkgXSA9IGFkYXB0b3JzWyBhZGFwdG9yIF0gfHwgYWRhcHRvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0fSxcblx0XHRcdGNvbWJpbmU6IGZ1bmN0aW9uKCBwYXJlbnQsIGFkYXB0ICkge1xuXHRcdFx0XHQvLyBub3JtYWxpemUgJ0ZvbycgdG8gWyAnRm9vJyBdXG5cdFx0XHRcdHBhcmVudCA9IGFycmF5SWZTdHJpbmcoIHBhcmVudCApO1xuXHRcdFx0XHRhZGFwdCA9IGFycmF5SWZTdHJpbmcoIGFkYXB0ICk7XG5cdFx0XHRcdC8vIG5vIHBhcmVudD8gcmV0dXJuIGFkYXB0XG5cdFx0XHRcdGlmICggIXBhcmVudCB8fCAhcGFyZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbm8gYWRhcHQ/IHJldHVybiAnY29weScgb2YgcGFyZW50XG5cdFx0XHRcdGlmICggIWFkYXB0IHx8ICFhZGFwdC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5zbGljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFkZCBwYXJlbnQgYWRhcHRvcnMgdG8gb3B0aW9uc1xuXHRcdFx0XHRwYXJlbnQuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgcHV0IGluIGR1cGxpY2F0ZXNcblx0XHRcdFx0XHRpZiAoIGFkYXB0LmluZGV4T2YoIGEgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRhZGFwdC5wdXNoKCBhICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYXJyYXlJZlN0cmluZyggYWRhcHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBhZGFwdCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFkYXB0ID0gWyBhZGFwdCBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdH1cblx0XHRyZXR1cm4gY29uZmlndXJlO1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL1ZpZXdtb2RlbC5qcyAqL1xuXHR2YXIgVmlld21vZGVsID0gZnVuY3Rpb24oIGNyZWF0ZSwgYWRhcHQsIGFwcGx5Q2hhbmdlcywgY2FwdHVyZSwgY2xlYXJDYWNoZSwgY29tcHV0ZSwgZ2V0LCBpbml0LCBtYXJrLCBtZXJnZSwgcmVnaXN0ZXIsIHJlbGVhc2UsIHNldCwgc21hcnRVcGRhdGUsIHRlYXJkb3duLCB1bnJlZ2lzdGVyLCBhZGFwdENvbmZpZyApIHtcblxuXHRcdHZhciBub01hZ2ljO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bm9NYWdpYyA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHQvLyBUT0RPIGV2ZW50dWFsbHksIHdlIHNob3VsZG4ndCBuZWVkIHRoaXMgcmVmZXJlbmNlXG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlICk7XG5cdFx0XHR0aGlzLmNhY2hlID0ge307XG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gdXNlIGhhc093blByb3BlcnR5LCBzbyBjYW4ndCBpbmhlcml0IGZyb20gbnVsbFxuXHRcdFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5kZXBzID0ge1xuXHRcdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRcdCdkZWZhdWx0Jzoge31cblx0XHRcdH07XG5cdFx0XHR0aGlzLmRlcHNNYXAgPSB7XG5cdFx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdFx0J2RlZmF1bHQnOiB7fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMucGF0dGVybk9ic2VydmVycyA9IFtdO1xuXHRcdFx0dGhpcy53cmFwcGVkID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmNvbXB1dGF0aW9ucyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5jYXB0dXJlR3JvdXBzID0gW107XG5cdFx0XHR0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcyA9IFtdO1xuXHRcdFx0dGhpcy5jaGFuZ2VzID0gW107XG5cdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuXHRcdFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblx0XHR9O1xuXHRcdFZpZXdtb2RlbC5leHRlbmQgPSBmdW5jdGlvbiggUGFyZW50LCBpbnN0YW5jZSApIHtcblx0XHRcdGlmICggaW5zdGFuY2UubWFnaWMgJiYgbm9NYWdpYyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnR2V0dGVycyBhbmQgc2V0dGVycyAobWFnaWMgbW9kZSkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5jb21iaW5lKCBQYXJlbnQucHJvdG90eXBlLmFkYXB0LCBpbnN0YW5jZS5hZGFwdCApIHx8IFtdO1xuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5sb29rdXAoIGluc3RhbmNlLCBpbnN0YW5jZS5hZGFwdG9ycyApO1xuXHRcdH07XG5cdFx0Vmlld21vZGVsLnByb3RvdHlwZSA9IHtcblx0XHRcdGFkYXB0OiBhZGFwdCxcblx0XHRcdGFwcGx5Q2hhbmdlczogYXBwbHlDaGFuZ2VzLFxuXHRcdFx0Y2FwdHVyZTogY2FwdHVyZSxcblx0XHRcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG5cdFx0XHRjb21wdXRlOiBjb21wdXRlLFxuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0bWFyazogbWFyayxcblx0XHRcdG1lcmdlOiBtZXJnZSxcblx0XHRcdHJlZ2lzdGVyOiByZWdpc3Rlcixcblx0XHRcdHJlbGVhc2U6IHJlbGVhc2UsXG5cdFx0XHRzZXQ6IHNldCxcblx0XHRcdHNtYXJ0VXBkYXRlOiBzbWFydFVwZGF0ZSxcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHVucmVnaXN0ZXI6IHVucmVnaXN0ZXJcblx0XHR9O1xuXHRcdHJldHVybiBWaWV3bW9kZWw7XG5cdH0oIGNyZWF0ZSwgdmlld21vZGVsJGFkYXB0LCB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzLCB2aWV3bW9kZWwkY2FwdHVyZSwgdmlld21vZGVsJGNsZWFyQ2FjaGUsIHZpZXdtb2RlbCRjb21wdXRlLCB2aWV3bW9kZWwkZ2V0LCB2aWV3bW9kZWwkaW5pdCwgdmlld21vZGVsJG1hcmssIHZpZXdtb2RlbCRtZXJnZSwgdmlld21vZGVsJHJlZ2lzdGVyLCB2aWV3bW9kZWwkcmVsZWFzZSwgdmlld21vZGVsJHNldCwgdmlld21vZGVsJHNtYXJ0VXBkYXRlLCB2aWV3bW9kZWwkdGVhcmRvd24sIHZpZXdtb2RlbCR1bnJlZ2lzdGVyLCBhZGFwdENvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvaW5pdGlhbGlzZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZV9pbml0aWFsaXNlID0gZnVuY3Rpb24oIGNvbmZpZywgY3JlYXRlLCBGcmFnbWVudCwgZ2V0RWxlbWVudCwgZ2V0TmV4dE51bWJlciwgSG9vaywgSG9va1F1ZXVlLCBWaWV3bW9kZWwgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGNvbnN0cnVjdEhvb2sgPSBuZXcgSG9vayggJ2NvbnN0cnVjdCcgKSxcblx0XHRcdGNvbmZpZ0hvb2sgPSBuZXcgSG9vayggJ2NvbmZpZycgKSxcblx0XHRcdGluaXRIb29rID0gbmV3IEhvb2tRdWV1ZSggJ2luaXQnICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0aW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdC8vIG1ha2UgdGhpcyBvcHRpb24gZG8gd2hhdCB3b3VsZCBiZSBleHBlY3RlZCBpZiBzb21lb25lXG5cdFx0XHQvLyBkaWQgaW5jbHVkZSBpdCBvbiBhIG5ldyBSYWN0aXZlKCkgb3IgbmV3IENvbXBvbmVudCgpIGNhbGwuXG5cdFx0XHQvLyBTaWxseSB0byBkbyBzbyAocHV0IGEgaG9vayBvbiB0aGUgdmVyeSBvcHRpb25zIGJlaW5nIHVzZWQpLFxuXHRcdFx0Ly8gYnV0IGhhbmRsZSBpdCBjb3JyZWN0bHksIGNvbnNpc3RlbnQgd2l0aCB0aGUgaW50ZW50LlxuXHRcdFx0Y29uc3RydWN0SG9vay5maXJlKCBjb25maWcuZ2V0Q29uc3RydWN0VGFyZ2V0KCByYWN0aXZlLCBvcHRpb25zICksIG9wdGlvbnMgKTtcblx0XHRcdC8vIGluaXQgY29uZmlnIGZyb20gUGFyZW50IGFuZCBvcHRpb25zXG5cdFx0XHRjb25maWcuaW5pdCggcmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0Y29uZmlnSG9vay5maXJlKCByYWN0aXZlICk7XG5cdFx0XHQvLyBUZWFyZG93biBhbnkgZXhpc3RpbmcgaW5zdGFuY2VzICpiZWZvcmUqIHRyeWluZyB0byBzZXQgdXAgdGhlIG5ldyBvbmUgLVxuXHRcdFx0Ly8gYXZvaWRzIGNlcnRhaW4gd2VpcmQgYnVnc1xuXHRcdFx0aWYgKCBlbCA9IGdldEVsZW1lbnQoIHJhY3RpdmUuZWwgKSApIHtcblx0XHRcdFx0aWYgKCAhcmFjdGl2ZS5hcHBlbmQgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18uc3BsaWNlKCAwLCBlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18ubGVuZ3RoICkuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHIudGVhcmRvd24oKTtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpbml0SG9vay5iZWdpbiggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gVEVNUE9SQVJZLiBUaGlzIGlzIHNvIHdlIGNhbiBpbXBsZW1lbnQgVmlld21vZGVsIGdyYWR1YWxseVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwgPSBuZXcgVmlld21vZGVsKCByYWN0aXZlICk7XG5cdFx0XHQvLyBoYWNreSBjaXJjdWxhciBwcm9ibGVtIHVudGlsIHdlIGdldCB0aGlzIHNvcnRlZCBvdXRcblx0XHRcdC8vIGlmIHZpZXdtb2RlbCBpbW1lZGlhdGVseSBwcm9jZXNzZXMgY29tcHV0ZWQgcHJvcGVydGllcyxcblx0XHRcdC8vIHRoZXkgbWF5IGNhbGwgcmFjdGl2ZS5nZXQsIHdoaWNoIGNhbGxzIHJhY3RpdmUudmlld21vZGVsLFxuXHRcdFx0Ly8gd2hpY2ggaGFzbid0IGJlZW4gc2V0IHRpbGwgbGluZSBhYm92ZSBmaW5pc2hlcy5cblx0XHRcdHJhY3RpdmUudmlld21vZGVsLmluaXQoKTtcblx0XHRcdC8vIFJlbmRlciBvdXIgKnJvb3QgZnJhZ21lbnQqXG5cdFx0XHRpZiAoIHJhY3RpdmUudGVtcGxhdGUgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogcmFjdGl2ZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiByYWN0aXZlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGluaXRIb29rLmVuZCggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG5cdFx0XHRpZiAoIGVsICkge1xuXHRcdFx0XHRyYWN0aXZlLnJlbmRlciggZWwsIHJhY3RpdmUuYXBwZW5kICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXRpYWxpc2VQcm9wZXJ0aWVzKCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0Ly8gR2VuZXJhdGUgYSB1bmlxdWUgaWRlbnRpZmllciwgZm9yIHBsYWNlcyB3aGVyZSB5b3UnZCB1c2UgYSB3ZWFrIG1hcCBpZiBpdFxuXHRcdFx0Ly8gZXhpc3RlZFxuXHRcdFx0cmFjdGl2ZS5fZ3VpZCA9IGdldE5leHROdW1iZXIoKTtcblx0XHRcdC8vIGV2ZW50c1xuXHRcdFx0cmFjdGl2ZS5fc3VicyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0Ly8gc3RvcmFnZSBmb3IgaXRlbSBjb25maWd1cmF0aW9uIGZyb20gaW5zdGFudGlhdGlvbiB0byByZXNldCxcblx0XHRcdC8vIGxpa2UgZHluYW1pYyBmdW5jdGlvbnMgb3Igb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHRyYWN0aXZlLl9jb25maWcgPSB7fTtcblx0XHRcdC8vIHR3by13YXkgYmluZGluZ3Ncblx0XHRcdHJhY3RpdmUuX3R3b3dheUJpbmRpbmdzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBhbmltYXRpb25zIChzbyB3ZSBjYW4gc3RvcCBhbnkgaW4gcHJvZ3Jlc3MgYXQgdGVhcmRvd24pXG5cdFx0XHRyYWN0aXZlLl9hbmltYXRpb25zID0gW107XG5cdFx0XHQvLyBub2RlcyByZWdpc3RyeVxuXHRcdFx0cmFjdGl2ZS5ub2RlcyA9IHt9O1xuXHRcdFx0Ly8gbGl2ZSBxdWVyaWVzXG5cdFx0XHRyYWN0aXZlLl9saXZlUXVlcmllcyA9IFtdO1xuXHRcdFx0cmFjdGl2ZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXMgPSBbXTtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnRcblx0XHRcdGlmICggb3B0aW9ucy5fcGFyZW50ICYmIG9wdGlvbnMuX2NvbXBvbmVudCApIHtcblx0XHRcdFx0cmFjdGl2ZS5fcGFyZW50ID0gb3B0aW9ucy5fcGFyZW50O1xuXHRcdFx0XHRyYWN0aXZlLmNvbXBvbmVudCA9IG9wdGlvbnMuX2NvbXBvbmVudDtcblx0XHRcdFx0Ly8gQW5kIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvbiB0aGUgY29tcG9uZW50XG5cdFx0XHRcdG9wdGlvbnMuX2NvbXBvbmVudC5pbnN0YW5jZSA9IHJhY3RpdmU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY29uZmlnLCBjcmVhdGUsIEZyYWdtZW50LCBnZXRFbGVtZW50LCBnZXROZXh0TnVtYmVyLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rUXVldWUsIFZpZXdtb2RlbCApO1xuXG5cdC8qIGV4dGVuZC91bndyYXBFeHRlbmRlZC5qcyAqL1xuXHR2YXIgdW53cmFwRXh0ZW5kZWQgPSBmdW5jdGlvbiggd3JhcCwgY29uZmlnLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgUmFjdGl2ZTtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFJhY3RpdmUgPSBjaXJjdWxhci5SYWN0aXZlO1xuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHVud3JhcEV4dGVuZGVkKCBDaGlsZCApIHtcblx0XHRcdGlmICggISggQ2hpbGQucHJvdG90eXBlIGluc3RhbmNlb2YgUmFjdGl2ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gQ2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHt9O1xuXHRcdFx0d2hpbGUgKCBDaGlsZCApIHtcblx0XHRcdFx0Y29uZmlnLnJlZ2lzdHJpZXMuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0YWRkUmVnaXN0cnkoIHIudXNlRGVmYXVsdHMgPyBDaGlsZC5wcm90b3R5cGUgOiBDaGlsZCwgb3B0aW9ucywgci5uYW1lICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0T2JqZWN0LmtleXMoIENoaWxkLnByb3RvdHlwZSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0aWYgKCBrZXkgPT09ICdjb21wdXRlZCcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IENoaWxkLnByb3RvdHlwZVsga2V5IF07XG5cdFx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gb3B0aW9ucyApICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBvcHRpb25zWyBrZXkgXSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9uc1sga2V5IF0uX21ldGhvZCApIHtcblx0XHRcdFx0XHRcdHZhciByZXN1bHQsIG5lZWRzU3VwZXIgPSB2YWx1ZS5fbWV0aG9kO1xuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLl9tZXRob2Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyByZXdyYXAgYm91bmQgZGlyZWN0bHkgdG8gcGFyZW50IGZuXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB3cmFwKCBvcHRpb25zWyBrZXkgXS5fbWV0aG9kLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQuX21ldGhvZCA9IHJlc3VsdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIENoaWxkLl9wYXJlbnQgIT09IFJhY3RpdmUgKSB7XG5cdFx0XHRcdFx0Q2hpbGQgPSBDaGlsZC5fcGFyZW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdENoaWxkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRpb25zO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhZGRSZWdpc3RyeSggdGFyZ2V0LCBvcHRpb25zLCBuYW1lICkge1xuXHRcdFx0dmFyIHJlZ2lzdHJ5LCBrZXlzID0gT2JqZWN0LmtleXMoIHRhcmdldFsgbmFtZSBdICk7XG5cdFx0XHRpZiAoICFrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhKCByZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSApICkge1xuXHRcdFx0XHRyZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0a2V5cy5maWx0ZXIoIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBrZXkgaW4gcmVnaXN0cnkgKTtcblx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVnaXN0cnlbIGtleSBdID0gdGFyZ2V0WyBuYW1lIF1bIGtleSBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdyYXBNZXRob2QsIGNvbmZpZywgY2lyY3VsYXIgKTtcblxuXHQvKiBleHRlbmQvX2V4dGVuZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZV9leHRlbmQgPSBmdW5jdGlvbiggY3JlYXRlLCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRHdWlkLCBjb25maWcsIGluaXRpYWxpc2UsIFZpZXdtb2RlbCwgdW53cmFwICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAwIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRDaGlsZCwgcHJvdG8sIHN0YXRpY1Byb3BlcnRpZXM7XG5cdFx0XHQvLyBpZiB3ZSdyZSBleHRlbmRpbmcgd2l0aCBhbm90aGVyIFJhY3RpdmUgaW5zdGFuY2UsIGluaGVyaXQgaXRzXG5cdFx0XHQvLyBwcm90b3R5cGUgbWV0aG9kcyBhbmQgZGVmYXVsdCBvcHRpb25zIGFzIHdlbGxcblx0XHRcdG9wdGlvbnMgPSB1bndyYXAoIG9wdGlvbnMgKTtcblx0XHRcdC8vIGNyZWF0ZSBDaGlsZCBjb25zdHJ1Y3RvclxuXHRcdFx0Q2hpbGQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0aW5pdGlhbGlzZSggdGhpcywgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdHByb3RvID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRwcm90by5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXHRcdFx0c3RhdGljUHJvcGVydGllcyA9IHtcblx0XHRcdFx0Ly8gZWFjaCBjb21wb25lbnQgbmVlZHMgYSBndWlkLCBmb3IgbWFuYWdpbmcgQ1NTIGV0Y1xuXHRcdFx0XHRfZ3VpZDoge1xuXHRcdFx0XHRcdHZhbHVlOiBnZXRHdWlkKClcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0XHRcdGRlZmF1bHRzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByb3RvXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIGV4dGVuZGFibGVcblx0XHRcdFx0ZXh0ZW5kOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGV4dGVuZCxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuXHRcdFx0XHRfcGFyZW50OiB7XG5cdFx0XHRcdFx0dmFsdWU6IFBhcmVudFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggQ2hpbGQsIHN0YXRpY1Byb3BlcnRpZXMgKTtcblx0XHRcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG5cdFx0XHRjb25maWcuZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCBQYXJlbnQsIHByb3RvICk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdHJldHVybiBDaGlsZDtcblx0XHR9O1xuXHR9KCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgUmFjdGl2ZV9pbml0aWFsaXNlLCBWaWV3bW9kZWwsIHVud3JhcEV4dGVuZGVkICk7XG5cblx0LyogUmFjdGl2ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSA9IGZ1bmN0aW9uKCBkZWZhdWx0cywgZWFzaW5nLCBpbnRlcnBvbGF0b3JzLCBzdmcsIG1hZ2ljLCBkZWZpbmVQcm9wZXJ0aWVzLCBwcm90bywgUHJvbWlzZSwgZXh0ZW5kT2JqLCBleHRlbmQsIHBhcnNlLCBpbml0aWFsaXNlLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBSYWN0aXZlLCBwcm9wZXJ0aWVzO1xuXHRcdC8vIE1haW4gUmFjdGl2ZSByZXF1aXJlZCBvYmplY3Rcblx0XHRSYWN0aXZlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRpbml0aWFsaXNlKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHQvLyBSYWN0aXZlIHByb3BlcnRpZXNcblx0XHRwcm9wZXJ0aWVzID0ge1xuXHRcdFx0Ly8gc3RhdGljIG1ldGhvZHM6XG5cdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0dmFsdWU6IGV4dGVuZFxuXHRcdFx0fSxcblx0XHRcdHBhcnNlOiB7XG5cdFx0XHRcdHZhbHVlOiBwYXJzZVxuXHRcdFx0fSxcblx0XHRcdC8vIE5hbWVzcGFjZWQgY29uc3RydWN0b3JzXG5cdFx0XHRQcm9taXNlOiB7XG5cdFx0XHRcdHZhbHVlOiBQcm9taXNlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gc3VwcG9ydFxuXHRcdFx0c3ZnOiB7XG5cdFx0XHRcdHZhbHVlOiBzdmdcblx0XHRcdH0sXG5cdFx0XHRtYWdpYzoge1xuXHRcdFx0XHR2YWx1ZTogbWFnaWNcblx0XHRcdH0sXG5cdFx0XHQvLyB2ZXJzaW9uXG5cdFx0XHRWRVJTSU9OOiB7XG5cdFx0XHRcdHZhbHVlOiAnMC42LjEnXG5cdFx0XHR9LFxuXHRcdFx0Ly8gUGx1Z2luc1xuXHRcdFx0YWRhcHRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGNvbXBvbmVudHM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGRlY29yYXRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGVhc2luZzoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGVhc2luZ1xuXHRcdFx0fSxcblx0XHRcdGV2ZW50czoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJwb2xhdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGludGVycG9sYXRvcnNcblx0XHRcdH0sXG5cdFx0XHRwYXJ0aWFsczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNpdGlvbnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0Ly8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG5cdFx0ZGVmaW5lUHJvcGVydGllcyggUmFjdGl2ZSwgcHJvcGVydGllcyApO1xuXHRcdFJhY3RpdmUucHJvdG90eXBlID0gZXh0ZW5kT2JqKCBwcm90bywgZGVmYXVsdHMgKTtcblx0XHRSYWN0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhY3RpdmU7XG5cdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0UmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXHRcdC8vIENlcnRhaW4gbW9kdWxlcyBoYXZlIGNpcmN1bGFyIGRlcGVuZGVuY2llcy4gSWYgd2Ugd2VyZSBidW5kbGluZyBhXG5cdFx0Ly8gbW9kdWxlIGxvYWRlciwgZS5nLiBhbG1vbmQuanMsIHRoaXMgd291bGRuJ3QgYmUgYSBwcm9ibGVtLCBidXQgd2UncmVcblx0XHQvLyBub3QgLSB3ZSdyZSB1c2luZyBhbWRjbGVhbiBhcyBwYXJ0IG9mIHRoZSBidWlsZCBwcm9jZXNzLiBCZWNhdXNlIG9mXG5cdFx0Ly8gdGhpcywgd2UgbmVlZCB0byB3YWl0IHVudGlsIGFsbCBtb2R1bGVzIGhhdmUgbG9hZGVkIGJlZm9yZSB0aG9zZVxuXHRcdC8vIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBjYW4gYmUgcmVxdWlyZWQuXG5cdFx0Y2lyY3VsYXIuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cdFx0d2hpbGUgKCBjaXJjdWxhci5sZW5ndGggKSB7XG5cdFx0XHRjaXJjdWxhci5wb3AoKSgpO1xuXHRcdH1cblx0XHQvLyBSYWN0aXZlLmpzIG1ha2VzIGxpYmVyYWwgdXNlIG9mIHRoaW5ncyBsaWtlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLiBJblxuXHRcdC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcblx0XHQvLyBwcmUtZmxpZ2h0IGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGVpdGhlciBhKSB3ZSdyZSBub3QgaW4gYSBzaGl0IGJyb3dzZXIsXG5cdFx0Ly8gb3IgYikgd2UncmUgdXNpbmcgYSBSYWN0aXZlLWxlZ2FjeS5qcyBidWlsZFxuXHRcdHZhciBGVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cdFx0aWYgKCB0eXBlb2YgRGF0ZS5ub3cgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBPYmplY3Qua2V5cyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUubWFwICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgUmFjdGl2ZS5qcyBpbiBhbiBvbGRlciBicm93c2VyLiBZb3VcXCdsbCBuZWVkIHRvIHVzZSBvbmUgb2YgdGhlIFxcJ2xlZ2FjeSBidWlsZHNcXCcgaW4gb3JkZXIgdG8gY29udGludWUgLSBzZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbGVnYWN5LWJ1aWxkcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nICk7XG5cdFx0fVxuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9KCBvcHRpb25zLCBlYXNpbmcsIGludGVycG9sYXRvcnMsIHN2ZywgbWFnaWMsIGRlZmluZVByb3BlcnRpZXMsIHByb3RvdHlwZSwgUHJvbWlzZSwgZXh0ZW5kLCBSYWN0aXZlX2V4dGVuZCwgcGFyc2UsIFJhY3RpdmVfaW5pdGlhbGlzZSwgY2lyY3VsYXIgKTtcblxuXG5cdC8vIGV4cG9ydCBhcyBDb21tb24gSlMgbW9kdWxlLi4uXG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmU7XG5cdH1cblxuXHQvLyAuLi4gb3IgYXMgQU1EIG1vZHVsZVxuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBSYWN0aXZlO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIC4uLiBvciBhcyBicm93c2VyIGdsb2JhbFxuXHRnbG9iYWwuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cblx0UmFjdGl2ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Z2xvYmFsLlJhY3RpdmUgPSBub0NvbmZsaWN0O1xuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9O1xuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMgKSApO1xuIl19
