(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./source/js/app.coffee":[function(require,module,exports){
require("./module/index");

require("./../../vendor/gsap/src/uncompressed/TweenMax.js");

require("./../../vendor/ractive-events-tap/ractive-events-tap.js");

require("./../../vendor/ractive-touch/index.js");

require("./../../vendor/ractive-transitions-fade/ractive-transitions-fade.js");

require("./../../vendor/ractive-transitions-fly/ractive-transitions-fly.js");

require("./../../vendor/ractive-transitions-slide/ractive-transitions-slide.js");

require('./../../vendor/domready/ready.js')(function() {
  var View;
  if ("development" === "development") {
    require("./app-debug")();
  }
  View = require("./view/main-view");
  return window._view = new View();
});



},{"./../../vendor/domready/ready.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/domready/ready.js","./../../vendor/gsap/src/uncompressed/TweenMax.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/gsap/src/uncompressed/TweenMax.js","./../../vendor/ractive-events-tap/ractive-events-tap.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-events-tap/ractive-events-tap.js","./../../vendor/ractive-touch/index.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-touch/index.js","./../../vendor/ractive-transitions-fade/ractive-transitions-fade.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-transitions-fade/ractive-transitions-fade.js","./../../vendor/ractive-transitions-fly/ractive-transitions-fly.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-transitions-fly/ractive-transitions-fly.js","./../../vendor/ractive-transitions-slide/ractive-transitions-slide.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-transitions-slide/ractive-transitions-slide.js","./app-debug":"/Users/luke.hedger/dev/Experiments/040715/source/js/app-debug.coffee","./module/index":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/index.coffee","./view/main-view":"/Users/luke.hedger/dev/Experiments/040715/source/js/view/main-view.coffee"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/index.js":[function(require,module,exports){
module.exports = require('./vendor/dat.gui')
module.exports.color = require('./vendor/dat.color')
},{"./vendor/dat.color":"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.color.js","./vendor/dat.gui":"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.gui.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.color.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);
},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/vendor/dat.gui.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/firebase/lib/firebase-web.js":[function(require,module,exports){
/*! @license Firebase v2.1.2 - License: https://www.firebase.com/terms/terms-of-service.html */ (function() {var h,aa=this;function m(a){return void 0!==a}function ba(){}function ca(a){a.Nb=function(){return a.kf?a.kf:a.kf=new a}}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return"array"==da(a)}function fa(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"string"==typeof a}function ga(a){return"number"==typeof a}function ha(a){return"function"==da(a)}function ia(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ja(a,b,c){return a.call.apply(a.bind,arguments)}
function ka(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){q=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ja:ka;return q.apply(null,arguments)}var la=Date.now||function(){return+new Date};
function ma(a,b){function c(){}c.prototype=b.prototype;a.Jg=b.prototype;a.prototype=new c;a.Fg=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};function na(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function oa(){this.Hd=void 0}
function pa(a,b,c){switch(typeof b){case "string":qa(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(ea(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],pa(a,a.Hd?a.Hd.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),qa(f,c),
c.push(":"),pa(a,a.Hd?a.Hd.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var ra={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},sa=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function qa(a,b){b.push('"',a.replace(sa,function(a){if(a in ra)return ra[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return ra[a]=e+b.toString(16)}),'"')};function ta(a){return"undefined"!==typeof JSON&&m(JSON.parse)?JSON.parse(a):na(a)}function r(a){if("undefined"!==typeof JSON&&m(JSON.stringify))a=JSON.stringify(a);else{var b=[];pa(new oa,a,b);a=b.join("")}return a};function s(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function t(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function ua(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])}function va(a){var b={};ua(a,function(a,d){b[a]=d});return b};function wa(a){this.uc=a;this.Ed="firebase:"}h=wa.prototype;h.set=function(a,b){null==b?this.uc.removeItem(this.Ed+a):this.uc.setItem(this.Ed+a,r(b))};h.get=function(a){a=this.uc.getItem(this.Ed+a);return null==a?null:ta(a)};h.remove=function(a){this.uc.removeItem(this.Ed+a)};h.lf=!1;h.toString=function(){return this.uc.toString()};function xa(){this.oc={}}xa.prototype.set=function(a,b){null==b?delete this.oc[a]:this.oc[a]=b};xa.prototype.get=function(a){return s(this.oc,a)?this.oc[a]:null};xa.prototype.remove=function(a){delete this.oc[a]};xa.prototype.lf=!0;function ya(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new wa(b)}}catch(c){}return new xa}var za=ya("localStorage"),v=ya("sessionStorage");function Aa(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.Ab=b;this.tb=c;this.Dg=d;this.Dd=e||"";this.Ma=za.get("host:"+a)||this.host}function Ba(a,b){b!==a.Ma&&(a.Ma=b,"s-"===a.Ma.substr(0,2)&&za.set("host:"+a.host,a.Ma))}Aa.prototype.toString=function(){var a=(this.Ab?"https://":"http://")+this.host;this.Dd&&(a+="<"+this.Dd+">");return a};function Ca(){this.Sa=-1};function Da(){this.Sa=-1;this.Sa=64;this.R=[];this.be=[];this.Ef=[];this.Ad=[];this.Ad[0]=128;for(var a=1;a<this.Sa;++a)this.Ad[a]=0;this.Td=this.Sb=0;this.reset()}ma(Da,Ca);Da.prototype.reset=function(){this.R[0]=1732584193;this.R[1]=4023233417;this.R[2]=2562383102;this.R[3]=271733878;this.R[4]=3285377520;this.Td=this.Sb=0};
function Ea(a,b,c){c||(c=0);var d=a.Ef;if(p(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.R[0];c=a.R[1];for(var g=a.R[2],k=a.R[3],l=a.R[4],n,e=0;80>e;e++)40>e?20>e?(f=k^c&(g^k),n=1518500249):(f=c^g^k,n=1859775393):60>e?(f=c&g|k&(c|g),n=2400959708):(f=c^g^k,n=3395469782),f=(b<<
5|b>>>27)+f+l+n+d[e]&4294967295,l=k,k=g,g=(c<<30|c>>>2)&4294967295,c=b,b=f;a.R[0]=a.R[0]+b&4294967295;a.R[1]=a.R[1]+c&4294967295;a.R[2]=a.R[2]+g&4294967295;a.R[3]=a.R[3]+k&4294967295;a.R[4]=a.R[4]+l&4294967295}
Da.prototype.update=function(a,b){m(b)||(b=a.length);for(var c=b-this.Sa,d=0,e=this.be,f=this.Sb;d<b;){if(0==f)for(;d<=c;)Ea(this,a,d),d+=this.Sa;if(p(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Sa){Ea(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Sa){Ea(this,e);f=0;break}}this.Sb=f;this.Td+=b};function Fa(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^la()).toString(36)};var w=Array.prototype,Ga=w.indexOf?function(a,b,c){return w.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return p(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Ha=w.forEach?function(a,b,c){w.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Ia=w.filter?function(a,b,c){return w.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=p(a)?
a.split(""):a,k=0;k<d;k++)if(k in g){var l=g[k];b.call(c,l,k,a)&&(e[f++]=l)}return e},Ja=w.map?function(a,b,c){return w.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=p(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Ka=w.reduce?function(a,b,c,d){d&&(b=q(b,d));return w.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;Ha(a,function(c,g){e=b.call(d,e,c,g,a)});return e},La=w.every?function(a,b,c){return w.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=
p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Ma(a,b){var c=Na(a,b,void 0);return 0>c?null:p(a)?a.charAt(c):a[c]}function Na(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Oa(a,b){var c=Ga(a,b);0<=c&&w.splice.call(a,c,1)}function Pa(a,b,c){return 2>=arguments.length?w.slice.call(a,b):w.slice.call(a,b,c)}function Qa(a,b){a.sort(b||Ra)}function Ra(a,b){return a>b?1:a<b?-1:0};var Sa;a:{var Ta=aa.navigator;if(Ta){var Ua=Ta.userAgent;if(Ua){Sa=Ua;break a}}Sa=""}function Va(a){return-1!=Sa.indexOf(a)};var Wa=Va("Opera")||Va("OPR"),Xa=Va("Trident")||Va("MSIE"),Ya=Va("Gecko")&&-1==Sa.toLowerCase().indexOf("webkit")&&!(Va("Trident")||Va("MSIE")),Za=-1!=Sa.toLowerCase().indexOf("webkit");(function(){var a="",b;if(Wa&&aa.opera)return a=aa.opera.version,ha(a)?a():a;Ya?b=/rv\:([^\);]+)(\)|;)/:Xa?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:Za&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(Sa))?a[1]:"");return Xa&&(b=(b=aa.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var $a=null,ab=null,bb=null;function cb(a,b){if(!fa(a))throw Error("encodeByteArray takes an array as a parameter");db();for(var c=b?ab:$a,d=[],e=0;e<a.length;e+=3){var f=a[e],g=e+1<a.length,k=g?a[e+1]:0,l=e+2<a.length,n=l?a[e+2]:0,u=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|n>>6,n=n&63;l||(n=64,g||(k=64));d.push(c[u],c[f],c[k],c[n])}return d.join("")}
function db(){if(!$a){$a={};ab={};bb={};for(var a=0;65>a;a++)$a[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),ab[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),bb[ab[a]]=a}};var eb=function(){var a=1;return function(){return a++}}();function y(a,b){if(!a)throw fb(b);}function fb(a){return Error("Firebase INTERNAL ASSERT FAILED:"+a)}
function gb(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{db();for(var c=bb,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],g=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var l=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==g||null==k||null==l)throw Error();d.push(f<<2|g>>4);64!=k&&(d.push(g<<4&240|k>>2),64!=l&&d.push(k<<6&192|l))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Pa(d,c,
c+8192));b=a}}return b}catch(n){hb("base64Decode failed: ",n)}return null}function ib(a){var b=jb(a);a=new Da;a.update(b);var b=[],c=8*a.Td;56>a.Sb?a.update(a.Ad,56-a.Sb):a.update(a.Ad,a.Sa-(a.Sb-56));for(var d=a.Sa-1;56<=d;d--)a.be[d]=c&255,c/=256;Ea(a,a.be);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.R[d]>>e&255,++c;return cb(b)}
function kb(a){for(var b="",c=0;c<arguments.length;c++)b=fa(arguments[c])?b+kb.apply(null,arguments[c]):"object"===typeof arguments[c]?b+r(arguments[c]):b+arguments[c],b+=" ";return b}var lb=null,mb=!0;function hb(a){!0===mb&&(mb=!1,null===lb&&!0===v.get("logging_enabled")&&nb(!0));if(lb){var b=kb.apply(null,arguments);lb(b)}}function ob(a){return function(){hb(a,arguments)}}
function pb(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+kb.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function qb(a){var b=kb.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function z(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+kb.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function rb(a){var b="",c="",d="",e="",f=!0,g="https",k=443;if(p(a)){var l=a.indexOf("//");0<=l&&(g=a.substring(0,l-1),a=a.substring(l+2));l=a.indexOf("/");-1===l&&(l=a.length);b=a.substring(0,l);e="";a=a.substring(l).split("/");for(l=0;l<a.length;l++)if(0<a[l].length){var n=a[l];try{n=decodeURIComponent(n.replace(/\+/g," "))}catch(u){}e+="/"+n}a=b.split(".");3===a.length?(c=a[1],d=a[0].toLowerCase()):2===a.length&&(c=a[0]);l=b.indexOf(":");0<=l&&(f="https"===g||"wss"===g,k=b.substring(l+1),isFinite(k)&&
(k=String(k)),k=p(k)?/^\s*-?0x/i.test(k)?parseInt(k,16):parseInt(k,10):NaN)}return{host:b,port:k,domain:c,Ag:d,Ab:f,scheme:g,Pc:e}}function sb(a){return ga(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function tb(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function ub(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=vb(a),d=vb(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function wb(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+r(b));}
function xb(a){if("object"!==typeof a||null===a)return r(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=r(b[d]),c+=":",c+=xb(a[b[d]]);return c+"}"}function yb(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function zb(a,b){if(ea(a))for(var c=0;c<a.length;++c)b(c,a[c]);else A(a,b)}
function Ab(a){y(!sb(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;a-=1)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;a-=1)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var Bb=/^-?\d{1,10}$/;function vb(a){return Bb.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function Cb(a){try{a()}catch(b){setTimeout(function(){z("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function B(a,b){if(ha(a)){var c=Array.prototype.slice.call(arguments,1).slice();Cb(function(){a.apply(null,c)})}};function Db(a,b,c,d){this.le=b;this.Nd=c;this.Fd=d;this.jd=a}Db.prototype.Qb=function(){var a=this.Nd.cc();return"value"===this.jd?a.path:a.parent().path};Db.prototype.pe=function(){return this.jd};Db.prototype.Lb=function(){return this.le.Lb(this)};Db.prototype.toString=function(){return this.Qb().toString()+":"+this.jd+":"+r(this.Nd.bf())};function Eb(a,b,c){this.le=a;this.error=b;this.path=c}Eb.prototype.Qb=function(){return this.path};Eb.prototype.pe=function(){return"cancel"};
Eb.prototype.Lb=function(){return this.le.Lb(this)};Eb.prototype.toString=function(){return this.path.toString()+":cancel"};function C(a,b,c,d){this.type=a;this.Ha=b;this.Ua=c;this.De=d;this.Fd=void 0}function Fb(a){return new C(Gb,a)}var Gb="value";function Hb(a,b,c){this.Hb=a;this.kb=b;this.mb=c||null}h=Hb.prototype;h.wf=function(a){return"value"===a};h.createEvent=function(a,b){var c=b.n.g;return new Db("value",this,new D(a.Ha,b.cc(),c))};h.Lb=function(a){var b=this.mb;if("cancel"===a.pe()){y(this.kb,"Raising a cancel event on a listener with no cancel callback");var c=this.kb;return function(){c.call(b,a.error)}}var d=this.Hb;return function(){d.call(b,a.Nd)}};h.Ye=function(a,b){return this.kb?new Eb(this,a,b):null};
h.matches=function(a){return a instanceof Hb?a.Hb&&this.Hb?a.Hb===this.Hb&&a.mb===this.mb:!0:!1};h.hf=function(){return null!==this.Hb};function Ib(a,b,c){this.da=a;this.kb=b;this.mb=c}h=Ib.prototype;h.wf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.da};h.Ye=function(a,b){return this.kb?new Eb(this,a,b):null};
h.createEvent=function(a,b){y(null!=a.Ua,"Child events should have a childName.");var c=b.cc().o(a.Ua);return new Db(a.type,this,new D(a.Ha,c,b.n.g),a.Fd)};h.Lb=function(a){var b=this.mb;if("cancel"===a.pe()){y(this.kb,"Raising a cancel event on a listener with no cancel callback");var c=this.kb;return function(){c.call(b,a.error)}}var d=this.da[a.jd];return function(){d.call(b,a.Nd,a.Fd)}};
h.matches=function(a){if(a instanceof Ib){if(!this.da||!a.da)return!0;if(this.mb===a.mb){var b=Jb(a.da);if(b===Jb(this.da)){if(1===b){var b=Kb(a.da),c=Kb(this.da);return c===b&&(!a.da[b]||!this.da[c]||a.da[b]===this.da[c])}return Lb(this.da,function(b,c){return a.da[c]===b})}}}return!1};h.hf=function(){return null!==this.da};function jb(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,y(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b};function F(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function G(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function H(a,b,c,d){if((!d||m(c))&&!ha(c))throw Error(G(a,b,d)+"must be a valid function.");}function Mb(a,b,c){if(m(c)&&(!ia(c)||null===c))throw Error(G(a,b,!0)+"must be a valid context object.");};var Nb=/[\[\].#$\/\u0000-\u001F\u007F]/,Ob=/[\[\].#$\u0000-\u001F\u007F]/;function Pb(a){return p(a)&&0!==a.length&&!Nb.test(a)}function Qb(a){return null===a||p(a)||ga(a)&&!sb(a)||ia(a)&&s(a,".sv")}function Rb(a,b,c){c&&!m(b)||Sb(G(a,1,c),b)}
function Sb(a,b,c,d){c||(c=0);var e=d||[];if(!m(b))throw Error(a+"contains undefined"+Tb(e));if(ha(b))throw Error(a+"contains a function"+Tb(e)+" with contents: "+b.toString());if(sb(b))throw Error(a+"contains "+b.toString()+Tb(e));if(1E3<c)throw new TypeError(a+"contains a cyclic object value ("+e.slice(0,100).join(".")+"...)");if(p(b)&&b.length>10485760/3&&10485760<jb(b).length)throw Error(a+"contains a string greater than 10485760 utf8 bytes"+Tb(e)+" ('"+b.substring(0,50)+"...')");if(ia(b)){var f=
!1,g=!1;ua(b,function(b,d){if(".value"===b)f=!0;else if(".priority"!==b&&".sv"!==b&&(g=!0,!Pb(b)))throw Error(a+" contains an invalid key ("+b+")"+Tb(e)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');e.push(b);Sb(a,d,c+1,e);e.pop()});if(f&&g)throw Error(a+' contains ".value" child'+Tb(e)+" in addition to actual children.");}}function Tb(a){return 0==a.length?"":" in property '"+a.join(".")+"'"}
function Ub(a,b){if(!ia(b)||ea(b))throw Error(G(a,1,!1)+" must be an Object containing the children to replace.");if(s(b,".value"))throw Error(G(a,1,!1)+' must not contain ".value".  To overwrite with a leaf value, just use .set() instead.');Rb(a,b,!1)}
function Vb(a,b,c){if(sb(c))throw Error(G(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!Qb(c))throw Error(G(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function Wb(a,b,c){if(!c||m(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(G(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function Xb(a,b,c,d){if((!d||m(c))&&!Pb(c))throw Error(G(a,b,d)+'was an invalid key: "'+c+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function Yb(a,b){if(!p(b)||0===b.length||Ob.test(b))throw Error(G(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function Zb(a,b){if(".info"===I(b))throw Error(a+" failed: Can't modify data under /.info/");}function $b(a,b){if(!p(b))throw Error(G(a,1,!1)+"must be a valid credential (a string).");}function ac(a,b,c){if(!p(c))throw Error(G(a,b,!1)+"must be a valid string.");}
function J(a,b,c,d){if(!d||m(c))if(!ia(c)||null===c)throw Error(G(a,b,d)+"must be a valid object.");}function K(a,b,c){if(!ia(b)||null===b||!s(b,c))throw Error(G(a,1,!1)+'must contain the key "'+c+'"');if(!p(t(b,c)))throw Error(G(a,1,!1)+'must contain the key "'+c+'" with type "string"');};function bc(a){this.g=a}h=bc.prototype;h.C=function(a,b,c,d,e){y(a.Bc(this.g),"A node must be indexed if only a child is updated");d=a.K(b);if(d.ea(c))return a;null!=e&&(c.e()?a.Da(b)?cc(e,new C("child_removed",d,b)):y(a.M(),"A child remove without an old child only makes sense on a leaf node"):d.e()?cc(e,new C("child_added",c,b)):cc(e,new C("child_changed",c,b,d)));return a.M()&&c.e()?a:a.P(b,c)};
h.oa=function(a,b,c){null!=c&&(a.M()||a.U(L,function(a,e){b.Da(a)||cc(c,new C("child_removed",e,a))}),b.M()||b.U(L,function(b,e){if(a.Da(b)){var f=a.K(b);f.ea(e)||cc(c,new C("child_changed",e,b,f))}else cc(c,new C("child_added",e,b))}));return b.Fb(this.g)};h.Z=function(a,b){return a.e()?M:a.Z(b)};h.ya=function(){return!1};h.Mb=function(){return this};function dc(a){this.re=new bc(a.g);this.g=a.g;var b;a.ia?(b=ec(a),b=a.g.Ae(fc(a),b)):b=a.g.Ce();this.Vc=b;a.qa?(b=gc(a),a=a.g.Ae(hc(a),b)):a=a.g.Be();this.wc=a}h=dc.prototype;h.matches=function(a){return 0>=this.g.compare(this.Vc,a)&&0>=this.g.compare(a,this.wc)};h.C=function(a,b,c,d,e){this.matches(new N(b,c))||(c=M);return this.re.C(a,b,c,d,e)};h.oa=function(a,b,c){b.M()&&(b=M);var d=b.Fb(this.g),d=d.Z(M),e=this;b.U(L,function(a,b){e.matches(new N(a,b))||(d=d.P(a,M))});return this.re.oa(a,d,c)};
h.Z=function(a){return a};h.ya=function(){return!0};h.Mb=function(){return this.re};function ic(a,b){return ub(a.name,b.name)}function jc(a,b){return ub(a,b)};function kc(){}var lc={};function mc(a){return q(a.compare,a)}kc.prototype.jf=function(a,b){return 0!==this.compare(new N("[MIN_NAME]",a),new N("[MIN_NAME]",b))};kc.prototype.Ce=function(){return nc};function oc(a){this.Ub=a}ma(oc,kc);h=oc.prototype;h.ue=function(a){return!a.K(this.Ub).e()};h.compare=function(a,b){var c=a.Y.K(this.Ub),d=b.Y.K(this.Ub),c=c.he(d);return 0===c?ub(a.name,b.name):c};h.Ae=function(a,b){var c=O(a),c=M.P(this.Ub,c);return new N(b,c)};
h.Be=function(){var a=M.P(this.Ub,pc);return new N("[MAX_NAME]",a)};h.toString=function(){return this.Ub};var L=new oc(".priority");function qc(){}ma(qc,kc);h=qc.prototype;h.compare=function(a,b){return ub(a.name,b.name)};h.ue=function(){throw fb("KeyIndex.isDefinedOn not expected to be called.");};h.jf=function(){return!1};h.Ce=function(){return nc};h.Be=function(){return new N("[MAX_NAME]",M)};h.Ae=function(a){y(p(a),"KeyIndex indexValue must always be a string.");return new N(a,M)};
h.toString=function(){return".key"};var rc=new qc;function sc(){}sc.prototype.ef=function(){return null};sc.prototype.oe=function(){return null};var tc=new sc;function uc(a,b,c){this.Bf=a;this.Ia=b;this.zd=c}uc.prototype.ef=function(a){var b=this.Ia.F;if(vc(b,a))return b.j().K(a);b=null!=this.zd?new wc(this.zd,!0,!1):this.Ia.u();return this.Bf.Ta(a,b)};uc.prototype.oe=function(a,b,c){var d=null!=this.zd?this.zd:xc(this.Ia);a=this.Bf.ce(d,b,1,c,a);return 0===a.length?null:a[0]};function yc(){this.Za={}}
function cc(a,b){var c=b.type,d=b.Ua;y("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");y(".priority"!==d,"Only non-priority child changes can be tracked.");var e=t(a.Za,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.Ha);else if("child_removed"==c&&"child_added"==f)delete a.Za[d];else if("child_removed"==c&&"child_changed"==f)a.Za[d]=new C("child_removed",e.De,d);else if("child_changed"==c&&
"child_added"==f)a.Za[d]=new C("child_added",b.Ha,d);else if("child_changed"==c&&"child_changed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.De);else throw fb("Illegal combination of changes: "+b+" occurred after "+e);}else a.Za[d]=b};function N(a,b){this.name=a;this.Y=b}function zc(a,b){return new N(a,b)};function Ac(a){this.ma=new dc(a);this.g=a.g;y(a.ka,"Only valid if limit has been set");this.sa=a.sa;this.zb=!(""===a.Eb?a.ia:"l"===a.Eb)}h=Ac.prototype;h.C=function(a,b,c,d,e){this.ma.matches(new N(b,c))||(c=M);return a.K(b).ea(c)?a:a.ub()<this.sa?this.ma.Mb().C(a,b,c,d,e):Bc(this,a,b,c,d,e)};
h.oa=function(a,b,c){var d;if(b.M()||b.e())d=M.Fb(this.g);else if(2*this.sa<b.ub()&&b.Bc(this.g)){d=M.Fb(this.g);b=this.zb?b.Rb(this.ma.wc,this.g):b.Pb(this.ma.Vc,this.g);for(var e=0;0<b.Na.length&&e<this.sa;){var f=P(b),g;if(g=this.zb?0>=this.g.compare(this.ma.Vc,f):0>=this.g.compare(f,this.ma.wc))d=d.P(f.name,f.Y),e++;else break}}else{d=b.Fb(this.g);d=d.Z(M);var k,l,n;if(this.zb){b=d.gf(this.g);k=this.ma.wc;l=this.ma.Vc;var u=mc(this.g);n=function(a,b){return u(b,a)}}else b=d.Ob(this.g),k=this.ma.Vc,
l=this.ma.wc,n=mc(this.g);for(var e=0,x=!1;0<b.Na.length;)f=P(b),!x&&0>=n(k,f)&&(x=!0),(g=x&&e<this.sa&&0>=n(f,l))?e++:d=d.P(f.name,M)}return this.ma.Mb().oa(a,d,c)};h.Z=function(a){return a};h.ya=function(){return!0};h.Mb=function(){return this.ma.Mb()};
function Bc(a,b,c,d,e,f){var g;if(a.zb){var k=mc(a.g);g=function(a,b){return k(b,a)}}else g=mc(a.g);y(b.ub()==a.sa,"");var l=new N(c,d),n=a.zb?Cc(b,a.g):Dc(b,a.g),u=a.ma.matches(l);if(b.Da(c)){var x=b.K(c),n=e.oe(a.g,n,a.zb);null!=n&&n.name==c&&(n=e.oe(a.g,n,a.zb));e=null==n?1:g(n,l);if(u&&!d.e()&&0<=e)return null!=f&&cc(f,new C("child_changed",d,c,x)),b.P(c,d);null!=f&&cc(f,new C("child_removed",x,c));b=b.P(c,M);return null!=n&&a.ma.matches(n)?(null!=f&&cc(f,new C("child_added",n.Y,n.name)),b.P(n.name,
n.Y)):b}return d.e()?b:u&&0<=g(n,l)?(null!=f&&(cc(f,new C("child_removed",n.Y,n.name)),cc(f,new C("child_added",d,c))),b.P(c,d).P(n.name,M)):b};function Ec(){this.vc=this.qa=this.kc=this.ia=this.ka=!1;this.sa=0;this.Eb="";this.Ac=null;this.Wb="";this.zc=null;this.Tb="";this.g=L}var Fc=new Ec;function fc(a){y(a.ia,"Only valid if start has been set");return a.Ac}function ec(a){y(a.ia,"Only valid if start has been set");return a.kc?a.Wb:"[MIN_NAME]"}function hc(a){y(a.qa,"Only valid if end has been set");return a.zc}function gc(a){y(a.qa,"Only valid if end has been set");return a.vc?a.Tb:"[MAX_NAME]"}
function Gc(a){var b=new Ec;b.ka=a.ka;b.sa=a.sa;b.ia=a.ia;b.Ac=a.Ac;b.kc=a.kc;b.Wb=a.Wb;b.qa=a.qa;b.zc=a.zc;b.vc=a.vc;b.Tb=a.Tb;b.g=a.g;return b}h=Ec.prototype;h.xe=function(a){var b=Gc(this);b.ka=!0;b.sa=a;b.Eb="";return b};h.ye=function(a){var b=Gc(this);b.ka=!0;b.sa=a;b.Eb="l";return b};h.ze=function(a){var b=Gc(this);b.ka=!0;b.sa=a;b.Eb="r";return b};h.Od=function(a,b){var c=Gc(this);c.ia=!0;m(a)||(a=null);c.Ac=a;null!=b?(c.kc=!0,c.Wb=b):(c.kc=!1,c.Wb="");return c};
h.hd=function(a,b){var c=Gc(this);c.qa=!0;m(a)||(a=null);c.zc=a;m(b)?(c.vc=!0,c.Tb=b):(c.Ig=!1,c.Tb="");return c};function Hc(a,b){var c=Gc(a);c.g=b;return c}function Ic(a){var b={};a.ia&&(b.sp=a.Ac,a.kc&&(b.sn=a.Wb));a.qa&&(b.ep=a.zc,a.vc&&(b.en=a.Tb));if(a.ka){b.l=a.sa;var c=a.Eb;""===c&&(c=a.ia?"l":"r");b.vf=c}a.g!==L&&(b.i=a.g.toString());return b}function Jc(a){return!(a.ia||a.qa||a.ka)}h.toString=function(){return r(Ic(this))};function Q(a,b,c,d){this.k=a;this.path=b;this.n=c;this.ac=d}
function Kc(a){var b=null,c=null;a.ia&&(b=fc(a));a.qa&&(c=hc(a));if(a.g===rc){if(a.ia){if("[MIN_NAME]"!=ec(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if(null!=b&&"string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.qa){if("[MAX_NAME]"!=gc(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if(null!=
c&&"string"!==typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===L){if(null!=b&&!Qb(b)||null!=c&&!Qb(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(y(a.g instanceof oc,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function Lc(a){if(a.ia&&a.qa&&a.ka&&(!a.ka||""===a.Eb))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function Mc(a,b){if(!0===a.ac)throw Error(b+": You can't combine multiple orderBy calls.");}Q.prototype.cc=function(){F("Query.ref",0,0,arguments.length);return new R(this.k,this.path)};Q.prototype.ref=Q.prototype.cc;
Q.prototype.vb=function(a,b,c,d){F("Query.on",2,4,arguments.length);Wb("Query.on",a,!1);H("Query.on",2,b,!1);var e=Nc("Query.on",c,d);if("value"===a)Oc(this.k,this,new Hb(b,e.cancel||null,e.Ka||null));else{var f={};f[a]=b;Oc(this.k,this,new Ib(f,e.cancel,e.Ka))}return b};Q.prototype.on=Q.prototype.vb;
Q.prototype.Zb=function(a,b,c){F("Query.off",0,3,arguments.length);Wb("Query.off",a,!0);H("Query.off",2,b,!0);Mb("Query.off",3,c);var d=null,e=null;"value"===a?d=new Hb(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new Ib(e,null,c||null));e=this.k;d=".info"===I(this.path)?e.qd.gb(this,d):e.N.gb(this,d);Pc(e.$,this.path,d)};Q.prototype.off=Q.prototype.Zb;
Q.prototype.lg=function(a,b){function c(g){f&&(f=!1,e.Zb(a,c),b.call(d.Ka,g))}F("Query.once",2,4,arguments.length);Wb("Query.once",a,!1);H("Query.once",2,b,!1);var d=Nc("Query.once",arguments[2],arguments[3]),e=this,f=!0;this.vb(a,c,function(b){e.Zb(a,c);d.cancel&&d.cancel.call(d.Ka,b)})};Q.prototype.once=Q.prototype.lg;
Q.prototype.xe=function(a){z("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");F("Query.limit",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limit: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");var b=this.n.xe(a);Lc(b);return new Q(this.k,this.path,b,this.ac)};Q.prototype.limit=Q.prototype.xe;
Q.prototype.ye=function(a){F("Query.limitToFirst",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.ye(a),this.ac)};Q.prototype.limitToFirst=Q.prototype.ye;
Q.prototype.ze=function(a){F("Query.limitToLast",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.ze(a),this.ac)};Q.prototype.limitToLast=Q.prototype.ze;
Q.prototype.mg=function(a){F("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');Xb("Query.orderByChild",1,a,!1);Mc(this,"Query.orderByChild");var b=Hc(this.n,new oc(a));Kc(b);return new Q(this.k,this.path,b,!0)};Q.prototype.orderByChild=Q.prototype.mg;
Q.prototype.ng=function(){F("Query.orderByKey",0,0,arguments.length);Mc(this,"Query.orderByKey");var a=Hc(this.n,rc);Kc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByKey=Q.prototype.ng;Q.prototype.og=function(){F("Query.orderByPriority",0,0,arguments.length);Mc(this,"Query.orderByPriority");var a=Hc(this.n,L);Kc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByPriority=Q.prototype.og;
Q.prototype.Od=function(a,b){F("Query.startAt",0,2,arguments.length);Rb("Query.startAt",a,!0);Xb("Query.startAt",2,b,!0);var c=this.n.Od(a,b);Lc(c);Kc(c);if(this.n.ia)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");m(a)||(b=a=null);return new Q(this.k,this.path,c,this.ac)};Q.prototype.startAt=Q.prototype.Od;
Q.prototype.hd=function(a,b){F("Query.endAt",0,2,arguments.length);Rb("Query.endAt",a,!0);Xb("Query.endAt",2,b,!0);var c=this.n.hd(a,b);Lc(c);Kc(c);if(this.n.qa)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new Q(this.k,this.path,c,this.ac)};Q.prototype.endAt=Q.prototype.hd;
Q.prototype.Tf=function(a,b){F("Query.equalTo",1,2,arguments.length);Rb("Query.equalTo",a,!1);Xb("Query.equalTo",2,b,!0);if(this.n.ia)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.qa)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.Od(a,b).hd(a,b)};Q.prototype.equalTo=Q.prototype.Tf;Q.prototype.Fa=function(){var a=xb(Ic(this.n));return"{}"===a?"default":a};
function Nc(a,b,c){var d={cancel:null,Ka:null};if(b&&c)d.cancel=b,H(a,3,d.cancel,!0),d.Ka=c,Mb(a,4,d.Ka);else if(b)if("object"===typeof b&&null!==b)d.Ka=b;else if("function"===typeof b)d.cancel=b;else throw Error(G(a,3,!0)+" must either be a cancel callback or a context object.");return d};function S(a,b){if(1==arguments.length){this.w=a.split("/");for(var c=0,d=0;d<this.w.length;d++)0<this.w[d].length&&(this.w[c]=this.w[d],c++);this.w.length=c;this.ca=0}else this.w=a,this.ca=b}function I(a){return a.ca>=a.w.length?null:a.w[a.ca]}function Qc(a){return a.w.length-a.ca}function T(a){var b=a.ca;b<a.w.length&&b++;return new S(a.w,b)}function Rc(a){return a.ca<a.w.length?a.w[a.w.length-1]:null}
S.prototype.toString=function(){for(var a="",b=this.ca;b<this.w.length;b++)""!==this.w[b]&&(a+="/"+this.w[b]);return a||"/"};S.prototype.parent=function(){if(this.ca>=this.w.length)return null;for(var a=[],b=this.ca;b<this.w.length-1;b++)a.push(this.w[b]);return new S(a,0)};
S.prototype.o=function(a){for(var b=[],c=this.ca;c<this.w.length;c++)b.push(this.w[c]);if(a instanceof S)for(c=a.ca;c<a.w.length;c++)b.push(a.w[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new S(b,0)};S.prototype.e=function(){return this.ca>=this.w.length};var U=new S("");function V(a,b){var c=I(a);if(null===c)return b;if(c===I(b))return V(T(a),T(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
S.prototype.ea=function(a){if(Qc(this)!==Qc(a))return!1;for(var b=this.ca,c=a.ca;b<=this.w.length;b++,c++)if(this.w[b]!==a.w[c])return!1;return!0};S.prototype.contains=function(a){var b=this.ca,c=a.ca;if(Qc(this)>Qc(a))return!1;for(;b<this.w.length;){if(this.w[b]!==a.w[c])return!1;++b;++c}return!0};function Sc(){this.children={};this.bd=0;this.value=null}function Tc(a,b,c){this.ud=a?a:"";this.Oc=b?b:null;this.A=c?c:new Sc}function Uc(a,b){for(var c=b instanceof S?b:new S(b),d=a,e;null!==(e=I(c));)d=new Tc(e,d,t(d.A.children,e)||new Sc),c=T(c);return d}h=Tc.prototype;h.za=function(){return this.A.value};function Vc(a,b){y("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;Wc(a)}h.clear=function(){this.A.value=null;this.A.children={};this.A.bd=0;Wc(this)};
h.ld=function(){return 0<this.A.bd};h.e=function(){return null===this.za()&&!this.ld()};h.U=function(a){var b=this;A(this.A.children,function(c,d){a(new Tc(d,b,c))})};function Xc(a,b,c,d){c&&!d&&b(a);a.U(function(a){Xc(a,b,!0,d)});c&&d&&b(a)}function Yc(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}h.path=function(){return new S(null===this.Oc?this.ud:this.Oc.path()+"/"+this.ud)};h.name=function(){return this.ud};h.parent=function(){return this.Oc};
function Wc(a){if(null!==a.Oc){var b=a.Oc,c=a.ud,d=a.e(),e=s(b.A.children,c);d&&e?(delete b.A.children[c],b.A.bd--,Wc(b)):d||e||(b.A.children[c]=a.A,b.A.bd++,Wc(b))}};function Zc(a,b){this.Ja=a;this.ua=b?b:$c}h=Zc.prototype;h.La=function(a,b){return new Zc(this.Ja,this.ua.La(a,b,this.Ja).X(null,null,!1,null,null))};h.remove=function(a){return new Zc(this.Ja,this.ua.remove(a,this.Ja).X(null,null,!1,null,null))};h.get=function(a){for(var b,c=this.ua;!c.e();){b=this.Ja(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function ad(a,b){for(var c,d=a.ua,e=null;!d.e();){c=a.Ja(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}h.e=function(){return this.ua.e()};h.count=function(){return this.ua.count()};h.Ic=function(){return this.ua.Ic()};h.Xb=function(){return this.ua.Xb()};h.fa=function(a){return this.ua.fa(a)};
h.Ob=function(a){return new bd(this.ua,null,this.Ja,!1,a)};h.Pb=function(a,b){return new bd(this.ua,a,this.Ja,!1,b)};h.Rb=function(a,b){return new bd(this.ua,a,this.Ja,!0,b)};h.gf=function(a){return new bd(this.ua,null,this.Ja,!0,a)};function bd(a,b,c,d,e){this.Id=e||null;this.ve=d;this.Na=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.ve?a.left:a.right;else if(0===e){this.Na.push(a);break}else this.Na.push(a),a=this.ve?a.right:a.left}
function P(a){if(0===a.Na.length)return null;var b=a.Na.pop(),c;c=a.Id?a.Id(b.key,b.value):{key:b.key,value:b.value};if(a.ve)for(b=b.left;!b.e();)a.Na.push(b),b=b.right;else for(b=b.right;!b.e();)a.Na.push(b),b=b.left;return c}function cd(a){if(0===a.Na.length)return null;var b;b=a.Na;b=b[b.length-1];return a.Id?a.Id(b.key,b.value):{key:b.key,value:b.value}}function dd(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:$c;this.right=null!=e?e:$c}h=dd.prototype;
h.X=function(a,b,c,d,e){return new dd(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};h.count=function(){return this.left.count()+1+this.right.count()};h.e=function(){return!1};h.fa=function(a){return this.left.fa(a)||a(this.key,this.value)||this.right.fa(a)};function ed(a){return a.left.e()?a:ed(a.left)}h.Ic=function(){return ed(this).key};h.Xb=function(){return this.right.e()?this.key:this.right.Xb()};
h.La=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.X(null,null,null,e.left.La(a,b,c),null):0===d?e.X(null,b,null,null,null):e.X(null,null,null,null,e.right.La(a,b,c));return fd(e)};function gd(a){if(a.left.e())return $c;a.left.ba()||a.left.left.ba()||(a=hd(a));a=a.X(null,null,null,gd(a.left),null);return fd(a)}
h.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.ba()||c.left.left.ba()||(c=hd(c)),c=c.X(null,null,null,c.left.remove(a,b),null);else{c.left.ba()&&(c=jd(c));c.right.e()||c.right.ba()||c.right.left.ba()||(c=kd(c),c.left.left.ba()&&(c=jd(c),c=kd(c)));if(0===b(a,c.key)){if(c.right.e())return $c;d=ed(c.right);c=c.X(d.key,d.value,null,null,gd(c.right))}c=c.X(null,null,null,null,c.right.remove(a,b))}return fd(c)};h.ba=function(){return this.color};
function fd(a){a.right.ba()&&!a.left.ba()&&(a=ld(a));a.left.ba()&&a.left.left.ba()&&(a=jd(a));a.left.ba()&&a.right.ba()&&(a=kd(a));return a}function hd(a){a=kd(a);a.right.left.ba()&&(a=a.X(null,null,null,null,jd(a.right)),a=ld(a),a=kd(a));return a}function ld(a){return a.right.X(null,null,a.color,a.X(null,null,!0,null,a.right.left),null)}function jd(a){return a.left.X(null,null,a.color,null,a.X(null,null,!0,a.left.right,null))}
function kd(a){return a.X(null,null,!a.color,a.left.X(null,null,!a.left.color,null,null),a.right.X(null,null,!a.right.color,null,null))}function md(){}h=md.prototype;h.X=function(){return this};h.La=function(a,b){return new dd(a,b,null)};h.remove=function(){return this};h.count=function(){return 0};h.e=function(){return!0};h.fa=function(){return!1};h.Ic=function(){return null};h.Xb=function(){return null};h.ba=function(){return!1};var $c=new md;function nd(a,b){this.D=a;y(m(this.D)&&null!==this.D,"LeafNode shouldn't be created with null/undefined value.");this.ha=b||M;od(this.ha);this.sb=null}h=nd.prototype;h.M=function(){return!0};h.L=function(){return this.ha};h.Z=function(a){return new nd(this.D,a)};h.K=function(a){return".priority"===a?this.ha:M};h.ra=function(a){return a.e()?this:".priority"===I(a)?this.ha:M};h.Da=function(){return!1};h.ff=function(){return null};
h.P=function(a,b){return".priority"===a?this.Z(b):b.e()&&".priority"!==a?this:M.P(a,b).Z(this.ha)};h.C=function(a,b){var c=I(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;y(".priority"!==c||1===Qc(a),".priority must be the last token in a path");return this.P(c,M.C(T(a),b))};h.e=function(){return!1};h.ub=function(){return 0};h.I=function(a){return a&&!this.L().e()?{".value":this.za(),".priority":this.L().I()}:this.za()};
h.hash=function(){if(null===this.sb){var a="";this.ha.e()||(a+="priority:"+pd(this.ha.I())+":");var b=typeof this.D,a=a+(b+":"),a="number"===b?a+Ab(this.D):a+this.D;this.sb=ib(a)}return this.sb};h.za=function(){return this.D};h.he=function(a){if(a===M)return 1;if(a instanceof W)return-1;y(a.M(),"Unknown node type");var b=typeof a.D,c=typeof this.D,d=Ga(qd,b),e=Ga(qd,c);y(0<=d,"Unknown leaf type: "+b);y(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.D<a.D?-1:this.D===a.D?0:1:e-d};
var qd=["object","boolean","number","string"];nd.prototype.Fb=function(){return this};nd.prototype.Bc=function(){return!0};nd.prototype.ea=function(a){return a===this?!0:a.M()?this.D===a.D&&this.ha.ea(a.ha):!1};nd.prototype.toString=function(){return r(this.I(!0))};function rd(a,b){this.pd=a;this.Vb=b}rd.prototype.get=function(a){var b=t(this.pd,a);if(!b)throw Error("No index defined for "+a);return b===lc?null:b};function sd(a,b,c){var d=td(a.pd,function(d,f){var g=t(a.Vb,f);y(g,"Missing index implementation for "+f);if(d===lc){if(g.ue(b.Y)){for(var k=[],l=c.Ob(zc),n=P(l);n;)n.name!=b.name&&k.push(n),n=P(l);k.push(b);return ud(k,mc(g))}return lc}g=c.get(b.name);k=d;g&&(k=k.remove(new N(b.name,g)));return k.La(b,b.Y)});return new rd(d,a.Vb)}
function vd(a,b,c){var d=td(a.pd,function(a){if(a===lc)return a;var d=c.get(b.name);return d?a.remove(new N(b.name,d)):a});return new rd(d,a.Vb)}var wd=new rd({".priority":lc},{".priority":L});function W(a,b,c){this.m=a;(this.ha=b)&&od(this.ha);this.ob=c;this.sb=null}h=W.prototype;h.M=function(){return!1};h.L=function(){return this.ha||M};h.Z=function(a){return new W(this.m,a,this.ob)};h.K=function(a){if(".priority"===a)return this.L();a=this.m.get(a);return null===a?M:a};h.ra=function(a){var b=I(a);return null===b?this:this.K(b).ra(T(a))};h.Da=function(a){return null!==this.m.get(a)};
h.P=function(a,b){y(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.Z(b);var c=new N(a,b),d;b.e()?(d=this.m.remove(a),c=vd(this.ob,c,this.m)):(d=this.m.La(a,b),c=sd(this.ob,c,this.m));return new W(d,this.ha,c)};h.C=function(a,b){var c=I(a);if(null===c)return b;y(".priority"!==I(a)||1===Qc(a),".priority must be the last token in a path");var d=this.K(c).C(T(a),b);return this.P(c,d)};h.e=function(){return this.m.e()};h.ub=function(){return this.m.count()};var xd=/^(0|[1-9]\d*)$/;
h=W.prototype;h.I=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.U(L,function(f,g){b[f]=g.I(a);c++;e&&xd.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],g;for(g in b)f[g]=b[g];return f}a&&!this.L().e()&&(b[".priority"]=this.L().I());return b};h.hash=function(){if(null===this.sb){var a="";this.L().e()||(a+="priority:"+pd(this.L().I())+":");this.U(L,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.sb=""===a?"":ib(a)}return this.sb};
h.ff=function(a,b,c){return(c=yd(this,c))?(a=ad(c,new N(a,b)))?a.name:null:ad(this.m,a)};function Cc(a,b){var c;c=(c=yd(a,b))?(c=c.Ic())&&c.name:a.m.Ic();return c?new N(c,a.m.get(c)):null}function Dc(a,b){var c;c=(c=yd(a,b))?(c=c.Xb())&&c.name:a.m.Xb();return c?new N(c,a.m.get(c)):null}h.U=function(a,b){var c=yd(this,a);return c?c.fa(function(a){return b(a.name,a.Y)}):this.m.fa(b)};h.Ob=function(a){return this.Pb(a.Ce(),a)};
h.Pb=function(a,b){var c=yd(this,b);if(c)return c.Pb(a,function(a){return a});for(var c=this.m.Pb(a.name,zc),d=cd(c);null!=d&&0>b.compare(d,a);)P(c),d=cd(c);return c};h.gf=function(a){return this.Rb(a.Be(),a)};h.Rb=function(a,b){var c=yd(this,b);if(c)return c.Rb(a,function(a){return a});for(var c=this.m.Rb(a.name,zc),d=cd(c);null!=d&&0<b.compare(d,a);)P(c),d=cd(c);return c};h.he=function(a){return this.e()?a.e()?0:-1:a.M()||a.e()?1:a===pc?-1:0};
h.Fb=function(a){if(a===rc||zd(this.ob.Vb,a.toString()))return this;var b=this.ob,c=this.m;y(a!==rc,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.Ob(zc),f=P(c);f;)e=e||a.ue(f.Y),d.push(f),f=P(c);d=e?ud(d,mc(a)):lc;e=a.toString();c=Ad(b.Vb);c[e]=a;a=Ad(b.pd);a[e]=d;return new W(this.m,this.ha,new rd(a,c))};h.Bc=function(a){return a===rc||zd(this.ob.Vb,a.toString())};
h.ea=function(a){if(a===this)return!0;if(a.M())return!1;if(this.L().ea(a.L())&&this.m.count()===a.m.count()){var b=this.Ob(L);a=a.Ob(L);for(var c=P(b),d=P(a);c&&d;){if(c.name!==d.name||!c.Y.ea(d.Y))return!1;c=P(b);d=P(a)}return null===c&&null===d}return!1};function yd(a,b){return b===rc?null:a.ob.get(b.toString())}h.toString=function(){return r(this.I(!0))};function O(a,b){if(null===a)return M;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);y(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new nd(a,O(c));if(a instanceof Array){var d=M,e=a;A(e,function(a,b){if(s(e,b)&&"."!==b.substring(0,1)){var c=O(a);if(c.M()||!c.e())d=
d.P(b,c)}});return d.Z(O(c))}var f=[],g=!1,k=a;ua(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=O(k[a]);b.e()||(g=g||!b.L().e(),f.push(new N(a,b)))}});var l=ud(f,ic,function(a){return a.name},jc);if(g){var n=ud(f,mc(L));return new W(l,O(c),new rd({".priority":n},{".priority":L}))}return new W(l,O(c),wd)}var Bd=Math.log(2);function Cd(a){this.count=parseInt(Math.log(a+1)/Bd,10);this.$e=this.count-1;this.Nf=a+1&parseInt(Array(this.count+1).join("1"),2)}
function Dd(a){var b=!(a.Nf&1<<a.$e);a.$e--;return b}
function ud(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var n=a[b],u=c?c(n):n;return new dd(u,n.Y,!1,null,null)}var n=parseInt(f/2,10)+b,f=e(b,n),x=e(n+1,d),n=a[n],u=c?c(n):n;return new dd(u,n.Y,!1,f,x)}a.sort(b);var f=function(b){function d(b,g){var k=u-b,x=u;u-=b;var x=e(k+1,x),k=a[k],E=c?c(k):k,x=new dd(E,k.Y,g,null,x);f?f.left=x:n=x;f=x}for(var f=null,n=null,u=a.length,x=0;x<b.count;++x){var E=Dd(b),id=Math.pow(2,b.count-(x+1));E?d(id,!1):(d(id,!1),d(id,!0))}return n}(new Cd(a.length));
return null!==f?new Zc(d||b,f):new Zc(d||b)}function pd(a){return"number"===typeof a?"number:"+Ab(a):"string:"+a}function od(a){if(a.M()){var b=a.I();y("string"===typeof b||"number"===typeof b||"object"===typeof b&&s(b,".sv"),"Priority must be a string or number.")}else y(a===pc||a.e(),"priority of unexpected type.");y(a===pc||a.L().e(),"Priority nodes can't have a priority of their own.")}var M=new W(new Zc(jc),null,wd);function Ed(){W.call(this,new Zc(jc),M,wd)}ma(Ed,W);h=Ed.prototype;
h.he=function(a){return a===this?0:1};h.ea=function(a){return a===this};h.L=function(){throw fb("Why is this called?");};h.K=function(){return M};h.e=function(){return!1};var pc=new Ed,nc=new N("[MIN_NAME]",M);function D(a,b,c){this.A=a;this.V=b;this.g=c}D.prototype.I=function(){F("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.I()};D.prototype.val=D.prototype.I;D.prototype.bf=function(){F("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.I(!0)};D.prototype.exportVal=D.prototype.bf;D.prototype.Wf=function(){F("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};D.prototype.exists=D.prototype.Wf;
D.prototype.o=function(a){F("Firebase.DataSnapshot.child",0,1,arguments.length);ga(a)&&(a=String(a));Yb("Firebase.DataSnapshot.child",a);var b=new S(a),c=this.V.o(b);return new D(this.A.ra(b),c,L)};D.prototype.child=D.prototype.o;D.prototype.Da=function(a){F("Firebase.DataSnapshot.hasChild",1,1,arguments.length);Yb("Firebase.DataSnapshot.hasChild",a);var b=new S(a);return!this.A.ra(b).e()};D.prototype.hasChild=D.prototype.Da;
D.prototype.L=function(){F("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.L().I()};D.prototype.getPriority=D.prototype.L;D.prototype.forEach=function(a){F("Firebase.DataSnapshot.forEach",1,1,arguments.length);H("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.M())return!1;var b=this;return!!this.A.U(this.g,function(c,d){return a(new D(d,b.V.o(c),L))})};D.prototype.forEach=D.prototype.forEach;
D.prototype.ld=function(){F("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.M()?!1:!this.A.e()};D.prototype.hasChildren=D.prototype.ld;D.prototype.name=function(){z("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");F("Firebase.DataSnapshot.name",0,0,arguments.length);return this.key()};D.prototype.name=D.prototype.name;D.prototype.key=function(){F("Firebase.DataSnapshot.key",0,0,arguments.length);return this.V.key()};
D.prototype.key=D.prototype.key;D.prototype.ub=function(){F("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.ub()};D.prototype.numChildren=D.prototype.ub;D.prototype.cc=function(){F("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.V};D.prototype.ref=D.prototype.cc;function Fd(a){y(ea(a)&&0<a.length,"Requires a non-empty array");this.Ff=a;this.Gc={}}Fd.prototype.Vd=function(a,b){for(var c=this.Gc[a]||[],d=0;d<c.length;d++)c[d].qc.apply(c[d].Ka,Array.prototype.slice.call(arguments,1))};Fd.prototype.vb=function(a,b,c){Gd(this,a);this.Gc[a]=this.Gc[a]||[];this.Gc[a].push({qc:b,Ka:c});(a=this.qe(a))&&b.apply(c,a)};Fd.prototype.Zb=function(a,b,c){Gd(this,a);a=this.Gc[a]||[];for(var d=0;d<a.length;d++)if(a[d].qc===b&&(!c||c===a[d].Ka)){a.splice(d,1);break}};
function Gd(a,b){y(Ma(a.Ff,function(a){return a===b}),"Unknown event: "+b)};function Hd(){Fd.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.mc=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.mc&&(c.mc=b,c.Vd("visible",b))},!1)}}ma(Hd,Fd);ca(Hd);Hd.prototype.qe=function(a){y("visible"===a,"Unknown event type: "+a);return[this.mc]};function Id(){Fd.call(this,["online"]);this.Lc=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.Lc||a.Vd("online",!0);a.Lc=!0},!1);window.addEventListener("offline",function(){a.Lc&&a.Vd("online",!1);a.Lc=!1},!1)}}ma(Id,Fd);ca(Id);Id.prototype.qe=function(a){y("online"===a,"Unknown event type: "+a);return[this.Lc]};function A(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function td(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function Lb(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function Jb(a){var b=0,c;for(c in a)b++;return b}function Kb(a){for(var b in a)return b}function Jd(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Kd(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function zd(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function Ld(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function Md(a,b){var c=Ld(a,b,void 0);return c&&a[c]}function Nd(a){for(var b in a)return!1;return!0}function Od(a,b){return b in a?a[b]:void 0}function Ad(a){var b={},c;for(c in a)b[c]=a[c];return b}var Pd="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Qd(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Pd.length;f++)c=Pd[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Rd(){this.tc={}}function Sd(a,b,c){m(c)||(c=1);s(a.tc,b)||(a.tc[b]=0);a.tc[b]+=c}Rd.prototype.get=function(){return Ad(this.tc)};function Td(a){this.Pf=a;this.rd=null}Td.prototype.get=function(){var a=this.Pf.get(),b=Ad(a);if(this.rd)for(var c in this.rd)b[c]-=this.rd[c];this.rd=a;return b};function Ud(a,b){this.zf={};this.Pd=new Td(a);this.S=b;var c=1E4+2E4*Math.random();setTimeout(q(this.tf,this),Math.floor(c))}Ud.prototype.tf=function(){var a=this.Pd.get(),b={},c=!1,d;for(d in a)0<a[d]&&s(this.zf,d)&&(b[d]=a[d],c=!0);c&&(a=this.S,a.ja&&(b={c:b},a.f("reportStats",b),a.Ca("s",b)));setTimeout(q(this.tf,this),Math.floor(6E5*Math.random()))};var Vd={},Wd={};function Xd(a){a=a.toString();Vd[a]||(Vd[a]=new Rd);return Vd[a]}function Yd(a,b){var c=a.toString();Wd[c]||(Wd[c]=b());return Wd[c]};var Zd=null;"undefined"!==typeof MozWebSocket?Zd=MozWebSocket:"undefined"!==typeof WebSocket&&(Zd=WebSocket);function $d(a,b,c){this.ie=a;this.f=ob(this.ie);this.frames=this.Cc=null;this.ib=this.jb=this.Te=0;this.Ra=Xd(b);this.$a=(b.Ab?"wss://":"ws://")+b.Ma+"/.ws?v=5";"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(this.$a+="&r=f");b.host!==b.Ma&&(this.$a=this.$a+"&ns="+b.tb);c&&(this.$a=this.$a+"&s="+c)}var ae;
$d.prototype.open=function(a,b){this.fb=b;this.hg=a;this.f("Websocket connecting to "+this.$a);this.xc=!1;za.set("previous_websocket_failure",!0);try{this.ta=new Zd(this.$a)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.eb();return}var e=this;this.ta.onopen=function(){e.f("Websocket connected.");e.xc=!0};this.ta.onclose=function(){e.f("Websocket connection was disconnected.");e.ta=null;e.eb()};this.ta.onmessage=function(a){if(null!==e.ta)if(a=a.data,e.ib+=
a.length,Sd(e.Ra,"bytes_received",a.length),be(e),null!==e.frames)ce(e,a);else{a:{y(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.Te=b;e.frames=[];a=null;break a}}e.Te=1;e.frames=[]}null!==a&&ce(e,a)}};this.ta.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.eb()}};$d.prototype.start=function(){};
$d.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==Zd&&!ae};$d.responsesRequiredToBeHealthy=2;$d.healthyTimeout=3E4;h=$d.prototype;h.sd=function(){za.remove("previous_websocket_failure")};function ce(a,b){a.frames.push(b);if(a.frames.length==a.Te){var c=a.frames.join("");a.frames=null;c=ta(c);a.hg(c)}}
h.send=function(a){be(this);a=r(a);this.jb+=a.length;Sd(this.Ra,"bytes_sent",a.length);a=yb(a,16384);1<a.length&&this.ta.send(String(a.length));for(var b=0;b<a.length;b++)this.ta.send(a[b])};h.Uc=function(){this.qb=!0;this.Cc&&(clearInterval(this.Cc),this.Cc=null);this.ta&&(this.ta.close(),this.ta=null)};h.eb=function(){this.qb||(this.f("WebSocket is closing itself"),this.Uc(),this.fb&&(this.fb(this.xc),this.fb=null))};h.close=function(){this.qb||(this.f("WebSocket is being closed"),this.Uc())};
function be(a){clearInterval(a.Cc);a.Cc=setInterval(function(){a.ta&&a.ta.send("0");be(a)},Math.floor(45E3))};function de(a){this.$b=a;this.Cd=[];this.Jb=0;this.ge=-1;this.wb=null}function ee(a,b,c){a.ge=b;a.wb=c;a.ge<a.Jb&&(a.wb(),a.wb=null)}function fe(a,b,c){for(a.Cd[b]=c;a.Cd[a.Jb];){var d=a.Cd[a.Jb];delete a.Cd[a.Jb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;Cb(function(){f.$b(d[e])})}if(a.Jb===a.ge){a.wb&&(clearTimeout(a.wb),a.wb(),a.wb=null);break}a.Jb++}};function ge(){this.set={}}h=ge.prototype;h.add=function(a,b){this.set[a]=null!==b?b:!0};h.contains=function(a){return s(this.set,a)};h.get=function(a){return this.contains(a)?this.set[a]:void 0};h.remove=function(a){delete this.set[a]};h.clear=function(){this.set={}};h.e=function(){return Nd(this.set)};h.count=function(){return Jb(this.set)};function he(a,b){A(a.set,function(a,d){b(d,a)})};function ie(a,b,c){this.ie=a;this.f=ob(a);this.ib=this.jb=0;this.Ra=Xd(b);this.Md=c;this.xc=!1;this.Zc=function(a){b.host!==b.Ma&&(a.ns=b.tb);var c=[],f;for(f in a)a.hasOwnProperty(f)&&c.push(f+"="+a[f]);return(b.Ab?"https://":"http://")+b.Ma+"/.lp?"+c.join("&")}}var je,ke;
ie.prototype.open=function(a,b){this.Ze=0;this.ga=b;this.mf=new de(a);this.qb=!1;var c=this;this.lb=setTimeout(function(){c.f("Timed out trying to connect.");c.eb();c.lb=null},Math.floor(3E4));tb(function(){if(!c.qb){c.Pa=new le(function(a,b,d,k,l){me(c,arguments);if(c.Pa)if(c.lb&&(clearTimeout(c.lb),c.lb=null),c.xc=!0,"start"==a)c.id=b,c.rf=d;else if("close"===a)b?(c.Pa.Kd=!1,ee(c.mf,b,function(){c.eb()})):c.eb();else throw Error("Unrecognized command received: "+a);},function(a,b){me(c,arguments);
fe(c.mf,a,b)},function(){c.eb()},c.Zc);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Pa.Wd&&(a.cb=c.Pa.Wd);a.v="5";c.Md&&(a.s=c.Md);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.Zc(a);c.f("Connecting via long-poll to "+a);ne(c.Pa,a,function(){})}})};
ie.prototype.start=function(){var a=this.Pa,b=this.rf;a.cg=this.id;a.dg=b;for(a.ae=!0;oe(a););a=this.id;b=this.rf;this.Yb=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.Yb.src=this.Zc(c);this.Yb.style.display="none";document.body.appendChild(this.Yb)};ie.isAvailable=function(){return!ke&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.Eg)&&(je||!0)};h=ie.prototype;
h.sd=function(){};h.Uc=function(){this.qb=!0;this.Pa&&(this.Pa.close(),this.Pa=null);this.Yb&&(document.body.removeChild(this.Yb),this.Yb=null);this.lb&&(clearTimeout(this.lb),this.lb=null)};h.eb=function(){this.qb||(this.f("Longpoll is closing itself"),this.Uc(),this.ga&&(this.ga(this.xc),this.ga=null))};h.close=function(){this.qb||(this.f("Longpoll is being closed."),this.Uc())};
h.send=function(a){a=r(a);this.jb+=a.length;Sd(this.Ra,"bytes_sent",a.length);a=jb(a);a=cb(a,!0);a=yb(a,1840);for(var b=0;b<a.length;b++){var c=this.Pa;c.Qc.push({tg:this.Ze,Bg:a.length,af:a[b]});c.ae&&oe(c);this.Ze++}};function me(a,b){var c=r(b).length;a.ib+=c;Sd(a.Ra,"bytes_received",c)}
function le(a,b,c,d){this.Zc=d;this.fb=c;this.Ie=new ge;this.Qc=[];this.ke=Math.floor(1E8*Math.random());this.Kd=!0;this.Wd=eb();window["pLPCommand"+this.Wd]=a;window["pRTLPCB"+this.Wd]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||hb("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.ab=a.contentDocument:a.contentWindow?a.ab=a.contentWindow.document:a.document&&(a.ab=a.document);this.Ba=a;a="";this.Ba.src&&"javascript:"===this.Ba.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Ba.ab.open(),this.Ba.ab.write(a),this.Ba.ab.close()}catch(f){hb("frame writing exception"),f.stack&&hb(f.stack),hb(f)}}
le.prototype.close=function(){this.ae=!1;if(this.Ba){this.Ba.ab.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Ba&&(document.body.removeChild(a.Ba),a.Ba=null)},Math.floor(0))}var b=this.fb;b&&(this.fb=null,b())};
function oe(a){if(a.ae&&a.Kd&&a.Ie.count()<(0<a.Qc.length?2:1)){a.ke++;var b={};b.id=a.cg;b.pw=a.dg;b.ser=a.ke;for(var b=a.Zc(b),c="",d=0;0<a.Qc.length;)if(1870>=a.Qc[0].af.length+30+c.length){var e=a.Qc.shift(),c=c+"&seg"+d+"="+e.tg+"&ts"+d+"="+e.Bg+"&d"+d+"="+e.af;d++}else break;pe(a,b+c,a.ke);return!0}return!1}function pe(a,b,c){function d(){a.Ie.remove(c);oe(a)}a.Ie.add(c);var e=setTimeout(d,Math.floor(25E3));ne(a,b,function(){clearTimeout(e);d()})}
function ne(a,b,c){setTimeout(function(){try{if(a.Kd){var d=a.Ba.ab.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){hb("Long-poll script failed to load: "+b);a.Kd=!1;a.close()};a.Ba.ab.body.appendChild(d)}}catch(e){}},Math.floor(1))};function qe(a){re(this,a)}var se=[ie,$d];function re(a,b){var c=$d&&$d.isAvailable(),d=c&&!(za.lf||!0===za.get("previous_websocket_failure"));b.Dg&&(c||z("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.Xc=[$d];else{var e=a.Xc=[];zb(se,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function te(a){if(0<a.Xc.length)return a.Xc[0];throw Error("No transports available");};function ue(a,b,c,d,e,f){this.id=a;this.f=ob("c:"+this.id+":");this.$b=c;this.Kc=d;this.ga=e;this.Ge=f;this.O=b;this.Bd=[];this.Xe=0;this.Af=new qe(b);this.Qa=0;this.f("Connection created");ve(this)}
function ve(a){var b=te(a.Af);a.J=new b("c:"+a.id+":"+a.Xe++,a.O);a.Ke=b.responsesRequiredToBeHealthy||0;var c=we(a,a.J),d=xe(a,a.J);a.Yc=a.J;a.Tc=a.J;a.B=null;a.rb=!1;setTimeout(function(){a.J&&a.J.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.nd=setTimeout(function(){a.nd=null;a.rb||(a.J&&102400<a.J.ib?(a.f("Connection exceeded healthy timeout but has received "+a.J.ib+" bytes.  Marking connection healthy."),a.rb=!0,a.J.sd()):a.J&&10240<a.J.jb?a.f("Connection exceeded healthy timeout but has sent "+
a.J.jb+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function xe(a,b){return function(c){b===a.J?(a.J=null,c||0!==a.Qa?1===a.Qa&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.O.Ma.substr(0,2)&&(za.remove("host:"+a.O.host),a.O.Ma=a.O.host)),a.close()):b===a.B?(a.f("Secondary connection lost."),c=a.B,a.B=null,a.Yc!==c&&a.Tc!==c||a.close()):a.f("closing an old connection")}}
function we(a,b){return function(c){if(2!=a.Qa)if(b===a.Tc){var d=wb("t",c);c=wb("d",c);if("c"==d){if(d=wb("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.Md=c.s;Ba(a.O,f);0==a.Qa&&(a.J.start(),ye(a,a.J,d),"5"!==e&&z("Protocol version mismatch detected"),c=a.Af,(c=1<c.Xc.length?c.Xc[1]:null)&&ze(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.Tc=a.B;for(c=0;c<a.Bd.length;++c)a.xd(a.Bd[c]);a.Bd=[];Ae(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.Ge&&(a.Ge(c),a.Ge=null),a.ga=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),Ba(a.O,c),1===a.Qa?a.close():(Be(a),ve(a))):"e"===d?pb("Server Error: "+c):"o"===d?(a.f("got pong on primary."),Ce(a),De(a)):pb("Unknown control packet command: "+d)}else"d"==d&&a.xd(c)}else if(b===a.B)if(d=wb("t",c),c=wb("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?Ee(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.B.close(),a.Yc!==a.B&&a.Tc!==a.B||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.yf--,Ee(a)));else if("d"==d)a.Bd.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}ue.prototype.Ca=function(a){Fe(this,{t:"d",d:a})};function Ae(a){a.Yc===a.B&&a.Tc===a.B&&(a.f("cleaning up and promoting a connection: "+a.B.ie),a.J=a.B,a.B=null)}
function Ee(a){0>=a.yf?(a.f("Secondary connection is healthy."),a.rb=!0,a.B.sd(),a.B.start(),a.f("sending client ack on secondary"),a.B.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.J.send({t:"c",d:{t:"n",d:{}}}),a.Yc=a.B,Ae(a)):(a.f("sending ping on secondary."),a.B.send({t:"c",d:{t:"p",d:{}}}))}ue.prototype.xd=function(a){Ce(this);this.$b(a)};function Ce(a){a.rb||(a.Ke--,0>=a.Ke&&(a.f("Primary connection is healthy."),a.rb=!0,a.J.sd()))}
function ze(a,b){a.B=new b("c:"+a.id+":"+a.Xe++,a.O,a.Md);a.yf=b.responsesRequiredToBeHealthy||0;a.B.open(we(a,a.B),xe(a,a.B));setTimeout(function(){a.B&&(a.f("Timed out trying to upgrade."),a.B.close())},Math.floor(6E4))}function ye(a,b,c){a.f("Realtime connection established.");a.J=b;a.Qa=1;a.Kc&&(a.Kc(c),a.Kc=null);0===a.Ke?(a.f("Primary connection is healthy."),a.rb=!0):setTimeout(function(){De(a)},Math.floor(5E3))}
function De(a){a.rb||1!==a.Qa||(a.f("sending ping on primary."),Fe(a,{t:"c",d:{t:"p",d:{}}}))}function Fe(a,b){if(1!==a.Qa)throw"Connection is not connected";a.Yc.send(b)}ue.prototype.close=function(){2!==this.Qa&&(this.f("Closing realtime connection."),this.Qa=2,Be(this),this.ga&&(this.ga(),this.ga=null))};function Be(a){a.f("Shutting down all connections");a.J&&(a.J.close(),a.J=null);a.B&&(a.B.close(),a.B=null);a.nd&&(clearTimeout(a.nd),a.nd=null)};function Ge(a){var b={},c={},d={},e="";try{var f=a.split("."),b=ta(gb(f[0])||""),c=ta(gb(f[1])||""),e=f[2],d=c.d||{};delete c.d}catch(g){}return{Gg:b,fe:c,data:d,xg:e}}function He(a){a=Ge(a).fe;return"object"===typeof a&&a.hasOwnProperty("iat")?t(a,"iat"):null}function Ie(a){a=Ge(a);var b=a.fe;return!!a.xg&&!!b&&"object"===typeof b&&b.hasOwnProperty("iat")};function Je(a,b,c,d){this.id=Ke++;this.f=ob("p:"+this.id+":");this.Cb=!0;this.Aa={};this.la=[];this.Nc=0;this.Jc=[];this.ja=!1;this.Wa=1E3;this.td=3E5;this.yd=b;this.wd=c;this.He=d;this.O=a;this.Oe=null;this.Sc={};this.sg=0;this.Dc=this.we=null;Le(this,0);Hd.Nb().vb("visible",this.kg,this);-1===a.host.indexOf("fblocal")&&Id.Nb().vb("online",this.ig,this)}var Ke=0,Me=0;h=Je.prototype;
h.Ca=function(a,b,c){var d=++this.sg;a={r:d,a:a,b:b};this.f(r(a));y(this.ja,"sendRequest call when we're not connected not allowed.");this.Oa.Ca(a);c&&(this.Sc[d]=c)};function Ne(a,b,c,d,e){var f=b.Fa(),g=b.path.toString();a.f("Listen called for "+g+" "+f);a.Aa[g]=a.Aa[g]||{};y(!a.Aa[g][f],"listen() called twice for same path/queryId.");b={H:e,md:c,pg:Ic(b.n),tag:d};a.Aa[g][f]=b;a.ja&&Oe(a,g,f,b)}
function Oe(a,b,c,d){a.f("Listen on "+b+" for "+c);var e={p:b};d.tag&&(e.q=d.pg,e.t=d.tag);e.h=d.md();a.Ca("q",e,function(e){if((a.Aa[b]&&a.Aa[b][c])===d){a.f("listen response",e);var g=e.s;"ok"!==g&&Pe(a,b,c);e=e.d;d.H&&d.H(g,e)}})}h.Q=function(a,b,c){this.Ib={Rf:a,cf:!1,qc:b,ad:c};this.f("Authenticating using credential: "+a);Qe(this);(b=40==a.length)||(a=Ge(a).fe,b="object"===typeof a&&!0===t(a,"admin"));b&&(this.f("Admin auth credential detected.  Reducing max reconnect time."),this.td=3E4)};
h.Ue=function(a){delete this.Ib;this.ja&&this.Ca("unauth",{},function(b){a(b.s,b.d)})};function Qe(a){var b=a.Ib;a.ja&&b&&a.Ca("auth",{cred:b.Rf},function(c){var d=c.s;c=c.d||"error";"ok"!==d&&a.Ib===b&&delete a.Ib;b.cf?"ok"!==d&&b.ad&&b.ad(d,c):(b.cf=!0,b.qc&&b.qc(d,c))})}function Re(a,b,c,d){a.ja?Se(a,"o",b,c,d):a.Jc.push({Pc:b,action:"o",data:c,H:d})}function Te(a,b,c,d){a.ja?Se(a,"om",b,c,d):a.Jc.push({Pc:b,action:"om",data:c,H:d})}
h.Fe=function(a,b){this.ja?Se(this,"oc",a,null,b):this.Jc.push({Pc:a,action:"oc",data:null,H:b})};function Se(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.Ca(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}h.put=function(a,b,c,d){Ue(this,"p",a,b,c,d)};function Ve(a,b,c,d){Ue(a,"m",b,c,d,void 0)}function Ue(a,b,c,d,e,f){d={p:c,d:d};m(f)&&(d.h=f);a.la.push({action:b,uf:d,H:e});a.Nc++;b=a.la.length-1;a.ja?We(a,b):a.f("Buffering put: "+c)}
function We(a,b){var c=a.la[b].action,d=a.la[b].uf,e=a.la[b].H;a.la[b].qg=a.ja;a.Ca(c,d,function(d){a.f(c+" response",d);delete a.la[b];a.Nc--;0===a.Nc&&(a.la=[]);e&&e(d.s,d.d)})}
h.xd=function(a){if("r"in a){this.f("from server: "+r(a));var b=a.r,c=this.Sc[b];c&&(delete this.Sc[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,c=a.b,this.f("handleServerMessage",b,c),"d"===b?this.yd(c.p,c.d,!1,c.t):"m"===b?this.yd(c.p,c.d,!0,c.t):"c"===b?Xe(this,c.p,c.q):"ac"===b?(a=c.s,b=c.d,c=this.Ib,delete this.Ib,c&&c.ad&&c.ad(a,b)):"sd"===b?this.Oe?this.Oe(c):"msg"in c&&"undefined"!==typeof console&&console.log("FIREBASE: "+c.msg.replace("\n",
"\nFIREBASE: ")):pb("Unrecognized action received from server: "+r(b)+"\nAre you using the latest client?"))}};h.Kc=function(a){this.f("connection ready");this.ja=!0;this.Dc=(new Date).getTime();this.He({serverTimeOffset:a-(new Date).getTime()});Ye(this);this.wd(!0)};function Le(a,b){y(!a.Oa,"Scheduling a connect when we're already connected/ing?");a.Kb&&clearTimeout(a.Kb);a.Kb=setTimeout(function(){a.Kb=null;Ze(a)},Math.floor(b))}
h.kg=function(a){a&&!this.mc&&this.Wa===this.td&&(this.f("Window became visible.  Reducing delay."),this.Wa=1E3,this.Oa||Le(this,0));this.mc=a};h.ig=function(a){a?(this.f("Browser went online.  Reconnecting."),this.Wa=1E3,this.Cb=!0,this.Oa||Le(this,0)):(this.f("Browser went offline.  Killing connection; don't reconnect."),this.Cb=!1,this.Oa&&this.Oa.close())};
h.of=function(){this.f("data client disconnected");this.ja=!1;this.Oa=null;for(var a=0;a<this.la.length;a++){var b=this.la[a];b&&"h"in b.uf&&b.qg&&(b.H&&b.H("disconnect"),delete this.la[a],this.Nc--)}0===this.Nc&&(this.la=[]);if(this.Cb)this.mc?this.Dc&&(3E4<(new Date).getTime()-this.Dc&&(this.Wa=1E3),this.Dc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.Wa=this.td,this.we=(new Date).getTime()),a=Math.max(0,this.Wa-((new Date).getTime()-this.we)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),Le(this,a),this.Wa=Math.min(this.td,1.3*this.Wa);else for(var c in this.Sc)delete this.Sc[c];this.wd(!1)};function Ze(a){if(a.Cb){a.f("Making a connection attempt");a.we=(new Date).getTime();a.Dc=null;var b=q(a.xd,a),c=q(a.Kc,a),d=q(a.of,a),e=a.id+":"+Me++;a.Oa=new ue(e,a.O,b,c,d,function(b){z(b+" ("+a.O.toString()+")");a.Cb=!1})}}h.pb=function(){this.Cb=!1;this.Oa?this.Oa.close():(this.Kb&&(clearTimeout(this.Kb),this.Kb=null),this.ja&&this.of())};
h.hc=function(){this.Cb=!0;this.Wa=1E3;this.Oa||Le(this,0)};function Xe(a,b,c){c=c?Ja(c,function(a){return xb(a)}).join("$"):"default";(a=Pe(a,b,c))&&a.H&&a.H("permission_denied")}function Pe(a,b,c){b=(new S(b)).toString();var d=a.Aa[b][c];delete a.Aa[b][c];0===Jb(a.Aa[b])&&delete a.Aa[b];return d}function Ye(a){Qe(a);A(a.Aa,function(b,d){A(b,function(b,c){Oe(a,d,c,b)})});for(var b=0;b<a.la.length;b++)a.la[b]&&We(a,b);for(;a.Jc.length;)b=a.Jc.shift(),Se(a,b.action,b.Pc,b.data,b.H)};function $e(){this.m=this.D=null}$e.prototype.dc=function(a,b){if(a.e())this.D=b,this.m=null;else if(null!==this.D)this.D=this.D.C(a,b);else{null==this.m&&(this.m=new ge);var c=I(a);this.m.contains(c)||this.m.add(c,new $e);c=this.m.get(c);a=T(a);c.dc(a,b)}};
function af(a,b){if(b.e())return a.D=null,a.m=null,!0;if(null!==a.D){if(a.D.M())return!1;var c=a.D;a.D=null;c.U(L,function(b,c){a.dc(new S(b),c)});return af(a,b)}return null!==a.m?(c=I(b),b=T(b),a.m.contains(c)&&af(a.m.get(c),b)&&a.m.remove(c),a.m.e()?(a.m=null,!0):!1):!0}function bf(a,b,c){null!==a.D?c(b,a.D):a.U(function(a,e){var f=new S(b.toString()+"/"+a);bf(e,f,c)})}$e.prototype.U=function(a){null!==this.m&&he(this.m,function(b,c){a(b,c)})};function cf(){this.Jd=M}cf.prototype.j=function(a){return this.Jd.ra(a)};cf.prototype.toString=function(){return this.Jd.toString()};function df(){this.nb=[]}function ef(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.Qb();null===c||f.ea(c.Qb())||(a.nb.push(c),c=null);null===c&&(c=new ff(f));c.add(e)}c&&a.nb.push(c)}function Pc(a,b,c){ef(a,c);gf(a,function(a){return a.ea(b)})}function hf(a,b,c){ef(a,c);gf(a,function(a){return a.contains(b)||b.contains(a)})}
function gf(a,b){for(var c=!0,d=0;d<a.nb.length;d++){var e=a.nb[d];if(e)if(e=e.Qb(),b(e)){for(var e=a.nb[d],f=0;f<e.kd.length;f++){var g=e.kd[f];if(null!==g){e.kd[f]=null;var k=g.Lb();lb&&hb("event: "+g.toString());Cb(k)}}a.nb[d]=null}else c=!1}c&&(a.nb=[])}function ff(a){this.Ea=a;this.kd=[]}ff.prototype.add=function(a){this.kd.push(a)};ff.prototype.Qb=function(){return this.Ea};var jf="auth.firebase.com";function kf(a,b,c){this.cd=a||{};this.Ud=b||{};this.Xa=c||{};this.cd.remember||(this.cd.remember="default")}var lf=["remember","redirectTo"];function mf(a){var b={},c={};ua(a||{},function(a,e){0<=Ga(lf,a)?b[a]=e:c[a]=e});return new kf(b,{},c)};var nf={NETWORK_ERROR:"Unable to contact the Firebase server.",SERVER_ERROR:"An unknown server error occurred.",TRANSPORT_UNAVAILABLE:"There are no login transports available for the requested method.",REQUEST_INTERRUPTED:"The browser redirected the page before the login request could complete.",USER_CANCELLED:"The user cancelled authentication."};function X(a){var b=Error(t(nf,a),a);b.code=a;return b};function of(){var a=window.opener.frames,b;for(b=a.length-1;0<=b;b--)try{if(a[b].location.protocol===window.location.protocol&&a[b].location.host===window.location.host&&"__winchan_relay_frame"===a[b].name)return a[b]}catch(c){}return null}function pf(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,!1)}function qf(a,b,c){a.detachEvent?a.detachEvent("on"+b,c):a.removeEventListener&&a.removeEventListener(b,c,!1)}
function rf(a){/^https?:\/\//.test(a)||(a=window.location.href);var b=/^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);return b?b[1]:a}function sf(a){var b="";try{a=a.replace("#","");var c={},d=a.replace(/^\?/,"").split("&");for(a=0;a<d.length;a++)if(d[a]){var e=d[a].split("=");c[e[0]]=e[1]}c&&s(c,"__firebase_request_key")&&(b=t(c,"__firebase_request_key"))}catch(f){}return b}
function tf(a){var b=[],c;for(c in a)if(s(a,c)){var d=t(a,c);if(ea(d))for(var e=0;e<d.length;e++)b.push(encodeURIComponent(c)+"="+encodeURIComponent(d[e]));else b.push(encodeURIComponent(c)+"="+encodeURIComponent(t(a,c)))}return b?"&"+b.join("&"):""}function uf(){var a=rb(jf);return a.scheme+"://"+a.host+"/v2"}function vf(a){return uf()+"/"+a+"/auth/channel"};function wf(){return!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(navigator.userAgent)}function xf(){var a=navigator.userAgent;if("Microsoft Internet Explorer"===navigator.appName){if((a=a.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1])}else if(-1<a.indexOf("Trident")&&(a=a.match(/rv:([0-9]{2,2}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1]);return!1};function yf(a){a.method||(a.method="GET");a.headers||(a.headers={});a.headers.content_type||(a.headers.content_type="application/json");a.headers.content_type=a.headers.content_type.toLowerCase();this.options=a}
yf.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}var e=new XMLHttpRequest,f=this.options.method.toUpperCase(),g;pf(window,"beforeunload",d);e.onreadystatechange=function(){if(c&&4===e.readyState){var a;if(200<=e.status&&300>e.status){try{a=ta(e.responseText)}catch(b){}c(null,a)}else 500<=e.status&&600>e.status?c(X("SERVER_ERROR")):c(X("NETWORK_ERROR"));c=null;qf(window,"beforeunload",d)}};if("GET"===f)a+=(/\?/.test(a)?"":"?")+tf(b),g=null;else{var k=this.options.headers.content_type;
"application/json"===k&&(g=r(b));"application/x-www-form-urlencoded"===k&&(g=tf(b))}e.open(f,a,!0);a={"X-Requested-With":"XMLHttpRequest",Accept:"application/json;text/plain"};Qd(a,this.options.headers);for(var l in a)e.setRequestHeader(l,a[l]);e.send(g)};yf.isAvailable=function(){return!!window.XMLHttpRequest&&"string"===typeof(new XMLHttpRequest).responseType&&(!(navigator.userAgent.match(/MSIE/)||navigator.userAgent.match(/Trident/))||xf())};yf.prototype.sc=function(){return"json"};function zf(a){this.fc=Fa()+Fa()+Fa();this.pf=a}
zf.prototype.open=function(a,b,c){function d(){c&&(c(X("USER_CANCELLED")),c=null)}var e=this,f=rb(jf),g;b.requestId=this.fc;b.redirectTo=f.scheme+"://"+f.host+"/blank/page.html";a+=/\?/.test(a)?"":"?";a+=tf(b);(g=window.open(a,"_blank","location=no"))&&ha(g.addEventListener)?(g.addEventListener("loadstart",function(a){var b;if(b=a&&a.url)a:{var n=a.url;try{var u=document.createElement("a");u.href=n;b=u.host===f.host&&"/blank/page.html"===u.pathname;break a}catch(x){}b=!1}b&&(a=sf(a.url),g.removeEventListener("exit",
d),g.close(),a=new kf(null,null,{requestId:e.fc,requestKey:a}),e.pf.requestWithCredential("/auth/session",a,c),c=null)}),g.addEventListener("exit",d)):c(X("TRANSPORT_UNAVAILABLE"))};zf.isAvailable=function(){return wf()};zf.prototype.sc=function(){return"redirect"};function Af(a){if(!a.window_features||-1!==navigator.userAgent.indexOf("Fennec/")||-1!==navigator.userAgent.indexOf("Firefox/")&&-1!==navigator.userAgent.indexOf("Android"))a.window_features=void 0;a.window_name||(a.window_name="_blank");this.options=a}
Af.prototype.open=function(a,b,c){function d(a){g&&(document.body.removeChild(g),g=void 0);u&&(u=clearInterval(u));qf(window,"message",e);qf(window,"unload",d);if(n&&!a)try{n.close()}catch(b){k.postMessage("die",l)}n=k=void 0}function e(a){if(a.origin===l)try{var b=ta(a.data);"ready"===b.a?k.postMessage(x,l):"error"===b.a?(d(!1),c&&(c(b.d),c=null)):"response"===b.a&&(d(b.forceKeepWindowOpen),c&&(c(null,b.d),c=null))}catch(e){}}var f=xf(),g,k;if(!this.options.relay_url)return c(Error("invalid arguments: origin of url and relay_url must match"));
var l=rf(a);if(l!==rf(this.options.relay_url))c&&setTimeout(function(){c(Error("invalid arguments: origin of url and relay_url must match"))},0);else{f&&(g=document.createElement("iframe"),g.setAttribute("src",this.options.relay_url),g.style.display="none",g.setAttribute("name","__winchan_relay_frame"),document.body.appendChild(g),k=g.contentWindow);a+=(/\?/.test(a)?"":"?")+tf(b);var n=window.open(a,this.options.window_name,this.options.window_features);k||(k=n);var u=setInterval(function(){n&&n.closed&&
(d(!1),c&&(c(X("USER_CANCELLED")),c=null))},500),x=r({a:"request",d:b});pf(window,"unload",d);pf(window,"message",e)}};
Af.isAvailable=function(){return"postMessage"in window&&!/^file:\//.test(location.href)&&!(wf()||navigator.userAgent.match(/Windows Phone/)||window.Windows&&/^ms-appx:/.test(location.href)||navigator.userAgent.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)||navigator.userAgent.match(/CriOS/)||navigator.userAgent.match(/Twitter for iPhone/)||navigator.userAgent.match(/FBAN\/FBIOS/)||window.navigator.standalone)&&!navigator.userAgent.match(/PhantomJS/)};Af.prototype.sc=function(){return"popup"};function Bf(a){a.callback_parameter||(a.callback_parameter="callback");this.options=a;window.__firebase_auth_jsonp=window.__firebase_auth_jsonp||{}}
Bf.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}function e(){setTimeout(function(){window.__firebase_auth_jsonp[f]=void 0;Nd(window.__firebase_auth_jsonp)&&(window.__firebase_auth_jsonp=void 0);try{var a=document.getElementById(f);a&&a.parentNode.removeChild(a)}catch(b){}},1);qf(window,"beforeunload",d)}var f="fn"+(new Date).getTime()+Math.floor(99999*Math.random());b[this.options.callback_parameter]="__firebase_auth_jsonp."+f;a+=(/\?/.test(a)?"":"?")+tf(b);
pf(window,"beforeunload",d);window.__firebase_auth_jsonp[f]=function(a){c&&(c(null,a),c=null);e()};Cf(f,a,c)};
function Cf(a,b,c){setTimeout(function(){try{var d=document.createElement("script");d.type="text/javascript";d.id=a;d.async=!0;d.src=b;d.onerror=function(){var b=document.getElementById(a);null!==b&&b.parentNode.removeChild(b);c&&c(X("NETWORK_ERROR"))};var e=document.getElementsByTagName("head");(e&&0!=e.length?e[0]:document.documentElement).appendChild(d)}catch(f){c&&c(X("NETWORK_ERROR"))}},0)}Bf.isAvailable=function(){return!wf()};Bf.prototype.sc=function(){return"json"};function Df(a,b){this.Je=["session",a.Dd,a.tb].join(":");this.Rd=b}Df.prototype.set=function(a,b){if(!b)if(this.Rd.length)b=this.Rd[0];else throw Error("fb.login.SessionManager : No storage options available!");b.set(this.Je,a)};Df.prototype.get=function(){var a=Ja(this.Rd,q(this.Zf,this)),a=Ia(a,function(a){return null!==a});Qa(a,function(a,c){return He(c.token)-He(a.token)});return 0<a.length?a.shift():null};Df.prototype.Zf=function(a){try{var b=a.get(this.Je);if(b&&b.token)return b}catch(c){}return null};
Df.prototype.clear=function(){var a=this;Ha(this.Rd,function(b){b.remove(a.Je)})};function Ef(a){this.fc=Fa()+Fa()+Fa();this.pf=a}Ef.prototype.open=function(a,b){v.set("redirect_request_id",this.fc);v.set("redirect_request_id",this.fc);b.requestId=this.fc;b.redirectTo=b.redirectTo||window.location.href;a+=(/\?/.test(a)?"":"?")+tf(b);window.location=a};Ef.isAvailable=function(){return!/^file:\//.test(location.href)&&!wf()};Ef.prototype.sc=function(){return"redirect"};function Ff(a,b,c,d){Fd.call(this,["auth_status"]);this.O=a;this.We=b;this.Cg=c;this.Ee=d;this.ic=new Df(a,[za,v]);this.hb=null;Gf(this)}ma(Ff,Fd);h=Ff.prototype;h.ne=function(){return this.hb||null};function Gf(a){v.get("redirect_request_id")&&Hf(a);var b=a.ic.get();b&&b.token?(If(a,b),a.We(b.token,function(c,d){Jf(a,c,d,!1,b.token,b)},function(b,d){Kf(a,"resumeSession()",b,d)})):If(a,null)}
function Lf(a,b,c,d,e,f){"firebaseio-demo.com"===a.O.domain&&z("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");a.We(b,function(f,k){Jf(a,f,k,!0,b,c,d||{},e)},function(b,c){Kf(a,"auth()",b,c,f)})}function Mf(a,b){a.ic.clear();If(a,null);a.Cg(function(a,d){if("ok"===a)B(b,null);else{var e=(a||"error").toUpperCase(),f=e;d&&(f+=": "+d);f=Error(f);f.code=e;B(b,f)}})}
function Jf(a,b,c,d,e,f,g,k){"ok"===b?(d&&(b=c.auth,f.auth=b,f.expires=c.expires,f.token=Ie(e)?e:"",c=null,b&&s(b,"uid")?c=t(b,"uid"):s(f,"uid")&&(c=t(f,"uid")),f.uid=c,c="custom",b&&s(b,"provider")?c=t(b,"provider"):s(f,"provider")&&(c=t(f,"provider")),f.provider=c,a.ic.clear(),Ie(e)&&(g=g||{},c=za,"sessionOnly"===g.remember&&(c=v),"none"!==g.remember&&a.ic.set(f,c)),If(a,f)),B(k,null,f)):(a.ic.clear(),If(a,null),f=a=(b||"error").toUpperCase(),c&&(f+=": "+c),f=Error(f),f.code=a,B(k,f))}
function Kf(a,b,c,d,e){z(b+" was canceled: "+d);a.ic.clear();If(a,null);a=Error(d);a.code=c.toUpperCase();B(e,a)}function Nf(a,b,c,d,e){Of(a);c=new kf(d||{},{},c||{});Pf(a,[yf,Bf],"/auth/"+b,c,e)}
function Qf(a,b,c,d){Of(a);var e=[Af,zf];c=mf(c);"anonymous"===b||"password"===b?setTimeout(function(){B(d,X("TRANSPORT_UNAVAILABLE"))},0):(c.Ud.window_features="menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top="+("object"===typeof screen?.5*(screen.height-625):0)+",left="+("object"===typeof screen?.5*(screen.width-625):0),c.Ud.relay_url=vf(a.O.tb),c.Ud.requestWithCredential=q(a.gc,a),Pf(a,e,"/auth/"+b,c,d))}
function Hf(a){var b=v.get("redirect_request_id");if(b){var c=v.get("redirect_client_options");v.remove("redirect_request_id");v.remove("redirect_client_options");var d=[yf,Bf],b={requestId:b,requestKey:sf(document.location.hash)},c=new kf(c,{},b);try{document.location.hash=document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/,"")}catch(e){}Pf(a,d,"/auth/session",c)}}h.je=function(a,b){Of(this);var c=mf(a);c.Xa._method="POST";this.gc("/users",c,function(a,c){a?B(b,a):B(b,a,c)})};
h.Le=function(a,b){var c=this;Of(this);var d="/users/"+encodeURIComponent(a.email),e=mf(a);e.Xa._method="DELETE";this.gc(d,e,function(a,d){!a&&d&&d.uid&&c.hb&&c.hb.uid&&c.hb.uid===d.uid&&Mf(c);B(b,a)})};h.ee=function(a,b){Of(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=mf(a);d.Xa._method="PUT";d.Xa.password=a.newPassword;this.gc(c,d,function(a){B(b,a)})};
h.de=function(a,b){Of(this);var c="/users/"+encodeURIComponent(a.oldEmail)+"/email",d=mf(a);d.Xa._method="PUT";d.Xa.email=a.newEmail;d.Xa.password=a.password;this.gc(c,d,function(a){B(b,a)})};h.Me=function(a,b){Of(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=mf(a);d.Xa._method="POST";this.gc(c,d,function(a){B(b,a)})};h.gc=function(a,b,c){Rf(this,[yf,Bf],a,b,c)};
function Pf(a,b,c,d,e){Rf(a,b,c,d,function(b,c){!b&&c&&c.token&&c.uid?Lf(a,c.token,c,d.cd,function(a,b){a?B(e,a):B(e,null,b)}):B(e,b||X("UNKNOWN_ERROR"))})}
function Rf(a,b,c,d,e){b=Ia(b,function(a){return"function"===typeof a.isAvailable&&a.isAvailable()});0===b.length?setTimeout(function(){B(e,X("TRANSPORT_UNAVAILABLE"))},0):(b=new (b.shift())(d.Ud),d=va(d.Xa),d.v="js-2.1.2",d.transport=b.sc(),d.suppress_status_codes=!0,a=uf()+"/"+a.O.tb+c,b.open(a,d,function(a,b){if(a)B(e,a);else if(b&&b.error){var c=Error(b.error.message);c.code=b.error.code;c.details=b.error.details;B(e,c)}else B(e,null,b)}))}
function If(a,b){var c=null!==a.hb||null!==b;a.hb=b;c&&a.Vd("auth_status",b);a.Ee(null!==b)}h.qe=function(a){y("auth_status"===a,'initial event must be of type "auth_status"');return[this.hb]};function Of(a){var b=a.O;if("firebaseio.com"!==b.domain&&"firebaseio-demo.com"!==b.domain&&"auth.firebase.com"===jf)throw Error("This custom Firebase server ('"+a.O.domain+"') does not support delegated login.");};function Sf(a,b){return a&&"object"===typeof a?(y(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function Tf(a,b){var c=new $e;bf(a,new S(""),function(a,e){c.dc(a,Uf(e,b))});return c}function Uf(a,b){var c=a.L().I(),c=Sf(c,b),d;if(a.M()){var e=Sf(a.za(),b);return e!==a.za()||c!==a.L().I()?new nd(e,O(c)):a}d=a;c!==a.L().I()&&(d=d.Z(new nd(c)));a.U(L,function(a,c){var e=Uf(c,b);e!==c&&(d=d.P(a,e))});return d};function wc(a,b,c){this.A=a;this.aa=b;this.yc=c}function Vf(a){return a.aa}function vc(a,b){return a.aa&&!a.yc||a.A.Da(b)}wc.prototype.j=function(){return this.A};function Wf(a,b){this.F=a;this.Ld=b}function Xf(a,b,c,d){return new Wf(new wc(b,c,d),a.Ld)}function Yf(a){return a.F.aa?a.F.j():null}Wf.prototype.u=function(){return this.Ld};function xc(a){return a.Ld.aa?a.Ld.j():null};function Zf(a,b){this.Yd=a;this.Of=b}function $f(a){this.G=a}
$f.prototype.Ya=function(a,b,c,d){var e=new yc,f;if(b.type===ag)b.source.me?c=bg(this,a,b.path,b.Ga,c,d,e):(y(b.source.df,"Unknown source."),f=b.source.Se,c=cg(this,a,b.path,b.Ga,c,d,f,e));else if(b.type===dg)b.source.me?c=eg(this,a,b.path,b.children,c,d,e):(y(b.source.df,"Unknown source."),f=b.source.Se,c=fg(this,a,b.path,b.children,c,d,f,e));else if(b.type===gg)if(b.Ne)if(f=b.path,null!=c.jc(f))c=a;else{b=new uc(c,a,d);d=a.F.j();if(f.e()||".priority"===I(f))Vf(a.u())?b=c.pa(xc(a)):(b=a.u().j(),
y(b instanceof W,"serverChildren would be complete if leaf node"),b=c.pc(b)),b=this.G.oa(d,b,e);else{f=I(f);var g=c.Ta(f,a.u());null==g&&vc(a.u(),f)&&(g=d.K(f));b=null!=g?this.G.C(d,f,g,b,e):a.F.j().Da(f)?this.G.C(d,f,M,b,e):d;b.e()&&Vf(a.u())&&(d=c.pa(xc(a)),d.M()&&(b=this.G.oa(b,d,e)))}d=Vf(a.u())||null!=c.jc(U);c=Xf(a,b,d,this.G.ya())}else c=hg(this,a,b.path,c,d,e);else if(b.type===ig)d=b.path,b=a.u(),f=b.j(),g=b.aa||d.e(),c=jg(this,new Wf(a.F,new wc(f,g,b.yc)),d,c,tc,e);else throw fb("Unknown operation type: "+
b.type);e=Jd(e.Za);d=c;b=d.F;b.aa&&(f=b.j().M()||b.j().e(),g=Yf(a),(0<e.length||!a.F.aa||f&&!b.j().ea(g)||!b.j().L().ea(g.L()))&&e.push(Fb(Yf(d))));return new Zf(c,e)};
function jg(a,b,c,d,e,f){var g=b.F;if(null!=d.jc(c))return b;var k;if(c.e())y(Vf(b.u()),"If change path is empty, we must have complete server data"),a.G.ya()?(e=xc(b),d=d.pc(e instanceof W?e:M)):d=d.pa(xc(b)),f=a.G.oa(b.F.j(),d,f);else{var l=I(c);if(".priority"==l)y(1==Qc(c),"Can't have a priority with additional path components"),f=g.j(),k=b.u().j(),d=d.$c(c,f,k),f=null!=d?a.G.Z(f,d):g.j();else{var n=T(c);vc(g,l)?(k=b.u().j(),d=d.$c(c,g.j(),k),d=null!=d?g.j().K(l).C(n,d):g.j().K(l)):d=d.Ta(l,b.u());
f=null!=d?a.G.C(g.j(),l,d,e,f):g.j()}}return Xf(b,f,g.aa||c.e(),a.G.ya())}function cg(a,b,c,d,e,f,g,k){var l=b.u();g=g?a.G:a.G.Mb();if(c.e())d=g.oa(l.j(),d,null);else if(g.ya()&&!l.yc)d=l.j().C(c,d),d=g.oa(l.j(),d,null);else{var n=I(c);if((c.e()?!l.aa||l.yc:!vc(l,I(c)))&&1<Qc(c))return b;d=l.j().K(n).C(T(c),d);d=".priority"==n?g.Z(l.j(),d):g.C(l.j(),n,d,tc,null)}l=l.aa||c.e();b=new Wf(b.F,new wc(d,l,g.ya()));return jg(a,b,c,e,new uc(e,b,f),k)}
function bg(a,b,c,d,e,f,g){var k=b.F;e=new uc(e,b,f);if(c.e())g=a.G.oa(b.F.j(),d,g),a=Xf(b,g,!0,a.G.ya());else if(f=I(c),".priority"===f)g=a.G.Z(b.F.j(),d),a=Xf(b,g,k.aa,k.yc);else{var l=T(c);c=k.j().K(f);if(!l.e()){var n=e.ef(f);d=null!=n?".priority"===Rc(l)&&n.ra(l.parent()).e()?n:n.C(l,d):M}c.ea(d)?a=b:(g=a.G.C(k.j(),f,d,e,g),a=Xf(b,g,k.aa,a.G.ya()))}return a}
function eg(a,b,c,d,e,f,g){var k=b;kg(d,function(d,n){var u=c.o(d);vc(b.F,I(u))&&(k=bg(a,k,u,n,e,f,g))});kg(d,function(d,n){var u=c.o(d);vc(b.F,I(u))||(k=bg(a,k,u,n,e,f,g))});return k}function lg(a,b){kg(b,function(b,d){a=a.C(b,d)});return a}
function fg(a,b,c,d,e,f,g,k){if(b.u().j().e()&&!Vf(b.u()))return b;var l=b;c=c.e()?d:mg(ng,c,d);var n=b.u().j();c.children.fa(function(c,d){if(n.Da(c)){var E=b.u().j().K(c),E=lg(E,d);l=cg(a,l,new S(c),E,e,f,g,k)}});c.children.fa(function(c,d){var E=!Vf(b.u())&&null==d.value;n.Da(c)||E||(E=b.u().j().K(c),E=lg(E,d),l=cg(a,l,new S(c),E,e,f,g,k))});return l}
function hg(a,b,c,d,e,f){if(null!=d.jc(c))return b;var g=new uc(d,b,e),k=e=b.F.j();if(Vf(b.u())){if(c.e())e=d.pa(xc(b)),k=a.G.oa(b.F.j(),e,f);else if(".priority"===I(c)){var l=d.Ta(I(c),b.u());null==l||e.e()||e.L().ea(l)||(k=a.G.Z(e,l))}else l=I(c),e=d.Ta(l,b.u()),null!=e&&(k=a.G.C(b.F.j(),l,e,g,f));e=!0}else b.F.aa?(k=e,e=Yf(b),e.M()||e.U(L,function(c){var e=d.Ta(c,b.u());null!=e&&(k=a.G.C(k,c,e,g,f))}),e=!0):(!c.e()&&(l=I(c),1==Qc(c)||vc(b.F,l))&&(c=d.Ta(l,b.u()),null!=c&&(k=a.G.C(e,l,c,g,f))),
e=!1);return Xf(b,k,e,a.G.ya())};function og(a){this.V=a;this.g=a.n.g}function pg(a,b,c,d){var e=[],f=[];Ha(b,function(b){"child_changed"===b.type&&a.g.jf(b.De,b.Ha)&&f.push(new C("child_moved",b.Ha,b.Ua))});qg(a,e,"child_removed",b,d,c);qg(a,e,"child_added",b,d,c);qg(a,e,"child_moved",f,d,c);qg(a,e,"child_changed",b,d,c);qg(a,e,Gb,b,d,c);return e}function qg(a,b,c,d,e,f){d=Ia(d,function(a){return a.type===c});Qa(d,q(a.Qf,a));Ha(d,function(c){var d=rg(a,c,f);Ha(e,function(e){e.wf(c.type)&&b.push(e.createEvent(d,a.V))})})}
function rg(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Fd=c.ff(b.Ua,b.Ha,a.g));return b}og.prototype.Qf=function(a,b){if(null==a.Ua||null==b.Ua)throw fb("Should only compare child_ events.");return this.g.compare(new N(a.Ua,a.Ha),new N(b.Ua,b.Ha))};function sg(a,b){this.V=a;var c=a.n,d=new bc(c.g),c=Jc(c)?new bc(c.g):c.ka?new Ac(c):new dc(c);this.sf=new $f(c);var e=b.u(),f=b.F,g=d.oa(M,e.j(),null),k=c.oa(M,f.j(),null);this.Ia=new Wf(new wc(k,f.aa,c.ya()),new wc(g,e.aa,d.ya()));this.Va=[];this.Uf=new og(a)}function tg(a){return a.V}h=sg.prototype;h.u=function(){return this.Ia.u().j()};h.bb=function(a){var b=xc(this.Ia);return b&&(Jc(this.V.n)||!a.e()&&!b.K(I(a)).e())?b.ra(a):null};h.e=function(){return 0===this.Va.length};h.Gb=function(a){this.Va.push(a)};
h.gb=function(a,b){var c=[];if(b){y(null==a,"A cancel should cancel all event registrations.");var d=this.V.path;Ha(this.Va,function(a){(a=a.Ye(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.Va.length;++f){var g=this.Va[f];if(!g.matches(a))e.push(g);else if(a.hf()){e=e.concat(this.Va.slice(f+1));break}}this.Va=e}else this.Va=[];return c};
h.Ya=function(a,b,c){a.type===dg&&null!==a.source.yb&&(y(xc(this.Ia),"We should always have a full cache before handling merges"),y(Yf(this.Ia),"Missing event cache, even though we have a server cache"));var d=this.Ia;a=this.sf.Ya(d,a,b,c);b=this.sf;c=a.Yd;y(c.F.j().Bc(b.G.g),"Event snap not indexed");y(c.u().j().Bc(b.G.g),"Server snap not indexed");y(Vf(a.Yd.u())||!Vf(d.u()),"Once a server snap is complete, it should never go back");this.Ia=a.Yd;return ug(this,a.Of,a.Yd.F.j(),null)};
function vg(a,b){var c=a.Ia.F,d=[];c.j().M()||c.j().U(L,function(a,b){d.push(new C("child_added",b,a))});c.aa&&d.push(Fb(c.j()));return ug(a,d,c.j(),b)}function ug(a,b,c,d){return pg(a.Uf,b,c,d?[d]:a.Va)};function wg(a,b){this.value=a;this.children=b||xg}var xg=new Zc(function(a,b){return a===b?0:a<b?-1:1}),ng=new wg(null);function yg(a){var b=ng;A(a,function(a,d){b=b.set(new S(d),a)});return b}h=wg.prototype;h.e=function(){return null===this.value&&this.children.e()};function zg(a,b,c){if(null!=a.value&&c(a.value))return{path:U,value:a.value};if(b.e())return null;var d=I(b);a=a.children.get(d);return null!==a?(b=zg(a,T(b),c),null!=b?{path:(new S(d)).o(b.path),value:b.value}:null):null}
function Ag(a,b){return zg(a,b,function(){return!0})}h.subtree=function(a){if(a.e())return this;var b=this.children.get(I(a));return null!==b?b.subtree(T(a)):ng};h.set=function(a,b){if(a.e())return new wg(b,this.children);var c=I(a),d=(this.children.get(c)||ng).set(T(a),b),c=this.children.La(c,d);return new wg(this.value,c)};
h.remove=function(a){if(a.e())return this.children.e()?ng:new wg(null,this.children);var b=I(a),c=this.children.get(b);return c?(a=c.remove(T(a)),b=a.e()?this.children.remove(b):this.children.La(b,a),null===this.value&&b.e()?ng:new wg(this.value,b)):this};h.get=function(a){if(a.e())return this.value;var b=this.children.get(I(a));return b?b.get(T(a)):null};
function mg(a,b,c){if(b.e())return c;var d=I(b);b=mg(a.children.get(d)||ng,T(b),c);d=b.e()?a.children.remove(d):a.children.La(d,b);return new wg(a.value,d)}function Bg(a,b){return Cg(a,U,b)}function Cg(a,b,c){var d={};a.children.fa(function(a,f){d[a]=Cg(f,b.o(a),c)});return c(b,a.value,d)}function Dg(a,b,c){return Eg(a,b,U,c)}function Eg(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=I(b);return(a=a.children.get(e))?Eg(a,T(b),c.o(e),d):null}
function Fg(a,b,c){if(!b.e()){var d=!0;a.value&&(d=c(U,a.value));!0===d&&(d=I(b),(a=a.children.get(d))&&Gg(a,T(b),U.o(d),c))}}function Gg(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=I(b);return(a=a.children.get(e))?Gg(a,T(b),c.o(e),d):ng}function kg(a,b){Hg(a,U,b)}function Hg(a,b,c){a.children.fa(function(a,e){Hg(e,b.o(a),c)});a.value&&c(b,a.value)}function Ig(a,b){a.children.fa(function(a,d){d.value&&b(a,d.value)})}
h.toString=function(){var a={};kg(this,function(b,c){a[b.toString()]=c.toString()});return r(a)};function Jg(){this.va={}}h=Jg.prototype;h.e=function(){return Nd(this.va)};h.Ya=function(a,b,c){var d=a.source.yb;if(null!==d)return d=t(this.va,d),y(null!=d,"SyncTree gave us an op for an invalid query."),d.Ya(a,b,c);var e=[];A(this.va,function(d){e=e.concat(d.Ya(a,b,c))});return e};h.Gb=function(a,b,c,d,e){var f=a.Fa(),g=t(this.va,f);if(!g){var g=c.pa(e?d:null),k=!1;g?k=!0:(g=d instanceof W?c.pc(d):M,k=!1);g=new sg(a,new Wf(new wc(g,k,!1),new wc(d,e,!1)));this.va[f]=g}g.Gb(b);return vg(g,b)};
h.gb=function(a,b,c){var d=a.Fa(),e=[],f=[],g=null!=Kg(this);if("default"===d){var k=this;A(this.va,function(a,d){f=f.concat(a.gb(b,c));a.e()&&(delete k.va[d],Jc(a.V.n)||e.push(a.V))})}else{var l=t(this.va,d);l&&(f=f.concat(l.gb(b,c)),l.e()&&(delete this.va[d],Jc(l.V.n)||e.push(l.V)))}g&&null==Kg(this)&&e.push(new R(a.k,a.path));return{rg:e,Vf:f}};function Lg(a){return Ia(Jd(a.va),function(a){return!Jc(a.V.n)})}h.bb=function(a){var b=null;A(this.va,function(c){b=b||c.bb(a)});return b};
function Mg(a,b){if(Jc(b.n))return Kg(a);var c=b.Fa();return t(a.va,c)}function Kg(a){return Md(a.va,function(a){return Jc(a.V.n)})||null};function Ng(a){this.W=a}var Og=new Ng(new wg(null));function Pg(a,b,c){if(b.e())return new Ng(new wg(c));var d=Ag(a.W,b);if(null!=d){var e=d.path,d=d.value;b=V(e,b);d=d.C(b,c);return new Ng(a.W.set(e,d))}a=mg(a.W,b,new wg(c));return new Ng(a)}function Qg(a,b,c){var d=a;ua(c,function(a,c){d=Pg(d,b.o(a),c)});return d}Ng.prototype.Gd=function(a){if(a.e())return Og;a=mg(this.W,a,ng);return new Ng(a)};function Rg(a,b){var c=Ag(a.W,b);return null!=c?a.W.get(c.path).ra(V(c.path,b)):null}
function Sg(a){var b=[],c=a.W.value;null!=c?c.M()||c.U(L,function(a,c){b.push(new N(a,c))}):a.W.children.fa(function(a,c){null!=c.value&&b.push(new N(a,c.value))});return b}function Tg(a,b){if(b.e())return a;var c=Rg(a,b);return null!=c?new Ng(new wg(c)):new Ng(a.W.subtree(b))}Ng.prototype.e=function(){return this.W.e()};Ng.prototype.apply=function(a){return Ug(U,this.W,a)};
function Ug(a,b,c){if(null!=b.value)return c.C(a,b.value);var d=null;b.children.fa(function(b,f){".priority"===b?(y(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=Ug(a.o(b),f,c)});c.ra(a).e()||null===d||(c=c.C(a.o(".priority"),d));return c};function Vg(){this.T=Og;this.wa=[];this.Ec=-1}h=Vg.prototype;
h.Gd=function(a){var b=Na(this.wa,function(b){return b.Zd===a});y(0<=b,"removeWrite called with nonexistent writeId.");var c=this.wa[b];this.wa.splice(b,1);for(var d=c.visible,e=!1,f=this.wa.length-1;d&&0<=f;){var g=this.wa[f];g.visible&&(f>=b&&Wg(g,c.path)?d=!1:c.path.contains(g.path)&&(e=!0));f--}if(d){if(e)this.T=Xg(this.wa,Yg,U),this.Ec=0<this.wa.length?this.wa[this.wa.length-1].Zd:-1;else if(c.Ga)this.T=this.T.Gd(c.path);else{var k=this;A(c.children,function(a,b){k.T=k.T.Gd(c.path.o(b))})}return c.path}return null};
h.pa=function(a,b,c,d){if(c||d){var e=Tg(this.T,a);return!d&&e.e()?b:d||null!=b||null!=Rg(e,U)?(e=Xg(this.wa,function(b){return(b.visible||d)&&(!c||!(0<=Ga(c,b.Zd)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||M,e.apply(b)):null}e=Rg(this.T,a);if(null!=e)return e;e=Tg(this.T,a);return e.e()?b:null!=b||null!=Rg(e,U)?(b=b||M,e.apply(b)):null};
h.pc=function(a,b){var c=M,d=Rg(this.T,a);if(d)d.M()||d.U(L,function(a,b){c=c.P(a,b)});else if(b){var e=Tg(this.T,a);b.U(L,function(a,b){var d=Tg(e,new S(a)).apply(b);c=c.P(a,d)});Ha(Sg(e),function(a){c=c.P(a.name,a.Y)})}else e=Tg(this.T,a),Ha(Sg(e),function(a){c=c.P(a.name,a.Y)});return c};h.$c=function(a,b,c,d){y(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.o(b);if(null!=Rg(this.T,a))return null;a=Tg(this.T,a);return a.e()?d.ra(b):a.apply(d.ra(b))};
h.Ta=function(a,b,c){a=a.o(b);var d=Rg(this.T,a);return null!=d?d:vc(c,b)?Tg(this.T,a).apply(c.j().K(b)):null};h.jc=function(a){return Rg(this.T,a)};h.ce=function(a,b,c,d,e,f){var g;a=Tg(this.T,a);g=Rg(a,U);if(null==g)if(null!=b)g=a.apply(b);else return[];g=g.Fb(f);if(g.e()||g.M())return[];b=[];a=mc(f);e=e?g.Rb(c,f):g.Pb(c,f);for(f=P(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=P(e);return b};
function Wg(a,b){return a.Ga?a.path.contains(b):!!Ld(a.children,function(c,d){return a.path.o(d).contains(b)})}function Yg(a){return a.visible}
function Xg(a,b,c){for(var d=Og,e=0;e<a.length;++e){var f=a[e];if(b(f)){var g=f.path;if(f.Ga)c.contains(g)?(g=V(c,g),d=Pg(d,g,f.Ga)):g.contains(c)&&(g=V(g,c),d=Pg(d,U,f.Ga.ra(g)));else if(f.children)if(c.contains(g))g=V(c,g),d=Qg(d,g,f.children);else{if(g.contains(c))if(g=V(g,c),g.e())d=Qg(d,U,f.children);else if(f=t(f.children,I(g)))f=f.ra(T(g)),d=Pg(d,U,f)}else throw fb("WriteRecord should have .snap or .children");}}return d}function Zg(a,b){this.Db=a;this.W=b}h=Zg.prototype;
h.pa=function(a,b,c){return this.W.pa(this.Db,a,b,c)};h.pc=function(a){return this.W.pc(this.Db,a)};h.$c=function(a,b,c){return this.W.$c(this.Db,a,b,c)};h.jc=function(a){return this.W.jc(this.Db.o(a))};h.ce=function(a,b,c,d,e){return this.W.ce(this.Db,a,b,c,d,e)};h.Ta=function(a,b){return this.W.Ta(this.Db,a,b)};h.o=function(a){return new Zg(this.Db.o(a),this.W)};function $g(a,b,c){this.type=ag;this.source=a;this.path=b;this.Ga=c}$g.prototype.Mc=function(a){return this.path.e()?new $g(this.source,U,this.Ga.K(a)):new $g(this.source,T(this.path),this.Ga)};$g.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ga.toString()+")"};function ah(a,b){this.type=gg;this.source=bh;this.path=a;this.Ne=b}ah.prototype.Mc=function(){return this.path.e()?this:new ah(T(this.path),this.Ne)};ah.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Ne+")"};function ch(a,b){this.type=ig;this.source=a;this.path=b}ch.prototype.Mc=function(){return this.path.e()?new ch(this.source,U):new ch(this.source,T(this.path))};ch.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function dh(a,b,c){this.type=dg;this.source=a;this.path=b;this.children=c}dh.prototype.Mc=function(a){if(this.path.e())return a=this.children.subtree(new S(a)),a.e()?null:a.value?new $g(this.source,U,a.value):new dh(this.source,U,a);y(I(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new dh(this.source,T(this.path),this.children)};dh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};var ag=0,dg=1,gg=2,ig=3;function eh(a,b,c,d){this.me=a;this.df=b;this.yb=c;this.Se=d;y(!d||b,"Tagged queries must be from server.")}var bh=new eh(!0,!1,null,!1),fh=new eh(!1,!0,null,!1);eh.prototype.toString=function(){return this.me?"user":this.Se?"server(queryID="+this.yb+")":"server"};function gh(a){this.na=ng;this.xb=new Vg;this.Wc={};this.bc={};this.Fc=a}function hh(a,b,c,d,e){var f=a.xb,g=e;y(d>f.Ec,"Stacking an older write on top of newer ones");m(g)||(g=!0);f.wa.push({path:b,Ga:c,Zd:d,visible:g});g&&(f.T=Pg(f.T,b,c));f.Ec=d;return e?ih(a,new $g(bh,b,c)):[]}function jh(a,b,c,d){var e=a.xb;y(d>e.Ec,"Stacking an older merge on top of newer ones");e.wa.push({path:b,children:c,Zd:d,visible:!0});e.T=Qg(e.T,b,c);e.Ec=d;c=yg(c);return ih(a,new dh(bh,b,c))}
function kh(a,b,c){c=c||!1;b=a.xb.Gd(b);return null==b?[]:ih(a,new ah(b,c))}function lh(a,b,c){c=yg(c);return ih(a,new dh(fh,b,c))}function mh(a,b,c,d){d=Od(a.Wc,"_"+d);if(null!=d){var e=nh(d);d=e.path;e=e.yb;b=V(d,b);c=new $g(new eh(!1,!0,e,!0),b,c);return oh(a,d,c)}return[]}function ph(a,b,c,d){if(d=Od(a.Wc,"_"+d)){var e=nh(d);d=e.path;e=e.yb;b=V(d,b);c=yg(c);c=new dh(new eh(!1,!0,e,!0),b,c);return oh(a,d,c)}return[]}
gh.prototype.Gb=function(a,b){var c=a.path,d=null,e=!1;Fg(this.na,c,function(a,b){var f=V(a,c);d=b.bb(f);e=e||null!=Kg(b);return!d});var f=this.na.get(c);f?(e=e||null!=Kg(f),d=d||f.bb(U)):(f=new Jg,this.na=this.na.set(c,f));var g;null!=d?g=!0:(g=!1,d=M,Ig(this.na.subtree(c),function(a,b){var c=b.bb(U);c&&(d=d.P(a,c))}));var k=null!=Mg(f,a);if(!k&&!Jc(a.n)){var l=qh(a);y(!(l in this.bc),"View does not exist, but we have a tag");var n=rh++;this.bc[l]=n;this.Wc["_"+n]=l}g=f.Gb(a,b,new Zg(c,this.xb),
d,g);k||e||(f=Mg(f,a),g=g.concat(sh(this,a,f)));return g};
gh.prototype.gb=function(a,b,c){var d=a.path,e=this.na.get(d),f=[];if(e&&("default"===a.Fa()||null!=Mg(e,a))){f=e.gb(a,b,c);e.e()&&(this.na=this.na.remove(d));e=f.rg;f=f.Vf;b=-1!==Na(e,function(a){return Jc(a.n)});var g=Dg(this.na,d,function(a,b){return null!=Kg(b)});if(b&&!g&&(d=this.na.subtree(d),!d.e()))for(var d=th(d),k=0;k<d.length;++k){var l=d[k],n=l.V,l=uh(this,l);this.Fc.Pe(n,vh(this,n),l.md,l.H)}if(!g&&0<e.length&&!c)if(b)this.Fc.Qd(a,null);else{var u=this;Ha(e,function(a){a.Fa();var b=u.bc[qh(a)];
u.Fc.Qd(a,b)})}wh(this,e)}return f};gh.prototype.pa=function(a,b){var c=this.xb,d=Dg(this.na,a,function(b,c){var d=V(b,a);if(d=c.bb(d))return d});return c.pa(a,d,b,!0)};function th(a){return Bg(a,function(a,c,d){if(c&&null!=Kg(c))return[Kg(c)];var e=[];c&&(e=Lg(c));A(d,function(a){e=e.concat(a)});return e})}function wh(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!Jc(d.n)){var d=qh(d),e=a.bc[d];delete a.bc[d];delete a.Wc["_"+e]}}}
function sh(a,b,c){var d=b.path,e=vh(a,b);c=uh(a,c);b=a.Fc.Pe(b,e,c.md,c.H);d=a.na.subtree(d);if(e)y(null==Kg(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=Bg(d,function(a,b,c){if(!a.e()&&b&&null!=Kg(b))return[tg(Kg(b))];var d=[];b&&(d=d.concat(Ja(Lg(b),function(a){return a.V})));A(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Fc.Qd(c,vh(a,c));return b}
function uh(a,b){var c=b.V,d=vh(a,c);return{md:function(){return(b.u()||M).hash()},H:function(b,f){if("ok"===b){if(f&&"object"===typeof f&&s(f,"w")){var g=t(f,"w");ea(g)&&0<=Ga(g,"no_index")&&z("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}if(d){var k=c.path;if(g=Od(a.Wc,"_"+d))var l=nh(g),g=l.path,l=l.yb,k=V(g,k),k=new ch(new eh(!1,!0,l,!0),k),g=oh(a,g,k);else g=[]}else g=ih(a,new ch(fh,
c.path));return g}g="Unknown Error";"too_big"===b?g="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?g="Client doesn't have permission to access the desired data.":"unavailable"==b&&(g="The service is unavailable");g=Error(b+": "+g);g.code=b.toUpperCase();return a.gb(c,null,g)}}}function qh(a){return a.path.toString()+"$"+a.Fa()}
function nh(a){var b=a.indexOf("$");y(-1!==b&&b<a.length-1,"Bad queryKey.");return{yb:a.substr(b+1),path:new S(a.substr(0,b))}}function vh(a,b){var c=qh(b);return t(a.bc,c)}var rh=1;function oh(a,b,c){var d=a.na.get(b);y(d,"Missing sync point for query tag that we're tracking");return d.Ya(c,new Zg(b,a.xb),null)}function ih(a,b){return xh(a,b,a.na,null,new Zg(U,a.xb))}
function xh(a,b,c,d,e){if(b.path.e())return yh(a,b,c,d,e);var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[],k=I(b.path),l=b.Mc(k);if((c=c.children.get(k))&&l)var n=d?d.K(k):null,k=e.o(k),g=g.concat(xh(a,l,c,n,k));f&&(g=g.concat(f.Ya(b,e,d)));return g}function yh(a,b,c,d,e){var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[];c.children.fa(function(c,f){var n=d?d.K(c):null,u=e.o(c),x=b.Mc(c);x&&(g=g.concat(yh(a,x,f,n,u)))});f&&(g=g.concat(f.Ya(b,e,d)));return g};function zh(a){this.O=a;this.Ra=Xd(a);this.$=new df;this.vd=1;this.S=new Je(this.O,q(this.yd,this),q(this.wd,this),q(this.He,this));this.zg=Yd(a,q(function(){return new Ud(this.Ra,this.S)},this));this.lc=new Tc;this.se=new cf;var b=this;this.qd=new gh({Pe:function(a,d,e,f){d=[];e=b.se.j(a.path);e.e()||(d=ih(b.qd,new $g(fh,a.path,e)),setTimeout(function(){f("ok")},0));return d},Qd:ba});Ah(this,"connected",!1);this.ga=new $e;this.Q=new Ff(a,q(this.S.Q,this.S),q(this.S.Ue,this.S),q(this.Ee,this));this.gd=
0;this.te=null;this.N=new gh({Pe:function(a,d,e,f){Ne(b.S,a,e,d,function(d,e){var l=f(d,e);hf(b.$,a.path,l)});return[]},Qd:function(a,d){var e=b.S,f=a.path.toString(),g=a.Fa();e.f("Unlisten called for "+f+" "+g);if(Pe(e,f,g)&&e.ja){var k=Ic(a.n);e.f("Unlisten on "+f+" for "+g);f={p:f};d&&(f.q=k,f.t=d);e.Ca("n",f)}}})}h=zh.prototype;h.toString=function(){return(this.O.Ab?"https://":"http://")+this.O.host};h.name=function(){return this.O.tb};
function Bh(a){a=a.se.j(new S(".info/serverTimeOffset")).I()||0;return(new Date).getTime()+a}function Ch(a){a=a={timestamp:Bh(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}h.yd=function(a,b,c,d){this.gd++;var e=new S(a);b=this.te?this.te(a,b):b;a=[];d?c?(b=td(b,function(a){return O(a)}),a=ph(this.N,e,b,d)):(b=O(b),a=mh(this.N,e,b,d)):c?(d=td(b,function(a){return O(a)}),a=lh(this.N,e,d)):(d=O(b),a=ih(this.N,new $g(fh,e,d)));d=e;0<a.length&&(d=Dh(this,e));hf(this.$,d,a)};
h.wd=function(a){Ah(this,"connected",a);!1===a&&Eh(this)};h.He=function(a){var b=this;zb(a,function(a,d){Ah(b,d,a)})};h.Ee=function(a){Ah(this,"authenticated",a)};function Ah(a,b,c){b=new S("/.info/"+b);c=O(c);var d=a.se;d.Jd=d.Jd.C(b,c);c=ih(a.qd,new $g(fh,b,c));hf(a.$,b,c)}
h.Bb=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,Hg:c});var e=Ch(this);b=O(b,c);var e=Uf(b,e),f=this.vd++,e=hh(this.N,a,e,f,!0);ef(this.$,e);var g=this;this.S.put(a.toString(),b.I(!0),function(b,c){var e="ok"===b;e||z("set at "+a+" failed: "+b);e=kh(g.N,f,!e);hf(g.$,a,e);Fh(d,b,c)});e=Gh(this,a);Dh(this,e);hf(this.$,e,[])};
h.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=Ch(this),f={};A(b,function(a,b){d=!1;var c=O(a);f[b]=Uf(c,e)});if(d)hb("update() called with empty data.  Don't do anything."),Fh(c,"ok");else{var g=this.vd++,k=jh(this.N,a,f,g);ef(this.$,k);var l=this;Ve(this.S,a.toString(),b,function(b,d){y("ok"===b||"permission_denied"===b,"merge at "+a+" failed.");var e="ok"===b;e||z("update at "+a+" failed: "+b);var e=kh(l.N,g,!e),f=a;0<e.length&&(f=Dh(l,a));hf(l.$,f,e);Fh(c,b,d)});
b=Gh(this,a);Dh(this,b);hf(this.$,a,[])}};function Eh(a){a.f("onDisconnectEvents");var b=Ch(a),c=[];bf(Tf(a.ga,b),U,function(b,e){c=c.concat(ih(a.N,new $g(fh,b,e)));var f=Gh(a,b);Dh(a,f)});a.ga=new $e;hf(a.$,U,c)}h.Fe=function(a,b){var c=this;this.S.Fe(a.toString(),function(d,e){"ok"===d&&af(c.ga,a);Fh(b,d,e)})};function Hh(a,b,c,d){var e=O(c);Re(a.S,b.toString(),e.I(!0),function(c,g){"ok"===c&&a.ga.dc(b,e);Fh(d,c,g)})}
function Ih(a,b,c,d,e){var f=O(c,d);Re(a.S,b.toString(),f.I(!0),function(c,d){"ok"===c&&a.ga.dc(b,f);Fh(e,c,d)})}function Jh(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(hb("onDisconnect().update() called with empty data.  Don't do anything."),Fh(d,"ok")):Te(a.S,b.toString(),c,function(e,f){if("ok"===e)for(var l in c){var n=O(c[l]);a.ga.dc(b.o(l),n)}Fh(d,e,f)})}function Oc(a,b,c){c=".info"===I(b.path)?a.qd.Gb(b,c):a.N.Gb(b,c);Pc(a.$,b.path,c)}h.pb=function(){this.S.pb()};h.hc=function(){this.S.hc()};
h.Qe=function(a){if("undefined"!==typeof console){a?(this.Pd||(this.Pd=new Td(this.Ra)),a=this.Pd.get()):a=this.Ra.get();var b=Ka(Kd(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};h.Re=function(a){Sd(this.Ra,a);this.zg.zf[a]=!0};h.f=function(a){hb("r:"+this.S.id+":",arguments)};function Fh(a,b,c){a&&Cb(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function Kh(a,b,c,d,e){function f(){}a.f("transaction on "+b);var g=new R(a,b);g.vb("value",f);c={path:b,update:c,H:d,status:null,qf:eb(),Ve:e,xf:0,Xd:function(){g.Zb("value",f)},$d:null,xa:null,dd:null,ed:null,fd:null};d=a.N.pa(b,void 0)||M;c.dd=d;d=c.update(d.I());if(m(d)){Sb("transaction failed: Data returned ",d);c.status=1;e=Uc(a.lc,b);var k=e.za()||[];k.push(c);Vc(e,k);"object"===typeof d&&null!==d&&s(d,".priority")?(k=t(d,".priority"),y(Qb(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.N.pa(b)||M).L().I();e=Ch(a);d=O(d,k);e=Uf(d,e);c.ed=d;c.fd=e;c.xa=a.vd++;c=hh(a.N,b,e,c.xa,c.Ve);hf(a.$,b,c);Lh(a)}else c.Xd(),c.ed=null,c.fd=null,c.H&&(a=new D(c.dd,new R(a,c.path),L),c.H(null,!1,a))}function Lh(a,b){var c=b||a.lc;b||Mh(a,c);if(null!==c.za()){var d=Nh(a,c);y(0<d.length,"Sending zero length transaction queue");La(d,function(a){return 1===a.status})&&Oh(a,c.path(),d)}else c.ld()&&c.U(function(b){Lh(a,b)})}
function Oh(a,b,c){for(var d=Ja(c,function(a){return a.xa}),e=a.N.pa(b,d)||M,d=e,e=e.hash(),f=0;f<c.length;f++){var g=c[f];y(1===g.status,"tryToSendTransactionQueue_: items in queue should all be run.");g.status=2;g.xf++;var k=V(b,g.path),d=d.C(k,g.ed)}d=d.I(!0);a.S.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(kh(a.N,c[f].xa));if(c[f].H){var g=c[f].fd,k=new R(a,c[f].path);d.push(q(c[f].H,
null,null,!0,new D(g,k,L)))}c[f].Xd()}Mh(a,Uc(a.lc,b));Lh(a);hf(a.$,b,e);for(f=0;f<d.length;f++)Cb(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(z("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].$d=d;Dh(a,b)}},e)}function Dh(a,b){var c=Ph(a,b),d=c.path(),c=Nh(a,c);Qh(a,c,d);return d}
function Qh(a,b,c){if(0!==b.length){for(var d=[],e=[],f=Ja(b,function(a){return a.xa}),g=0;g<b.length;g++){var k=b[g],l=V(c,k.path),n=!1,u;y(null!==l,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)n=!0,u=k.$d,e=e.concat(kh(a.N,k.xa,!0));else if(1===k.status)if(25<=k.xf)n=!0,u="maxretry",e=e.concat(kh(a.N,k.xa,!0));else{var x=a.N.pa(k.path,f)||M;k.dd=x;var E=b[g].update(x.I());m(E)?(Sb("transaction failed: Data returned ",E),l=O(E),"object"===typeof E&&null!=E&&s(E,
".priority")||(l=l.Z(x.L())),x=k.xa,E=Ch(a),E=Uf(l,E),k.ed=l,k.fd=E,k.xa=a.vd++,Oa(f,x),e=e.concat(hh(a.N,k.path,E,k.xa,k.Ve)),e=e.concat(kh(a.N,x,!0))):(n=!0,u="nodata",e=e.concat(kh(a.N,k.xa,!0)))}hf(a.$,c,e);e=[];n&&(b[g].status=3,setTimeout(b[g].Xd,Math.floor(0)),b[g].H&&("nodata"===u?(k=new R(a,b[g].path),d.push(q(b[g].H,null,null,!1,new D(b[g].dd,k,L)))):d.push(q(b[g].H,null,Error(u),!1,null))))}Mh(a,a.lc);for(g=0;g<d.length;g++)Cb(d[g]);Lh(a)}}
function Ph(a,b){for(var c,d=a.lc;null!==(c=I(b))&&null===d.za();)d=Uc(d,c),b=T(b);return d}function Nh(a,b){var c=[];Rh(a,b,c);c.sort(function(a,b){return a.qf-b.qf});return c}function Rh(a,b,c){var d=b.za();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.U(function(b){Rh(a,b,c)})}function Mh(a,b){var c=b.za();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;Vc(b,0<c.length?c:null)}b.U(function(b){Mh(a,b)})}
function Gh(a,b){var c=Ph(a,b).path(),d=Uc(a.lc,b);Yc(d,function(b){Sh(a,b)});Sh(a,d);Xc(d,function(b){Sh(a,b)});return c}
function Sh(a,b){var c=b.za();if(null!==c){for(var d=[],e=[],f=-1,g=0;g<c.length;g++)4!==c[g].status&&(2===c[g].status?(y(f===g-1,"All SENT items should be at beginning of queue."),f=g,c[g].status=4,c[g].$d="set"):(y(1===c[g].status,"Unexpected transaction status in abort"),c[g].Xd(),e=e.concat(kh(a.N,c[g].xa,!0)),c[g].H&&d.push(q(c[g].H,null,Error("set"),!1,null))));-1===f?Vc(b,null):c.length=f+1;hf(a.$,b.path(),e);for(g=0;g<d.length;g++)Cb(d[g])}};function Th(){this.ec={}}ca(Th);Th.prototype.pb=function(){for(var a in this.ec)this.ec[a].pb()};Th.prototype.interrupt=Th.prototype.pb;Th.prototype.hc=function(){for(var a in this.ec)this.ec[a].hc()};Th.prototype.resume=Th.prototype.hc;function Uh(a){var b=this;this.rc=a;this.Sd="*";xf()?this.Hc=this.od=of():(this.Hc=window.opener,this.od=window);if(!b.Hc)throw"Unable to find relay frame";pf(this.od,"message",q(this.$b,this));pf(this.od,"message",q(this.nf,this));try{Vh(this,{a:"ready"})}catch(c){pf(this.Hc,"load",function(){Vh(b,{a:"ready"})})}pf(window,"unload",q(this.jg,this))}function Vh(a,b){b=r(b);xf()?a.Hc.doPost(b,a.Sd):a.Hc.postMessage(b,a.Sd)}
Uh.prototype.$b=function(a){var b=this,c;try{c=ta(a.data)}catch(d){}c&&"request"===c.a&&(qf(window,"message",this.$b),this.Sd=a.origin,this.rc&&setTimeout(function(){b.rc(b.Sd,c.d,function(a,c){b.Mf=!c;b.rc=void 0;Vh(b,{a:"response",d:a,forceKeepWindowOpen:c})})},0))};Uh.prototype.jg=function(){try{qf(this.od,"message",this.nf)}catch(a){}this.rc&&(Vh(this,{a:"error",d:"unknown closed window"}),this.rc=void 0);try{window.close()}catch(b){}};Uh.prototype.nf=function(a){if(this.Mf&&"die"===a.data)try{window.close()}catch(b){}};var Y={Xf:function(){je=ae=!0}};Y.forceLongPolling=Y.Xf;Y.Yf=function(){ke=!0};Y.forceWebSockets=Y.Yf;Y.wg=function(a,b){a.k.S.Oe=b};Y.setSecurityDebugCallback=Y.wg;Y.Qe=function(a,b){a.k.Qe(b)};Y.stats=Y.Qe;Y.Re=function(a,b){a.k.Re(b)};Y.statsIncrementCounter=Y.Re;Y.gd=function(a){return a.k.gd};Y.dataUpdateCount=Y.gd;Y.ag=function(a,b){a.k.te=b};Y.interceptServerData=Y.ag;Y.gg=function(a){new Uh(a)};Y.onPopupOpen=Y.gg;Y.ug=function(a){jf=a};Y.setAuthenticationServer=Y.ug;function Z(a,b){this.Rc=a;this.Ea=b}Z.prototype.cancel=function(a){F("Firebase.onDisconnect().cancel",0,1,arguments.length);H("Firebase.onDisconnect().cancel",1,a,!0);this.Rc.Fe(this.Ea,a||null)};Z.prototype.cancel=Z.prototype.cancel;Z.prototype.remove=function(a){F("Firebase.onDisconnect().remove",0,1,arguments.length);Zb("Firebase.onDisconnect().remove",this.Ea);H("Firebase.onDisconnect().remove",1,a,!0);Hh(this.Rc,this.Ea,null,a)};Z.prototype.remove=Z.prototype.remove;
Z.prototype.set=function(a,b){F("Firebase.onDisconnect().set",1,2,arguments.length);Zb("Firebase.onDisconnect().set",this.Ea);Rb("Firebase.onDisconnect().set",a,!1);H("Firebase.onDisconnect().set",2,b,!0);Hh(this.Rc,this.Ea,a,b)};Z.prototype.set=Z.prototype.set;
Z.prototype.Bb=function(a,b,c){F("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);Zb("Firebase.onDisconnect().setWithPriority",this.Ea);Rb("Firebase.onDisconnect().setWithPriority",a,!1);Vb("Firebase.onDisconnect().setWithPriority",2,b);H("Firebase.onDisconnect().setWithPriority",3,c,!0);Ih(this.Rc,this.Ea,a,b,c)};Z.prototype.setWithPriority=Z.prototype.Bb;
Z.prototype.update=function(a,b){F("Firebase.onDisconnect().update",1,2,arguments.length);Zb("Firebase.onDisconnect().update",this.Ea);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.onDisconnect().update",a);H("Firebase.onDisconnect().update",2,b,!0);Jh(this.Rc,
this.Ea,a,b)};Z.prototype.update=Z.prototype.update;var $={};$.nc=Je;$.DataConnection=$.nc;Je.prototype.yg=function(a,b){this.Ca("q",{p:a},b)};$.nc.prototype.simpleListen=$.nc.prototype.yg;Je.prototype.Sf=function(a,b){this.Ca("echo",{d:a},b)};$.nc.prototype.echo=$.nc.prototype.Sf;Je.prototype.interrupt=Je.prototype.pb;$.Df=ue;$.RealTimeConnection=$.Df;ue.prototype.sendRequest=ue.prototype.Ca;ue.prototype.close=ue.prototype.close;
$.$f=function(a){var b=Je.prototype.put;Je.prototype.put=function(c,d,e,f){m(f)&&(f=a());b.call(this,c,d,e,f)};return function(){Je.prototype.put=b}};$.hijackHash=$.$f;$.Cf=Aa;$.ConnectionTarget=$.Cf;$.Fa=function(a){return a.Fa()};$.queryIdentifier=$.Fa;$.bg=function(a){return a.k.S.Aa};$.listens=$.bg;var Wh=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);y(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);y(20===c.length,"NextPushId: Length should be 20.");
return c}}();function R(a,b){var c,d,e;if(a instanceof zh)c=a,d=b;else{F("new Firebase",1,2,arguments.length);d=rb(arguments[0]);c=d.Ag;"firebase"===d.domain&&qb(d.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");c||qb("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d.Ab||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&z("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
c=new Aa(d.host,d.Ab,c,"ws"===d.scheme||"wss"===d.scheme);d=new S(d.Pc);e=d.toString();var f;!(f=!p(c.host)||0===c.host.length||!Pb(c.tb))&&(f=0!==e.length)&&(e&&(e=e.replace(/^\/*\.info(\/|$)/,"/")),f=!(p(e)&&0!==e.length&&!Ob.test(e)));if(f)throw Error(G("new Firebase",1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');if(b)if(b instanceof Th)e=b;else if(p(b))e=Th.Nb(),c.Dd=b;else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()");
else e=Th.Nb();f=c.toString();var g=t(e.ec,f);g||(g=new zh(c),e.ec[f]=g);c=g}Q.call(this,c,d,Fc,!1)}ma(R,Q);var Xh=R,Yh=["Firebase"],Zh=aa;Yh[0]in Zh||!Zh.execScript||Zh.execScript("var "+Yh[0]);for(var $h;Yh.length&&($h=Yh.shift());)!Yh.length&&m(Xh)?Zh[$h]=Xh:Zh=Zh[$h]?Zh[$h]:Zh[$h]={};R.prototype.name=function(){z("Firebase.name() being deprecated. Please use Firebase.key() instead.");F("Firebase.name",0,0,arguments.length);return this.key()};R.prototype.name=R.prototype.name;
R.prototype.key=function(){F("Firebase.key",0,0,arguments.length);return this.path.e()?null:Rc(this.path)};R.prototype.key=R.prototype.key;R.prototype.o=function(a){F("Firebase.child",1,1,arguments.length);if(ga(a))a=String(a);else if(!(a instanceof S))if(null===I(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));Yb("Firebase.child",b)}else Yb("Firebase.child",a);return new R(this.k,this.path.o(a))};R.prototype.child=R.prototype.o;
R.prototype.parent=function(){F("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new R(this.k,a)};R.prototype.parent=R.prototype.parent;R.prototype.root=function(){F("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.parent();)a=a.parent();return a};R.prototype.root=R.prototype.root;
R.prototype.toString=function(){F("Firebase.toString",0,0,arguments.length);var a;if(null===this.parent())a=this.k.toString();else{a=this.parent().toString()+"/";var b=this.key();a+=encodeURIComponent(String(b))}return a};R.prototype.toString=R.prototype.toString;R.prototype.set=function(a,b){F("Firebase.set",1,2,arguments.length);Zb("Firebase.set",this.path);Rb("Firebase.set",a,!1);H("Firebase.set",2,b,!0);this.k.Bb(this.path,a,null,b||null)};R.prototype.set=R.prototype.set;
R.prototype.update=function(a,b){F("Firebase.update",1,2,arguments.length);Zb("Firebase.update",this.path);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.update",a);H("Firebase.update",2,b,!0);if(s(a,".priority"))throw Error("update() does not currently support updating .priority.");
this.k.update(this.path,a,b||null)};R.prototype.update=R.prototype.update;R.prototype.Bb=function(a,b,c){F("Firebase.setWithPriority",2,3,arguments.length);Zb("Firebase.setWithPriority",this.path);Rb("Firebase.setWithPriority",a,!1);Vb("Firebase.setWithPriority",2,b);H("Firebase.setWithPriority",3,c,!0);if(".length"===this.key()||".keys"===this.key())throw"Firebase.setWithPriority failed: "+this.key()+" is a read-only object.";this.k.Bb(this.path,a,b,c||null)};R.prototype.setWithPriority=R.prototype.Bb;
R.prototype.remove=function(a){F("Firebase.remove",0,1,arguments.length);Zb("Firebase.remove",this.path);H("Firebase.remove",1,a,!0);this.set(null,a)};R.prototype.remove=R.prototype.remove;
R.prototype.transaction=function(a,b,c){F("Firebase.transaction",1,3,arguments.length);Zb("Firebase.transaction",this.path);H("Firebase.transaction",1,a,!1);H("Firebase.transaction",2,b,!0);if(m(c)&&"boolean"!=typeof c)throw Error(G("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.key()||".keys"===this.key())throw"Firebase.transaction failed: "+this.key()+" is a read-only object.";"undefined"===typeof c&&(c=!0);Kh(this.k,this.path,a,b||null,c)};R.prototype.transaction=R.prototype.transaction;
R.prototype.vg=function(a,b){F("Firebase.setPriority",1,2,arguments.length);Zb("Firebase.setPriority",this.path);Vb("Firebase.setPriority",1,a);H("Firebase.setPriority",2,b,!0);this.k.Bb(this.path.o(".priority"),a,null,b)};R.prototype.setPriority=R.prototype.vg;R.prototype.push=function(a,b){F("Firebase.push",0,2,arguments.length);Zb("Firebase.push",this.path);Rb("Firebase.push",a,!0);H("Firebase.push",2,b,!0);var c=Bh(this.k),c=Wh(c),c=this.o(c);"undefined"!==typeof a&&null!==a&&c.set(a,b);return c};
R.prototype.push=R.prototype.push;R.prototype.fb=function(){Zb("Firebase.onDisconnect",this.path);return new Z(this.k,this.path)};R.prototype.onDisconnect=R.prototype.fb;R.prototype.Q=function(a,b,c){z("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");F("Firebase.auth",1,3,arguments.length);$b("Firebase.auth",a);H("Firebase.auth",2,b,!0);H("Firebase.auth",3,b,!0);Lf(this.k.Q,a,{},{remember:"none"},b,c)};R.prototype.auth=R.prototype.Q;
R.prototype.Ue=function(a){F("Firebase.unauth",0,1,arguments.length);H("Firebase.unauth",1,a,!0);Mf(this.k.Q,a)};R.prototype.unauth=R.prototype.Ue;R.prototype.ne=function(){F("Firebase.getAuth",0,0,arguments.length);return this.k.Q.ne()};R.prototype.getAuth=R.prototype.ne;R.prototype.fg=function(a,b){F("Firebase.onAuth",1,2,arguments.length);H("Firebase.onAuth",1,a,!1);Mb("Firebase.onAuth",2,b);this.k.Q.vb("auth_status",a,b)};R.prototype.onAuth=R.prototype.fg;
R.prototype.eg=function(a,b){F("Firebase.offAuth",1,2,arguments.length);H("Firebase.offAuth",1,a,!1);Mb("Firebase.offAuth",2,b);this.k.Q.Zb("auth_status",a,b)};R.prototype.offAuth=R.prototype.eg;R.prototype.Hf=function(a,b,c){F("Firebase.authWithCustomToken",2,3,arguments.length);$b("Firebase.authWithCustomToken",a);H("Firebase.authWithCustomToken",2,b,!1);J("Firebase.authWithCustomToken",3,c,!0);Lf(this.k.Q,a,{},c||{},b)};R.prototype.authWithCustomToken=R.prototype.Hf;
R.prototype.If=function(a,b,c){F("Firebase.authWithOAuthPopup",2,3,arguments.length);ac("Firebase.authWithOAuthPopup",1,a);H("Firebase.authWithOAuthPopup",2,b,!1);J("Firebase.authWithOAuthPopup",3,c,!0);Qf(this.k.Q,a,c,b)};R.prototype.authWithOAuthPopup=R.prototype.If;
R.prototype.Jf=function(a,b,c){F("Firebase.authWithOAuthRedirect",2,3,arguments.length);ac("Firebase.authWithOAuthRedirect",1,a);H("Firebase.authWithOAuthRedirect",2,b,!1);J("Firebase.authWithOAuthRedirect",3,c,!0);var d=this.k.Q;Of(d);var e=[Ef],f=mf(c);"anonymous"===a||"firebase"===a?B(b,X("TRANSPORT_UNAVAILABLE")):(v.set("redirect_client_options",f.cd),Pf(d,e,"/auth/"+a,f,b))};R.prototype.authWithOAuthRedirect=R.prototype.Jf;
R.prototype.Kf=function(a,b,c,d){F("Firebase.authWithOAuthToken",3,4,arguments.length);ac("Firebase.authWithOAuthToken",1,a);H("Firebase.authWithOAuthToken",3,c,!1);J("Firebase.authWithOAuthToken",4,d,!0);p(b)?(ac("Firebase.authWithOAuthToken",2,b),Nf(this.k.Q,a+"/token",{access_token:b},d,c)):(J("Firebase.authWithOAuthToken",2,b,!1),Nf(this.k.Q,a+"/token",b,d,c))};R.prototype.authWithOAuthToken=R.prototype.Kf;
R.prototype.Gf=function(a,b){F("Firebase.authAnonymously",1,2,arguments.length);H("Firebase.authAnonymously",1,a,!1);J("Firebase.authAnonymously",2,b,!0);Nf(this.k.Q,"anonymous",{},b,a)};R.prototype.authAnonymously=R.prototype.Gf;
R.prototype.Lf=function(a,b,c){F("Firebase.authWithPassword",2,3,arguments.length);J("Firebase.authWithPassword",1,a,!1);K("Firebase.authWithPassword",a,"email");K("Firebase.authWithPassword",a,"password");H("Firebase.authAnonymously",2,b,!1);J("Firebase.authAnonymously",3,c,!0);Nf(this.k.Q,"password",a,c,b)};R.prototype.authWithPassword=R.prototype.Lf;
R.prototype.je=function(a,b){F("Firebase.createUser",2,2,arguments.length);J("Firebase.createUser",1,a,!1);K("Firebase.createUser",a,"email");K("Firebase.createUser",a,"password");H("Firebase.createUser",2,b,!1);this.k.Q.je(a,b)};R.prototype.createUser=R.prototype.je;R.prototype.Le=function(a,b){F("Firebase.removeUser",2,2,arguments.length);J("Firebase.removeUser",1,a,!1);K("Firebase.removeUser",a,"email");K("Firebase.removeUser",a,"password");H("Firebase.removeUser",2,b,!1);this.k.Q.Le(a,b)};
R.prototype.removeUser=R.prototype.Le;R.prototype.ee=function(a,b){F("Firebase.changePassword",2,2,arguments.length);J("Firebase.changePassword",1,a,!1);K("Firebase.changePassword",a,"email");K("Firebase.changePassword",a,"oldPassword");K("Firebase.changePassword",a,"newPassword");H("Firebase.changePassword",2,b,!1);this.k.Q.ee(a,b)};R.prototype.changePassword=R.prototype.ee;
R.prototype.de=function(a,b){F("Firebase.changeEmail",2,2,arguments.length);J("Firebase.changeEmail",1,a,!1);K("Firebase.changeEmail",a,"oldEmail");K("Firebase.changeEmail",a,"newEmail");K("Firebase.changeEmail",a,"password");H("Firebase.changeEmail",2,b,!1);this.k.Q.de(a,b)};R.prototype.changeEmail=R.prototype.de;
R.prototype.Me=function(a,b){F("Firebase.resetPassword",2,2,arguments.length);J("Firebase.resetPassword",1,a,!1);K("Firebase.resetPassword",a,"email");H("Firebase.resetPassword",2,b,!1);this.k.Q.Me(a,b)};R.prototype.resetPassword=R.prototype.Me;R.goOffline=function(){F("Firebase.goOffline",0,0,arguments.length);Th.Nb().pb()};R.goOnline=function(){F("Firebase.goOnline",0,0,arguments.length);Th.Nb().hc()};
function nb(a,b){y(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?lb=q(console.log,console):"object"===typeof console.log&&(lb=function(a){console.log(a)})),b&&v.set("logging_enabled",!0)):a?lb=a:(lb=null,v.remove("logging_enabled"))}R.enableLogging=nb;R.ServerValue={TIMESTAMP:{".sv":"timestamp"}};R.SDK_VERSION="2.1.2";R.INTERNAL=Y;R.Context=Th;R.TEST_ACCESS=$;})();
module.exports = Firebase;

},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'append' : require('./array/append'),
    'collect' : require('./array/collect'),
    'combine' : require('./array/combine'),
    'compact' : require('./array/compact'),
    'contains' : require('./array/contains'),
    'difference' : require('./array/difference'),
    'equals' : require('./array/equals'),
    'every' : require('./array/every'),
    'filter' : require('./array/filter'),
    'find' : require('./array/find'),
    'findIndex' : require('./array/findIndex'),
    'findLast' : require('./array/findLast'),
    'findLastIndex' : require('./array/findLastIndex'),
    'flatten' : require('./array/flatten'),
    'forEach' : require('./array/forEach'),
    'groupBy' : require('./array/groupBy'),
    'indexOf' : require('./array/indexOf'),
    'insert' : require('./array/insert'),
    'intersection' : require('./array/intersection'),
    'invoke' : require('./array/invoke'),
    'join' : require('./array/join'),
    'last' : require('./array/last'),
    'lastIndexOf' : require('./array/lastIndexOf'),
    'map' : require('./array/map'),
    'max' : require('./array/max'),
    'min' : require('./array/min'),
    'pick' : require('./array/pick'),
    'pluck' : require('./array/pluck'),
    'range' : require('./array/range'),
    'reduce' : require('./array/reduce'),
    'reduceRight' : require('./array/reduceRight'),
    'reject' : require('./array/reject'),
    'remove' : require('./array/remove'),
    'removeAll' : require('./array/removeAll'),
    'shuffle' : require('./array/shuffle'),
    'slice' : require('./array/slice'),
    'some' : require('./array/some'),
    'sort' : require('./array/sort'),
    'sortBy' : require('./array/sortBy'),
    'split' : require('./array/split'),
    'take' : require('./array/take'),
    'toLookup' : require('./array/toLookup'),
    'union' : require('./array/union'),
    'unique' : require('./array/unique'),
    'xor' : require('./array/xor'),
    'zip' : require('./array/zip')
};



},{"./array/append":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/append.js","./array/collect":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/collect.js","./array/combine":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/combine.js","./array/compact":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/compact.js","./array/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/contains.js","./array/difference":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/difference.js","./array/equals":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/equals.js","./array/every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/every.js","./array/filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js","./array/find":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/find.js","./array/findIndex":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findIndex.js","./array/findLast":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findLast.js","./array/findLastIndex":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findLastIndex.js","./array/flatten":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/flatten.js","./array/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js","./array/groupBy":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/groupBy.js","./array/indexOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/indexOf.js","./array/insert":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/insert.js","./array/intersection":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/intersection.js","./array/invoke":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/invoke.js","./array/join":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/join.js","./array/last":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/last.js","./array/lastIndexOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/lastIndexOf.js","./array/map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/map.js","./array/max":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/max.js","./array/min":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/min.js","./array/pick":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/pick.js","./array/pluck":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/pluck.js","./array/range":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/range.js","./array/reduce":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/reduce.js","./array/reduceRight":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/reduceRight.js","./array/reject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/reject.js","./array/remove":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/remove.js","./array/removeAll":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/removeAll.js","./array/shuffle":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/shuffle.js","./array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js","./array/some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/some.js","./array/sort":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/sort.js","./array/sortBy":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/sortBy.js","./array/split":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/split.js","./array/take":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/take.js","./array/toLookup":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/toLookup.js","./array/union":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/union.js","./array/unique":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/unique.js","./array/xor":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/xor.js","./array/zip":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/zip.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/append.js":[function(require,module,exports){


    /**
     * Appends an array to the end of another.
     * The first array will be modified.
     */
    function append(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var pad = arr1.length,
            i = -1,
            len = arr2.length;
        while (++i < len) {
            arr1[pad + i] = arr2[i];
        }
        return arr1;
    }
    module.exports = append;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/collect.js":[function(require,module,exports){
var append = require('./append');
var makeIterator = require('../function/makeIterator_');

    /**
     * Maps the items in the array and concatenates the result arrays.
     */
    function collect(arr, callback, thisObj){
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            var value = callback(arr[i], i, arr);
            if (value != null) {
                append(results, value);
            }
        }

        return results;
    }

    module.exports = collect;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./append":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/append.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/combine.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/compact.js":[function(require,module,exports){
var filter = require('./filter');

    /**
     * Remove all null/undefined items from array.
     */
    function compact(arr) {
        return filter(arr, function(val){
            return (val != null);
        });
    }

    module.exports = compact;


},{"./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/contains.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/difference.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/contains.js","./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js","./slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js","./some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/some.js","./unique":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/unique.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/equals.js":[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/is.js","../lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","./every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/every.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/every.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/find.js":[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findIndex.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findIndex.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findLast.js":[function(require,module,exports){
var findLastIndex = require('./findLastIndex');

    /**
     * Returns last item that matches criteria
     */
    function findLast(arr, iterator, thisObj){
        var idx = findLastIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = findLast;



},{"./findLastIndex":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findLastIndex.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/findLastIndex.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the last item that matches criteria
     */
    function findLastIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var n = arr.length;
        while (--n >= 0) {
            if (iterator(arr[n], n, arr)) {
                return n;
            }
        }

        return -1;
    }

    module.exports = findLastIndex;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/flatten.js":[function(require,module,exports){
var isArray = require('../lang/isArray');
var append = require('./append');

    /*
     * Helper function to flatten to a destination array.
     * Used to remove the need to create intermediate arrays while flattening.
     */
    function flattenTo(arr, result, level) {
        if (arr == null) {
            return result;
        } else if (level === 0) {
            append(result, arr);
            return result;
        }

        var value,
            i = -1,
            len = arr.length;
        while (++i < len) {
            value = arr[i];
            if (isArray(value)) {
                flattenTo(value, result, level - 1);
            } else {
                result.push(value);
            }
        }
        return result;
    }

    /**
     * Recursively flattens an array.
     * A new array containing all the elements is returned.
     * If `shallow` is true, it will only flatten one level.
     */
    function flatten(arr, level) {
        level = level == null? -1 : level;
        return flattenTo(arr, [], level);
    }

    module.exports = flatten;




},{"../lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","./append":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/append.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js":[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/groupBy.js":[function(require,module,exports){
var forEach = require('../array/forEach');
var identity = require('../function/identity');
var makeIterator = require('../function/makeIterator_');

    /**
     * Bucket the array values.
     */
    function groupBy(arr, categorize, thisObj) {
        if (categorize) {
            categorize = makeIterator(categorize, thisObj);
        } else {
            // Default to identity function.
            categorize = identity;
        }

        var buckets = {};
        forEach(arr, function(element) {
            var bucket = categorize(element);
            if (!(bucket in buckets)) {
                buckets[bucket] = [];
            }

            buckets[bucket].push(element);
        });

        return buckets;
    }

    module.exports = groupBy;


},{"../array/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js","../function/identity":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/identity.js","../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/indexOf.js":[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/insert.js":[function(require,module,exports){
var difference = require('./difference');
var slice = require('./slice');

    /**
     * Insert item into array if not already present.
     */
    function insert(arr, rest_items) {
        var diff = difference(slice(arguments, 1), arr);
        if (diff.length) {
            Array.prototype.push.apply(arr, diff);
        }
        return arr.length;
    }
    module.exports = insert;


},{"./difference":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/difference.js","./slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/intersection.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/contains.js","./every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/every.js","./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js","./slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js","./unique":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/unique.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/invoke.js":[function(require,module,exports){
var slice = require('./slice');

    /**
     * Call `methodName` on each item of the array passing custom arguments if
     * needed.
     */
    function invoke(arr, methodName, var_args){
        if (arr == null) {
            return arr;
        }

        var args = slice(arguments, 2);
        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            value[methodName].apply(value, args);
        }

        return arr;
    }

    module.exports = invoke;


},{"./slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/join.js":[function(require,module,exports){
var filter = require('./filter');

    function isValidString(val) {
        return (val != null && val !== '');
    }

    /**
     * Joins strings with the specified separator inserted between each value.
     * Null values and empty strings will be excluded.
     */
    function join(items, separator) {
        separator = separator || '';
        return filter(items, isValidString).join(separator);
    }

    module.exports = join;


},{"./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/last.js":[function(require,module,exports){


    /**
     * Returns last element of array.
     */
    function last(arr){
        if (arr == null || arr.length < 1) {
            return undefined;
        }

        return arr[arr.length - 1];
    }

    module.exports = last;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/lastIndexOf.js":[function(require,module,exports){


    /**
     * Array lastIndexOf
     */
    function lastIndexOf(arr, item, fromIndex) {
        if (arr == null) {
            return -1;
        }

        var len = arr.length;
        fromIndex = (fromIndex == null || fromIndex >= len)? len - 1 : fromIndex;
        fromIndex = (fromIndex < 0)? len + fromIndex : fromIndex;

        while (fromIndex >= 0) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[fromIndex] === item) {
                return fromIndex;
            }
            fromIndex--;
        }

        return -1;
    }

    module.exports = lastIndexOf;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/map.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/max.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return maximum value inside array
     */
    function max(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return Infinity;
        } else if (arr.length && !iterator) {
            return Math.max.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = -Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp > compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = max;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/min.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return minimum value inside array
     */
    function min(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return -Infinity;
        } else if (arr.length && !iterator) {
            return Math.min.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp < compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = min;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/pick.js":[function(require,module,exports){
var randInt = require('../random/randInt');

    /**
     * Remove random item(s) from the Array and return it.
     * Returns an Array of items if [nItems] is provided or a single item if
     * it isn't specified.
     */
    function pick(arr, nItems){
        if (nItems != null) {
            var result = [];
            if (nItems > 0 && arr && arr.length) {
                nItems = nItems > arr.length? arr.length : nItems;
                while (nItems--) {
                    result.push( pickOne(arr) );
                }
            }
            return result;
        }
        return (arr && arr.length)? pickOne(arr) : void(0);
    }


    function pickOne(arr){
        var idx = randInt(0, arr.length - 1);
        return arr.splice(idx, 1)[0];
    }


    module.exports = pick;



},{"../random/randInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randInt.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/pluck.js":[function(require,module,exports){
var map = require('./map');

    /**
     * Extract a list of property values.
     */
    function pluck(arr, propName){
        return map(arr, propName);
    }

    module.exports = pluck;



},{"./map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/map.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/range.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');

    /**
     * Returns an Array of numbers inside range.
     */
    function range(start, stop, step) {
        if (stop == null) {
            stop = start;
            start = 0;
        }
        step = step || 1;

        var result = [],
            nSteps = countSteps(stop - start, step),
            i = start;

        while (i <= stop) {
            result.push(i);
            i += step;
        }

        return result;
    }

    module.exports = range;



},{"../math/countSteps":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/countSteps.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/reduce.js":[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/reduceRight.js":[function(require,module,exports){


    /**
     * Array reduceRight
     */
    function reduceRight(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2;

        if (arr == null || !arr.length) {
            if (hasInit) {
                return initVal;
            } else {
                throw new Error('reduce of empty array with no initial value');
            }
        }

        var i = arr.length, result = initVal, value;
        while (--i >= 0) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            value = arr[i];
            if (!hasInit) {
                result = value;
                hasInit = true;
            } else {
                result = fn(result, value, i, arr);
            }
        }
        return result;
    }

    module.exports = reduceRight;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/reject.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array reject
     */
    function reject(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (!callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = reject;


},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/remove.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/removeAll.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove all instances of an item from array.
     */
    function removeAll(arr, item){
        var idx = indexOf(arr, item);
        while (idx !== -1) {
            arr.splice(idx, 1);
            idx = indexOf(arr, item, idx);
        }
    }

    module.exports = removeAll;


},{"./indexOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/shuffle.js":[function(require,module,exports){
var randInt = require('../random/randInt');

    /**
     * Shuffle array items.
     */
    function shuffle(arr) {
        var results = [],
            rnd;
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            if (!i) {
                results[0] = arr[0];
            } else {
                rnd = randInt(0, i);
                results[i] = results[rnd];
                results[rnd] = arr[i];
            }
        }

        return results;
    }

    module.exports = shuffle;


},{"../random/randInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randInt.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js":[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/some.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/sort.js":[function(require,module,exports){


    /**
     * Merge sort (http://en.wikipedia.org/wiki/Merge_sort)
     */
    function mergeSort(arr, compareFn) {
        if (arr == null) {
            return [];
        } else if (arr.length < 2) {
            return arr;
        }

        if (compareFn == null) {
            compareFn = defaultCompare;
        }

        var mid, left, right;

        mid   = ~~(arr.length / 2);
        left  = mergeSort( arr.slice(0, mid), compareFn );
        right = mergeSort( arr.slice(mid, arr.length), compareFn );

        return merge(left, right, compareFn);
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : (a > b? 1 : 0);
    }

    function merge(left, right, compareFn) {
        var result = [];

        while (left.length && right.length) {
            if (compareFn(left[0], right[0]) <= 0) {
                // if 0 it should preserve same order (stable)
                result.push(left.shift());
            } else {
                result.push(right.shift());
            }
        }

        if (left.length) {
            result.push.apply(result, left);
        }

        if (right.length) {
            result.push.apply(result, right);
        }

        return result;
    }

    module.exports = mergeSort;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/sortBy.js":[function(require,module,exports){
var sort = require('./sort');
var makeIterator = require('../function/makeIterator_');

    /*
     * Sort array by the result of the callback
     */
    function sortBy(arr, callback, context){
        callback = makeIterator(callback, context);

        return sort(arr, function(a, b) {
            a = callback(a);
            b = callback(b);
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        });
    }

    module.exports = sortBy;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./sort":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/sort.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/split.js":[function(require,module,exports){


    /**
     * Split array into a fixed number of segments.
     */
    function split(array, segments) {
        segments = segments || 2;
        var results = [];
        if (array == null) {
            return results;
        }

        var minLength = Math.floor(array.length / segments),
            remainder = array.length % segments,
            i = 0,
            len = array.length,
            segmentIndex = 0,
            segmentLength;

        while (i < len) {
            segmentLength = minLength;
            if (segmentIndex < remainder) {
                segmentLength++;
            }

            results.push(array.slice(i, i + segmentLength));

            segmentIndex++;
            i += segmentLength;
        }

        return results;
    }
    module.exports = split;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/take.js":[function(require,module,exports){


    /**
     * Iterates over a callback a set amount of times
     * returning the results
     */
    function take(n, callback, thisObj){
        var i = -1;
        var arr = [];
        if( !thisObj ){
            while(++i < n){
                arr[i] = callback(i, n);
            }
        } else {
            while(++i < n){
                arr[i] = callback.call(thisObj, i, n);
            }
        }
        return arr;
    }

    module.exports = take;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/toLookup.js":[function(require,module,exports){
var isFunction = require('../lang/isFunction');

    /**
     * Creates an object that holds a lookup for the objects in the array.
     */
    function toLookup(arr, key) {
        var result = {};
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length, value;
        if (isFunction(key)) {
            while (++i < len) {
                value = arr[i];
                result[key(value)] = value;
            }
        } else {
            while (++i < len) {
                value = arr[i];
                result[value[key]] = value;
            }
        }

        return result;
    }
    module.exports = toLookup;


},{"../lang/isFunction":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isFunction.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/union.js":[function(require,module,exports){
var unique = require('./unique');
var append = require('./append');

    /**
     * Concat multiple arrays and remove duplicates
     */
    function union(arrs) {
        var results = [];
        var i = -1, len = arguments.length;
        while (++i < len) {
            append(results, arguments[i]);
        }

        return unique(results);
    }

    module.exports = union;



},{"./append":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/append.js","./unique":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/unique.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/unique.js":[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/xor.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var contains = require('./contains');


    /**
     * Exclusive OR. Returns items that are present in a single array.
     * - like ptyhon's `symmetric_difference`
     */
    function xor(arr1, arr2) {
        arr1 = unique(arr1);
        arr2 = unique(arr2);

        var a1 = filter(arr1, function(item){
                return !contains(arr2, item);
            }),
            a2 = filter(arr2, function(item){
                return !contains(arr1, item);
            });

        return a1.concat(a2);
    }

    module.exports = xor;



},{"./contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/contains.js","./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/filter.js","./unique":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/unique.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/zip.js":[function(require,module,exports){
var max = require('./max');
var map = require('./map');

    function getLength(arr) {
        return arr == null ? 0 : arr.length;
    }

    /**
     * Merges together the values of each of the arrays with the values at the
     * corresponding position.
     */
    function zip(arr){
        var len = arr ? max(map(arguments, getLength)) : 0,
            results = [],
            i = -1;
        while (++i < len) {
            // jshint loopfunc: true
            results.push(map(arguments, function(item) {
                return item == null ? undefined : item[i];
            }));
        }

        return results;
    }

    module.exports = zip;



},{"./map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/map.js","./max":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/max.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'contains' : require('./collection/contains'),
    'every' : require('./collection/every'),
    'filter' : require('./collection/filter'),
    'find' : require('./collection/find'),
    'forEach' : require('./collection/forEach'),
    'make_' : require('./collection/make_'),
    'map' : require('./collection/map'),
    'max' : require('./collection/max'),
    'min' : require('./collection/min'),
    'pluck' : require('./collection/pluck'),
    'reduce' : require('./collection/reduce'),
    'reject' : require('./collection/reject'),
    'size' : require('./collection/size'),
    'some' : require('./collection/some')
};



},{"./collection/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/contains.js","./collection/every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/every.js","./collection/filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/filter.js","./collection/find":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/find.js","./collection/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/forEach.js","./collection/make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js","./collection/map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/map.js","./collection/max":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/max.js","./collection/min":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/min.js","./collection/pluck":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/pluck.js","./collection/reduce":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/reduce.js","./collection/reject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/reject.js","./collection/size":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/size.js","./collection/some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/some.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/contains.js":[function(require,module,exports){
var make = require('./make_');
var arrContains = require('../array/contains');
var objContains = require('../object/contains');

    /**
     */
    module.exports = make(arrContains, objContains);



},{"../array/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/contains.js","../object/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/contains.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/every.js":[function(require,module,exports){
var make = require('./make_');
var arrEvery = require('../array/every');
var objEvery = require('../object/every');

    /**
     */
    module.exports = make(arrEvery, objEvery);



},{"../array/every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/every.js","../object/every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/every.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/filter.js":[function(require,module,exports){
var forEach = require('./forEach');
var makeIterator = require('../function/makeIterator_');

    /**
     * filter collection values, returns array.
     */
    function filter(list, iterator, thisObj) {
        iterator = makeIterator(iterator, thisObj);
        var results = [];
        if (!list) {
            return results;
        }
        forEach(list, function(value, index, list) {
            if (iterator(value, index, list)) {
                results[results.length] = value;
            }
        });
        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/forEach.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/find.js":[function(require,module,exports){
var make = require('./make_');
var arrFind = require('../array/find');
var objFind = require('../object/find');

    /**
     * Find value that returns true on iterator check.
     */
    module.exports = make(arrFind, objFind);



},{"../array/find":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/find.js","../object/find":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/find.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/forEach.js":[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js","../object/forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/map.js":[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/map.js","../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","../lang/isObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isObject.js","../object/values":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/values.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/max.js":[function(require,module,exports){
var make = require('./make_');
var arrMax = require('../array/max');
var objMax = require('../object/max');

    /**
     * Get maximum value inside collection
     */
    module.exports = make(arrMax, objMax);



},{"../array/max":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/max.js","../object/max":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/max.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/min.js":[function(require,module,exports){
var make = require('./make_');
var arrMin = require('../array/min');
var objMin = require('../object/min');

    /**
     * Get minimum value inside collection.
     */
    module.exports = make(arrMin, objMin);



},{"../array/min":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/min.js","../object/min":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/min.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/pluck.js":[function(require,module,exports){
var map = require('./map');

    /**
     * Extract a list of property values.
     */
    function pluck(list, key) {
        return map(list, function(value) {
            return value[key];
        });
    }

    module.exports = pluck;



},{"./map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/map.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/reduce.js":[function(require,module,exports){
var make = require('./make_');
var arrReduce = require('../array/reduce');
var objReduce = require('../object/reduce');

    /**
     */
    module.exports = make(arrReduce, objReduce);



},{"../array/reduce":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/reduce.js","../object/reduce":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/reduce.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/reject.js":[function(require,module,exports){
var filter = require('./filter');
var makeIterator = require('../function/makeIterator_');

    /**
     * Inverse or collection/filter
     */
    function reject(list, iterator, thisObj) {
        iterator = makeIterator(iterator, thisObj);
        return filter(list, function(value, index, list) {
            return !iterator(value, index, list);
        }, thisObj);
    }

    module.exports = reject;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/filter.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/size.js":[function(require,module,exports){
var isArray = require('../lang/isArray');
var objSize = require('../object/size');

    /**
     * Get collection size
     */
    function size(list) {
        if (!list) {
            return 0;
        }
        if (isArray(list)) {
            return list.length;
        }
        return objSize(list);
    }

    module.exports = size;



},{"../lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","../object/size":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/size.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/some.js":[function(require,module,exports){
var make = require('./make_');
var arrSome = require('../array/some');
var objSome = require('../object/some');

    /**
     */
    module.exports = make(arrSome, objSome);



},{"../array/some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/some.js","../object/some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/some.js","./make_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection/make_.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'dayOfTheYear' : require('./date/dayOfTheYear'),
    'diff' : require('./date/diff'),
    'i18n_' : require('./date/i18n_'),
    'isLeapYear' : require('./date/isLeapYear'),
    'isSame' : require('./date/isSame'),
    'parseIso' : require('./date/parseIso'),
    'quarter' : require('./date/quarter'),
    'startOf' : require('./date/startOf'),
    'strftime' : require('./date/strftime'),
    'timezoneAbbr' : require('./date/timezoneAbbr'),
    'timezoneOffset' : require('./date/timezoneOffset'),
    'totalDaysInMonth' : require('./date/totalDaysInMonth'),
    'totalDaysInYear' : require('./date/totalDaysInYear'),
    'weekOfTheYear' : require('./date/weekOfTheYear')
};



},{"./date/dayOfTheYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/dayOfTheYear.js","./date/diff":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/diff.js","./date/i18n_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/i18n_.js","./date/isLeapYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/isLeapYear.js","./date/isSame":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/isSame.js","./date/parseIso":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/parseIso.js","./date/quarter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/quarter.js","./date/startOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/startOf.js","./date/strftime":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/strftime.js","./date/timezoneAbbr":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/timezoneAbbr.js","./date/timezoneOffset":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/timezoneOffset.js","./date/totalDaysInMonth":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/totalDaysInMonth.js","./date/totalDaysInYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/totalDaysInYear.js","./date/weekOfTheYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/weekOfTheYear.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/dayOfTheYear.js":[function(require,module,exports){
var isDate = require('../lang/isDate');

    /**
     * return the day of the year (1..366)
     */
    function dayOfTheYear(date){
        return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) -
                Date.UTC(date.getFullYear(), 0, 1)) / 86400000 + 1;
    }

    module.exports = dayOfTheYear;



},{"../lang/isDate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isDate.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/diff.js":[function(require,module,exports){
var totalDaysInMonth = require('./totalDaysInMonth');
var totalDaysInYear = require('./totalDaysInYear');
var convert = require('../time/convert');

    /**
     * calculate the difference between dates (range)
     */
    function diff(start, end, unitName){
        // sort the dates to make it easier to process (specially year/month)
        if (start > end) {
            var swap = start;
            start = end;
            end = swap;
        }

        var output;

        if (unitName === 'month') {
            output = getMonthsDiff(start, end);
        } else if (unitName === 'year'){
            output = getYearsDiff(start, end);
        } else if (unitName != null) {
            if (unitName === 'day') {
                // ignore timezone difference because of daylight savings time
                start = toUtc(start);
                end = toUtc(end);
            }
            output = convert(end - start, 'ms', unitName);
        } else {
            output = end - start;
        }

        return output;
    }


    function toUtc(d){
        // we ignore timezone differences on purpose because of daylight
        // savings time, otherwise it would return fractional days/weeks even
        // if a full day elapsed. eg:
        // Wed Feb 12 2014 00:00:00 GMT-0200 (BRST)
        // Sun Feb 16 2014 00:00:00 GMT-0300 (BRT)
        // diff should be 4 days and not 4.041666666666667
        return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(),
                        d.getHours(), d.getMinutes(), d.getSeconds(),
                        d.getMilliseconds());
    }


    function getMonthsDiff(start, end){
        return getElapsedMonths(start, end) +
               getElapsedYears(start, end) * 12 +
               getFractionalMonth(start, end);
    }


    function getYearsDiff(start, end){
        var elapsedYears = getElapsedYears(start, end);
        return elapsedYears + getFractionalYear(start, end, elapsedYears);
    }


    function getElapsedMonths(start, end){
        var monthDiff = end.getMonth() - start.getMonth();
        if (monthDiff < 0) {
            monthDiff += 12;
        }
        // less than a full month
        if (start.getDate() > end.getDate()) {
            monthDiff -= 1;
        }
        return monthDiff;
    }


    function getElapsedYears(start, end){
        var yearDiff = end.getFullYear() - start.getFullYear();
        // less than a full year
        if (start.getMonth() > end.getMonth()) {
            yearDiff -= 1;
        }
        return yearDiff;
    }


    function getFractionalMonth(start, end){
        var fractionalDiff = 0;
        var startDay = start.getDate();
        var endDay = end.getDate();

        if (startDay !== endDay) {
            var startTotalDays = totalDaysInMonth(start);
            var endTotalDays = totalDaysInMonth(end);
            var totalDays;
            var daysElapsed;

            if (startDay > endDay) {
                // eg: Jan 29 - Feb 27 (29 days elapsed but not a full month)
                var baseDay = startTotalDays - startDay;
                daysElapsed = endDay + baseDay;
                // total days should be relative to 1st day of next month if
                // startDay > endTotalDays
                totalDays = (startDay > endTotalDays)?
                    endTotalDays + baseDay + 1 : startDay + baseDay;
            } else {
                // fractional is only based on endMonth eg: Jan 12 - Feb 18
                // (6 fractional days, 28 days until next full month)
                daysElapsed = endDay - startDay;
                totalDays = endTotalDays;
            }

            fractionalDiff = daysElapsed / totalDays;
        }

        return fractionalDiff;
    }


    function getFractionalYear(start, end, elapsedYears){
        var base = elapsedYears?
            new Date(end.getFullYear(), start.getMonth(), start.getDate()) :
            start;
        var elapsedDays = diff(base, end, 'day');
        return elapsedDays / totalDaysInYear(end);
    }


    module.exports = diff;



},{"../time/convert":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/convert.js","./totalDaysInMonth":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/totalDaysInMonth.js","./totalDaysInYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/totalDaysInYear.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/i18n/en-US.js":[function(require,module,exports){

    // en-US (English, United States)
    module.exports = {
        "am" : "AM",
        "pm" : "PM",

        "x": "%m/%d/%y",
        "X": "%H:%M:%S",
        "c": "%a %d %b %Y %I:%M:%S %p %Z",

        "months" : [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ],

        "months_abbr" : [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ],

        "days" : [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ],

        "days_abbr" : [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ]
    };


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/i18n_.js":[function(require,module,exports){
var mixIn = require('../object/mixIn');
var enUS = require('./i18n/en-US');

    // we also use mixIn to make sure we don't affect the original locale
    var activeLocale = mixIn({}, enUS, {
        // we expose a "set" method to allow overriding the global locale
        set : function(localeData){
            mixIn(activeLocale, localeData);
        }
    });

    module.exports = activeLocale;



},{"../object/mixIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/mixIn.js","./i18n/en-US":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/i18n/en-US.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/isLeapYear.js":[function(require,module,exports){
var isDate = require('../lang/isDate');

    /**
     * checks if it's a leap year
     */
    function isLeapYear(fullYear){
        if (isDate(fullYear)) {
            fullYear = fullYear.getFullYear();
        }
        return fullYear % 400 === 0 || (fullYear % 100 !== 0 && fullYear % 4 === 0);
    }

    module.exports = isLeapYear;



},{"../lang/isDate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isDate.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/isSame.js":[function(require,module,exports){
var startOf = require('./startOf');

    /**
     * Check if date is "same" with optional period
     */
    function isSame(date1, date2, period){
        if (period) {
            date1 = startOf(date1, period);
            date2 = startOf(date2, period);
        }
        return Number(date1) === Number(date2);
    }

    module.exports = isSame;



},{"./startOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/startOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/parseIso.js":[function(require,module,exports){
var some = require('../array/some');

    var datePatterns = [
        /^([0-9]{4})$/,                        // YYYY
        /^([0-9]{4})-([0-9]{2})$/,             // YYYY-MM (YYYYMM not allowed)
        /^([0-9]{4})-?([0-9]{2})-?([0-9]{2})$/ // YYYY-MM-DD or YYYYMMDD
    ];
    var ORD_DATE = /^([0-9]{4})-?([0-9]{3})$/; // YYYY-DDD

    var timePatterns = [
        /^([0-9]{2}(?:\.[0-9]*)?)$/,                      // HH.hh
        /^([0-9]{2}):?([0-9]{2}(?:\.[0-9]*)?)$/,          // HH:MM.mm
        /^([0-9]{2}):?([0-9]{2}):?([0-9]{2}(\.[0-9]*)?)$/ // HH:MM:SS.ss
    ];

    var DATE_TIME = /^(.+)T(.+)$/;
    var TIME_ZONE = /^(.+)([+\-])([0-9]{2}):?([0-9]{2})$/;

    function matchAll(str, patterns) {
        var match;
        var found = some(patterns, function(pattern) {
            return !!(match = pattern.exec(str));
        });

        return found ? match : null;
    }

    function getDate(year, month, day) {
        var date = new Date(Date.UTC(year, month, day));

        // Explicitly set year to avoid Date.UTC making dates < 100 relative to
        // 1900
        date.setUTCFullYear(year);

        var valid =
            date.getUTCFullYear() === year &&
            date.getUTCMonth() === month &&
            date.getUTCDate() === day;
        return valid ? +date : NaN;
    }

    function parseOrdinalDate(str) {
        var match = ORD_DATE.exec(str);
        if (match ) {
            var year = +match[1],
                day = +match[2],
                date = new Date(Date.UTC(year, 0, day));

            if (date.getUTCFullYear() === year) {
                return +date;
            }
        }

        return NaN;
    }

    function parseDate(str) {
        var match, year, month, day;

        match = matchAll(str, datePatterns);
        if (match === null) {
            // Ordinal dates are verified differently.
            return parseOrdinalDate(str);
        }

        year = (match[1] === void 0) ? 0 : +match[1];
        month = (match[2] === void 0) ? 0 : +match[2] - 1;
        day = (match[3] === void 0) ? 1 : +match[3];

        return getDate(year, month, day);
    }

    function getTime(hr, min, sec) {
        var valid =
            (hr < 24 && hr >= 0 &&
             min < 60 && min >= 0 &&
             sec < 60 && min >= 0) ||
            (hr === 24 && min === 0 && sec === 0);
        if (!valid) {
            return NaN;
        }

        return ((hr * 60 + min) * 60 + sec) * 1000;
    }

    function parseOffset(str) {
        var match;
        if (str.charAt(str.length - 1) === 'Z') {
            str = str.substring(0, str.length - 1);
        } else {
            match = TIME_ZONE.exec(str);
            if (match) {
                var hours = +match[3],
                    minutes = (match[4] === void 0) ? 0 : +match[4],
                    offset = getTime(hours, minutes, 0);

                if (match[2] === '-') {
                    offset *= -1;
                }

                return { offset: offset, time: match[1] };
            }
        }

        // No time zone specified, assume UTC
        return { offset: 0, time: str };
    }

    function parseTime(str) {
        var match;
        var offset = parseOffset(str);

        str = offset.time;
        offset = offset.offset;
        if (isNaN(offset)) {
            return NaN;
        }

        match = matchAll(str, timePatterns);
        if (match === null) {
            return NaN;
        }

        var hours = (match[1] === void 0) ? 0 : +match[1],
            minutes = (match[2] === void 0) ? 0 : +match[2],
            seconds = (match[3] === void 0) ? 0 : +match[3];

        return getTime(hours, minutes, seconds) - offset;
    }

    /**
     * Parse an ISO8601 formatted date string, and return a Date object.
     */
    function parseISO8601(str){
        var match = DATE_TIME.exec(str);
        if (!match) {
            // No time specified
            return parseDate(str);
        }

        return parseDate(match[1]) + parseTime(match[2]);
    }

    module.exports = parseISO8601;



},{"../array/some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/some.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/quarter.js":[function(require,module,exports){


    /**
     * gets date quarter
     */
    function quarter(date){
        var month = date.getMonth();
        if (month < 3) return 1;
        if (month < 6) return 2;
        if (month < 9) return 3;
        return 4;
    }

    module.exports = quarter;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/startOf.js":[function(require,module,exports){
var clone = require('../lang/clone');

    /**
     * get a new Date object representing start of period
     */
    function startOf(date, period){
        date = clone(date);

        // intentionally removed "break" from switch since start of
        // month/year/etc should also reset the following periods
        switch (period) {
            case 'year':
                date.setMonth(0);
            /* falls through */
            case 'month':
                date.setDate(1);
            /* falls through */
            case 'week':
            case 'day':
                date.setHours(0);
            /* falls through */
            case 'hour':
                date.setMinutes(0);
            /* falls through */
            case 'minute':
                date.setSeconds(0);
            /* falls through */
            case 'second':
                date.setMilliseconds(0);
                break;
            default:
                throw new Error('"'+ period +'" is not a valid period');
        }

        // week is the only case that should reset the weekDay and maybe even
        // overflow to previous month
        if (period === 'week') {
            var weekDay = date.getDay();
            var baseDate = date.getDate();
            if (weekDay) {
                if (weekDay >= baseDate) {
                    //start of the week is on previous month
                    date.setDate(0);
                }
                date.setDate(date.getDate() - date.getDay());
            }
        }

        return date;
    }

    module.exports = startOf;



},{"../lang/clone":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/clone.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/strftime.js":[function(require,module,exports){
var pad = require('../number/pad');
var lpad = require('../string/lpad');
var i18n = require('./i18n_');
var dayOfTheYear = require('./dayOfTheYear');
var timezoneOffset = require('./timezoneOffset');
var timezoneAbbr = require('./timezoneAbbr');
var weekOfTheYear = require('./weekOfTheYear');

    var _combinations = {
        'D': '%m/%d/%y',
        'F': '%Y-%m-%d',
        'r': '%I:%M:%S %p',
        'R': '%H:%M',
        'T': '%H:%M:%S',
        'x': 'locale',
        'X': 'locale',
        'c': 'locale'
    };


    /**
     * format date based on strftime format
     */
    function strftime(date, format, localeData){
        localeData = localeData  || i18n;
        var reToken = /%([a-z%])/gi;

        function makeIterator(fn) {
            return function(match, token){
                return fn(date, token, localeData);
            };
        }

        return format
            .replace(reToken, makeIterator(expandCombinations))
            .replace(reToken, makeIterator(convertToken));
    }


    function expandCombinations(date, token, l10n){
        if (token in _combinations) {
            var expanded = _combinations[token];
            return expanded === 'locale'? l10n[token] : expanded;
        } else {
            return '%'+ token;
        }
    }


    function convertToken(date, token, l10n){
        switch (token){
            case 'a':
                return l10n.days_abbr[date.getDay()];
            case 'A':
                return l10n.days[date.getDay()];
            case 'h':
            case 'b':
                return l10n.months_abbr[date.getMonth()];
            case 'B':
                return l10n.months[date.getMonth()];
            case 'C':
                return pad(Math.floor(date.getFullYear() / 100), 2);
            case 'd':
                return pad(date.getDate(), 2);
            case 'e':
                return pad(date.getDate(), 2, ' ');
            case 'H':
                return pad(date.getHours(), 2);
            case 'I':
                return pad(date.getHours() % 12, 2);
            case 'j':
                return pad(dayOfTheYear(date), 3);
            case 'l':
                return lpad(date.getHours() % 12, 2);
            case 'L':
                return pad(date.getMilliseconds(), 3);
            case 'm':
                return pad(date.getMonth() + 1, 2);
            case 'M':
                return pad(date.getMinutes(), 2);
            case 'n':
                return '\n';
            case 'p':
                return date.getHours() >= 12? l10n.pm : l10n.am;
            case 'P':
                return convertToken(date, 'p', l10n).toLowerCase();
            case 's':
                return date.getTime() / 1000;
            case 'S':
                return pad(date.getSeconds(), 2);
            case 't':
                return '\t';
            case 'u':
                var day = date.getDay();
                return day === 0? 7 : day;
            case 'U':
                return pad(weekOfTheYear(date), 2);
            case 'w':
                return date.getDay();
            case 'W':
                return pad(weekOfTheYear(date, 1), 2);
            case 'y':
                return pad(date.getFullYear() % 100, 2);
            case 'Y':
                return pad(date.getFullYear(), 4);
            case 'z':
                return timezoneOffset(date);
            case 'Z':
                return timezoneAbbr(date);
            case '%':
                return '%';
            default:
                // keep unrecognized tokens
                return '%'+ token;
        }
    }


    module.exports = strftime;



},{"../number/pad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/pad.js","../string/lpad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lpad.js","./dayOfTheYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/dayOfTheYear.js","./i18n_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/i18n_.js","./timezoneAbbr":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/timezoneAbbr.js","./timezoneOffset":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/timezoneOffset.js","./weekOfTheYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/weekOfTheYear.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/timezoneAbbr.js":[function(require,module,exports){
var timezoneOffset = require('./timezoneOffset');

    /**
     * Abbreviated time zone name or similar information.
     */
    function timezoneAbbr(date){
        // Date.toString gives different results depending on the
        // browser/system so we fallback to timezone offset
        // chrome: 'Mon Apr 08 2013 09:02:04 GMT-0300 (BRT)'
        // IE: 'Mon Apr 8 09:02:04 UTC-0300 2013'
        var tz = /\(([A-Z]{3,4})\)/.exec(date.toString());
        return tz? tz[1] : timezoneOffset(date);
    }

    module.exports = timezoneAbbr;



},{"./timezoneOffset":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/timezoneOffset.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/timezoneOffset.js":[function(require,module,exports){
var pad = require('../number/pad');

    /**
     * time zone as hour and minute offset from UTC (e.g. +0900)
     */
    function timezoneOffset(date){
        var offset = date.getTimezoneOffset();
        var abs = Math.abs(offset);
        var h = pad(Math.floor(abs / 60), 2);
        var m = pad(abs % 60, 2);
        return (offset > 0? '-' : '+') + h + m;
    }

    module.exports = timezoneOffset;



},{"../number/pad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/pad.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/totalDaysInMonth.js":[function(require,module,exports){
var isDate = require('../lang/isDate');
var isLeapYear = require('./isLeapYear');

    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    /**
     * returns the total amount of days in the month (considering leap years)
     */
    function totalDaysInMonth(fullYear, monthIndex){
        if (isDate(fullYear)) {
            monthIndex = fullYear.getMonth();
        }

        if (monthIndex === 1 && isLeapYear(fullYear)) {
            return 29;
        } else {
            return DAYS_IN_MONTH[monthIndex];
        }
    }

    module.exports = totalDaysInMonth;



},{"../lang/isDate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isDate.js","./isLeapYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/isLeapYear.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/totalDaysInYear.js":[function(require,module,exports){
var isLeapYear = require('./isLeapYear');

    /**
     * return the amount of days in the year following the gregorian calendar
     * and leap years
     */
    function totalDaysInYear(fullYear){
        return isLeapYear(fullYear)? 366 : 365;
    }

    module.exports = totalDaysInYear;



},{"./isLeapYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/isLeapYear.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/weekOfTheYear.js":[function(require,module,exports){
var dayOfTheYear = require('./dayOfTheYear');

    /**
     * Return the week of the year based on given firstDayOfWeek
     */
    function weekOfTheYear(date, firstDayOfWeek){
        firstDayOfWeek = firstDayOfWeek == null? 0 : firstDayOfWeek;
        var doy = dayOfTheYear(date);
        var dow = (7 + date.getDay() - firstDayOfWeek) % 7;
        var relativeWeekDay = 6 - firstDayOfWeek - dow;
        return Math.floor((doy + relativeWeekDay) / 7);
    }

    module.exports = weekOfTheYear;



},{"./dayOfTheYear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date/dayOfTheYear.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'awaitDelay' : require('./function/awaitDelay'),
    'bind' : require('./function/bind'),
    'compose' : require('./function/compose'),
    'constant' : require('./function/constant'),
    'debounce' : require('./function/debounce'),
    'func' : require('./function/func'),
    'identity' : require('./function/identity'),
    'makeIterator_' : require('./function/makeIterator_'),
    'partial' : require('./function/partial'),
    'prop' : require('./function/prop'),
    'series' : require('./function/series'),
    'throttle' : require('./function/throttle'),
    'timeout' : require('./function/timeout'),
    'times' : require('./function/times'),
    'wrap' : require('./function/wrap')
};



},{"./function/awaitDelay":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/awaitDelay.js","./function/bind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/bind.js","./function/compose":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/compose.js","./function/constant":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/constant.js","./function/debounce":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/debounce.js","./function/func":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/func.js","./function/identity":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/identity.js","./function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./function/partial":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/partial.js","./function/prop":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/prop.js","./function/series":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/series.js","./function/throttle":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/throttle.js","./function/timeout":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/timeout.js","./function/times":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/times.js","./function/wrap":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/wrap.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/awaitDelay.js":[function(require,module,exports){
var now = require('../time/now');
var timeout = require('./timeout');
var append = require('../array/append');

    /**
     * Ensure a minimum delay for callbacks
     */
    function awaitDelay( callback, delay ){
        var baseTime = now() + delay;
        return function() {
            // ensure all browsers will execute it asynchronously (avoid hard
            // to catch errors) not using "0" because of old browsers and also
            // since new browsers increase the value to be at least "4"
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout
            var ms = Math.max(baseTime - now(), 4);
            return timeout.apply(this, append([callback, ms, this], arguments));
        };
    }

    module.exports = awaitDelay;



},{"../array/append":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/append.js","../time/now":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/now.js","./timeout":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/timeout.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/bind.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a function that will execute in the given context, optionally adding any additional supplied parameters to the beginning of the arguments collection.
     * @param {Function} fn  Function.
     * @param {object} context   Execution context.
     * @param {rest} args    Arguments (0...n arguments).
     * @return {Function} Wrapped Function.
     */
    function bind(fn, context, args){
        var argsArr = slice(arguments, 2); //curried args
        return function(){
            return fn.apply(context, argsArr.concat(slice(arguments)));
        };
    }

    module.exports = bind;



},{"../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/compose.js":[function(require,module,exports){


    /**
     * Returns a function that composes multiple functions, passing results to
     * each other.
     */
    function compose() {
        var fns = arguments;
        return function(arg){
            // only cares about the first argument since the chain can only
            // deal with a single return value anyway. It should start from
            // the last fn.
            var n = fns.length;
            while (n--) {
                arg = fns[n].call(this, arg);
            }
            return arg;
         };
     }

     module.exports = compose;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/constant.js":[function(require,module,exports){


    /**
     * Returns a new function that will return the value
     */
    function constant(value){
        return function() {
            return value;
        };
    }

    module.exports = constant;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/debounce.js":[function(require,module,exports){


    /**
     * Debounce callback execution
     */
    function debounce(fn, threshold, isAsap){
        var timeout, result;
        function debounced(){
            var args = arguments, context = this;
            function delayed(){
                if (! isAsap) {
                    result = fn.apply(context, args);
                }
                timeout = null;
            }
            if (timeout) {
                clearTimeout(timeout);
            } else if (isAsap) {
                result = fn.apply(context, args);
            }
            timeout = setTimeout(delayed, threshold);
            return result;
        }
        debounced.cancel = function(){
            clearTimeout(timeout);
        };
        return debounced;
    }

    module.exports = debounce;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/func.js":[function(require,module,exports){


    /**
     * Returns a function that call a method on the passed object
     */
    function func(name){
        return function(obj){
            return obj[name]();
        };
    }

    module.exports = func;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/identity.js":[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js":[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/deepMatches.js","./identity":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/identity.js","./prop":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/prop.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/partial.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Creates a partially applied function.
     */
    function partial(f) {
        var as = slice(arguments, 1);
        return function() {
            var args = as.concat(slice(arguments));
            for (var i = args.length; i--;) {
                if (args[i] === partial._) {
                    args[i] = args.splice(-1)[0];
                }
            }
            return f.apply(this, args);
        };
    }

    partial._ = {};

    module.exports = partial;



},{"../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/prop.js":[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/series.js":[function(require,module,exports){


    /**
     * Returns a function that will execute a list of functions in sequence
     * passing the same arguments to each one. (useful for batch processing
     * items during a forEach loop)
     */
    function series(){
        var fns = arguments;
        return function(){
            var i = 0,
                n = fns.length;
            while (i < n) {
                fns[i].apply(this, arguments);
                i += 1;
            }
        };
    }

    module.exports = series;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/throttle.js":[function(require,module,exports){
var now = require('../time/now');

    /**
     */
    function throttle(fn, delay){
        var context, timeout, result, args,
            diff, prevCall = 0;
        function delayed(){
            prevCall = now();
            timeout = null;
            result = fn.apply(context, args);
        }
        function throttled(){
            context = this;
            args = arguments;
            diff = delay - (now() - prevCall);
            if (diff <= 0) {
                clearTimeout(timeout);
                delayed();
            } else if (! timeout) {
                timeout = setTimeout(delayed, diff);
            }
            return result;
        }
        throttled.cancel = function(){
            clearTimeout(timeout);
        };
        return throttled;
    }

    module.exports = throttle;



},{"../time/now":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/now.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/timeout.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Delays the call of a function within a given context.
     */
    function timeout(fn, millis, context){

        var args = slice(arguments, 3);

        return setTimeout(function() {
            fn.apply(context, args);
        }, millis);
    }

    module.exports = timeout;



},{"../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/times.js":[function(require,module,exports){


    /**
     * Iterates over a callback a set amount of times
     */
    function times(n, callback, thisObj){
        var i = -1;
        while (++i < n) {
            if ( callback.call(thisObj, i) === false ) {
                break;
            }
        }
    }

    module.exports = times;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/wrap.js":[function(require,module,exports){
var partial = require('./partial');

    /**
     * Returns the first function passed as an argument to the second,
     * allowing you to adjust arguments, run code before and after, and
     * conditionally execute the original function.
     */
    function wrap(fn, wrapper){
        return partial(wrapper, fn);
    }

    module.exports = wrap;



},{"./partial":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/partial.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/index.js":[function(require,module,exports){
/**@license
 * mout v0.11.0 | http://moutjs.com | MIT license
 */


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'VERSION' : '0.11.0',
    'array' : require('./array'),
    'collection' : require('./collection'),
    'date' : require('./date'),
    'function' : require('./function'),
    'lang' : require('./lang'),
    'math' : require('./math'),
    'number' : require('./number'),
    'object' : require('./object'),
    'queryString' : require('./queryString'),
    'random' : require('./random'),
    'string' : require('./string'),
    'time' : require('./time'),
    'fn' : require('./function')
};



},{"./array":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array.js","./collection":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/collection.js","./date":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/date.js","./function":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function.js","./lang":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang.js","./math":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math.js","./number":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number.js","./object":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object.js","./queryString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString.js","./random":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random.js","./string":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string.js","./time":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'GLOBAL' : require('./lang/GLOBAL'),
    'clone' : require('./lang/clone'),
    'createObject' : require('./lang/createObject'),
    'ctorApply' : require('./lang/ctorApply'),
    'deepClone' : require('./lang/deepClone'),
    'deepEquals' : require('./lang/deepEquals'),
    'defaults' : require('./lang/defaults'),
    'inheritPrototype' : require('./lang/inheritPrototype'),
    'is' : require('./lang/is'),
    'isArguments' : require('./lang/isArguments'),
    'isArray' : require('./lang/isArray'),
    'isBoolean' : require('./lang/isBoolean'),
    'isDate' : require('./lang/isDate'),
    'isEmpty' : require('./lang/isEmpty'),
    'isFinite' : require('./lang/isFinite'),
    'isFunction' : require('./lang/isFunction'),
    'isInteger' : require('./lang/isInteger'),
    'isKind' : require('./lang/isKind'),
    'isNaN' : require('./lang/isNaN'),
    'isNull' : require('./lang/isNull'),
    'isNumber' : require('./lang/isNumber'),
    'isObject' : require('./lang/isObject'),
    'isPlainObject' : require('./lang/isPlainObject'),
    'isPrimitive' : require('./lang/isPrimitive'),
    'isRegExp' : require('./lang/isRegExp'),
    'isString' : require('./lang/isString'),
    'isUndefined' : require('./lang/isUndefined'),
    'isnt' : require('./lang/isnt'),
    'kindOf' : require('./lang/kindOf'),
    'toArray' : require('./lang/toArray'),
    'toNumber' : require('./lang/toNumber'),
    'toString' : require('./lang/toString')
};



},{"./lang/GLOBAL":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/GLOBAL.js","./lang/clone":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/clone.js","./lang/createObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/createObject.js","./lang/ctorApply":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/ctorApply.js","./lang/deepClone":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/deepClone.js","./lang/deepEquals":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/deepEquals.js","./lang/defaults":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/defaults.js","./lang/inheritPrototype":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/inheritPrototype.js","./lang/is":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/is.js","./lang/isArguments":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArguments.js","./lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","./lang/isBoolean":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isBoolean.js","./lang/isDate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isDate.js","./lang/isEmpty":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isEmpty.js","./lang/isFinite":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isFinite.js","./lang/isFunction":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isFunction.js","./lang/isInteger":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isInteger.js","./lang/isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js","./lang/isNaN":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNaN.js","./lang/isNull":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNull.js","./lang/isNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNumber.js","./lang/isObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isObject.js","./lang/isPlainObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPlainObject.js","./lang/isPrimitive":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPrimitive.js","./lang/isRegExp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isRegExp.js","./lang/isString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isString.js","./lang/isUndefined":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isUndefined.js","./lang/isnt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isnt.js","./lang/kindOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/kindOf.js","./lang/toArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toArray.js","./lang/toNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toNumber.js","./lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/GLOBAL.js":[function(require,module,exports){


    // Reference to the global context (works on ES3 and ES5-strict mode)
    //jshint -W061, -W064
    module.exports = Function('return this')();



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/clone.js":[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/mixIn.js","./isPlainObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPlainObject.js","./kindOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/createObject.js":[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/mixIn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/ctorApply.js":[function(require,module,exports){


    function F(){}

    /**
     * Do fn.apply on a constructor.
     */
    function ctorApply(ctor, args) {
        F.prototype = ctor.prototype;
        var instance = new F();
        ctor.apply(instance, args);
        return instance;
    }

    module.exports = ctorApply;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/deepClone.js":[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js","./clone":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/clone.js","./isPlainObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPlainObject.js","./kindOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/deepEquals.js":[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/equals.js","../object/equals":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/equals.js","./is":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/is.js","./isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","./isObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isObject.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/defaults.js":[function(require,module,exports){
var toArray = require('./toArray');
var find = require('../array/find');

    /**
     * Return first non void argument
     */
    function defaults(var_args){
        return find(toArray(arguments), nonVoid);
    }

    function nonVoid(val){
        return val != null;
    }

    module.exports = defaults;



},{"../array/find":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/find.js","./toArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toArray.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/inheritPrototype.js":[function(require,module,exports){
var createObject = require('./createObject');

    /**
    * Inherit prototype from another Object.
    * - inspired by Nicholas Zackas <http://nczonline.net> Solution
    * @param {object} child Child object
    * @param {object} parent    Parent Object
    */
    function inheritPrototype(child, parent){
        var p = createObject(parent.prototype);
        p.constructor = child;
        child.prototype = p;
        child.super_ = parent;
        return p;
    }

    module.exports = inheritPrototype;


},{"./createObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/createObject.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/is.js":[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArguments.js":[function(require,module,exports){
var isKind = require('./isKind');

    /**
     */
    var isArgs = isKind(arguments, 'Arguments')?
            function(val){
                return isKind(val, 'Arguments');
            } :
            function(val){
                // Arguments is an Object on IE7
                return !!(val && Object.prototype.hasOwnProperty.call(val, 'callee'));
            };

    module.exports = isArgs;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isBoolean.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isBoolean(val) {
        return isKind(val, 'Boolean');
    }
    module.exports = isBoolean;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isDate.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isDate(val) {
        return isKind(val, 'Date');
    }
    module.exports = isDate;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isEmpty.js":[function(require,module,exports){
var forOwn = require('../object/forOwn');
var isArray = require('./isArray');

    function isEmpty(val){
        if (val == null) {
            // typeof null == 'object' so we check it first
            return true;
        } else if ( typeof val === 'string' || isArray(val) ) {
            return !val.length;
        } else if ( typeof val === 'object' ) {
            var result = true;
            forOwn(val, function(){
                result = false;
                return false; // break loop
            });
            return result;
        } else {
            return true;
        }
    }

    module.exports = isEmpty;



},{"../object/forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js","./isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isFinite.js":[function(require,module,exports){
var isNumber = require('./isNumber');
var GLOBAL = require('./GLOBAL');

    /**
     * Check if value is finite
     */
    function isFinite(val){
        var is = false;
        if (typeof val === 'string' && val !== '') {
            is = GLOBAL.isFinite( parseFloat(val) );
        } else if (isNumber(val)){
            // need to use isNumber because of Number constructor
            is = GLOBAL.isFinite( val );
        }
        return is;
    }

    module.exports = isFinite;



},{"./GLOBAL":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/GLOBAL.js","./isNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isFunction.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isFunction(val) {
        return isKind(val, 'Function');
    }
    module.exports = isFunction;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isInteger.js":[function(require,module,exports){
var isNumber = require('./isNumber');

    /**
     * Check if value is an integer
     */
    function isInteger(val){
        return isNumber(val) && (val % 1 === 0);
    }

    module.exports = isInteger;



},{"./isNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js":[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNaN.js":[function(require,module,exports){
var isNumber = require('./isNumber');
var $isNaN = require('../number/isNaN');

    /**
     * Check if value is NaN for realz
     */
    function isNaN(val){
        // based on the fact that NaN !== NaN
        // need to check if it's a number to avoid conflicts with host objects
        // also need to coerce ToNumber to avoid edge case `new Number(NaN)`
        return !isNumber(val) || $isNaN(Number(val));
    }

    module.exports = isNaN;



},{"../number/isNaN":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/isNaN.js","./isNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNull.js":[function(require,module,exports){

    /**
     */
    function isNull(val){
        return val === null;
    }
    module.exports = isNull;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNumber.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isObject.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPlainObject.js":[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPrimitive.js":[function(require,module,exports){


    /**
     * Checks if the object is a primitive
     */
    function isPrimitive(value) {
        // Using switch fallthrough because it's simple to read and is
        // generally fast: http://jsperf.com/testing-value-is-primitive/5
        switch (typeof value) {
            case "string":
            case "number":
            case "boolean":
                return true;
        }

        return value == null;
    }

    module.exports = isPrimitive;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isRegExp.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isString.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isString(val) {
        return isKind(val, 'String');
    }
    module.exports = isString;


},{"./isKind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isUndefined.js":[function(require,module,exports){

    var UNDEF;

    /**
     */
    function isUndef(val){
        return val === UNDEF;
    }
    module.exports = isUndef;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isnt.js":[function(require,module,exports){
var is = require('./is');

    /**
     * Check if both values are not identical/egal
     */
    function isnt(x, y){
        return !is(x, y);
    }

    module.exports = isnt;



},{"./is":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/is.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/kindOf.js":[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toArray.js":[function(require,module,exports){
var kindOf = require('./kindOf');
var GLOBAL = require('./GLOBAL');

    /**
     * Convert array-like object into array
     */
    function toArray(val){
        var ret = [],
            kind = kindOf(val),
            n;

        if (val != null) {
            if ( val.length == null || kind === 'String' || kind === 'Function' || kind === 'RegExp' || val === GLOBAL ) {
                //string, regexp, function have .length but user probably just want
                //to wrap value into an array..
                ret[ret.length] = val;
            } else {
                //window returns true on isObject in IE7 and may have length
                //property. `typeof NodeList` returns `function` on Safari so
                //we can't use it (#58)
                n = val.length;
                while (n--) {
                    ret[n] = val[n];
                }
            }
        }
        return ret;
    }
    module.exports = toArray;


},{"./GLOBAL":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/GLOBAL.js","./kindOf":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toNumber.js":[function(require,module,exports){
var isArray = require('./isArray');

    /**
     * covert value into number if numeric
     */
    function toNumber(val){
        // numberic values should come first because of -0
        if (typeof val === 'number') return val;
        // we want all falsy values (besides -0) to return zero to avoid
        // headaches
        if (!val) return 0;
        if (typeof val === 'string') return parseFloat(val);
        // arrays are edge cases. `Number([4]) === 4`
        if (isArray(val)) return NaN;
        return Number(val);
    }

    module.exports = toNumber;



},{"./isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js":[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'ceil' : require('./math/ceil'),
    'clamp' : require('./math/clamp'),
    'countSteps' : require('./math/countSteps'),
    'floor' : require('./math/floor'),
    'inRange' : require('./math/inRange'),
    'isNear' : require('./math/isNear'),
    'lerp' : require('./math/lerp'),
    'loop' : require('./math/loop'),
    'map' : require('./math/map'),
    'norm' : require('./math/norm'),
    'round' : require('./math/round')
};



},{"./math/ceil":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/ceil.js","./math/clamp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/clamp.js","./math/countSteps":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/countSteps.js","./math/floor":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/floor.js","./math/inRange":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/inRange.js","./math/isNear":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/isNear.js","./math/lerp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/lerp.js","./math/loop":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/loop.js","./math/map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/map.js","./math/norm":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/norm.js","./math/round":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/round.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/ceil.js":[function(require,module,exports){

    /**
     * Round value up with a custom radix.
     */
    function ceil(val, step){
        step = Math.abs(step || 1);
        return Math.ceil(val / step) * step;
    }

    module.exports = ceil;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/clamp.js":[function(require,module,exports){

    /**
     * Clamps value inside range.
     */
    function clamp(val, min, max){
        return val < min? min : (val > max? max : val);
    }
    module.exports = clamp;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/countSteps.js":[function(require,module,exports){

    /**
    * Count number of full steps.
    */
    function countSteps(val, step, overflow){
        val = Math.floor(val / step);

        if (overflow) {
            return val % overflow;
        }

        return val;
    }

    module.exports = countSteps;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/floor.js":[function(require,module,exports){

    /**
    * Floor value to full steps.
    */
    function floor(val, step){
        step = Math.abs(step || 1);
        return Math.floor(val / step) * step;
    }
    module.exports = floor;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/inRange.js":[function(require,module,exports){

    /**
    * Checks if value is inside the range.
    */
    function inRange(val, min, max, threshold){
        threshold = threshold || 0;
        return (val + threshold >= min && val - threshold <= max);
    }

    module.exports = inRange;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/isNear.js":[function(require,module,exports){

    /**
    * Check if value is close to target.
    */
    function isNear(val, target, threshold){
        return (Math.abs(val - target) <= threshold);
    }
    module.exports = isNear;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/lerp.js":[function(require,module,exports){

    /**
    * Linear interpolation.
    * IMPORTANT:will return `Infinity` if numbers overflow Number.MAX_VALUE
    */
    function lerp(ratio, start, end){
        return start + (end - start) * ratio;
    }

    module.exports = lerp;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/loop.js":[function(require,module,exports){

    /**
    * Loops value inside range.
    */
    function loop(val, min, max){
        return val < min? max : (val > max? min : val);
    }

    module.exports = loop;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/map.js":[function(require,module,exports){
var lerp = require('./lerp');
var norm = require('./norm');
    /**
    * Maps a number from one scale to another.
    * @example map(3, 0, 4, -1, 1) -> 0.5
    */
    function map(val, min1, max1, min2, max2){
        return lerp( norm(val, min1, max1), min2, max2 );
    }
    module.exports = map;


},{"./lerp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/lerp.js","./norm":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/norm.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/norm.js":[function(require,module,exports){

    /**
    * Gets normalized ratio of value inside range.
    */
    function norm(val, min, max){
        if (val < min || val > max) {
            throw new RangeError('value (' + val + ') must be between ' + min + ' and ' + max);
        }

        return val === max ? 1 : (val - min) / (max - min);
    }
    module.exports = norm;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/round.js":[function(require,module,exports){

    /**
     * Round number to a specific radix
     */
    function round(value, radix){
        radix = radix || 1; // default round 1
        return Math.round(value / radix) * radix;
    }

    module.exports = round;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'MAX_INT' : require('./number/MAX_INT'),
    'MAX_SAFE_INTEGER' : require('./number/MAX_SAFE_INTEGER'),
    'MAX_UINT' : require('./number/MAX_UINT'),
    'MIN_INT' : require('./number/MIN_INT'),
    'abbreviate' : require('./number/abbreviate'),
    'currencyFormat' : require('./number/currencyFormat'),
    'enforcePrecision' : require('./number/enforcePrecision'),
    'isNaN' : require('./number/isNaN'),
    'nth' : require('./number/nth'),
    'ordinal' : require('./number/ordinal'),
    'pad' : require('./number/pad'),
    'rol' : require('./number/rol'),
    'ror' : require('./number/ror'),
    'sign' : require('./number/sign'),
    'toInt' : require('./number/toInt'),
    'toUInt' : require('./number/toUInt'),
    'toUInt31' : require('./number/toUInt31')
};



},{"./number/MAX_INT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_INT.js","./number/MAX_SAFE_INTEGER":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_SAFE_INTEGER.js","./number/MAX_UINT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_UINT.js","./number/MIN_INT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MIN_INT.js","./number/abbreviate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/abbreviate.js","./number/currencyFormat":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/currencyFormat.js","./number/enforcePrecision":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/enforcePrecision.js","./number/isNaN":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/isNaN.js","./number/nth":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/nth.js","./number/ordinal":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/ordinal.js","./number/pad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/pad.js","./number/rol":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/rol.js","./number/ror":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/ror.js","./number/sign":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/sign.js","./number/toInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toInt.js","./number/toUInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toUInt.js","./number/toUInt31":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toUInt31.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_INT.js":[function(require,module,exports){
/**
 * @constant Maximum 32-bit signed integer value. (2^31 - 1)
 */

    module.exports = 2147483647;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_SAFE_INTEGER.js":[function(require,module,exports){


    // maximum safe integer (Math.pow(2, 53) - 1)
    // see: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer
    module.exports = 9007199254740991;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_UINT.js":[function(require,module,exports){
/**
 * @constant Maximum 32-bit unsigned integet value (2^32 - 1)
 */

    module.exports = 4294967295;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MIN_INT.js":[function(require,module,exports){
/**
 * @constant Minimum 32-bit signed integer value (-2^31).
 */

    module.exports = -2147483648;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/abbreviate.js":[function(require,module,exports){
var enforcePrecision = require('./enforcePrecision');

    var _defaultDict = {
        thousand : 'K',
        million : 'M',
        billion : 'B'
    };

    /**
     * Abbreviate number if bigger than 1000. (eg: 2.5K, 17.5M, 3.4B, ...)
     */
    function abbreviateNumber(val, nDecimals, dict){
        nDecimals = nDecimals != null? nDecimals : 1;
        dict = dict || _defaultDict;
        val = enforcePrecision(val, nDecimals);

        var str, mod;

        if (val < 1000000) {
            mod = enforcePrecision(val / 1000, nDecimals);
            // might overflow to next scale during rounding
            str = mod < 1000? mod + dict.thousand : 1 + dict.million;
        } else if (val < 1000000000) {
            mod = enforcePrecision(val / 1000000, nDecimals);
            str = mod < 1000? mod + dict.million : 1 + dict.billion;
        } else {
            str = enforcePrecision(val / 1000000000, nDecimals) + dict.billion;
        }

        return str;
    }

    module.exports = abbreviateNumber;



},{"./enforcePrecision":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/enforcePrecision.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/currencyFormat.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');

    /**
     * Converts number into currency format
     */
    function currencyFormat(val, nDecimalDigits, decimalSeparator, thousandsSeparator) {
        val = toNumber(val);
        nDecimalDigits = nDecimalDigits == null? 2 : nDecimalDigits;
        decimalSeparator = decimalSeparator == null? '.' : decimalSeparator;
        thousandsSeparator = thousandsSeparator == null? ',' : thousandsSeparator;

        //can't use enforce precision since it returns a number and we are
        //doing a RegExp over the string
        var fixed = val.toFixed(nDecimalDigits),
            //separate begin [$1], middle [$2] and decimal digits [$4]
            parts = new RegExp('^(-?\\d{1,3})((?:\\d{3})+)(\\.(\\d{'+ nDecimalDigits +'}))?$').exec( fixed );

        if(parts){ //val >= 1000 || val <= -1000
            return parts[1] + parts[2].replace(/\d{3}/g, thousandsSeparator + '$&') + (parts[4] ? decimalSeparator + parts[4] : '');
        }else{
            return fixed.replace('.', decimalSeparator);
        }
    }

    module.exports = currencyFormat;



},{"../lang/toNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/enforcePrecision.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');
    /**
     * Enforce a specific amount of decimal digits and also fix floating
     * point rounding issues.
     */
    function enforcePrecision(val, nDecimalDigits){
        val = toNumber(val);
        var pow = Math.pow(10, nDecimalDigits);
        return +(Math.round(val * pow) / pow).toFixed(nDecimalDigits);
    }
    module.exports = enforcePrecision;


},{"../lang/toNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/isNaN.js":[function(require,module,exports){


    /**
     * ES6 Number.isNaN
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
     */
    function isNaN(val){
        // jshint eqeqeq:false
        return typeof val === 'number' && val != val;
    }

    module.exports = isNaN;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/nth.js":[function(require,module,exports){


    /**
     * Returns "nth" of number (1 = "st", 2 = "nd", 3 = "rd", 4..10 = "th", ...)
     */
    function nth(i) {
        var t = (i % 100);
        if (t >= 10 && t <= 20) {
            return 'th';
        }
        switch(i % 10) {
            case 1:
                return 'st';
            case 2:
                return 'nd';
            case 3:
                return 'rd';
            default:
                return 'th';
        }
    }

    module.exports = nth;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/ordinal.js":[function(require,module,exports){
var toInt = require('./toInt');
var nth = require('./nth');

    /**
     * converts number into ordinal form (1st, 2nd, 3rd, 4th, ...)
     */
    function ordinal(n){
       n = toInt(n);
       return n + nth(n);
    }

    module.exports = ordinal;



},{"./nth":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/nth.js","./toInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toInt.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/pad.js":[function(require,module,exports){
var lpad = require('../string/lpad');
var toNumber = require('../lang/toNumber');

    /**
     * Add padding zeros if n.length < minLength.
     */
    function pad(n, minLength, char){
        n = toNumber(n);
        return lpad(''+ n, minLength, char || '0');
    }

    module.exports = pad;



},{"../lang/toNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toNumber.js","../string/lpad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lpad.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/rol.js":[function(require,module,exports){

    /**
     * Bitwise circular shift left
     * http://en.wikipedia.org/wiki/Circular_shift
     */
    function rol(val, shift){
        return (val << shift) | (val >> (32 - shift));
    }
    module.exports = rol;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/ror.js":[function(require,module,exports){

    /**
     * Bitwise circular shift right
     * http://en.wikipedia.org/wiki/Circular_shift
     */
    function ror(val, shift){
        return (val >> shift) | (val << (32 - shift));
    }
    module.exports = ror;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/sign.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');

    /**
     * Get sign of the value.
     */
    function sign(val) {
        var num = toNumber(val);
        if (num === 0) return num; // +0 and +0 === 0
        if (isNaN(num)) return num; // NaN
        return num < 0? -1 : 1;
    }

    module.exports = sign;



},{"../lang/toNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toInt.js":[function(require,module,exports){


    /**
     * "Convert" value into an 32-bit integer.
     * Works like `Math.floor` if val > 0 and `Math.ceil` if val < 0.
     * IMPORTANT: val will wrap at 2^31 and -2^31.
     * Perf tests: http://jsperf.com/vs-vs-parseint-bitwise-operators/7
     */
    function toInt(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return ~~val;
    }

    module.exports = toInt;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toUInt.js":[function(require,module,exports){


    /**
     * "Convert" value into a 32-bit unsigned integer.
     * IMPORTANT: Value will wrap at 2^32.
     */
    function toUInt(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return val >>> 0;
    }

    module.exports = toUInt;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toUInt31.js":[function(require,module,exports){
var MAX_INT = require('./MAX_INT');

    /**
     * "Convert" value into an 31-bit unsigned integer (since 1 bit is used for sign).
     * IMPORTANT: value wil wrap at 2^31, if negative will return 0.
     */
    function toUInt31(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return (val <= 0)? 0 : (val > MAX_INT? ~~(val % (MAX_INT + 1)) : ~~val);
    }

    module.exports = toUInt31;



},{"./MAX_INT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_INT.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'bindAll' : require('./object/bindAll'),
    'contains' : require('./object/contains'),
    'deepFillIn' : require('./object/deepFillIn'),
    'deepMatches' : require('./object/deepMatches'),
    'deepMixIn' : require('./object/deepMixIn'),
    'equals' : require('./object/equals'),
    'every' : require('./object/every'),
    'fillIn' : require('./object/fillIn'),
    'filter' : require('./object/filter'),
    'find' : require('./object/find'),
    'forIn' : require('./object/forIn'),
    'forOwn' : require('./object/forOwn'),
    'functions' : require('./object/functions'),
    'get' : require('./object/get'),
    'has' : require('./object/has'),
    'hasOwn' : require('./object/hasOwn'),
    'keys' : require('./object/keys'),
    'map' : require('./object/map'),
    'matches' : require('./object/matches'),
    'max' : require('./object/max'),
    'merge' : require('./object/merge'),
    'min' : require('./object/min'),
    'mixIn' : require('./object/mixIn'),
    'namespace' : require('./object/namespace'),
    'omit' : require('./object/omit'),
    'pick' : require('./object/pick'),
    'pluck' : require('./object/pluck'),
    'reduce' : require('./object/reduce'),
    'reject' : require('./object/reject'),
    'result' : require('./object/result'),
    'set' : require('./object/set'),
    'size' : require('./object/size'),
    'some' : require('./object/some'),
    'unset' : require('./object/unset'),
    'values' : require('./object/values')
};



},{"./object/bindAll":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/bindAll.js","./object/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/contains.js","./object/deepFillIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/deepFillIn.js","./object/deepMatches":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/deepMatches.js","./object/deepMixIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/deepMixIn.js","./object/equals":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/equals.js","./object/every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/every.js","./object/fillIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/fillIn.js","./object/filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/filter.js","./object/find":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/find.js","./object/forIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forIn.js","./object/forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js","./object/functions":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/functions.js","./object/get":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/get.js","./object/has":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/has.js","./object/hasOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/hasOwn.js","./object/keys":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/keys.js","./object/map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/map.js","./object/matches":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/matches.js","./object/max":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/max.js","./object/merge":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/merge.js","./object/min":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/min.js","./object/mixIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/mixIn.js","./object/namespace":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/namespace.js","./object/omit":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/omit.js","./object/pick":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/pick.js","./object/pluck":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/pluck.js","./object/reduce":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/reduce.js","./object/reject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/reject.js","./object/result":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/result.js","./object/set":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/set.js","./object/size":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/size.js","./object/some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/some.js","./object/unset":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/unset.js","./object/values":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/values.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/bindAll.js":[function(require,module,exports){
var functions = require('./functions');
var bind = require('../function/bind');
var forEach = require('../array/forEach');
var slice = require('../array/slice');

    /**
     * Binds methods of the object to be run in it's own context.
     */
    function bindAll(obj, rest_methodNames){
        var keys = arguments.length > 1?
                    slice(arguments, 1) : functions(obj);
        forEach(keys, function(key){
            obj[key] = bind(obj[key], obj);
        });
    }

    module.exports = bindAll;



},{"../array/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js","../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js","../function/bind":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/bind.js","./functions":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/functions.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/contains.js":[function(require,module,exports){
var some = require('./some');

    /**
     * Check if object contains value
     */
    function contains(obj, needle) {
        return some(obj, function(val) {
            return (val === needle);
        });
    }
    module.exports = contains;



},{"./some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/some.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/deepFillIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPlainObject.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/deepMatches.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/deepMixIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPlainObject.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/equals.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/is.js","../lang/isObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isObject.js","./every":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/every.js","./hasOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/every.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/fillIn.js":[function(require,module,exports){
var forEach = require('../array/forEach');
var slice = require('../array/slice');
var forOwn = require('./forOwn');

    /**
     * Copy missing properties in the obj from the defaults.
     */
    function fillIn(obj, var_defaults){
        forEach(slice(arguments, 1), function(base){
            forOwn(base, function(val, key){
                if (obj[key] == null) {
                    obj[key] = val;
                }
            });
        });
        return obj;
    }

    module.exports = fillIn;



},{"../array/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js","../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/filter.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Creates a new object with all the properties where the callback returns
     * true.
     */
    function filterValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(value, key, obj) {
            if (callback(value, key, obj)) {
                output[key] = value;
            }
        });

        return output;
    }
    module.exports = filterValues;


},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/find.js":[function(require,module,exports){
var some = require('./some');
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns first item that matches criteria
     */
    function find(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result;
        some(obj, function(value, key, obj) {
            if (callback(value, key, obj)) {
                result = value;
                return true; //break
            }
        });
        return result;
    }

    module.exports = find;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./some":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/some.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forIn.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forIn.js","./hasOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/functions.js":[function(require,module,exports){
var forIn = require('./forIn');

    /**
     * return a list of all enumerable properties that have function values
     */
    function functions(obj){
        var keys = [];
        forIn(obj, function(val, key){
            if (typeof val === 'function'){
                keys.push(key);
            }
        });
        return keys.sort();
    }

    module.exports = functions;



},{"./forIn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forIn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/get.js":[function(require,module,exports){
var isPrimitive = require('../lang/isPrimitive');

    /**
     * get "nested" object property
     */
    function get(obj, prop){
        var parts = prop.split('.'),
            last = parts.pop();

        while (prop = parts.shift()) {
            obj = obj[prop];
            if (obj == null) return;
        }

        return obj[last];
    }

    module.exports = get;



},{"../lang/isPrimitive":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isPrimitive.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/has.js":[function(require,module,exports){
var get = require('./get');

    var UNDEF;

    /**
     * Check if object has nested property.
     */
    function has(obj, prop){
        return get(obj, prop) !== UNDEF;
    }

    module.exports = has;




},{"./get":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/get.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/hasOwn.js":[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/keys.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/map.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Creates a new object where all the values are the result of calling
     * `callback`.
     */
    function mapValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(val, key, obj) {
            output[key] = callback(val, key, obj);
        });

        return output;
    }
    module.exports = mapValues;


},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/matches.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * checks if a object contains all given properties/values
     */
    function matches(target, props){
        // can't use "object/every" because of circular dependency
        var result = true;
        forOwn(props, function(val, key){
            if (target[key] !== val) {
                // break loop at first difference
                return (result = false);
            }
        });
        return result;
    }

    module.exports = matches;



},{"./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/max.js":[function(require,module,exports){
var arrMax = require('../array/max');
var values = require('./values');

    /**
     * Returns maximum value inside object.
     */
    function max(obj, compareFn) {
        return arrMax(values(obj), compareFn);
    }

    module.exports = max;


},{"../array/max":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/max.js","./values":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/values.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/merge.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/deepClone.js","../lang/isObject":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isObject.js","./hasOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/min.js":[function(require,module,exports){
var arrMin = require('../array/min');
var values = require('./values');

    /**
     * Returns minimum value inside object.
     */
    function min(obj, iterator) {
        return arrMin(values(obj), iterator);
    }

    module.exports = min;


},{"../array/min":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/min.js","./values":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/values.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/mixIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/namespace.js":[function(require,module,exports){
var forEach = require('../array/forEach');

    /**
     * Create nested object if non-existent
     */
    function namespace(obj, path){
        if (!path) return obj;
        forEach(path.split('.'), function(key){
            if (!obj[key]) {
                obj[key] = {};
            }
            obj = obj[key];
        });
        return obj;
    }

    module.exports = namespace;



},{"../array/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/omit.js":[function(require,module,exports){
var slice = require('../array/slice');
var contains = require('../array/contains');

    /**
     * Return a copy of the object, filtered to only contain properties except the blacklisted keys.
     */
    function omit(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {};

        for (var property in obj) {
            if (obj.hasOwnProperty(property) && !contains(keys, property)) {
                out[property] = obj[property];
            }
        }
        return out;
    }

    module.exports = omit;



},{"../array/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/contains.js","../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/pick.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/pluck.js":[function(require,module,exports){
var map = require('./map');
var prop = require('../function/prop');

    /**
     * Extract a list of property values.
     */
    function pluck(obj, propName){
        return map(obj, prop(propName));
    }

    module.exports = pluck;



},{"../function/prop":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/prop.js","./map":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/map.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/reduce.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var size = require('./size');

    /**
     * Object reduce
     */
    function reduce(obj, callback, memo, thisObj) {
        var initial = arguments.length > 2;

        if (!size(obj) && !initial) {
            throw new Error('reduce of empty object with no initial value');
        }

        forOwn(obj, function(value, key, list) {
            if (!initial) {
                memo = value;
                initial = true;
            }
            else {
                memo = callback.call(thisObj, memo, value, key, list);
            }
        });

        return memo;
    }

    module.exports = reduce;



},{"./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js","./size":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/size.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/reject.js":[function(require,module,exports){
var filter = require('./filter');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object reject
     */
    function reject(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        return filter(obj, function(value, index, obj) {
            return !callback(value, index, obj);
        }, thisObj);
    }

    module.exports = reject;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./filter":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/filter.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/result.js":[function(require,module,exports){
var isFunction = require('../lang/isFunction');

    function result(obj, prop) {
        var property = obj[prop];

        if(property === undefined) {
            return;
        }

        return isFunction(property) ? property.call(obj) : property;
    }

    module.exports = result;


},{"../lang/isFunction":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isFunction.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/set.js":[function(require,module,exports){
var namespace = require('./namespace');

    /**
     * set "nested" object property
     */
    function set(obj, prop, val){
        var parts = (/^(.+)\.(.+)$/).exec(prop);
        if (parts){
            namespace(obj, parts[1])[parts[2]] = val;
        } else {
            obj[prop] = val;
        }
    }

    module.exports = set;



},{"./namespace":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/namespace.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/size.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object size
     */
    function size(obj) {
        var count = 0;
        forOwn(obj, function(){
            count++;
        });
        return count;
    }

    module.exports = size;



},{"./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/some.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object some
     */
    function some(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        forOwn(obj, function(val, key) {
            if (callback(val, key, obj)) {
                result = true;
                return false; // break
            }
        });
        return result;
    }

    module.exports = some;



},{"../function/makeIterator_":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/unset.js":[function(require,module,exports){
var has = require('./has');

    /**
     * Unset object property.
     */
    function unset(obj, prop){
        if (has(obj, prop)) {
            var parts = prop.split('.'),
                last = parts.pop();
            while (prop = parts.shift()) {
                obj = obj[prop];
            }
            return (delete obj[last]);

        } else {
            // if property doesn't exist treat as deleted
            return true;
        }
    }

    module.exports = unset;



},{"./has":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/has.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/values.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'contains' : require('./queryString/contains'),
    'decode' : require('./queryString/decode'),
    'encode' : require('./queryString/encode'),
    'getParam' : require('./queryString/getParam'),
    'getQuery' : require('./queryString/getQuery'),
    'parse' : require('./queryString/parse'),
    'setParam' : require('./queryString/setParam')
};



},{"./queryString/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/contains.js","./queryString/decode":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/decode.js","./queryString/encode":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/encode.js","./queryString/getParam":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/getParam.js","./queryString/getQuery":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/getQuery.js","./queryString/parse":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/parse.js","./queryString/setParam":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/setParam.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/contains.js":[function(require,module,exports){
var getQuery = require('./getQuery');

    /**
     * Checks if query string contains parameter.
     */
    function contains(url, paramName) {
        var regex = new RegExp('(\\?|&)'+ paramName +'=', 'g'); //matches `?param=` or `&param=`
        return regex.test(getQuery(url));
    }

    module.exports = contains;


},{"./getQuery":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/decode.js":[function(require,module,exports){
var typecast = require('../string/typecast');
var isString = require('../lang/isString');
var isArray = require('../lang/isArray');
var hasOwn = require('../object/hasOwn');

    /**
     * Decode query string into an object of keys => vals.
     */
    function decode(queryStr, shouldTypecast) {
        var queryArr = (queryStr || '').replace('?', '').split('&'),
            count = -1,
            length = queryArr.length,
            obj = {},
            item, pValue, pName, toSet;

        while (++count < length) {
            item = queryArr[count].split('=');
            pName = item[0];
            if (!pName || !pName.length){
                continue;
            }
            pValue = shouldTypecast === false ? item[1] : typecast(item[1]);
            toSet = isString(pValue) ? decodeURIComponent(pValue) : pValue;
            if (hasOwn(obj,pName)){
                if(isArray(obj[pName])){
                    obj[pName].push(toSet);
                } else {
                    obj[pName] = [obj[pName],toSet];
                }
            } else {
                obj[pName] = toSet;
           }
        }
        return obj;
    }

    module.exports = decode;


},{"../lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","../lang/isString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isString.js","../object/hasOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/hasOwn.js","../string/typecast":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/typecast.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/encode.js":[function(require,module,exports){
var forOwn = require('../object/forOwn');
var isArray = require('../lang/isArray');
var forEach = require('../array/forEach');

    /**
     * Encode object into a query string.
     */
    function encode(obj){
        var query = [],
            arrValues, reg;
        forOwn(obj, function (val, key) {
            if (isArray(val)) {
                arrValues = key + '=';
                reg = new RegExp('&'+key+'+=$');
                forEach(val, function (aValue) {
                    arrValues += encodeURIComponent(aValue) + '&' + key + '=';
                });
                query.push(arrValues.replace(reg, ''));
            } else {
               query.push(key + '=' + encodeURIComponent(val));
            }
        });
        return (query.length) ? '?' + query.join('&') : '';
    }

    module.exports = encode;


},{"../array/forEach":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/forEach.js","../lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","../object/forOwn":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/getParam.js":[function(require,module,exports){
var typecast = require('../string/typecast');
var getQuery = require('./getQuery');

    /**
     * Get query parameter value.
     */
    function getParam(url, param, shouldTypecast){
        var regexp = new RegExp('(\\?|&)'+ param + '=([^&]*)'), //matches `?param=value` or `&param=value`, value = $2
            result = regexp.exec( getQuery(url) ),
            val = (result && result[2])? result[2] : null;
        return shouldTypecast === false? val : typecast(val);
    }

    module.exports = getParam;


},{"../string/typecast":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/typecast.js","./getQuery":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/getQuery.js":[function(require,module,exports){


    /**
     * Gets full query as string with all special chars decoded.
     */
    function getQuery(url) {
        url = url.replace(/#.*/, ''); //removes hash (to avoid getting hash query)
        var queryString = /\?[a-zA-Z0-9\=\&\%\$\-\_\.\+\!\*\'\(\)\,]+/.exec(url); //valid chars according to: http://www.ietf.org/rfc/rfc1738.txt
        return (queryString)? decodeURIComponent(queryString[0]) : '';
    }

    module.exports = getQuery;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/parse.js":[function(require,module,exports){
var decode = require('./decode');
var getQuery = require('./getQuery');

    /**
     * Get query string, parses and decodes it.
     */
    function parse(url, shouldTypecast) {
        return decode(getQuery(url), shouldTypecast);
    }

    module.exports = parse;



},{"./decode":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/decode.js","./getQuery":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/queryString/setParam.js":[function(require,module,exports){


    /**
     * Set query string parameter value
     */
    function setParam(url, paramName, value){
        url = url || '';

        var re = new RegExp('(\\?|&)'+ paramName +'=[^&]*' );
        var param = paramName +'='+ encodeURIComponent( value );

        if ( re.test(url) ) {
            return url.replace(re, '$1'+ param);
        } else {
            if (url.indexOf('?') === -1) {
                url += '?';
            }
            if (url.indexOf('=') !== -1) {
                url += '&';
            }
            return url + param;
        }

    }

    module.exports = setParam;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'choice' : require('./random/choice'),
    'guid' : require('./random/guid'),
    'rand' : require('./random/rand'),
    'randBit' : require('./random/randBit'),
    'randBool' : require('./random/randBool'),
    'randHex' : require('./random/randHex'),
    'randInt' : require('./random/randInt'),
    'randSign' : require('./random/randSign'),
    'randString' : require('./random/randString'),
    'random' : require('./random/random')
};



},{"./random/choice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/choice.js","./random/guid":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/guid.js","./random/rand":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/rand.js","./random/randBit":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randBit.js","./random/randBool":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randBool.js","./random/randHex":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randHex.js","./random/randInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randInt.js","./random/randSign":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randSign.js","./random/randString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randString.js","./random/random":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/random.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/choice.js":[function(require,module,exports){
var randInt = require('./randInt');
var isArray = require('../lang/isArray');

    /**
     * Returns a random element from the supplied arguments
     * or from the array (if single argument is an array).
     */
    function choice(items) {
        var target = (arguments.length === 1 && isArray(items))? items : arguments;
        return target[ randInt(0, target.length - 1) ];
    }

    module.exports = choice;



},{"../lang/isArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isArray.js","./randInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randInt.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/guid.js":[function(require,module,exports){
var randHex = require('./randHex');
var choice = require('./choice');

  /**
   * Returns pseudo-random guid (UUID v4)
   * IMPORTANT: it's not totally "safe" since randHex/choice uses Math.random
   * by default and sequences can be predicted in some cases. See the
   * "random/random" documentation for more info about it and how to replace
   * the default PRNG.
   */
  function guid() {
    return (
        randHex(8)+'-'+
        randHex(4)+'-'+
        // v4 UUID always contain "4" at this position to specify it was
        // randomly generated
        '4' + randHex(3) +'-'+
        // v4 UUID always contain chars [a,b,8,9] at this position
        choice(8, 9, 'a', 'b') + randHex(3)+'-'+
        randHex(12)
    );
  }
  module.exports = guid;


},{"./choice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/choice.js","./randHex":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randHex.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/rand.js":[function(require,module,exports){
var random = require('./random');
var MIN_INT = require('../number/MIN_INT');
var MAX_INT = require('../number/MAX_INT');

    /**
     * Returns random number inside range
     */
    function rand(min, max){
        min = min == null? MIN_INT : min;
        max = max == null? MAX_INT : max;
        return min + (max - min) * random();
    }

    module.exports = rand;


},{"../number/MAX_INT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_INT.js","../number/MIN_INT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MIN_INT.js","./random":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/random.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randBit.js":[function(require,module,exports){
var randBool = require('./randBool');

    /**
     * Returns random bit (0 or 1)
     */
    function randomBit() {
        return randBool()? 1 : 0;
    }

    module.exports = randomBit;


},{"./randBool":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randBool.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randBool.js":[function(require,module,exports){
var random = require('./random');

    /**
     * returns a random boolean value (true or false)
     */
    function randBool(){
        return random() >= 0.5;
    }

    module.exports = randBool;



},{"./random":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/random.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randHex.js":[function(require,module,exports){
var choice = require('./choice');

    var _chars = '0123456789abcdef'.split('');

    /**
     * Returns a random hexadecimal string
     */
    function randHex(size){
        size = size && size > 0? size : 6;
        var str = '';
        while (size--) {
            str += choice(_chars);
        }
        return str;
    }

    module.exports = randHex;



},{"./choice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/choice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randInt.js":[function(require,module,exports){
var MIN_INT = require('../number/MIN_INT');
var MAX_INT = require('../number/MAX_INT');
var rand = require('./rand');

    /**
     * Gets random integer inside range or snap to min/max values.
     */
    function randInt(min, max){
        min = min == null? MIN_INT : ~~min;
        max = max == null? MAX_INT : ~~max;
        // can't be max + 0.5 otherwise it will round up if `rand`
        // returns `max` causing it to overflow range.
        // -0.5 and + 0.49 are required to avoid bias caused by rounding
        return Math.round( rand(min - 0.5, max + 0.499999999999) );
    }

    module.exports = randInt;


},{"../number/MAX_INT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MAX_INT.js","../number/MIN_INT":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/MIN_INT.js","./rand":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/rand.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randSign.js":[function(require,module,exports){
var randBool = require('./randBool');

    /**
     * Returns random sign (-1 or 1)
     */
    function randomSign() {
        return randBool()? 1 : -1;
    }

    module.exports = randomSign;


},{"./randBool":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randBool.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randString.js":[function(require,module,exports){
var isNumber = require('../lang/isNumber');
var isString = require('../lang/isString');
var randInt = require('./randInt');

    var defaultDictionary = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    function randomString(length, dictionary) {
        if(!isNumber(length) || length <= 0) {
          length = 8;
        }

        if(!isString(dictionary) || dictionary.length < 1) {
          dictionary = defaultDictionary;
        }

        var result = '',
            domain = dictionary.length - 1;

        while(length--) {
          result += dictionary[randInt(0, domain)];
        }
        
        return result;
    }

    module.exports = randomString;


},{"../lang/isNumber":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isNumber.js","../lang/isString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/isString.js","./randInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/randInt.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/random/random.js":[function(require,module,exports){


    /**
     * Just a wrapper to Math.random. No methods inside mout/random should call
     * Math.random() directly so we can inject the pseudo-random number
     * generator if needed (ie. in case we need a seeded random or a better
     * algorithm than the native one)
     */
    function random(){
        return random.get();
    }

    // we expose the method so it can be swapped if needed
    random.get = Math.random;

    module.exports = random;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'WHITE_SPACES' : require('./string/WHITE_SPACES'),
    'camelCase' : require('./string/camelCase'),
    'contains' : require('./string/contains'),
    'crop' : require('./string/crop'),
    'endsWith' : require('./string/endsWith'),
    'escapeHtml' : require('./string/escapeHtml'),
    'escapeRegExp' : require('./string/escapeRegExp'),
    'escapeUnicode' : require('./string/escapeUnicode'),
    'hyphenate' : require('./string/hyphenate'),
    'insert' : require('./string/insert'),
    'interpolate' : require('./string/interpolate'),
    'lowerCase' : require('./string/lowerCase'),
    'lpad' : require('./string/lpad'),
    'ltrim' : require('./string/ltrim'),
    'makePath' : require('./string/makePath'),
    'normalizeLineBreaks' : require('./string/normalizeLineBreaks'),
    'pascalCase' : require('./string/pascalCase'),
    'properCase' : require('./string/properCase'),
    'removeNonASCII' : require('./string/removeNonASCII'),
    'removeNonWord' : require('./string/removeNonWord'),
    'repeat' : require('./string/repeat'),
    'replace' : require('./string/replace'),
    'replaceAccents' : require('./string/replaceAccents'),
    'rpad' : require('./string/rpad'),
    'rtrim' : require('./string/rtrim'),
    'sentenceCase' : require('./string/sentenceCase'),
    'slugify' : require('./string/slugify'),
    'startsWith' : require('./string/startsWith'),
    'stripHtmlTags' : require('./string/stripHtmlTags'),
    'trim' : require('./string/trim'),
    'truncate' : require('./string/truncate'),
    'typecast' : require('./string/typecast'),
    'unCamelCase' : require('./string/unCamelCase'),
    'underscore' : require('./string/underscore'),
    'unescapeHtml' : require('./string/unescapeHtml'),
    'unescapeUnicode' : require('./string/unescapeUnicode'),
    'unhyphenate' : require('./string/unhyphenate'),
    'upperCase' : require('./string/upperCase')
};



},{"./string/WHITE_SPACES":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/WHITE_SPACES.js","./string/camelCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/camelCase.js","./string/contains":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/contains.js","./string/crop":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/crop.js","./string/endsWith":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/endsWith.js","./string/escapeHtml":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/escapeHtml.js","./string/escapeRegExp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/escapeRegExp.js","./string/escapeUnicode":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/escapeUnicode.js","./string/hyphenate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/hyphenate.js","./string/insert":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/insert.js","./string/interpolate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/interpolate.js","./string/lowerCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lowerCase.js","./string/lpad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lpad.js","./string/ltrim":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/ltrim.js","./string/makePath":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/makePath.js","./string/normalizeLineBreaks":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/normalizeLineBreaks.js","./string/pascalCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/pascalCase.js","./string/properCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/properCase.js","./string/removeNonASCII":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/removeNonASCII.js","./string/removeNonWord":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/removeNonWord.js","./string/repeat":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/repeat.js","./string/replace":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/replace.js","./string/replaceAccents":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/replaceAccents.js","./string/rpad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/rpad.js","./string/rtrim":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/rtrim.js","./string/sentenceCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/sentenceCase.js","./string/slugify":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/slugify.js","./string/startsWith":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/startsWith.js","./string/stripHtmlTags":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/stripHtmlTags.js","./string/trim":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/trim.js","./string/truncate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/truncate.js","./string/typecast":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/typecast.js","./string/unCamelCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unCamelCase.js","./string/underscore":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/underscore.js","./string/unescapeHtml":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unescapeHtml.js","./string/unescapeUnicode":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unescapeUnicode.js","./string/unhyphenate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unhyphenate.js","./string/upperCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/WHITE_SPACES.js":[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/camelCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var replaceAccents = require('./replaceAccents');
var removeNonWord = require('./removeNonWord');
var upperCase = require('./upperCase');
var lowerCase = require('./lowerCase');
    /**
    * Convert string to camelCase text.
    */
    function camelCase(str){
        str = toString(str);
        str = replaceAccents(str);
        str = removeNonWord(str)
            .replace(/[\-_]/g, ' ') //convert all hyphens and underscores to spaces
            .replace(/\s[a-z]/g, upperCase) //convert first char of each word to UPPERCASE
            .replace(/\s+/g, '') //remove spaces
            .replace(/^[A-Z]/g, lowerCase); //convert first char to lowercase
        return str;
    }
    module.exports = camelCase;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lowerCase.js","./removeNonWord":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/removeNonWord.js","./replaceAccents":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/replaceAccents.js","./upperCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/contains.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Searches for a given substring
     */
    function contains(str, substring, fromIndex){
        str = toString(str);
        substring = toString(substring);
        return str.indexOf(substring, fromIndex) !== -1;
    }

    module.exports = contains;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/crop.js":[function(require,module,exports){
var toString = require('../lang/toString');
var truncate = require('./truncate');
    /**
     * Truncate string at full words.
     */
     function crop(str, maxChars, append) {
         str = toString(str);
         return truncate(str, maxChars, append, true);
     }

     module.exports = crop;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./truncate":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/truncate.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/endsWith.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Checks if string ends with specified suffix.
     */
    function endsWith(str, suffix) {
        str = toString(str);
        suffix = toString(suffix);

        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    module.exports = endsWith;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/escapeHtml.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escapes a string for insertion into HTML.
     */
    function escapeHtml(str){
        str = toString(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;');
        return str;
    }

    module.exports = escapeHtml;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/escapeRegExp.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/escapeUnicode.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape string into unicode sequences
     */
    function escapeUnicode(str, shouldEscapePrintable){
        str = toString(str);
        return str.replace(/[\s\S]/g, function(ch){
            // skip printable ASCII chars if we should not escape them
            if (!shouldEscapePrintable && (/[\x20-\x7E]/).test(ch)) {
                return ch;
            }
            // we use "000" and slice(-4) for brevity, need to pad zeros,
            // unicode escape always have 4 chars after "\u"
            return '\\u'+ ('000'+ ch.charCodeAt(0).toString(16)).slice(-4);
        });
    }

    module.exports = escapeUnicode;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/hyphenate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var slugify = require('./slugify');
var unCamelCase = require('./unCamelCase');
    /**
     * Replaces spaces with hyphens, split camelCase text, remove non-word chars, remove accents and convert to lower case.
     */
    function hyphenate(str){
        str = toString(str);
        str = unCamelCase(str);
        return slugify(str, "-");
    }

    module.exports = hyphenate;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./slugify":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/slugify.js","./unCamelCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unCamelCase.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/insert.js":[function(require,module,exports){
var clamp = require('../math/clamp');
var toString = require('../lang/toString');

    /**
     * Inserts a string at a given index.
     */
    function insert(string, index, partial){
        string = toString(string);

        if (index < 0) {
            index = string.length + index;
        }

        index = clamp(index, 0, string.length);

        return string.substr(0, index) + partial + string.substr(index);
    }

    module.exports = insert;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","../math/clamp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/clamp.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/interpolate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var get = require('../object/get');

    var stache = /\{\{([^\}]+)\}\}/g; //mustache-like

    /**
     * String interpolation
     */
    function interpolate(template, replacements, syntax){
        template = toString(template);
        var replaceFn = function(match, prop){
            return toString( get(replacements, prop) );
        };
        return template.replace(syntax || stache, replaceFn);
    }

    module.exports = interpolate;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","../object/get":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/object/get.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lowerCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * "Safer" String.toLowerCase()
     */
    function lowerCase(str){
        str = toString(str);
        return str.toLowerCase();
    }

    module.exports = lowerCase;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lpad.js":[function(require,module,exports){
var toString = require('../lang/toString');
var repeat = require('./repeat');

    /**
     * Pad string with `char` if its' length is smaller than `minLen`
     */
    function lpad(str, minLen, ch) {
        str = toString(str);
        ch = ch || ' ';

        return (str.length < minLen) ?
            repeat(ch, minLen - str.length) + str : str;
    }

    module.exports = lpad;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./repeat":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/repeat.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/ltrim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/WHITE_SPACES.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/makePath.js":[function(require,module,exports){
var join = require('../array/join');
var slice = require('../array/slice');

    /**
     * Group arguments as path segments, if any of the args is `null` or an
     * empty string it will be ignored from resulting path.
     */
    function makePath(var_args){
        var result = join(slice(arguments), '/');
        // need to disconsider duplicate '/' after protocol (eg: 'http://')
        return result.replace(/([^:\/]|^)\/{2,}/g, '$1/');
    }

    module.exports = makePath;


},{"../array/join":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/join.js","../array/slice":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/array/slice.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/normalizeLineBreaks.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Convert line-breaks from DOS/MAC to a single standard (UNIX by default)
     */
    function normalizeLineBreaks(str, lineEnd) {
        str = toString(str);
        lineEnd = lineEnd || '\n';

        return str
            .replace(/\r\n/g, lineEnd) // DOS
            .replace(/\r/g, lineEnd)   // Mac
            .replace(/\n/g, lineEnd);  // Unix
    }

    module.exports = normalizeLineBreaks;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/pascalCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var camelCase = require('./camelCase');
var upperCase = require('./upperCase');
    /**
     * camelCase + UPPERCASE first char
     */
    function pascalCase(str){
        str = toString(str);
        return camelCase(str).replace(/^[a-z]/, upperCase);
    }

    module.exports = pascalCase;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./camelCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/camelCase.js","./upperCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/properCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var lowerCase = require('./lowerCase');
var upperCase = require('./upperCase');
    /**
     * UPPERCASE first char of each word.
     */
    function properCase(str){
        str = toString(str);
        return lowerCase(str).replace(/^\w|\s\w/g, upperCase);
    }

    module.exports = properCase;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lowerCase.js","./upperCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/removeNonASCII.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Remove non-printable ASCII chars
     */
    function removeNonASCII(str){
        str = toString(str);

        // Matches non-printable ASCII chars -
        // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
        return str.replace(/[^\x20-\x7E]/g, '');
    }

    module.exports = removeNonASCII;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/removeNonWord.js":[function(require,module,exports){
var toString = require('../lang/toString');
    // This pattern is generated by the _build/pattern-removeNonWord.js script
    var PATTERN = /[^\x20\x2D0-9A-Z\x5Fa-z\xC0-\xD6\xD8-\xF6\xF8-\xFF]/g;

    /**
     * Remove non-word chars.
     */
    function removeNonWord(str){
        str = toString(str);
        return str.replace(PATTERN, '');
    }

    module.exports = removeNonWord;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/repeat.js":[function(require,module,exports){
var toString = require('../lang/toString');
var toInt = require('../number/toInt');

    /**
     * Repeat string n times
     */
     function repeat(str, n){
         var result = '';
         str = toString(str);
         n = toInt(n);
        if (n < 1) {
            return '';
        }
        while (n > 0) {
            if (n % 2) {
                result += str;
            }
            n = Math.floor(n / 2);
            str += str;
        }
        return result;
     }

     module.exports = repeat;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","../number/toInt":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/toInt.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/replace.js":[function(require,module,exports){
var toString = require('../lang/toString');
var toArray = require('../lang/toArray');

    /**
     * Replace string(s) with the replacement(s) in the source.
     */
    function replace(str, search, replacements) {
        str = toString(str);
        search = toArray(search);
        replacements = toArray(replacements);

        var searchLength = search.length,
            replacementsLength = replacements.length;

        if (replacementsLength !== 1 && searchLength !== replacementsLength) {
            throw new Error('Unequal number of searches and replacements');
        }

        var i = -1;
        while (++i < searchLength) {
            // Use the first replacement for all searches if only one
            // replacement is provided
            str = str.replace(
                search[i],
                replacements[(replacementsLength === 1) ? 0 : i]);
        }

        return str;
    }

    module.exports = replace;



},{"../lang/toArray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toArray.js","../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/replaceAccents.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
    * Replaces all accented chars with regular ones
    */
    function replaceAccents(str){
        str = toString(str);

        // verifies if the String has accents and replace them
        if (str.search(/[\xC0-\xFF]/g) > -1) {
            str = str
                    .replace(/[\xC0-\xC5]/g, "A")
                    .replace(/[\xC6]/g, "AE")
                    .replace(/[\xC7]/g, "C")
                    .replace(/[\xC8-\xCB]/g, "E")
                    .replace(/[\xCC-\xCF]/g, "I")
                    .replace(/[\xD0]/g, "D")
                    .replace(/[\xD1]/g, "N")
                    .replace(/[\xD2-\xD6\xD8]/g, "O")
                    .replace(/[\xD9-\xDC]/g, "U")
                    .replace(/[\xDD]/g, "Y")
                    .replace(/[\xDE]/g, "P")
                    .replace(/[\xE0-\xE5]/g, "a")
                    .replace(/[\xE6]/g, "ae")
                    .replace(/[\xE7]/g, "c")
                    .replace(/[\xE8-\xEB]/g, "e")
                    .replace(/[\xEC-\xEF]/g, "i")
                    .replace(/[\xF1]/g, "n")
                    .replace(/[\xF2-\xF6\xF8]/g, "o")
                    .replace(/[\xF9-\xFC]/g, "u")
                    .replace(/[\xFE]/g, "p")
                    .replace(/[\xFD\xFF]/g, "y");
        }
        return str;
    }
    module.exports = replaceAccents;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/rpad.js":[function(require,module,exports){
var toString = require('../lang/toString');
var repeat = require('./repeat');

    /**
     * Pad string with `char` if its' length is smaller than `minLen`
     */
    function rpad(str, minLen, ch) {
        str = toString(str);
        ch = ch || ' ';
        return (str.length < minLen)? str + repeat(ch, minLen - str.length) : str;
    }

    module.exports = rpad;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./repeat":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/repeat.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/rtrim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/WHITE_SPACES.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/sentenceCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var lowerCase = require('./lowerCase');
var upperCase = require('./upperCase');
    /**
     * UPPERCASE first char of each sentence and lowercase other chars.
     */
    function sentenceCase(str){
        str = toString(str);

        // Replace first char of each sentence (new line or after '.\s+') to
        // UPPERCASE
        return lowerCase(str).replace(/(^\w)|\.\s+(\w)/gm, upperCase);
    }
    module.exports = sentenceCase;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/lowerCase.js","./upperCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/slugify.js":[function(require,module,exports){
var toString = require('../lang/toString');
var replaceAccents = require('./replaceAccents');
var removeNonWord = require('./removeNonWord');
var trim = require('./trim');
    /**
     * Convert to lower case, remove accents, remove non-word chars and
     * replace spaces with the specified delimeter.
     * Does not split camelCase text.
     */
    function slugify(str, delimeter){
        str = toString(str);

        if (delimeter == null) {
            delimeter = "-";
        }
        str = replaceAccents(str);
        str = removeNonWord(str);
        str = trim(str) //should come after removeNonWord
                .replace(/ +/g, delimeter) //replace spaces with delimeter
                .toLowerCase();
        return str;
    }
    module.exports = slugify;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./removeNonWord":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/removeNonWord.js","./replaceAccents":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/replaceAccents.js","./trim":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/trim.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/startsWith.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Checks if string starts with specified prefix.
     */
    function startsWith(str, prefix) {
        str = toString(str);
        prefix = toString(prefix);

        return str.indexOf(prefix) === 0;
    }

    module.exports = startsWith;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/stripHtmlTags.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Remove HTML tags from string.
     */
    function stripHtmlTags(str){
        str = toString(str);

        return str.replace(/<[^>]*>/g, '');
    }
    module.exports = stripHtmlTags;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/trim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/WHITE_SPACES.js","./ltrim":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/ltrim.js","./rtrim":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/rtrim.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/truncate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var trim = require('./trim');
    /**
     * Limit number of chars.
     */
    function truncate(str, maxChars, append, onlyFullWords){
        str = toString(str);
        append = append || '...';
        maxChars = onlyFullWords? maxChars + 1 : maxChars;

        str = trim(str);
        if(str.length <= maxChars){
            return str;
        }
        str = str.substr(0, maxChars - append.length);
        //crop at last space or remove trailing whitespace
        str = onlyFullWords? str.substr(0, str.lastIndexOf(' ')) : trim(str);
        return str + append;
    }
    module.exports = truncate;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./trim":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/trim.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/typecast.js":[function(require,module,exports){


    var UNDEF;

    /**
     * Parses string and convert it into a native value.
     */
    function typecast(val) {
        var r;
        if ( val === null || val === 'null' ) {
            r = null;
        } else if ( val === 'true' ) {
            r = true;
        } else if ( val === 'false' ) {
            r = false;
        } else if ( val === UNDEF || val === 'undefined' ) {
            r = UNDEF;
        } else if ( val === '' || isNaN(val) ) {
            //isNaN('') returns false
            r = val;
        } else {
            //parseFloat(null || '') returns NaN
            r = parseFloat(val);
        }
        return r;
    }

    module.exports = typecast;


},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unCamelCase.js":[function(require,module,exports){
var toString = require('../lang/toString');

    var CAMEL_CASE_BORDER = /([a-z\xE0-\xFF])([A-Z\xC0\xDF])/g;

    /**
     * Add space between camelCase text.
     */
    function unCamelCase(str, delimiter){
        if (delimiter == null) {
            delimiter = ' ';
        }

        function join(str, c1, c2) {
            return c1 + delimiter + c2;
        }

        str = toString(str);
        str = str.replace(CAMEL_CASE_BORDER, join);
        str = str.toLowerCase(); //add space between camelCase text
        return str;
    }
    module.exports = unCamelCase;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/underscore.js":[function(require,module,exports){
var toString = require('../lang/toString');
var slugify = require('./slugify');
var unCamelCase = require('./unCamelCase');
    /**
     * Replaces spaces with underscores, split camelCase text, remove non-word chars, remove accents and convert to lower case.
     */
    function underscore(str){
        str = toString(str);
        str = unCamelCase(str);
        return slugify(str, "_");
    }
    module.exports = underscore;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js","./slugify":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/slugify.js","./unCamelCase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unCamelCase.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unescapeHtml.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Unescapes HTML special chars
     */
    function unescapeHtml(str){
        str = toString(str)
            .replace(/&amp;/g , '&')
            .replace(/&lt;/g  , '<')
            .replace(/&gt;/g  , '>')
            .replace(/&#0*39;/g , "'")
            .replace(/&quot;/g, '"');
        return str;
    }

    module.exports = unescapeHtml;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unescapeUnicode.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Unescape unicode char sequences
     */
    function unescapeUnicode(str){
        str = toString(str);
        return str.replace(/\\u[0-9a-f]{4}/g, function(ch){
            var code = parseInt(ch.slice(2), 16);
            return String.fromCharCode(code);
        });
    }

    module.exports = unescapeUnicode;



},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/unhyphenate.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Replaces hyphens with spaces. (only hyphens between word chars)
     */
    function unhyphenate(str){
        str = toString(str);
        return str.replace(/(\w)(-)(\w)/g, '$1 $3');
    }
    module.exports = unhyphenate;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/string/upperCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * "Safer" String.toUpperCase()
     */
    function upperCase(str){
        str = toString(str);
        return str.toUpperCase();
    }
    module.exports = upperCase;


},{"../lang/toString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/lang/toString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'convert' : require('./time/convert'),
    'now' : require('./time/now'),
    'parseMs' : require('./time/parseMs'),
    'toTimeString' : require('./time/toTimeString')
};



},{"./time/convert":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/convert.js","./time/now":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/now.js","./time/parseMs":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/parseMs.js","./time/toTimeString":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/toTimeString.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/convert.js":[function(require,module,exports){


    /**
     * convert time into another unit
     */
    function convert(val, sourceUnitName, destinationUnitName){
        destinationUnitName = destinationUnitName || 'ms';
        return (val * getUnit(sourceUnitName)) / getUnit(destinationUnitName);
    }


    //TODO: maybe extract to a separate module
    function getUnit(unitName){
        switch(unitName){
            case 'ms':
            case 'millisecond':
                return 1;
            case 's':
            case 'second':
                 return 1000;
            case 'm':
            case 'minute':
                 return 60000;
            case 'h':
            case 'hour':
                 return 3600000;
            case 'd':
            case 'day':
                 return 86400000;
            case 'w':
            case 'week':
                 return 604800000;
            default:
                throw new Error('"'+ unitName + '" is not a valid unit');
        }
    }


    module.exports = convert;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/now.js":[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/parseMs.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');

    /**
     * Parse timestamp into an object.
     */
    function parseMs(ms){
        return {
            milliseconds : countSteps(ms, 1, 1000),
            seconds      : countSteps(ms, 1000, 60),
            minutes      : countSteps(ms, 60000, 60),
            hours        : countSteps(ms, 3600000, 24),
            days         : countSteps(ms, 86400000)
        };
    }

    module.exports = parseMs;


},{"../math/countSteps":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/countSteps.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/time/toTimeString.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');
var pad = require('../number/pad');

    var HOUR = 3600000,
        MINUTE = 60000,
        SECOND = 1000;

    /**
     * Format timestamp into a time string.
     */
    function toTimeString(ms){
        var h = ms < HOUR   ? 0 : countSteps(ms, HOUR),
            m = ms < MINUTE ? 0 : countSteps(ms, MINUTE, 60),
            s = ms < SECOND ? 0 : countSteps(ms, SECOND, 60),
            str = '';

        str += h? h + ':' : '';
        str += pad(m, 2) + ':';
        str += pad(s, 2);

        return str;
    }
    module.exports = toTimeString;


},{"../math/countSteps":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/math/countSteps.js","../number/pad":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/number/pad.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/index.js":[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys) {
  var index = 0;

  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  return path.replace(PATH_REGEXP, replace);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

},{"isarray":"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/node_modules/isarray/index.js"}],"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/luke.hedger/dev/Experiments/040715/source/js/app-debug.coffee":[function(require,module,exports){
var dat, gui, options, page;

dat = require("dat-gui");

page = require("./../../vendor/page/page.js");

gui = window._gui = new dat.GUI();

options = {
  "debug": false,
  "index": function() {
    return page("/");
  },
  "day": function() {
    return page("/day");
  },
  "digest": function() {
    return page("/digest");
  },
  "night": function() {
    return page("/night");
  }
};

module.exports = function() {
  var debug, folder;
  debug = gui.add(options, "debug");
  folder = gui.addFolder("navigation");
  folder.add(options, "index").name("/index");
  folder.add(options, "day").name("/day");
  folder.add(options, "digest").name("/digest");
  folder.add(options, "night").name("/night");
  return folder.open();
};



},{"./../../vendor/page/page.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js","dat-gui":"/Users/luke.hedger/dev/Experiments/040715/node_modules/dat-gui/index.js"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/config.coffee":[function(require,module,exports){
module.exports = {
  firebase: "aliceluke"
};



},{}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-module.coffee":[function(require,module,exports){
var Ractive;

Ractive = require("./../../../vendor/ractive/ractive.js");

module.exports = Ractive.extend({
  isolated: true
});



},{"./../../../vendor/ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-scene.coffee":[function(require,module,exports){

/*
	@module:   abstract-scene
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/abstract-scene.styl
	@html:     ./source/template/module/abstract-scene.html
 */
var Module;

Module = require("./abstract-module");

module.exports = Module.extend({
  template: require("module/abstract-scene.html"),
  oninit: function() {}
});



},{"./abstract-module":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-module.coffee","module/abstract-scene.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/abstract-scene.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/index.coffee":[function(require,module,exports){

/*
	THIS FILE IS GENERATED AUTOMATICALLY AND IT WILL
	BE REPLACED IF A NEW MODULE IS ADDED OR DELETED.
 */
var Ractive, register;

Ractive = require("./../../../vendor/ractive/ractive.js");

register = function() {
  Ractive.components["ui-abstract-scene"] = require("./abstract-scene");
  Ractive.components["ui-nav"] = require("./nav");
  Ractive.components["ui-scene-day"] = require("./scene-day");
  Ractive.components["ui-scene-digest"] = require("./scene-digest");
  Ractive.components["ui-scene-night"] = require("./scene-night");
  Ractive.components["ui-stage"] = require("./stage");
  return true;
};

module.exports = register();



},{"./../../../vendor/ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js","./abstract-scene":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-scene.coffee","./nav":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/nav.coffee","./scene-day":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/scene-day.coffee","./scene-digest":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/scene-digest.coffee","./scene-night":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/scene-night.coffee","./stage":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/stage.coffee"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/nav.coffee":[function(require,module,exports){

/*
	@module:   nav
	@author:   Luke Hedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/nav.styl
	@html:     ./source/template/module/nav.html
 */
var Module, page;

Module = require("./abstract-module");

page = require("./../../../vendor/page/page.js");

module.exports = Module.extend({
  template: require("module/nav.html"),
  oninit: function() {
    this.on("toIndex", function() {
      return page("/");
    });
    return this.on("toTest", function() {
      return page("/test");
    });
  }
});



},{"./../../../vendor/page/page.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js","./abstract-module":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-module.coffee","module/nav.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/nav.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/scene-day.coffee":[function(require,module,exports){

/*
	@module:   scene-day
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-day.styl
	@html:     ./source/template/module/scene-day.html
 */
var Module;

Module = require("./abstract-scene");

module.exports = Module.extend({
  template: require("module/scene-day.html"),
  oninit: function() {
    return this._super();
  },
  onrender: function() {
    var length, path;
    path = this.find("path");
    length = path.getTotalLength();
    return TweenMax.to(path, 2, {
      delay: 1,
      'stroke-dashoffset': length,
      ease: Bounce.easeOut
    });
  }
});



},{"./abstract-scene":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-scene.coffee","module/scene-day.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/scene-day.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/scene-digest.coffee":[function(require,module,exports){

/*
	@module:   scene-digest
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-digest.styl
	@html:     ./source/template/module/scene-digest.html
 */
var Module, keys, last;

Module = require("./abstract-scene");

keys = require("mout").object.keys;

last = require("mout").array.last;

module.exports = Module.extend({
  template: require("module/scene-digest.html"),
  data: {
    current: 0,
    x: ["100%", "-200%"],
    slides: {
      1: {
        title: "slide 1",
        body: "this is slide 1",
        links: ["a", "b"],
        active: false
      },
      2: {
        title: "slide 2",
        body: "this is slide 2",
        active: false
      },
      3: {
        title: "slide 3",
        body: "this is slide 3",
        active: false
      }
    }
  },
  oninit: function() {
    return this._super();
  },
  onteardown: function() {
    this.prevSlide();
    return this.set("slides.*.active", false);
  },
  onrender: function() {
    this.on("goNextSlide", function() {
      return this.nextSlide();
    });
    this.on("goPrevSlide", function() {
      return this.prevSlide();
    });
    return this.nextSlide();
  },
  nextSlide: function() {
    var current, next;
    current = this.get("current");
    next = current === keys(this.get("slides")).length ? 1 : current += 1;
    if (this.get("current") !== 0) {
      this.set("slides." + (this.get("current")) + ".x", this.get("x[1]"));
    }
    this.set("slides." + next + ".x", this.get("x[0]"));
    return this.setSlide(next);
  },
  prevSlide: function() {
    var current, prev;
    current = this.get("current");
    prev = current === 1 ? keys(this.get("slides")).length : current -= 1;
    if (this.get("current") !== 0) {
      this.set("slides." + (this.get("current")) + ".x", this.get("x[0]"));
    }
    this.set("slides." + prev + ".x", this.get("x[1]"));
    return this.setSlide(prev);
  },
  setSlide: function(slide) {
    if (this.get("current") !== 0) {
      this.set("slides." + (this.get("current")) + ".active", false);
    }
    this.set("slides." + slide + ".active", true);
    return this.set({
      current: slide
    });
  }
});



},{"./abstract-scene":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-scene.coffee","module/scene-digest.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/scene-digest.html","mout":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/index.js"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/scene-night.coffee":[function(require,module,exports){

/*
	@module:   scene-night
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-night.styl
	@html:     ./source/template/module/scene-night.html
 */
var Module;

Module = require("./abstract-scene");

module.exports = Module.extend({
  template: require("module/scene-night.html"),
  oninit: function() {
    return this._super();
  },
  onrender: function() {}
});



},{"./abstract-scene":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-scene.coffee","module/scene-night.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/scene-night.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/module/stage.coffee":[function(require,module,exports){

/*
	@module:   stage
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/stage.styl
	@html:     ./source/template/module/stage.html
 */
var AddClass, Module, forIn, keys, page;

Module = require("./abstract-module");

page = require("./../../../vendor/page/page.js");

keys = require("mout").object.keys;

forIn = require("mout").object.forIn;

AddClass = require("../util/addClass");

module.exports = Module.extend({
  template: require("module/stage.html"),
  partials: {
    stageControls: require("partials/stage-controls.html"),
    farm: require("partials/farm.html")
  },
  data: {
    current: 0,
    scenes: {
      1: "day",
      2: "digest",
      3: "night"
    }
  },
  oninit: function() {
    window.onkeydown = (function(_this) {
      return function(e) {
        if (e.keyCode === 38) {
          _this.prevScene();
        }
        if (e.keyCode === 40) {
          return _this.nextScene();
        }
      };
    })(this);
    this.on("goNextScene", function() {
      return this.nextScene();
    });
    this.on("goPrevScene", function() {
      return this.prevScene();
    });
    return this.observe("view", (function(_this) {
      return function(newValue) {
        if (newValue) {
          return forIn(_this.get("scenes"), function(v, k) {
            if (v === newValue) {
              return _this.set({
                current: parseInt(k, 10)
              });
            }
          });
        }
      };
    })(this));
  },
  onrender: function() {
    var cable, div, left, line;
    line = this.find("line");
    cable = this.find(".cable--left");
    left = this.find(".cable--left svg path");
    div = document.createElement("div");
    AddClass(div, "flag");
    return cable.appendChild(div);
  },
  nextScene: function() {
    var current, next;
    current = this.get("current");
    next = current === keys(this.get("scenes")).length ? 1 : current += 1;
    return this.setScene(next);
  },
  prevScene: function() {
    var current, prev;
    current = this.get("current");
    prev = current === 1 ? keys(this.get("scenes")).length : current -= 1;
    return this.setScene(prev);
  },
  setScene: function(scene) {
    return page("/" + (this.get("scenes." + scene)));
  }
});



},{"../util/addClass":"/Users/luke.hedger/dev/Experiments/040715/source/js/util/addClass.coffee","./../../../vendor/page/page.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js","./abstract-module":"/Users/luke.hedger/dev/Experiments/040715/source/js/module/abstract-module.coffee","module/stage.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/module/stage.html","mout":"/Users/luke.hedger/dev/Experiments/040715/node_modules/mout/index.js","partials/farm.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/partials/farm.html","partials/stage-controls.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/partials/stage-controls.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/js/util/addClass.coffee":[function(require,module,exports){
module.exports = function(el, className) {
  if (el != null) {
    if (el.classList != null) {
      return el.classList.add(className);
    } else {
      return el.className += ' ' + className;
    }
  }
};



},{}],"/Users/luke.hedger/dev/Experiments/040715/source/js/view/main-view.coffee":[function(require,module,exports){
var Firebase, Ractive, config, page;

Ractive = require("./../../../vendor/ractive/ractive.js");

Firebase = require("firebase");

page = require("./../../../vendor/page/page.js");

config = require("../config");

module.exports = Ractive.extend({
  el: document.body,
  append: true,
  template: require("main-view.html"),
  data: {
    view: null,
    code: null,
    guest: null
  },
  oninit: function() {
    this.getData();
    return this.set_router();
  },
  getData: function() {
    var db;
    db = new Firebase("https://" + config.firebase + ".firebaseio.com/");
    return db.on("value", (function(_this) {
      return function(snapshot) {
        return console.log("ok:", snapshot.val());
      };
    })(this), function(err) {
      return console.log("err:", err.code);
    });
  },
  set_router: function() {
    var self;
    self = this;
    page("/", function() {
      return self.set({
        "view": "day"
      });
    });
    page("/:scene", function(ctx) {
      return self.set({
        "view": ctx.params.scene
      });
    });
    return page({
      click: false,
      dispatch: true,
      hashbang: false
    });
  }
});



},{"../config":"/Users/luke.hedger/dev/Experiments/040715/source/js/config.coffee","./../../../vendor/page/page.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js","./../../../vendor/ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js","firebase":"/Users/luke.hedger/dev/Experiments/040715/node_modules/firebase/lib/firebase-web.js","main-view.html":"/Users/luke.hedger/dev/Experiments/040715/source/template/main-view.html"}],"/Users/luke.hedger/dev/Experiments/040715/source/template/main-view.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"wrapper"},"f":[{"t":7,"e":"div","a":{"class":["sky ",{"t":2,"r":"view"}]}}," ",{"t":7,"e":"ui-stage","a":{"view":[{"t":2,"r":"view"}]}}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/abstract-scene.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"abstract-scene"},"f":[{"t":7,"e":"h1","f":["abstract-scene :)"]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/nav.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"nav"},"f":[{"t":7,"e":"a","v":{"tap":"toIndex"},"f":["Home"]}," ",{"t":7,"e":"a","v":{"tap":"toTest"},"f":["Test"]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/scene-day.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-day"},"t1":"fade","f":[{"t":7,"e":"svg","a":{"width":"200px","height":"200px","version":"1.1","xmlns":"http://www.w3.org/2000/svg"},"f":[{"t":7,"e":"path","a":{"d":"M10 10 C 20 20, 40 20, 50 10","stroke":"black","fill":"transparent"}}]}," ",{"t":7,"e":"div","a":{"class":"greeting"},"f":[{"t":7,"e":"h2","f":["Howdy! You're invited to Woodstock 2015"]}]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/scene-digest.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-digest"},"f":[{"t":7,"e":"div","a":{"class":"showtime"},"v":{"swiperight":"goPrevSlide","swipeleft":"goNextSlide"},"f":[{"t":7,"e":"div","a":{"class":"showtime__controls"},"f":[{"t":7,"e":"a","a":{"class":"showtime__control--prev"},"v":{"tap":"goPrevSlide"},"f":[""]}," ",{"t":7,"e":"a","a":{"class":"showtime__control--next"},"v":{"tap":"goNextSlide"},"f":[""]}]}," ",{"t":4,"r":"slides","i":"slide","f":[{"t":4,"r":"active","f":[{"t":7,"e":"div","a":{"class":["slide--",{"t":2,"r":"slide"}]},"t0":{"n":"fly","d":["{ x:'",{"t":2,"r":"x"},"', y:'0%', opacity:1 }"]},"f":[{"t":7,"e":"h1","f":[{"t":2,"r":"title"}]}," ",{"t":7,"e":"p","f":[{"t":2,"r":"body"}]}," ",{"t":4,"r":"links","f":[{"t":2,"r":"."}]}," ",{"t":7,"e":"div","a":{"class":"flower"}}]}]}]}]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/scene-night.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-night"},"f":[{"t":7,"e":"h1","f":["scene-night :)"]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/module/stage.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"stage"},"f":[{"t":8,"r":"stageControls"}," ",{"t":7,"e":"div","a":{"class":"sun"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","id":"Layer_1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 100 100","enable-background":"new 0 0 100 100","xml:space":"preserve"},"f":[{"t":7,"e":"circle","a":{"cx":"50","cy":"49.9","r":"25","fill":"#FDB813"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"23","y1":"49.5","x2":"2","y2":"49.5"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"98","y1":"49.5","x2":"77","y2":"49.5"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"49.5","y1":"77","x2":"49.5","y2":"98"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"49.5","y1":"2","x2":"49.5","y2":"23"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"30.6","y1":"68.7","x2":"15.7","y2":"83.6"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"83.6","y1":"15.7","x2":"68.7","y2":"30.6"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"68.7","y1":"69.4","x2":"83.6","y2":"84.3"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"15.7","y1":"16.4","x2":"30.6","y2":"31.3"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"24.9","y1":"59.9","x2":"5.5","y2":"67.9"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"94.2","y1":"31.2","x2":"74.8","y2":"39.2"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"59.9","y1":"75.1","x2":"67.9","y2":"94.5"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"31.2","y1":"5.8","x2":"39.2","y2":"25.2"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"39.2","y1":"74.8","x2":"31.2","y2":"94.2"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"67.9","y1":"5.5","x2":"59.9","y2":"24.9"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"74.8","y1":"60.8","x2":"94.2","y2":"68.8"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"5.5","y1":"32.1","x2":"24.9","y2":"40.1"}}]}]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"day\""},"f":[{"t":7,"e":"ui-scene-day"}]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"digest\""},"f":[{"t":7,"e":"ui-scene-digest"}]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"night\""},"f":[{"t":7,"e":"ui-scene-night"}]}," ",{"x":{"r":["view"],"s":"{view:_0}"},"f":[{"t":8,"r":"farm"}],"t":4,"n":53}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/partials/farm.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":["farm--",{"t":2,"r":"view"}]},"f":[{"t":7,"e":"div","a":{"class":"field"},"f":[{"t":7,"e":"div","a":{"class":"camber"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","id":"Layer_1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 593.2 28.8","enable-background":"new 0 0 593.2 28.8","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"#7AB490","stroke":"#7AB490","stroke-miterlimit":"10","d":"M593.2,29.3H0c0,0,0.5-3,0-20c43.4,23.1,518.7-24.7,593.2,0\n            C592.7,22.6,593.2,29.3,593.2,29.3z"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"bunting"},"f":[{"t":7,"e":"div","a":{"class":"cable--left"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","id":"Layer_1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 7 600 29","enable-background":"new 0 7 600 29","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M0,7L0,7c268.7,51.6,600,12.5,600,0l0,0"}}]}]}," ",{"t":7,"e":"div","a":{"class":"pole"}}," ",{"t":7,"e":"div","a":{"class":"cable--right"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","id":"Layer_1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 7 600 29","enable-background":"new 0 7 600 29","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M0,7L0,7c268.7,51.6,600,12.5,600,0l0,0"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"trees"},"f":[{"t":7,"e":"div","a":{"class":"tree--dark"}}," ",{"t":7,"e":"div","a":{"class":"tree"}}," ",{"t":7,"e":"div","a":{"class":"tree--dark"}}," ",{"t":7,"e":"div","a":{"class":"tree"}}]}," ",{"t":7,"e":"div","a":{"class":"tents"},"f":[{"t":7,"e":"div","a":{"class":"tent"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}," ",{"t":7,"e":"div","a":{"class":"tent--blue"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}," ",{"t":7,"e":"div","a":{"class":"tent--pink"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"fire"},"f":[{"t":7,"e":"div","a":{"class":"logs"}}]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/source/template/partials/stage-controls.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"a","a":{"class":"stage__control--prev"},"v":{"tap":"goPrevScene"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","id":"Layer_1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 70 32.1","enable-background":"new 0 0 70 32.1","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M0.6,31.6L33.8,1.2c0.7-0.6,1.7-0.6,2.4,0l33.1,30.4"}}]}]}," ",{"t":7,"e":"a","a":{"class":"stage__control--next"},"v":{"tap":"goNextScene"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","id":"Layer_1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 70 32.1","enable-background":"new 0 0 70 32.1","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M69.3,0.7L36.1,31.2c-0.7,0.6-1.7,0.6-2.4,0L0.6,0.7"}}]}]}]}
},{}],"/Users/luke.hedger/dev/Experiments/040715/vendor/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/Users/luke.hedger/dev/Experiments/040715/vendor/gsap/src/uncompressed/TweenMax.js":[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.16.1
 * DATE: 2015-03-13
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			TweenMax = function(target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
			_blankArray = [];

		TweenMax.version = "1.16.1";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};
		
		p.updateTo = function(vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._time;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else if (this._time > 0 || immediate) {
						this._initted = false;
						this._init();
						var inv = 1 / (1 - curRatio),
							pt = this._firstPT, endValue;
						while (pt) {
							endValue = pt.s + pt.c; 
							pt.c *= inv;
							pt.s = endValue - pt.c;
							pt = pt._next;
						}
					}
				}
			}
			return this;
		};
				
		p.render = function(time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime, 
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime;
			if (time >= totalDur) {
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time) {
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
				
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but Flash reports it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - (this._cycle * cycleDuration);
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
				
			}
				
			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}
			
			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
			}
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};
		
//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
		
		TweenMax.to = function(target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		};
		
		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = vars.delay || 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || this, onCompleteAllParams || _blankArray);
				},
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				copy.delay = delay;
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};
		
		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
		
		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
				
		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, useFrames:useFrames, overwrite:0});
		};
		
		TweenMax.set = function(target, vars) {
			return new TweenMax(target, 0, vars);
		};
		
		TweenMax.isTweening = function(target) {
			return (TweenLite.getTweensOf(target, true).length > 0);
		};
		
		var _getChildrenOf = function(timeline, includeTimelines) {
				var a = [],
					cnt = 0,
					tween = timeline._first;
				while (tween) {
					if (tween instanceof TweenLite) {
						a[cnt++] = tween;
					} else {
						if (includeTimelines) {
							a[cnt++] = tween;
						}
						a = a.concat(_getChildrenOf(tween, includeTimelines));
						cnt = a.length;
					}
					tween = tween._next;
				}
				return a;
			}, 
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
			};
		
		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens && delayedCalls && timelines),
				isDC, tween, i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};
		
		TweenMax.killChildTweensOf = function(parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function(pause, tweens, delayedCalls, timelines) {
			tweens = (tweens !== false);
			delayedCalls = (delayedCalls !== false);
			timelines = (timelines !== false);
			var a = getAllTweens(timelines),
				allTrue = (tweens && delayedCalls && timelines),
				i = a.length,
				isDC, tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);
				}
			}
		};
		
		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};
		
		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function(value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};
		
	
//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
		
		p.progress = function(value) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), false);
		};
		
		p.totalProgress = function(value) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, false);
		};
		
		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function(value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};
		
		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};
		
		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};
		
		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};
		
		
		return TweenMax;
		
	}, true);








/*
 * ----------------------------------------------------------------
 * TimelineLite
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_blankArray = [],
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_pauseCallback = _internals.pauseCallback = function(tween, callback, params, scope) {
				var tl = tween._timeline,
					time = tl._totalTime,
					startTime = tween._startTime,
					reversed = (tween._rawPrevTime < 0 || (tween._rawPrevTime === 0 && tl._reversed)),//don't use tween.ratio because if the playhead lands exactly on top of the addPause(), ratio will be 1 even if the master timeline was reversed (which is correct). The key here is to sense the direction of the playhead.
					next = reversed ? 0 : _tinyNum,
					prev = reversed ? _tinyNum : 0,
					sibling;
				if (callback || !this._forcingPlayhead) { //if the user calls a method that moves the playhead (like progress() or time()), it should honor that and skip any pauses (although if there's a callback positioned at that pause, it must jump there and make the call to ensure the time is EXACTLY what it is supposed to be, and then proceed to where the playhead is being forced). Otherwise, imagine placing a pause in the middle of a timeline and then doing timeline.progress(0.9) - it would get stuck where the pause is.
					tl.pause(startTime);
					//now find sibling tweens that are EXACTLY at the same spot on the timeline and adjust the _rawPrevTime so that they fire (or don't fire) correctly on the next render. This is primarily to accommodate zero-duration tweens/callbacks that are positioned right on top of a pause. For example, tl.to(...).call(...).addPause(...).call(...) - notice that there's a call() on each side of the pause, so when it's running forward it should call the first one and then pause, and then when resumed, call the other. Zero-duration tweens use _rawPrevTime to sense momentum figure out if events were suppressed when arriving directly on top of that time.
					sibling = tween._prev;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = prev;
						sibling = sibling._prev;
					}
					sibling = tween._next;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = next;
						sibling = sibling._next;
					}
					if (callback) {
						callback.apply(scope || tl, params || _blankArray);
					}
					if (this._forcingPlayhead || !tl._paused) { //the callback could have called resume().
						tl.seek(time);
					}
				}
			},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.16.1";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, onCompleteScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				if (vars.startAt) {
					vars.startAt = _copy(vars.startAt);
				}
				tl.to(targets[i], duration, _copy(vars), i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				return this._remove(value, false);
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, ["{self}", callback, params, scope], this);
			t.data = "isPause"; // we use this flag in TweenLite's render() method to identify it as a special case that shouldn't be triggered when the virtual playhead is LEAVING the exact position where the pause is, otherwise timeline.addPause(1).play(1) would end up paused on the very next tick.
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce;
			if (time >= totalDur) {
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			if (this.totalDuration() !== 0) if (value !== 0) {
				this.timeScale(this._totalDuration / value);
			}
			return this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function() {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);
	







	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * TimelineMax
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {

		var TimelineMax = function(vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			},
			_tinyNum = 0.0000000001,
			_blankArray = [],
			TweenLiteInternals = TweenLite._internals,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_easeNone = new Ease(null, null, 1, 0),
			p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.16.1";

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function(callback, position, params, scope) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function(callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function(position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function(position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false},
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new TweenLite(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale );
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
					vars.onStart.apply(vars.onStartScope || t, vars.onStartParams || _blankArray);
				}
			};
			return t;
		};

		p.tweenFromTo = function(fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], onCompleteScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused,
				prevCycle = this._cycle,
				tween, isComplete, next, callback, internalForce, cycleDuration;
			if (time >= totalDur) {
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - (this._cycle * cycleDuration);
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}
			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
				*/
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
					recTotalTime = this._totalTime,
					recCycle = this._cycle,
					recRawPrevTime = this._rawPrevTime,
					recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;
				this.render(prevTime, suppressEvents, (dur === 0));
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
					}
				}
				if (wrap) {
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}

					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p.getActive = function(nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
				all = this.getChildren(nested, tweens, timelines),
				cnt = 0,
				l = all.length,
				i, tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};


		p.getLabelAfter = function(time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function(time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function() {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		};


//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};

		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function(value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;

	}, true);
	




	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * BezierPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors. For example, if you set an object's position to 4.945, Flash will make it 4.9
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = a[j+1].da / _r2[j] + a[j].da / _r1[j];
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.4",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._round = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._round[p]) {
								val = Math.round(val);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._roundProps = function(lookup, value) {
			var op = this._overwriteProps,
				i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

	}());






	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * CSSPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function() {
				TweenPlugin.call(this, "css");
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_globals = _gsScope._gsDefine.globals,
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},
			p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.16.1";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


		var _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_opacityExp = /opacity *= *([^)]*)/i,
			_opacityValExp = /opacity:([^;]*)/i,
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
			_rgbhslExp = /^(rgb|hsl)/,
			_capsExp = /([A-Z])/g,
			_camelExp = /-([a-z])/gi,
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },
			_horizExp = /(?:Left|Right|Width)/i,
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
			_DEG2RAD = Math.PI / 180,
			_RAD2DEG = 180 / Math.PI,
			_forcePT = {},
			_doc = document,
			_createElement = function(type) {
				return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_tempImg = _createElement("img"),
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = navigator.userAgent,
			_autoRound,
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

			_isSafari,
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),
					a = _createElement("a");
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i+8, 1)) > 3));
				_isSafariLT6 = (_isSafari && (Number(_agent.substr(_agent.indexOf("Version/")+8, 1)) < 6));
				_isFirefox = (_agent.indexOf("Firefox") !== -1);
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
					_ieVers = parseFloat( RegExp.$1 );
				}
				if (!a) {
					return false;
				}
				a.style.cssText = "top:1px;opacity:.55;";
				return /^0.55/.test(a.style.opacity);
			}()),
			_getIEOpacity = function(v) {
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
				if (window.console) {
					console.log(s);
				}
			},

			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {
				e = e || _tempDiv;
				var s = e.style,
					a, i;
				if (s[p] !== undefined) {
					return p;
				}
				p = p.charAt(0).toUpperCase() + p.substr(1);
				a = ["O","Moz","ms","Ms","Webkit"];
				i = 5;
				while (--i > -1 && s[a[i]+p] === undefined) { }
				if (i >= 0) {
					_prefix = (i === 3) ? "ms" : a[i];
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";
					return _prefix + p;
				}
				return null;
			},

			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},

			/**
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
			 *
			 * @param {!Object} t Target element whose style property you want to query
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
			 * @return {?string} The current property value
			 */
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc && t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
			},

			/**
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
			 * @param {!number} v Value
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels
			 */
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || !sfx) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
					if (sfx === "%" || !node.appendChild) {
						node = t.parentNode || _doc.body;
						cache = node._gsCache;
						time = TweenLite.ticker.frame;
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;
						}
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, cs);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
			},

			// @private returns at object containing ALL of the style properties in camelCase and their associated values.
			_getAllStyles = function(t, cs) {
				var s = {},
					i, tr, p;
				if ((cs = cs || _getComputedStyle(t, null))) {
					if ((i = cs.length)) {
						while (--i > -1) {
							p = cs[i];
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
							}
						}
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
						for (i in cs) {
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];
							}
						}
					}
				} else if ((cs = t.currentStyle || t.style)) {
					for (i in cs) {
						if (typeof(i) === "string" && s[i] === undefined) {
							s[i.replace(_camelExp, _camelFunc)] = cs[i];
						}
					}
				}
				if (!_supportsOpacity) {
					s.opacity = _getIEOpacity(t);
				}
				tr = _getTransform(t, cs, false);
				s.rotation = tr.rotation;
				s.skewX = tr.skewX;
				s.scaleX = tr.scaleX;
				s.scaleY = tr.scaleY;
				s.x = tr.x;
				s.y = tr.y;
				if (_supports3D) {
					s.z = tr.z;
					s.rotationX = tr.rotationX;
					s.rotationY = tr.rotationY;
					s.scaleZ = tr.scaleZ;
				}
				if (s.filters) {
					delete s.filters;
				}
				return s;
			},

			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {
				var difs = {},
					style = t.style,
					val, p, mpt;
				for (p in s2) {
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);
						}
					}
				}
				if (vars) {
					for (p in vars) { //copy properties (except className)
						if (p !== "className") {
							difs[p] = vars[p];
						}
					}
				}
				return {difs:difs, firstMPT:mpt};
			},
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

			/**
			 * @private Gets the width or height of an element
			 * @param {!Object} t Target element
			 * @param {!string} p Property name ("width" or "height")
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
			 * @return {number} Dimension (in pixels)
			 */
			_getDimension = function(t, p, cs) {
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
					a = _dimensions[p],
					i = a.length;
				cs = cs || _getComputedStyle(t, null);
				while (--i > -1) {
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
				}
				return v;
			},

			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {
				if (v == null || v === "" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					v = "0 0";
				}
				var a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];
				if (y == null) {
					y = (x === "center") ? "50%" : "0";
				} else if (y === "center") {
					y = "50%";
				}
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
				if (recObj) {
					recObj.oxp = (x.indexOf("%") !== -1);
					recObj.oyp = (y.indexOf("%") !== -1);
					recObj.oxr = (x.charAt(1) === "=");
					recObj.oyr = (y.charAt(1) === "=");
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));
					recObj.v = v;
				}
				return recObj || v;
			},

			/**
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */
			_parseChange = function(e, b) {
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
			},

			/**
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value
			 */
			_parseVal = function(v, d) {
				return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v);
			},

			/**
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians
			 */
			_parseAngle = function(v, d, p, directionalEnd) {
				var min = 0.000001,
					cap, split, dif, result, isRelative;
				if (v == null) {
					result = d;
				} else if (typeof(v) === "number") {
					result = v;
				} else {
					cap = 360;
					split = v.split("_");
					isRelative = (v.charAt(1) === "=");
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {
						if (directionalEnd) {
							directionalEnd[p] = d + dif;
						}
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					result = d + dif;
				}
				if (result < min && result > -min) {
					result = 0;
				}
				return result;
			},

			_colorLookup = {aqua:[0,255,255],
				lime:[0,255,0],
				silver:[192,192,192],
				black:[0,0,0],
				maroon:[128,0,0],
				teal:[0,128,128],
				blue:[0,0,255],
				navy:[0,0,128],
				white:[255,255,255],
				fuchsia:[255,0,255],
				olive:[128,128,0],
				yellow:[255,255,0],
				orange:[255,165,0],
				gray:[128,128,128],
				purple:[128,0,128],
				green:[0,128,0],
				red:[255,0,0],
				pink:[255,192,203],
				cyan:[0,255,255],
				transparent:[255,255,255,0]},

			_hue = function(h, m1, m2) {
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},

			/**
			 * @private Parses a color (like #9F0, #FF9900, or rgb(255,51,153)) into an array with 3 elements for red, green, and blue. Also handles rgba() values (splits into array of 4 elements of course)
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order.
			 */
			_parseColor = CSSPlugin.parseColor = function(v) {
				var c1, c2, c3, h, s, l;
				if (!v || v === "") {
					return _colorLookup.black;
				}
				if (typeof(v) === "number") {
					return [v >> 16, (v >> 8) & 255, v & 255];
				}
				if (v.charAt(v.length - 1) === ",") { //sometimes a trailing commma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					return _colorLookup[v];
				}
				if (v.charAt(0) === "#") {
					if (v.length === 4) { //for shorthand like #9F0
						c1 = v.charAt(1),
						c2 = v.charAt(2),
						c3 = v.charAt(3);
						v = "#" + c1 + c1 + c2 + c2 + c3 + c3;
					}
					v = parseInt(v.substr(1), 16);
					return [v >> 16, (v >> 8) & 255, v & 255];
				}
				if (v.substr(0, 3) === "hsl") {
					v = v.match(_numExp);
					h = (Number(v[0]) % 360) / 360;
					s = Number(v[1]) / 100;
					l = Number(v[2]) / 100;
					c2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
					c1 = l * 2 - c2;
					if (v.length > 3) {
						v[3] = Number(v[3]);
					}
					v[0] = _hue(h + 1 / 3, c1, c2);
					v[1] = _hue(h, c1, c2);
					v[2] = _hue(h - 1 / 3, c1, c2);
					return v;
				}
				v = v.match(_numExp) || _colorLookup.transparent;
				v[0] = Number(v[0]);
				v[1] = Number(v[1]);
				v[2] = Number(v[2]);
				if (v.length > 3) {
					v[3] = Number(v[3]);
				}
				return v;
			},
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp+")", "gi");

		/**
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function
		 */
		var _getFormatter = function(dflt, clr, collapsible, multi) {
				if (dflt == null) {
					return function(v) {return v;};
				}
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
					numVals = dVals.length,
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
					formatter;
				if (!numVals) {
					return function(v) {return v;};
				}
				if (clr) {
					formatter = function(v) {
						var color, vals, i, a;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						color = (v.match(_colorExp) || [dColor])[0];
						vals = v.split(color).join("").match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
					};
					return formatter;

				}
				formatter = function(v) {
					var vals, a, i;
					if (typeof(v) === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					vals = v.match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + sfx;
				};
				return formatter;
			},

			/**
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function
			 */
			_getEdgeParser = function(props) {
				props = props.split(",");
				return function(t, e, p, cssp, pt, plugin, vars) {
					var a = (e + "").split(" "),
						i;
					vars = {};
					for (i = 0; i < 4; i++) {
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
					}
					return cssp.parse(t, vars, pt, plugin);
				};
			},

			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = Math.round(val);
					} else if (val < min && val > -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = proxy.rotation;
				}
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method.
				if (v === 1) {
					mpt = d.firstMPT;
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt.e = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.e = str;
						}
						mpt = mpt._next;
					}
				}
			},

			/**
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
			 * @param {!string} p property name
			 * @param {(number|string|object)} v value
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
			 */
			MiniPropTween = function(t, p, v, next, r) {
				this.t = t;
				this.p = p;
				this.v = v;
				this.r = r;
				if (next) {
					next._prev = this;
					this._next = next;
				}
			},

			/**
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
			 */
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt && pt !== bpt) {
					if (pt.type <= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i > 0) {
								xp = "xn" + i;
								p = pt.p + "_" + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			},



			/**
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
			 * @param {number} s Starting numeric value
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = r; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},

			/**
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *
			 * @param {!Object} t Target whose property will be tweened
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
			 * @param {string} b Beginning value
			 * @param {string} e Ending value
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
				b = b || dflt || "";
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += ""; //ensures it's a string
				var ba = b.split(", ").join(",").split(" "), //beginning array
					ea = e.split(", ").join(",").split(" "), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, rgba, temp, cv, str;
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
					ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
					ba = (dflt || "").split(" ");
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				for (i = 0; i < l; i++) {
					bv = ba[i];
					ev = ea[i];
					bn = parseFloat(bv);
					//if the value begins with a number (most common). It's fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);

					//if the value is a color
					} else if (clrs && (bv.charAt(0) === "#" || _colorLookup[bv] || _rgbhslExp.test(bv))) {
						str = ev.charAt(ev.length - 1) === "," ? ")," : ")"; //if there's a comma at the end, retain it.
						bv = _parseColor(bv);
						ev = _parseColor(ev);
						rgba = (bv.length + ev.length > 6);
						if (rgba && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) { //old versions of IE don't support rgba().
								rgba = false;
							}
							pt.appendXtra((rgba ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)
								.appendXtra("", bv[1], ev[1] - bv[1], ",", true)
								.appendXtra("", bv[2], ev[2] - bv[2], (rgba ? "," : str), true);
							if (rgba) {
								bv = (bv.length < 4) ? 1 : bv[3];
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
							}
						}

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt["xs" + pt.l] += pt.l ? " " + bv : bv;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
								return pt;
							}
							ni = 0;
							for (xi = 0; xi < bnums.length; xi++) {
								cv = bnums[xi];
								temp = bv.indexOf(cv, ni);
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
								ni = temp + cv.length;
							}
							pt["xs" + pt.l] += bv.substr(ni);
						}
					}
				}
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {
					str = pt.xs0 + pt.data.s;
					for (i = 1; i < pt.l; i++) {
						str += pt["xs" + i] + pt.data["xn" + i];
					}
					pt.e = str + pt["xs" + i];
				}
				if (!pt.l) {
					pt.type = -1;
					pt.xs0 = pt.e;
				}
				return pt.xfirst || pt;
			},
			i = 9;


		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


		/**
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
		 * @param {string=} pfx Prefix (if any)
		 * @param {!number} s Starting value
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)
		 * @param {boolean=} r Round (if true).
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
		 */
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt["xs" + l] += (pad && l) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")
		 * @param {Object=} options An object containing any of the following configuration options:
		 *                      - defaultValue: the default value
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */
		var SpecialProp = function(p, options) {
				options = options || {};
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;
				_specialProps[p] = _specialProps[this.p] = this;
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {
					this.parse = options.parser;
				}
				this.clrs = options.color;
				this.multi = options.multi;
				this.keyword = options.keyword;
				this.dflt = options.defaultValue;
				this.pr = options.priority || 0;
			},

			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
				if (typeof(options) !== "object") {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(","),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i < a.length; i++) {
					options.prefix = (i === 0 && options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			},

			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = function(p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			};


		p = SpecialProp.prototype;

		/**
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element
		 * @param {(string|number|object)} b beginning value
		 * @param {(string|number|object)} e ending (destination) value
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list
		 */
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
				i, ba, ea, l, bi, ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = (ea.length > ba.length) ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
		 * @param {Object=} vars Original vars object that contains the data for parsing.
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
		 *      var start = target.style.width;
		 *      return function(ratio) {
		 *              target.style.width = (start + value * ratio) + "px";
		 *              console.log("set width to " + target.style.width);
		 *          }
		 * }, 0);
		 *
		 * Then, when I do this tween, it will trigger my special property:
		 *
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
		 *
		 * In the example, of course, we're just changing the width, but you can do anything you want.
		 *
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		};






		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari; //Safari has some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead.
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",
			_transformOriginProp = _checkPropPrefix("transformOrigin"),
			_supports3D = (_checkPropPrefix("perspective") !== null),
			Transform = _internals.Transform = function() {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
			},
			_SVGElement = window.SVGElement,
			_useSVGTransformAttr,
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

			_createSVG = function(type, container, attributes) {
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
					reg = /([a-z])([A-Z])/g,
					p;
				for (p in attributes) {
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
				}
				container.appendChild(element);
				return element;
			},
			_docElement = _doc.documentElement,
			_forceSVGTransformAttr = (function() {
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !window.chrome),
					svg, rect, width;
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
					svg = _createSVG("svg", _docElement);
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});
					width = rect.getBoundingClientRect().width;
					rect.style[_transformOriginProp] = "50% 50%";
					rect.style[_transformProp] = "scaleX(0.5)";
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);
				}
				return force;
			})(),
			_parseSVGOrigin = function(e, local, decoratee, absolute) {
				var bbox, v;
				if (!absolute || !(v = absolute.split(" ")).length) {
					bbox = e.getBBox();
					local = _parsePosition(local).split(" ");
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * bbox.width : parseFloat(local[0])) + bbox.x,
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * bbox.height : parseFloat(local[1])) + bbox.y];
				}
				decoratee.xOrigin = parseFloat(v[0]);
				decoratee.yOrigin = parseFloat(v[1]);
				e.setAttribute("data-svg-origin", v.join(" "));
			},

			/**
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element
			 * @param {Object=} cs computed style object (optional)
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
			 */
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
				if (t._gsTransform && rec && !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					isDefault, s, m, i, n, dec, scaleX, scaleY, rotation, skewX;
				if (_transformProp) {
					s = _getStyle(t, _transformPropCSS, cs, true);
				} else if (t.currentStyle) {
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = t.currentStyle.filter.match(_ieGetMatrixExp);
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
				tm.svg = !!(_SVGElement && typeof(t.getBBox) === "function" && t.getCTM && (!t.parentNode || (t.parentNode.getBBox && t.parentNode.getCTM))); //don't just rely on "instanceof _SVGElement" because if the SVG is embedded via an object tag, it won't work (SVGElement is mapped to a different object)
				if (tm.svg) {
					if (isDefault && (t.style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = t.style[_transformProp];
						isDefault = false;
					}
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
					m = t.getAttribute("transform");
					if (isDefault && m && m.indexOf("matrix") !== -1) { //just in case there's a "transform" value specified as an attribute instead of CSS style. Only accept a matrix, though.
						s = m;
						isDefault = 0;
					}
				}
				if (!isDefault) {
					//split the matrix values out into an array (m for matrix)
					m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [];
					i = m.length;
					while (--i > -1) {
						n = Number(m[i]);
						m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
					}
					if (m.length === 16) {
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;

						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(a13, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							a11 = a11*cos+a12*sin;
							t2 = a21*cos+a22*sin;
							a22 = a21*-sin+a22*cos;
							a32 = a31*-sin+a32*cos;
							a21 = t2;
						}

						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY += 180;
						}

						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;
						tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;
						tm.skewX = 0;
						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
						tm.x = a14;
						tm.y = a24;
						tm.z = a34;
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
						}

					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY)) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),
							a = k ? m[0] : 1,
							b = m[1] || 0,
							c = m[2] || 0,
							d = k ? m[3] : 1;
						tm.x = m[4] || 0;
						tm.y = m[5] || 0;
						scaleX = Math.sqrt(a * a + b * b);
						scaleY = Math.sqrt(d * d + c * c);
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
						if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
							if (invX) {
								scaleX *= -1;
								skewX += (rotation <= 0) ? 180 : -180;
								rotation += (rotation <= 0) ? 180 : -180;
							} else {
								scaleY *= -1;
								skewX += (skewX <= 0) ? 180 : -180;
							}
						}
						tm.scaleX = scaleX;
						tm.scaleY = scaleY;
						tm.rotation = rotation;
						tm.skewX = skewX;
						if (_supports3D) {
							tm.rotationX = tm.rotationY = tm.z = 0;
							tm.perspective = defaultTransformPerspective;
							tm.scaleZ = 1;
						}
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a - tm.yOrigin * b);
							tm.y -= tm.yOrigin - (tm.yOrigin * d - tm.xOrigin * c);
						}
					}
					tm.zOrigin = zOrigin;
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {
						if (tm[i] < min) if (tm[i] > -min) {
							tm[i] = 0;
						}
					}
				}
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective);
				if (rec) {
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {
							_removeProp(t.style, _transformProp);
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
							t.removeAttribute("transform");
						}
					}
				}
				return tm;
			},

			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					ang = -t.rotation * _DEG2RAD,
					skew = ang + t.skewX * _DEG2RAD,
					rnd = 100000,
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
					style = this.t.style,
					cs = this.t.currentStyle,
					filters, val;
				if (!cs) {
					return;
				}
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;
				c = -val;
				filters = cs.filter;
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
				var w = this.t.offsetWidth,
					h = this.t.offsetHeight,
					clip = (cs.position !== "absolute"),
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
					ox = t.x + (w * t.xPercent / 100),
					oy = t.y + (h * t.yPercent / 100),
					dx, dy;

				//if transformOrigin is being used, adjust the offset x and y
				if (t.ox != null) {
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
					ox += dx - (dx * a + dy * b);
					oy += dy - (dx * c + dy * d);
				}

				if (!clip) {
					m += ", sizingMethod='auto expand')";
				} else {
					dx = (w / 2);
					dy = (h / 2);
					//translate to ensure that transformations occur around the correct origin (default is center).
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
				}
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
					style.filter = filters.replace(_ieSetMatrixExp, m);
				} else {
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}

				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");
				}

				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;
					dx = t.ieOffsetX || 0;
					dy = t.ieOffsetY || 0;
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
					for (i = 0; i < 4; i++) {
						prop = _margins[i];
						marg = cs[prop];
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
					}
				}
			},

			/* translates a super small decimal to a string WITHOUT scientific notation
			_safeDecimal = function(n) {
				var s = (n < 0 ? -n : n) + "",
					a = s.split("e-");
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
			},
			*/

			_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					style = this.t.style,
					angle = t.rotation,
					rotationX = t.rotationX,
					rotationY = t.rotationY,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					isSVG = t.svg,
					perspective = t.perspective,
					force3D = t.force3D,
					a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t1, t2, transform, comma, zero, skew, rnd;

				//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
				if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX) || (_useSVGTransformAttr && isSVG) || !_supports3D) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

					//2D
					if (angle || t.skewX || isSVG) {
						angle *= _DEG2RAD;
						skew = t.skewX * _DEG2RAD;
						rnd = 100000;
						a11 = Math.cos(angle) * sx;
						a21 = Math.sin(angle) * sx;
						a12 = Math.sin(angle - skew) * -sy;
						a22 = Math.cos(angle - skew) * sy;
						if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(skew);
							t1 = Math.sqrt(1 + t1 * t1);
							a12 *= t1;
							a22 *= t1;
							if (t.skewY) {
								a11 *= t1;
								a21 *= t1;
							}
						}
						if (isSVG) {
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12);
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22);
							min = 0.000001;
							if (x < min) if (x > -min) {
								x = 0;
							}
							if (y < min) if (y > -min) {
								y = 0;
							}
						}
						transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
						if (isSVG && _useSVGTransformAttr) {
							this.t.setAttribute("transform", "matrix(" + transform);
						} else {
							//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
							style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
						}
					} else {
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
					}
					return;

				}
				if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
					min = 0.0001;
					if (sx < min && sx > -min) {
						sx = sz = 0.00002;
					}
					if (sy < min && sy > -min) {
						sy = sz = 0.00002;
					}
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;
					}
				}
				if (angle || t.skewX) {
					angle *= _DEG2RAD;
					cos = a11 = Math.cos(angle);
					sin = a21 = Math.sin(angle);
					if (t.skewX) {
						angle -= t.skewX * _DEG2RAD;
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(t.skewX * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							cos *= t1;
							sin *= t1;
							if (t.skewY) {
								a11 *= t1;
								a21 *= t1;
							}
						}
					}
					a12 = -sin;
					a22 = cos;

				} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;
				} else {
					a11 = a22 = 1;
					a12 = a21 = 0;
				}
				// KEY  INDEX   AFFECTS
				// a11  0       rotation, rotationY, scaleX
				// a21  1       rotation, rotationY, scaleX
				// a31  2       rotationY, scaleX
				// a41  3       rotationY, scaleX
				// a12  4       rotation, skewX, rotationX, scaleY
				// a22  5       rotation, skewX, rotationX, scaleY
				// a32  6       rotationX, scaleY
				// a42  7       rotationX, scaleY
				// a13  8       rotationY, rotationX, scaleZ
				// a23  9       rotationY, rotationX, scaleZ
				// a33  10      rotationY, rotationX, scaleZ
				// a43  11      rotationY, rotationX, perspective, scaleZ
				// a14  12      x, zOrigin, svgOrigin
				// a24  13      y, zOrigin, svgOrigin
				// a34  14      z, zOrigin
				// a44  15
				// rotation: Math.atan2(a21, a11)
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
				// rotationX: Math.atan2(a32, a33)
				a33 = 1;
				a13 = a23 = a31 = a32 = a41 = a42 = 0;
				a43 = (perspective) ? -1 / perspective : 0;
				zOrigin = t.zOrigin;
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.
				comma = ",";
				zero = "0";
				angle = rotationY * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					a31 = -sin;
					a41 = a43*-sin;
					a13 = a11*sin;
					a23 = a21*sin;
					a33 = cos;
					a43 *= cos;
					a11 *= cos;
					a21 *= cos;
				}
				angle = rotationX * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					a32 = a33*sin;
					a42 = a43*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a33*cos;
					a43 = a43*cos;
					a12 = t1;
					a22 = t2;
				}
				if (sz !== 1) {
					a13*=sz;
					a23*=sz;
					a33*=sz;
					a43*=sz;
				}
				if (sy !== 1) {
					a12*=sy;
					a22*=sy;
					a32*=sy;
					a42*=sy;
				}
				if (sx !== 1) {
					a11*=sx;
					a21*=sx;
					a31*=sx;
					a41*=sx;
				}

				if (zOrigin || isSVG) {
					if (zOrigin) {
						x += a13*-zOrigin;
						y += a23*-zOrigin;
						z += a33*-zOrigin+zOrigin;
					}
					if (isSVG) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12);
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22);
					}
					if (x < min && x > -min) {
						x = zero;
					}
					if (y < min && y > -min) {
						y = zero;
					}
					if (z < min && z > -min) {
						z = 0; //don't use string because we calculate perspective later and need the number.
					}
				}

				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (rotationX || rotationY) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {
					transform += ",0,0,0,0,1,0,";
				}
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

				style[_transformProp] = transform;
			};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;
			var m1 = cssp._transform = _getTransform(t, _cs, true, vars.parseTransform),
				style = t.style,
				min = 0.000001,
				i = _transformProps.length,
				v = vars,
				endRotations = {},
				m2, skewY, copy, orig, has3D, hasChange, dr;
			if (typeof(v.transform) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = v.transform;
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";
				_doc.body.appendChild(_tempDiv);
				m2 = _getTransform(_tempDiv, null, false);
				_doc.body.removeChild(_tempDiv);
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
					x:_parseVal(v.x, m1.x),
					y:_parseVal(v.y, m1.y),
					z:_parseVal(v.z, m1.z),
					xPercent:_parseVal(v.xPercent, m1.xPercent),
					yPercent:_parseVal(v.yPercent, m1.yPercent),
					perspective:_parseVal(v.transformPerspective, m1.perspective)};
				dr = v.directionalRotation;
				if (dr != null) {
					if (typeof(dr) === "object") {
						for (copy in dr) {
							v[copy] = dr[copy];
						}
					} else {
						v.rotation = dr;
					}
				}
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
					m2.x = 0;
					m2.xPercent = _parseVal(v.x, m1.xPercent);
				}
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
					m2.y = 0;
					m2.yPercent = _parseVal(v.y, m1.yPercent);
				}

				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
				if (_supports3D) {
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}
				m2.skewX = (v.skewX == null) ? m1.skewX : _parseAngle(v.skewX, m1.skewX);

				//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
				m2.skewY = (v.skewY == null) ? m1.skewY : _parseAngle(v.skewY, m1.skewY);
				if ((skewY = m2.skewY - m1.skewY)) {
					m2.skewX += skewY;
					m2.rotation += skewY;
				}
			}
			if (_supports3D && v.force3D != null) {
				m1.force3D = v.force3D;
				hasChange = true;
			}

			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {
				m2.scaleZ = 1; //no need to tween scaleZ.
			}

			while (--i > -1) {
				p = _transformProps[i];
				orig = m2[p] - m1[p];
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
					hasChange = true;
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);
					if (p in endRotations) {
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()
					pt.plugin = plugin;
					cssp._overwriteProps.push(pt.n);
				}
			}

			orig = v.transformOrigin;
			if (m1.svg && (orig || v.svgOrigin)) {
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin);
				pt = new CSSPropTween(m1, "xOrigin", m1.xOrigin, m2.xOrigin - m1.xOrigin, pt, -1, "transformOrigin");
				pt.b = m1.xOrigin;
				pt.e = pt.xs0 = m2.xOrigin;
				pt = new CSSPropTween(m1, "yOrigin", m1.yOrigin, m2.yOrigin - m1.yOrigin, pt, -1, "transformOrigin");
				pt.b = m1.yOrigin;
				pt.e = pt.xs0 = m2.yOrigin;
				orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {
					hasChange = true;
					p = _transformOriginProp;
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin");
					pt.b = style[p];
					pt.plugin = plugin;
					if (_supports3D) {
						copy = m1.zOrigin;
						orig = orig.split(" ");
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;
						pt.xs0 = pt.e = m1.zOrigin;
					} else {
						pt.xs0 = pt.e = orig;
					}

					//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {
					_parsePosition(orig + "", m1);
				}
			}
			if (hasChange) {
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}
			return pt;
		}, prefix:true});

		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});

		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			e = this.format(e);
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
				style = t.style,
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
			w = parseFloat(t.offsetWidth);
			h = parseFloat(t.offsetHeight);
			ea1 = e.split(" ");
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix
					props[i] = _checkPropPrefix(props[i]);
				}
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
				if (bs.indexOf(" ") !== -1) {
					bs2 = bs.split(" ");
					bs = bs2[0];
					bs2 = bs2[1];
				}
				es = es2 = ea1[i];
				bn = parseFloat(bs);
				bsfx = bs.substr((bn + "").length);
				rel = (es.charAt(1) === "=");
				if (rel) {
					en = parseInt(es.charAt(0)+"1", 10);
					es = es.substr(2);
					en *= parseFloat(es);
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
				} else {
					en = parseFloat(es);
					esfx = es.substr((en + "").length);
				}
				if (esfx === "") {
					esfx = _suffixMap[p] || bsfx;
				}
				if (esfx !== bsfx) {
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
					if (esfx === "%") {
						bs = (hn / w * 100) + "%";
						bs2 = (vn / h * 100) + "%";
					} else if (esfx === "em") {
						em = _convertToPixels(t, "borderLeft", 1, "em");
						bs = (hn / em) + "em";
						bs2 = (vn / em) + "em";
					} else {
						bs = hn + "px";
						bs2 = vn + "px";
					}
					if (rel) {
						es = (parseFloat(bs) + en) + esfx;
						es2 = (parseFloat(bs2) + en) + esfx;
					}
				}
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
			}
			return pt;
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
			var bp = "background-position",
				cs = (_cs || _getComputedStyle(t, null)),
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				ba, ea, i, pct, overlap, src;
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1)) {
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
				if (src && src !== "none") {
					ba = bs.split(" ");
					ea = es.split(" ");
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;
					while (--i > -1) {
						bs = ba[i];
						pct = (bs.indexOf("%") !== -1);
						if (pct !== (ea[i].indexOf("%") !== -1)) {
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
						}
					}
					bs = ba.join(" ");
				}
			}
			return this.parseComplex(t.style, bs, es, pt, plugin);
		}, formatter:_parsePosition});
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:_parsePosition});
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
		_registerComplexSpecialProp("transformStyle", {prefix:true});
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
		_registerComplexSpecialProp("userSelect", {prefix:true});
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;
				delim = _ieVers < 8 ? " " : ",";
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
				e = this.format(e).split(",").join(delim);
			} else {
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
				e = this.format(e);
			}
			return this.parseComplex(t.style, b, e, pt, plugin);
		}});
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
				return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
			}, color:true, formatter:function(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			}});
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
			var s = t.style,
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
		}});

		//opacity-related
		var _setIEOpacityRatio = function(v) {
				var t = this.t, //refers to the element's style property
					filters = t.filter || _getStyle(this.data, "filter") || "",
					val = (this.s + this.c * v) | 0,
					skip;
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
						t.removeAttribute("filter");
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
				}
				if (!skip) {
					if (this.xn1) {
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}
					} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
				}
			};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				style = t.style,
				isAutoAlpha = (p === "autoAlpha");
			if (typeof(e) === "string" && e.charAt(1) === "=") {
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
			}
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;
			}
			if (_supportsOpacity) {
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);
			} else {
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.
				pt.type = 2;
				pt.b = "alpha(opacity=" + pt.s + ")";
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
				pt.data = t;
				pt.plugin = plugin;
				pt.setRatio = _setIEOpacityRatio;
			}
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";
				cssp._overwriteProps.push(pt.n);
				cssp._overwriteProps.push(p);
			}
			return pt;
		}});


		var _removeProp = function(s, p) {
				if (p) {
					if (s.removeProperty) {
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;
						}
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				}
			},
			_setClassNameRatio = function(v) {
				this.t._gsClassPT = this;
				if (v === 1 || v === 0) {
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);
					var mpt = this.data, //first MiniPropTween
						s = this.t.style;
					while (mpt) {
						if (!mpt.v) {
							_removeProp(s, mpt.p);
						} else {
							s[mpt.p] = mpt.v;
						}
						mpt = mpt._next;
					}
					if (v === 1 && this.t._gsClassPT === this) {
						this.t._gsClassPT = null;
					}
				} else if (this.t.getAttribute("class") !== this.e) {
					this.t.setAttribute("class", this.e);
				}
			};
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				difData, bs, cnpt, cnptLookup, mpt;
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClassNameRatio;
			pt.pr = -11;
			_hasPriority = true;
			pt.b = b;
			bs = _getAllStyles(t, _cs);
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;
			if (cnpt) {
				cnptLookup = {};
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {
					cnptLookup[mpt.p] = 1;
					mpt = mpt._next;
				}
				cnpt.setRatio(1);
			}
			t._gsClassPT = pt;
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			t.setAttribute("class", pt.e);
			difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
			t.setAttribute("class", b);
			pt.data = difData.firstMPT;
			t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
			pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			return pt;
		}});


		var _setClearPropsRatio = function(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
					transformParse = _specialProps.transform.parse,
					a, p, i, clearTransform, transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
						}
						delete this.t._gsTransform;
					}
				}

			}
		};
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClearPropsRatio;
			pt.e = e;
			pt.pr = -10;
			pt.data = cssp._tween;
			_hasPriority = true;
			return pt;
		}});

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}








		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function(target, vars, tween) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = target;
			this._tween = tween;
			this._vars = vars;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof(vars) === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};


		p.parse = function(target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);

				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = (typeof(es) === "string");
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

					} else if (isStr && (es.indexOf(" ") !== -1 || es.indexOf(",") !== -1)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = (p !== "opacity") ? 0 : 1;
								bsfx = "";
							}
						}

						rel = (isStr && es.charAt(1) === "=");
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}

							} else if (esfx === "em") {
								bn /= _convertToPixels(target, p, 1, "em");

							//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};


		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.e;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
		 * @private
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you
		 * want and it won't create duplicate CSSPropTweens.
		 *
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */
		p._enableTransforms = function(threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};

		var lazySet = function(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function(t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function(pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};



		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function(e, props, targets) {
				var children, i, child, type;
				if (e.slice) {
					i = e.length;
					while (--i > -1) {
						_getChildStyles(e[i], props, targets);
					}
					return;
				}
				children = e.childNodes;
				i = children.length;
				while (--i > -1) {
					child = children[i];
					type = child.type;
					if (child.style) {
						props.push(_getAllStyles(child));
						if (targets) {
							targets.push(child);
						}
					}
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
						_getChildStyles(child, props, targets);
					}
				}
			};

		/**
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
		 * and it would create other problems. For example:
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *
		 * @param {Object} target object to be tweened
		 * @param {number} Duration in seconds (or frames for frames-based tweens)
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
		 * @return {Array} An array of TweenLite instances
		 */
		CSSPlugin.cascadeTo = function(target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = TweenLite._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;

	}, true);

	
	
	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * RoundPropsPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
				propName: "roundProps",
				priority: -1,
				API: 2,

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {
					this._tween = tween;
					return true;
				}

			}),
			p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function() {
			var tween = this._tween,
				rp = (tween.vars.roundProps instanceof Array) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
				i = rp.length,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				prop, pt, next;
			while (--i > -1) {
				lookup[rp[i]] = 1;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._roundProps(lookup, true);
					} else if (pt.n === prop) {
						this._add(pt.t, prop, pt.s, pt.c);
						//remove from linked list
						if (next) {
							next._prev = pt._prev;
						}
						if (pt._prev) {
							pt._prev._next = next;
						} else if (tween._firstPT === pt) {
							tween._firstPT = next;
						}
						pt._next = pt._prev = null;
						tween._propLookup[prop] = rpt;
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c) {
			this._addTween(target, p, s, s + c, p, true);
			this._overwriteProps.push(p);
		};

	}());










/*
 * ----------------------------------------------------------------
 * AttrPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "attr",
		API: 2,
		version: "0.3.3",

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			var p, start, end;
			if (typeof(target.setAttribute) !== "function") {
				return false;
			}
			this._target = target;
			this._proxy = {};
			this._start = {}; // we record start and end values exactly as they are in case they're strings (not numbers) - we need to be able to revert to them cleanly.
			this._end = {};
			for (p in value) {
				this._start[p] = this._proxy[p] = start = target.getAttribute(p);
				end = this._addTween(this._proxy, p, parseFloat(start), value[p], p);
				this._end[p] = end ? end.s + end.c : value[p];
				this._overwriteProps.push(p);
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			this._super.setRatio.call(this, ratio);
			var props = this._overwriteProps,
				i = props.length,
				lookup = (ratio === 1) ? this._end : ratio ? this._proxy : this._start,
				p;
			while (--i > -1) {
				p = props[i];
				this._target.setAttribute(p, lookup[p] + "");
			}
		}

	});










/*
 * ----------------------------------------------------------------
 * DirectionalRotationPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;







	
	
	
	
/*
 * ----------------------------------------------------------------
 * EasePack
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, RoughEase, _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function(steps) {
			return new SteppedEase(steps);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
		
	}, true);


});

if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function(window, moduleName) {

		"use strict";
		var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							if (typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (ns === moduleName && typeof(module) !== "undefined" && module.exports){ //node
								module.exports = cl;
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			_blankArray = [],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame),
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function() {
				if (_id !== null) {
					_self.sleep();
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF && _self.frame < 5) {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {
					_ticker.wake();
				}
				setTimeout(_checkTimeout, 2000);
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				var pauseTime = this._pauseTime,
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			return this._uncache(false);
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					this.render((tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale), true, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(-this._delay);
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.16.1";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},

			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (_onOverwrite(curTween, tween) && curTween._enabled(false, false)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},

			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null)) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:true, n:p, pg:true, pr:plugin._priority};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}

				} else {
					this._firstPT = propLookup[p] = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === "function"), n:p, pg:false, pr:0};
					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
					pt.c = (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : (Number(v) - pt.s) || 0;
				}
				if (pt) if (pt._next) {
					pt._next._prev = pt;
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration) {
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i])) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if (!_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(-this._delay);
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.10.1";
		TweenPlugin.API = 2;
		p._firstPT = null;

		p._addTween = function(target, prop, start, end, overwriteProp, round) {
			var c, pt;
			if (end != null && (c = (typeof(end) === "number" || end.charAt(1) !== "=") ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
				this._firstPT = pt = {_next:this._firstPT, t:target, p:prop, s:start, c:c, f:(typeof(target[prop]) === "function"), n:overwriteProp || prop, r:round};
				if (pt._next) {
					pt._next._prev = pt;
				}
				return pt;
			}
		};

		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val;
			while (pt) {
				val = pt.c * v + pt.s;
				if (pt.r) {
					val = Math.round(val);
				} else if (val < min) if (val > -min) { //prevents issues with converting very small numbers to strings in the browser
					val = 0;
				}
				if (pt.f) {
					pt.t[pt.p](val);
				} else {
					pt.t[pt.p] = val;
				}
				pt = pt._next;
			}
		};

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._roundProps = function(lookup, value) {
			var pt = this._firstPT;
			while (pt) {
				if (lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ])) { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					pt.r = value;
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_roundProps", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: com.greensock." + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/luke.hedger/dev/Experiments/040715/vendor/hammerjs/hammer.js":[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],"/Users/luke.hedger/dev/Experiments/040715/vendor/page/page.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.page=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /* globals require, module */

/**
   * Module dependencies.
   */

  var pathtoRegexp = require('path-to-regexp');

  /**
   * Module exports.
   */

  module.exports = page;

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var location = window.history.location || window.location;

  /**
   * Perform initial dispatch.
   */

  var dispatch = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
  * HashBang option
  */

  var hashbang = false;

  /**
   * Previous context, for capturing
   * page exit events.
   */

  var prevContext;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
    // show <path> with [state]
    } else if ('string' == typeof path) {
      'string' === typeof fn
        ? page.redirect(path, fn)
        : page.show(path, fn);
    // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];
  page.exits = [];

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path){
    if (0 === arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options){
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) window.addEventListener('click', onclick, false);
    if (true === options.hashbang) hashbang = true;
    if (!dispatch) return;
    var url = (hashbang && ~location.hash.indexOf('#!'))
      ? location.hash.substr(2) + location.search
      : location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function(){
    if (!running) return;
    running = false;
    window.removeEventListener('click', onclick, false);
    window.removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch){
    var ctx = new Context(path, state);
    if (false !== dispatch) page.dispatch(ctx);
    if (false !== ctx.handled) ctx.pushState();
    return ctx;
  };

  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {String} from - if param 'to' is undefined redirects to 'from'
   * @param {String} [to]
   * @api public
   */
  page.redirect = function(from, to) {
    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page(from, function (e) {
        setTimeout(function() {
          page.replace(to);
        },0);
      });
    }

    // Wait for the push state and replace it with another
    if('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
          page.replace(from);
      },0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */

  page.replace = function(path, state, init, dispatch){
    var ctx = new Context(path, state);
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) page.dispatch(ctx);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx){
    var prev = prevContext;
    var i = 0;
    var j = 0;

    prevContext = ctx;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];
      if (!fn) return unhandled(ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;

    if (hashbang) {
      current = base + location.hash.replace('#!','');
    } else {
      current = location.pathname + location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    location.href = ctx.canonicalPath;
  }

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  page.exit = function(path, fn) {
    if (typeof path == 'function') {
      return page.exit('*', path);
    };

    var route = new Route(path);
    for (var i = 1; i < arguments.length; ++i) {
      page.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
  * Remove URL encoding from the given `str`.
  * Accommodates whitespace in both x-www-form-urlencoded
  * and regular percent-encoded form.
  *
  * @param {str} URL component to decode
  */
  function decodeURLEncodedURIComponent(str) {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    path = decodeURLEncodedURIComponent(path);
    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i
      ? path.slice(i + 1)
      : '';
    this.pathname = ~i
      ? path.slice(0, i)
      : path;
    this.params = [];

    // fragment
    this.hash = '';
    if (!~this.path.indexOf('#')) return;
    var parts = this.path.split('#');
    this.path = parts[0];
    this.hash = parts[1] || '';
    this.querystring = this.querystring.split('#')[0];
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function(){
    history.pushState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function(){
    history.replaceState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(this.path,
      this.keys = [],
      options.sensitive,
      options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn){
    var self = this;
    return function(ctx, next){
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Array} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params){
    var keys = this.keys,
        qsIndex = path.indexOf('?'),
        pathname = ~qsIndex
          ? path.slice(0, qsIndex)
          : path,
        m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];

      var val = 'string' === typeof m[i]
        ? decodeURIComponent(m[i])
        : m[i];

      if (key) {
        params[key.name] = undefined !== params[key.name]
          ? params[key.name]
          : val;
      } else {
        params.push(val);
      }
    }

    return true;
  };

  /**
   * Handle "populate" events.
   */

  function onpopstate(e) {
    if (e.state) {
      var path = e.state.path;
      page.replace(path, e.state);
    }
  }

  /**
   * Handle "click" events.
   */

  function onclick(e) {
    if (1 != which(e)) return;
    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    var el = e.target;
    while (el && 'A' != el.nodeName) el = el.parentNode;
    if (!el || 'A' != el.nodeName) return;

    // Ignore if tag has a "download" attribute
    if (el.getAttribute("download")) return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (el.pathname === location.pathname && (el.hash || '#' === link)) return;

    // Check for mailto: in the href
    if (link && link.indexOf("mailto:") > -1) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;

    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // same page
    var orig = path;

    path = path.replace(base, '');

    if (base && orig === path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null === e.which
      ? e.button
      : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return (href && (0 === href.indexOf(origin)));
  }

  page.sameOrigin = sameOrigin;

},{"path-to-regexp":2}],2:[function(require,module,exports){
/**
 * Expose `pathtoRegexp`.
 */
module.exports = pathtoRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match already escaped characters that would otherwise incorrectly appear
  // in future matches. This allows the user to escape special characters that
  // shouldn't be transformed.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that should always be escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
var attachKeys = function (re, keys) {
  re.keys = keys;

  return re;
};

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array should be passed in, which will contain the placeholder key
 * names. For example `/user/:id` will then contain `["id"]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 keys
 * @param  {Object}                options
 * @return {RegExp}
 */
function pathtoRegexp (path, keys, options) {
  if (keys && !Array.isArray(keys)) {
    options = keys;
    keys = null;
  }

  keys = keys || [];
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var index = 0;

  if (path instanceof RegExp) {
    // Match all capturing groups of a regexp.
    var groups = path.source.match(/\((?!\?)/g) || [];

    // Map all the matches to their numeric keys and push into the keys.
    keys.push.apply(keys, groups.map(function (match, index) {
      return {
        name:      index,
        delimiter: null,
        optional:  false,
        repeat:    false
      };
    }));

    // Return the source back to the user.
    return attachKeys(path, keys);
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    // Generate a new regexp instance by joining all the parts together.
    return attachKeys(new RegExp('(?:' + path.join('|') + ')', flags), keys);
  }

  // Alter the path string into a usable regexp.
  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {
    // Avoiding re-escaping escaped characters.
    if (escaped) {
      return escaped;
    }

    // Escape regexp special characters.
    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    // Escape the prefix character.
    prefix = prefix ? '\\' + prefix : '';

    // Match using the custom capturing group, or fallback to capturing
    // everything up to the next slash (or next period if the param was
    // prefixed with a period).
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    // Allow parameters to be repeated more than once.
    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    // Allow a parameter to be optional.
    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  });

  // Check whether the path ends in a slash as it alters some match behaviour.
  var endsWithSlash = path[path.length - 1] === '/';

  // In non-strict mode we allow an optional trailing slash in the match. If
  // the path to match already ended with a slash, we need to remove it for
  // consistency. The slash is only valid at the very end of a path match, not
  // anywhere in the middle. This is important for non-ending mode, otherwise
  // "/test/" will match "/test//route".
  if (!strict) {
    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\/(?=$))?';
  }

  // In non-ending mode, we need prompt the capturing groups to match as much
  // as possible by using a positive lookahead for the end or next path segment.
  if (!end) {
    path += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + path + (end ? '$' : ''), flags), keys);
};

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"path-to-regexp":"/Users/luke.hedger/dev/Experiments/040715/node_modules/path-to-regexp/index.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-events-tap/ractive-events-tap.js":[function(require,module,exports){
/*

	ractive-events-tap
	==================

	Version 0.1.2.

	On mobile devices, using `on-click` isn't good enough. Tapping the
	touchscreen will fire a simulated click event, but only after a 300
	millisecond delay, which makes your app feel sluggish. It also
	causes the tapped area to highlight, which in most cases looks a
	bit messy.

	Instead, use `on-tap`. When you tap an area, the simulated click
	event will be prevented, and the user's action is responded to
	instantly. The `on-tap` event also differs from `on-click` in that
	the click event will (frankly rather bizarrely) fire even if you
	hold the mouse down over a single element for several seconds and
	waggle it about.

	Pointer events are also supported, as is pressing the spacebar when
	the relevant element is focused (which triggers a click event, and
	is good for accessibility).

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-events-tap.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-events-tap' );

	Add a tap event in the normal fashion:

	    <div on-tap='foo'>tap me!</div>

	Then add a handler:

	    ractive.on( 'foo', function ( event ) {
	      alert( 'tapped' );
	    });

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-events-tap plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var tap = function ( node, fire ) {
		var mousedown, touchstart, focusHandler, distanceThreshold, timeThreshold, preventMousedownEvents, preventMousedownTimeout;

		distanceThreshold = 5; // maximum pixels pointer can move before cancel
		timeThreshold = 400;   // maximum milliseconds between down and up before cancel

		mousedown = function ( event ) {
			var currentTarget, x, y, pointerId, up, move, cancel;

			if ( preventMousedownEvents ) {
				return;
			}

			if ( event.which !== undefined && event.which !== 1 ) {
				return;
			}

			x = event.clientX;
			y = event.clientY;
			currentTarget = this;
			// This will be null for mouse events.
			pointerId = event.pointerId;

			up = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				if ( ( Math.abs( event.clientX - x ) >= distanceThreshold ) || ( Math.abs( event.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'MSPointerUp', up, false );
				document.removeEventListener( 'MSPointerMove', move, false );
				document.removeEventListener( 'MSPointerCancel', cancel, false );
				node.removeEventListener( 'pointerup', up, false );
				document.removeEventListener( 'pointermove', move, false );
				document.removeEventListener( 'pointercancel', cancel, false );
				node.removeEventListener( 'click', up, false );
				document.removeEventListener( 'mousemove', move, false );
			};

			if ( window.navigator.pointerEnabled ) {
				node.addEventListener( 'pointerup', up, false );
				document.addEventListener( 'pointermove', move, false );
				document.addEventListener( 'pointercancel', cancel, false );
			} else if ( window.navigator.msPointerEnabled ) {
				node.addEventListener( 'MSPointerUp', up, false );
				document.addEventListener( 'MSPointerMove', move, false );
				document.addEventListener( 'MSPointerCancel', cancel, false );
			} else {
				node.addEventListener( 'click', up, false );
				document.addEventListener( 'mousemove', move, false );
			}

			setTimeout( cancel, timeThreshold );
		};

		if ( window.navigator.pointerEnabled ) {
			node.addEventListener( 'pointerdown', mousedown, false );
		} else if ( window.navigator.msPointerEnabled ) {
			node.addEventListener( 'MSPointerDown', mousedown, false );
		} else {
			node.addEventListener( 'mousedown', mousedown, false );
		}


		touchstart = function ( event ) {
			var currentTarget, x, y, touch, finger, move, up, cancel;

			if ( event.touches.length !== 1 ) {
				return;
			}

			touch = event.touches[0];

			x = touch.clientX;
			y = touch.clientY;
			currentTarget = this;

			finger = touch.identifier;

			up = function ( event ) {
				var touch;

				touch = event.changedTouches[0];
				if ( touch.identifier !== finger ) {
					cancel();
				}

				event.preventDefault();  // prevent compatibility mouse event

				// for the benefit of mobile Firefox and old Android browsers, we need this absurd hack.
				preventMousedownEvents = true;
				clearTimeout( preventMousedownTimeout );

				preventMousedownTimeout = setTimeout( function () {
					preventMousedownEvents = false;
				}, 400 );

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				var touch;

				if ( event.touches.length !== 1 || event.touches[0].identifier !== finger ) {
					cancel();
				}

				touch = event.touches[0];
				if ( ( Math.abs( touch.clientX - x ) >= distanceThreshold ) || ( Math.abs( touch.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'touchend', up, false );
				window.removeEventListener( 'touchmove', move, false );
				window.removeEventListener( 'touchcancel', cancel, false );
			};

			node.addEventListener( 'touchend', up, false );
			window.addEventListener( 'touchmove', move, false );
			window.addEventListener( 'touchcancel', cancel, false );

			setTimeout( cancel, timeThreshold );
		};

		node.addEventListener( 'touchstart', touchstart, false );


		// native buttons, and <input type='button'> elements, should fire a tap event
		// when the space key is pressed
		if ( node.tagName === 'BUTTON' || node.type === 'button' ) {
			focusHandler = function () {
				var blurHandler, keydownHandler;

				keydownHandler = function ( event ) {
					if ( event.which === 32 ) { // space key
						fire({
							node: node,
							original: event
						});
					}
				};

				blurHandler = function () {
					node.removeEventListener( 'keydown', keydownHandler, false );
					node.removeEventListener( 'blur', blurHandler, false );
				};

				node.addEventListener( 'keydown', keydownHandler, false );
				node.addEventListener( 'blur', blurHandler, false );
			};

			node.addEventListener( 'focus', focusHandler, false );
		}


		return {
			teardown: function () {
				node.removeEventListener( 'pointerdown', mousedown, false );
				node.removeEventListener( 'MSPointerDown', mousedown, false );
				node.removeEventListener( 'mousedown', mousedown, false );
				node.removeEventListener( 'touchstart', touchstart, false );
				node.removeEventListener( 'focus', focusHandler, false );
			}
		};
	};

	Ractive.events.tap = tap;

}));

},{"./../ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-touch/index.js":[function(require,module,exports){
;(function (root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['ractive', 'hammerjs'], factory);
  }

  else if (typeof module !== 'undefined') {
    factory(require("./../ractive/ractive.js"), require("./../hammerjs/hammer.js"));
  }

  else {
    factory(root.Ractive, root.Hammer);
  }

}(this, function (Ractive, Hammer) {

  // Check the recognizers documentation.
  // http://hammerjs.github.io/recognizer-tap

  var defaults = {
    tap: {
      recognizerClass: Hammer.Tap,
      options: {
        time: 500
      },
      events: [
        'tap' 
      ]
    },
    doubletap: {
      recognizerClass: Hammer.Tap,
      options: {
        taps: 2,
        event: 'doubletap'
      },
      recognizeWith: ['tap'],
      events: [
        'doubletap' 
      ]
    },
    swipe: {
      recognizerClass: Hammer.Swipe,
      options: {},
      events: [
        'swipe',
        'swipeleft',
        'swiperight',
        'swipeup',
        'swipedown' 
      ]
    },
    pan: {
      recognizerClass: Hammer.Pan,
      options: {
        direction: Hammer.DIRECTION_HORIZONTAL
      },
      recognizeWith: ['swipe'],
      events: [
        'pan',
        'panstart',
        'panmove',
        'panend',
        'pancancel',
        'panleft',
        'panright',
        'panup',
        'pandown' 
      ]
    },
    press: {
      recognizerClass: Hammer.Press,
      options: {},
      events: [
        'press' 
      ]
    },
    rotate: {
      recognizerClass: Hammer.Rotate,
      options: {},
      events: [
        'rotate',
        'rotatestart',
        'rotatemove',
        'rotateend',
        'rotatecancel' 
      ]
    },
    pinch: {
      recognizerClass: Hammer.Pinch,
      options: {},
      recognizeWith: ['rotate'],
      events: [
        'pinch',
        'pinchstart',
        'pinchmove',
        'pinchend',
        'pinchcancel',
        'pinchin',
        'pinchout' 
      ]
    }
  };

  var aliases;

  // bind all events using buildEvent
  for (var recognizerName in defaults) {
    if (!defaults.hasOwnProperty(recognizerName)) continue;
    
    var events = defaults[recognizerName].events;
    for (var i = 0; i < events.length; i++) {
      buildEvent(events[i], recognizerName, defaults[recognizerName]);
    }
  }

  /**
   * buildEvent : buildEvent(event, recognizerName, config)
   * (private) registers an event handler for buildEvent.
   *
   *     buildEvent('panstart', 'pan', { ... });
   */

  function buildEvent(eventName, recognizerName, config) {
    Ractive.events[eventName] = buildEventHandler(eventName, recognizerName, config);
  }

  /**
   * buildEventHandler() : buildEventHandler(event, recognizerName, config)
   * (private) Creates the event handler for a given `eventName` that will be
   * registered to `Ractive.events`.
   */

  function buildEventHandler(eventName, recognizerName, config) {
    return function (node, fire) {
      var hammerManager = getHammerManager(node);

      var recognizerExists = (hammerManager.get(recognizerName) !== null);

      if (!recognizerExists) {
        // init with default options
        var recognizer = new config.recognizerClass(config.options);

        // Hammer.Recognizer.set merges it on top of the defaults supplied above
        var options = parseOptions(node, recognizerName);
        if (options)
          recognizer.set(options);

        hammerManager.add(recognizer);
        
        updateRecognizeWith(hammerManager);
      }

      // register the handler
      hammerManager.on(eventName, function (e) {
        fire({
          node: node,
          original: e
        });
      });

      // handle exits
      function teardown() {
        getHammerManager(node).destroy();
        delete node._hammer;
      }

      return { teardown: teardown };
    };
  }

  /**
   * updateRecognizeWith : updateRecognizeWith(hammerManager)
   * (private) Sets recognizeWith if defaults have it
   *
   * Since we add recognizers dynamically and without any strict order,
   *  we need to guard against trying to set a requireWith for a recognizer
   *  that haven't been created yet.
   * 
   */
  function updateRecognizeWith(hammerManager) {
    for (var i = 0; i < hammerManager.recognizers.length; i++) {
      var recognizer = hammerManager.recognizers[i];
      var recognizerName = recognizer.options.event;

      if (!defaults[recognizerName].hasOwnProperty('recognizeWith')) continue;
      
      var recognizeWiths = defaults[recognizerName].recognizeWith;
      for (var k = 0; k < recognizeWiths.length; k++) {
        // Verify that the recgonizer we're trying to depend on is really there
        if (!hammerManager.get(recognizeWiths[k])) continue;

        // It's safe to recognizeWith multiple times for the same recognizer
        recognizer.recognizeWith(recognizeWiths[k]);
      }
    }
  }

  /**
   * parseOptions : parseOptions(node, key)
   * (private) Returns options for a given DOM node.
   *
   *     node = <div data-swipe-direction='left' data-swipe-threshold='2'>
   *
   *     parseOptions(node, 'swipe')
   *     => { direction: 'left', threshold: 2 }
   */

  function parseOptions(node, key) {
    var attrs = node.attributes,
        output,
        re = new RegExp("^(?:data-)?"+key+"-(.*)$");

    for (var i = attrs.length-1; i >= 0; i--) {
      var attr = attrs[i],
          m = attr.name.match(re);

      if (!m) continue;
      if (!output) output = {};
      output[m[1]] = parseHammerValue(attr.value, m[1]);
    }

    return output;
  }

  /**
   * parseHammerValue : parseHammerValue(str, key)
   * (private) Value-izes a given string `str`, converting it to a number as
   * needed. If `key` is given, it can also resolve aliases for that given
   * key.
   *
   * Used by `getData()`. 
   *
   *     parseHammerValue("100")   => 100
   *     parseHammerValue("right") => "right"
   *     parseHammerValue("right", "direction") => Hammer.DIRECTION_RIGHT
   */

  function parseHammerValue(str, key) {
    if (str.match && str.match(/^-?\d+(?:\.\d+)?$/)) return +str;
    return (aliases[key] && aliases[key][str]) ||
      aliases.all[str] || str;
  }

  /*
   * Aliases for `val()`.
   */

  aliases = {
    all: {
      'true': true,
      'false': false,
      'undefined': undefined,
      'null': null
    },
    direction: {
      'none': Hammer.DIRECTION_NONE,
      'all': Hammer.DIRECTION_ALL,
      'up': Hammer.DIRECTION_UP,
      'down': Hammer.DIRECTION_DOWN,
      'left': Hammer.DIRECTION_LEFT,
      'right': Hammer.DIRECTION_RIGHT,
      'horizontal': Hammer.DIRECTION_HORIZONTAL,
      'vertical': Hammer.DIRECTION_VERTICAL
    }
  };

  /**
   * getHammerManager : getHammerManager(node)
   * (private) Returns the `HammerManager` instance for the given node.
   */

  function getHammerManager(node) {
    if (node._hammer) return node._hammer;

    node._hammer = new Hammer.Manager(node, {recognizers: []});
    return node._hammer;
  }


  return {defaults: defaults};

}));

},{"./../hammerjs/hammer.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/hammerjs/hammer.js","./../ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-transitions-fade/ractive-transitions-fade.js":[function(require,module,exports){
/*

	ractive-transitions-fade
	========================

	Version 0.1.2.

	This plugin does exactly what it says on the tin - it fades elements
	in and out, using CSS transitions. You can control the following
	properties: `duration`, `delay` and `easing` (which must be a valid
	CSS transition timing function, and defaults to `linear`).

	The `duration` property is in milliseconds, and defaults to 300 (you
	can also use `fast` or `slow` instead of a millisecond value, which
	equate to 200 and 600 respectively). As a shorthand, you can use
	`intro='fade:500'` instead of `intro='fade:{"duration":500}'` - this
	applies to many other transition plugins as well.

	If an element has an opacity other than 1 (whether directly, because
	of an inline style, or indirectly because of a CSS rule), it will be
	respected. You can override the target opacity of an intro fade by
	specifying a `to` property between 0 and 1.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'Ractive' )` or `define([ 'Ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-fade.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-fade' );

	Add a fade transition like so:

	    <div intro='fade'>this will fade in</div>

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fade plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var fade, defaults;

	defaults = {
		delay: 0,
		duration: 300,
		easing: 'linear'
	};

	fade = function ( t, params ) {
		var targetOpacity;

		params = t.processParams( params, defaults );

		if ( t.isIntro ) {
			targetOpacity = t.getStyle( 'opacity' );
			t.setStyle( 'opacity', 0 );
		} else {
			targetOpacity = 0;
		}

		t.animateStyle( 'opacity', targetOpacity, params ).then( t.complete );
	};

	Ractive.transitions.fade = fade;

}));

},{"./../ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-transitions-fly/ractive-transitions-fly.js":[function(require,module,exports){
/*

	ractive-transitions-fly
	=======================

	Version 0.1.3.

	This transition uses CSS transforms to 'fly' elements to their
	natural location on the page, fading in from transparent as they go.
	By default, they will fly in from left.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-fly.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-fly' );

	You can adjust the following parameters: `x`, `y`, `duration`,
	`delay` and `easing`.

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fly plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var fly, addPx, defaults;

	defaults = {
		duration: 800,
		easing: 'cubic-bezier(0.770, 0.000, 0.175, 1.000)',
		x: -500,
		y: 0
	};

	addPx = function ( num ) {
		if ( num === 0 || typeof num === 'string' ) {
			return num;
		}

		return num + 'px';
	};

	fly = function ( t, params ) {
		var x, y, offscreen, target;

		params = t.processParams( params, defaults );

		x = addPx( params.x );
		y = addPx( params.y );

		offscreen = {
			transform: 'translate(' + x + ',' + y + ')'
		};

		if ( t.isIntro ) {
			// animate to the current style
			target = t.getStyle([ 'transform' ]);

			// set offscreen style
			t.setStyle( offscreen );
		} else {
			target = offscreen;
		}

		t.animateStyle( target, params ).then( t.complete );
	};

	Ractive.transitions.fly = fly;

}));

},{"./../ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive-transitions-slide/ractive-transitions-slide.js":[function(require,module,exports){
/*

	ractive-transitions-slide
	=========================

	Version 0.1.2.

	This transition slides an element in and out of view,
	using CSS transitions where possible.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-slide.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-slide' );

	You can specify the `delay`, `duration` and `easing` properties
	using the conventional syntax:

	    <div intro='slide:{"delay":500,"easing":"ease-out"}'>content</div>

	Both `delay` and `duration` are in milliseconds. The `easing` value
	must be a valid CSS easing function (see http://cubic-bezier.com/).

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-slide plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var slide, props, collapsed, defaults;

	defaults = {
		duration: 300,
		easing: 'easeInOut'
	};

	props = [
		'height',
		'borderTopWidth',
		'borderBottomWidth',
		'paddingTop',
		'paddingBottom',
		'marginTop',
		'marginBottom'
	];

	collapsed = {
		height: 0,
		borderTopWidth: 0,
		borderBottomWidth: 0,
		paddingTop: 0,
		paddingBottom: 0,
		marginTop: 0,
		marginBottom: 0
	};

	slide = function ( t, params ) {
		var targetStyle;

		params = t.processParams( params, defaults );

		if ( t.isIntro ) {
			targetStyle = t.getStyle( props );
			t.setStyle( collapsed );
		} else {
			// make style explicit, so we're not transitioning to 'auto'
			t.setStyle( t.getStyle( props ) );
			targetStyle = collapsed;
		}

		t.setStyle( 'overflowY', 'hidden' );

		t.animateStyle( targetStyle, params ).then( t.complete );
	};

	Ractive.transitions.slide = slide;

}));

},{"./../ractive/ractive.js":"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js"}],"/Users/luke.hedger/dev/Experiments/040715/vendor/ractive/ractive.js":[function(require,module,exports){
/*
	ractive.js v0.6.1
	2014-10-25 - commit 3a576eb3 

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

( function( global ) {

	'use strict';

	var noConflict = global.Ractive;

	/* config/defaults/options.js */
	var options = function() {

		var defaultOptions = {
			// render placement:
			el: void 0,
			append: false,
			// template:
			template: {
				v: 1,
				t: []
			},
			yield: null,
			// parse:
			preserveWhitespace: false,
			sanitize: false,
			stripComments: true,
			// data & binding:
			data: {},
			computed: {},
			magic: false,
			modifyArrays: true,
			adapt: [],
			isolated: false,
			twoway: true,
			lazy: false,
			// transitions:
			noIntro: false,
			transitionsEnabled: true,
			complete: void 0,
			// css:
			noCssTransform: false,
			// debug:
			debug: false
		};
		return defaultOptions;
	}();

	/* config/defaults/easing.js */
	var easing = {
		linear: function( pos ) {
			return pos;
		},
		easeIn: function( pos ) {
			return Math.pow( pos, 3 );
		},
		easeOut: function( pos ) {
			return Math.pow( pos - 1, 3 ) + 1;
		},
		easeInOut: function( pos ) {
			if ( ( pos /= 0.5 ) < 1 ) {
				return 0.5 * Math.pow( pos, 3 );
			}
			return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
		}
	};

	/* circular.js */
	var circular = [];

	/* utils/hasOwnProperty.js */
	var hasOwn = Object.prototype.hasOwnProperty;

	/* utils/isArray.js */
	var isArray = function() {

		var toString = Object.prototype.toString;
		// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		return function( thing ) {
			return toString.call( thing ) === '[object Array]';
		};
	}();

	/* utils/isObject.js */
	var isObject = function() {

		var toString = Object.prototype.toString;
		return function( thing ) {
			return thing && toString.call( thing ) === '[object Object]';
		};
	}();

	/* utils/isNumeric.js */
	var isNumeric = function( thing ) {
		return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	};

	/* config/defaults/interpolators.js */
	var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

		var interpolators, interpolate, cssLengthPattern;
		circular.push( function() {
			interpolate = circular.interpolate;
		} );
		cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
		interpolators = {
			number: function( from, to ) {
				var delta;
				if ( !isNumeric( from ) || !isNumeric( to ) ) {
					return null;
				}
				from = +from;
				to = +to;
				delta = to - from;
				if ( !delta ) {
					return function() {
						return from;
					};
				}
				return function( t ) {
					return from + t * delta;
				};
			},
			array: function( from, to ) {
				var intermediate, interpolators, len, i;
				if ( !isArray( from ) || !isArray( to ) ) {
					return null;
				}
				intermediate = [];
				interpolators = [];
				i = len = Math.min( from.length, to.length );
				while ( i-- ) {
					interpolators[ i ] = interpolate( from[ i ], to[ i ] );
				}
				// surplus values - don't interpolate, but don't exclude them either
				for ( i = len; i < from.length; i += 1 ) {
					intermediate[ i ] = from[ i ];
				}
				for ( i = len; i < to.length; i += 1 ) {
					intermediate[ i ] = to[ i ];
				}
				return function( t ) {
					var i = len;
					while ( i-- ) {
						intermediate[ i ] = interpolators[ i ]( t );
					}
					return intermediate;
				};
			},
			object: function( from, to ) {
				var properties, len, interpolators, intermediate, prop;
				if ( !isObject( from ) || !isObject( to ) ) {
					return null;
				}
				properties = [];
				intermediate = {};
				interpolators = {};
				for ( prop in from ) {
					if ( hasOwnProperty.call( from, prop ) ) {
						if ( hasOwnProperty.call( to, prop ) ) {
							properties.push( prop );
							interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
						} else {
							intermediate[ prop ] = from[ prop ];
						}
					}
				}
				for ( prop in to ) {
					if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
						intermediate[ prop ] = to[ prop ];
					}
				}
				len = properties.length;
				return function( t ) {
					var i = len,
						prop;
					while ( i-- ) {
						prop = properties[ i ];
						intermediate[ prop ] = interpolators[ prop ]( t );
					}
					return intermediate;
				};
			}
		};
		return interpolators;
	}( circular, hasOwn, isArray, isObject, isNumeric );

	/* config/svg.js */
	var svg = function() {

		var svg;
		if ( typeof document === 'undefined' ) {
			svg = false;
		} else {
			svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
		}
		return svg;
	}();

	/* utils/warn.js */
	var warn = function() {

		/* global console */
		var warn, warned = {};
		if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
			warn = function( message, allowDuplicates ) {
				if ( !allowDuplicates ) {
					if ( warned[ message ] ) {
						return;
					}
					warned[ message ] = true;
				}
				console.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );
			};
		} else {
			warn = function() {};
		}
		return warn;
	}();

	/* config/errors.js */
	var errors = {
		missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
		mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
		noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
		noTemplateForPartial: 'Could not find template for partial "{name}"',
		noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
		evaluationError: 'Error evaluating "{uniqueString}": {err}',
		badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
		failedComputation: 'Failed to compute "{key}": {err}',
		missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
		badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
		noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned',
		defaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',
		noElementProxyEventWildcards: 'Only component proxy-events may contain "*" wildcards, <{element} on-{event}/> is not valid.',
		methodDeprecated: 'The method "{deprecated}" has been deprecated in favor of "{replacement}" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'
	};

	/* utils/log.js */
	var log = function( consolewarn, errors ) {

		var log = {
			warn: function( options, passthru ) {
				if ( !options.debug && !passthru ) {
					return;
				}
				this.warnAlways( options );
			},
			warnAlways: function( options ) {
				this.logger( getMessage( options ), options.allowDuplicates );
			},
			error: function( options ) {
				this.errorOnly( options );
				if ( !options.debug ) {
					this.warn( options, true );
				}
			},
			errorOnly: function( options ) {
				if ( options.debug ) {
					this.critical( options );
				}
			},
			critical: function( options ) {
				var err = options.err || new Error( getMessage( options ) );
				this.thrower( err );
			},
			logger: consolewarn,
			thrower: function( err ) {
				throw err;
			}
		};

		function getMessage( options ) {
			var message = errors[ options.message ] || options.message || '';
			return interpolate( message, options.args );
		}
		// simple interpolation. probably quicker (and better) out there,
		// but log is not in golden path of execution, only exceptions
		function interpolate( message, args ) {
			return message.replace( /{([^{}]*)}/g, function( a, b ) {
				return args[ b ];
			} );
		}
		return log;
	}( warn, errors );

	/* Ractive/prototype/shared/hooks/Hook.js */
	var Ractive$shared_hooks_Hook = function( log ) {

		var deprecations = {
			construct: {
				deprecated: 'beforeInit',
				replacement: 'onconstruct'
			},
			render: {
				deprecated: 'init',
				message: 'The "init" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the "oninit" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use "onrender" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'
			},
			complete: {
				deprecated: 'complete',
				replacement: 'oncomplete'
			}
		};

		function Hook( event ) {
			this.event = event;
			this.method = 'on' + event;
			this.deprecate = deprecations[ event ];
		}
		Hook.prototype.fire = function( ractive, arg ) {
			function call( method ) {
				if ( ractive[ method ] ) {
					arg ? ractive[ method ]( arg ) : ractive[ method ]();
					return true;
				}
			}
			call( this.method );
			if ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {
				log.warnAlways( {
					debug: ractive.debug,
					message: this.deprecate.message || 'methodDeprecated',
					args: this.deprecate
				} );
			}
			arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
		};
		return Hook;
	}( log );

	/* utils/removeFromArray.js */
	var removeFromArray = function( array, member ) {
		var index = array.indexOf( member );
		if ( index !== -1 ) {
			array.splice( index, 1 );
		}
	};

	/* utils/Promise.js */
	var Promise = function() {

		var __export;
		var _Promise, PENDING = {},
			FULFILLED = {},
			REJECTED = {};
		if ( typeof Promise === 'function' ) {
			// use native Promise
			_Promise = Promise;
		} else {
			_Promise = function( callback ) {
				var fulfilledHandlers = [],
					rejectedHandlers = [],
					state = PENDING,
					result, dispatchHandlers, makeResolver, fulfil, reject, promise;
				makeResolver = function( newState ) {
					return function( value ) {
						if ( state !== PENDING ) {
							return;
						}
						result = value;
						state = newState;
						dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
						// dispatch onFulfilled and onRejected handlers asynchronously
						wait( dispatchHandlers );
					};
				};
				fulfil = makeResolver( FULFILLED );
				reject = makeResolver( REJECTED );
				try {
					callback( fulfil, reject );
				} catch ( err ) {
					reject( err );
				}
				promise = {
					// `then()` returns a Promise - 2.2.7
					then: function( onFulfilled, onRejected ) {
						var promise2 = new _Promise( function( fulfil, reject ) {
							var processResolutionHandler = function( handler, handlers, forward ) {
								// 2.2.1.1
								if ( typeof handler === 'function' ) {
									handlers.push( function( p1result ) {
										var x;
										try {
											x = handler( p1result );
											resolve( promise2, x, fulfil, reject );
										} catch ( err ) {
											reject( err );
										}
									} );
								} else {
									// Forward the result of promise1 to promise2, if resolution handlers
									// are not given
									handlers.push( forward );
								}
							};
							// 2.2
							processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
							processResolutionHandler( onRejected, rejectedHandlers, reject );
							if ( state !== PENDING ) {
								// If the promise has resolved already, dispatch the appropriate handlers asynchronously
								wait( dispatchHandlers );
							}
						} );
						return promise2;
					}
				};
				promise[ 'catch' ] = function( onRejected ) {
					return this.then( null, onRejected );
				};
				return promise;
			};
			_Promise.all = function( promises ) {
				return new _Promise( function( fulfil, reject ) {
					var result = [],
						pending, i, processPromise;
					if ( !promises.length ) {
						fulfil( result );
						return;
					}
					processPromise = function( i ) {
						promises[ i ].then( function( value ) {
							result[ i ] = value;
							if ( !--pending ) {
								fulfil( result );
							}
						}, reject );
					};
					pending = i = promises.length;
					while ( i-- ) {
						processPromise( i );
					}
				} );
			};
			_Promise.resolve = function( value ) {
				return new _Promise( function( fulfil ) {
					fulfil( value );
				} );
			};
			_Promise.reject = function( reason ) {
				return new _Promise( function( fulfil, reject ) {
					reject( reason );
				} );
			};
		}
		__export = _Promise;
		// TODO use MutationObservers or something to simulate setImmediate
		function wait( callback ) {
			setTimeout( callback, 0 );
		}

		function makeDispatcher( handlers, result ) {
			return function() {
				var handler;
				while ( handler = handlers.shift() ) {
					handler( result );
				}
			};
		}

		function resolve( promise, x, fulfil, reject ) {
			// Promise Resolution Procedure
			var then;
			// 2.3.1
			if ( x === promise ) {
				throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
			}
			// 2.3.2
			if ( x instanceof _Promise ) {
				x.then( fulfil, reject );
			} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
				try {
					then = x.then;
				} catch ( e ) {
					reject( e );
					// 2.3.3.2
					return;
				}
				// 2.3.3.3
				if ( typeof then === 'function' ) {
					var called, resolvePromise, rejectPromise;
					resolvePromise = function( y ) {
						if ( called ) {
							return;
						}
						called = true;
						resolve( promise, y, fulfil, reject );
					};
					rejectPromise = function( r ) {
						if ( called ) {
							return;
						}
						called = true;
						reject( r );
					};
					try {
						then.call( x, resolvePromise, rejectPromise );
					} catch ( e ) {
						if ( !called ) {
							// 2.3.3.3.4.1
							reject( e );
							// 2.3.3.3.4.2
							called = true;
							return;
						}
					}
				} else {
					fulfil( x );
				}
			} else {
				fulfil( x );
			}
		}
		return __export;
	}();

	/* utils/normaliseRef.js */
	var normaliseRef = function() {

		var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
		return function normaliseRef( ref ) {
			return ( ref || '' ).replace( regex, '.$1' );
		};
	}();

	/* shared/getInnerContext.js */
	var getInnerContext = function( fragment ) {
		do {
			if ( fragment.context !== undefined ) {
				return fragment.context;
			}
		} while ( fragment = fragment.parent );
		return '';
	};

	/* utils/isEqual.js */
	var isEqual = function( a, b ) {
		if ( a === null && b === null ) {
			return true;
		}
		if ( typeof a === 'object' || typeof b === 'object' ) {
			return false;
		}
		return a === b;
	};

	/* shared/createComponentBinding.js */
	var createComponentBinding = function( circular, isEqual ) {

		var runloop;
		circular.push( function() {
			return runloop = circular.runloop;
		} );
		var Binding = function( ractive, keypath, otherInstance, otherKeypath ) {
			var this$0 = this;
			this.root = ractive;
			this.keypath = keypath;
			this.otherInstance = otherInstance;
			this.otherKeypath = otherKeypath;
			this.lock = function() {
				return this$0.updating = true;
			};
			this.unlock = function() {
				return this$0.updating = false;
			};
			this.bind();
			this.value = this.root.viewmodel.get( this.keypath );
		};
		Binding.prototype = {
			isLocked: function() {
				return this.updating || this.counterpart && this.counterpart.updating;
			},
			shuffle: function( newIndices, value ) {
				this.propagateChange( value, newIndices );
			},
			setValue: function( value ) {
				this.propagateChange( value );
			},
			propagateChange: function( value, newIndices ) {
				var other;
				// Only *you* can prevent infinite loops
				if ( this.isLocked() ) {
					this.value = value;
					return;
				}
				if ( !isEqual( value, this.value ) ) {
					this.lock();
					// TODO maybe the case that `value === this.value` - should that result
					// in an update rather than a set?
					// if the other viewmodel is already locked up, need to do a deferred update
					if ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {
						runloop.scheduleTask( function() {
							return runloop.addViewmodel( other );
						} );
					}
					if ( newIndices ) {
						other.smartUpdate( this.otherKeypath, value, newIndices );
					} else {
						if ( isSettable( other, this.otherKeypath ) ) {
							other.set( this.otherKeypath, value );
						}
					}
					this.value = value;
					// TODO will the counterpart update after this line, during
					// the runloop end cycle? may be a problem...
					runloop.scheduleTask( this.unlock );
				}
			},
			refineValue: function( keypaths ) {
				var this$0 = this;
				var other;
				if ( this.isLocked() ) {
					return;
				}
				this.lock();
				runloop.addViewmodel( other = this.otherInstance.viewmodel );
				keypaths.map( function( keypath ) {
					return this$0.otherKeypath + keypath.substr( this$0.keypath.length );
				} ).forEach( function( keypath ) {
					return other.mark( keypath );
				} );
				runloop.scheduleTask( this.unlock );
			},
			bind: function() {
				this.root.viewmodel.register( this.keypath, this );
			},
			rebind: function( newKeypath ) {
				this.unbind();
				this.keypath = newKeypath;
				this.counterpart.otherKeypath = newKeypath;
				this.bind();
			},
			unbind: function() {
				this.root.viewmodel.unregister( this.keypath, this );
			}
		};

		function isSettable( viewmodel, keypath ) {
			var computed = viewmodel.computations[ keypath ];
			return !computed || computed.setter;
		}
		return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
			var hash, childInstance, bindings, parentToChildBinding, childToParentBinding;
			hash = parentKeypath + '=' + childKeypath;
			bindings = component.bindings;
			if ( bindings[ hash ] ) {
				// TODO does this ever happen?
				return;
			}
			childInstance = component.instance;
			parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );
			bindings.push( parentToChildBinding );
			if ( childInstance.twoway ) {
				childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );
				bindings.push( childToParentBinding );
				parentToChildBinding.counterpart = childToParentBinding;
				childToParentBinding.counterpart = parentToChildBinding;
			}
			bindings[ hash ] = parentToChildBinding;
		};
	}( circular, isEqual );

	/* shared/resolveRef.js */
	var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

		var __export;
		var ancestorErrorMessage, getOptions;
		ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
		getOptions = {
			evaluateWrapped: true
		};
		__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {
			var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
			ref = normaliseRef( ref );
			// If a reference begins '~/', it's a top-level reference
			if ( ref.substr( 0, 2 ) === '~/' ) {
				return ref.substring( 2 );
			}
			// If a reference begins with '.', it's either a restricted reference or
			// an ancestor reference...
			if ( ref.charAt( 0 ) === '.' ) {
				return resolveAncestorReference( getInnerContext( fragment ), ref );
			}
			// ...otherwise we need to find the keypath
			key = ref.split( '.' )[ 0 ];
			// get() in viewmodel creation means no fragment (yet)
			fragment = fragment || {};
			do {
				context = fragment.context;
				if ( !context ) {
					continue;
				}
				hasContextChain = true;
				parentValue = ractive.viewmodel.get( context, getOptions );
				if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
					return context + '.' + ref;
				}
			} while ( fragment = fragment.parent );
			// Root/computed property?
			if ( key in ractive.data || key in ractive.viewmodel.computations ) {
				return ref;
			}
			// If this is an inline component, and it's not isolated, we
			// can try going up the scope chain
			if ( ractive._parent && !ractive.isolated ) {
				hasContextChain = true;
				fragment = ractive.component.parentFragment;
				// Special case - index refs
				if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
					// Create an index ref binding, so that it can be rebound letter if necessary.
					// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
					ractive.component.indexRefBindings[ ref ] = ref;
					ractive.viewmodel.set( ref, index, true );
					return;
				}
				keypath = resolveRef( ractive._parent, ref, fragment, true );
				if ( keypath ) {
					// We need to create an inter-component binding
					// If parent keypath is 'one.foo' and child is 'two.foo', we bind
					// 'one' to 'two' as it's more efficient and avoids edge cases
					parentKeys = keypath.split( '.' );
					childKeys = ref.split( '.' );
					while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
						parentKeys.pop();
						childKeys.pop();
					}
					parentKeypath = parentKeys.join( '.' );
					childKeypath = childKeys.join( '.' );
					ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
					createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
					return ref;
				}
			}
			// If there's no context chain, and the instance is either a) isolated or
			// b) an orphan, then we know that the keypath is identical to the reference
			if ( !isParentLookup && !hasContextChain ) {
				// the data object needs to have a property by this name,
				// to prevent future failed lookups
				ractive.viewmodel.set( ref, undefined );
				return ref;
			}
			if ( ractive.viewmodel.get( ref ) !== undefined ) {
				return ref;
			}
		};

		function resolveAncestorReference( baseContext, ref ) {
			var contextKeys;
			// {{.}} means 'current context'
			if ( ref === '.' )
				return baseContext;
			contextKeys = baseContext ? baseContext.split( '.' ) : [];
			// ancestor references (starting "../") go up the tree
			if ( ref.substr( 0, 3 ) === '../' ) {
				while ( ref.substr( 0, 3 ) === '../' ) {
					if ( !contextKeys.length ) {
						throw new Error( ancestorErrorMessage );
					}
					contextKeys.pop();
					ref = ref.substring( 3 );
				}
				contextKeys.push( ref );
				return contextKeys.join( '.' );
			}
			// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
			if ( !baseContext ) {
				return ref.replace( /^\.\/?/, '' );
			}
			return baseContext + ref.replace( /^\.\//, '.' );
		}
		return __export;
	}( normaliseRef, getInnerContext, createComponentBinding );

	/* global/TransitionManager.js */
	var TransitionManager = function( removeFromArray ) {

		var TransitionManager = function( callback, parent ) {
			this.callback = callback;
			this.parent = parent;
			this.intros = [];
			this.outros = [];
			this.children = [];
			this.totalChildren = this.outroChildren = 0;
			this.detachQueue = [];
			this.outrosComplete = false;
			if ( parent ) {
				parent.addChild( this );
			}
		};
		TransitionManager.prototype = {
			addChild: function( child ) {
				this.children.push( child );
				this.totalChildren += 1;
				this.outroChildren += 1;
			},
			decrementOutros: function() {
				this.outroChildren -= 1;
				check( this );
			},
			decrementTotal: function() {
				this.totalChildren -= 1;
				check( this );
			},
			add: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				list.push( transition );
			},
			remove: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				removeFromArray( list, transition );
				check( this );
			},
			init: function() {
				this.ready = true;
				check( this );
			},
			detachNodes: function() {
				this.detachQueue.forEach( detach );
				this.children.forEach( detachNodes );
			}
		};

		function detach( element ) {
			element.detach();
		}

		function detachNodes( tm ) {
			tm.detachNodes();
		}

		function check( tm ) {
			if ( !tm.ready || tm.outros.length || tm.outroChildren )
				return;
			// If all outros are complete, and we haven't already done this,
			// we notify the parent if there is one, otherwise
			// start detaching nodes
			if ( !tm.outrosComplete ) {
				if ( tm.parent ) {
					tm.parent.decrementOutros( tm );
				} else {
					tm.detachNodes();
				}
				tm.outrosComplete = true;
			}
			// Once everything is done, we can notify parent transition
			// manager and call the callback
			if ( !tm.intros.length && !tm.totalChildren ) {
				if ( typeof tm.callback === 'function' ) {
					tm.callback();
				}
				if ( tm.parent ) {
					tm.parent.decrementTotal();
				}
			}
		}
		return TransitionManager;
	}( removeFromArray );

	/* global/runloop.js */
	var runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {

		var __export;
		var batch, runloop, unresolved = [],
			changeHook = new Hook( 'change' );
		runloop = {
			start: function( instance, returnPromise ) {
				var promise, fulfilPromise;
				if ( returnPromise ) {
					promise = new Promise( function( f ) {
						return fulfilPromise = f;
					} );
				}
				batch = {
					previousBatch: batch,
					transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
					views: [],
					tasks: [],
					viewmodels: [],
					instance: instance
				};
				if ( instance ) {
					batch.viewmodels.push( instance.viewmodel );
				}
				return promise;
			},
			end: function() {
				flushChanges();
				batch.transitionManager.init();
				if ( !batch.previousBatch && !!batch.instance )
					batch.instance.viewmodel.changes = [];
				batch = batch.previousBatch;
			},
			addViewmodel: function( viewmodel ) {
				if ( batch ) {
					if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
						batch.viewmodels.push( viewmodel );
						return true;
					} else {
						return false;
					}
				} else {
					viewmodel.applyChanges();
					return false;
				}
			},
			registerTransition: function( transition ) {
				transition._manager = batch.transitionManager;
				batch.transitionManager.add( transition );
			},
			addView: function( view ) {
				batch.views.push( view );
			},
			addUnresolved: function( thing ) {
				unresolved.push( thing );
			},
			removeUnresolved: function( thing ) {
				removeFromArray( unresolved, thing );
			},
			// synchronise node detachments with transition ends
			detachWhenReady: function( thing ) {
				batch.transitionManager.detachQueue.push( thing );
			},
			scheduleTask: function( task, postRender ) {
				var _batch;
				if ( !batch ) {
					task();
				} else {
					_batch = batch;
					while ( postRender && _batch.previousBatch ) {
						// this can't happen until the DOM has been fully updated
						// otherwise in some situations (with components inside elements)
						// transitions and decorators will initialise prematurely
						_batch = _batch.previousBatch;
					}
					_batch.tasks.push( task );
				}
			}
		};
		circular.runloop = runloop;
		__export = runloop;

		function flushChanges() {
			var i, thing, changeHash;
			for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
				thing = batch.viewmodels[ i ];
				changeHash = thing.applyChanges();
				if ( changeHash ) {
					changeHook.fire( thing.ractive, changeHash );
				}
			}
			batch.viewmodels.length = 0;
			attemptKeypathResolution();
			// Now that changes have been fully propagated, we can update the DOM
			// and complete other tasks
			for ( i = 0; i < batch.views.length; i += 1 ) {
				batch.views[ i ].update();
			}
			batch.views.length = 0;
			for ( i = 0; i < batch.tasks.length; i += 1 ) {
				batch.tasks[ i ]();
			}
			batch.tasks.length = 0;
			// If updating the view caused some model blowback - e.g. a triple
			// containing <option> elements caused the binding on the <select>
			// to update - then we start over
			if ( batch.viewmodels.length )
				return flushChanges();
		}

		function attemptKeypathResolution() {
			var i, item, keypath, resolved;
			i = unresolved.length;
			// see if we can resolve any unresolved references
			while ( i-- ) {
				item = unresolved[ i ];
				if ( item.keypath ) {
					// it resolved some other way. TODO how? two-way binding? Seems
					// weird that we'd still end up here
					unresolved.splice( i, 1 );
				}
				if ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {
					( resolved || ( resolved = [] ) ).push( {
						item: item,
						keypath: keypath
					} );
					unresolved.splice( i, 1 );
				}
			}
			if ( resolved ) {
				resolved.forEach( resolve );
			}
		}

		function resolve( resolved ) {
			resolved.item.resolve( resolved.keypath );
		}
		return __export;
	}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );

	/* utils/createBranch.js */
	var createBranch = function() {

		var numeric = /^\s*[0-9]+\s*$/;
		return function( key ) {
			return numeric.test( key ) ? [] : {};
		};
	}();

	/* viewmodel/prototype/get/magicAdaptor.js */
	var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

		var __export;
		var magicAdaptor, MagicWrapper;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			magicAdaptor = {
				filter: function( object, keypath, ractive ) {
					var keys, key, parentKeypath, parentWrapper, parentValue;
					if ( !keypath ) {
						return false;
					}
					keys = keypath.split( '.' );
					key = keys.pop();
					parentKeypath = keys.join( '.' );
					// If the parent value is a wrapper, other than a magic wrapper,
					// we shouldn't wrap this property
					if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
						return false;
					}
					parentValue = ractive.get( parentKeypath );
					// if parentValue is an array that doesn't include this member,
					// we should return false otherwise lengths will get messed up
					if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
						return false;
					}
					return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
				},
				wrap: function( ractive, property, keypath ) {
					return new MagicWrapper( ractive, property, keypath );
				}
			};
			MagicWrapper = function( ractive, value, keypath ) {
				var keys, objKeypath, template, siblings;
				this.magic = true;
				this.ractive = ractive;
				this.keypath = keypath;
				this.value = value;
				keys = keypath.split( '.' );
				this.prop = keys.pop();
				objKeypath = keys.join( '.' );
				this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
				template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
				// Has this property already been wrapped?
				if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
					// Yes. Register this wrapper to this property, if it hasn't been already
					if ( siblings.indexOf( this ) === -1 ) {
						siblings.push( this );
					}
					return;
				}
				// No, it hasn't been wrapped
				createAccessors( this, value, template );
			};
			MagicWrapper.prototype = {
				get: function() {
					return this.value;
				},
				reset: function( value ) {
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.obj[ this.prop ] = value;
					// trigger set() accessor
					runloop.addViewmodel( this.ractive.viewmodel );
					this.ractive.viewmodel.mark( this.keypath );
					this.updating = false;
				},
				set: function( key, value ) {
					if ( this.updating ) {
						return;
					}
					if ( !this.obj[ this.prop ] ) {
						this.updating = true;
						this.obj[ this.prop ] = createBranch( key );
						this.updating = false;
					}
					this.obj[ this.prop ][ key ] = value;
				},
				teardown: function() {
					var template, set, value, wrappers, index;
					// If this method was called because the cache was being cleared as a
					// result of a set()/update() call made by this wrapper, we return false
					// so that it doesn't get torn down
					if ( this.updating ) {
						return false;
					}
					template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					set = template && template.set;
					if ( !set ) {
						// most likely, this was an array member that was spliced out
						return;
					}
					wrappers = set._ractiveWrappers;
					index = wrappers.indexOf( this );
					if ( index !== -1 ) {
						wrappers.splice( index, 1 );
					}
					// Last one out, turn off the lights
					if ( !wrappers.length ) {
						value = this.obj[ this.prop ];
						Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
							writable: true,
							enumerable: true,
							configurable: true
						} );
						this.obj[ this.prop ] = value;
					}
				}
			};
		} catch ( err ) {
			magicAdaptor = false;
		}
		__export = magicAdaptor;

		function createAccessors( originalWrapper, value, template ) {
			var object, property, oldGet, oldSet, get, set;
			object = originalWrapper.obj;
			property = originalWrapper.prop;
			// Is this template configurable?
			if ( template && !template.configurable ) {
				// Special case - array length
				if ( property === 'length' ) {
					return;
				}
				throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
			}
			// Time to wrap this property
			if ( template ) {
				oldGet = template.get;
				oldSet = template.set;
			}
			get = oldGet || function() {
				return value;
			};
			set = function( v ) {
				if ( oldSet ) {
					oldSet( v );
				}
				value = oldGet ? oldGet() : v;
				set._ractiveWrappers.forEach( updateWrapper );
			};

			function updateWrapper( wrapper ) {
				var keypath, ractive;
				wrapper.value = value;
				if ( wrapper.updating ) {
					return;
				}
				ractive = wrapper.ractive;
				keypath = wrapper.keypath;
				wrapper.updating = true;
				runloop.start( ractive );
				ractive.viewmodel.mark( keypath );
				runloop.end();
				wrapper.updating = false;
			}
			// Create an array of wrappers, in case other keypaths/ractives depend on this property.
			// Handily, we can store them as a property of the set function. Yay JavaScript.
			set._ractiveWrappers = [ originalWrapper ];
			Object.defineProperty( object, property, {
				get: get,
				set: set,
				enumerable: true,
				configurable: true
			} );
		}
		return __export;
	}( runloop, createBranch, isArray );

	/* config/magic.js */
	var magic = function( magicAdaptor ) {

		return !!magicAdaptor;
	}( viewmodel$get_magicAdaptor );

	/* config/namespaces.js */
	var namespaces = {
		html: 'http://www.w3.org/1999/xhtml',
		mathml: 'http://www.w3.org/1998/Math/MathML',
		svg: 'http://www.w3.org/2000/svg',
		xlink: 'http://www.w3.org/1999/xlink',
		xml: 'http://www.w3.org/XML/1998/namespace',
		xmlns: 'http://www.w3.org/2000/xmlns/'
	};

	/* utils/createElement.js */
	var createElement = function( svg, namespaces ) {

		var createElement;
		// Test for SVG support
		if ( !svg ) {
			createElement = function( type, ns ) {
				if ( ns && ns !== namespaces.html ) {
					throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
				}
				return document.createElement( type );
			};
		} else {
			createElement = function( type, ns ) {
				if ( !ns || ns === namespaces.html ) {
					return document.createElement( type );
				}
				return document.createElementNS( ns, type );
			};
		}
		return createElement;
	}( svg, namespaces );

	/* config/isClient.js */
	var isClient = function() {

		var isClient = typeof document === 'object';
		return isClient;
	}();

	/* utils/defineProperty.js */
	var defineProperty = function( isClient ) {

		var defineProperty;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			if ( isClient ) {
				Object.defineProperty( document.createElement( 'div' ), 'test', {
					value: 0
				} );
			}
			defineProperty = Object.defineProperty;
		} catch ( err ) {
			// Object.defineProperty doesn't exist, or we're in IE8 where you can
			// only use it with DOM objects (what the fuck were you smoking, MSFT?)
			defineProperty = function( obj, prop, desc ) {
				obj[ prop ] = desc.value;
			};
		}
		return defineProperty;
	}( isClient );

	/* utils/defineProperties.js */
	var defineProperties = function( createElement, defineProperty, isClient ) {

		var defineProperties;
		try {
			try {
				Object.defineProperties( {}, {
					test: {
						value: 0
					}
				} );
			} catch ( err ) {
				// TODO how do we account for this? noMagic = true;
				throw err;
			}
			if ( isClient ) {
				Object.defineProperties( createElement( 'div' ), {
					test: {
						value: 0
					}
				} );
			}
			defineProperties = Object.defineProperties;
		} catch ( err ) {
			defineProperties = function( obj, props ) {
				var prop;
				for ( prop in props ) {
					if ( props.hasOwnProperty( prop ) ) {
						defineProperty( obj, prop, props[ prop ] );
					}
				}
			};
		}
		return defineProperties;
	}( createElement, defineProperty, isClient );

	/* Ractive/prototype/shared/add.js */
	var Ractive$shared_add = function( isNumeric ) {

		return function add( root, keypath, d ) {
			var value;
			if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
				throw new Error( 'Bad arguments' );
			}
			value = +root.get( keypath ) || 0;
			if ( !isNumeric( value ) ) {
				throw new Error( 'Cannot add to a non-numeric value' );
			}
			return root.set( keypath, value + d );
		};
	}( isNumeric );

	/* Ractive/prototype/add.js */
	var Ractive$add = function( add ) {

		return function Ractive$add( keypath, d ) {
			return add( this, keypath, d === undefined ? 1 : +d );
		};
	}( Ractive$shared_add );

	/* utils/normaliseKeypath.js */
	var normaliseKeypath = function( normaliseRef ) {

		var leadingDot = /^\.+/;
		return function normaliseKeypath( keypath ) {
			return normaliseRef( keypath ).replace( leadingDot, '' );
		};
	}( normaliseRef );

	/* config/vendors.js */
	var vendors = [
		'o',
		'ms',
		'moz',
		'webkit'
	];

	/* utils/requestAnimationFrame.js */
	var requestAnimationFrame = function( vendors ) {

		var requestAnimationFrame;
		// If window doesn't exist, we don't need requestAnimationFrame
		if ( typeof window === 'undefined' ) {
			requestAnimationFrame = null;
		} else {
			// https://gist.github.com/paulirish/1579671
			( function( vendors, lastTime, window ) {
				var x, setTimeout;
				if ( window.requestAnimationFrame ) {
					return;
				}
				for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
					window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
				}
				if ( !window.requestAnimationFrame ) {
					setTimeout = window.setTimeout;
					window.requestAnimationFrame = function( callback ) {
						var currTime, timeToCall, id;
						currTime = Date.now();
						timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
						id = setTimeout( function() {
							callback( currTime + timeToCall );
						}, timeToCall );
						lastTime = currTime + timeToCall;
						return id;
					};
				}
			}( vendors, 0, window ) );
			requestAnimationFrame = window.requestAnimationFrame;
		}
		return requestAnimationFrame;
	}( vendors );

	/* utils/getTime.js */
	var getTime = function() {

		var getTime;
		if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
			getTime = function() {
				return window.performance.now();
			};
		} else {
			getTime = function() {
				return Date.now();
			};
		}
		return getTime;
	}();

	/* shared/animations.js */
	var animations = function( rAF, getTime, runloop ) {

		var queue = [];
		var animations = {
			tick: function() {
				var i, animation, now;
				now = getTime();
				runloop.start();
				for ( i = 0; i < queue.length; i += 1 ) {
					animation = queue[ i ];
					if ( !animation.tick( now ) ) {
						// animation is complete, remove it from the stack, and decrement i so we don't miss one
						queue.splice( i--, 1 );
					}
				}
				runloop.end();
				if ( queue.length ) {
					rAF( animations.tick );
				} else {
					animations.running = false;
				}
			},
			add: function( animation ) {
				queue.push( animation );
				if ( !animations.running ) {
					animations.running = true;
					rAF( animations.tick );
				}
			},
			// TODO optimise this
			abort: function( keypath, root ) {
				var i = queue.length,
					animation;
				while ( i-- ) {
					animation = queue[ i ];
					if ( animation.root === root && animation.keypath === keypath ) {
						animation.stop();
					}
				}
			}
		};
		return animations;
	}( requestAnimationFrame, getTime, runloop );

	/* config/options/css/transform.js */
	var transform = function() {

		var __export;
		var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
			commentsPattern = /\/\*.*?\*\//g,
			selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
			mediaQueryPattern = /^@media/,
			dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
		__export = function transformCss( css, guid ) {
			var transformed, addGuid;
			addGuid = function( selector ) {
				var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
				selectorUnits = [];
				while ( match = selectorUnitPattern.exec( selector ) ) {
					selectorUnits.push( {
						str: match[ 0 ],
						base: match[ 1 ],
						modifiers: match[ 2 ]
					} );
				}
				// For each simple selector within the selector, we need to create a version
				// that a) combines with the guid, and b) is inside the guid
				dataAttr = '[data-rvcguid="' + guid + '"]';
				base = selectorUnits.map( extractString );
				i = selectorUnits.length;
				while ( i-- ) {
					appended = base.slice();
					// Pseudo-selectors should go after the attribute selector
					unit = selectorUnits[ i ];
					appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
					prepended = base.slice();
					prepended[ i ] = dataAttr + ' ' + prepended[ i ];
					transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
				}
				return transformed.join( ', ' );
			};
			if ( dataRvcGuidPattern.test( css ) ) {
				transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
			} else {
				transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
					var selectors, transformed;
					// don't transform media queries!
					if ( mediaQueryPattern.test( $1 ) )
						return match;
					selectors = $1.split( ',' ).map( trim );
					transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
					return match.replace( $1, transformed );
				} );
			}
			return transformed;
		};

		function trim( str ) {
			if ( str.trim ) {
				return str.trim();
			}
			return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
		}

		function extractString( unit ) {
			return unit.str;
		}
		return __export;
	}();

	/* config/options/css/css.js */
	var css = function( transformCss ) {

		var cssConfig = {
			name: 'css',
			extend: extend,
			init: function() {}
		};

		function extend( Parent, proto, options ) {
			var guid = proto.constructor._guid,
				css;
			if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
				proto.constructor.css = css;
			}
		}

		function getCss( css, target, guid ) {
			if ( !css ) {
				return;
			}
			return target.noCssTransform ? css : transformCss( css, guid );
		}
		return cssConfig;
	}( transform );

	/* utils/wrapMethod.js */
	var wrapMethod = function() {

		var __export;
		__export = function( method, superMethod, force ) {
			if ( force || needsSuper( method, superMethod ) ) {
				return function() {
					var hasSuper = '_super' in this,
						_super = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = _super;
					}
					return result;
				};
			} else {
				return method;
			}
		};

		function needsSuper( method, superMethod ) {
			return typeof superMethod === 'function' && /_super/.test( method );
		}
		return __export;
	}();

	/* config/options/data.js */
	var data = function( wrap ) {

		var __export;
		var dataConfig = {
			name: 'data',
			extend: extend,
			init: init,
			reset: reset
		};
		__export = dataConfig;

		function combine( Parent, target, options ) {
			var value = options.data || {},
				parentValue = getAddedKeys( Parent.prototype.data );
			if ( typeof value !== 'object' && typeof value !== 'function' ) {
				throw new TypeError( 'data option must be an object or a function, "' + value + '" is not valid' );
			}
			return dispatch( parentValue, value );
		}

		function extend( Parent, proto, options ) {
			proto.data = combine( Parent, proto, options );
		}

		function init( Parent, ractive, options ) {
			var value = options.data,
				result = combine( Parent, ractive, options );
			if ( typeof result === 'function' ) {
				result = result.call( ractive, value ) || value;
			}
			return ractive.data = result || {};
		}

		function reset( ractive ) {
			var result = this.init( ractive.constructor, ractive, ractive );
			if ( result ) {
				ractive.data = result;
				return true;
			}
		}

		function getAddedKeys( parent ) {
			// only for functions that had keys added
			if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
				return parent;
			}
			// copy the added keys to temp 'object', otherwise
			// parent would be interpreted as 'function' by dispatch
			var temp = {};
			copy( parent, temp );
			// roll in added keys
			return dispatch( parent, temp );
		}

		function dispatch( parent, child ) {
			if ( typeof child === 'function' ) {
				return extendFn( child, parent );
			} else if ( typeof parent === 'function' ) {
				return fromFn( child, parent );
			} else {
				return fromProperties( child, parent );
			}
		}

		function copy( from, to, fillOnly ) {
			for ( var key in from ) {
				if ( fillOnly && key in to ) {
					continue;
				}
				to[ key ] = from[ key ];
			}
		}

		function fromProperties( child, parent ) {
			child = child || {};
			if ( !parent ) {
				return child;
			}
			copy( parent, child, true );
			return child;
		}

		function fromFn( child, parentFn ) {
			return function( data ) {
				var keys;
				if ( child ) {
					// Track the keys that our on the child,
					// but not on the data. We'll need to apply these
					// after the parent function returns.
					keys = [];
					for ( var key in child ) {
						if ( !data || !( key in data ) ) {
							keys.push( key );
						}
					}
				}
				// call the parent fn, use data if no return value
				data = parentFn.call( this, data ) || data;
				// Copy child keys back onto data. The child keys
				// should take precedence over whatever the
				// parent did with the data.
				if ( keys && keys.length ) {
					data = data || {};
					keys.forEach( function( key ) {
						data[ key ] = child[ key ];
					} );
				}
				return data;
			};
		}

		function extendFn( childFn, parent ) {
			var parentFn;
			if ( typeof parent !== 'function' ) {
				// copy props to data
				parentFn = function( data ) {
					fromProperties( data, parent );
				};
			} else {
				parentFn = function( data ) {
					// give parent function it's own this._super context,
					// otherwise this._super is from child and
					// causes infinite loop
					parent = wrap( parent, function() {}, true );
					return parent.call( this, data ) || data;
				};
			}
			return wrap( childFn, parentFn );
		}
		return __export;
	}( wrapMethod );

	/* config/types.js */
	var types = {
		TEXT: 1,
		INTERPOLATOR: 2,
		TRIPLE: 3,
		SECTION: 4,
		INVERTED: 5,
		CLOSING: 6,
		ELEMENT: 7,
		PARTIAL: 8,
		COMMENT: 9,
		DELIMCHANGE: 10,
		MUSTACHE: 11,
		TAG: 12,
		ATTRIBUTE: 13,
		CLOSING_TAG: 14,
		COMPONENT: 15,
		NUMBER_LITERAL: 20,
		STRING_LITERAL: 21,
		ARRAY_LITERAL: 22,
		OBJECT_LITERAL: 23,
		BOOLEAN_LITERAL: 24,
		GLOBAL: 26,
		KEY_VALUE_PAIR: 27,
		REFERENCE: 30,
		REFINEMENT: 31,
		MEMBER: 32,
		PREFIX_OPERATOR: 33,
		BRACKETED: 34,
		CONDITIONAL: 35,
		INFIX_OPERATOR: 36,
		INVOCATION: 40,
		SECTION_IF: 50,
		SECTION_UNLESS: 51,
		SECTION_EACH: 52,
		SECTION_WITH: 53,
		SECTION_IF_WITH: 54
	};

	/* utils/create.js */
	var create = function() {

		var create;
		try {
			Object.create( null );
			create = Object.create;
		} catch ( err ) {
			// sigh
			create = function() {
				var F = function() {};
				return function( proto, props ) {
					var obj;
					if ( proto === null ) {
						return {};
					}
					F.prototype = proto;
					obj = new F();
					if ( props ) {
						Object.defineProperties( obj, props );
					}
					return obj;
				};
			}();
		}
		return create;
	}();

	/* parse/Parser/expressions/shared/errors.js */
	var parse_Parser_expressions_shared_errors = {
		expectedExpression: 'Expected a JavaScript expression',
		expectedParen: 'Expected closing paren'
	};

	/* parse/Parser/expressions/primary/literal/numberLiteral.js */
	var numberLiteral = function( types ) {

		var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		return function( parser ) {
			var result;
			if ( result = parser.matchPattern( numberPattern ) ) {
				return {
					t: types.NUMBER_LITERAL,
					v: result
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
	var booleanLiteral = function( types ) {

		return function( parser ) {
			var remaining = parser.remaining();
			if ( remaining.substr( 0, 4 ) === 'true' ) {
				parser.pos += 4;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'true'
				};
			}
			if ( remaining.substr( 0, 5 ) === 'false' ) {
				parser.pos += 5;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'false'
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
	var makeQuotedStringMatcher = function() {

		var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
		// Match one or more characters until: ", ', \, or EOL/EOF.
		// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
		stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
		// Match one escape sequence, including the backslash.
		escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
		// Match one ES5 line continuation (backslash + line terminator).
		lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
		// Helper for defining getDoubleQuotedString and getSingleQuotedString.
		return function( okQuote ) {
			return function( parser ) {
				var start, literal, done, next;
				start = parser.pos;
				literal = '"';
				done = false;
				while ( !done ) {
					next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
					if ( next ) {
						if ( next === '"' ) {
							literal += '\\"';
						} else if ( next === '\\\'' ) {
							literal += '\'';
						} else {
							literal += next;
						}
					} else {
						next = parser.matchPattern( lineContinuationPattern );
						if ( next ) {
							// convert \(newline-like) into a \u escape, which is allowed in JSON
							literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
						} else {
							done = true;
						}
					}
				}
				literal += '"';
				// use JSON.parse to interpret escapes
				return JSON.parse( literal );
			};
		};
	}();

	/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
	var singleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '"' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
	var doubleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '\'' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
	var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

		return function( parser ) {
			var start, string;
			start = parser.pos;
			if ( parser.matchString( '"' ) ) {
				string = getDoubleQuotedString( parser );
				if ( !parser.matchString( '"' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			if ( parser.matchString( '\'' ) ) {
				string = getSingleQuotedString( parser );
				if ( !parser.matchString( '\'' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			return null;
		};
	}( types, singleQuotedString, doubleQuotedString );

	/* parse/Parser/expressions/shared/patterns.js */
	var patterns = {
		name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
	};

	/* parse/Parser/expressions/shared/key.js */
	var key = function( getStringLiteral, getNumberLiteral, patterns ) {

		var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		// http://mathiasbynens.be/notes/javascript-properties
		// can be any name, string literal, or number literal
		return function( parser ) {
			var token;
			if ( token = getStringLiteral( parser ) ) {
				return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
			}
			if ( token = getNumberLiteral( parser ) ) {
				return token.v;
			}
			if ( token = parser.matchPattern( patterns.name ) ) {
				return token;
			}
		};
	}( stringLiteral, numberLiteral, patterns );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
	var keyValuePair = function( types, getKey ) {

		return function( parser ) {
			var start, key, value;
			start = parser.pos;
			// allow whitespace between '{' and key
			parser.allowWhitespace();
			key = getKey( parser );
			if ( key === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between key and ':'
			parser.allowWhitespace();
			// next character must be ':'
			if ( !parser.matchString( ':' ) ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between ':' and value
			parser.allowWhitespace();
			// next expression must be a, well... expression
			value = parser.readExpression();
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.KEY_VALUE_PAIR,
				k: key,
				v: value
			};
		};
	}( types, key );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
	var keyValuePairs = function( getKeyValuePair ) {

		return function getKeyValuePairs( parser ) {
			var start, pairs, pair, keyValuePairs;
			start = parser.pos;
			pair = getKeyValuePair( parser );
			if ( pair === null ) {
				return null;
			}
			pairs = [ pair ];
			if ( parser.matchString( ',' ) ) {
				keyValuePairs = getKeyValuePairs( parser );
				if ( !keyValuePairs ) {
					parser.pos = start;
					return null;
				}
				return pairs.concat( keyValuePairs );
			}
			return pairs;
		};
	}( keyValuePair );

	/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
	var objectLiteral = function( types, getKeyValuePairs ) {

		return function( parser ) {
			var start, keyValuePairs;
			start = parser.pos;
			// allow whitespace
			parser.allowWhitespace();
			if ( !parser.matchString( '{' ) ) {
				parser.pos = start;
				return null;
			}
			keyValuePairs = getKeyValuePairs( parser );
			// allow whitespace between final value and '}'
			parser.allowWhitespace();
			if ( !parser.matchString( '}' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.OBJECT_LITERAL,
				m: keyValuePairs
			};
		};
	}( types, keyValuePairs );

	/* parse/Parser/expressions/shared/expressionList.js */
	var expressionList = function( errors ) {

		return function getExpressionList( parser ) {
			var start, expressions, expr, next;
			start = parser.pos;
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( expr === null ) {
				return null;
			}
			expressions = [ expr ];
			// allow whitespace between expression and ','
			parser.allowWhitespace();
			if ( parser.matchString( ',' ) ) {
				next = getExpressionList( parser );
				if ( next === null ) {
					parser.error( errors.expectedExpression );
				}
				next.forEach( append );
			}

			function append( expression ) {
				expressions.push( expression );
			}
			return expressions;
		};
	}( parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
	var arrayLiteral = function( types, getExpressionList ) {

		return function( parser ) {
			var start, expressionList;
			start = parser.pos;
			// allow whitespace before '['
			parser.allowWhitespace();
			if ( !parser.matchString( '[' ) ) {
				parser.pos = start;
				return null;
			}
			expressionList = getExpressionList( parser );
			if ( !parser.matchString( ']' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.ARRAY_LITERAL,
				m: expressionList
			};
		};
	}( types, expressionList );

	/* parse/Parser/expressions/primary/literal/_literal.js */
	var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

		return function( parser ) {
			var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
			return literal;
		};
	}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

	/* parse/Parser/expressions/primary/reference.js */
	var reference = function( types, patterns ) {

		var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
		dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
		getArrayRefinement = function( parser ) {
			var num = parser.matchPattern( arrayMemberPattern );
			if ( num ) {
				return '.' + num;
			}
			return null;
		};
		arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
		// if a reference is a browser global, we don't deference it later, so it needs special treatment
		globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
		// keywords are not valid references, with the exception of `this`
		keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
		return function( parser ) {
			var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
			startPos = parser.pos;
			// we might have a root-level reference
			if ( parser.matchString( '~/' ) ) {
				ancestor = '~/';
			} else {
				// we might have ancestor refs...
				ancestor = '';
				while ( parser.matchString( '../' ) ) {
					ancestor += '../';
				}
			}
			if ( !ancestor ) {
				// we might have an implicit iterator or a restricted reference
				dot = parser.matchString( './' ) || parser.matchString( '.' ) || '';
			}
			name = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';
			// bug out if it's a keyword
			if ( keywords.test( name ) ) {
				parser.pos = startPos;
				return null;
			}
			// if this is a browser global, stop here
			if ( !ancestor && !dot && globals.test( name ) ) {
				return {
					t: types.GLOBAL,
					v: name
				};
			}
			combo = ( ancestor || dot ) + name;
			if ( !combo ) {
				return null;
			}
			while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
				combo += refinement;
			}
			if ( parser.matchString( '(' ) ) {
				// if this is a method invocation (as opposed to a function) we need
				// to strip the method name from the reference combo, else the context
				// will be wrong
				lastDotIndex = combo.lastIndexOf( '.' );
				if ( lastDotIndex !== -1 ) {
					combo = combo.substr( 0, lastDotIndex );
					parser.pos = startPos + combo.length;
				} else {
					parser.pos -= 1;
				}
			}
			return {
				t: types.REFERENCE,
				n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
			};
		};
	}( types, patterns );

	/* parse/Parser/expressions/primary/bracketedExpression.js */
	var bracketedExpression = function( types, errors ) {

		return function( parser ) {
			var start, expr;
			start = parser.pos;
			if ( !parser.matchString( '(' ) ) {
				return null;
			}
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( !expr ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ')' ) ) {
				parser.error( errors.expectedParen );
			}
			return {
				t: types.BRACKETED,
				x: expr
			};
		};
	}( types, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/_primary.js */
	var primary = function( getLiteral, getReference, getBracketedExpression ) {

		return function( parser ) {
			return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
		};
	}( literal, reference, bracketedExpression );

	/* parse/Parser/expressions/shared/refinement.js */
	var refinement = function( types, errors, patterns ) {

		return function getRefinement( parser ) {
			var start, name, expr;
			start = parser.pos;
			parser.allowWhitespace();
			// "." name
			if ( parser.matchString( '.' ) ) {
				parser.allowWhitespace();
				if ( name = parser.matchPattern( patterns.name ) ) {
					return {
						t: types.REFINEMENT,
						n: name
					};
				}
				parser.error( 'Expected a property name' );
			}
			// "[" expression "]"
			if ( parser.matchString( '[' ) ) {
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ']' ) ) {
					parser.error( 'Expected \']\'' );
				}
				return {
					t: types.REFINEMENT,
					x: expr
				};
			}
			return null;
		};
	}( types, parse_Parser_expressions_shared_errors, patterns );

	/* parse/Parser/expressions/memberOrInvocation.js */
	var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

		return function( parser ) {
			var current, expression, refinement, expressionList;
			expression = getPrimary( parser );
			if ( !expression ) {
				return null;
			}
			while ( expression ) {
				current = parser.pos;
				if ( refinement = getRefinement( parser ) ) {
					expression = {
						t: types.MEMBER,
						x: expression,
						r: refinement
					};
				} else if ( parser.matchString( '(' ) ) {
					parser.allowWhitespace();
					expressionList = getExpressionList( parser );
					parser.allowWhitespace();
					if ( !parser.matchString( ')' ) ) {
						parser.error( errors.expectedParen );
					}
					expression = {
						t: types.INVOCATION,
						x: expression
					};
					if ( expressionList ) {
						expression.o = expressionList;
					}
				} else {
					break;
				}
			}
			return expression;
		};
	}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/typeof.js */
	var _typeof = function( types, errors, getMemberOrInvocation ) {

		var getTypeof, makePrefixSequenceMatcher;
		makePrefixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var expression;
				if ( expression = fallthrough( parser ) ) {
					return expression;
				}
				if ( !parser.matchString( symbol ) ) {
					return null;
				}
				parser.allowWhitespace();
				expression = parser.readExpression();
				if ( !expression ) {
					parser.error( errors.expectedExpression );
				}
				return {
					s: symbol,
					o: expression,
					t: types.PREFIX_OPERATOR
				};
			};
		};
		// create all prefix sequence matchers, return getTypeof
		( function() {
			var i, len, matcher, prefixOperators, fallthrough;
			prefixOperators = '! ~ + - typeof'.split( ' ' );
			fallthrough = getMemberOrInvocation;
			for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
				matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// typeof operator is higher precedence than multiplication, so provides the
			// fallthrough for the multiplication sequence matcher we're about to create
			// (we're skipping void and delete)
			getTypeof = fallthrough;
		}() );
		return getTypeof;
	}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

	/* parse/Parser/expressions/logicalOr.js */
	var logicalOr = function( types, getTypeof ) {

		var getLogicalOr, makeInfixSequenceMatcher;
		makeInfixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var start, left, right;
				left = fallthrough( parser );
				if ( !left ) {
					return null;
				}
				// Loop to handle left-recursion in a case like `a * b * c` and produce
				// left association, i.e. `(a * b) * c`.  The matcher can't call itself
				// to parse `left` because that would be infinite regress.
				while ( true ) {
					start = parser.pos;
					parser.allowWhitespace();
					if ( !parser.matchString( symbol ) ) {
						parser.pos = start;
						return left;
					}
					// special case - in operator must not be followed by [a-zA-Z_$0-9]
					if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
						parser.pos = start;
						return left;
					}
					parser.allowWhitespace();
					// right operand must also consist of only higher-precedence operators
					right = fallthrough( parser );
					if ( !right ) {
						parser.pos = start;
						return left;
					}
					left = {
						t: types.INFIX_OPERATOR,
						s: symbol,
						o: [
							left,
							right
						]
					};
				}
			};
		};
		// create all infix sequence matchers, and return getLogicalOr
		( function() {
			var i, len, matcher, infixOperators, fallthrough;
			// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
			// Each sequence matcher will initially fall through to its higher precedence
			// neighbour, and only attempt to match if one of the higher precedence operators
			// (or, ultimately, a literal, reference, or bracketed expression) already matched
			infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
			// A typeof operator is higher precedence than multiplication
			fallthrough = getTypeof;
			for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
				matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// Logical OR is the fallthrough for the conditional matcher
			getLogicalOr = fallthrough;
		}() );
		return getLogicalOr;
	}( types, _typeof );

	/* parse/Parser/expressions/conditional.js */
	var conditional = function( types, getLogicalOr, errors ) {

		return function( parser ) {
			var start, expression, ifTrue, ifFalse;
			expression = getLogicalOr( parser );
			if ( !expression ) {
				return null;
			}
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '?' ) ) {
				parser.pos = start;
				return expression;
			}
			parser.allowWhitespace();
			ifTrue = parser.readExpression();
			if ( !ifTrue ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				parser.error( 'Expected ":"' );
			}
			parser.allowWhitespace();
			ifFalse = parser.readExpression();
			if ( !ifFalse ) {
				parser.error( errors.expectedExpression );
			}
			return {
				t: types.CONDITIONAL,
				o: [
					expression,
					ifTrue,
					ifFalse
				]
			};
		};
	}( types, logicalOr, parse_Parser_expressions_shared_errors );

	/* parse/Parser/utils/flattenExpression.js */
	var flattenExpression = function( types, isObject ) {

		var __export;
		__export = function( expression ) {
			var refs = [],
				flattened;
			extractRefs( expression, refs );
			flattened = {
				r: refs,
				s: stringify( this, expression, refs )
			};
			return flattened;
		};

		function quoteStringLiteral( str ) {
			return JSON.stringify( String( str ) );
		}
		// TODO maybe refactor this?
		function extractRefs( node, refs ) {
			var i, list;
			if ( node.t === types.REFERENCE ) {
				if ( refs.indexOf( node.n ) === -1 ) {
					refs.unshift( node.n );
				}
			}
			list = node.o || node.m;
			if ( list ) {
				if ( isObject( list ) ) {
					extractRefs( list, refs );
				} else {
					i = list.length;
					while ( i-- ) {
						extractRefs( list[ i ], refs );
					}
				}
			}
			if ( node.x ) {
				extractRefs( node.x, refs );
			}
			if ( node.r ) {
				extractRefs( node.r, refs );
			}
			if ( node.v ) {
				extractRefs( node.v, refs );
			}
		}

		function stringify( parser, node, refs ) {
			var stringifyAll = function( item ) {
				return stringify( parser, item, refs );
			};
			switch ( node.t ) {
				case types.BOOLEAN_LITERAL:
				case types.GLOBAL:
				case types.NUMBER_LITERAL:
					return node.v;
				case types.STRING_LITERAL:
					return quoteStringLiteral( node.v );
				case types.ARRAY_LITERAL:
					return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
				case types.OBJECT_LITERAL:
					return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
				case types.KEY_VALUE_PAIR:
					return node.k + ':' + stringify( parser, node.v, refs );
				case types.PREFIX_OPERATOR:
					return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
				case types.INFIX_OPERATOR:
					return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
				case types.INVOCATION:
					return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
				case types.BRACKETED:
					return '(' + stringify( parser, node.x, refs ) + ')';
				case types.MEMBER:
					return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
				case types.REFINEMENT:
					return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
				case types.CONDITIONAL:
					return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
				case types.REFERENCE:
					return '_' + refs.indexOf( node.n );
				default:
					parser.error( 'Expected legal JavaScript' );
			}
		}
		return __export;
	}( types, isObject );

	/* parse/Parser/_Parser.js */
	var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

		var Parser, ParseError, leadingWhitespace = /^\s+/;
		ParseError = function( message ) {
			this.name = 'ParseError';
			this.message = message;
			try {
				throw new Error( message );
			} catch ( e ) {
				this.stack = e.stack;
			}
		};
		ParseError.prototype = Error.prototype;
		Parser = function( str, options ) {
			var items, item, lineStart = 0;
			this.str = str;
			this.options = options || {};
			this.pos = 0;
			this.lines = this.str.split( '\n' );
			this.lineEnds = this.lines.map( function( line ) {
				var lineEnd = lineStart + line.length + 1;
				// +1 for the newline
				lineStart = lineEnd;
				return lineEnd;
			}, 0 );
			// Custom init logic
			if ( this.init )
				this.init( str, options );
			items = [];
			while ( this.pos < this.str.length && ( item = this.read() ) ) {
				items.push( item );
			}
			this.leftover = this.remaining();
			this.result = this.postProcess ? this.postProcess( items, options ) : items;
		};
		Parser.prototype = {
			read: function( converters ) {
				var pos, i, len, item;
				if ( !converters )
					converters = this.converters;
				pos = this.pos;
				len = converters.length;
				for ( i = 0; i < len; i += 1 ) {
					this.pos = pos;
					// reset for each attempt
					if ( item = converters[ i ]( this ) ) {
						return item;
					}
				}
				return null;
			},
			readExpression: function() {
				// The conditional operator is the lowest precedence operator (except yield,
				// assignment operators, and commas, none of which are supported), so we
				// start there. If it doesn't match, it 'falls through' to progressively
				// higher precedence operators, until it eventually matches (or fails to
				// match) a 'primary' - a literal or a reference. This way, the abstract syntax
				// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
				return getConditional( this );
			},
			flattenExpression: flattenExpression,
			getLinePos: function( char ) {
				var lineNum = 0,
					lineStart = 0,
					columnNum;
				while ( char >= this.lineEnds[ lineNum ] ) {
					lineStart = this.lineEnds[ lineNum ];
					lineNum += 1;
				}
				columnNum = char - lineStart;
				return [
					lineNum + 1,
					columnNum + 1,
					char
				];
			},
			error: function( message ) {
				var pos, lineNum, columnNum, line, annotation, error;
				pos = this.getLinePos( this.pos );
				lineNum = pos[ 0 ];
				columnNum = pos[ 1 ];
				line = this.lines[ pos[ 0 ] - 1 ];
				annotation = line + '\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';
				error = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\n' + annotation );
				error.line = pos[ 0 ];
				error.character = pos[ 1 ];
				error.shortMessage = message;
				throw error;
			},
			matchString: function( string ) {
				if ( this.str.substr( this.pos, string.length ) === string ) {
					this.pos += string.length;
					return string;
				}
			},
			matchPattern: function( pattern ) {
				var match;
				if ( match = pattern.exec( this.remaining() ) ) {
					this.pos += match[ 0 ].length;
					return match[ 1 ] || match[ 0 ];
				}
			},
			allowWhitespace: function() {
				this.matchPattern( leadingWhitespace );
			},
			remaining: function() {
				return this.str.substring( this.pos );
			},
			nextChar: function() {
				return this.str.charAt( this.pos );
			}
		};
		Parser.extend = function( proto ) {
			var Parent = this,
				Child, key;
			Child = function( str, options ) {
				Parser.call( this, str, options );
			};
			Child.prototype = create( Parent.prototype );
			for ( key in proto ) {
				if ( hasOwnProperty.call( proto, key ) ) {
					Child.prototype[ key ] = proto[ key ];
				}
			}
			Child.extend = Parser.extend;
			return Child;
		};
		circular.Parser = Parser;
		return Parser;
	}( circular, create, hasOwn, conditional, flattenExpression );

	/* parse/converters/mustache/delimiterChange.js */
	var delimiterChange = function() {

		var delimiterChangePattern = /^[^\s=]+/,
			whitespacePattern = /^\s+/;
		return function( parser ) {
			var start, opening, closing;
			if ( !parser.matchString( '=' ) ) {
				return null;
			}
			start = parser.pos;
			// allow whitespace before new opening delimiter
			parser.allowWhitespace();
			opening = parser.matchPattern( delimiterChangePattern );
			if ( !opening ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace (in fact, it's necessary...)
			if ( !parser.matchPattern( whitespacePattern ) ) {
				return null;
			}
			closing = parser.matchPattern( delimiterChangePattern );
			if ( !closing ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing '='
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			return [
				opening,
				closing
			];
		};
	}();

	/* parse/converters/mustache/delimiterTypes.js */
	var delimiterTypes = [ {
		delimiters: 'delimiters',
		isTriple: false,
		isStatic: false
	}, {
		delimiters: 'tripleDelimiters',
		isTriple: true,
		isStatic: false
	}, {
		delimiters: 'staticDelimiters',
		isTriple: false,
		isStatic: true
	}, {
		delimiters: 'staticTripleDelimiters',
		isTriple: true,
		isStatic: true
	} ];

	/* parse/converters/mustache/type.js */
	var type = function( types ) {

		var mustacheTypes = {
			'#': types.SECTION,
			'^': types.INVERTED,
			'/': types.CLOSING,
			'>': types.PARTIAL,
			'!': types.COMMENT,
			'&': types.TRIPLE
		};
		return function( parser ) {
			var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
			if ( !type ) {
				return null;
			}
			parser.pos += 1;
			return type;
		};
	}( types );

	/* parse/converters/mustache/handlebarsBlockCodes.js */
	var handlebarsBlockCodes = function( types ) {

		return {
			'each': types.SECTION_EACH,
			'if': types.SECTION_IF,
			'if-with': types.SECTION_IF_WITH,
			'with': types.SECTION_WITH,
			'unless': types.SECTION_UNLESS
		};
	}( types );

	/* empty/legacy.js */
	var legacy = null;

	/* parse/converters/mustache/content.js */
	var content = function( types, mustacheType, handlebarsBlockCodes ) {

		var __export;
		var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
			arrayMemberPattern = /^[0-9][1-9]*$/,
			handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
			legalReference;
		legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
		__export = function( parser, delimiterType ) {
			var start, pos, mustache, type, block, expression, i, remaining, index, delimiters;
			start = parser.pos;
			mustache = {};
			delimiters = parser[ delimiterType.delimiters ];
			if ( delimiterType.isStatic ) {
				mustache.s = true;
			}
			// Determine mustache type
			if ( delimiterType.isTriple ) {
				mustache.t = types.TRIPLE;
			} else {
				// We need to test for expressions before we test for mustache type, because
				// an expression that begins '!' looks a lot like a comment
				if ( parser.remaining()[ 0 ] === '!' ) {
					try {
						expression = parser.readExpression();
						// Was it actually an expression, or a comment block in disguise?
						parser.allowWhitespace();
						if ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {
							expression = null;
						} else {
							mustache.t = types.INTERPOLATOR;
						}
					} catch ( err ) {}
					if ( !expression ) {
						index = parser.remaining().indexOf( delimiters[ 1 ] );
						if ( ~index ) {
							parser.pos += index;
						} else {
							parser.error( 'Expected closing delimiter (\'' + delimiters[ 1 ] + '\')' );
						}
						return {
							t: types.COMMENT
						};
					}
				}
				if ( !expression ) {
					type = mustacheType( parser );
					mustache.t = type || types.INTERPOLATOR;
					// default
					// See if there's an explicit section type e.g. {{#with}}...{{/with}}
					if ( type === types.SECTION ) {
						if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
							mustache.n = block;
						}
						parser.allowWhitespace();
					} else if ( type === types.COMMENT || type === types.CLOSING ) {
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];
							parser.pos += index;
							return mustache;
						}
					}
				}
			}
			if ( !expression ) {
				// allow whitespace
				parser.allowWhitespace();
				// get expression
				expression = parser.readExpression();
				// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These
				// cases involve a bit of a hack - we want to turn it into the equivalent of
				// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append
				// a 'contextPartialExpression' to the mustache, and process the context instead of
				// the reference
				var temp;
				if ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {
					mustache = {
						contextPartialExpression: expression
					};
					expression = temp;
				}
				// With certain valid references that aren't valid expressions,
				// e.g. {{1.foo}}, we have a problem: it looks like we've got an
				// expression, but the expression didn't consume the entire
				// reference. So we need to check that the mustache delimiters
				// appear next, unless there's an index reference (i.e. a colon)
				remaining = parser.remaining();
				if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
					pos = parser.pos;
					parser.pos = start;
					remaining = parser.remaining();
					index = remaining.indexOf( delimiters[ 1 ] );
					if ( index !== -1 ) {
						mustache.r = remaining.substr( 0, index ).trim();
						// Check it's a legal reference
						if ( !legalReference.test( mustache.r ) ) {
							parser.error( 'Expected a legal Mustache reference' );
						}
						parser.pos += index;
						return mustache;
					}
					parser.pos = pos;
				}
			}
			refineExpression( parser, expression, mustache );
			// if there was context, process the expression now and save it for later
			if ( mustache.contextPartialExpression ) {
				mustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {
					t: types.PARTIAL
				} ) ];
			}
			// optional index reference
			if ( i = parser.matchPattern( indexRefPattern ) ) {
				mustache.i = i;
			}
			return mustache;
		};

		function refineExpression( parser, expression, mustache ) {
			var referenceExpression;
			if ( expression ) {
				while ( expression.t === types.BRACKETED && expression.x ) {
					expression = expression.x;
				}
				// special case - integers should be treated as array members references,
				// rather than as expressions in their own right
				if ( expression.t === types.REFERENCE ) {
					mustache.r = expression.n;
				} else {
					if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
						mustache.r = expression.v;
					} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
						mustache.rx = referenceExpression;
					} else {
						mustache.x = parser.flattenExpression( expression );
					}
				}
				return mustache;
			}
		}
		// TODO refactor this! it's bewildering
		function getReferenceExpression( parser, expression ) {
			var members = [],
				refinement;
			while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
				refinement = expression.r;
				if ( refinement.x ) {
					if ( refinement.x.t === types.REFERENCE ) {
						members.unshift( refinement.x );
					} else {
						members.unshift( parser.flattenExpression( refinement.x ) );
					}
				} else {
					members.unshift( refinement.n );
				}
				expression = expression.x;
			}
			if ( expression.t !== types.REFERENCE ) {
				return null;
			}
			return {
				r: expression.n,
				m: members
			};
		}
		return __export;
	}( types, type, handlebarsBlockCodes, legacy );

	/* parse/converters/mustache.js */
	var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

		var __export;
		var delimiterChangeToken = {
			t: types.DELIMCHANGE,
			exclude: true
		};
		__export = getMustache;

		function getMustache( parser ) {
			var types;
			// If we're inside a <script> or <style> tag, and we're not
			// interpolating, bug out
			if ( parser.interpolate[ parser.inside ] === false ) {
				return null;
			}
			types = delimiterTypes.slice().sort( function compare( a, b ) {
				// Sort in order of descending opening delimiter length (longer first),
				// to protect against opening delimiters being substrings of each other
				return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
			} );
			return function r( type ) {
				if ( !type ) {
					return null;
				} else {
					return getMustacheOfType( parser, type ) || r( types.shift() );
				}
			}( types.shift() );
		}

		function getMustacheOfType( parser, delimiterType ) {
			var start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;
			start = parser.pos;
			delimiters = parser[ delimiterType.delimiters ];
			if ( !parser.matchString( delimiters[ 0 ] ) ) {
				return null;
			}
			// delimiter change?
			if ( mustache = delimiterChange( parser ) ) {
				// find closing delimiter or abort...
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					return null;
				}
				// ...then make the switch
				parser[ delimiterType.delimiters ] = mustache;
				return delimiterChangeToken;
			}
			parser.allowWhitespace();
			mustache = mustacheContent( parser, delimiterType );
			if ( mustache === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing delimiter
			parser.allowWhitespace();
			if ( !parser.matchString( delimiters[ 1 ] ) ) {
				parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
			}
			if ( mustache.t === types.COMMENT ) {
				mustache.exclude = true;
			}
			if ( mustache.t === types.CLOSING ) {
				parser.sectionDepth -= 1;
				if ( parser.sectionDepth < 0 ) {
					parser.pos = start;
					parser.error( 'Attempted to close a section that wasn\'t open' );
				}
			}
			// partials with context
			if ( mustache.contextPartialExpression ) {
				mustache.f = mustache.contextPartialExpression;
				mustache.t = types.SECTION;
				mustache.n = 'with';
				delete mustache.contextPartialExpression;
			} else if ( isSection( mustache ) ) {
				parser.sectionDepth += 1;
				children = [];
				currentChildren = children;
				expectedClose = mustache.n;
				while ( child = parser.read() ) {
					if ( child.t === types.CLOSING ) {
						if ( expectedClose && child.r !== expectedClose ) {
							parser.error( 'Expected {{/' + expectedClose + '}}' );
						}
						break;
					}
					// {{else}} tags require special treatment
					if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
						// no {{else}} allowed in {{#unless}}
						if ( mustache.n === 'unless' ) {
							parser.error( '{{else}} not allowed in {{#unless}}' );
						} else {
							currentChildren = elseChildren = [];
							continue;
						}
					}
					currentChildren.push( child );
				}
				if ( children.length ) {
					mustache.f = children;
				}
				if ( elseChildren && elseChildren.length ) {
					mustache.l = elseChildren;
					if ( mustache.n === 'with' ) {
						mustache.n = 'if-with';
					}
				}
			}
			if ( parser.includeLinePositions ) {
				mustache.p = parser.getLinePos( start );
			}
			// Replace block name with code
			if ( mustache.n ) {
				mustache.n = handlebarsBlockCodes[ mustache.n ];
			} else if ( mustache.t === types.INVERTED ) {
				mustache.t = types.SECTION;
				mustache.n = types.SECTION_UNLESS;
			}
			return mustache;
		}

		function isSection( mustache ) {
			return mustache.t === types.SECTION || mustache.t === types.INVERTED;
		}
		return __export;
	}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

	/* parse/converters/comment.js */
	var comment = function( types ) {

		var OPEN_COMMENT = '<!--',
			CLOSE_COMMENT = '-->';
		return function( parser ) {
			var start, content, remaining, endIndex, comment;
			start = parser.pos;
			if ( !parser.matchString( OPEN_COMMENT ) ) {
				return null;
			}
			remaining = parser.remaining();
			endIndex = remaining.indexOf( CLOSE_COMMENT );
			if ( endIndex === -1 ) {
				parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
			}
			content = remaining.substr( 0, endIndex );
			parser.pos += endIndex + 3;
			comment = {
				t: types.COMMENT,
				c: content
			};
			if ( parser.includeLinePositions ) {
				comment.p = parser.getLinePos( start );
			}
			return comment;
		};
	}( types );

	/* config/voidElementNames.js */
	var voidElementNames = function() {

		var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
		return voidElementNames;
	}();

	/* parse/converters/utils/getLowestIndex.js */
	var getLowestIndex = function( haystack, needles ) {
		var i, index, lowest;
		i = needles.length;
		while ( i-- ) {
			index = haystack.indexOf( needles[ i ] );
			// short circuit
			if ( !index ) {
				return 0;
			}
			if ( index === -1 ) {
				continue;
			}
			if ( !lowest || index < lowest ) {
				lowest = index;
			}
		}
		return lowest || -1;
	};

	/* shared/decodeCharacterReferences.js */
	var decodeCharacterReferences = function() {

		var __export;
		var htmlEntities, controlCharacters, entityPattern;
		htmlEntities = {
			quot: 34,
			amp: 38,
			apos: 39,
			lt: 60,
			gt: 62,
			nbsp: 160,
			iexcl: 161,
			cent: 162,
			pound: 163,
			curren: 164,
			yen: 165,
			brvbar: 166,
			sect: 167,
			uml: 168,
			copy: 169,
			ordf: 170,
			laquo: 171,
			not: 172,
			shy: 173,
			reg: 174,
			macr: 175,
			deg: 176,
			plusmn: 177,
			sup2: 178,
			sup3: 179,
			acute: 180,
			micro: 181,
			para: 182,
			middot: 183,
			cedil: 184,
			sup1: 185,
			ordm: 186,
			raquo: 187,
			frac14: 188,
			frac12: 189,
			frac34: 190,
			iquest: 191,
			Agrave: 192,
			Aacute: 193,
			Acirc: 194,
			Atilde: 195,
			Auml: 196,
			Aring: 197,
			AElig: 198,
			Ccedil: 199,
			Egrave: 200,
			Eacute: 201,
			Ecirc: 202,
			Euml: 203,
			Igrave: 204,
			Iacute: 205,
			Icirc: 206,
			Iuml: 207,
			ETH: 208,
			Ntilde: 209,
			Ograve: 210,
			Oacute: 211,
			Ocirc: 212,
			Otilde: 213,
			Ouml: 214,
			times: 215,
			Oslash: 216,
			Ugrave: 217,
			Uacute: 218,
			Ucirc: 219,
			Uuml: 220,
			Yacute: 221,
			THORN: 222,
			szlig: 223,
			agrave: 224,
			aacute: 225,
			acirc: 226,
			atilde: 227,
			auml: 228,
			aring: 229,
			aelig: 230,
			ccedil: 231,
			egrave: 232,
			eacute: 233,
			ecirc: 234,
			euml: 235,
			igrave: 236,
			iacute: 237,
			icirc: 238,
			iuml: 239,
			eth: 240,
			ntilde: 241,
			ograve: 242,
			oacute: 243,
			ocirc: 244,
			otilde: 245,
			ouml: 246,
			divide: 247,
			oslash: 248,
			ugrave: 249,
			uacute: 250,
			ucirc: 251,
			uuml: 252,
			yacute: 253,
			thorn: 254,
			yuml: 255,
			OElig: 338,
			oelig: 339,
			Scaron: 352,
			scaron: 353,
			Yuml: 376,
			fnof: 402,
			circ: 710,
			tilde: 732,
			Alpha: 913,
			Beta: 914,
			Gamma: 915,
			Delta: 916,
			Epsilon: 917,
			Zeta: 918,
			Eta: 919,
			Theta: 920,
			Iota: 921,
			Kappa: 922,
			Lambda: 923,
			Mu: 924,
			Nu: 925,
			Xi: 926,
			Omicron: 927,
			Pi: 928,
			Rho: 929,
			Sigma: 931,
			Tau: 932,
			Upsilon: 933,
			Phi: 934,
			Chi: 935,
			Psi: 936,
			Omega: 937,
			alpha: 945,
			beta: 946,
			gamma: 947,
			delta: 948,
			epsilon: 949,
			zeta: 950,
			eta: 951,
			theta: 952,
			iota: 953,
			kappa: 954,
			lambda: 955,
			mu: 956,
			nu: 957,
			xi: 958,
			omicron: 959,
			pi: 960,
			rho: 961,
			sigmaf: 962,
			sigma: 963,
			tau: 964,
			upsilon: 965,
			phi: 966,
			chi: 967,
			psi: 968,
			omega: 969,
			thetasym: 977,
			upsih: 978,
			piv: 982,
			ensp: 8194,
			emsp: 8195,
			thinsp: 8201,
			zwnj: 8204,
			zwj: 8205,
			lrm: 8206,
			rlm: 8207,
			ndash: 8211,
			mdash: 8212,
			lsquo: 8216,
			rsquo: 8217,
			sbquo: 8218,
			ldquo: 8220,
			rdquo: 8221,
			bdquo: 8222,
			dagger: 8224,
			Dagger: 8225,
			bull: 8226,
			hellip: 8230,
			permil: 8240,
			prime: 8242,
			Prime: 8243,
			lsaquo: 8249,
			rsaquo: 8250,
			oline: 8254,
			frasl: 8260,
			euro: 8364,
			image: 8465,
			weierp: 8472,
			real: 8476,
			trade: 8482,
			alefsym: 8501,
			larr: 8592,
			uarr: 8593,
			rarr: 8594,
			darr: 8595,
			harr: 8596,
			crarr: 8629,
			lArr: 8656,
			uArr: 8657,
			rArr: 8658,
			dArr: 8659,
			hArr: 8660,
			forall: 8704,
			part: 8706,
			exist: 8707,
			empty: 8709,
			nabla: 8711,
			isin: 8712,
			notin: 8713,
			ni: 8715,
			prod: 8719,
			sum: 8721,
			minus: 8722,
			lowast: 8727,
			radic: 8730,
			prop: 8733,
			infin: 8734,
			ang: 8736,
			and: 8743,
			or: 8744,
			cap: 8745,
			cup: 8746,
			'int': 8747,
			there4: 8756,
			sim: 8764,
			cong: 8773,
			asymp: 8776,
			ne: 8800,
			equiv: 8801,
			le: 8804,
			ge: 8805,
			sub: 8834,
			sup: 8835,
			nsub: 8836,
			sube: 8838,
			supe: 8839,
			oplus: 8853,
			otimes: 8855,
			perp: 8869,
			sdot: 8901,
			lceil: 8968,
			rceil: 8969,
			lfloor: 8970,
			rfloor: 8971,
			lang: 9001,
			rang: 9002,
			loz: 9674,
			spades: 9824,
			clubs: 9827,
			hearts: 9829,
			diams: 9830
		};
		controlCharacters = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
		__export = function decodeCharacterReferences( html ) {
			return html.replace( entityPattern, function( match, entity ) {
				var code;
				// Handle named entities
				if ( entity[ 0 ] !== '#' ) {
					code = htmlEntities[ entity ];
				} else if ( entity[ 1 ] === 'x' ) {
					code = parseInt( entity.substring( 2 ), 16 );
				} else {
					code = parseInt( entity.substring( 1 ), 10 );
				}
				if ( !code ) {
					return match;
				}
				return String.fromCharCode( validateCode( code ) );
			} );
		};
		// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
		// code points with alternatives in some cases - since we're bypassing that mechanism, we need
		// to replace them ourselves
		//
		// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
		function validateCode( code ) {
			if ( !code ) {
				return 65533;
			}
			// line feed becomes generic whitespace
			if ( code === 10 ) {
				return 32;
			}
			// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
			if ( code < 128 ) {
				return code;
			}
			// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
			// to correct the mistake or we'll end up with missing  signs and so on
			if ( code <= 159 ) {
				return controlCharacters[ code - 128 ];
			}
			// basic multilingual plane
			if ( code < 55296 ) {
				return code;
			}
			// UTF-16 surrogate halves
			if ( code <= 57343 ) {
				return 65533;
			}
			// rest of the basic multilingual plane
			if ( code <= 65535 ) {
				return code;
			}
			return 65533;
		}
		return __export;
	}( legacy );

	/* parse/converters/text.js */
	var text = function( getLowestIndex, decodeCharacterReferences ) {

		return function( parser ) {
			var index, remaining, disallowed, barrier;
			remaining = parser.remaining();
			barrier = parser.inside ? '</' + parser.inside : '<';
			if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
				index = remaining.indexOf( barrier );
			} else {
				disallowed = [
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				// http://developers.whatwg.org/syntax.html#syntax-attributes
				if ( parser.inAttribute === true ) {
					// we're inside an unquoted attribute value
					disallowed.push( '"', '\'', '=', '<', '>', '`' );
				} else if ( parser.inAttribute ) {
					// quoted attribute value
					disallowed.push( parser.inAttribute );
				} else {
					disallowed.push( barrier );
				}
				index = getLowestIndex( remaining, disallowed );
			}
			if ( !index ) {
				return null;
			}
			if ( index === -1 ) {
				index = remaining.length;
			}
			parser.pos += index;
			return parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );
		};
	}( getLowestIndex, decodeCharacterReferences );

	/* parse/converters/element/closingTag.js */
	var closingTag = function( types ) {

		var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
		return function( parser ) {
			var tag;
			// are we looking at a closing tag?
			if ( !parser.matchString( '</' ) ) {
				return null;
			}
			if ( tag = parser.matchPattern( closingTagPattern ) ) {
				return {
					t: types.CLOSING_TAG,
					e: tag
				};
			}
			// We have an illegal closing tag, report it
			parser.pos -= 2;
			parser.error( 'Illegal closing tag' );
		};
	}( types );

	/* parse/converters/element/attribute.js */
	var attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {

		var __export;
		var attributeNamePattern = /^[^\s"'>\/=]+/,
			unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
		__export = getAttribute;

		function getAttribute( parser ) {
			var attr, name, value;
			parser.allowWhitespace();
			name = parser.matchPattern( attributeNamePattern );
			if ( !name ) {
				return null;
			}
			attr = {
				name: name
			};
			value = getAttributeValue( parser );
			if ( value ) {
				attr.value = value;
			}
			return attr;
		}

		function getAttributeValue( parser ) {
			var start, valueStart, startDepth, value;
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			parser.allowWhitespace();
			valueStart = parser.pos;
			startDepth = parser.sectionDepth;
			value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
			if ( parser.sectionDepth !== startDepth ) {
				parser.pos = valueStart;
				parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
			}
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			if ( !value.length ) {
				return null;
			}
			if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
				return decodeCharacterReferences( value[ 0 ] );
			}
			return value;
		}

		function getUnquotedAttributeValueToken( parser ) {
			var start, text, haystack, needles, index;
			start = parser.pos;
			text = parser.matchPattern( unquotedAttributeValueTextPattern );
			if ( !text ) {
				return null;
			}
			haystack = text;
			needles = [
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
				text = text.substr( 0, index );
				parser.pos = start + text.length;
			}
			return text;
		}

		function getUnquotedAttributeValue( parser ) {
			var tokens, token;
			parser.inAttribute = true;
			tokens = [];
			token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			}
			if ( !tokens.length ) {
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedAttributeValue( parser, quoteMark ) {
			var start, tokens, token;
			start = parser.pos;
			if ( !parser.matchString( quoteMark ) ) {
				return null;
			}
			parser.inAttribute = quoteMark;
			tokens = [];
			token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			}
			if ( !parser.matchString( quoteMark ) ) {
				parser.pos = start;
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedStringToken( parser, quoteMark ) {
			var start, index, haystack, needles;
			start = parser.pos;
			haystack = parser.remaining();
			needles = [
				quoteMark,
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			index = getLowestIndex( haystack, needles );
			if ( index === -1 ) {
				parser.error( 'Quoted attribute value must have a closing quote' );
			}
			if ( !index ) {
				return null;
			}
			parser.pos += index;
			return haystack.substr( 0, index );
		}
		return __export;
	}( getLowestIndex, mustache, decodeCharacterReferences );

	/* utils/parseJSON.js */
	var parseJSON = function( Parser, getStringLiteral, getKey ) {

		var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
		specials = {
			'true': true,
			'false': false,
			'undefined': undefined,
			'null': null
		};
		specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
		numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		placeholderPattern = /\$\{([^\}]+)\}/g;
		placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
		onlyWhitespace = /^\s*$/;
		JsonParser = Parser.extend( {
			init: function( str, options ) {
				this.values = options.values;
				this.allowWhitespace();
			},
			postProcess: function( result ) {
				if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
					return null;
				}
				return {
					value: result[ 0 ].v
				};
			},
			converters: [

				function getPlaceholder( parser ) {
					var placeholder;
					if ( !parser.values ) {
						return null;
					}
					placeholder = parser.matchPattern( placeholderAtStartPattern );
					if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
						return {
							v: parser.values[ placeholder ]
						};
					}
				},
				function getSpecial( parser ) {
					var special;
					if ( special = parser.matchPattern( specialsPattern ) ) {
						return {
							v: specials[ special ]
						};
					}
				},
				function getNumber( parser ) {
					var number;
					if ( number = parser.matchPattern( numberPattern ) ) {
						return {
							v: +number
						};
					}
				},
				function getString( parser ) {
					var stringLiteral = getStringLiteral( parser ),
						values;
					if ( stringLiteral && ( values = parser.values ) ) {
						return {
							v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
								return $1 in values ? values[ $1 ] : $1;
							} )
						};
					}
					return stringLiteral;
				},
				function getObject( parser ) {
					var result, pair;
					if ( !parser.matchString( '{' ) ) {
						return null;
					}
					result = {};
					parser.allowWhitespace();
					if ( parser.matchString( '}' ) ) {
						return {
							v: result
						};
					}
					while ( pair = getKeyValuePair( parser ) ) {
						result[ pair.key ] = pair.value;
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
					}
					return null;
				},
				function getArray( parser ) {
					var result, valueToken;
					if ( !parser.matchString( '[' ) ) {
						return null;
					}
					result = [];
					parser.allowWhitespace();
					if ( parser.matchString( ']' ) ) {
						return {
							v: result
						};
					}
					while ( valueToken = parser.read() ) {
						result.push( valueToken.v );
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
						parser.allowWhitespace();
					}
					return null;
				}
			]
		} );

		function getKeyValuePair( parser ) {
			var key, valueToken, pair;
			parser.allowWhitespace();
			key = getKey( parser );
			if ( !key ) {
				return null;
			}
			pair = {
				key: key
			};
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				return null;
			}
			parser.allowWhitespace();
			valueToken = parser.read();
			if ( !valueToken ) {
				return null;
			}
			pair.value = valueToken.v;
			return pair;
		}
		return function( str, values ) {
			var parser = new JsonParser( str, {
				values: values
			} );
			return parser.result;
		};
	}( Parser, stringLiteral, key );

	/* parse/converters/element/processDirective.js */
	var processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {

		var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
			ExpressionParser;
		ExpressionParser = Parser.extend( {
			converters: [ conditional ]
		} );
		// TODO clean this up, it's shocking
		return function( tokens ) {
			var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;
			if ( typeof tokens === 'string' ) {
				if ( match = methodCallPattern.exec( tokens ) ) {
					result = {
						m: match[ 1 ]
					};
					args = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';
					parser = new ExpressionParser( args );
					result.a = flattenExpression( parser.result[ 0 ] );
					return result;
				}
				if ( tokens.indexOf( ':' ) === -1 ) {
					return tokens.trim();
				}
				tokens = [ tokens ];
			}
			result = {};
			directiveName = [];
			directiveArgs = [];
			if ( tokens ) {
				while ( tokens.length ) {
					token = tokens.shift();
					if ( typeof token === 'string' ) {
						colonIndex = token.indexOf( ':' );
						if ( colonIndex === -1 ) {
							directiveName.push( token );
						} else {
							// is the colon the first character?
							if ( colonIndex ) {
								// no
								directiveName.push( token.substr( 0, colonIndex ) );
							}
							// if there is anything after the colon in this token, treat
							// it as the first token of the directiveArgs fragment
							if ( token.length > colonIndex + 1 ) {
								directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
							}
							break;
						}
					} else {
						directiveName.push( token );
					}
				}
				directiveArgs = directiveArgs.concat( tokens );
			}
			if ( !directiveName.length ) {
				result = '';
			} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
				result = {
					// TODO is this really necessary? just use the array
					n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
				};
				if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
					parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
					result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
				} else {
					result.d = directiveArgs;
				}
			} else {
				result = directiveName;
			}
			return result;
		};
	}( Parser, conditional, flattenExpression, parseJSON );

	/* parse/converters/element.js */
	var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

		var __export;
		var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
			validTagNameFollower = /^[\s\n\/>]/,
			onPattern = /^on/,
			proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
			reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
			directives = {
				'intro-outro': 't0',
				intro: 't1',
				outro: 't2',
				decorator: 'o'
			},
			exclude = {
				exclude: true
			},
			converters, disallowedContents;
		// Different set of converters, because this time we're looking for closing tags
		converters = [
			getMustache,
			getComment,
			getElement,
			getText,
			getClosingTag
		];
		// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
		disallowedContents = {
			li: [ 'li' ],
			dt: [
				'dt',
				'dd'
			],
			dd: [
				'dt',
				'dd'
			],
			p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
			rt: [
				'rt',
				'rp'
			],
			rp: [
				'rt',
				'rp'
			],
			optgroup: [ 'optgroup' ],
			option: [
				'option',
				'optgroup'
			],
			thead: [
				'tbody',
				'tfoot'
			],
			tbody: [
				'tbody',
				'tfoot'
			],
			tfoot: [ 'tbody' ],
			tr: [
				'tr',
				'tbody'
			],
			td: [
				'td',
				'th',
				'tr'
			],
			th: [
				'td',
				'th',
				'tr'
			]
		};
		__export = getElement;

		function getElement( parser ) {
			var start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
			start = parser.pos;
			if ( parser.inside || parser.inAttribute ) {
				return null;
			}
			if ( !parser.matchString( '<' ) ) {
				return null;
			}
			// if this is a closing tag, abort straight away
			if ( parser.nextChar() === '/' ) {
				return null;
			}
			element = {
				t: types.ELEMENT
			};
			if ( parser.includeLinePositions ) {
				element.p = parser.getLinePos( start );
			}
			if ( parser.matchString( '!' ) ) {
				element.y = 1;
			}
			// element name
			element.e = parser.matchPattern( tagNamePattern );
			if ( !element.e ) {
				return null;
			}
			// next character must be whitespace, closing solidus or '>'
			if ( !validTagNameFollower.test( parser.nextChar() ) ) {
				parser.error( 'Illegal tag name' );
			}
			addProxyEvent = function( name, directive ) {
				var directiveName = directive.n || directive;
				if ( reservedEventNames.test( directiveName ) ) {
					parser.pos -= directiveName.length;
					parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
				}
				element.v[ name ] = directive;
			};
			parser.allowWhitespace();
			// directives and attributes
			while ( attribute = getMustache( parser ) || getAttribute( parser ) ) {
				// regular attributes
				if ( attribute.name ) {
					// intro, outro, decorator
					if ( directiveName = directives[ attribute.name ] ) {
						element[ directiveName ] = processDirective( attribute.value );
					} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
						if ( !element.v )
							element.v = {};
						directive = processDirective( attribute.value );
						addProxyEvent( match[ 1 ], directive );
					} else {
						if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
							if ( !element.a )
								element.a = {};
							element.a[ attribute.name ] = attribute.value || 0;
						}
					}
				} else {
					if ( !element.m )
						element.m = [];
					element.m.push( attribute );
				}
				parser.allowWhitespace();
			}
			// allow whitespace before closing solidus
			parser.allowWhitespace();
			// self-closing solidus?
			if ( parser.matchString( '/' ) ) {
				selfClosing = true;
			}
			// closing angle bracket
			if ( !parser.matchString( '>' ) ) {
				return null;
			}
			lowerCaseName = element.e.toLowerCase();
			if ( !selfClosing && !voidElementNames.test( element.e ) ) {
				// Special case - if we open a script element, further tags should
				// be ignored unless they're a closing script element
				if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
					parser.inside = lowerCaseName;
				}
				children = [];
				while ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {
					// Special case - closing section tag
					if ( child.t === types.CLOSING ) {
						break;
					}
					if ( child.t === types.CLOSING_TAG ) {
						break;
					}
					children.push( child );
				}
				if ( children.length ) {
					element.f = children;
				}
			}
			parser.inside = null;
			if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
				return exclude;
			}
			return element;
		}

		function canContain( name, remaining ) {
			var match, disallowed;
			match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
			disallowed = disallowedContents[ name ];
			if ( !match || !disallowed ) {
				return true;
			}
			return !~disallowed.indexOf( match[ 1 ].toLowerCase() );
		}
		return __export;
	}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

	/* parse/utils/trimWhitespace.js */
	var trimWhitespace = function() {

		var leadingWhitespace = /^[ \t\f\r\n]+/,
			trailingWhitespace = /[ \t\f\r\n]+$/;
		return function( items, leading, trailing ) {
			var item;
			if ( leading ) {
				item = items[ 0 ];
				if ( typeof item === 'string' ) {
					item = item.replace( leadingWhitespace, '' );
					if ( !item ) {
						items.shift();
					} else {
						items[ 0 ] = item;
					}
				}
			}
			if ( trailing ) {
				item = items[ items.length - 1 ];
				if ( typeof item === 'string' ) {
					item = item.replace( trailingWhitespace, '' );
					if ( !item ) {
						items.pop();
					} else {
						items[ items.length - 1 ] = item;
					}
				}
			}
		};
	}();

	/* parse/utils/stripStandalones.js */
	var stripStandalones = function( types ) {

		var __export;
		var leadingLinebreak = /^\s*\r?\n/,
			trailingLinebreak = /\r?\n\s*$/;
		__export = function( items ) {
			var i, current, backOne, backTwo, lastSectionItem;
			for ( i = 1; i < items.length; i += 1 ) {
				current = items[ i ];
				backOne = items[ i - 1 ];
				backTwo = items[ i - 2 ];
				// if we're at the end of a [text][comment][text] sequence...
				if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
					// ... and the comment is a standalone (i.e. line breaks either side)...
					if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
						// ... then we want to remove the whitespace after the first line break
						items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
						// and the leading line break of the second text token
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
				// if the current item is a section, and it is preceded by a linebreak, and
				// its first item is a linebreak...
				if ( isSection( current ) && isString( backOne ) ) {
					if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
						items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
						current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
					}
				}
				// if the last item was a section, and it is followed by a linebreak, and
				// its last item is a linebreak...
				if ( isString( current ) && isSection( backOne ) ) {
					lastSectionItem = backOne.f[ backOne.f.length - 1 ];
					if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
						backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
			}
			return items;
		};

		function isString( item ) {
			return typeof item === 'string';
		}

		function isComment( item ) {
			return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
		}

		function isSection( item ) {
			return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
		}
		return __export;
	}( types );

	/* utils/escapeRegExp.js */
	var escapeRegExp = function() {

		var pattern = /[-/\\^$*+?.()|[\]{}]/g;
		return function escapeRegExp( str ) {
			return str.replace( pattern, '\\$&' );
		};
	}();

	/* parse/_parse.js */
	var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {

		var __export;
		var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
			preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
			leadingWhitespace = /^\s+/,
			trailingWhitespace = /\s+$/;
		StandardParser = Parser.extend( {
			init: function( str, options ) {
				// config
				setDelimiters( options, this );
				this.sectionDepth = 0;
				this.interpolate = {
					script: !options.interpolate || options.interpolate.script !== false,
					style: !options.interpolate || options.interpolate.style !== false
				};
				if ( options.sanitize === true ) {
					options.sanitize = {
						// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
						elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
						eventAttributes: true
					};
				}
				this.sanitizeElements = options.sanitize && options.sanitize.elements;
				this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
				this.includeLinePositions = options.includeLinePositions;
			},
			postProcess: function( items, options ) {
				if ( this.sectionDepth > 0 ) {
					this.error( 'A section was left open' );
				}
				cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
				return items;
			},
			converters: [
				mustache,
				comment,
				element,
				text
			]
		} );
		parse = function( template ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;
			setDelimiters( options );
			inlinePartialStart = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*>\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			inlinePartialEnd = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*\\/\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			result = {
				v: 1
			};
			if ( inlinePartialStart.test( template ) ) {
				remaining = template;
				template = '';
				while ( startMatch = inlinePartialStart.exec( remaining ) ) {
					name = startMatch[ 1 ];
					template += remaining.substr( 0, startMatch.index );
					remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
					endMatch = inlinePartialEnd.exec( remaining );
					if ( !endMatch || endMatch[ 1 ] !== name ) {
						throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for "' + name + '", but ' + ( endMatch ? 'instead found "' + endMatch[ 1 ] + '"' : ' no closing found' ) );
					}
					( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
					remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
				}
				template += remaining;
				result.p = partials;
			}
			result.t = new StandardParser( template, options ).result;
			return result;
		};
		__export = parse;

		function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
			var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
			// First pass - remove standalones and comments etc
			stripStandalones( items );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Remove delimiter changes, unsafe elements etc
				if ( item.exclude ) {
					items.splice( i, 1 );
				} else if ( stripComments && item.t === types.COMMENT ) {
					items.splice( i, 1 );
				}
			}
			// If necessary, remove leading and trailing whitespace
			trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Recurse
				if ( item.f ) {
					preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
					if ( !preserveWhitespaceInsideFragment ) {
						previousItem = items[ i - 1 ];
						nextItem = items[ i + 1 ];
						// if the previous item was a text item with trailing whitespace,
						// remove leading whitespace inside the fragment
						if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
							removeLeadingWhitespaceInsideFragment = true;
						}
						// and vice versa
						if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
							removeTrailingWhitespaceInsideFragment = true;
						}
					}
					cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
				}
				// Split if-else blocks into two (an if, and an unless)
				if ( item.l ) {
					cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					if ( rewriteElse ) {
						unlessBlock = {
							t: 4,
							n: types.SECTION_UNLESS,
							f: item.l
						};
						// copy the conditional based on its type
						if ( item.r ) {
							unlessBlock.r = item.r;
						}
						if ( item.x ) {
							unlessBlock.x = item.x;
						}
						if ( item.rx ) {
							unlessBlock.rx = item.rx;
						}
						items.splice( i + 1, 0, unlessBlock );
						delete item.l;
					}
				}
				// Clean up element attributes
				if ( item.a ) {
					for ( key in item.a ) {
						if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
							cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						}
					}
				}
			}
			// final pass - fuse text nodes together
			i = items.length;
			while ( i-- ) {
				if ( typeof items[ i ] === 'string' ) {
					if ( typeof items[ i + 1 ] === 'string' ) {
						items[ i ] = items[ i ] + items[ i + 1 ];
						items.splice( i + 1, 1 );
					}
					if ( !preserveWhitespace ) {
						items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
					}
					if ( items[ i ] === '' ) {
						items.splice( i, 1 );
					}
				}
			}
		}

		function setDelimiters( source ) {
			var target = arguments[ 1 ];
			if ( target === void 0 )
				target = source;
			target.delimiters = source.delimiters || [
				'{{',
				'}}'
			];
			target.tripleDelimiters = source.tripleDelimiters || [
				'{{{',
				'}}}'
			];
			target.staticDelimiters = source.staticDelimiters || [
				'[[',
				']]'
			];
			target.staticTripleDelimiters = source.staticTripleDelimiters || [
				'[[[',
				']]]'
			];
		}
		return __export;
	}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );

	/* config/options/groups/optionGroup.js */
	var optionGroup = function() {

		return function createOptionGroup( keys, config ) {
			var group = keys.map( config );
			keys.forEach( function( key, i ) {
				group[ key ] = group[ i ];
			} );
			return group;
		};
	}( legacy );

	/* config/options/groups/parseOptions.js */
	var parseOptions = function( optionGroup ) {

		var keys, parseOptions;
		keys = [
			'preserveWhitespace',
			'sanitize',
			'stripComments',
			'delimiters',
			'tripleDelimiters',
			'interpolate'
		];
		parseOptions = optionGroup( keys, function( key ) {
			return key;
		} );
		return parseOptions;
	}( optionGroup );

	/* config/options/template/parser.js */
	var parser = function( errors, isClient, parse, create, parseOptions ) {

		var parser = {
			parse: doParse,
			fromId: fromId,
			isHashedId: isHashedId,
			isParsed: isParsed,
			getParseOptions: getParseOptions,
			createHelper: createHelper
		};

		function createHelper( parseOptions ) {
			var helper = create( parser );
			helper.parse = function( template, options ) {
				return doParse( template, options || parseOptions );
			};
			return helper;
		}

		function doParse( template, parseOptions ) {
			if ( !parse ) {
				throw new Error( errors.missingParser );
			}
			return parse( template, parseOptions || this.options );
		}

		function fromId( id, options ) {
			var template;
			if ( !isClient ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
			}
			if ( isHashedId( id ) ) {
				id = id.substring( 1 );
			}
			if ( !( template = document.getElementById( id ) ) ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Could not find template element with id #' + id );
			}
			if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
			}
			return template.innerHTML;
		}

		function isHashedId( id ) {
			return id && id.charAt( 0 ) === '#';
		}

		function isParsed( template ) {
			return !( typeof template === 'string' );
		}

		function getParseOptions( ractive ) {
			// Could be Ractive or a Component
			if ( ractive.defaults ) {
				ractive = ractive.defaults;
			}
			return parseOptions.reduce( function( val, key ) {
				val[ key ] = ractive[ key ];
				return val;
			}, {} );
		}
		return parser;
	}( errors, isClient, parse, create, parseOptions );

	/* config/options/template/template.js */
	var template = function( parser, parse ) {

		var templateConfig = {
			name: 'template',
			extend: function extend( Parent, proto, options ) {
				var template;
				// only assign if exists
				if ( 'template' in options ) {
					template = options.template;
					if ( typeof template === 'function' ) {
						proto.template = template;
					} else {
						proto.template = parseIfString( template, proto );
					}
				}
			},
			init: function init( Parent, ractive, options ) {
				var template, fn;
				// TODO because of prototypal inheritance, we might just be able to use
				// ractive.template, and not bother passing through the Parent object.
				// At present that breaks the test mocks' expectations
				template = 'template' in options ? options.template : Parent.prototype.template;
				if ( typeof template === 'function' ) {
					fn = template;
					template = getDynamicTemplate( ractive, fn );
					ractive._config.template = {
						fn: fn,
						result: template
					};
				}
				template = parseIfString( template, ractive );
				// TODO the naming of this is confusing - ractive.template refers to [...],
				// but Component.prototype.template refers to {v:1,t:[],p:[]}...
				// it's unnecessary, because the developer never needs to access
				// ractive.template
				ractive.template = template.t;
				if ( template.p ) {
					extendPartials( ractive.partials, template.p );
				}
			},
			reset: function( ractive ) {
				var result = resetValue( ractive ),
					parsed;
				if ( result ) {
					parsed = parseIfString( result, ractive );
					ractive.template = parsed.t;
					extendPartials( ractive.partials, parsed.p, true );
					return true;
				}
			}
		};

		function resetValue( ractive ) {
			var initial = ractive._config.template,
				result;
			// If this isn't a dynamic template, there's nothing to do
			if ( !initial || !initial.fn ) {
				return;
			}
			result = getDynamicTemplate( ractive, initial.fn );
			// TODO deep equality check to prevent unnecessary re-rendering
			// in the case of already-parsed templates
			if ( result !== initial.result ) {
				initial.result = result;
				result = parseIfString( result, ractive );
				return result;
			}
		}

		function getDynamicTemplate( ractive, fn ) {
			var helper = parser.createHelper( parser.getParseOptions( ractive ) );
			return fn.call( ractive, ractive.data, helper );
		}

		function parseIfString( template, ractive ) {
			if ( typeof template === 'string' ) {
				// ID of an element containing the template?
				if ( template[ 0 ] === '#' ) {
					template = parser.fromId( template );
				}
				template = parse( template, parser.getParseOptions( ractive ) );
			} else if ( template.v !== 1 ) {
				throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
			}
			return template;
		}

		function extendPartials( existingPartials, newPartials, overwrite ) {
			if ( !newPartials )
				return;
			// TODO there's an ambiguity here - we need to overwrite in the `reset()`
			// case, but not initially...
			for ( var key in newPartials ) {
				if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
					existingPartials[ key ] = newPartials[ key ];
				}
			}
		}
		return templateConfig;
	}( parser, parse );

	/* config/options/Registry.js */
	var Registry = function( create ) {

		function Registry( name, useDefaults ) {
			this.name = name;
			this.useDefaults = useDefaults;
		}
		Registry.prototype = {
			constructor: Registry,
			extend: function( Parent, proto, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
			},
			init: function( Parent, ractive, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
			},
			configure: function( Parent, target, options ) {
				var name = this.name,
					option = options[ name ],
					registry;
				registry = create( Parent[ name ] );
				for ( var key in option ) {
					registry[ key ] = option[ key ];
				}
				target[ name ] = registry;
			},
			reset: function( ractive ) {
				var registry = ractive[ this.name ];
				var changed = false;
				Object.keys( registry ).forEach( function( key ) {
					var item = registry[ key ];
					if ( item._fn ) {
						if ( item._fn.isOwner ) {
							registry[ key ] = item._fn;
						} else {
							delete registry[ key ];
						}
						changed = true;
					}
				} );
				return changed;
			},
			findOwner: function( ractive, key ) {
				return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
			},
			findConstructor: function( constructor, key ) {
				if ( !constructor ) {
					return;
				}
				return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
			},
			find: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ];
				} );
			},
			findInstance: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ] ? r : void 0;
				} );
			}
		};

		function recurseFind( ractive, fn ) {
			var find, parent;
			if ( find = fn( ractive ) ) {
				return find;
			}
			if ( !ractive.isolated && ( parent = ractive._parent ) ) {
				return recurseFind( parent, fn );
			}
		}
		return Registry;
	}( create, legacy );

	/* config/options/groups/registries.js */
	var registries = function( optionGroup, Registry ) {

		var keys = [
				'adaptors',
				'components',
				'computed',
				'decorators',
				'easing',
				'events',
				'interpolators',
				'partials',
				'transitions'
			],
			registries = optionGroup( keys, function( key ) {
				return new Registry( key, key === 'computed' );
			} );
		return registries;
	}( optionGroup, Registry );

	/* utils/noop.js */
	var noop = function() {};

	/* utils/wrapPrototypeMethod.js */
	var wrapPrototypeMethod = function( noop ) {

		var __export;
		__export = function wrap( parent, name, method ) {
			if ( !/_super/.test( method ) ) {
				return method;
			}
			var wrapper = function wrapSuper() {
				var superMethod = getSuperMethod( wrapper._parent, name ),
					hasSuper = '_super' in this,
					oldSuper = this._super,
					result;
				this._super = superMethod;
				result = method.apply( this, arguments );
				if ( hasSuper ) {
					this._super = oldSuper;
				} else {
					delete this._super;
				}
				return result;
			};
			wrapper._parent = parent;
			wrapper._method = method;
			return wrapper;
		};

		function getSuperMethod( parent, name ) {
			var method;
			if ( name in parent ) {
				var value = parent[ name ];
				if ( typeof value === 'function' ) {
					method = value;
				} else {
					method = function returnValue() {
						return value;
					};
				}
			} else {
				method = noop;
			}
			return method;
		}
		return __export;
	}( noop );

	/* config/deprecate.js */
	var deprecate = function( warn, isArray ) {

		function deprecate( options, deprecated, correct ) {
			if ( deprecated in options ) {
				if ( !( correct in options ) ) {
					warn( getMessage( deprecated, correct ) );
					options[ correct ] = options[ deprecated ];
				} else {
					throw new Error( getMessage( deprecated, correct, true ) );
				}
			}
		}

		function getMessage( deprecated, correct, isError ) {
			return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
		}

		function deprecateEventDefinitions( options ) {
			deprecate( options, 'eventDefinitions', 'events' );
		}

		function deprecateAdaptors( options ) {
			// Using extend with Component instead of options,
			// like Human.extend( Spider ) means adaptors as a registry
			// gets copied to options. So we have to check if actually an array
			if ( isArray( options.adaptors ) ) {
				deprecate( options, 'adaptors', 'adapt' );
			}
		}
		return function deprecateOptions( options ) {
			deprecate( options, 'beforeInit', 'onconstruct' );
			deprecate( options, 'init', 'onrender' );
			deprecate( options, 'complete', 'oncomplete' );
			deprecateEventDefinitions( options );
			deprecateAdaptors( options );
		};
	}( warn, isArray );

	/* config/config.js */
	var config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {

		var custom, options, config, blacklisted;
		// would be nice to not have these here,
		// they get added during initialise, so for now we have
		// to make sure not to try and extend them.
		// Possibly, we could re-order and not add till later
		// in process.
		blacklisted = {
			'_parent': true,
			'_component': true
		};
		custom = {
			data: data,
			template: template,
			css: css
		};
		options = Object.keys( defaults ).filter( function( key ) {
			return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
		} );
		// this defines the order:
		config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
		for ( var key in custom ) {
			config[ key ] = custom[ key ];
		}
		// for iteration
		config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
			return r.name;
		} ) ).concat( [ 'css' ] );
		// add these to blacklisted key's that we don't double extend
		config.keys.forEach( function( key ) {
			return blacklisted[ key ] = true;
		} );
		config.parseOptions = parseOptions;
		config.registries = registries;

		function customConfig( method, key, Parent, instance, options ) {
			custom[ key ][ method ]( Parent, instance, options );
		}
		config.extend = function( Parent, proto, options ) {
			configure( 'extend', Parent, proto, options );
		};
		config.init = function( Parent, ractive, options ) {
			configure( 'init', Parent, ractive, options );
		};

		function isStandardDefaultKey( key ) {
			return key in defaults && !( key in config.parseOptions ) && !( key in custom );
		}

		function configure( method, Parent, instance, options ) {
			deprecate( options );
			customConfig( method, 'data', Parent, instance, options );
			config.parseOptions.forEach( function( key ) {
				if ( key in options ) {
					instance[ key ] = options[ key ];
				}
			} );
			for ( var key in options ) {
				if ( isStandardDefaultKey( key ) ) {
					var value = options[ key ];
					instance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;
				}
			}
			config.registries.forEach( function( registry ) {
				registry[ method ]( Parent, instance, options );
			} );
			customConfig( method, 'template', Parent, instance, options );
			customConfig( method, 'css', Parent, instance, options );
			extendOtherMethods( Parent.prototype, instance, options );
		}

		function extendOtherMethods( parent, instance, options ) {
			for ( var key in options ) {
				if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
					var member = options[ key ];
					// if this is a method that overwrites a method, wrap it:
					if ( typeof member === 'function' ) {
						member = wrapPrototype( parent, key, member );
					}
					instance[ key ] = member;
				}
			}
		}
		config.reset = function( ractive ) {
			return config.filter( function( c ) {
				return c.reset && c.reset( ractive );
			} ).map( function( c ) {
				return c.name;
			} );
		};
		config.getConstructTarget = function( ractive, options ) {
			if ( options.onconstruct ) {
				// pretend this object literal is the ractive instance
				return {
					onconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),
					fire: ractive.fire.bind( ractive )
				};
			} else {
				return ractive;
			}
		};
		return config;
	}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

	/* shared/interpolate.js */
	var interpolate = function( circular, warn, interpolators, config ) {

		var __export;
		var interpolate = function( from, to, ractive, type ) {
			if ( from === to ) {
				return snap( to );
			}
			if ( type ) {
				var interpol = config.registries.interpolators.find( ractive, type );
				if ( interpol ) {
					return interpol( from, to ) || snap( to );
				}
				warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
			}
			return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );
		};
		circular.interpolate = interpolate;
		__export = interpolate;

		function snap( to ) {
			return function() {
				return to;
			};
		}
		return __export;
	}( circular, warn, interpolators, config );

	/* Ractive/prototype/animate/Animation.js */
	var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

		var Animation = function( options ) {
			var key;
			this.startTime = Date.now();
			// from and to
			for ( key in options ) {
				if ( options.hasOwnProperty( key ) ) {
					this[ key ] = options[ key ];
				}
			}
			this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
			this.running = true;
			this.tick();
		};
		Animation.prototype = {
			tick: function() {
				var elapsed, t, value, timeNow, index, keypath;
				keypath = this.keypath;
				if ( this.running ) {
					timeNow = Date.now();
					elapsed = timeNow - this.startTime;
					if ( elapsed >= this.duration ) {
						if ( keypath !== null ) {
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, this.to );
							runloop.end();
						}
						if ( this.step ) {
							this.step( 1, this.to );
						}
						this.complete( this.to );
						index = this.root._animations.indexOf( this );
						// TODO investigate why this happens
						if ( index === -1 ) {
							warn( 'Animation was not found' );
						}
						this.root._animations.splice( index, 1 );
						this.running = false;
						return false;
					}
					t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
					if ( keypath !== null ) {
						value = this.interpolator( t );
						runloop.start( this.root );
						this.root.viewmodel.set( keypath, value );
						runloop.end();
					}
					if ( this.step ) {
						this.step( t, value );
					}
					return true;
				}
				return false;
			},
			stop: function() {
				var index;
				this.running = false;
				index = this.root._animations.indexOf( this );
				// TODO investigate why this happens
				if ( index === -1 ) {
					warn( 'Animation was not found' );
				}
				this.root._animations.splice( index, 1 );
			}
		};
		return Animation;
	}( warn, runloop, interpolate );

	/* Ractive/prototype/animate.js */
	var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

		var __export;
		var noop = function() {},
			noAnimation = {
				stop: noop
			};
		__export = function Ractive$animate( keypath, to, options ) {
			var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
			promise = new Promise( function( fulfil ) {
				fulfilPromise = fulfil;
			} );
			// animate multiple keypaths
			if ( typeof keypath === 'object' ) {
				options = to || {};
				easing = options.easing;
				duration = options.duration;
				animations = [];
				// we don't want to pass the `step` and `complete` handlers, as they will
				// run for each animation! So instead we'll store the handlers and create
				// our own...
				step = options.step;
				complete = options.complete;
				if ( step || complete ) {
					currentValues = {};
					options.step = null;
					options.complete = null;
					makeValueCollector = function( keypath ) {
						return function( t, value ) {
							currentValues[ keypath ] = value;
						};
					};
				}
				for ( k in keypath ) {
					if ( keypath.hasOwnProperty( k ) ) {
						if ( step || complete ) {
							collectValue = makeValueCollector( k );
							options = {
								easing: easing,
								duration: duration
							};
							if ( step ) {
								options.step = collectValue;
							}
						}
						options.complete = complete ? collectValue : noop;
						animations.push( animate( this, k, keypath[ k ], options ) );
					}
				}
				// Create a dummy animation, to facilitate step/complete
				// callbacks, and Promise fulfilment
				dummyOptions = {
					easing: easing,
					duration: duration
				};
				if ( step ) {
					dummyOptions.step = function( t ) {
						step( t, currentValues );
					};
				}
				if ( complete ) {
					promise.then( function( t ) {
						complete( t, currentValues );
					} );
				}
				dummyOptions.complete = fulfilPromise;
				dummy = animate( this, null, null, dummyOptions );
				animations.push( dummy );
				promise.stop = function() {
					var animation;
					while ( animation = animations.pop() ) {
						animation.stop();
					}
					if ( dummy ) {
						dummy.stop();
					}
				};
				return promise;
			}
			// animate a single keypath
			options = options || {};
			if ( options.complete ) {
				promise.then( options.complete );
			}
			options.complete = fulfilPromise;
			animation = animate( this, keypath, to, options );
			promise.stop = function() {
				animation.stop();
			};
			return promise;
		};

		function animate( root, keypath, to, options ) {
			var easing, duration, animation, from;
			if ( keypath ) {
				keypath = normaliseKeypath( keypath );
			}
			if ( keypath !== null ) {
				from = root.viewmodel.get( keypath );
			}
			// cancel any existing animation
			// TODO what about upstream/downstream keypaths?
			animations.abort( keypath, root );
			// don't bother animating values that stay the same
			if ( isEqual( from, to ) ) {
				if ( options.complete ) {
					options.complete( options.to );
				}
				return noAnimation;
			}
			// easing function
			if ( options.easing ) {
				if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = root.easing[ options.easing ];
				}
				if ( typeof easing !== 'function' ) {
					easing = null;
				}
			}
			// duration
			duration = options.duration === undefined ? 400 : options.duration;
			// TODO store keys, use an internal set method
			animation = new Animation( {
				keypath: keypath,
				from: from,
				to: to,
				root: root,
				duration: duration,
				easing: easing,
				interpolator: options.interpolator,
				// TODO wrap callbacks if necessary, to use instance as context
				step: options.step,
				complete: options.complete
			} );
			animations.add( animation );
			root._animations.push( animation );
			return animation;
		}
		return __export;
	}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

	/* Ractive/prototype/detach.js */
	var Ractive$detach = function( Hook, removeFromArray ) {

		var detachHook = new Hook( 'detach' );
		return function Ractive$detach() {
			if ( this.detached ) {
				return this.detached;
			}
			if ( this.el ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.detached = this.fragment.detach();
			detachHook.fire( this );
			return this.detached;
		};
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* Ractive/prototype/find.js */
	var Ractive$find = function Ractive$find( selector ) {
		if ( !this.el ) {
			return null;
		}
		return this.fragment.find( selector );
	};

	/* utils/matches.js */
	var matches = function( isClient, vendors, createElement ) {

		var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
		if ( !isClient ) {
			matches = null;
		} else {
			div = createElement( 'div' );
			methodNames = [
				'matches',
				'matchesSelector'
			];
			makeFunction = function( methodName ) {
				return function( node, selector ) {
					return node[ methodName ]( selector );
				};
			};
			i = methodNames.length;
			while ( i-- && !matches ) {
				unprefixed = methodNames[ i ];
				if ( div[ unprefixed ] ) {
					matches = makeFunction( unprefixed );
				} else {
					j = vendors.length;
					while ( j-- ) {
						prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
						if ( div[ prefixed ] ) {
							matches = makeFunction( prefixed );
							break;
						}
					}
				}
			}
			// IE8...
			if ( !matches ) {
				matches = function( node, selector ) {
					var nodes, parentNode, i;
					parentNode = node.parentNode;
					if ( !parentNode ) {
						// empty dummy <div>
						div.innerHTML = '';
						parentNode = div;
						node = node.cloneNode();
						div.appendChild( node );
					}
					nodes = parentNode.querySelectorAll( selector );
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] === node ) {
							return true;
						}
					}
					return false;
				};
			}
		}
		return matches;
	}( isClient, vendors, createElement );

	/* Ractive/prototype/shared/makeQuery/test.js */
	var Ractive$shared_makeQuery_test = function( matches ) {

		return function( item, noDirty ) {
			var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
			if ( itemMatches ) {
				this.push( item.node || item.instance );
				if ( !noDirty ) {
					this._makeDirty();
				}
				return true;
			}
		};
	}( matches );

	/* Ractive/prototype/shared/makeQuery/cancel.js */
	var Ractive$shared_makeQuery_cancel = function() {
		var liveQueries, selector, index;
		liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
		selector = this.selector;
		index = liveQueries.indexOf( selector );
		if ( index !== -1 ) {
			liveQueries.splice( index, 1 );
			liveQueries[ selector ] = null;
		}
	};

	/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
	var Ractive$shared_makeQuery_sortByItemPosition = function() {

		var __export;
		__export = function( a, b ) {
			var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
			ancestryA = getAncestry( a.component || a._ractive.proxy );
			ancestryB = getAncestry( b.component || b._ractive.proxy );
			oldestA = ancestryA[ ancestryA.length - 1 ];
			oldestB = ancestryB[ ancestryB.length - 1 ];
			// remove items from the end of both ancestries as long as they are identical
			// - the final one removed is the closest mutual ancestor
			while ( oldestA && oldestA === oldestB ) {
				ancestryA.pop();
				ancestryB.pop();
				mutualAncestor = oldestA;
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
			}
			// now that we have the mutual ancestor, we can find which is earliest
			oldestA = oldestA.component || oldestA;
			oldestB = oldestB.component || oldestB;
			fragmentA = oldestA.parentFragment;
			fragmentB = oldestB.parentFragment;
			// if both items share a parent fragment, our job is easy
			if ( fragmentA === fragmentB ) {
				indexA = fragmentA.items.indexOf( oldestA );
				indexB = fragmentB.items.indexOf( oldestB );
				// if it's the same index, it means one contains the other,
				// so we see which has the longest ancestry
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			// if mutual ancestor is a section, we first test to see which section
			// fragment comes first
			if ( fragments = mutualAncestor.fragments ) {
				indexA = fragments.indexOf( fragmentA );
				indexB = fragments.indexOf( fragmentB );
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
		};

		function getParent( item ) {
			var parentFragment;
			if ( parentFragment = item.parentFragment ) {
				return parentFragment.owner;
			}
			if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
				return parentFragment.owner;
			}
		}

		function getAncestry( item ) {
			var ancestry, ancestor;
			ancestry = [ item ];
			ancestor = getParent( item );
			while ( ancestor ) {
				ancestry.push( ancestor );
				ancestor = getParent( ancestor );
			}
			return ancestry;
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
	var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

		return function( node, otherNode ) {
			var bitmask;
			if ( node.compareDocumentPosition ) {
				bitmask = node.compareDocumentPosition( otherNode );
				return bitmask & 2 ? 1 : -1;
			}
			// In old IE, we can piggy back on the mechanism for
			// comparing component positions
			return sortByItemPosition( node, otherNode );
		};
	}( Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/sort.js */
	var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

		return function() {
			this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
			this._dirty = false;
		};
	}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/dirty.js */
	var Ractive$shared_makeQuery_dirty = function( runloop ) {

		return function() {
			var this$0 = this;
			if ( !this._dirty ) {
				this._dirty = true;
				// Once the DOM has been updated, ensure the query
				// is correctly ordered
				runloop.scheduleTask( function() {
					this$0._sort();
				} );
			}
		};
	}( runloop );

	/* Ractive/prototype/shared/makeQuery/remove.js */
	var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
		var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
		if ( index !== -1 ) {
			this.splice( index, 1 );
		}
	};

	/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
	var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

		return function makeQuery( ractive, selector, live, isComponentQuery ) {
			var query = [];
			defineProperties( query, {
				selector: {
					value: selector
				},
				live: {
					value: live
				},
				_isComponentQuery: {
					value: isComponentQuery
				},
				_test: {
					value: test
				}
			} );
			if ( !live ) {
				return query;
			}
			defineProperties( query, {
				cancel: {
					value: cancel
				},
				_root: {
					value: ractive
				},
				_sort: {
					value: sort
				},
				_makeDirty: {
					value: dirty
				},
				_remove: {
					value: remove
				},
				_dirty: {
					value: false,
					writable: true
				}
			} );
			return query;
		};
	}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

	/* Ractive/prototype/findAll.js */
	var Ractive$findAll = function( makeQuery ) {

		return function Ractive$findAll( selector, options ) {
			var liveQueries, query;
			if ( !this.el ) {
				return [];
			}
			options = options || {};
			liveQueries = this._liveQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, false );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAll( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findAllComponents.js */
	var Ractive$findAllComponents = function( makeQuery ) {

		return function Ractive$findAllComponents( selector, options ) {
			var liveQueries, query;
			options = options || {};
			liveQueries = this._liveComponentQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, true );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAllComponents( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findComponent.js */
	var Ractive$findComponent = function Ractive$findComponent( selector ) {
		return this.fragment.findComponent( selector );
	};

	/* utils/getPotentialWildcardMatches.js */
	var getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, i, result, wildcardKeypath;
			keys = keypath.split( '.' );
			if ( !( starMap = starMaps[ keys.length ] ) ) {
				starMap = getStarMap( keys.length );
			}
			result = [];
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			i = starMap.length;
			while ( i-- ) {
				wildcardKeypath = starMap[ i ].map( mapper ).join( '.' );
				if ( !result.hasOwnProperty( wildcardKeypath ) ) {
					result.push( wildcardKeypath );
					result[ wildcardKeypath ] = true;
				}
			}
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( num ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ num ] ) {
				starMap = [];
				while ( ones.length < num ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < num ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ num ] = starMap;
			}
			return starMaps[ num ];
		}
		return __export;
	}();

	/* Ractive/prototype/shared/fireEvent.js */
	var Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {

		var __export;
		__export = function fireEvent( ractive, eventName ) {
			var options = arguments[ 2 ];
			if ( options === void 0 )
				options = {};
			if ( !eventName ) {
				return;
			}
			if ( !options.event ) {
				options.event = {
					name: eventName,
					context: ractive.data,
					keypath: '',
					// until event not included as argument default
					_noArg: true
				};
			} else {
				options.event.name = eventName;
			}
			var eventNames = getPotentialWildcardMatches( eventName );
			fireEventAs( ractive, eventNames, options.event, options.args, true );
		};

		function fireEventAs( ractive, eventNames, event, args ) {
			var initialFire = arguments[ 4 ];
			if ( initialFire === void 0 )
				initialFire = false;
			var subscribers, i, bubble = true;
			if ( event ) {
				ractive.event = event;
			}
			for ( i = eventNames.length; i >= 0; i-- ) {
				subscribers = ractive._subs[ eventNames[ i ] ];
				if ( subscribers ) {
					bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
				}
			}
			if ( event ) {
				delete ractive.event;
			}
			if ( ractive._parent && bubble ) {
				if ( initialFire && ractive.component ) {
					var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];
					eventNames = getPotentialWildcardMatches( fullName );
					if ( event ) {
						event.component = ractive;
					}
				}
				fireEventAs( ractive._parent, eventNames, event, args );
			}
		}

		function notifySubscribers( ractive, subscribers, event, args ) {
			var originalEvent = null,
				stopEvent = false;
			if ( event && !event._noArg ) {
				args = [ event ].concat( args );
			}
			for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
				if ( subscribers[ i ].apply( ractive, args ) === false ) {
					stopEvent = true;
				}
			}
			if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
				originalEvent.preventDefault && originalEvent.preventDefault();
				originalEvent.stopPropagation && originalEvent.stopPropagation();
			}
			return !stopEvent;
		}
		return __export;
	}( getPotentialWildcardMatches );

	/* Ractive/prototype/fire.js */
	var Ractive$fire = function( fireEvent ) {

		return function Ractive$fire( eventName ) {
			var options = {
				args: Array.prototype.slice.call( arguments, 1 )
			};
			fireEvent( this, eventName, options );
		};
	}( Ractive$shared_fireEvent );

	/* Ractive/prototype/get.js */
	var Ractive$get = function( normaliseKeypath, resolveRef ) {

		var options = {
			capture: true
		};
		// top-level calls should be intercepted
		return function Ractive$get( keypath ) {
			var value;
			keypath = normaliseKeypath( keypath );
			value = this.viewmodel.get( keypath, options );
			// Create inter-component binding, if necessary
			if ( value === undefined && this._parent && !this.isolated ) {
				if ( resolveRef( this, keypath, this.fragment ) ) {
					// creates binding as side-effect, if appropriate
					value = this.viewmodel.get( keypath );
				}
			}
			return value;
		};
	}( normaliseKeypath, resolveRef );

	/* utils/getElement.js */
	var getElement = function getElement( input ) {
		var output;
		if ( !input || typeof input === 'boolean' ) {
			return;
		}
		if ( typeof window === 'undefined' || !document || !input ) {
			return null;
		}
		// We already have a DOM node - no work to do. (Duck typing alert!)
		if ( input.nodeType ) {
			return input;
		}
		// Get node from string
		if ( typeof input === 'string' ) {
			// try ID first
			output = document.getElementById( input );
			// then as selector, if possible
			if ( !output && document.querySelector ) {
				output = document.querySelector( input );
			}
			// did it work?
			if ( output && output.nodeType ) {
				return output;
			}
		}
		// If we've been given a collection (jQuery, Zepto etc), extract the first item
		if ( input[ 0 ] && input[ 0 ].nodeType ) {
			return input[ 0 ];
		}
		return null;
	};

	/* Ractive/prototype/insert.js */
	var Ractive$insert = function( Hook, getElement ) {

		var __export;
		var insertHook = new Hook( 'insert' );
		__export = function Ractive$insert( target, anchor ) {
			if ( !this.fragment.rendered ) {
				// TODO create, and link to, documentation explaining this
				throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
			}
			target = getElement( target );
			anchor = getElement( anchor ) || null;
			if ( !target ) {
				throw new Error( 'You must specify a valid target to insert into' );
			}
			target.insertBefore( this.detach(), anchor );
			this.el = target;
			( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
			this.detached = null;
			fireInsertHook( this );
		};

		function fireInsertHook( ractive ) {
			insertHook.fire( ractive );
			ractive.findAllComponents( '*' ).forEach( function( child ) {
				fireInsertHook( child.instance );
			} );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, getElement );

	/* Ractive/prototype/merge.js */
	var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

		return function Ractive$merge( keypath, array, options ) {
			var currentArray, promise;
			keypath = normaliseKeypath( keypath );
			currentArray = this.viewmodel.get( keypath );
			// If either the existing value or the new value isn't an
			// array, just do a regular set
			if ( !isArray( currentArray ) || !isArray( array ) ) {
				return this.set( keypath, array, options && options.complete );
			}
			// Manage transitions
			promise = runloop.start( this, true );
			this.viewmodel.merge( keypath, currentArray, array, options );
			runloop.end();
			// attach callback as fulfilment handler, if specified
			if ( options && options.complete ) {
				promise.then( options.complete );
			}
			return promise;
		};
	}( runloop, isArray, normaliseKeypath );

	/* Ractive/prototype/observe/Observer.js */
	var Ractive$observe_Observer = function( runloop, isEqual ) {

		var Observer = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.keypath = keypath;
			this.callback = callback;
			this.defer = options.defer;
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		Observer.prototype = {
			init: function( immediate ) {
				this.value = this.root.get( this.keypath );
				if ( immediate !== false ) {
					this.update();
				} else {
					this.oldValue = this.value;
				}
			},
			setValue: function( value ) {
				var this$0 = this;
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.update();
						} );
					} else {
						this.update();
					}
				}
			},
			update: function() {
				// Prevent infinite loops
				if ( this.updating ) {
					return;
				}
				this.updating = true;
				this.callback.call( this.context, this.value, this.oldValue, this.keypath );
				this.oldValue = this.value;
				this.updating = false;
			}
		};
		return Observer;
	}( runloop, isEqual );

	/* shared/getMatchingKeypaths.js */
	var getMatchingKeypaths = function( isArray ) {

		return function getMatchingKeypaths( ractive, pattern ) {
			var keys, key, matchingKeypaths;
			keys = pattern.split( '.' );
			matchingKeypaths = [ '' ];
			while ( key = keys.shift() ) {
				if ( key === '*' ) {
					// expand to find all valid child keypaths
					matchingKeypaths = matchingKeypaths.reduce( expand, [] );
				} else {
					if ( matchingKeypaths[ 0 ] === '' ) {
						// first key
						matchingKeypaths[ 0 ] = key;
					} else {
						matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
					}
				}
			}
			return matchingKeypaths;

			function expand( matchingKeypaths, keypath ) {
				var value, key, childKeypath;
				value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
				for ( key in value ) {
					if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
						// for benefit of IE8
						childKeypath = keypath ? keypath + '.' + key : key;
						matchingKeypaths.push( childKeypath );
					}
				}
				return matchingKeypaths;
			}

			function concatenate( key ) {
				return function( keypath ) {
					return keypath ? keypath + '.' + key : key;
				};
			}
		};
	}( isArray );

	/* Ractive/prototype/observe/getPattern.js */
	var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

		return function getPattern( ractive, pattern ) {
			var matchingKeypaths, values;
			matchingKeypaths = getMatchingKeypaths( ractive, pattern );
			values = {};
			matchingKeypaths.forEach( function( keypath ) {
				values[ keypath ] = ractive.get( keypath );
			} );
			return values;
		};
	}( getMatchingKeypaths );

	/* Ractive/prototype/observe/PatternObserver.js */
	var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

		var PatternObserver, wildcard = /\*/,
			slice = Array.prototype.slice;
		PatternObserver = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.callback = callback;
			this.defer = options.defer;
			this.keypath = keypath;
			this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
			this.values = {};
			if ( this.defer ) {
				this.proxies = [];
			}
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		PatternObserver.prototype = {
			init: function( immediate ) {
				var values, keypath;
				values = getPattern( this.root, this.keypath );
				if ( immediate !== false ) {
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
				} else {
					this.values = values;
				}
			},
			update: function( keypath ) {
				var this$0 = this;
				var values;
				if ( wildcard.test( keypath ) ) {
					values = getPattern( this.root, keypath );
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
					return;
				}
				// special case - array mutation should not trigger `array.*`
				// pattern observer with `array.length`
				if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
					return;
				}
				if ( this.defer && this.ready ) {
					runloop.scheduleTask( function() {
						return this$0.getProxy( keypath ).update();
					} );
					return;
				}
				this.reallyUpdate( keypath );
			},
			reallyUpdate: function( keypath ) {
				var value, keys, args;
				value = this.root.viewmodel.get( keypath );
				// Prevent infinite loops
				if ( this.updating ) {
					this.values[ keypath ] = value;
					return;
				}
				this.updating = true;
				if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
					keys = slice.call( this.regex.exec( keypath ), 1 );
					args = [
						value,
						this.values[ keypath ],
						keypath
					].concat( keys );
					this.callback.apply( this.context, args );
					this.values[ keypath ] = value;
				}
				this.updating = false;
			},
			getProxy: function( keypath ) {
				var self = this;
				if ( !this.proxies[ keypath ] ) {
					this.proxies[ keypath ] = {
						update: function() {
							self.reallyUpdate( keypath );
						}
					};
				}
				return this.proxies[ keypath ];
			}
		};
		return PatternObserver;
	}( runloop, isEqual, Ractive$observe_getPattern );

	/* Ractive/prototype/observe/getObserverFacade.js */
	var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

		var wildcard = /\*/,
			emptyObject = {};
		return function getObserverFacade( ractive, keypath, callback, options ) {
			var observer, isPatternObserver, cancelled;
			keypath = normaliseKeypath( keypath );
			options = options || emptyObject;
			// pattern observers are treated differently
			if ( wildcard.test( keypath ) ) {
				observer = new PatternObserver( ractive, keypath, callback, options );
				ractive.viewmodel.patternObservers.push( observer );
				isPatternObserver = true;
			} else {
				observer = new Observer( ractive, keypath, callback, options );
			}
			ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
			observer.init( options.init );
			// This flag allows observers to initialise even with undefined values
			observer.ready = true;
			return {
				cancel: function() {
					var index;
					if ( cancelled ) {
						return;
					}
					if ( isPatternObserver ) {
						index = ractive.viewmodel.patternObservers.indexOf( observer );
						ractive.viewmodel.patternObservers.splice( index, 1 );
						ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
					} else {
						ractive.viewmodel.unregister( keypath, observer, 'observers' );
					}
					cancelled = true;
				}
			};
		};
	}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

	/* Ractive/prototype/observe.js */
	var Ractive$observe = function( isObject, getObserverFacade ) {

		return function Ractive$observe( keypath, callback, options ) {
			var observers, map, keypaths, i;
			// Allow a map of keypaths to handlers
			if ( isObject( keypath ) ) {
				options = callback;
				map = keypath;
				observers = [];
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						callback = map[ keypath ];
						observers.push( this.observe( keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			}
			// Allow `ractive.observe( callback )` - i.e. observe entire model
			if ( typeof keypath === 'function' ) {
				options = callback;
				callback = keypath;
				keypath = '';
				return getObserverFacade( this, keypath, callback, options );
			}
			keypaths = keypath.split( ' ' );
			// Single keypath
			if ( keypaths.length === 1 ) {
				return getObserverFacade( this, keypath, callback, options );
			}
			// Multiple space-separated keypaths
			observers = [];
			i = keypaths.length;
			while ( i-- ) {
				keypath = keypaths[ i ];
				if ( keypath ) {
					observers.push( getObserverFacade( this, keypath, callback, options ) );
				}
			}
			return {
				cancel: function() {
					while ( observers.length ) {
						observers.pop().cancel();
					}
				}
			};
		};
	}( isObject, Ractive$observe_getObserverFacade );

	/* Ractive/prototype/shared/trim.js */
	var Ractive$shared_trim = function( str ) {
		return str.trim();
	};

	/* Ractive/prototype/shared/notEmptyString.js */
	var Ractive$shared_notEmptyString = function( str ) {
		return str !== '';
	};

	/* Ractive/prototype/off.js */
	var Ractive$off = function( trim, notEmptyString ) {

		return function Ractive$off( eventName, callback ) {
			var this$0 = this;
			var eventNames;
			// if no arguments specified, remove all callbacks
			if ( !eventName ) {
				// TODO use this code instead, once the following issue has been resolved
				// in PhantomJS (tests are unpassable otherwise!)
				// https://github.com/ariya/phantomjs/issues/11856
				// defineProperty( this, '_subs', { value: create( null ), configurable: true });
				for ( eventName in this._subs ) {
					delete this._subs[ eventName ];
				}
			} else {
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					var subscribers, index;
					// If we have subscribers for this event...
					if ( subscribers = this$0._subs[ eventName ] ) {
						// ...if a callback was specified, only remove that
						if ( callback ) {
							index = subscribers.indexOf( callback );
							if ( index !== -1 ) {
								subscribers.splice( index, 1 );
							}
						} else {
							this$0._subs[ eventName ] = [];
						}
					}
				} );
			}
			return this;
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* Ractive/prototype/on.js */
	var Ractive$on = function( trim, notEmptyString ) {

		return function Ractive$on( eventName, callback ) {
			var this$0 = this;
			var self = this,
				listeners, n, eventNames;
			// allow mutliple listeners to be bound in one go
			if ( typeof eventName === 'object' ) {
				listeners = [];
				for ( n in eventName ) {
					if ( eventName.hasOwnProperty( n ) ) {
						listeners.push( this.on( n, eventName[ n ] ) );
					}
				}
				return {
					cancel: function() {
						var listener;
						while ( listener = listeners.pop() ) {
							listener.cancel();
						}
					}
				};
			}
			// Handle multiple space-separated event names
			eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
			eventNames.forEach( function( eventName ) {
				( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
			} );
			return {
				cancel: function() {
					self.off( eventName, callback );
				}
			};
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* shared/getNewIndices.js */
	var getNewIndices = function() {

		var __export;
		// This function takes an array, the name of a mutator method, and the
		// arguments to call that mutator method with, and returns an array that
		// maps the old indices to their new indices.
		// So if you had something like this...
		//
		//     array = [ 'a', 'b', 'c', 'd' ];
		//     array.push( 'e' );
		//
		// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
		// have changed. If you then did this...
		//
		//     array.unshift( 'z' );
		//
		// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
		// one higher to make room for the 'z'. If you removed an item, the new index
		// would be -1...
		//
		//     array.splice( 2, 2 );
		//
		// ...this would result in [ 0, 1, -1, -1, 2, 3 ].
		//
		// This information is used to enable fast, non-destructive shuffling of list
		// sections when you do e.g. `ractive.splice( 'items', 2, 2 );
		__export = function getNewIndices( array, methodName, args ) {
			var spliceArguments, len, newIndices = [],
				removeStart, removeEnd, balance, i;
			spliceArguments = getSpliceEquivalent( array, methodName, args );
			if ( !spliceArguments ) {
				return null;
			}
			len = array.length;
			balance = spliceArguments.length - 2 - spliceArguments[ 1 ];
			removeStart = Math.min( len, spliceArguments[ 0 ] );
			removeEnd = removeStart + spliceArguments[ 1 ];
			for ( i = 0; i < removeStart; i += 1 ) {
				newIndices.push( i );
			}
			for ( ; i < removeEnd; i += 1 ) {
				newIndices.push( -1 );
			}
			for ( ; i < len; i += 1 ) {
				newIndices.push( i + balance );
			}
			return newIndices;
		};
		// The pop, push, shift an unshift methods can all be represented
		// as an equivalent splice
		function getSpliceEquivalent( array, methodName, args ) {
			switch ( methodName ) {
				case 'splice':
					if ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {
						args[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );
					}
					while ( args.length < 2 ) {
						args.push( 0 );
					}
					// ensure we only remove elements that exist
					args[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );
					return args;
				case 'sort':
				case 'reverse':
					return null;
				case 'pop':
					if ( array.length ) {
						return [
							array.length - 1,
							1
						];
					}
					return null;
				case 'push':
					return [
						array.length,
						0
					].concat( args );
				case 'shift':
					return [
						0,
						1
					];
				case 'unshift':
					return [
						0,
						0
					].concat( args );
			}
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeArrayMethod.js */
	var Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {

		var arrayProto = Array.prototype;
		return function( methodName ) {
			return function( keypath ) {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 1 );
				var array, newIndices = [],
					len, promise, result;
				array = this.get( keypath );
				len = array.length;
				if ( !isArray( array ) ) {
					throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
				}
				newIndices = getNewIndices( array, methodName, args );
				result = arrayProto[ methodName ].apply( array, args );
				promise = runloop.start( this, true ).then( function() {
					return result;
				} );
				if ( !!newIndices ) {
					this.viewmodel.smartUpdate( keypath, array, newIndices );
				} else {
					this.viewmodel.mark( keypath );
				}
				runloop.end();
				return promise;
			};
		};
	}( isArray, runloop, getNewIndices );

	/* Ractive/prototype/pop.js */
	var Ractive$pop = function( makeArrayMethod ) {

		return makeArrayMethod( 'pop' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/push.js */
	var Ractive$push = function( makeArrayMethod ) {

		return makeArrayMethod( 'push' );
	}( Ractive$shared_makeArrayMethod );

	/* global/css.js */
	var global_css = function( circular, isClient, removeFromArray ) {

		var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
			componentsInPage = {},
			styles = [];
		if ( !isClient ) {
			css = null;
		} else {
			circular.push( function() {
				runloop = circular.runloop;
			} );
			styleElement = document.createElement( 'style' );
			styleElement.type = 'text/css';
			head = document.getElementsByTagName( 'head' )[ 0 ];
			inDom = false;
			// Internet Exploder won't let you use styleSheet.innerHTML - we have to
			// use styleSheet.cssText instead
			styleSheet = styleElement.styleSheet;
			update = function() {
				var css;
				if ( styles.length ) {
					css = prefix + styles.join( ' ' );
					if ( styleSheet ) {
						styleSheet.cssText = css;
					} else {
						styleElement.innerHTML = css;
					}
					if ( !inDom ) {
						head.appendChild( styleElement );
						inDom = true;
					}
				} else if ( inDom ) {
					head.removeChild( styleElement );
					inDom = false;
				}
			};
			css = {
				add: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					if ( !componentsInPage[ Component._guid ] ) {
						// we create this counter so that we can in/decrement it as
						// instances are added and removed. When all components are
						// removed, the style is too
						componentsInPage[ Component._guid ] = 0;
						styles.push( Component.css );
						update();
					}
					componentsInPage[ Component._guid ] += 1;
				},
				remove: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					componentsInPage[ Component._guid ] -= 1;
					if ( !componentsInPage[ Component._guid ] ) {
						removeFromArray( styles, Component.css );
						runloop.scheduleTask( update );
					}
				}
			};
		}
		return css;
	}( circular, isClient, removeFromArray );

	/* Ractive/prototype/render.js */
	var Ractive$render = function( css, Hook, getElement, runloop ) {

		var renderHook = new Hook( 'render' ),
			completeHook = new Hook( 'complete' );
		return function Ractive$render( target, anchor ) {
			var this$0 = this;
			var promise, instances, transitionsEnabled;
			// if `noIntro` is `true`, temporarily disable transitions
			transitionsEnabled = this.transitionsEnabled;
			if ( this.noIntro ) {
				this.transitionsEnabled = false;
			}
			promise = runloop.start( this, true );
			runloop.scheduleTask( function() {
				return renderHook.fire( this$0 );
			}, true );
			if ( this.fragment.rendered ) {
				throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
			}
			target = getElement( target ) || this.el;
			anchor = getElement( anchor ) || this.anchor;
			this.el = target;
			this.anchor = anchor;
			// Add CSS, if applicable
			if ( this.constructor.css ) {
				css.add( this.constructor );
			}
			if ( target ) {
				if ( !( instances = target.__ractive_instances__ ) ) {
					target.__ractive_instances__ = [ this ];
				} else {
					instances.push( this );
				}
				if ( anchor ) {
					target.insertBefore( this.fragment.render(), anchor );
				} else {
					target.appendChild( this.fragment.render() );
				}
			}
			runloop.end();
			this.transitionsEnabled = transitionsEnabled;
			// It is now more problematic to know if the complete hook
			// would fire. Method checking is straight-forward, but would
			// also require preflighting event subscriptions. Which seems
			// like more work then just letting the promise happen.
			// But perhaps I'm wrong about that...
			promise.then( function() {
				return completeHook.fire( this$0 );
			} );
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );

	/* virtualdom/Fragment/prototype/bubble.js */
	var virtualdom_Fragment$bubble = function Fragment$bubble() {
		this.dirtyValue = this.dirtyArgs = true;
		if ( this.bound && typeof this.owner.bubble === 'function' ) {
			this.owner.bubble();
		}
	};

	/* virtualdom/Fragment/prototype/detach.js */
	var virtualdom_Fragment$detach = function Fragment$detach() {
		var docFrag;
		if ( this.items.length === 1 ) {
			return this.items[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.items.forEach( function( item ) {
			var node = item.detach();
			// TODO The if {...} wasn't previously required - it is now, because we're
			// forcibly detaching everything to reorder sections after an update. That's
			// a non-ideal brute force approach, implemented to get all the tests to pass
			// - as soon as it's replaced with something more elegant, this should
			// revert to `docFrag.appendChild( item.detach() )`
			if ( node ) {
				docFrag.appendChild( node );
			}
		} );
		return docFrag;
	};

	/* virtualdom/Fragment/prototype/find.js */
	var virtualdom_Fragment$find = function Fragment$find( selector ) {
		var i, len, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.find && ( queryResult = item.find( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findAll.js */
	var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAll ) {
					item.findAll( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findAllComponents.js */
	var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAllComponents ) {
					item.findAllComponents( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findComponent.js */
	var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
		var len, i, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findNextNode.js */
	var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
		var index = item.index,
			node;
		if ( this.items[ index + 1 ] ) {
			node = this.items[ index + 1 ].firstNode();
		} else if ( this.owner === this.root ) {
			if ( !this.owner.component ) {
				// TODO but something else could have been appended to
				// this.root.el, no?
				node = null;
			} else {
				node = this.owner.component.findNextNode();
			}
		} else {
			node = this.owner.findNextNode( this );
		}
		return node;
	};

	/* virtualdom/Fragment/prototype/firstNode.js */
	var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
		if ( this.items && this.items[ 0 ] ) {
			return this.items[ 0 ].firstNode();
		}
		return null;
	};

	/* virtualdom/Fragment/prototype/getNode.js */
	var virtualdom_Fragment$getNode = function Fragment$getNode() {
		var fragment = this;
		do {
			if ( fragment.pElement ) {
				return fragment.pElement.node;
			}
		} while ( fragment = fragment.parent );
		return this.root.detached || this.root.el;
	};

	/* virtualdom/Fragment/prototype/getValue.js */
	var virtualdom_Fragment$getValue = function( parseJSON ) {

		var __export;
		var empty = {};
		__export = function Fragment$getValue() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = empty;
			var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
			asArgs = options.args;
			cachedResult = asArgs ? 'argsList' : 'value';
			dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
			if ( this[ dirtyFlag ] ) {
				source = processItems( this.items, values = {}, this.root._guid );
				parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
				if ( !parsed ) {
					result = asArgs ? [ this.toString() ] : this.toString();
				} else {
					result = parsed.value;
				}
				this[ cachedResult ] = result;
				this[ dirtyFlag ] = false;
			}
			return this[ cachedResult ];
		};

		function processItems( items, values, guid, counter ) {
			counter = counter || 0;
			return items.map( function( item ) {
				var placeholderId, wrapped, value;
				if ( item.text ) {
					return item.text;
				}
				if ( item.fragments ) {
					return item.fragments.map( function( fragment ) {
						return processItems( fragment.items, values, guid, counter );
					} ).join( '' );
				}
				placeholderId = guid + '-' + counter++;
				if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
					value = wrapped.value;
				} else {
					value = item.getValue();
				}
				values[ placeholderId ] = value;
				return '${' + placeholderId + '}';
			} ).join( '' );
		}
		return __export;
	}( parseJSON );

	/* utils/escapeHtml.js */
	var escapeHtml = function() {

		var lessThan = /</g;
		var greaterThan = />/g;
		var amp = /&/g;
		return function escapeHtml( str ) {
			return str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
		};
	}();

	/* utils/detachNode.js */
	var detachNode = function detachNode( node ) {
		if ( node && node.parentNode ) {
			node.parentNode.removeChild( node );
		}
		return node;
	};

	/* virtualdom/items/shared/detach.js */
	var detach = function( detachNode ) {

		return function() {
			return detachNode( this.node );
		};
	}( detachNode );

	/* virtualdom/items/Text.js */
	var Text = function( types, escapeHtml, detach ) {

		var Text = function( options ) {
			this.type = types.TEXT;
			this.text = options.template;
		};
		Text.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.text );
				}
				return this.node;
			},
			toString: function( escape ) {
				return escape ? escapeHtml( this.text ) : this.text;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					return this.detach();
				}
			}
		};
		return Text;
	}( types, escapeHtml, detach );

	/* virtualdom/items/shared/unbind.js */
	var unbind = function unbind() {
		if ( this.registered ) {
			// this was registered as a dependant
			this.root.viewmodel.unregister( this.keypath, this );
		}
		if ( this.resolver ) {
			this.resolver.unbind();
		}
	};

	/* virtualdom/items/shared/Mustache/getValue.js */
	var getValue = function Mustache$getValue() {
		return this.value;
	};

	/* virtualdom/items/shared/utils/startsWithKeypath.js */
	var startsWithKeypath = function startsWithKeypath( target, keypath ) {
		return target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';
	};

	/* virtualdom/items/shared/utils/getNewKeypath.js */
	var getNewKeypath = function( startsWithKeypath ) {

		return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
			// exact match
			if ( targetKeypath === oldKeypath ) {
				return newKeypath !== undefined ? newKeypath : null;
			}
			// partial match based on leading keypath segments
			if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
				return newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
			}
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */
	var ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {

		var ReferenceResolver = function( owner, ref, callback ) {
			var keypath;
			this.ref = ref;
			this.resolved = false;
			this.root = owner.root;
			this.parentFragment = owner.parentFragment;
			this.callback = callback;
			keypath = resolveRef( owner.root, ref, owner.parentFragment );
			if ( keypath !== undefined ) {
				this.resolve( keypath );
			} else {
				runloop.addUnresolved( this );
			}
		};
		ReferenceResolver.prototype = {
			resolve: function( keypath ) {
				this.resolved = true;
				this.keypath = keypath;
				this.callback( keypath );
			},
			forceResolution: function() {
				this.resolve( this.ref );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var keypath;
				if ( this.keypath !== undefined ) {
					keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );
					// was a new keypath created?
					if ( keypath !== undefined ) {
						// resolve it
						this.resolve( keypath );
					}
				}
			},
			unbind: function() {
				if ( !this.resolved ) {
					runloop.removeUnresolved( this );
				}
			}
		};
		return ReferenceResolver;
	}( runloop, resolveRef, getNewKeypath );

	/* virtualdom/items/shared/Resolvers/SpecialResolver.js */
	var SpecialResolver = function() {

		var SpecialResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		SpecialResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					fragment = this.parentFragment;
				if ( ref === '@keypath' ) {
					while ( fragment ) {
						if ( !!fragment.context ) {
							return this.callback( '@' + fragment.context );
						}
						fragment = fragment.parent;
					}
				}
				if ( ref === '@index' || ref === '@key' ) {
					while ( fragment ) {
						if ( fragment.index !== undefined ) {
							return this.callback( '@' + fragment.index );
						}
						fragment = fragment.parent;
					}
				}
				throw new Error( 'Unknown special reference "' + ref + '" - valid references are @index, @key and @keypath' );
			},
			unbind: function() {}
		};
		return SpecialResolver;
	}();

	/* virtualdom/items/shared/Resolvers/IndexResolver.js */
	var IndexResolver = function() {

		var IndexResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		IndexResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					indexRefs = this.parentFragment.indexRefs,
					index = indexRefs[ ref ];
				if ( index !== undefined ) {
					this.callback( '@' + index );
				}
			},
			unbind: function() {}
		};
		return IndexResolver;
	}();

	/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */
	var createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {

		return function createReferenceResolver( owner, ref, callback ) {
			var indexRefs, index;
			if ( ref.charAt( 0 ) === '@' ) {
				return new SpecialResolver( owner, ref, callback );
			}
			indexRefs = owner.parentFragment.indexRefs;
			if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
				return new IndexResolver( owner, ref, callback );
			}
			return new ReferenceResolver( owner, ref, callback );
		};
	}( ReferenceResolver, SpecialResolver, IndexResolver );

	/* shared/getFunctionFromString.js */
	var getFunctionFromString = function() {

		var cache = {};
		return function getFunctionFromString( str, i ) {
			var fn, args;
			if ( cache[ str ] ) {
				return cache[ str ];
			}
			args = [];
			while ( i-- ) {
				args[ i ] = '_' + i;
			}
			fn = new Function( args.join( ',' ), 'return(' + str + ')' );
			cache[ str ] = fn;
			return fn;
		};
	}();

	/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
	var ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {

		var __export;
		var ExpressionResolver, bind = Function.prototype.bind;
		ExpressionResolver = function( owner, parentFragment, expression, callback ) {
			var resolver = this,
				ractive, indexRefs;
			ractive = owner.root;
			resolver.root = ractive;
			resolver.parentFragment = parentFragment;
			resolver.callback = callback;
			resolver.owner = owner;
			resolver.str = expression.s;
			resolver.keypaths = [];
			indexRefs = parentFragment.indexRefs;
			// Create resolvers for each reference
			resolver.pending = expression.r.length;
			resolver.refResolvers = expression.r.map( function( ref, i ) {
				return createReferenceResolver( resolver, ref, function( keypath ) {
					resolver.resolve( i, keypath );
				} );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ExpressionResolver.prototype = {
			bubble: function() {
				if ( !this.ready ) {
					return;
				}
				this.uniqueString = getUniqueString( this.str, this.keypaths );
				this.keypath = getKeypath( this.uniqueString );
				this.createEvaluator();
				this.callback( this.keypath );
			},
			unbind: function() {
				var resolver;
				while ( resolver = this.refResolvers.pop() ) {
					resolver.unbind();
				}
			},
			resolve: function( index, keypath ) {
				this.keypaths[ index ] = keypath;
				this.bubble();
			},
			createEvaluator: function() {
				var this$0 = this;
				var self = this,
					computation, valueGetters, signature, keypath, fn;
				computation = this.root.viewmodel.computations[ this.keypath ];
				// only if it doesn't exist yet!
				if ( !computation ) {
					fn = getFunctionFromString( this.str, this.refResolvers.length );
					valueGetters = this.keypaths.map( function( keypath ) {
						var value;
						if ( keypath === 'undefined' ) {
							return function() {
								return undefined;
							};
						}
						// 'special' keypaths encode a value
						if ( keypath[ 0 ] === '@' ) {
							value = keypath.slice( 1 );
							return isNumeric( value ) ? function() {
								return +value;
							} : function() {
								return value;
							};
						}
						return function() {
							var value = this$0.root.viewmodel.get( keypath );
							if ( typeof value === 'function' ) {
								value = wrapFunction( value, self.root );
							}
							return value;
						};
					} );
					signature = {
						deps: this.keypaths.filter( isValidDependency ),
						get: function() {
							var args = valueGetters.map( call );
							return fn.apply( null, args );
						}
					};
					computation = this.root.viewmodel.compute( this.keypath, signature );
				} else {
					this.root.viewmodel.mark( this.keypath );
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				// TODO only bubble once, no matter how many references are affected by the rebind
				this.refResolvers.forEach( function( r ) {
					return r.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
		};
		__export = ExpressionResolver;

		function call( value ) {
			return value.call();
		}

		function getUniqueString( str, keypaths ) {
			// get string that is unique to this expression
			return str.replace( /_([0-9]+)/g, function( match, $1 ) {
				var keypath, value;
				keypath = keypaths[ $1 ];
				if ( keypath === undefined ) {
					return 'undefined';
				}
				if ( keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					return isNumeric( value ) ? value : '"' + value + '"';
				}
				return keypath;
			} );
		}

		function getKeypath( uniqueString ) {
			// Sanitize by removing any periods or square brackets. Otherwise
			// we can't split the keypath into keys!
			return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
		}

		function isValidDependency( keypath ) {
			return keypath !== undefined && keypath[ 0 ] !== '@';
		}

		function wrapFunction( fn, ractive ) {
			var wrapped, prop, key;
			if ( fn._noWrap ) {
				return fn;
			}
			prop = '__ractive_' + ractive._guid;
			wrapped = fn[ prop ];
			if ( wrapped ) {
				return wrapped;
			} else if ( /this/.test( fn.toString() ) ) {
				defineProperty( fn, prop, {
					value: bind.call( fn, ractive )
				} );
				// Add properties/methods to wrapped function
				for ( key in fn ) {
					if ( fn.hasOwnProperty( key ) ) {
						fn[ prop ][ key ] = fn[ key ];
					}
				}
				return fn[ prop ];
			}
			defineProperty( fn, '__ractive_nowrap', {
				value: fn
			} );
			return fn.__ractive_nowrap;
		}
		return __export;
	}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
	var MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {

		var MemberResolver = function( template, resolver, parentFragment ) {
			var member = this,
				keypath;
			member.resolver = resolver;
			member.root = resolver.root;
			member.parentFragment = parentFragment;
			member.viewmodel = resolver.root.viewmodel;
			if ( typeof template === 'string' ) {
				member.value = template;
			} else if ( template.t === types.REFERENCE ) {
				member.refResolver = createReferenceResolver( this, template.n, function( keypath ) {
					member.resolve( keypath );
				} );
			} else {
				new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
					member.resolve( keypath );
				} );
			}
		};
		MemberResolver.prototype = {
			resolve: function( keypath ) {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				this.keypath = keypath;
				this.value = this.viewmodel.get( keypath );
				this.bind();
				this.resolver.bubble();
			},
			bind: function() {
				this.viewmodel.register( this.keypath, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.refResolver ) {
					this.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			setValue: function( value ) {
				this.value = value;
				this.resolver.bubble();
			},
			unbind: function() {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				if ( this.unresolved ) {
					this.unresolved.unbind();
				}
			},
			forceResolution: function() {
				if ( this.refResolver ) {
					this.refResolver.forceResolution();
				}
			}
		};
		return MemberResolver;
	}( types, createReferenceResolver, ExpressionResolver );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
	var ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {

		var ReferenceExpressionResolver = function( mustache, template, callback ) {
			var this$0 = this;
			var resolver = this,
				ractive, ref, keypath, parentFragment;
			resolver.parentFragment = parentFragment = mustache.parentFragment;
			resolver.root = ractive = mustache.root;
			resolver.mustache = mustache;
			resolver.ref = ref = template.r;
			resolver.callback = callback;
			resolver.unresolved = [];
			// Find base keypath
			if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
				resolver.base = keypath;
			} else {
				resolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {
					resolver.base = keypath;
					resolver.baseResolver = null;
					resolver.bubble();
				} );
			}
			// Find values for members, or mark them as unresolved
			resolver.members = template.m.map( function( template ) {
				return new MemberResolver( template, this$0, parentFragment );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ReferenceExpressionResolver.prototype = {
			getKeypath: function() {
				var values = this.members.map( getValue );
				if ( !values.every( isDefined ) || this.baseResolver ) {
					return null;
				}
				return this.base + '.' + values.join( '.' );
			},
			bubble: function() {
				if ( !this.ready || this.baseResolver ) {
					return;
				}
				this.callback( this.getKeypath() );
			},
			unbind: function() {
				this.members.forEach( unbind );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.members.forEach( function( members ) {
					if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			},
			forceResolution: function() {
				if ( this.baseResolver ) {
					this.base = this.ref;
					this.baseResolver.unbind();
					this.baseResolver = null;
				}
				this.members.forEach( function( m ) {
					return m.forceResolution();
				} );
				this.bubble();
			}
		};

		function getValue( member ) {
			return member.value;
		}

		function isDefined( value ) {
			return value != undefined;
		}

		function unbind( member ) {
			member.unbind();
		}
		return ReferenceExpressionResolver;
	}( resolveRef, ReferenceResolver, MemberResolver );

	/* virtualdom/items/shared/Mustache/initialise.js */
	var initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {

		return function Mustache$init( mustache, options ) {
			var ref, parentFragment, template;
			parentFragment = options.parentFragment;
			template = options.template;
			mustache.root = parentFragment.root;
			mustache.parentFragment = parentFragment;
			mustache.pElement = parentFragment.pElement;
			mustache.template = options.template;
			mustache.index = options.index || 0;
			mustache.isStatic = options.template.s;
			mustache.type = options.template.t;
			mustache.registered = false;
			// if this is a simple mustache, with a reference, we just need to resolve
			// the reference to a keypath
			if ( ref = template.r ) {
				mustache.resolver = new createReferenceResolver( mustache, ref, resolve );
			}
			// if it's an expression, we have a bit more work to do
			if ( options.template.x ) {
				mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
			}
			if ( options.template.rx ) {
				mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
			}
			// Special case - inverted sections
			if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
				mustache.setValue( undefined );
			}

			function resolve( keypath ) {
				mustache.resolve( keypath );
			}

			function resolveAndRebindChildren( newKeypath ) {
				var oldKeypath = mustache.keypath;
				if ( newKeypath !== oldKeypath ) {
					mustache.resolve( newKeypath );
					if ( oldKeypath !== undefined ) {
						mustache.fragments && mustache.fragments.forEach( function( f ) {
							f.rebind( null, null, oldKeypath, newKeypath );
						} );
					}
				}
			}
		};
	}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );

	/* virtualdom/items/shared/Mustache/resolve.js */
	var resolve = function( isNumeric ) {

		return function Mustache$resolve( keypath ) {
			var wasResolved, value, twowayBinding;
			// 'Special' keypaths, e.g. @foo or @7, encode a value
			if ( keypath && keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				if ( isNumeric( value ) ) {
					value = +value;
				}
				this.keypath = keypath;
				this.setValue( value );
				return;
			}
			// If we resolved previously, we need to unregister
			if ( this.registered ) {
				// undefined or null
				this.root.viewmodel.unregister( this.keypath, this );
				this.registered = false;
				wasResolved = true;
			}
			this.keypath = keypath;
			// If the new keypath exists, we need to register
			// with the viewmodel
			if ( keypath != undefined ) {
				// undefined or null
				value = this.root.viewmodel.get( keypath );
				this.root.viewmodel.register( keypath, this );
				this.registered = true;
			}
			// Either way we need to queue up a render (`value`
			// will be `undefined` if there's no keypath)
			this.setValue( value );
			// Two-way bindings need to point to their new target keypath
			if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
				twowayBinding.rebound();
			}
		};
	}( isNumeric );

	/* virtualdom/items/shared/Mustache/rebind.js */
	var rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		// Children first
		if ( this.fragments ) {
			this.fragments.forEach( function( f ) {
				return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			} );
		}
		// Expression mustache?
		if ( this.resolver ) {
			this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/shared/Mustache/_Mustache.js */
	var Mustache = function( getValue, init, resolve, rebind ) {

		return {
			getValue: getValue,
			init: init,
			resolve: resolve,
			rebind: rebind
		};
	}( getValue, initialise, resolve, rebind );

	/* virtualdom/items/Interpolator.js */
	var Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {

		var Interpolator = function( options ) {
			this.type = types.INTERPOLATOR;
			Mustache.init( this, options );
		};
		Interpolator.prototype = {
			update: function() {
				this.node.data = this.value == undefined ? '' : this.value;
			},
			resolve: Mustache.resolve,
			rebind: Mustache.rebind,
			detach: detach,
			unbind: unbind,
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.value != undefined ? this.value : '' );
				}
				return this.node;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					detachNode( this.node );
				}
			},
			getValue: Mustache.getValue,
			// TEMP
			setValue: function( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.node ) {
						runloop.addView( this );
					}
				}
			},
			firstNode: function() {
				return this.node;
			},
			toString: function( escape ) {
				var string = this.value != undefined ? '' + this.value : '';
				return escape ? escapeHtml( string ) : string;
			}
		};
		return Interpolator;
	}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );

	/* virtualdom/items/Section/prototype/bubble.js */
	var virtualdom_items_Section$bubble = function Section$bubble() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Section/prototype/detach.js */
	var virtualdom_items_Section$detach = function Section$detach() {
		var docFrag;
		if ( this.fragments.length === 1 ) {
			return this.fragments[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.fragments.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/find.js */
	var virtualdom_items_Section$find = function Section$find( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].find( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findAll.js */
	var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAll( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findAllComponents.js */
	var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findComponent.js */
	var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findNextNode.js */
	var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
		if ( this.fragments[ fragment.index + 1 ] ) {
			return this.fragments[ fragment.index + 1 ].firstNode();
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/firstNode.js */
	var virtualdom_items_Section$firstNode = function Section$firstNode() {
		var len, i, node;
		if ( len = this.fragments.length ) {
			for ( i = 0; i < len; i += 1 ) {
				if ( node = this.fragments[ i ].firstNode() ) {
					return node;
				}
			}
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/shuffle.js */
	var virtualdom_items_Section$shuffle = function( types, runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$shuffle( newIndices ) {
			var this$0 = this;
			var section = this,
				parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;
			// short circuit any double-updates, and ensure that this isn't applied to
			// non-list sections
			if ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {
				return;
			}
			this.shuffling = true;
			runloop.scheduleTask( function() {
				return this$0.shuffling = false;
			} );
			parentFragment = this.parentFragment;
			reboundFragments = [];
			// first, rebind existing fragments
			newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
				var fragment, by, oldKeypath, newKeypath;
				if ( newIndex === oldIndex ) {
					reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
					return;
				}
				fragment = section.fragments[ oldIndex ];
				if ( firstChange === undefined ) {
					firstChange = oldIndex;
				}
				// does this fragment need to be torn down?
				if ( newIndex === -1 ) {
					section.fragmentsToUnrender.push( fragment );
					fragment.unbind();
					return;
				}
				// Otherwise, it needs to be rebound to a new index
				by = newIndex - oldIndex;
				oldKeypath = section.keypath + '.' + oldIndex;
				newKeypath = section.keypath + '.' + newIndex;
				fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
				fragment.index = newIndex;
				reboundFragments[ newIndex ] = fragment;
			} );
			newLength = this.root.get( this.keypath ).length;
			// If nothing changed with the existing fragments, then we start adding
			// new fragments at the end...
			if ( firstChange === undefined ) {
				// ...unless there are no new fragments to add
				if ( this.length === newLength ) {
					return;
				}
				firstChange = this.length;
			}
			this.length = this.fragments.length = newLength;
			if ( this.rendered ) {
				runloop.addView( this );
			}
			// Prepare new fragment options
			fragmentOptions = {
				template: this.template.f,
				root: this.root,
				owner: this
			};
			if ( this.template.i ) {
				fragmentOptions.indexRef = this.template.i;
			}
			// Add as many new fragments as we need to, or add back existing
			// (detached) fragments
			for ( i = firstChange; i < newLength; i += 1 ) {
				fragment = reboundFragments[ i ];
				if ( !fragment ) {
					this.fragmentsToCreate.push( i );
				}
				this.fragments[ i ] = fragment;
			}
		};
	}( types, runloop, circular );

	/* virtualdom/items/Section/prototype/render.js */
	var virtualdom_items_Section$render = function Section$render() {
		var docFrag;
		docFrag = this.docFrag = document.createDocumentFragment();
		this.update();
		this.rendered = true;
		return docFrag;
	};

	/* utils/isArrayLike.js */
	var isArrayLike = function() {

		var pattern = /^\[object (?:Array|FileList)\]$/,
			toString = Object.prototype.toString;
		return function isArrayLike( obj ) {
			return pattern.test( toString.call( obj ) );
		};
	}();

	/* virtualdom/items/Section/prototype/setValue.js */
	var virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function Section$setValue( value ) {
			var this$0 = this;
			var wrapper, fragmentOptions;
			if ( this.updating ) {
				// If a child of this section causes a re-evaluation - for example, an
				// expression refers to a function that mutates the array that this
				// section depends on - we'll end up with a double rendering bug (see
				// https://github.com/ractivejs/ractive/issues/748). This prevents it.
				return;
			}
			this.updating = true;
			// with sections, we need to get the fake value if we have a wrapped object
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			// If any fragments are awaiting creation after a splice,
			// this is the place to do it
			if ( this.fragmentsToCreate.length ) {
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					pElement: this.pElement,
					owner: this,
					indexRef: this.template.i
				};
				this.fragmentsToCreate.forEach( function( index ) {
					var fragment;
					fragmentOptions.context = this$0.keypath + '.' + index;
					fragmentOptions.index = index;
					fragment = new Fragment( fragmentOptions );
					this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
				} );
				this.fragmentsToCreate.length = 0;
			} else if ( reevaluateSection( this, value ) ) {
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
			this.value = value;
			this.updating = false;
		};

		function reevaluateSection( section, value ) {
			var fragmentOptions = {
				template: section.template.f,
				root: section.root,
				pElement: section.parentFragment.pElement,
				owner: section
			};
			// If we already know the section type, great
			// TODO can this be optimised? i.e. pick an reevaluateSection function during init
			// and avoid doing this each time?
			if ( section.subtype ) {
				switch ( section.subtype ) {
					case types.SECTION_IF:
						return reevaluateConditionalSection( section, value, false, fragmentOptions );
					case types.SECTION_UNLESS:
						return reevaluateConditionalSection( section, value, true, fragmentOptions );
					case types.SECTION_WITH:
						return reevaluateContextSection( section, fragmentOptions );
					case types.SECTION_IF_WITH:
						return reevaluateConditionalContextSection( section, value, fragmentOptions );
					case types.SECTION_EACH:
						if ( isObject( value ) ) {
							return reevaluateListObjectSection( section, value, fragmentOptions );
						}
				}
			}
			// Otherwise we need to work out what sort of section we're dealing with
			section.ordered = !!isArrayLike( value );
			// Ordered list section
			if ( section.ordered ) {
				return reevaluateListSection( section, value, fragmentOptions );
			}
			// Unordered list, or context
			if ( isObject( value ) || typeof value === 'function' ) {
				// Index reference indicates section should be treated as a list
				if ( section.template.i ) {
					return reevaluateListObjectSection( section, value, fragmentOptions );
				}
				// Otherwise, object provides context for contents
				return reevaluateContextSection( section, fragmentOptions );
			}
			// Conditional section
			return reevaluateConditionalSection( section, value, false, fragmentOptions );
		}

		function reevaluateListSection( section, value, fragmentOptions ) {
			var i, length, fragment;
			length = value.length;
			if ( length === section.length ) {
				// Nothing to do
				return false;
			}
			// if the array is shorter than it was previously, remove items
			if ( length < section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
				section.fragmentsToUnrender.forEach( unbind );
			} else {
				if ( length > section.length ) {
					// add any new ones
					for ( i = section.length; i < length; i += 1 ) {
						// append list item to context stack
						fragmentOptions.context = section.keypath + '.' + i;
						fragmentOptions.index = i;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ i ] = fragment );
					}
				}
			}
			section.length = length;
			return true;
		}

		function reevaluateListObjectSection( section, value, fragmentOptions ) {
			var id, i, hasKey, fragment, changed;
			hasKey = section.hasKey || ( section.hasKey = {} );
			// remove any fragments that should no longer exist
			i = section.fragments.length;
			while ( i-- ) {
				fragment = section.fragments[ i ];
				if ( !( fragment.index in value ) ) {
					changed = true;
					fragment.unbind();
					section.fragmentsToUnrender.push( fragment );
					section.fragments.splice( i, 1 );
					hasKey[ fragment.index ] = false;
				}
			}
			// add any that haven't been created yet
			for ( id in value ) {
				if ( !hasKey[ id ] ) {
					changed = true;
					fragmentOptions.context = section.keypath + '.' + id;
					fragmentOptions.index = id;
					if ( section.template.i ) {
						fragmentOptions.indexRef = section.template.i;
					}
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( fragment );
					section.fragments.push( fragment );
					hasKey[ id ] = true;
				}
			}
			section.length = section.fragments.length;
			return changed;
		}

		function reevaluateConditionalContextSection( section, value, fragmentOptions ) {
			if ( value ) {
				return reevaluateContextSection( section, fragmentOptions );
			} else {
				return removeSectionFragments( section );
			}
		}

		function reevaluateContextSection( section, fragmentOptions ) {
			var fragment;
			// ...then if it isn't rendered, render it, adding section.keypath to the context stack
			// (if it is already rendered, then any children dependent on the context stack
			// will update themselves without any prompting)
			if ( !section.length ) {
				// append this section to the context stack
				fragmentOptions.context = section.keypath;
				fragmentOptions.index = 0;
				fragment = new Fragment( fragmentOptions );
				section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
				section.length = 1;
				return true;
			}
		}

		function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
			var doRender, emptyArray, emptyObject, fragment, name;
			emptyArray = isArrayLike( value ) && value.length === 0;
			emptyObject = false;
			if ( !isArrayLike( value ) && isObject( value ) ) {
				emptyObject = true;
				for ( name in value ) {
					emptyObject = false;
					break;
				}
			}
			if ( inverted ) {
				doRender = emptyArray || emptyObject || !value;
			} else {
				doRender = value && !emptyArray && !emptyObject;
			}
			if ( doRender ) {
				if ( !section.length ) {
					// no change to context stack
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
				if ( section.length > 1 ) {
					section.fragmentsToUnrender = section.fragments.splice( 1 );
					section.fragmentsToUnrender.forEach( unbind );
					return true;
				}
			} else {
				return removeSectionFragments( section );
			}
		}

		function removeSectionFragments( section ) {
			if ( section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );
				section.fragmentsToUnrender.forEach( unbind );
				section.length = section.fragmentsToRender.length = 0;
				return true;
			}
		}

		function unbind( fragment ) {
			fragment.unbind();
		}

		function isRendered( fragment ) {
			return fragment.rendered;
		}
		return __export;
	}( types, isArrayLike, isObject, runloop, circular );

	/* virtualdom/items/Section/prototype/toString.js */
	var virtualdom_items_Section$toString = function Section$toString( escape ) {
		var str, i, len;
		str = '';
		i = 0;
		len = this.length;
		for ( i = 0; i < len; i += 1 ) {
			str += this.fragments[ i ].toString( escape );
		}
		return str;
	};

	/* virtualdom/items/Section/prototype/unbind.js */
	var virtualdom_items_Section$unbind = function( unbind ) {

		var __export;
		__export = function Section$unbind() {
			this.fragments.forEach( unbindFragment );
			unbind.call( this );
			this.length = 0;
			this.unbound = true;
		};

		function unbindFragment( fragment ) {
			fragment.unbind();
		}
		return __export;
	}( unbind );

	/* virtualdom/items/Section/prototype/unrender.js */
	var virtualdom_items_Section$unrender = function() {

		var __export;
		__export = function Section$unrender( shouldDestroy ) {
			this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
		};

		function unrenderAndDestroy( fragment ) {
			fragment.unrender( true );
		}

		function unrender( fragment ) {
			fragment.unrender( false );
		}
		return __export;
	}();

	/* virtualdom/items/Section/prototype/update.js */
	var virtualdom_items_Section$update = function Section$update() {
		var fragment, renderIndex, renderedFragments, anchor, target, i, len;
		// `this.renderedFragments` is in the order of the previous render.
		// If fragments have shuffled about, this allows us to quickly
		// reinsert them in the correct place
		renderedFragments = this.renderedFragments;
		// Remove fragments that have been marked for destruction
		while ( fragment = this.fragmentsToUnrender.pop() ) {
			fragment.unrender( true );
			renderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );
		}
		// Render new fragments (but don't insert them yet)
		while ( fragment = this.fragmentsToRender.shift() ) {
			fragment.render();
		}
		if ( this.rendered ) {
			target = this.parentFragment.getNode();
		}
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			fragment = this.fragments[ i ];
			renderIndex = renderedFragments.indexOf( fragment, i );
			// search from current index - it's guaranteed to be the same or higher
			if ( renderIndex === i ) {
				// already in the right place. insert accumulated nodes (if any) and carry on
				if ( this.docFrag.childNodes.length ) {
					anchor = fragment.firstNode();
					target.insertBefore( this.docFrag, anchor );
				}
				continue;
			}
			this.docFrag.appendChild( fragment.detach() );
			// update renderedFragments
			if ( renderIndex !== -1 ) {
				renderedFragments.splice( renderIndex, 1 );
			}
			renderedFragments.splice( i, 0, fragment );
		}
		if ( this.rendered && this.docFrag.childNodes.length ) {
			anchor = this.parentFragment.findNextNode( this );
			target.insertBefore( this.docFrag, anchor );
		}
		// Save the rendering order for next time
		this.renderedFragments = this.fragments.slice();
	};

	/* virtualdom/items/Section/_Section.js */
	var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {

		var Section = function( options ) {
			this.type = types.SECTION;
			this.subtype = options.template.n;
			this.inverted = this.subtype === types.SECTION_UNLESS;
			this.pElement = options.pElement;
			this.fragments = [];
			this.fragmentsToCreate = [];
			this.fragmentsToRender = [];
			this.fragmentsToUnrender = [];
			this.renderedFragments = [];
			this.length = 0;
			// number of times this section is rendered
			Mustache.init( this, options );
		};
		Section.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			shuffle: shuffle,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Section;
	}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

	/* virtualdom/items/Triple/prototype/detach.js */
	var virtualdom_items_Triple$detach = function Triple$detach() {
		var len, i;
		if ( this.docFrag ) {
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				this.docFrag.appendChild( this.nodes[ i ] );
			}
			return this.docFrag;
		}
	};

	/* virtualdom/items/Triple/prototype/find.js */
	var virtualdom_items_Triple$find = function( matches ) {

		return function Triple$find( selector ) {
			var i, len, node, queryResult;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					return node;
				}
				if ( queryResult = node.querySelector( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/findAll.js */
	var virtualdom_items_Triple$findAll = function( matches ) {

		return function Triple$findAll( selector, queryResult ) {
			var i, len, node, queryAllResult, numNodes, j;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					queryResult.push( node );
				}
				if ( queryAllResult = node.querySelectorAll( selector ) ) {
					numNodes = queryAllResult.length;
					for ( j = 0; j < numNodes; j += 1 ) {
						queryResult.push( queryAllResult[ j ] );
					}
				}
			}
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/firstNode.js */
	var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
		if ( this.rendered && this.nodes[ 0 ] ) {
			return this.nodes[ 0 ];
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Triple/helpers/insertHtml.js */
	var insertHtml = function( namespaces, createElement ) {

		var __export;
		var elementCache = {},
			ieBug, ieBlacklist;
		try {
			createElement( 'table' ).innerHTML = 'foo';
		} catch ( err ) {
			ieBug = true;
			ieBlacklist = {
				TABLE: [
					'<table class="x">',
					'</table>'
				],
				THEAD: [
					'<table><thead class="x">',
					'</thead></table>'
				],
				TBODY: [
					'<table><tbody class="x">',
					'</tbody></table>'
				],
				TR: [
					'<table><tr class="x">',
					'</tr></table>'
				],
				SELECT: [
					'<select class="x">',
					'</select>'
				]
			};
		}
		__export = function( html, node, docFrag ) {
			var container, nodes = [],
				wrapper, selectedOption, child, i;
			// render 0 and false
			if ( html != null && html !== '' ) {
				if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
					container = element( 'DIV' );
					container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
					container = container.querySelector( '.x' );
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				} else if ( node.namespaceURI === namespaces.svg ) {
					container = element( 'DIV' );
					container.innerHTML = '<svg class="x">' + html + '</svg>';
					container = container.querySelector( '.x' );
				} else {
					container = element( node.tagName );
					container.innerHTML = html;
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				}
				while ( child = container.firstChild ) {
					nodes.push( child );
					docFrag.appendChild( child );
				}
				// This is really annoying. Extracting <option> nodes from the
				// temporary container <select> causes the remaining ones to
				// become selected. So now we have to deselect them. IE8, you
				// amaze me. You really do
				// ...and now Chrome too
				if ( node.tagName === 'SELECT' ) {
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] !== selectedOption ) {
							nodes[ i ].selected = false;
						}
					}
				}
			}
			return nodes;
		};

		function element( tagName ) {
			return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
		}
		return __export;
	}( namespaces, createElement );

	/* utils/toArray.js */
	var toArray = function toArray( arrayLike ) {
		var array = [],
			i = arrayLike.length;
		while ( i-- ) {
			array[ i ] = arrayLike[ i ];
		}
		return array;
	};

	/* virtualdom/items/Triple/helpers/updateSelect.js */
	var updateSelect = function( toArray ) {

		var __export;
		__export = function updateSelect( parentElement ) {
			var selectedOptions, option, value;
			if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
				return;
			}
			selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
			// If one of them had a `selected` attribute, we need to sync
			// the model to the view
			if ( parentElement.getAttribute( 'multiple' ) ) {
				value = selectedOptions.map( function( o ) {
					return o.value;
				} );
			} else if ( option = selectedOptions[ 0 ] ) {
				value = option.value;
			}
			if ( value !== undefined ) {
				parentElement.binding.setValue( value );
			}
			parentElement.bubble();
		};

		function isSelected( option ) {
			return option.selected;
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Triple/prototype/render.js */
	var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

		return function Triple$render() {
			if ( this.rendered ) {
				throw new Error( 'Attempted to render an item that was already rendered' );
			}
			this.docFrag = document.createDocumentFragment();
			this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
			this.rendered = true;
			return this.docFrag;
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/prototype/setValue.js */
	var virtualdom_items_Triple$setValue = function( runloop ) {

		return function Triple$setValue( value ) {
			var wrapper;
			// TODO is there a better way to approach this?
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			if ( value !== this.value ) {
				this.value = value;
				this.parentFragment.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Triple/prototype/toString.js */
	var virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {

		return function Triple$toString() {
			return this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';
		};
	}( decodeCharacterReferences );

	/* virtualdom/items/Triple/prototype/unrender.js */
	var virtualdom_items_Triple$unrender = function( detachNode ) {

		return function Triple$unrender( shouldDestroy ) {
			if ( this.rendered && shouldDestroy ) {
				this.nodes.forEach( detachNode );
				this.rendered = false;
			}
		};
	}( detachNode );

	/* virtualdom/items/Triple/prototype/update.js */
	var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

		return function Triple$update() {
			var node, parentNode;
			if ( !this.rendered ) {
				return;
			}
			// Remove existing nodes
			while ( this.nodes && this.nodes.length ) {
				node = this.nodes.pop();
				node.parentNode.removeChild( node );
			}
			// Insert new nodes
			parentNode = this.parentFragment.getNode();
			this.nodes = insertHtml( this.value, parentNode, this.docFrag );
			parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/_Triple.js */
	var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

		var Triple = function( options ) {
			this.type = types.TRIPLE;
			Mustache.init( this, options );
		};
		Triple.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Triple;
	}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

	/* virtualdom/items/Element/prototype/bubble.js */
	var virtualdom_items_Element$bubble = function() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Element/prototype/detach.js */
	var virtualdom_items_Element$detach = function Element$detach() {
		var node = this.node,
			parentNode;
		if ( node ) {
			// need to check for parent node - DOM may have been altered
			// by something other than Ractive! e.g. jQuery UI...
			if ( parentNode = node.parentNode ) {
				parentNode.removeChild( node );
			}
			return node;
		}
	};

	/* virtualdom/items/Element/prototype/find.js */
	var virtualdom_items_Element$find = function( matches ) {

		return function( selector ) {
			if ( matches( this.node, selector ) ) {
				return this.node;
			}
			if ( this.fragment && this.fragment.find ) {
				return this.fragment.find( selector );
			}
		};
	}( matches );

	/* virtualdom/items/Element/prototype/findAll.js */
	var virtualdom_items_Element$findAll = function( selector, query ) {
		// Add this node to the query, if applicable, and register the
		// query on this element
		if ( query._test( this, true ) && query.live ) {
			( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
		}
		if ( this.fragment ) {
			this.fragment.findAll( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findAllComponents.js */
	var virtualdom_items_Element$findAllComponents = function( selector, query ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findComponent.js */
	var virtualdom_items_Element$findComponent = function( selector ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( selector );
		}
	};

	/* virtualdom/items/Element/prototype/findNextNode.js */
	var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
		return null;
	};

	/* virtualdom/items/Element/prototype/firstNode.js */
	var virtualdom_items_Element$firstNode = function Element$firstNode() {
		return this.node;
	};

	/* virtualdom/items/Element/prototype/getAttribute.js */
	var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
		if ( !this.attributes || !this.attributes[ name ] ) {
			return;
		}
		return this.attributes[ name ].value;
	};

	/* virtualdom/items/Element/shared/enforceCase.js */
	var enforceCase = function() {

		var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
		svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
		svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
		createMap = function( items ) {
			var map = {},
				i = items.length;
			while ( i-- ) {
				map[ items[ i ].toLowerCase() ] = items[ i ];
			}
			return map;
		};
		map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
		return function( elementName ) {
			var lowerCaseElementName = elementName.toLowerCase();
			return map[ lowerCaseElementName ] || lowerCaseElementName;
		};
	}();

	/* virtualdom/items/Element/Attribute/prototype/bubble.js */
	var virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {

		return function Attribute$bubble() {
			var value = this.fragment.getValue();
			// TODO this can register the attribute multiple times (see render test
			// 'Attribute with nested mustaches')
			if ( !isEqual( value, this.value ) ) {
				// Need to clear old id from ractive.nodes
				if ( this.name === 'id' && this.value ) {
					delete this.root.nodes[ this.value ];
				}
				this.value = value;
				if ( this.name === 'value' && this.node ) {
					// We need to store the value on the DOM like this so we
					// can retrieve it later without it being coerced to a string
					this.node._ractive.value = value;
				}
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop, isEqual );

	/* config/booleanAttributes.js */
	var booleanAttributes = function() {

		// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
		var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
		return booleanAttributes;
	}();

	/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
	var determineNameAndNamespace = function( namespaces, enforceCase ) {

		return function( attribute, name ) {
			var colonIndex, namespacePrefix;
			// are we dealing with a namespaced attribute, e.g. xlink:href?
			colonIndex = name.indexOf( ':' );
			if ( colonIndex !== -1 ) {
				// looks like we are, yes...
				namespacePrefix = name.substr( 0, colonIndex );
				// ...unless it's a namespace *declaration*, which we ignore (on the assumption
				// that only valid namespaces will be used)
				if ( namespacePrefix !== 'xmlns' ) {
					name = name.substring( colonIndex + 1 );
					attribute.name = enforceCase( name );
					attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
					attribute.namespacePrefix = namespacePrefix;
					if ( !attribute.namespace ) {
						throw 'Unknown namespace ("' + namespacePrefix + '")';
					}
					return;
				}
			}
			// SVG attribute names are case sensitive
			attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
		};
	}( namespaces, enforceCase );

	/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
	var getInterpolator = function( types ) {

		return function getInterpolator( attribute ) {
			var items = attribute.fragment.items;
			if ( items.length !== 1 ) {
				return;
			}
			if ( items[ 0 ].type === types.INTERPOLATOR ) {
				return items[ 0 ];
			}
		};
	}( types );

	/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
	var determinePropertyName = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			accesskey: 'accessKey',
			bgcolor: 'bgColor',
			'class': 'className',
			codebase: 'codeBase',
			colspan: 'colSpan',
			contenteditable: 'contentEditable',
			datetime: 'dateTime',
			dirname: 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			ismap: 'isMap',
			maxlength: 'maxLength',
			novalidate: 'noValidate',
			pubdate: 'pubDate',
			readonly: 'readOnly',
			rowspan: 'rowSpan',
			tabindex: 'tabIndex',
			usemap: 'useMap'
		};
		return function( attribute, options ) {
			var propertyName;
			if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
				propertyName = propertyNames[ attribute.name ] || attribute.name;
				if ( options.pNode[ propertyName ] !== undefined ) {
					attribute.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					attribute.useProperty = true;
				}
			}
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/init.js */
	var virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Attribute$init( options ) {
			this.type = types.ATTRIBUTE;
			this.element = options.element;
			this.root = options.root;
			determineNameAndNamespace( this, options.name );
			// if it's an empty attribute, or just a straight key-value pair, with no
			// mustache shenanigans, set the attribute accordingly and go home
			if ( !options.value || typeof options.value === 'string' ) {
				this.value = booleanAttributes.test( this.name ) ? true : options.value || '';
				return;
			}
			// otherwise we need to do some work
			// share parentFragment with parent element
			this.parentFragment = this.element.parentFragment;
			this.fragment = new Fragment( {
				template: options.value,
				root: this.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
			// Store a reference to this attribute's interpolator, if its fragment
			// takes the form `{{foo}}`. This is necessary for two-way binding and
			// for correctly rendering HTML later
			this.interpolator = getInterpolator( this );
			this.isBindable = !!this.interpolator && !this.interpolator.isStatic;
			// can we establish this attribute's property name equivalent?
			determinePropertyName( this, options );
			// mark as ready
			this.ready = true;
		};
	}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

	/* virtualdom/items/Element/Attribute/prototype/rebind.js */
	var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( this.fragment ) {
			this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/render.js */
	var virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			'accesskey': 'accessKey',
			'bgcolor': 'bgColor',
			'class': 'className',
			'codebase': 'codeBase',
			'colspan': 'colSpan',
			'contenteditable': 'contentEditable',
			'datetime': 'dateTime',
			'dirname': 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			'ismap': 'isMap',
			'maxlength': 'maxLength',
			'novalidate': 'noValidate',
			'pubdate': 'pubDate',
			'readonly': 'readOnly',
			'rowspan': 'rowSpan',
			'tabindex': 'tabIndex',
			'usemap': 'useMap'
		};
		return function Attribute$render( node ) {
			var propertyName;
			this.node = node;
			// should we use direct property access, or setAttribute?
			if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
				propertyName = propertyNames[ this.name ] || this.name;
				if ( node[ propertyName ] !== undefined ) {
					this.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					this.useProperty = true;
				}
				if ( propertyName === 'value' ) {
					this.useProperty = true;
					node._ractive.value = this.value;
				}
			}
			this.rendered = true;
			this.update();
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/toString.js */
	var virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {

		var __export;
		__export = function Attribute$toString() {
			var name = ( fragment = this ).name,
				namespacePrefix = fragment.namespacePrefix,
				value = fragment.value,
				interpolator = fragment.interpolator,
				fragment = fragment.fragment;
			// Special case - select and textarea values (should not be stringified)
			if ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {
				return;
			}
			// Special case - content editable
			if ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {
				return;
			}
			// Special case - radio names
			if ( name === 'name' && this.element.name === 'input' && interpolator ) {
				return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
			}
			// Boolean attributes
			if ( booleanAttributes.test( name ) ) {
				return value ? name : '';
			}
			if ( fragment ) {
				value = fragment.toString();
			}
			if ( namespacePrefix ) {
				name = namespacePrefix + ':' + name;
			}
			return value ? name + '="' + escape( value ) + '"' : name;
		};

		function escape( value ) {
			return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
		}
		return __export;
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/unbind.js */
	var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
		// ignore non-dynamic attributes
		if ( this.fragment ) {
			this.fragment.unbind();
		}
		if ( this.name === 'id' ) {
			delete this.root.nodes[ this.value ];
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
		var value = this.value,
			options, option, optionValue, i;
		if ( !this.locked ) {
			this.node._ractive.value = value;
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				if ( optionValue == value ) {
					// double equals as we may be comparing numbers with strings
					option.selected = true;
					break;
				}
			}
		}
	};

	/* utils/arrayContains.js */
	var arrayContains = function arrayContains( array, value ) {
		for ( var i = 0, c = array.length; i < c; i++ ) {
			if ( array[ i ] == value ) {
				return true;
			}
		}
		return false;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {

		return function Attribute$updateMultipleSelect() {
			var value = this.value,
				options, i, option, optionValue;
			if ( !isArray( value ) ) {
				value = [ value ];
			}
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				option.selected = arrayContains( value, optionValue );
			}
		};
	}( arrayContains, isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
	var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
		var node = ( value = this ).node,
			value = value.value;
		node.checked = value == node._ractive.value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
	var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

		return function Attribute$updateRadioValue() {
			var wasChecked, node = this.node,
				binding, bindings, i;
			wasChecked = node.checked;
			node.value = this.element.getAttribute( 'value' );
			node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
			// This is a special case - if the input was checked, and the value
			// changed so that it's no longer checked, the twoway binding is
			// most likely out of date. To fix it we have to jump through some
			// hoops... this is a little kludgy but it works
			if ( wasChecked && !node.checked && this.element.binding ) {
				bindings = this.element.binding.siblings;
				if ( i = bindings.length ) {
					while ( i-- ) {
						binding = bindings[ i ];
						if ( !binding.element.node ) {
							// this is the initial render, siblings are still rendering!
							// we'll come back later...
							return;
						}
						if ( binding.element.node.checked ) {
							runloop.addViewmodel( binding.root.viewmodel );
							return binding.handleChange();
						}
					}
					runloop.addViewmodel( binding.root.viewmodel );
					this.root.viewmodel.set( binding.keypath, undefined );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
	var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

		return function Attribute$updateCheckboxName() {
			var element = ( value = this ).element,
				node = value.node,
				value = value.value,
				valueAttribute, i;
			valueAttribute = element.getAttribute( 'value' );
			if ( !isArray( value ) ) {
				node.checked = value == valueAttribute;
			} else {
				i = value.length;
				while ( i-- ) {
					if ( valueAttribute == value[ i ] ) {
						node.checked = true;
						return;
					}
				}
				node.checked = false;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
	var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.className = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
		var node = ( value = this ).node,
			value = value.value;
		this.root.nodes[ value ] = node;
		node.id = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.style.setAttribute( 'cssText', value );
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
	var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
		var value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		if ( !this.locked ) {
			this.node.innerHTML = value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
	var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
		var node = ( value = this ).node,
			value = value.value;
		// store actual value, so it doesn't get coerced to a string
		node._ractive.value = value;
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			node.value = value == undefined ? '' : value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
	var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			this.node[ this.propertyName ] = this.value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
	var virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {

		return function Attribute$updateEverythingElse() {
			var node = ( fragment = this ).node,
				namespace = fragment.namespace,
				name = fragment.name,
				value = fragment.value,
				fragment = fragment.fragment;
			if ( namespace ) {
				node.setAttributeNS( namespace, name, ( fragment || value ).toString() );
			} else if ( !booleanAttributes.test( name ) ) {
				node.setAttribute( name, ( fragment || value ).toString() );
			} else {
				if ( value ) {
					node.setAttribute( name, '' );
				} else {
					node.removeAttribute( name );
				}
			}
		};
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/update.js */
	var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

		return function Attribute$update() {
			var name = ( node = this ).name,
				element = node.element,
				node = node.node,
				type, updateMethod;
			if ( name === 'id' ) {
				updateMethod = updateIdAttribute;
			} else if ( name === 'value' ) {
				// special case - selects
				if ( element.name === 'select' && name === 'value' ) {
					updateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
				} else if ( element.name === 'textarea' ) {
					updateMethod = updateValue;
				} else if ( element.getAttribute( 'contenteditable' ) != null ) {
					updateMethod = updateContentEditableValue;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					// type='file' value='{{fileList}}'>
					if ( type === 'file' ) {
						updateMethod = noop;
					} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
						updateMethod = updateRadioValue;
					} else {
						updateMethod = updateValue;
					}
				}
			} else if ( this.twoway && name === 'name' ) {
				if ( node.type === 'radio' ) {
					updateMethod = updateRadioName;
				} else if ( node.type === 'checkbox' ) {
					updateMethod = updateCheckboxName;
				}
			} else if ( name === 'style' && node.style.setAttribute ) {
				updateMethod = updateIEStyleAttribute;
			} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
				updateMethod = updateClassName;
			} else if ( this.useProperty ) {
				updateMethod = updateBoolean;
			}
			if ( !updateMethod ) {
				updateMethod = updateEverythingElse;
			}
			this.update = updateMethod;
			this.update();
		};
	}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

	/* virtualdom/items/Element/Attribute/_Attribute.js */
	var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

		var Attribute = function( options ) {
			this.init( options );
		};
		Attribute.prototype = {
			bubble: bubble,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			update: update
		};
		return Attribute;
	}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

	/* virtualdom/items/Element/prototype/init/createAttributes.js */
	var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

		return function( element, attributes ) {
			var name, attribute, result = [];
			for ( name in attributes ) {
				if ( attributes.hasOwnProperty( name ) ) {
					attribute = new Attribute( {
						element: element,
						name: name,
						value: attributes[ name ],
						root: element.root
					} );
					result.push( result[ name ] = attribute );
				}
			}
			return result;
		};
	}( Attribute );

	/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */
	var ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {

		var __export;
		var Fragment, div;
		if ( typeof document !== 'undefined' ) {
			div = createElement( 'div' );
		}
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var ConditionalAttribute = function( element, template ) {
			this.element = element;
			this.root = element.root;
			this.parentFragment = element.parentFragment;
			this.attributes = [];
			this.fragment = new Fragment( {
				root: element.root,
				owner: this,
				template: [ template ]
			} );
		};
		ConditionalAttribute.prototype = {
			bubble: function() {
				if ( this.node ) {
					this.update();
				}
				this.element.bubble();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function( node ) {
				this.node = node;
				this.isSvg = node.namespaceURI === namespaces.svg;
				this.update();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			update: function() {
				var this$0 = this;
				var str, attrs;
				str = this.fragment.toString();
				attrs = parseAttributes( str, this.isSvg );
				// any attributes that previously existed but no longer do
				// must be removed
				this.attributes.filter( function( a ) {
					return notIn( attrs, a );
				} ).forEach( function( a ) {
					this$0.node.removeAttribute( a.name );
				} );
				attrs.forEach( function( a ) {
					this$0.node.setAttribute( a.name, a.value );
				} );
				this.attributes = attrs;
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		__export = ConditionalAttribute;

		function parseAttributes( str, isSvg ) {
			var tag = isSvg ? 'svg' : 'div';
			div.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';
			return toArray( div.childNodes[ 0 ].attributes );
		}

		function notIn( haystack, needle ) {
			var i = haystack.length;
			while ( i-- ) {
				if ( haystack[ i ].name === needle.name ) {
					return false;
				}
			}
			return true;
		}
		return __export;
	}( circular, namespaces, createElement, toArray );

	/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */
	var virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {

		return function( element, attributes ) {
			if ( !attributes ) {
				return [];
			}
			return attributes.map( function( a ) {
				return new ConditionalAttribute( element, a );
			} );
		};
	}( ConditionalAttribute );

	/* utils/extend.js */
	var extend = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		var prop, source;
		while ( source = sources.shift() ) {
			for ( prop in source ) {
				if ( source.hasOwnProperty( prop ) ) {
					target[ prop ] = source[ prop ];
				}
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Binding/Binding.js */
	var Binding = function( runloop, warn, create, extend, removeFromArray ) {

		var Binding = function( element ) {
			var interpolator, keypath, value;
			this.element = element;
			this.root = element.root;
			this.attribute = element.attributes[ this.name || 'value' ];
			interpolator = this.attribute.interpolator;
			interpolator.twowayBinding = this;
			if ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {
				warn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );
				return false;
			}
			// A mustache may be *ambiguous*. Let's say we were given
			// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
			// *wasn't* `undefined`, the keypath would be `foo.bar`.
			// Then, any user input would result in `foo.bar` being updated.
			//
			// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
			// left with an unresolved partial keypath - so we are forced to make an
			// assumption. That assumption is that the input in question should
			// be forced to resolve to `bar`, and any user input would affect `bar`
			// and not `foo.bar`.
			//
			// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
			// be explicit when using two-way data-binding about what keypath you're
			// updating. Using it in lists is probably a recipe for confusion...
			if ( !interpolator.keypath ) {
				interpolator.resolver.forceResolution();
			}
			this.keypath = keypath = interpolator.keypath;
			// initialise value, if it's undefined
			if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
				value = this.getInitialValue();
				if ( value !== undefined ) {
					this.root.viewmodel.set( keypath, value );
				}
			}
		};
		Binding.prototype = {
			handleChange: function() {
				var this$0 = this;
				runloop.start( this.root );
				this.attribute.locked = true;
				this.root.viewmodel.set( this.keypath, this.getValue() );
				runloop.scheduleTask( function() {
					return this$0.attribute.locked = false;
				} );
				runloop.end();
			},
			rebound: function() {
				var bindings, oldKeypath, newKeypath;
				oldKeypath = this.keypath;
				newKeypath = this.attribute.interpolator.keypath;
				// The attribute this binding is linked to has already done the work
				if ( oldKeypath === newKeypath ) {
					return;
				}
				removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
				this.keypath = newKeypath;
				bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
				bindings.push( this );
			},
			unbind: function() {}
		};
		Binding.extend = function( properties ) {
			var Parent = this,
				SpecialisedBinding;
			SpecialisedBinding = function( element ) {
				Binding.call( this, element );
				if ( this.init ) {
					this.init();
				}
			};
			SpecialisedBinding.prototype = create( Parent.prototype );
			extend( SpecialisedBinding.prototype, properties );
			SpecialisedBinding.extend = Binding.extend;
			return SpecialisedBinding;
		};
		return Binding;
	}( runloop, warn, create, extend, removeFromArray );

	/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
	var handleDomEvent = function handleChange() {
		this._ractive.binding.handleChange();
	};

	/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
	var ContentEditableBinding = function( Binding, handleDomEvent ) {

		var ContentEditableBinding = Binding.extend( {
			getInitialValue: function() {
				return this.element.fragment ? this.element.fragment.toString() : '';
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.innerHTML;
			}
		} );
		return ContentEditableBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/shared/getSiblings.js */
	var getSiblings = function() {

		var sets = {};
		return function getSiblings( id, group, keypath ) {
			var hash = id + group + keypath;
			return sets[ hash ] || ( sets[ hash ] = [] );
		};
	}();

	/* virtualdom/items/Element/Binding/RadioBinding.js */
	var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var RadioBinding = Binding.extend( {
			name: 'checked',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
				this.siblings.push( this );
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			handleChange: function() {
				runloop.start( this.root );
				this.siblings.forEach( function( binding ) {
					binding.root.viewmodel.set( binding.keypath, binding.getValue() );
				} );
				runloop.end();
			},
			getValue: function() {
				return this.element.node.checked;
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioBinding;
	}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/RadioNameBinding.js */
	var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

		var RadioNameBinding = Binding.extend( {
			name: 'name',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
				this.siblings.push( this );
				this.radioName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
			},
			getInitialValue: function() {
				if ( this.element.getAttribute( 'checked' ) ) {
					return this.element.getAttribute( 'value' );
				}
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				var node = this.element.node;
				return node._ractive ? node._ractive.value : node.value;
			},
			handleChange: function() {
				// If this <input> is the one that's checked, then the value of its
				// `name` keypath gets set to its value
				if ( this.element.node.checked ) {
					Binding.prototype.handleChange.call( this );
				}
			},
			rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var node;
				Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				if ( node = this.element.node ) {
					node.name = '{{' + this.keypath + '}}';
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioNameBinding;
	}( removeFromArray, Binding, handleDomEvent, getSiblings );

	/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
	var CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var CheckboxNameBinding = Binding.extend( {
			name: 'name',
			getInitialValue: function() {
				// This only gets called once per group (of inputs that
				// share a name), because it only gets called if there
				// isn't an initial value. By the same token, we can make
				// a note of that fact that there was no initial value,
				// and populate it using any `checked` attributes that
				// exist (which users should avoid, but which we should
				// support anyway to avoid breaking expectations)
				this.noInitialValue = true;
				return [];
			},
			init: function() {
				var existingValue, bindingValue;
				this.checkboxName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
				// we set this property so that the attribute gets the correct update method
				// Each input has a reference to an array containing it and its
				// siblings, as two-way binding depends on being able to ascertain
				// the status of all inputs within the group
				this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
				this.siblings.push( this );
				if ( this.noInitialValue ) {
					this.siblings.noInitialValue = true;
				}
				// If no initial value was set, and this input is checked, we
				// update the model
				if ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {
					existingValue = this.root.viewmodel.get( this.keypath );
					bindingValue = this.element.getAttribute( 'value' );
					existingValue.push( bindingValue );
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			},
			render: function() {
				var node = this.element.node,
					existingValue, bindingValue;
				existingValue = this.root.viewmodel.get( this.keypath );
				bindingValue = this.element.getAttribute( 'value' );
				if ( isArray( existingValue ) ) {
					this.isChecked = arrayContains( existingValue, bindingValue );
				} else {
					this.isChecked = existingValue == bindingValue;
				}
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.isChecked;
				node.addEventListener( 'change', handleDomEvent, false );
				// in case of IE emergency, bind to click event as well
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			changed: function() {
				var wasChecked = !!this.isChecked;
				this.isChecked = this.element.node.checked;
				return this.isChecked === wasChecked;
			},
			handleChange: function() {
				this.isChecked = this.element.node.checked;
				Binding.prototype.handleChange.call( this );
			},
			getValue: function() {
				return this.siblings.filter( isChecked ).map( getValue );
			}
		} );

		function isChecked( binding ) {
			return binding.isChecked;
		}

		function getValue( binding ) {
			return binding.element.getAttribute( 'value' );
		}
		return CheckboxNameBinding;
	}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/CheckboxBinding.js */
	var CheckboxBinding = function( Binding, handleDomEvent ) {

		var CheckboxBinding = Binding.extend( {
			name: 'checked',
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.checked;
			}
		} );
		return CheckboxBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/SelectBinding.js */
	var SelectBinding = function( runloop, Binding, handleDomEvent ) {

		var SelectBinding = Binding.extend( {
			getInitialValue: function() {
				var options = this.element.options,
					len, i, value, optionWasSelected;
				if ( this.element.getAttribute( 'value' ) !== undefined ) {
					return;
				}
				i = len = options.length;
				if ( !len ) {
					return;
				}
				// take the final selected option...
				while ( i-- ) {
					if ( options[ i ].getAttribute( 'selected' ) ) {
						value = options[ i ].getAttribute( 'value' );
						optionWasSelected = true;
						break;
					}
				}
				// or the first non-disabled option, if none are selected
				if ( !optionWasSelected ) {
					while ( ++i < len ) {
						if ( !options[ i ].getAttribute( 'disabled' ) ) {
							value = options[ i ].getAttribute( 'value' );
							break;
						}
					}
				}
				// This is an optimisation (aka hack) that allows us to forgo some
				// other more expensive work
				if ( value !== undefined ) {
					this.element.attributes.value.value = value;
				}
				return value;
			},
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			// TODO this method is an anomaly... is it necessary?
			setValue: function( value ) {
				runloop.addViewmodel( this.root.viewmodel );
				this.root.viewmodel.set( this.keypath, value );
			},
			getValue: function() {
				var options, i, len, option, optionValue;
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( options[ i ].selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						return optionValue;
					}
				}
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			}
		} );
		return SelectBinding;
	}( runloop, Binding, handleDomEvent );

	/* utils/arrayContentsMatch.js */
	var arrayContentsMatch = function( isArray ) {

		return function( a, b ) {
			var i;
			if ( !isArray( a ) || !isArray( b ) ) {
				return false;
			}
			if ( a.length !== b.length ) {
				return false;
			}
			i = a.length;
			while ( i-- ) {
				if ( a[ i ] !== b[ i ] ) {
					return false;
				}
			}
			return true;
		};
	}( isArray );

	/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
	var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

		var MultipleSelectBinding = SelectBinding.extend( {
			getInitialValue: function() {
				return this.element.options.filter( function( option ) {
					return option.getAttribute( 'selected' );
				} ).map( function( option ) {
					return option.getAttribute( 'value' );
				} );
			},
			render: function() {
				var valueFromModel;
				this.element.node.addEventListener( 'change', handleDomEvent, false );
				valueFromModel = this.root.viewmodel.get( this.keypath );
				if ( valueFromModel === undefined ) {
					// get value from DOM, if possible
					this.handleChange();
				}
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			setValue: function() {
				throw new Error( 'TODO not implemented yet' );
			},
			getValue: function() {
				var selectedValues, options, i, len, option, optionValue;
				selectedValues = [];
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( option.selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						selectedValues.push( optionValue );
					}
				}
				return selectedValues;
			},
			handleChange: function() {
				var attribute, previousValue, value;
				attribute = this.attribute;
				previousValue = attribute.value;
				value = this.getValue();
				if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
					SelectBinding.prototype.handleChange.call( this );
				}
				return this;
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			},
			updateModel: function() {
				if ( this.attribute.value === undefined || !this.attribute.value.length ) {
					this.root.viewmodel.set( this.keypath, this.initialValue );
				}
			}
		} );
		return MultipleSelectBinding;
	}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

	/* virtualdom/items/Element/Binding/FileListBinding.js */
	var FileListBinding = function( Binding, handleDomEvent ) {

		var FileListBinding = Binding.extend( {
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.files;
			}
		} );
		return FileListBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/GenericBinding.js */
	var GenericBinding = function( Binding, handleDomEvent ) {

		var __export;
		var GenericBinding, getOptions;
		getOptions = {
			evaluateWrapped: true
		};
		GenericBinding = Binding.extend( {
			getInitialValue: function() {
				return '';
			},
			getValue: function() {
				return this.element.node.value;
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
				node.addEventListener( 'blur', handleBlur, false );
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
				node.removeEventListener( 'blur', handleBlur, false );
			}
		} );
		__export = GenericBinding;

		function handleBlur() {
			var value;
			handleDomEvent.call( this );
			value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
			this.value = value == undefined ? '' : value;
		}
		return __export;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/NumericBinding.js */
	var NumericBinding = function( GenericBinding ) {

		return GenericBinding.extend( {
			getInitialValue: function() {
				return undefined;
			},
			getValue: function() {
				var value = parseFloat( this.element.node.value );
				return isNaN( value ) ? undefined : value;
			}
		} );
	}( GenericBinding );

	/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
	var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

		var __export;
		__export = function createTwowayBinding( element ) {
			var attributes = element.attributes,
				type, Binding, bindName, bindChecked;
			// if this is a late binding, and there's already one, it
			// needs to be torn down
			if ( element.binding ) {
				element.binding.teardown();
				element.binding = null;
			}
			// contenteditable
			if ( // if the contenteditable attribute is true or is bindable and may thus become true
				( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {
				Binding = ContentEditableBinding;
			} else if ( element.name === 'input' ) {
				type = element.getAttribute( 'type' );
				if ( type === 'radio' || type === 'checkbox' ) {
					bindName = isBindable( attributes.name );
					bindChecked = isBindable( attributes.checked );
					// we can either bind the name attribute, or the checked attribute - not both
					if ( bindName && bindChecked ) {
						log.error( {
							message: 'badRadioInputBinding'
						} );
					}
					if ( bindName ) {
						Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
					} else if ( bindChecked ) {
						Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
					}
				} else if ( type === 'file' && isBindable( attributes.value ) ) {
					Binding = FileListBinding;
				} else if ( isBindable( attributes.value ) ) {
					Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
				}
			} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
				Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
			} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
				Binding = GenericBinding;
			}
			if ( Binding ) {
				return new Binding( element );
			}
		};

		function isBindable( attribute ) {
			return attribute && attribute.isBindable;
		}
		return __export;
	}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

	/* virtualdom/items/Element/EventHandler/prototype/bubble.js */
	var virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {
		var hasAction = this.getAction();
		if ( hasAction && !this.hasListener ) {
			this.listen();
		} else if ( !hasAction && this.hasListener ) {
			this.unrender();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/fire.js */
	var virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {

		return function EventHandler$fire( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event
			} );
		};
	}( Ractive$shared_fireEvent );

	/* virtualdom/items/Element/EventHandler/prototype/getAction.js */
	var virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {
		return this.action.toString().trim();
	};

	/* virtualdom/items/Element/EventHandler/prototype/init.js */
	var virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {

		var __export;
		var Fragment, getValueOptions = {
				args: true
			},
			eventPattern = /^event(?:\.(.+))?/;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function EventHandler$init( element, name, template ) {
			var handler = this,
				action, refs, ractive;
			handler.element = element;
			handler.root = element.root;
			handler.name = name;
			if ( name.indexOf( '*' ) !== -1 ) {
				log.error( {
					debug: this.root.debug,
					message: 'noElementProxyEventWildcards',
					args: {
						element: element.tagName,
						event: name
					}
				} );
				this.invalid = true;
			}
			if ( template.m ) {
				refs = template.a.r;
				// This is a method call
				handler.method = template.m;
				handler.keypaths = [];
				handler.fn = getFunctionFromString( template.a.s, refs.length );
				handler.parentFragment = element.parentFragment;
				ractive = handler.root;
				// Create resolvers for each reference
				handler.refResolvers = refs.map( function( ref, i ) {
					var match;
					// special case - the `event` object
					if ( match = eventPattern.exec( ref ) ) {
						handler.keypaths[ i ] = {
							eventObject: true,
							refinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []
						};
						return null;
					}
					return createReferenceResolver( handler, ref, function( keypath ) {
						handler.resolve( i, keypath );
					} );
				} );
				this.fire = fireMethodCall;
			} else {
				// Get action ('foo' in 'on-click='foo')
				action = template.n || template;
				if ( typeof action !== 'string' ) {
					action = new Fragment( {
						template: action,
						root: this.root,
						owner: this
					} );
				}
				this.action = action;
				// Get parameters
				if ( template.d ) {
					this.dynamicParams = new Fragment( {
						template: template.d,
						root: this.root,
						owner: this.element
					} );
					this.fire = fireEventWithDynamicParams;
				} else if ( template.a ) {
					this.params = template.a;
					this.fire = fireEventWithParams;
				}
			}
		};

		function fireMethodCall( event ) {
			var ractive, values, args;
			ractive = this.root;
			if ( typeof ractive[ this.method ] !== 'function' ) {
				throw new Error( 'Attempted to call a non-existent method ("' + this.method + '")' );
			}
			values = this.keypaths.map( function( keypath ) {
				var value, len, i;
				if ( keypath === undefined ) {
					// not yet resolved
					return undefined;
				}
				// TODO the refinements stuff would be better handled at parse time
				if ( keypath.eventObject ) {
					value = event;
					if ( len = keypath.refinements.length ) {
						for ( i = 0; i < len; i += 1 ) {
							value = value[ keypath.refinements[ i ] ];
						}
					}
				} else {
					value = ractive.viewmodel.get( keypath );
				}
				return value;
			} );
			ractive.event = event;
			args = this.fn.apply( null, values );
			ractive[ this.method ].apply( ractive, args );
			delete ractive.event;
		}

		function fireEventWithParams( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: this.params
			} );
		}

		function fireEventWithDynamicParams( event ) {
			var args = this.dynamicParams.getValue( getValueOptions );
			// need to strip [] from ends if a string!
			if ( typeof args === 'string' ) {
				args = args.substr( 1, args.length - 2 );
			}
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: args
			} );
		}
		return __export;
	}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
	var genericHandler = function genericHandler( event ) {
		var storage, handler;
		storage = this._ractive;
		handler = storage.events[ event.type ];
		handler.fire( {
			node: this,
			original: event,
			index: storage.index,
			keypath: storage.keypath,
			context: storage.root.get( storage.keypath )
		} );
	};

	/* virtualdom/items/Element/EventHandler/prototype/listen.js */
	var virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {

		var __export;
		var customHandlers = {},
			touchEvents = {
				touchstart: true,
				touchmove: true,
				touchend: true,
				touchcancel: true,
				//not w3c, but supported in some browsers
				touchleave: true
			};
		__export = function EventHandler$listen() {
			var definition, name = this.name;
			if ( this.invalid ) {
				return;
			}
			if ( definition = config.registries.events.find( this.root, name ) ) {
				this.custom = definition( this.node, getCustomHandler( name ) );
			} else {
				// Looks like we're dealing with a standard DOM event... but let's check
				if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
					// okay to use touch events if this browser doesn't support them
					if ( !touchEvents[ name ] ) {
						log.error( {
							debug: this.root.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'event',
								name: name
							}
						} );
					}
					return;
				}
				this.node.addEventListener( name, genericHandler, false );
			}
			this.hasListener = true;
		};

		function getCustomHandler( name ) {
			if ( !customHandlers[ name ] ) {
				customHandlers[ name ] = function( event ) {
					var storage = event.node._ractive;
					event.index = storage.index;
					event.keypath = storage.keypath;
					event.context = storage.root.get( storage.keypath );
					storage.events[ name ].fire( event );
				};
			}
			return customHandlers[ name ];
		}
		return __export;
	}( config, genericHandler, log );

	/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
	var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		var fragment;
		if ( this.method ) {
			fragment = this.element.parentFragment;
			this.refResolvers.forEach( rebind );
			return;
		}
		if ( typeof this.action !== 'string' ) {
			rebind( this.action );
		}
		if ( this.dynamicParams ) {
			rebind( this.dynamicParams );
		}

		function rebind( thing ) {
			thing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/render.js */
	var virtualdom_items_Element_EventHandler$render = function EventHandler$render() {
		this.node = this.element.node;
		// store this on the node itself, so it can be retrieved by a
		// universal handler
		this.node._ractive.events[ this.name ] = this;
		if ( this.method || this.getAction() ) {
			this.listen();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/resolve.js */
	var virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {
		this.keypaths[ index ] = keypath;
	};

	/* virtualdom/items/Element/EventHandler/prototype/unbind.js */
	var virtualdom_items_Element_EventHandler$unbind = function() {

		var __export;
		__export = function EventHandler$unbind() {
			if ( this.method ) {
				this.refResolvers.forEach( unbind );
				return;
			}
			// Tear down dynamic name
			if ( typeof this.action !== 'string' ) {
				this.action.unbind();
			}
			// Tear down dynamic parameters
			if ( this.dynamicParams ) {
				this.dynamicParams.unbind();
			}
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}();

	/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
	var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

		return function EventHandler$unrender() {
			if ( this.custom ) {
				this.custom.teardown();
			} else {
				this.node.removeEventListener( this.name, genericHandler, false );
			}
			this.hasListener = false;
		};
	}( genericHandler );

	/* virtualdom/items/Element/EventHandler/_EventHandler.js */
	var EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {

		var EventHandler = function( element, name, template ) {
			this.init( element, name, template );
		};
		EventHandler.prototype = {
			bubble: bubble,
			fire: fire,
			getAction: getAction,
			init: init,
			listen: listen,
			rebind: rebind,
			render: render,
			resolve: resolve,
			unbind: unbind,
			unrender: unrender
		};
		return EventHandler;
	}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );

	/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
	var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

		return function( element, template ) {
			var i, name, names, handler, result = [];
			for ( name in template ) {
				if ( template.hasOwnProperty( name ) ) {
					names = name.split( '-' );
					i = names.length;
					while ( i-- ) {
						handler = new EventHandler( element, names[ i ], template[ name ] );
						result.push( handler );
					}
				}
			}
			return result;
		};
	}( EventHandler );

	/* virtualdom/items/Element/Decorator/_Decorator.js */
	var Decorator = function( log, circular, config ) {

		var Fragment, getValueOptions, Decorator;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		getValueOptions = {
			args: true
		};
		Decorator = function( element, template ) {
			var decorator = this,
				ractive, name, fragment;
			decorator.element = element;
			decorator.root = ractive = element.root;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			if ( template.a ) {
				decorator.params = template.a;
			} else if ( template.d ) {
				decorator.fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				decorator.params = decorator.fragment.getValue( getValueOptions );
				decorator.fragment.bubble = function() {
					this.dirtyArgs = this.dirtyValue = true;
					decorator.params = this.getValue( getValueOptions );
					if ( decorator.ready ) {
						decorator.update();
					}
				};
			}
			decorator.fn = config.registries.decorators.find( ractive, name );
			if ( !decorator.fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'decorator',
						name: name
					}
				} );
			}
		};
		Decorator.prototype = {
			init: function() {
				var decorator = this,
					node, result, args;
				node = decorator.element.node;
				if ( decorator.params ) {
					args = [ node ].concat( decorator.params );
					result = decorator.fn.apply( decorator.root, args );
				} else {
					result = decorator.fn.call( decorator.root, node );
				}
				if ( !result || !result.teardown ) {
					throw new Error( 'Decorator definition must return an object with a teardown method' );
				}
				// TODO does this make sense?
				decorator.actual = result;
				decorator.ready = true;
			},
			update: function() {
				if ( this.actual.update ) {
					this.actual.update.apply( this.root, this.params );
				} else {
					this.actual.teardown( true );
					this.init();
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.fragment ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			teardown: function( updating ) {
				this.actual.teardown();
				if ( !updating && this.fragment ) {
					this.fragment.unbind();
				}
			}
		};
		return Decorator;
	}( log, circular, config );

	/* virtualdom/items/Element/special/select/sync.js */
	var sync = function( toArray ) {

		var __export;
		__export = function syncSelect( selectElement ) {
			var selectNode, selectValue, isMultiple, options, optionWasSelected;
			selectNode = selectElement.node;
			if ( !selectNode ) {
				return;
			}
			options = toArray( selectNode.options );
			selectValue = selectElement.getAttribute( 'value' );
			isMultiple = selectElement.getAttribute( 'multiple' );
			// If the <select> has a specified value, that should override
			// these options
			if ( selectValue !== undefined ) {
				options.forEach( function( o ) {
					var optionValue, shouldSelect;
					optionValue = o._ractive ? o._ractive.value : o.value;
					shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
					if ( shouldSelect ) {
						optionWasSelected = true;
					}
					o.selected = shouldSelect;
				} );
				if ( !optionWasSelected ) {
					if ( options[ 0 ] ) {
						options[ 0 ].selected = true;
					}
					if ( selectElement.binding ) {
						selectElement.binding.forceUpdate();
					}
				}
			} else if ( selectElement.binding ) {
				selectElement.binding.forceUpdate();
			}
		};

		function valueContains( selectValue, optionValue ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( selectValue[ i ] == optionValue ) {
					return true;
				}
			}
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Element/special/select/bubble.js */
	var bubble = function( runloop, syncSelect ) {

		return function bubbleSelect() {
			var this$0 = this;
			if ( !this.dirty ) {
				this.dirty = true;
				runloop.scheduleTask( function() {
					syncSelect( this$0 );
					this$0.dirty = false;
				} );
			}
			this.parentFragment.bubble();
		};
	}( runloop, sync );

	/* virtualdom/items/Element/special/option/findParentSelect.js */
	var findParentSelect = function findParentSelect( element ) {
		do {
			if ( element.name === 'select' ) {
				return element;
			}
		} while ( element = element.parent );
	};

	/* virtualdom/items/Element/special/option/init.js */
	var init = function( findParentSelect ) {

		return function initOption( option, template ) {
			option.select = findParentSelect( option.parent );
			// we might be inside a <datalist> element
			if ( !option.select ) {
				return;
			}
			option.select.options.push( option );
			// If the value attribute is missing, use the element's content
			if ( !template.a ) {
				template.a = {};
			}
			// ...as long as it isn't disabled
			if ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {
				template.a.value = template.f;
			}
			// If there is a `selected` attribute, but the <select>
			// already has a value, delete it
			if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
				delete template.a.selected;
			}
		};
	}( findParentSelect );

	/* virtualdom/items/Element/prototype/init.js */
	var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Element$init( options ) {
			var parentFragment, template, ractive, binding, bindings;
			this.type = types.ELEMENT;
			// stuff we'll need later
			parentFragment = this.parentFragment = options.parentFragment;
			template = this.template = options.template;
			this.parent = options.pElement || parentFragment.pElement;
			this.root = ractive = parentFragment.root;
			this.index = options.index;
			this.name = enforceCase( template.e );
			// Special case - <option> elements
			if ( this.name === 'option' ) {
				initOption( this, template );
			}
			// Special case - <select> elements
			if ( this.name === 'select' ) {
				this.options = [];
				this.bubble = bubbleSelect;
			}
			// create attributes
			this.attributes = createAttributes( this, template.a );
			this.conditionalAttributes = createConditionalAttributes( this, template.m );
			// append children, if there are any
			if ( template.f ) {
				this.fragment = new Fragment( {
					template: template.f,
					root: ractive,
					owner: this,
					pElement: this
				} );
			}
			// create twoway binding
			if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
				this.binding = binding;
				// register this with the root, so that we can do ractive.updateModel()
				bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
				bindings.push( binding );
			}
			// create event proxies
			if ( template.v ) {
				this.eventHandlers = createEventHandlers( this, template.v );
			}
			// create decorator
			if ( template.o ) {
				this.decorator = new Decorator( this, template.o );
			}
			// create transitions
			this.intro = template.t0 || template.t1;
			this.outro = template.t0 || template.t2;
		};
	}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

	/* virtualdom/items/shared/utils/startsWith.js */
	var startsWith = function( startsWithKeypath ) {

		return function startsWith( target, keypath ) {
			return target === keypath || startsWithKeypath( target, keypath );
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/utils/assignNewKeypath.js */
	var assignNewKeypath = function( startsWith, getNewKeypath ) {

		return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
			var existingKeypath = target[ property ];
			if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
				return;
			}
			target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
		};
	}( startsWith, getNewKeypath );

	/* virtualdom/items/Element/prototype/rebind.js */
	var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

		return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var i, storage, liveQueries, ractive;
			if ( this.attributes ) {
				this.attributes.forEach( rebind );
			}
			if ( this.conditionalAttributes ) {
				this.conditionalAttributes.forEach( rebind );
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( rebind );
			}
			if ( this.decorator ) {
				rebind( this.decorator );
			}
			// rebind children
			if ( this.fragment ) {
				rebind( this.fragment );
			}
			// Update live queries, if necessary
			if ( liveQueries = this.liveQueries ) {
				ractive = this.root;
				i = liveQueries.length;
				while ( i-- ) {
					liveQueries[ i ]._makeDirty();
				}
			}
			if ( this.node && ( storage = this.node._ractive ) ) {
				// adjust keypath if needed
				assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
				if ( indexRef != undefined ) {
					storage.index[ indexRef ] = newIndex;
				}
			}

			function rebind( thing ) {
				thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( assignNewKeypath );

	/* virtualdom/items/Element/special/img/render.js */
	var render = function renderImage( img ) {
		var loadHandler;
		// if this is an <img>, and we're in a crap browser, we may need to prevent it
		// from overriding width and height when it loads the src
		if ( img.attributes.width || img.attributes.height ) {
			img.node.addEventListener( 'load', loadHandler = function() {
				var width = img.getAttribute( 'width' ),
					height = img.getAttribute( 'height' );
				if ( width !== undefined ) {
					img.node.setAttribute( 'width', width );
				}
				if ( height !== undefined ) {
					img.node.setAttribute( 'height', height );
				}
				img.node.removeEventListener( 'load', loadHandler, false );
			}, false );
		}
	};

	/* virtualdom/items/Element/Transition/prototype/init.js */
	var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

		var Fragment, getValueOptions = {};
		// TODO what are the options?
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Transition$init( element, template, isIntro ) {
			var t = this,
				ractive, name, fragment;
			t.element = element;
			t.root = ractive = element.root;
			t.isIntro = isIntro;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			t.name = name;
			if ( template.a ) {
				t.params = template.a;
			} else if ( template.d ) {
				// TODO is there a way to interpret dynamic arguments without all the
				// 'dependency thrashing'?
				fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				t.params = fragment.getValue( getValueOptions );
				fragment.unbind();
			}
			t._fn = config.registries.transitions.find( ractive, name );
			if ( !t._fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'transition',
						name: name
					}
				} );
				return;
			}
		};
	}( log, config, circular );

	/* utils/camelCase.js */
	var camelCase = function( hyphenatedStr ) {
		return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
			return $1.toUpperCase();
		} );
	};

	/* virtualdom/items/Element/Transition/helpers/prefix.js */
	var prefix = function( isClient, vendors, createElement, camelCase ) {

		var prefix, prefixCache, testStyle;
		if ( !isClient ) {
			prefix = null;
		} else {
			prefixCache = {};
			testStyle = createElement( 'div' ).style;
			prefix = function( prop ) {
				var i, vendor, capped;
				prop = camelCase( prop );
				if ( !prefixCache[ prop ] ) {
					if ( testStyle[ prop ] !== undefined ) {
						prefixCache[ prop ] = prop;
					} else {
						// test vendors...
						capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
						i = vendors.length;
						while ( i-- ) {
							vendor = vendors[ i ];
							if ( testStyle[ vendor + capped ] !== undefined ) {
								prefixCache[ prop ] = vendor + capped;
								break;
							}
						}
					}
				}
				return prefixCache[ prop ];
			};
		}
		return prefix;
	}( isClient, vendors, createElement, camelCase );

	/* virtualdom/items/Element/Transition/prototype/getStyle.js */
	var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

		var getStyle, getComputedStyle;
		if ( !isClient ) {
			getStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			getStyle = function( props ) {
				var computedStyle, styles, i, prop, value;
				computedStyle = getComputedStyle( this.node );
				if ( typeof props === 'string' ) {
					value = computedStyle[ prefix( props ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					return value;
				}
				if ( !isArray( props ) ) {
					throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
				}
				styles = {};
				i = props.length;
				while ( i-- ) {
					prop = props[ i ];
					value = computedStyle[ prefix( prop ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					styles[ prop ] = value;
				}
				return styles;
			};
		}
		return getStyle;
	}( legacy, isClient, isArray, prefix );

	/* virtualdom/items/Element/Transition/prototype/setStyle.js */
	var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

		return function( style, value ) {
			var prop;
			if ( typeof style === 'string' ) {
				this.node.style[ prefix( style ) ] = value;
			} else {
				for ( prop in style ) {
					if ( style.hasOwnProperty( prop ) ) {
						this.node.style[ prefix( prop ) ] = style[ prop ];
					}
				}
			}
			return this;
		};
	}( prefix );

	/* shared/Ticker.js */
	var Ticker = function( warn, getTime, animations ) {

		var __export;
		var Ticker = function( options ) {
			var easing;
			this.duration = options.duration;
			this.step = options.step;
			this.complete = options.complete;
			// easing
			if ( typeof options.easing === 'string' ) {
				easing = options.root.easing[ options.easing ];
				if ( !easing ) {
					warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
					easing = linear;
				}
			} else if ( typeof options.easing === 'function' ) {
				easing = options.easing;
			} else {
				easing = linear;
			}
			this.easing = easing;
			this.start = getTime();
			this.end = this.start + this.duration;
			this.running = true;
			animations.add( this );
		};
		Ticker.prototype = {
			tick: function( now ) {
				var elapsed, eased;
				if ( !this.running ) {
					return false;
				}
				if ( now > this.end ) {
					if ( this.step ) {
						this.step( 1 );
					}
					if ( this.complete ) {
						this.complete( 1 );
					}
					return false;
				}
				elapsed = now - this.start;
				eased = this.easing( elapsed / this.duration );
				if ( this.step ) {
					this.step( eased );
				}
				return true;
			},
			stop: function() {
				if ( this.abort ) {
					this.abort();
				}
				this.running = false;
			}
		};
		__export = Ticker;

		function linear( t ) {
			return t;
		}
		return __export;
	}( warn, getTime, animations );

	/* virtualdom/items/Element/Transition/helpers/unprefix.js */
	var unprefix = function( vendors ) {

		var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
		return function( prop ) {
			return prop.replace( unprefixPattern, '' );
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
	var hyphenate = function( vendors ) {

		var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
		return function( str ) {
			var hyphenated;
			if ( !str ) {
				return '';
			}
			if ( vendorPattern.test( str ) ) {
				str = '-' + str;
			}
			hyphenated = str.replace( /[A-Z]/g, function( match ) {
				return '-' + match.toLowerCase();
			} );
			return hyphenated;
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
	var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

		var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
			cannotUseCssTransitions = {};
		if ( !isClient ) {
			createTransitions = null;
		} else {
			testStyle = createElement( 'div' ).style;
			// determine some facts about our environment
			( function() {
				if ( testStyle.transition !== undefined ) {
					TRANSITION = 'transition';
					TRANSITIONEND = 'transitionend';
					CSS_TRANSITIONS_ENABLED = true;
				} else if ( testStyle.webkitTransition !== undefined ) {
					TRANSITION = 'webkitTransition';
					TRANSITIONEND = 'webkitTransitionEnd';
					CSS_TRANSITIONS_ENABLED = true;
				} else {
					CSS_TRANSITIONS_ENABLED = false;
				}
			}() );
			if ( TRANSITION ) {
				TRANSITION_DURATION = TRANSITION + 'Duration';
				TRANSITION_PROPERTY = TRANSITION + 'Property';
				TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
			}
			createTransitions = function( t, to, options, changedProperties, resolve ) {
				// Wait a beat (otherwise the target styles will be applied immediately)
				// TODO use a fastdom-style mechanism?
				setTimeout( function() {
					var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
					checkComplete = function() {
						if ( jsTransitionsComplete && cssTransitionsComplete ) {
							// will changes to events and fire have an unexpected consequence here?
							t.root.fire( t.name + ':end', t.node, t.isIntro );
							resolve();
						}
					};
					// this is used to keep track of which elements can use CSS to animate
					// which properties
					hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
					t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
					t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
					t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
					transitionEndHandler = function( event ) {
						var index;
						index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
						if ( index !== -1 ) {
							changedProperties.splice( index, 1 );
						}
						if ( changedProperties.length ) {
							// still transitioning...
							return;
						}
						t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
						cssTransitionsComplete = true;
						checkComplete();
					};
					t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
					setTimeout( function() {
						var i = changedProperties.length,
							hash, originalValue, index, propertiesToTransitionInJs = [],
							prop, suffix;
						while ( i-- ) {
							prop = changedProperties[ i ];
							hash = hashPrefix + prop;
							if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
								t.node.style[ prefix( prop ) ] = to[ prop ];
								// If we're not sure if CSS transitions are supported for
								// this tag/property combo, find out now
								if ( !canUseCssTransitions[ hash ] ) {
									originalValue = t.getStyle( prop );
									// if this property is transitionable in this browser,
									// the current style will be different from the target style
									canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
									cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
									// Reset, if we're going to use timers after all
									if ( cannotUseCssTransitions[ hash ] ) {
										t.node.style[ prefix( prop ) ] = originalValue;
									}
								}
							}
							if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
								// we need to fall back to timer-based stuff
								if ( originalValue === undefined ) {
									originalValue = t.getStyle( prop );
								}
								// need to remove this from changedProperties, otherwise transitionEndHandler
								// will get confused
								index = changedProperties.indexOf( prop );
								if ( index === -1 ) {
									warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
								} else {
									changedProperties.splice( index, 1 );
								}
								// TODO Determine whether this property is animatable at all
								suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
								// ...then kick off a timer-based transition
								propertiesToTransitionInJs.push( {
									name: prefix( prop ),
									interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
									suffix: suffix
								} );
							}
						}
						// javascript transitions
						if ( propertiesToTransitionInJs.length ) {
							new Ticker( {
								root: t.root,
								duration: options.duration,
								easing: camelCase( options.easing || '' ),
								step: function( pos ) {
									var prop, i;
									i = propertiesToTransitionInJs.length;
									while ( i-- ) {
										prop = propertiesToTransitionInJs[ i ];
										t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
									}
								},
								complete: function() {
									jsTransitionsComplete = true;
									checkComplete();
								}
							} );
						} else {
							jsTransitionsComplete = true;
						}
						if ( !changedProperties.length ) {
							// We need to cancel the transitionEndHandler, and deal with
							// the fact that it will never fire
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						}
					}, 0 );
				}, options.delay || 0 );
			};
		}
		return createTransitions;
	}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
	var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

		var hidden, vendor, prefix, i, visibility;
		if ( typeof document !== 'undefined' ) {
			hidden = 'hidden';
			visibility = {};
			if ( hidden in document ) {
				prefix = '';
			} else {
				i = vendors.length;
				while ( i-- ) {
					vendor = vendors[ i ];
					hidden = vendor + 'Hidden';
					if ( hidden in document ) {
						prefix = vendor;
					}
				}
			}
			if ( prefix !== undefined ) {
				document.addEventListener( prefix + 'visibilitychange', onChange );
				// initialise
				onChange();
			} else {
				// gah, we're in an old browser
				if ( 'onfocusout' in document ) {
					document.addEventListener( 'focusout', onHide );
					document.addEventListener( 'focusin', onShow );
				} else {
					window.addEventListener( 'pagehide', onHide );
					window.addEventListener( 'blur', onHide );
					window.addEventListener( 'pageshow', onShow );
					window.addEventListener( 'focus', onShow );
				}
				visibility.hidden = false;
			}
		}

		function onChange() {
			visibility.hidden = document[ hidden ];
		}

		function onHide() {
			visibility.hidden = true;
		}

		function onShow() {
			visibility.hidden = false;
		}
		return visibility;
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
	var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

		var animateStyle, getComputedStyle, resolved;
		if ( !isClient ) {
			animateStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			animateStyle = function( style, value, options, complete ) {
				var t = this,
					to;
				// Special case - page isn't visible. Don't animate anything, because
				// that way you'll never get CSS transitionend events
				if ( visibility.hidden ) {
					this.setStyle( style, value );
					return resolved || ( resolved = Promise.resolve() );
				}
				if ( typeof style === 'string' ) {
					to = {};
					to[ style ] = value;
				} else {
					to = style;
					// shuffle arguments
					complete = options;
					options = value;
				}
				// As of 0.3.9, transition authors should supply an `option` object with
				// `duration` and `easing` properties (and optional `delay`), plus a
				// callback function that gets called after the animation completes
				// TODO remove this check in a future version
				if ( !options ) {
					warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
					options = t;
					complete = t.complete;
				}
				var promise = new Promise( function( resolve ) {
					var propertyNames, changedProperties, computedStyle, current, from, i, prop;
					// Edge case - if duration is zero, set style synchronously and complete
					if ( !options.duration ) {
						t.setStyle( to );
						resolve();
						return;
					}
					// Get a list of the properties we're animating
					propertyNames = Object.keys( to );
					changedProperties = [];
					// Store the current styles
					computedStyle = getComputedStyle( t.node );
					from = {};
					i = propertyNames.length;
					while ( i-- ) {
						prop = propertyNames[ i ];
						current = computedStyle[ prefix( prop ) ];
						if ( current === '0px' ) {
							current = 0;
						}
						// we need to know if we're actually changing anything
						if ( current != to[ prop ] ) {
							// use != instead of !==, so we can compare strings with numbers
							changedProperties.push( prop );
							// make the computed style explicit, so we can animate where
							// e.g. height='auto'
							t.node.style[ prefix( prop ) ] = current;
						}
					}
					// If we're not actually changing anything, the transitionend event
					// will never fire! So we complete early
					if ( !changedProperties.length ) {
						resolve();
						return;
					}
					createTransitions( t, to, options, changedProperties, resolve );
				} );
				// If a callback was supplied, do the honours
				// TODO remove this check in future
				if ( complete ) {
					warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
					promise.then( complete );
				}
				return promise;
			};
		}
		return animateStyle;
	}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

	/* utils/fillGaps.js */
	var fillGaps = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		sources.forEach( function( s ) {
			for ( var key in s ) {
				if ( s.hasOwnProperty( key ) && !( key in target ) ) {
					target[ key ] = s[ key ];
				}
			}
		} );
		return target;
	};

	/* virtualdom/items/Element/Transition/prototype/processParams.js */
	var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

		return function( params, defaults ) {
			if ( typeof params === 'number' ) {
				params = {
					duration: params
				};
			} else if ( typeof params === 'string' ) {
				if ( params === 'slow' ) {
					params = {
						duration: 600
					};
				} else if ( params === 'fast' ) {
					params = {
						duration: 200
					};
				} else {
					params = {
						duration: 400
					};
				}
			} else if ( !params ) {
				params = {};
			}
			return fillGaps( {}, params, defaults );
		};
	}( fillGaps );

	/* virtualdom/items/Element/Transition/prototype/start.js */
	var virtualdom_items_Element_Transition$start = function() {

		var __export;
		__export = function Transition$start() {
			var t = this,
				node, originalStyle, completed;
			node = t.node = t.element.node;
			originalStyle = node.getAttribute( 'style' );
			// create t.complete() - we don't want this on the prototype,
			// because we don't want `this` silliness when passing it as
			// an argument
			t.complete = function( noReset ) {
				if ( completed ) {
					return;
				}
				if ( !noReset && t.isIntro ) {
					resetStyle( node, originalStyle );
				}
				node._ractive.transition = null;
				t._manager.remove( t );
				completed = true;
			};
			// If the transition function doesn't exist, abort
			if ( !t._fn ) {
				t.complete();
				return;
			}
			t._fn.apply( t.root, [ t ].concat( t.params ) );
		};

		function resetStyle( node, style ) {
			if ( style ) {
				node.setAttribute( 'style', style );
			} else {
				// Next line is necessary, to remove empty style attribute!
				// See http://stackoverflow.com/a/7167553
				node.getAttribute( 'style' );
				node.removeAttribute( 'style' );
			}
		}
		return __export;
	}();

	/* virtualdom/items/Element/Transition/_Transition.js */
	var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

		var Fragment, Transition;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Transition = function( owner, template, isIntro ) {
			this.init( owner, template, isIntro );
		};
		Transition.prototype = {
			init: init,
			start: start,
			getStyle: getStyle,
			setStyle: setStyle,
			animateStyle: animateStyle,
			processParams: processParams
		};
		return Transition;
	}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

	/* virtualdom/items/Element/prototype/render.js */
	var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

		var __export;
		var updateCss, updateScript;
		updateCss = function() {
			var node = this.node,
				content = this.fragment.toString( false );
			// IE8 has no styleSheet unless there's a type text/css
			if ( window && window.appearsToBeIELessEqual8 ) {
				node.type = 'text/css';
			}
			if ( node.styleSheet ) {
				node.styleSheet.cssText = content;
			} else {
				while ( node.hasChildNodes() ) {
					node.removeChild( node.firstChild );
				}
				node.appendChild( document.createTextNode( content ) );
			}
		};
		updateScript = function() {
			if ( !this.node.type || this.node.type === 'text/javascript' ) {
				warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
			}
			this.node.text = this.fragment.toString( false );
		};
		__export = function Element$render() {
			var this$0 = this;
			var root = this.root,
				namespace, node;
			namespace = getNamespace( this );
			node = this.node = createElement( this.name, namespace );
			// Is this a top-level node of a component? If so, we may need to add
			// a data-rvcguid attribute, for CSS encapsulation
			// NOTE: css no longer copied to instance, so we check constructor.css -
			// we can enhance to handle instance, but this is more "correct" with current
			// functionality
			if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
				this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
			}
			// Add _ractive property to the node - we use this object to store stuff
			// related to proxy events, two-way bindings etc
			defineProperty( this.node, '_ractive', {
				value: {
					proxy: this,
					keypath: getInnerContext( this.parentFragment ),
					index: this.parentFragment.indexRefs,
					events: create( null ),
					root: root
				}
			} );
			// Render attributes
			this.attributes.forEach( function( a ) {
				return a.render( node );
			} );
			this.conditionalAttributes.forEach( function( a ) {
				return a.render( node );
			} );
			// Render children
			if ( this.fragment ) {
				// Special case - <script> element
				if ( this.name === 'script' ) {
					this.bubble = updateScript;
					this.node.text = this.fragment.toString( false );
					// bypass warning initially
					this.fragment.unrender = noop;
				} else if ( this.name === 'style' ) {
					this.bubble = updateCss;
					this.bubble();
					this.fragment.unrender = noop;
				} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
					this.fragment.unrender = noop;
				} else {
					this.node.appendChild( this.fragment.render() );
				}
			}
			// Add proxy event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.render();
				} );
			}
			// deal with two-way bindings
			if ( this.binding ) {
				this.binding.render();
				this.node._ractive.binding = this.binding;
			}
			// Special case: if this is an <img>, and we're in a crap browser, we may
			// need to prevent it from overriding width and height when it loads the src
			if ( this.name === 'img' ) {
				renderImage( this );
			}
			// apply decorator(s)
			if ( this.decorator && this.decorator.fn ) {
				runloop.scheduleTask( function() {
					return this$0.decorator.init();
				}, true );
			}
			// trigger intro transition
			if ( root.transitionsEnabled && this.intro ) {
				var transition = new Transition( this, this.intro, true );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				}, true );
				this.transition = transition;
			}
			if ( this.name === 'option' ) {
				processOption( this );
			}
			if ( this.node.autofocus ) {
				// Special case. Some browsers (*cough* Firefix *cough*) have a problem
				// with dynamically-generated elements having autofocus, and they won't
				// allow you to programmatically focus the element until it's in the DOM
				runloop.scheduleTask( function() {
					return this$0.node.focus();
				}, true );
			}
			updateLiveQueries( this );
			return this.node;
		};

		function getNamespace( element ) {
			var namespace, xmlns, parent;
			// Use specified namespace...
			if ( xmlns = element.getAttribute( 'xmlns' ) ) {
				namespace = xmlns;
			} else if ( element.name === 'svg' ) {
				namespace = namespaces.svg;
			} else if ( parent = element.parent ) {
				// ...or HTML, if the parent is a <foreignObject>
				if ( parent.name === 'foreignObject' ) {
					namespace = namespaces.html;
				} else {
					namespace = parent.node.namespaceURI;
				}
			} else {
				namespace = element.root.el.namespaceURI;
			}
			return namespace;
		}

		function processOption( option ) {
			var optionValue, selectValue, i;
			if ( !option.select ) {
				return;
			}
			selectValue = option.select.getAttribute( 'value' );
			if ( selectValue === undefined ) {
				return;
			}
			optionValue = option.getAttribute( 'value' );
			if ( option.select.node.multiple && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( optionValue == selectValue[ i ] ) {
						option.node.selected = true;
						break;
					}
				}
			} else {
				option.node.selected = optionValue == selectValue;
			}
		}

		function updateLiveQueries( element ) {
			var instance, liveQueries, i, selector, query;
			// Does this need to be added to any live queries?
			instance = element.root;
			do {
				liveQueries = instance._liveQueries;
				i = liveQueries.length;
				while ( i-- ) {
					selector = liveQueries[ i ];
					query = liveQueries[ '_' + selector ];
					if ( query._test( element ) ) {
						// keep register of applicable selectors, for when we teardown
						( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
					}
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

	/* virtualdom/items/Element/prototype/toString.js */
	var virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {

		var __export;
		__export = function() {
			var str, escape;
			str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
			str += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );
			// Special case - selected options
			if ( this.name === 'option' && optionIsSelected( this ) ) {
				str += ' selected';
			}
			// Special case - two-way radio name bindings
			if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
				str += ' checked';
			}
			str += '>';
			// Special case - textarea
			if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
				str += escapeHtml( this.getAttribute( 'value' ) );
			} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
				str += this.getAttribute( 'value' );
			}
			if ( this.fragment ) {
				escape = this.name !== 'script' && this.name !== 'style';
				str += this.fragment.toString( escape );
			}
			// add a closing tag if this isn't a void element
			if ( !voidElementNames.test( this.template.e ) ) {
				str += '</' + this.template.e + '>';
			}
			return str;
		};

		function optionIsSelected( element ) {
			var optionValue, selectValue, i;
			optionValue = element.getAttribute( 'value' );
			if ( optionValue === undefined || !element.select ) {
				return false;
			}
			selectValue = element.select.getAttribute( 'value' );
			if ( selectValue == optionValue ) {
				return true;
			}
			if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
		}

		function inputIsCheckedRadio( element ) {
			var attributes, typeAttribute, valueAttribute, nameAttribute;
			attributes = element.attributes;
			typeAttribute = attributes.type;
			valueAttribute = attributes.value;
			nameAttribute = attributes.name;
			if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
				return;
			}
			if ( valueAttribute.value === nameAttribute.interpolator.value ) {
				return true;
			}
		}

		function stringifyAttribute( attribute ) {
			var str = attribute.toString();
			return str ? ' ' + str : '';
		}
		return __export;
	}( voidElementNames, isArray, escapeHtml );

	/* virtualdom/items/Element/special/option/unbind.js */
	var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

		return function unbindOption( option ) {
			if ( option.select ) {
				removeFromArray( option.select.options, option );
			}
		};
	}( removeFromArray );

	/* virtualdom/items/Element/prototype/unbind.js */
	var virtualdom_items_Element$unbind = function( unbindOption ) {

		var __export;
		__export = function Element$unbind() {
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.binding ) {
				this.binding.unbind();
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( unbind );
			}
			// Special case - <option>
			if ( this.name === 'option' ) {
				unbindOption( this );
			}
			this.attributes.forEach( unbind );
			this.conditionalAttributes.forEach( unbind );
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}( virtualdom_items_Element_special_option_unbind );

	/* virtualdom/items/Element/prototype/unrender.js */
	var virtualdom_items_Element$unrender = function( runloop, Transition ) {

		var __export;
		__export = function Element$unrender( shouldDestroy ) {
			var binding, bindings;
			if ( this.transition ) {
				this.transition.complete();
			}
			// Detach as soon as we can
			if ( this.name === 'option' ) {
				// <option> elements detach immediately, so that
				// their parent <select> element syncs correctly, and
				// since option elements can't have transitions anyway
				this.detach();
			} else if ( shouldDestroy ) {
				runloop.detachWhenReady( this );
			}
			// Children first. that way, any transitions on child elements will be
			// handled by the current transitionManager
			if ( this.fragment ) {
				this.fragment.unrender( false );
			}
			if ( binding = this.binding ) {
				this.binding.unrender();
				this.node._ractive.binding = null;
				bindings = this.root._twowayBindings[ binding.keypath ];
				bindings.splice( bindings.indexOf( binding ), 1 );
			}
			// Remove event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.unrender();
				} );
			}
			if ( this.decorator ) {
				this.decorator.teardown();
			}
			// trigger outro transition if necessary
			if ( this.root.transitionsEnabled && this.outro ) {
				var transition = new Transition( this, this.outro, false );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			// Remove this node from any live queries
			if ( this.liveQueries ) {
				removeFromLiveQueries( this );
			}
		};

		function removeFromLiveQueries( element ) {
			var query, selector, i;
			i = element.liveQueries.length;
			while ( i-- ) {
				query = element.liveQueries[ i ];
				selector = query.selector;
				query._remove( element.node );
			}
		}
		return __export;
	}( runloop, Transition );

	/* virtualdom/items/Element/_Element.js */
	var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

		var Element = function( options ) {
			this.init( options );
		};
		Element.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getAttribute: getAttribute,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Element;
	}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

	/* virtualdom/items/Partial/deIndent.js */
	var deIndent = function() {

		var __export;
		var empty = /^\s*$/,
			leadingWhitespace = /^\s*/;
		__export = function( str ) {
			var lines, firstLine, lastLine, minIndent;
			lines = str.split( '\n' );
			// remove first and last line, if they only contain whitespace
			firstLine = lines[ 0 ];
			if ( firstLine !== undefined && empty.test( firstLine ) ) {
				lines.shift();
			}
			lastLine = lines[ lines.length - 1 ];
			if ( lastLine !== undefined && empty.test( lastLine ) ) {
				lines.pop();
			}
			minIndent = lines.reduce( reducer, null );
			if ( minIndent ) {
				str = lines.map( function( line ) {
					return line.replace( minIndent, '' );
				} ).join( '\n' );
			}
			return str;
		};

		function reducer( previous, line ) {
			var lineIndent = leadingWhitespace.exec( line )[ 0 ];
			if ( previous === null || lineIndent.length < previous.length ) {
				return lineIndent;
			}
			return previous;
		}
		return __export;
	}();

	/* virtualdom/items/Partial/getPartialTemplate.js */
	var getPartialTemplate = function( log, config, parser, deIndent ) {

		var __export;
		__export = function getPartialTemplate( ractive, name ) {
			var partial;
			// If the partial in instance or view heirarchy instances, great
			if ( partial = getPartialFromRegistry( ractive, name ) ) {
				return partial;
			}
			// Does it exist on the page as a script tag?
			partial = parser.fromId( name, {
				noThrow: true
			} );
			if ( partial ) {
				// is this necessary?
				partial = deIndent( partial );
				// parse and register to this ractive instance
				var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
				// register (and return main partial if there are others in the template)
				return ractive.partials[ name ] = parsed.t;
			}
		};

		function getPartialFromRegistry( ractive, name ) {
			var partials = config.registries.partials;
			// find first instance in the ractive or view hierarchy that has this partial
			var instance = partials.findInstance( ractive, name );
			if ( !instance ) {
				return;
			}
			var partial = instance.partials[ name ],
				fn;
			// partial is a function?
			if ( typeof partial === 'function' ) {
				fn = partial.bind( instance );
				fn.isOwner = instance.partials.hasOwnProperty( name );
				partial = fn( instance.data, parser );
			}
			if ( !partial ) {
				log.warn( {
					debug: ractive.debug,
					message: 'noRegistryFunctionReturn',
					args: {
						registry: 'partial',
						name: name
					}
				} );
				return;
			}
			// If this was added manually to the registry,
			// but hasn't been parsed, parse it now
			if ( !parser.isParsed( partial ) ) {
				// use the parseOptions of the ractive instance on which it was found
				var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
				// Partials cannot contain nested partials!
				// TODO add a test for this
				if ( parsed.p ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noNestedPartials',
						args: {
							rname: name
						}
					} );
				}
				// if fn, use instance to store result, otherwise needs to go
				// in the correct point in prototype chain on instance or constructor
				var target = fn ? instance : partials.findOwner( instance, name );
				// may be a template with partials, which need to be registered and main template extracted
				target.partials[ name ] = partial = parsed.t;
			}
			// store for reset
			if ( fn ) {
				partial._fn = fn;
			}
			return partial.v ? partial.t : partial;
		}
		return __export;
	}( log, config, parser, deIndent );

	/* virtualdom/items/Partial/applyIndent.js */
	var applyIndent = function( string, indent ) {
		var indented;
		if ( !indent ) {
			return string;
		}
		indented = string.split( '\n' ).map( function( line, notFirstLine ) {
			return notFirstLine ? indent + line : line;
		} ).join( '\n' );
		return indented;
	};

	/* virtualdom/items/Partial/_Partial.js */
	var Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {

		var Partial, Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Partial = function( options ) {
			var parentFragment, template;
			parentFragment = this.parentFragment = options.parentFragment;
			this.root = parentFragment.root;
			this.type = types.PARTIAL;
			this.index = options.index;
			this.name = options.template.r;
			this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;
			Mustache.init( this, options );
			// If this didn't resolve, it most likely means we have a named partial
			// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
			// whose name is the value of `foo`')
			if ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {
				unbind.call( this );
				// prevent any further changes
				this.isNamed = true;
				this.setTemplate( template );
			}
		};
		Partial.prototype = {
			bubble: function() {
				this.parentFragment.bubble();
			},
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			findNextNode: function() {
				return this.parentFragment.findNextNode( this );
			},
			getValue: function() {
				return this.fragment.getValue();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				rebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function() {
				this.docFrag = document.createDocumentFragment();
				this.update();
				this.rendered = true;
				return this.docFrag;
			},
			resolve: Mustache.resolve,
			setValue: function( value ) {
				var template;
				if ( value !== undefined && value === this.value ) {
					// nothing has changed, so no work to be done
					return;
				}
				template = getPartialTemplate( this.root, '' + value );
				// we may be here if we have a partial like `{{>foo}}` and `foo` is the
				// name of both a data property (whose value ISN'T the name of a partial)
				// and a partial. In those cases, this becomes a named partial
				if ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {
					unbind.call( this );
					this.isNamed = true;
				}
				if ( !template ) {
					log.error( {
						debug: this.root.debug,
						message: 'noTemplateForPartial',
						args: {
							name: this.name
						}
					} );
				}
				this.setTemplate( template || [] );
				this.value = value;
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			},
			setTemplate: function( template ) {
				if ( this.fragment ) {
					this.fragment.unbind();
					this.fragmentToUnrender = this.fragment;
				}
				this.fragment = new Fragment( {
					template: template,
					root: this.root,
					owner: this,
					pElement: this.parentFragment.pElement
				} );
				this.fragmentToRender = this.fragment;
			},
			toString: function( toString ) {
				var string, previousItem, lastLine, match;
				string = this.fragment.toString( toString );
				previousItem = this.parentFragment.items[ this.index - 1 ];
				if ( !previousItem || previousItem.type !== types.TEXT ) {
					return string;
				}
				lastLine = previousItem.text.split( '\n' ).pop();
				if ( match = /^\s+$/.exec( lastLine ) ) {
					return applyIndent( string, match[ 0 ] );
				}
				return string;
			},
			unbind: function() {
				if ( !this.isNamed ) {
					// dynamic partial - need to unbind self
					unbind.call( this );
				}
				if ( this.fragment ) {
					this.fragment.unbind();
				}
			},
			unrender: function( shouldDestroy ) {
				if ( this.rendered ) {
					if ( this.fragment ) {
						this.fragment.unrender( shouldDestroy );
					}
					this.rendered = false;
				}
			},
			update: function() {
				var target, anchor;
				if ( this.fragmentToUnrender ) {
					this.fragmentToUnrender.unrender( true );
					this.fragmentToUnrender = null;
				}
				if ( this.fragmentToRender ) {
					this.docFrag.appendChild( this.fragmentToRender.render() );
					this.fragmentToRender = null;
				}
				if ( this.rendered ) {
					target = this.parentFragment.getNode();
					anchor = this.parentFragment.findNextNode( this );
					target.insertBefore( this.docFrag, anchor );
				}
			}
		};
		return Partial;
	}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );

	/* virtualdom/items/Component/getComponent.js */
	var getComponent = function( config, log, circular ) {

		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		// finds the component constructor in the registry or view hierarchy registries
		return function getComponent( ractive, name ) {
			var component, instance = config.registries.components.findInstance( ractive, name );
			if ( instance ) {
				component = instance.components[ name ];
				// best test we have for not Ractive.extend
				if ( !component._parent ) {
					// function option, execute and store for reset
					var fn = component.bind( instance );
					fn.isOwner = instance.components.hasOwnProperty( name );
					component = fn( instance.data );
					if ( !component ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noRegistryFunctionReturn',
							args: {
								registry: 'component',
								name: name
							}
						} );
						return;
					}
					if ( typeof component === 'string' ) {
						//allow string lookup
						component = getComponent( ractive, component );
					}
					component._fn = fn;
					instance.components[ name ] = component;
				}
			}
			return component;
		};
	}( config, log, circular );

	/* virtualdom/items/Component/prototype/detach.js */
	var virtualdom_items_Component$detach = function( Hook ) {

		var detachHook = new Hook( 'detach' );
		return function Component$detach() {
			var detached = this.instance.fragment.detach();
			detachHook.fire( this.instance );
			return detached;
		};
	}( Ractive$shared_hooks_Hook );

	/* virtualdom/items/Component/prototype/find.js */
	var virtualdom_items_Component$find = function Component$find( selector ) {
		return this.instance.fragment.find( selector );
	};

	/* virtualdom/items/Component/prototype/findAll.js */
	var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
		return this.instance.fragment.findAll( selector, query );
	};

	/* virtualdom/items/Component/prototype/findAllComponents.js */
	var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
		query._test( this, true );
		if ( this.instance.fragment ) {
			this.instance.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Component/prototype/findComponent.js */
	var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
		if ( !selector || selector === this.name ) {
			return this.instance;
		}
		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( selector );
		}
		return null;
	};

	/* virtualdom/items/Component/prototype/findNextNode.js */
	var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Component/prototype/firstNode.js */
	var virtualdom_items_Component$firstNode = function Component$firstNode() {
		if ( this.rendered ) {
			return this.instance.fragment.firstNode();
		}
		return null;
	};

	/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
	var ComponentParameter = function( runloop, circular ) {

		var Fragment, ComponentParameter;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		ComponentParameter = function( component, key, value ) {
			this.parentFragment = component.parentFragment;
			this.component = component;
			this.key = key;
			this.fragment = new Fragment( {
				template: value,
				root: component.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
		};
		ComponentParameter.prototype = {
			bubble: function() {
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.addView( this );
				}
			},
			update: function() {
				var value = this.fragment.getValue();
				this.component.instance.viewmodel.set( this.key, value );
				runloop.addViewmodel( this.component.instance.viewmodel );
				this.value = value;
				this.dirty = false;
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			}
		};
		return ComponentParameter;
	}( runloop, circular );

	/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */
	var ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {

		var ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {
			var this$0 = this;
			this.root = component.root;
			this.parentFragment = component.parentFragment;
			this.ready = false;
			this.hash = null;
			this.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {
				// Are we updating an existing binding?
				if ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {
					component.bindings[ this$0.hash ] = null;
					this$0.binding.rebind( keypath );
					this$0.hash = keypath + '=' + childKeypath;
					component.bindings[ this$0.hash ];
				} else {
					if ( !this$0.ready ) {
						// The child instance isn't created yet, we need to create the binding later
						toBind.push( {
							childKeypath: childKeypath,
							parentKeypath: keypath
						} );
					} else {
						createComponentBinding( component, component.root, keypath, childKeypath );
					}
				}
				this$0.value = component.root.viewmodel.get( keypath );
			} );
		};
		ReferenceExpressionParameter.prototype = {
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.resolver.unbind();
			}
		};
		return ReferenceExpressionParameter;
	}( ReferenceExpressionResolver, createComponentBinding );

	/* virtualdom/items/Component/initialise/createModel/_createModel.js */
	var createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {

		var __export;
		__export = function( component, defaultData, attributes, toBind ) {
			var data = {},
				key, value;
			// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
			// other words, we need to construct a string fragment to watch
			// when they change. We store these so they can be torn down later
			component.complexParameters = [];
			for ( key in attributes ) {
				if ( attributes.hasOwnProperty( key ) ) {
					value = getValue( component, key, attributes[ key ], toBind );
					if ( value !== undefined || defaultData[ key ] === undefined ) {
						data[ key ] = value;
					}
				}
			}
			return data;
		};

		function getValue( component, key, template, toBind ) {
			var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
			parentInstance = component.root;
			parentFragment = component.parentFragment;
			// If this is a static value, great
			if ( typeof template === 'string' ) {
				parsed = parseJSON( template );
				if ( !parsed ) {
					return template;
				}
				return parsed.value;
			}
			// If null, we treat it as a boolean attribute (i.e. true)
			if ( template === null ) {
				return true;
			}
			// Single interpolator?
			if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {
				// If it's a regular interpolator, we bind to it
				if ( template[ 0 ].r ) {
					// Is it an index reference?
					if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
						component.indexRefBindings[ indexRef ] = key;
						return parentFragment.indexRefs[ indexRef ];
					}
					// TODO what about references that resolve late? Should these be considered?
					keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
					// We need to set up bindings between parent and child, but
					// we can't do it yet because the child instance doesn't exist
					// yet - so we make a note instead
					toBind.push( {
						childKeypath: key,
						parentKeypath: keypath
					} );
					return parentInstance.viewmodel.get( keypath );
				}
				// If it's a reference expression (e.g. `{{foo[bar]}}`), we need
				// to watch the keypath and create/destroy bindings
				if ( template[ 0 ].rx ) {
					parameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );
					component.complexParameters.push( parameter );
					parameter.ready = true;
					return parameter.value;
				}
			}
			// We have a 'complex parameter' - we need to create a full-blown string
			// fragment in order to evaluate and observe its value
			parameter = new ComponentParameter( component, key, template );
			component.complexParameters.push( parameter );
			return parameter.value;
		}
		return __export;
	}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );

	/* virtualdom/items/Component/initialise/createInstance.js */
	var createInstance = function( log ) {

		return function( component, Component, data, contentDescriptor ) {
			var instance, parentFragment, partials, ractive;
			parentFragment = component.parentFragment;
			ractive = component.root;
			// Make contents available as a {{>content}} partial
			partials = {
				content: contentDescriptor || []
			};
			if ( Component.defaults.el ) {
				log.warn( {
					debug: ractive.debug,
					message: 'defaultElSpecified',
					args: {
						name: component.name
					}
				} );
			}
			instance = new Component( {
				el: null,
				append: true,
				data: data,
				partials: partials,
				magic: ractive.magic || Component.defaults.magic,
				modifyArrays: ractive.modifyArrays,
				_parent: ractive,
				_component: component,
				// need to inherit runtime parent adaptors
				adapt: ractive.adapt,
				yield: {
					template: contentDescriptor,
					instance: ractive
				}
			} );
			return instance;
		};
	}( log );

	/* virtualdom/items/Component/initialise/createBindings.js */
	var createBindings = function( createComponentBinding ) {

		return function createInitialComponentBindings( component, toBind ) {
			toBind.forEach( function createInitialComponentBinding( pair ) {
				var childValue, parentValue;
				createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
				childValue = component.instance.viewmodel.get( pair.childKeypath );
				parentValue = component.root.viewmodel.get( pair.parentKeypath );
				if ( childValue !== undefined && parentValue === undefined ) {
					component.root.viewmodel.set( pair.parentKeypath, childValue );
				}
			} );
		};
	}( createComponentBinding );

	/* virtualdom/items/Component/initialise/propagateEvents.js */
	var propagateEvents = function( circular, fireEvent, log ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function propagateEvents( component, eventsDescriptor ) {
			var eventName;
			for ( eventName in eventsDescriptor ) {
				if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
					propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
				}
			}
		};

		function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
			if ( typeof proxyEventName !== 'string' ) {
				log.error( {
					debug: parentInstance.debug,
					message: 'noComponentEventArguments'
				} );
			}
			childInstance.on( eventName, function() {
				var event, args;
				// semi-weak test, but what else? tag the event obj ._isEvent ?
				if ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {
					event = Array.prototype.shift.call( arguments );
				}
				args = Array.prototype.slice.call( arguments );
				fireEvent( parentInstance, proxyEventName, {
					event: event,
					args: args
				} );
				// cancel bubbling
				return false;
			} );
		}
		return __export;
	}( circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Component/initialise/updateLiveQueries.js */
	var updateLiveQueries = function( component ) {
		var ancestor, query;
		// If there's a live query for this component type, add it
		ancestor = component.root;
		while ( ancestor ) {
			if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
				query.push( component.instance );
			}
			ancestor = ancestor._parent;
		}
	};

	/* virtualdom/items/Component/prototype/init.js */
	var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

		return function Component$init( options, Component ) {
			var parentFragment, root, data, toBind;
			parentFragment = this.parentFragment = options.parentFragment;
			root = parentFragment.root;
			this.root = root;
			this.type = types.COMPONENT;
			this.name = options.template.e;
			this.index = options.index;
			this.indexRefBindings = {};
			this.bindings = [];
			// even though only one yielder is allowed, we need to have an array of them
			// as it's possible to cause a yielder to be created before the last one
			// was destroyed in the same turn of the runloop
			this.yielders = [];
			if ( !Component ) {
				throw new Error( 'Component "' + this.name + '" not found' );
			}
			// First, we need to create a model for the component - e.g. if we
			// encounter <widget foo='bar'/> then we need to create a widget
			// with `data: { foo: 'bar' }`.
			//
			// This may involve setting up some bindings, but we can't do it
			// yet so we take some notes instead
			toBind = [];
			data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
			createInstance( this, Component, data, options.template.f );
			createBindings( this, toBind );
			propagateEvents( this, options.template.v );
			// intro, outro and decorator directives have no effect
			if ( options.template.t1 || options.template.t2 || options.template.o ) {
				warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
			}
			updateLiveQueries( this );
		};
	}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

	/* virtualdom/items/Component/prototype/rebind.js */
	var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

		return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var childInstance = this.instance,
				parentInstance = childInstance._parent,
				indexRefAlias, query;
			this.bindings.forEach( function( binding ) {
				var updated;
				if ( binding.root !== parentInstance ) {
					return;
				}
				if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
					binding.rebind( updated );
				}
			} );
			this.complexParameters.forEach( rebind );
			if ( this.yielders[ 0 ] ) {
				rebind( this.yielders[ 0 ] );
			}
			if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
				runloop.addViewmodel( childInstance.viewmodel );
				childInstance.viewmodel.set( indexRefAlias, newIndex );
			}
			if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
				query._makeDirty();
			}

			function rebind( x ) {
				x.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( runloop, getNewKeypath );

	/* virtualdom/items/Component/prototype/render.js */
	var virtualdom_items_Component$render = function Component$render() {
		var instance = this.instance;
		instance.render( this.parentFragment.getNode() );
		this.rendered = true;
		return instance.fragment.detach();
	};

	/* virtualdom/items/Component/prototype/toString.js */
	var virtualdom_items_Component$toString = function Component$toString() {
		return this.instance.fragment.toString();
	};

	/* virtualdom/items/Component/prototype/unbind.js */
	var virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {

		var __export;
		var teardownHook = new Hook( 'teardown' );
		__export = function Component$unbind() {
			var instance = this.instance;
			this.complexParameters.forEach( unbind );
			this.bindings.forEach( unbind );
			removeFromLiveComponentQueries( this );
			// teardown the instance
			instance.fragment.unbind();
			instance.viewmodel.teardown();
			if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
				removeFromArray( instance.el.__ractive_instances__, instance );
			}
			teardownHook.fire( instance );
		};

		function unbind( thing ) {
			thing.unbind();
		}

		function removeFromLiveComponentQueries( component ) {
			var instance, query;
			instance = component.root;
			do {
				if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
					query._remove( component );
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* virtualdom/items/Component/prototype/unrender.js */
	var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
		this.shouldDestroy = shouldDestroy;
		this.instance.unrender();
	};

	/* virtualdom/items/Component/_Component.js */
	var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

		var Component = function( options, Constructor ) {
			this.init( options, Constructor );
		};
		Component.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Component;
	}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

	/* virtualdom/items/Comment.js */
	var Comment = function( types, detach ) {

		var Comment = function( options ) {
			this.type = types.COMMENT;
			this.value = options.template.c;
		};
		Comment.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createComment( this.value );
				}
				return this.node;
			},
			toString: function() {
				return '<!--' + this.value + '-->';
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					this.node.parentNode.removeChild( this.node );
				}
			}
		};
		return Comment;
	}( types, detach );

	/* virtualdom/items/Yielder.js */
	var Yielder = function( runloop, removeFromArray, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var Yielder = function( options ) {
			var componentInstance, component;
			componentInstance = options.parentFragment.root;
			this.component = component = componentInstance.component;
			this.surrogateParent = options.parentFragment;
			this.parentFragment = component.parentFragment;
			this.fragment = new Fragment( {
				owner: this,
				root: componentInstance.yield.instance,
				template: componentInstance.yield.template,
				pElement: this.surrogateParent.pElement
			} );
			component.yielders.push( this );
			runloop.scheduleTask( function() {
				if ( component.yielders.length > 1 ) {
					throw new Error( 'A component template can only have one {{yield}} declaration at a time' );
				}
			} );
		};
		Yielder.prototype = {
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			findNextNode: function() {
				return this.surrogateParent.findNextNode( this );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			getValue: function( options ) {
				return this.fragment.getValue( options );
			},
			render: function() {
				return this.fragment.render();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			unrender: function( shouldDestroy ) {
				this.fragment.unrender( shouldDestroy );
				removeFromArray( this.component.yielders, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		return Yielder;
	}( runloop, removeFromArray, circular );

	/* virtualdom/Fragment/prototype/init/createItem.js */
	var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {

		return function createItem( options ) {
			if ( typeof options.template === 'string' ) {
				return new Text( options );
			}
			switch ( options.template.t ) {
				case types.INTERPOLATOR:
					if ( options.template.r === 'yield' ) {
						return new Yielder( options );
					}
					return new Interpolator( options );
				case types.SECTION:
					return new Section( options );
				case types.TRIPLE:
					return new Triple( options );
				case types.ELEMENT:
					var constructor;
					if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
						return new Component( options, constructor );
					}
					return new Element( options );
				case types.PARTIAL:
					return new Partial( options );
				case types.COMMENT:
					return new Comment( options );
				default:
					throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
			}
		};
	}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );

	/* virtualdom/Fragment/prototype/init.js */
	var virtualdom_Fragment$init = function( types, create, createItem ) {

		return function Fragment$init( options ) {
			var this$0 = this;
			var parentFragment, parentRefs, ref;
			// The item that owns this fragment - an element, section, partial, or attribute
			this.owner = options.owner;
			parentFragment = this.parent = this.owner.parentFragment;
			// inherited properties
			this.root = options.root;
			this.pElement = options.pElement;
			this.context = options.context;
			// If parent item is a section, this may not be the only fragment
			// that belongs to it - we need to make a note of the index
			if ( this.owner.type === types.SECTION ) {
				this.index = options.index;
			}
			// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
			// down the tree
			if ( parentFragment ) {
				parentRefs = parentFragment.indexRefs;
				if ( parentRefs ) {
					this.indexRefs = create( null );
					// avoids need for hasOwnProperty
					for ( ref in parentRefs ) {
						this.indexRefs[ ref ] = parentRefs[ ref ];
					}
				}
			}
			if ( options.indexRef ) {
				if ( !this.indexRefs ) {
					this.indexRefs = {};
				}
				this.indexRefs[ options.indexRef ] = options.index;
			}
			// Time to create this fragment's child items
			// TEMP should this be happening?
			if ( typeof options.template === 'string' ) {
				options.template = [ options.template ];
			} else if ( !options.template ) {
				options.template = [];
			}
			this.items = options.template.map( function( template, i ) {
				return createItem( {
					parentFragment: this$0,
					pElement: options.pElement,
					template: template,
					index: i
				} );
			} );
			this.value = this.argsList = null;
			this.dirtyArgs = this.dirtyValue = true;
			this.bound = true;
		};
	}( types, create, virtualdom_Fragment$init_createItem );

	/* virtualdom/Fragment/prototype/rebind.js */
	var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

		return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			this.index = newIndex;
			// assign new context keypath if needed
			assignNewKeypath( this, 'context', oldKeypath, newKeypath );
			if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
				this.indexRefs[ indexRef ] = newIndex;
			}
			this.items.forEach( function( item ) {
				if ( item.rebind ) {
					item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			} );
		};
	}( assignNewKeypath );

	/* virtualdom/Fragment/prototype/render.js */
	var virtualdom_Fragment$render = function Fragment$render() {
		var result;
		if ( this.items.length === 1 ) {
			result = this.items[ 0 ].render();
		} else {
			result = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				result.appendChild( item.render() );
			} );
		}
		this.rendered = true;
		return result;
	};

	/* virtualdom/Fragment/prototype/toString.js */
	var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
		if ( !this.items ) {
			return '';
		}
		return this.items.map( function( item ) {
			return item.toString( escape );
		} ).join( '' );
	};

	/* virtualdom/Fragment/prototype/unbind.js */
	var virtualdom_Fragment$unbind = function() {

		var __export;
		__export = function Fragment$unbind() {
			if ( !this.bound ) {
				return;
			}
			this.items.forEach( unbindItem );
			this.bound = false;
		};

		function unbindItem( item ) {
			if ( item.unbind ) {
				item.unbind();
			}
		}
		return __export;
	}();

	/* virtualdom/Fragment/prototype/unrender.js */
	var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
		if ( !this.rendered ) {
			throw new Error( 'Attempted to unrender a fragment that was not rendered' );
		}
		this.items.forEach( function( i ) {
			return i.unrender( shouldDestroy );
		} );
		this.rendered = false;
	};

	/* virtualdom/Fragment.js */
	var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

		var Fragment = function( options ) {
			this.init( options );
		};
		Fragment.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getNode: getNode,
			getValue: getValue,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		circular.Fragment = Fragment;
		return Fragment;
	}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

	/* Ractive/prototype/reset.js */
	var Ractive$reset = function( Hook, runloop, Fragment, config ) {

		var shouldRerender = [
				'template',
				'partials',
				'components',
				'decorators',
				'events'
			],
			resetHook = new Hook( 'reset' );
		return function Ractive$reset( data, callback ) {
			var promise, wrapper, changes, i, rerender;
			if ( typeof data === 'function' && !callback ) {
				callback = data;
				data = {};
			} else {
				data = data || {};
			}
			if ( typeof data !== 'object' ) {
				throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
			}
			// If the root object is wrapped, try and use the wrapper's reset value
			if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
				if ( wrapper.reset( data ) === false ) {
					// reset was rejected, we need to replace the object
					this.data = data;
				}
			} else {
				this.data = data;
			}
			// reset config items and track if need to rerender
			changes = config.reset( this );
			i = changes.length;
			while ( i-- ) {
				if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
					rerender = true;
					break;
				}
			}
			if ( rerender ) {
				var component;
				this.viewmodel.mark( '' );
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// If the template changed, we need to destroy the parallel DOM
				// TODO if we're here, presumably it did?
				if ( this.fragment.template !== this.template ) {
					this.fragment.unbind();
					this.fragment = new Fragment( {
						template: this.template,
						root: this,
						owner: this
					} );
				}
				promise = this.render( this.el, this.anchor );
			} else {
				promise = runloop.start( this, true );
				this.viewmodel.mark( '' );
				runloop.end();
			}
			resetHook.fire( this, data );
			if ( callback ) {
				promise.then( callback );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop, Fragment, config );

	/* Ractive/prototype/resetTemplate.js */
	var Ractive$resetTemplate = function( config, Fragment ) {

		return function Ractive$resetTemplate( template ) {
			var transitionsEnabled, component;
			config.template.init( null, this, {
				template: template
			} );
			transitionsEnabled = this.transitionsEnabled;
			this.transitionsEnabled = false;
			// Is this is a component, we need to set the `shouldDestroy`
			// flag, otherwise it will assume by default that a parent node
			// will be detached, and therefore it doesn't need to bother
			// detaching its own nodes
			if ( component = this.component ) {
				component.shouldDestroy = true;
			}
			this.unrender();
			if ( component ) {
				component.shouldDestroy = false;
			}
			// remove existing fragment and create new one
			this.fragment.unbind();
			this.fragment = new Fragment( {
				template: this.template,
				root: this,
				owner: this
			} );
			this.render( this.el, this.anchor );
			this.transitionsEnabled = transitionsEnabled;
		};
	}( config, Fragment );

	/* Ractive/prototype/reverse.js */
	var Ractive$reverse = function( makeArrayMethod ) {

		return makeArrayMethod( 'reverse' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/set.js */
	var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

		var wildcard = /\*/;
		return function Ractive$set( keypath, value, callback ) {
			var this$0 = this;
			var map, promise;
			promise = runloop.start( this, true );
			// Set multiple keypaths in one go
			if ( isObject( keypath ) ) {
				map = keypath;
				callback = value;
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						value = map[ keypath ];
						keypath = normaliseKeypath( keypath );
						this.viewmodel.set( keypath, value );
					}
				}
			} else {
				keypath = normaliseKeypath( keypath );
				if ( wildcard.test( keypath ) ) {
					getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
						this$0.viewmodel.set( keypath, value );
					} );
				} else {
					this.viewmodel.set( keypath, value );
				}
			}
			runloop.end();
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

	/* Ractive/prototype/shift.js */
	var Ractive$shift = function( makeArrayMethod ) {

		return makeArrayMethod( 'shift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/sort.js */
	var Ractive$sort = function( makeArrayMethod ) {

		return makeArrayMethod( 'sort' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/splice.js */
	var Ractive$splice = function( makeArrayMethod ) {

		return makeArrayMethod( 'splice' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/subtract.js */
	var Ractive$subtract = function( add ) {

		return function Ractive$subtract( keypath, d ) {
			return add( this, keypath, d === undefined ? -1 : -d );
		};
	}( Ractive$shared_add );

	/* Ractive/prototype/teardown.js */
	var Ractive$teardown = function( Hook, Promise, removeFromArray ) {

		var teardownHook = new Hook( 'teardown' );
		// Teardown. This goes through the root fragment and all its children, removing observers
		// and generally cleaning up after itself
		return function Ractive$teardown( callback ) {
			var promise;
			this.fragment.unbind();
			this.viewmodel.teardown();
			if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.shouldDestroy = true;
			promise = this.fragment.rendered ? this.unrender() : Promise.resolve();
			teardownHook.fire( this );
			if ( callback ) {
				// TODO deprecate this?
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, Promise, removeFromArray );

	/* Ractive/prototype/toggle.js */
	var Ractive$toggle = function( log ) {

		return function Ractive$toggle( keypath, callback ) {
			var value;
			if ( typeof keypath !== 'string' ) {
				log.errorOnly( {
					debug: this.debug,
					messsage: 'badArguments',
					arg: {
						arguments: keypath
					}
				} );
			}
			value = this.get( keypath );
			return this.set( keypath, !value, callback );
		};
	}( log );

	/* Ractive/prototype/toHTML.js */
	var Ractive$toHTML = function Ractive$toHTML() {
		return this.fragment.toString( true );
	};

	/* Ractive/prototype/unrender.js */
	var Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {

		var unrenderHook = new Hook( 'unrender' );
		return function Ractive$unrender() {
			var this$0 = this;
			var promise, shouldDestroy;
			if ( !this.fragment.rendered ) {
				log.warn( {
					debug: this.debug,
					message: 'ractive.unrender() was called on a Ractive instance that was not rendered'
				} );
				return Promise.resolve();
			}
			promise = runloop.start( this, true );
			// If this is a component, and the component isn't marked for destruction,
			// don't detach nodes from the DOM unnecessarily
			shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
			if ( this.constructor.css ) {
				promise.then( function() {
					css.remove( this$0.constructor );
				} );
			}
			// Cancel any animations in progress
			while ( this._animations[ 0 ] ) {
				this._animations[ 0 ].stop();
			}
			this.fragment.unrender( shouldDestroy );
			removeFromArray( this.el.__ractive_instances__, this );
			unrenderHook.fire( this );
			runloop.end();
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );

	/* Ractive/prototype/unshift.js */
	var Ractive$unshift = function( makeArrayMethod ) {

		return makeArrayMethod( 'unshift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/update.js */
	var Ractive$update = function( Hook, runloop ) {

		var updateHook = new Hook( 'update' );
		return function Ractive$update( keypath, callback ) {
			var promise;
			if ( typeof keypath === 'function' ) {
				callback = keypath;
				keypath = '';
			} else {
				keypath = keypath || '';
			}
			promise = runloop.start( this, true );
			this.viewmodel.mark( keypath );
			runloop.end();
			updateHook.fire( this, keypath );
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop );

	/* Ractive/prototype/updateModel.js */
	var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

		var __export;
		__export = function Ractive$updateModel( keypath, cascade ) {
			var values;
			if ( typeof keypath !== 'string' ) {
				keypath = '';
				cascade = true;
			}
			consolidateChangedValues( this, keypath, values = {}, cascade );
			return this.set( values );
		};

		function consolidateChangedValues( ractive, keypath, values, cascade ) {
			var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
			bindings = ractive._twowayBindings[ keypath ];
			if ( bindings && ( i = bindings.length ) ) {
				while ( i-- ) {
					binding = bindings[ i ];
					// special case - radio name bindings
					if ( binding.radioName && !binding.element.node.checked ) {
						continue;
					}
					// special case - checkbox name bindings come in groups, so
					// we want to get the value once at most
					if ( binding.checkboxName ) {
						if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
							checkboxGroups.push( binding.keypath );
							checkboxGroups[ binding.keypath ] = binding;
						}
						continue;
					}
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( arrayContentsMatch( oldValue, newValue ) ) {
						continue;
					}
					if ( !isEqual( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				}
			}
			// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
			if ( checkboxGroups.length ) {
				checkboxGroups.forEach( function( keypath ) {
					var binding, oldValue, newValue;
					binding = checkboxGroups[ keypath ];
					// one to represent the entire group
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( !arrayContentsMatch( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				} );
			}
			if ( !cascade ) {
				return;
			}
			// cascade
			childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
			if ( childDeps ) {
				i = childDeps.length;
				while ( i-- ) {
					consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
				}
			}
		}
		return __export;
	}( arrayContentsMatch, isEqual );

	/* Ractive/prototype.js */
	var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

		return {
			add: add,
			animate: animate,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			fire: fire,
			get: get,
			insert: insert,
			merge: merge,
			observe: observe,
			off: off,
			on: on,
			pop: pop,
			push: push,
			render: render,
			reset: reset,
			resetTemplate: resetTemplate,
			reverse: reverse,
			set: set,
			shift: shift,
			sort: sort,
			splice: splice,
			subtract: subtract,
			teardown: teardown,
			toggle: toggle,
			toHTML: toHTML,
			unrender: unrender,
			unshift: unshift,
			update: update,
			updateModel: updateModel
		};
	}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

	/* utils/getGuid.js */
	var getGuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
			var r, v;
			r = Math.random() * 16 | 0;
			v = c == 'x' ? r : r & 3 | 8;
			return v.toString( 16 );
		} );
	};

	/* utils/getNextNumber.js */
	var getNextNumber = function() {

		var i = 0;
		return function() {
			return 'r-' + i++;
		};
	}();

	/* Ractive/prototype/shared/hooks/HookQueue.js */
	var Ractive$shared_hooks_HookQueue = function( Hook ) {

		function HookQueue( event ) {
			this.hook = new Hook( event );
			this.inProcess = {};
			this.queue = {};
		}
		HookQueue.prototype = {
			constructor: HookQueue,
			begin: function( ractive ) {
				this.inProcess[ ractive._guid ] = true;
			},
			end: function( ractive ) {
				var parent = ractive._parent;
				// If this is *isn't* a child of a component that's in process,
				// it should call methods or fire at this point
				if ( !parent || !this.inProcess[ parent._guid ] ) {
					fire( this, ractive );
				} else {
					getChildQueue( this.queue, parent ).push( ractive );
				}
				delete this.inProcess[ ractive._guid ];
			}
		};

		function getChildQueue( queue, ractive ) {
			return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
		}

		function fire( hookQueue, ractive ) {
			var childQueue = getChildQueue( hookQueue.queue, ractive );
			hookQueue.hook.fire( ractive );
			// queue is "live" because components can end up being
			// added while hooks fire on parents that modify data values.
			while ( childQueue.length ) {
				fire( hookQueue, childQueue.shift() );
			}
			delete hookQueue.queue[ ractive._guid ];
		}
		return HookQueue;
	}( Ractive$shared_hooks_Hook );

	/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
	var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {
		var root = wrapper.root,
			keypath = wrapper.keypath;
		// If this is a sort or reverse, we just do root.set()...
		// TODO use merge logic?
		if ( methodName === 'sort' || methodName === 'reverse' ) {
			root.viewmodel.set( keypath, array );
			return;
		}
		root.viewmodel.smartUpdate( keypath, array, newIndices );
	};

	/* viewmodel/prototype/get/arrayAdaptor/patch.js */
	var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {

		var patchedArrayProto = [],
			mutatorMethods = [
				'pop',
				'push',
				'reverse',
				'shift',
				'sort',
				'splice',
				'unshift'
			],
			testObj, patchArrayMethods, unpatchArrayMethods;
		mutatorMethods.forEach( function( methodName ) {
			var method = function() {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 0 );
				var newIndices, result, wrapper, i;
				newIndices = getNewIndices( this, methodName, args );
				// apply the underlying method
				result = Array.prototype[ methodName ].apply( this, arguments );
				// trigger changes
				runloop.start();
				this._ractive.setting = true;
				i = this._ractive.wrappers.length;
				while ( i-- ) {
					wrapper = this._ractive.wrappers[ i ];
					runloop.addViewmodel( wrapper.root.viewmodel );
					processWrapper( wrapper, this, methodName, newIndices );
				}
				runloop.end();
				this._ractive.setting = false;
				return result;
			};
			defineProperty( patchedArrayProto, methodName, {
				value: method
			} );
		} );
		// can we use prototype chain injection?
		// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
		testObj = {};
		if ( testObj.__proto__ ) {
			// yes, we can
			patchArrayMethods = function( array ) {
				array.__proto__ = patchedArrayProto;
			};
			unpatchArrayMethods = function( array ) {
				array.__proto__ = Array.prototype;
			};
		} else {
			// no, we can't
			patchArrayMethods = function( array ) {
				var i, methodName;
				i = mutatorMethods.length;
				while ( i-- ) {
					methodName = mutatorMethods[ i ];
					defineProperty( array, methodName, {
						value: patchedArrayProto[ methodName ],
						configurable: true
					} );
				}
			};
			unpatchArrayMethods = function( array ) {
				var i;
				i = mutatorMethods.length;
				while ( i-- ) {
					delete array[ mutatorMethods[ i ] ];
				}
			};
		}
		patchArrayMethods.unpatch = unpatchArrayMethods;
		return patchArrayMethods;
	}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );

	/* viewmodel/prototype/get/arrayAdaptor.js */
	var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

		var arrayAdaptor,
			// helpers
			ArrayWrapper, errorMessage;
		arrayAdaptor = {
			filter: function( object ) {
				// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
				// or the array didn't trigger the get() itself
				return isArray( object ) && ( !object._ractive || !object._ractive.setting );
			},
			wrap: function( ractive, array, keypath ) {
				return new ArrayWrapper( ractive, array, keypath );
			}
		};
		ArrayWrapper = function( ractive, array, keypath ) {
			this.root = ractive;
			this.value = array;
			this.keypath = keypath;
			// if this array hasn't already been ractified, ractify it
			if ( !array._ractive ) {
				// define a non-enumerable _ractive property to store the wrappers
				defineProperty( array, '_ractive', {
					value: {
						wrappers: [],
						instances: [],
						setting: false
					},
					configurable: true
				} );
				patch( array );
			}
			// store the ractive instance, so we can handle transitions later
			if ( !array._ractive.instances[ ractive._guid ] ) {
				array._ractive.instances[ ractive._guid ] = 0;
				array._ractive.instances.push( ractive );
			}
			array._ractive.instances[ ractive._guid ] += 1;
			array._ractive.wrappers.push( this );
		};
		ArrayWrapper.prototype = {
			get: function() {
				return this.value;
			},
			teardown: function() {
				var array, storage, wrappers, instances, index;
				array = this.value;
				storage = array._ractive;
				wrappers = storage.wrappers;
				instances = storage.instances;
				// if teardown() was invoked because we're clearing the cache as a result of
				// a change that the array itself triggered, we can save ourselves the teardown
				// and immediate setup
				if ( storage.setting ) {
					return false;
				}
				index = wrappers.indexOf( this );
				if ( index === -1 ) {
					throw new Error( errorMessage );
				}
				wrappers.splice( index, 1 );
				// if nothing else depends on this array, we can revert it to its
				// natural state
				if ( !wrappers.length ) {
					delete array._ractive;
					patch.unpatch( this.value );
				} else {
					// remove ractive instance if possible
					instances[ this.root._guid ] -= 1;
					if ( !instances[ this.root._guid ] ) {
						index = instances.indexOf( this.root );
						if ( index === -1 ) {
							throw new Error( errorMessage );
						}
						instances.splice( index, 1 );
					}
				}
			}
		};
		errorMessage = 'Something went wrong in a rather interesting way';
		return arrayAdaptor;
	}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

	/* viewmodel/prototype/get/magicArrayAdaptor.js */
	var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

		var magicArrayAdaptor, MagicArrayWrapper;
		if ( magicAdaptor ) {
			magicArrayAdaptor = {
				filter: function( object, keypath, ractive ) {
					return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
				},
				wrap: function( ractive, array, keypath ) {
					return new MagicArrayWrapper( ractive, array, keypath );
				}
			};
			MagicArrayWrapper = function( ractive, array, keypath ) {
				this.value = array;
				this.magic = true;
				this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
				this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
			};
			MagicArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					this.arrayWrapper.teardown();
					this.magicWrapper.teardown();
				},
				reset: function( value ) {
					return this.magicWrapper.reset( value );
				}
			};
		}
		return magicArrayAdaptor;
	}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

	/* viewmodel/prototype/adapt.js */
	var viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {

		var __export;
		var prefixers = {};
		__export = function Viewmodel$adapt( keypath, value ) {
			var ractive = this.ractive,
				len, i, adaptor, wrapped;
			// Do we have an adaptor for this value?
			len = ractive.adapt.length;
			for ( i = 0; i < len; i += 1 ) {
				adaptor = ractive.adapt[ i ];
				// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
				// we need to get the actual adaptor if that's the case
				if ( typeof adaptor === 'string' ) {
					var found = config.registries.adaptors.find( ractive, adaptor );
					if ( !found ) {
						// will throw. "return" for safety, if we downgrade :)
						return log.critical( {
							debug: ractive.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'adaptor',
								name: adaptor
							}
						} );
					}
					adaptor = ractive.adapt[ i ] = found;
				}
				if ( adaptor.filter( value, keypath, ractive ) ) {
					wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
					wrapped.value = value;
					return value;
				}
			}
			if ( ractive.magic ) {
				if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
				} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
				}
			} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
				this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
			}
			return value;
		};

		function prefixKeypath( obj, prefix ) {
			var prefixed = {},
				key;
			if ( !prefix ) {
				return obj;
			}
			prefix += '.';
			for ( key in obj ) {
				if ( obj.hasOwnProperty( key ) ) {
					prefixed[ prefix + key ] = obj[ key ];
				}
			}
			return prefixed;
		}

		function getPrefixer( rootKeypath ) {
			var rootDot;
			if ( !prefixers[ rootKeypath ] ) {
				rootDot = rootKeypath ? rootKeypath + '.' : '';
				prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
					var obj;
					if ( typeof relativeKeypath === 'string' ) {
						obj = {};
						obj[ rootDot + relativeKeypath ] = value;
						return obj;
					}
					if ( typeof relativeKeypath === 'object' ) {
						// 'relativeKeypath' is in fact a hash, not a keypath
						return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
					}
				};
			}
			return prefixers[ rootKeypath ];
		}
		return __export;
	}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

	/* viewmodel/helpers/getUpstreamChanges.js */
	var getUpstreamChanges = function getUpstreamChanges( changes ) {
		var upstreamChanges = [ '' ],
			i, keypath, keys, upstreamKeypath;
		i = changes.length;
		while ( i-- ) {
			keypath = changes[ i ];
			keys = keypath.split( '.' );
			while ( keys.length > 1 ) {
				keys.pop();
				upstreamKeypath = keys.join( '.' );
				if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
					upstreamChanges.push( upstreamKeypath );
				}
			}
		}
		return upstreamChanges;
	};

	/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
	var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, result;
			keys = keypath.split( '.' );
			starMap = getStarMap( keys.length );
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			result = starMap.map( function( mask ) {
				return mask.map( mapper ).join( '.' );
			} );
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( length ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ length ] ) {
				starMap = [];
				while ( ones.length < length ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < length ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ length ] = starMap;
			}
			return starMaps[ length ];
		}
		return __export;
	}();

	/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
	var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

		var __export;
		var lastKey = /[^\.]+$/;
		__export = notifyPatternObservers;

		function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
			var potentialWildcardMatches;
			updateMatchingPatternObservers( viewmodel, keypath );
			if ( onlyDirect ) {
				return;
			}
			potentialWildcardMatches = getPotentialWildcardMatches( keypath );
			potentialWildcardMatches.forEach( function( upstreamPattern ) {
				cascade( viewmodel, upstreamPattern, keypath );
			} );
		}

		function cascade( viewmodel, upstreamPattern, keypath ) {
			var group, map, actualChildKeypath;
			group = viewmodel.depsMap.patternObservers;
			map = group[ upstreamPattern ];
			if ( map ) {
				map.forEach( function( childKeypath ) {
					var key = lastKey.exec( childKeypath )[ 0 ];
					// 'baz'
					actualChildKeypath = keypath ? keypath + '.' + key : key;
					// 'foo.bar.baz'
					updateMatchingPatternObservers( viewmodel, actualChildKeypath );
					cascade( viewmodel, childKeypath, actualChildKeypath );
				} );
			}
		}

		function updateMatchingPatternObservers( viewmodel, keypath ) {
			viewmodel.patternObservers.forEach( function( observer ) {
				if ( observer.regex.test( keypath ) ) {
					observer.update( keypath );
				}
			} );
		}
		return __export;
	}( viewmodel$applyChanges_getPotentialWildcardMatches );

	/* viewmodel/prototype/applyChanges.js */
	var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

		var __export;
		__export = function Viewmodel$applyChanges() {
			var this$0 = this;
			var self = this,
				changes, upstreamChanges, hash = {};
			changes = this.changes;
			if ( !changes.length ) {
				// TODO we end up here on initial render. Perhaps we shouldn't?
				return;
			}

			function cascade( keypath ) {
				var map, dependants, keys;
				if ( self.noCascade.hasOwnProperty( keypath ) ) {
					return;
				}
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
				if ( map = self.depsMap.computed[ keypath ] ) {
					map.forEach( cascade );
				}
			}

			function mark( keypath ) {
				self.mark( keypath );
			}
			changes.forEach( cascade );
			upstreamChanges = getUpstreamChanges( changes );
			upstreamChanges.forEach( function( keypath ) {
				var dependants, keys;
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
			} );
			this.changes = [];
			// Pattern observers are a weird special case
			if ( this.patternObservers.length ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath, true );
				} );
				changes.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath );
				} );
			}
			if ( this.deps.observers ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, null, keypath, 'observers' );
				} );
				notifyAllDependants( this, changes, 'observers' );
			}
			if ( this.deps[ 'default' ] ) {
				var bindings = [];
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, bindings, keypath, 'default' );
				} );
				if ( bindings.length ) {
					notifyBindings( this, bindings, changes );
				}
				notifyAllDependants( this, changes, 'default' );
			}
			// Return a hash of keypaths to updated values
			changes.forEach( function( keypath ) {
				hash[ keypath ] = this$0.get( keypath );
			} );
			this.implicitChanges = {};
			this.noCascade = {};
			return hash;
		};

		function invalidate( computation ) {
			computation.invalidate();
		}

		function getKey( computation ) {
			return computation.key;
		}

		function notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {
			var dependants, value;
			if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
				value = viewmodel.get( keypath );
				dependants.forEach( function( d ) {
					// don't "set" the parent value, refine it
					// i.e. not data = value, but data[foo] = fooValue
					if ( bindings && d.refineValue ) {
						bindings.push( d );
					} else {
						d.setValue( value );
					}
				} );
			}
		}

		function notifyBindings( viewmodel, bindings, changes ) {
			bindings.forEach( function( binding ) {
				var useSet = false,
					i = 0,
					length = changes.length,
					refinements = [];
				while ( i < length ) {
					var keypath = changes[ i ];
					if ( keypath === binding.keypath ) {
						useSet = true;
						break;
					}
					if ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {
						refinements.push( keypath );
					}
					i++;
				}
				if ( useSet ) {
					binding.setValue( viewmodel.get( binding.keypath ) );
				}
				if ( refinements.length ) {
					binding.refineValue( refinements );
				}
			} );
		}

		function notifyAllDependants( viewmodel, keypaths, groupName ) {
			var queue = [];
			addKeypaths( keypaths );
			queue.forEach( dispatch );

			function addKeypaths( keypaths ) {
				keypaths.forEach( addKeypath );
				keypaths.forEach( cascade );
			}

			function addKeypath( keypath ) {
				var deps = findDependants( viewmodel, keypath, groupName );
				if ( deps ) {
					queue.push( {
						keypath: keypath,
						deps: deps
					} );
				}
			}

			function cascade( keypath ) {
				var childDeps;
				if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
					addKeypaths( childDeps );
				}
			}

			function dispatch( set ) {
				var value = viewmodel.get( set.keypath );
				set.deps.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function findDependants( viewmodel, keypath, groupName ) {
			var group = viewmodel.deps[ groupName ];
			return group ? group[ keypath ] : null;
		}
		return __export;
	}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

	/* viewmodel/prototype/capture.js */
	var viewmodel$capture = function Viewmodel$capture() {
		this.captureGroups.push( [] );
	};

	/* viewmodel/prototype/clearCache.js */
	var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
		var cacheMap, wrapper;
		if ( !dontTeardownWrapper ) {
			// Is there a wrapped property at this keypath?
			if ( wrapper = this.wrapped[ keypath ] ) {
				// Did we unwrap it?
				if ( wrapper.teardown() !== false ) {
					// Is this right?
					// What's the meaning of returning false from teardown?
					// Could there be a GC ramification if this is a "real" ractive.teardown()?
					this.wrapped[ keypath ] = null;
				}
			}
		}
		this.cache[ keypath ] = undefined;
		if ( cacheMap = this.cacheMap[ keypath ] ) {
			while ( cacheMap.length ) {
				this.clearCache( cacheMap.pop() );
			}
		}
	};

	/* viewmodel/Computation/getComputationSignature.js */
	var getComputationSignature = function() {

		var __export;
		var pattern = /\$\{([^\}]+)\}/g;
		__export = function( signature ) {
			if ( typeof signature === 'function' ) {
				return {
					get: signature
				};
			}
			if ( typeof signature === 'string' ) {
				return {
					get: createFunctionFromString( signature )
				};
			}
			if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
				signature = {
					get: createFunctionFromString( signature.get ),
					set: signature.set
				};
			}
			return signature;
		};

		function createFunctionFromString( signature ) {
			var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
				return '__ractive.get("' + keypath + '")';
			} ) + ')';
			return new Function( functionBody );
		}
		return __export;
	}();

	/* viewmodel/Computation/Computation.js */
	var Computation = function( log, isEqual ) {

		var Computation = function( ractive, key, signature ) {
			var this$0 = this;
			this.ractive = ractive;
			this.viewmodel = ractive.viewmodel;
			this.key = key;
			this.getter = signature.get;
			this.setter = signature.set;
			this.hardDeps = signature.deps || [];
			this.softDeps = [];
			this.depValues = {};
			if ( this.hardDeps ) {
				this.hardDeps.forEach( function( d ) {
					return ractive.viewmodel.register( d, this$0, 'computed' );
				} );
			}
			this._dirty = this._firstRun = true;
		};
		Computation.prototype = {
			constructor: Computation,
			init: function() {
				var initial;
				this.bypass = true;
				initial = this.ractive.viewmodel.get( this.key );
				this.ractive.viewmodel.clearCache( this.key );
				this.bypass = false;
				if ( this.setter && initial !== undefined ) {
					this.set( initial );
				}
			},
			invalidate: function() {
				this._dirty = true;
			},
			get: function() {
				var this$0 = this;
				var ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;
				if ( this.getting ) {
					// prevent double-computation (e.g. caused by array mutation inside computation)
					return;
				}
				this.getting = true;
				if ( this._dirty ) {
					ractive = this.ractive;
					// determine whether the inputs have changed, in case this depends on
					// other computed values
					if ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {
						dependencyValuesChanged = true;
					} else {
						[
							this.hardDeps,
							this.softDeps
						].forEach( function( deps ) {
							var keypath, value, i;
							if ( dependencyValuesChanged ) {
								return;
							}
							i = deps.length;
							while ( i-- ) {
								keypath = deps[ i ];
								value = ractive.viewmodel.get( keypath );
								if ( !isEqual( value, this$0.depValues[ keypath ] ) ) {
									this$0.depValues[ keypath ] = value;
									dependencyValuesChanged = true;
									return;
								}
							}
						} );
					}
					if ( dependencyValuesChanged ) {
						ractive.viewmodel.capture();
						try {
							this.value = this.getter.call( ractive );
						} catch ( err ) {
							log.warn( {
								debug: ractive.debug,
								message: 'failedComputation',
								args: {
									key: this.key,
									err: err.message || err
								}
							} );
							this.value = void 0;
						}
						newDeps = ractive.viewmodel.release();
						dependenciesChanged = this.updateDependencies( newDeps );
						if ( dependenciesChanged ) {
							[
								this.hardDeps,
								this.softDeps
							].forEach( function( deps ) {
								deps.forEach( function( keypath ) {
									this$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );
								} );
							} );
						}
					}
					this._dirty = false;
				}
				this.getting = this._firstRun = false;
				return this.value;
			},
			set: function( value ) {
				if ( this.setting ) {
					this.value = value;
					return;
				}
				if ( !this.setter ) {
					throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
				}
				this.setter.call( this.ractive, value );
			},
			updateDependencies: function( newDeps ) {
				var i, oldDeps, keypath, dependenciesChanged;
				oldDeps = this.softDeps;
				// remove dependencies that are no longer used
				i = oldDeps.length;
				while ( i-- ) {
					keypath = oldDeps[ i ];
					if ( newDeps.indexOf( keypath ) === -1 ) {
						dependenciesChanged = true;
						this.viewmodel.unregister( keypath, this, 'computed' );
					}
				}
				// create references for any new dependencies
				i = newDeps.length;
				while ( i-- ) {
					keypath = newDeps[ i ];
					if ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {
						dependenciesChanged = true;
						this.viewmodel.register( keypath, this, 'computed' );
					}
				}
				if ( dependenciesChanged ) {
					this.softDeps = newDeps.slice();
				}
				return dependenciesChanged;
			}
		};
		return Computation;
	}( log, isEqual );

	/* viewmodel/prototype/compute.js */
	var viewmodel$compute = function( getComputationSignature, Computation ) {

		return function Viewmodel$compute( key, signature ) {
			signature = getComputationSignature( signature );
			return this.computations[ key ] = new Computation( this.ractive, key, signature );
		};
	}( getComputationSignature, Computation );

	/* viewmodel/prototype/get/FAILED_LOOKUP.js */
	var viewmodel$get_FAILED_LOOKUP = {
		FAILED_LOOKUP: true
	};

	/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
	var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

		var empty = {};
		var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
			this.viewmodel = viewmodel;
			this.root = viewmodel.ractive;
			// TODO eliminate this
			this.ref = keypath;
			this.parentFragment = empty;
			viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
			viewmodel.unresolvedImplicitDependencies.push( this );
			runloop.addUnresolved( this );
		};
		UnresolvedImplicitDependency.prototype = {
			resolve: function() {
				this.viewmodel.mark( this.ref );
				this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
				removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
			},
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return UnresolvedImplicitDependency;
	}( removeFromArray, runloop );

	/* viewmodel/prototype/get.js */
	var viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {

		var __export;
		var empty = {};
		__export = function Viewmodel$get( keypath ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = empty;
			var ractive = this.ractive,
				cache = this.cache,
				value, computation, wrapped, captureGroup;
			if ( keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				return isNumeric( value ) ? +value : value;
			}
			if ( cache[ keypath ] === undefined ) {
				// Is this a computed property?
				if ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {
					value = computation.get();
					this.adapt( keypath, value );
				} else if ( wrapped = this.wrapped[ keypath ] ) {
					value = wrapped.value;
				} else if ( !keypath ) {
					this.adapt( '', ractive.data );
					value = ractive.data;
				} else {
					value = retrieve( this, keypath );
				}
				cache[ keypath ] = value;
			} else {
				value = cache[ keypath ];
			}
			if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
				value = wrapped.get();
			}
			// capture the keypath, if we're inside a computation
			if ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {
				if ( !~captureGroup.indexOf( keypath ) ) {
					captureGroup.push( keypath );
					// if we couldn't resolve the keypath, we need to make it as a failed
					// lookup, so that the computation updates correctly once we CAN
					// resolve the keypath
					if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
						new UnresolvedImplicitDependency( this, keypath );
					}
				}
			}
			return value === FAILED_LOOKUP ? void 0 : value;
		};

		function retrieve( viewmodel, keypath ) {
			var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
			keys = keypath.split( '.' );
			key = keys.pop();
			parentKeypath = keys.join( '.' );
			parentValue = viewmodel.get( parentKeypath );
			if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
				parentValue = wrapped.get();
			}
			if ( parentValue === null || parentValue === undefined ) {
				return;
			}
			// update cache map
			if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
				viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
			} else {
				if ( cacheMap.indexOf( keypath ) === -1 ) {
					cacheMap.push( keypath );
				}
			}
			// If this property doesn't exist, we return a sentinel value
			// so that we know to query parent scope (if such there be)
			if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
				return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
			}
			value = parentValue[ key ];
			// Do we have an adaptor for this value?
			viewmodel.adapt( keypath, value, false );
			// Update cache
			viewmodel.cache[ keypath ] = value;
			return value;
		}
		return __export;
	}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

	/* viewmodel/prototype/init.js */
	var viewmodel$init = function() {

		var __export;
		__export = function Viewmodel$init() {
			var key, computation, computations = [];
			for ( key in this.ractive.computed ) {
				computation = this.compute( key, this.ractive.computed[ key ] );
				computations.push( computation );
			}
			computations.forEach( init );
		};

		function init( computation ) {
			computation.init();
		}
		return __export;
	}();

	/* viewmodel/prototype/mark.js */
	var viewmodel$mark = function Viewmodel$mark( keypath, options ) {
		var computation;
		// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
		// should not be picked up by pattern observers
		if ( options ) {
			if ( options.implicit ) {
				this.implicitChanges[ keypath ] = true;
			}
			if ( options.noCascade ) {
				this.noCascade[ keypath ] = true;
			}
		}
		if ( computation = this.computations[ keypath ] ) {
			computation.invalidate();
		}
		if ( this.changes.indexOf( keypath ) === -1 ) {
			this.changes.push( keypath );
		}
		this.clearCache( keypath );
	};

	/* viewmodel/prototype/merge/mapOldToNewIndex.js */
	var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
		var usedIndices, firstUnusedIndex, newIndices, changed;
		usedIndices = {};
		firstUnusedIndex = 0;
		newIndices = oldArray.map( function( item, i ) {
			var index, start, len;
			start = firstUnusedIndex;
			len = newArray.length;
			do {
				index = newArray.indexOf( item, start );
				if ( index === -1 ) {
					changed = true;
					return -1;
				}
				start = index + 1;
			} while ( usedIndices[ index ] && start < len );
			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			if ( index !== i ) {
				changed = true;
			}
			usedIndices[ index ] = true;
			return index;
		} );
		return newIndices;
	};

	/* viewmodel/prototype/merge.js */
	var viewmodel$merge = function( warn, mapOldToNewIndex ) {

		var __export;
		var comparators = {};
		__export = function Viewmodel$merge( keypath, currentArray, array, options ) {
			var oldArray, newArray, comparator, newIndices;
			this.mark( keypath );
			if ( options && options.compare ) {
				comparator = getComparatorFunction( options.compare );
				try {
					oldArray = currentArray.map( comparator );
					newArray = array.map( comparator );
				} catch ( err ) {
					// fallback to an identity check - worst case scenario we have
					// to do more DOM manipulation than we thought...
					// ...unless we're in debug mode of course
					if ( this.debug ) {
						throw err;
					} else {
						warn( 'Merge operation: comparison failed. Falling back to identity checking' );
					}
					oldArray = currentArray;
					newArray = array;
				}
			} else {
				oldArray = currentArray;
				newArray = array;
			}
			// find new indices for members of oldArray
			newIndices = mapOldToNewIndex( oldArray, newArray );
			this.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );
		};

		function stringify( item ) {
			return JSON.stringify( item );
		}

		function getComparatorFunction( comparator ) {
			// If `compare` is `true`, we use JSON.stringify to compare
			// objects that are the same shape, but non-identical - i.e.
			// { foo: 'bar' } !== { foo: 'bar' }
			if ( comparator === true ) {
				return stringify;
			}
			if ( typeof comparator === 'string' ) {
				if ( !comparators[ comparator ] ) {
					comparators[ comparator ] = function( item ) {
						return item[ comparator ];
					};
				}
				return comparators[ comparator ];
			}
			if ( typeof comparator === 'function' ) {
				return comparator;
			}
			throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
		}
		return __export;
	}( warn, viewmodel$merge_mapOldToNewIndex );

	/* viewmodel/prototype/register.js */
	var viewmodel$register = function() {

		var __export;
		__export = function Viewmodel$register( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var depsByKeypath, deps;
			if ( dependant.isStatic ) {
				return;
			}
			depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
			deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
			deps.push( dependant );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
				parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
				if ( parent[ keypath ] === undefined ) {
					parent[ keypath ] = 0;
					parent.push( keypath );
				}
				parent[ keypath ] += 1;
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/prototype/release.js */
	var viewmodel$release = function Viewmodel$release() {
		return this.captureGroups.pop();
	};

	/* viewmodel/prototype/set.js */
	var viewmodel$set = function( isEqual, createBranch ) {

		var __export;
		__export = function Viewmodel$set( keypath, value, silent ) {
			var computation, wrapper, dontTeardownWrapper;
			computation = this.computations[ keypath ];
			if ( computation ) {
				if ( computation.setting ) {
					// let the other computation set() handle things...
					return;
				}
				computation.set( value );
				value = computation.get();
			}
			if ( isEqual( this.cache[ keypath ], value ) ) {
				return;
			}
			wrapper = this.wrapped[ keypath ];
			// If we have a wrapper with a `reset()` method, we try and use it. If the
			// `reset()` method returns false, the wrapper should be torn down, and
			// (most likely) a new one should be created later
			if ( wrapper && wrapper.reset ) {
				dontTeardownWrapper = wrapper.reset( value ) !== false;
				if ( dontTeardownWrapper ) {
					value = wrapper.get();
				}
			}
			if ( !computation && !dontTeardownWrapper ) {
				resolveSet( this, keypath, value );
			}
			if ( !silent ) {
				this.mark( keypath );
			} else {
				// We're setting a parent of the original target keypath (i.e.
				// creating a fresh branch) - we need to clear the cache, but
				// not mark it as a change
				this.clearCache( keypath );
			}
		};

		function resolveSet( viewmodel, keypath, value ) {
			var keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;
			wrapperSet = function() {
				if ( wrapper.set ) {
					wrapper.set( lastKey, value );
				} else {
					parentValue = wrapper.get();
					valueSet();
				}
			};
			valueSet = function() {
				if ( !parentValue ) {
					parentValue = createBranch( lastKey );
					viewmodel.set( parentKeypath, parentValue, true );
				}
				parentValue[ lastKey ] = value;
			};
			keys = keypath.split( '.' );
			lastKey = keys.pop();
			parentKeypath = keys.join( '.' );
			wrapper = viewmodel.wrapped[ parentKeypath ];
			if ( wrapper ) {
				wrapperSet();
			} else {
				parentValue = viewmodel.get( parentKeypath );
				// may have been wrapped via the above .get()
				// call on viewmodel if this is first access via .set()!
				if ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {
					wrapperSet();
				} else {
					valueSet();
				}
			}
		}
		return __export;
	}( isEqual, createBranch );

	/* viewmodel/prototype/smartUpdate.js */
	var viewmodel$smartUpdate = function() {

		var __export;
		var implicitOption = {
				implicit: true
			},
			noCascadeOption = {
				noCascade: true
			};
		__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {
			var this$0 = this;
			var dependants, oldLength;
			oldLength = newIndices.length;
			// Indices that are being removed should be marked as dirty
			newIndices.forEach( function( newIndex, oldIndex ) {
				if ( newIndex === -1 ) {
					this$0.mark( keypath + '.' + oldIndex, noCascadeOption );
				}
			} );
			// Update the model
			// TODO allow existing array to be updated in place, rather than replaced?
			this.set( keypath, array, true );
			if ( dependants = this.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canShuffle ).forEach( function( d ) {
					return d.shuffle( newIndices, array );
				} );
			}
			if ( oldLength !== array.length ) {
				this.mark( keypath + '.length', implicitOption );
				for ( var i = oldLength; i < array.length; i += 1 ) {
					this.mark( keypath + '.' + i );
				}
				// don't allow removed indexes beyond end of new array to trigger recomputations
				for ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {
					this.mark( keypath + '.' + i$0, noCascadeOption );
				}
			}
		};

		function canShuffle( dependant ) {
			return typeof dependant.shuffle === 'function';
		}
		return __export;
	}();

	/* viewmodel/prototype/teardown.js */
	var viewmodel$teardown = function Viewmodel$teardown() {
		var this$0 = this;
		var unresolvedImplicitDependency;
		// Clear entire cache - this has the desired side-effect
		// of unwrapping adapted values (e.g. arrays)
		Object.keys( this.cache ).forEach( function( keypath ) {
			return this$0.clearCache( keypath );
		} );
		// Teardown any failed lookups - we don't need them to resolve any more
		while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
			unresolvedImplicitDependency.teardown();
		}
	};

	/* viewmodel/prototype/unregister.js */
	var viewmodel$unregister = function() {

		var __export;
		__export = function Viewmodel$unregister( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var deps, index;
			if ( dependant.isStatic ) {
				return;
			}
			deps = this.deps[ group ][ keypath ];
			index = deps.indexOf( dependant );
			if ( index === -1 ) {
				throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
			}
			deps.splice( index, 1 );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ];
				parent = map[ parentKeypath ];
				parent[ keypath ] -= 1;
				if ( !parent[ keypath ] ) {
					// remove from parent deps map
					parent.splice( parent.indexOf( keypath ), 1 );
					parent[ keypath ] = undefined;
				}
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/adaptConfig.js */
	var adaptConfig = function() {

		// should this be combined with prototype/adapt.js?
		var configure = {
			lookup: function( target, adaptors ) {
				var i, adapt = target.adapt;
				if ( !adapt || !adapt.length ) {
					return adapt;
				}
				if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
					while ( i-- ) {
						var adaptor = adapt[ i ];
						if ( typeof adaptor === 'string' ) {
							adapt[ i ] = adaptors[ adaptor ] || adaptor;
						}
					}
				}
				return adapt;
			},
			combine: function( parent, adapt ) {
				// normalize 'Foo' to [ 'Foo' ]
				parent = arrayIfString( parent );
				adapt = arrayIfString( adapt );
				// no parent? return adapt
				if ( !parent || !parent.length ) {
					return adapt;
				}
				// no adapt? return 'copy' of parent
				if ( !adapt || !adapt.length ) {
					return parent.slice();
				}
				// add parent adaptors to options
				parent.forEach( function( a ) {
					// don't put in duplicates
					if ( adapt.indexOf( a ) === -1 ) {
						adapt.push( a );
					}
				} );
				return adapt;
			}
		};

		function arrayIfString( adapt ) {
			if ( typeof adapt === 'string' ) {
				adapt = [ adapt ];
			}
			return adapt;
		}
		return configure;
	}();

	/* viewmodel/Viewmodel.js */
	var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {

		var noMagic;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
		} catch ( err ) {
			noMagic = true;
		}
		var Viewmodel = function( ractive ) {
			this.ractive = ractive;
			// TODO eventually, we shouldn't need this reference
			Viewmodel.extend( ractive.constructor, ractive );
			this.cache = {};
			// we need to be able to use hasOwnProperty, so can't inherit from null
			this.cacheMap = create( null );
			this.deps = {
				computed: {},
				'default': {}
			};
			this.depsMap = {
				computed: {},
				'default': {}
			};
			this.patternObservers = [];
			this.wrapped = create( null );
			this.computations = create( null );
			this.captureGroups = [];
			this.unresolvedImplicitDependencies = [];
			this.changes = [];
			this.implicitChanges = {};
			this.noCascade = {};
		};
		Viewmodel.extend = function( Parent, instance ) {
			if ( instance.magic && noMagic ) {
				throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
			}
			instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
			instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
		};
		Viewmodel.prototype = {
			adapt: adapt,
			applyChanges: applyChanges,
			capture: capture,
			clearCache: clearCache,
			compute: compute,
			get: get,
			init: init,
			mark: mark,
			merge: merge,
			register: register,
			release: release,
			set: set,
			smartUpdate: smartUpdate,
			teardown: teardown,
			unregister: unregister
		};
		return Viewmodel;
	}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );

	/* Ractive/initialise.js */
	var Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {

		var __export;
		var constructHook = new Hook( 'construct' ),
			configHook = new Hook( 'config' ),
			initHook = new HookQueue( 'init' );
		__export = function initialiseRactiveInstance( ractive ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var el;
			initialiseProperties( ractive, options );
			// make this option do what would be expected if someone
			// did include it on a new Ractive() or new Component() call.
			// Silly to do so (put a hook on the very options being used),
			// but handle it correctly, consistent with the intent.
			constructHook.fire( config.getConstructTarget( ractive, options ), options );
			// init config from Parent and options
			config.init( ractive.constructor, ractive, options );
			configHook.fire( ractive );
			// Teardown any existing instances *before* trying to set up the new one -
			// avoids certain weird bugs
			if ( el = getElement( ractive.el ) ) {
				if ( !ractive.append ) {
					if ( el.__ractive_instances__ ) {
						try {
							el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
								return r.teardown();
							} );
						} catch ( err ) {}
					}
					el.innerHTML = '';
				}
			}
			initHook.begin( ractive );
			// TEMPORARY. This is so we can implement Viewmodel gradually
			ractive.viewmodel = new Viewmodel( ractive );
			// hacky circular problem until we get this sorted out
			// if viewmodel immediately processes computed properties,
			// they may call ractive.get, which calls ractive.viewmodel,
			// which hasn't been set till line above finishes.
			ractive.viewmodel.init();
			// Render our *root fragment*
			if ( ractive.template ) {
				ractive.fragment = new Fragment( {
					template: ractive.template,
					root: ractive,
					owner: ractive
				} );
			}
			initHook.end( ractive );
			// render automatically ( if `el` is specified )
			if ( el ) {
				ractive.render( el, ractive.append );
			}
		};

		function initialiseProperties( ractive, options ) {
			// Generate a unique identifier, for places where you'd use a weak map if it
			// existed
			ractive._guid = getNextNumber();
			// events
			ractive._subs = create( null );
			// storage for item configuration from instantiation to reset,
			// like dynamic functions or original values
			ractive._config = {};
			// two-way bindings
			ractive._twowayBindings = create( null );
			// animations (so we can stop any in progress at teardown)
			ractive._animations = [];
			// nodes registry
			ractive.nodes = {};
			// live queries
			ractive._liveQueries = [];
			ractive._liveComponentQueries = [];
			// If this is a component, store a reference to the parent
			if ( options._parent && options._component ) {
				ractive._parent = options._parent;
				ractive.component = options._component;
				// And store a reference to the instance on the component
				options._component.instance = ractive;
			}
		}
		return __export;
	}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );

	/* extend/unwrapExtended.js */
	var unwrapExtended = function( wrap, config, circular ) {

		var __export;
		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		__export = function unwrapExtended( Child ) {
			if ( !( Child.prototype instanceof Ractive ) ) {
				return Child;
			}
			var options = {};
			while ( Child ) {
				config.registries.forEach( function( r ) {
					addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
				} );
				Object.keys( Child.prototype ).forEach( function( key ) {
					if ( key === 'computed' ) {
						return;
					}
					var value = Child.prototype[ key ];
					if ( !( key in options ) ) {
						options[ key ] = value._method ? value._method : value;
					} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
						var result, needsSuper = value._method;
						if ( needsSuper ) {
							value = value._method;
						}
						// rewrap bound directly to parent fn
						result = wrap( options[ key ]._method, value );
						if ( needsSuper ) {
							result._method = result;
						}
						options[ key ] = result;
					}
				} );
				if ( Child._parent !== Ractive ) {
					Child = Child._parent;
				} else {
					Child = false;
				}
			}
			return options;
		};

		function addRegistry( target, options, name ) {
			var registry, keys = Object.keys( target[ name ] );
			if ( !keys.length ) {
				return;
			}
			if ( !( registry = options[ name ] ) ) {
				registry = options[ name ] = {};
			}
			keys.filter( function( key ) {
				return !( key in registry );
			} ).forEach( function( key ) {
				return registry[ key ] = target[ name ][ key ];
			} );
		}
		return __export;
	}( wrapMethod, config, circular );

	/* extend/_extend.js */
	var Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {

		return function extend() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = {};
			var Parent = this,
				Child, proto, staticProperties;
			// if we're extending with another Ractive instance, inherit its
			// prototype methods and default options as well
			options = unwrap( options );
			// create Child constructor
			Child = function( options ) {
				initialise( this, options );
			};
			proto = create( Parent.prototype );
			proto.constructor = Child;
			staticProperties = {
				// each component needs a guid, for managing CSS etc
				_guid: {
					value: getGuid()
				},
				// alias prototype as defaults
				defaults: {
					value: proto
				},
				// extendable
				extend: {
					value: extend,
					writable: true,
					configurable: true
				},
				// Parent - for IE8, can't use Object.getPrototypeOf
				_parent: {
					value: Parent
				}
			};
			defineProperties( Child, staticProperties );
			// extend configuration
			config.extend( Parent, proto, options );
			Viewmodel.extend( Parent, proto );
			Child.prototype = proto;
			return Child;
		};
	}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );

	/* Ractive.js */
	var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

		var Ractive, properties;
		// Main Ractive required object
		Ractive = function( options ) {
			initialise( this, options );
		};
		// Ractive properties
		properties = {
			// static methods:
			extend: {
				value: extend
			},
			parse: {
				value: parse
			},
			// Namespaced constructors
			Promise: {
				value: Promise
			},
			// support
			svg: {
				value: svg
			},
			magic: {
				value: magic
			},
			// version
			VERSION: {
				value: '0.6.1'
			},
			// Plugins
			adaptors: {
				writable: true,
				value: {}
			},
			components: {
				writable: true,
				value: {}
			},
			decorators: {
				writable: true,
				value: {}
			},
			easing: {
				writable: true,
				value: easing
			},
			events: {
				writable: true,
				value: {}
			},
			interpolators: {
				writable: true,
				value: interpolators
			},
			partials: {
				writable: true,
				value: {}
			},
			transitions: {
				writable: true,
				value: {}
			}
		};
		// Ractive properties
		defineProperties( Ractive, properties );
		Ractive.prototype = extendObj( proto, defaults );
		Ractive.prototype.constructor = Ractive;
		// alias prototype as defaults
		Ractive.defaults = Ractive.prototype;
		// Certain modules have circular dependencies. If we were bundling a
		// module loader, e.g. almond.js, this wouldn't be a problem, but we're
		// not - we're using amdclean as part of the build process. Because of
		// this, we need to wait until all modules have loaded before those
		// circular dependencies can be required.
		circular.Ractive = Ractive;
		while ( circular.length ) {
			circular.pop()();
		}
		// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
		// older browsers, these are made available via a shim - here, we do a quick
		// pre-flight check to make sure that either a) we're not in a shit browser,
		// or b) we're using a Ractive-legacy.js build
		var FUNCTION = 'function';
		if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
			throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
		}
		return Ractive;
	}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


	// export as Common JS module...
	if ( typeof module !== "undefined" && module.exports ) {
		module.exports = Ractive;
	}

	// ... or as AMD module
	else if ( typeof define === "function" && define.amd ) {
		define( function() {
			return Ractive;
		} );
	}

	// ... or as browser global
	global.Ractive = Ractive;

	Ractive.noConflict = function() {
		global.Ractive = noConflict;
		return Ractive;
	};

}( typeof window !== 'undefined' ? window : this ) );

},{}]},{},["./source/js/app.coffee"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvYXBwLmNvZmZlZSIsIm5vZGVfbW9kdWxlcy9kYXQtZ3VpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5jb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9kYXQtZ3VpL3ZlbmRvci9kYXQuZ3VpLmpzIiwibm9kZV9tb2R1bGVzL2ZpcmViYXNlL2xpYi9maXJlYmFzZS13ZWIuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2FwcGVuZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2NvbGxlY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9jb21iaW5lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvY29tcGFjdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZGlmZmVyZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2VxdWFscy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2V2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ZpbmRMYXN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmluZExhc3RJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9mb3JFYWNoLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZ3JvdXBCeS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2luZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9pbnNlcnQuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9pbnRlcnNlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9pbnZva2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9qb2luLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvbGFzdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2xhc3RJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvbWFwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvbWF4LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvbWluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcGljay5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3BsdWNrLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9yZWR1Y2VSaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3JlamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3JlbW92ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3JlbW92ZUFsbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3NodWZmbGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9zbGljZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3NvbWUuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvc29ydEJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvc3BsaXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS90YWtlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvdG9Mb29rdXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS91bmlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3VuaXF1ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3hvci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3ppcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9ldmVyeS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9maW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9mb3JFYWNoLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9tYWtlXy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vbWFwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9tYXguanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL21pbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vcGx1Y2suanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL3JlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vcmVqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9zaXplLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9zb21lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvZGF5T2ZUaGVZZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9kaWZmLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9pMThuL2VuLVVTLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9pMThuXy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvaXNMZWFwWWVhci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvaXNTYW1lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9wYXJzZUlzby5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvcXVhcnRlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvc3RhcnRPZi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvc3RyZnRpbWUuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL3RpbWV6b25lQWJici5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvdGltZXpvbmVPZmZzZXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL3RvdGFsRGF5c0luTW9udGguanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL3RvdGFsRGF5c0luWWVhci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvd2Vla09mVGhlWWVhci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vYXdhaXREZWxheS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2JpbmQuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9jb21wb3NlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vY29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9kZWJvdW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2Z1bmMuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8uanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9wYXJ0aWFsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vcHJvcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL3Nlcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL3Rocm90dGxlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vdGltZW91dC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL3RpbWVzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vd3JhcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvR0xPQkFMLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvY3JlYXRlT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9jdG9yQXBwbHkuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2RlZXBDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvZGVlcEVxdWFscy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2luaGVyaXRQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNCb29sZWFuLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0RhdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzRW1wdHkuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzRmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0ludGVnZXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzS2luZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNOYU4uanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzTnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNOdW1iZXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc1ByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc1VuZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNudC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcva2luZE9mLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy90b0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy90b051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvdG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9jZWlsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9jbGFtcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvY291bnRTdGVwcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvZmxvb3IuanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL2luUmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL2lzTmVhci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvbGVycC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvbG9vcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvbWFwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9ub3JtLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9yb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9NQVhfSU5ULmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL01BWF9TQUZFX0lOVEVHRVIuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvTUFYX1VJTlQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvTUlOX0lOVC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9hYmJyZXZpYXRlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL2N1cnJlbmN5Rm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL2VuZm9yY2VQcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvaXNOYU4uanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvbnRoLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL29yZGluYWwuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvcGFkLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL3JvbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9yb3IuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci90b0ludC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci90b1VJbnQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvdG9VSW50MzEuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvYmluZEFsbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9jb250YWlucy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9kZWVwRmlsbEluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2RlZXBNYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2RlZXBNaXhJbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9lcXVhbHMuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZXZlcnkuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZmlsbEluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9maW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2ZvckluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2Zvck93bi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9oYXNPd24uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9tYXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9tYXguanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbWVyZ2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbWluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L21peEluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L25hbWVzcGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9vbWl0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3BpY2suanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvcGx1Y2suanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3JlamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9yZXN1bHQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3Qvc2V0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3NpemUuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3Qvc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC91bnNldC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC92YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3F1ZXJ5U3RyaW5nL2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvZ2V0UGFyYW0uanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9nZXRRdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3F1ZXJ5U3RyaW5nL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvc2V0UGFyYW0uanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20uanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vY2hvaWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL2d1aWQuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9yYW5kQml0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRCb29sLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRIZXguanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZEludC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9yYW5kU2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9yYW5kU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9XSElURV9TUEFDRVMuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvY2FtZWxDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2Nyb3AuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvZW5kc1dpdGguanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvZXNjYXBlSHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9lc2NhcGVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvZXNjYXBlVW5pY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9oeXBoZW5hdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvaW5zZXJ0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2ludGVycG9sYXRlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2xvd2VyQ2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9scGFkLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2x0cmltLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL21ha2VQYXRoLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL25vcm1hbGl6ZUxpbmVCcmVha3MuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcGFzY2FsQ2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9wcm9wZXJDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3JlbW92ZU5vbkFTQ0lJLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3JlbW92ZU5vbldvcmQuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3JlcGxhY2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVwbGFjZUFjY2VudHMuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcnBhZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9ydHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9zZW50ZW5jZUNhc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvc2x1Z2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9zdGFydHNXaXRoLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3N0cmlwSHRtbFRhZ3MuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvdHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy90cnVuY2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy90eXBlY2FzdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy91bkNhbWVsQ2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy91bmRlcnNjb3JlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3VuZXNjYXBlSHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy91bmVzY2FwZVVuaWNvZGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvdW5oeXBoZW5hdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvdXBwZXJDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3RpbWUvY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3RpbWUvbm93LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvdGltZS9wYXJzZU1zLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvdGltZS90b1RpbWVTdHJpbmcuanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvYXBwLWRlYnVnLmNvZmZlZSIsIi9Vc2Vycy9sdWtlLmhlZGdlci9kZXYvRXhwZXJpbWVudHMvMDQwNzE1L3NvdXJjZS9qcy9jb25maWcuY29mZmVlIiwiL1VzZXJzL2x1a2UuaGVkZ2VyL2Rldi9FeHBlcmltZW50cy8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9hYnN0cmFjdC1tb2R1bGUuY29mZmVlIiwiL1VzZXJzL2x1a2UuaGVkZ2VyL2Rldi9FeHBlcmltZW50cy8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9hYnN0cmFjdC1zY2VuZS5jb2ZmZWUiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL2luZGV4LmNvZmZlZSIsIi9Vc2Vycy9sdWtlLmhlZGdlci9kZXYvRXhwZXJpbWVudHMvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvbmF2LmNvZmZlZSIsIi9Vc2Vycy9sdWtlLmhlZGdlci9kZXYvRXhwZXJpbWVudHMvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvc2NlbmUtZGF5LmNvZmZlZSIsIi9Vc2Vycy9sdWtlLmhlZGdlci9kZXYvRXhwZXJpbWVudHMvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvc2NlbmUtZGlnZXN0LmNvZmZlZSIsIi9Vc2Vycy9sdWtlLmhlZGdlci9kZXYvRXhwZXJpbWVudHMvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvc2NlbmUtbmlnaHQuY29mZmVlIiwiL1VzZXJzL2x1a2UuaGVkZ2VyL2Rldi9FeHBlcmltZW50cy8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9zdGFnZS5jb2ZmZWUiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvdXRpbC9hZGRDbGFzcy5jb2ZmZWUiLCIvVXNlcnMvbHVrZS5oZWRnZXIvZGV2L0V4cGVyaW1lbnRzLzA0MDcxNS9zb3VyY2UvanMvdmlldy9tYWluLXZpZXcuY29mZmVlIiwic291cmNlL3RlbXBsYXRlL21haW4tdmlldy5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9hYnN0cmFjdC1zY2VuZS5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9uYXYuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvc2NlbmUtZGF5Lmh0bWwiLCJzb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLWRpZ2VzdC5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9zY2VuZS1uaWdodC5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9zdGFnZS5odG1sIiwic291cmNlL3RlbXBsYXRlL3BhcnRpYWxzL2Zhcm0uaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9wYXJ0aWFscy9zdGFnZS1jb250cm9scy5odG1sIiwidmVuZG9yL2RvbXJlYWR5L3JlYWR5LmpzIiwidmVuZG9yL2dzYXAvc3JjL3VuY29tcHJlc3NlZC9Ud2Vlbk1heC5qcyIsInZlbmRvci9oYW1tZXJqcy9oYW1tZXIuanMiLCJ2ZW5kb3IvcGFnZS9wYWdlLmpzIiwidmVuZG9yL3JhY3RpdmUtZXZlbnRzLXRhcC9yYWN0aXZlLWV2ZW50cy10YXAuanMiLCJ2ZW5kb3IvcmFjdGl2ZS10b3VjaC9pbmRleC5qcyIsInZlbmRvci9yYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUvcmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlLmpzIiwidmVuZG9yL3JhY3RpdmUtdHJhbnNpdGlvbnMtZmx5L3JhY3RpdmUtdHJhbnNpdGlvbnMtZmx5LmpzIiwidmVuZG9yL3JhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGUvcmFjdGl2ZS10cmFuc2l0aW9ucy1zbGlkZS5qcyIsInZlbmRvci9yYWN0aXZlL3JhY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNDQSxPQUFBLENBQVMsZ0JBQVQsQ0FBQSxDQUFBOztBQUFBLE9BR0EsQ0FBUyxNQUFULENBSEEsQ0FBQTs7QUFBQSxPQU1BLENBQVMsb0JBQVQsQ0FOQSxDQUFBOztBQUFBLE9BT0EsQ0FBUyxlQUFULENBUEEsQ0FBQTs7QUFBQSxPQVFBLENBQVMsMEJBQVQsQ0FSQSxDQUFBOztBQUFBLE9BU0EsQ0FBUyx5QkFBVCxDQVRBLENBQUE7O0FBQUEsT0FVQSxDQUFTLDJCQUFULENBVkEsQ0FBQTs7QUFBQSxPQWFBLENBQVMsVUFBVCxDQUFBLENBQW9CLFNBQUEsR0FBQTtBQUNuQixNQUFBLElBQUE7QUFBQSxFQUFBLElBQTRCLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBWixLQUF5QixhQUFyRDtBQUFBLElBQUEsT0FBQSxDQUFTLGFBQVQsQ0FBQSxDQUFBLENBQUEsQ0FBQTtHQUFBO0FBQUEsRUFFQSxJQUFBLEdBQU8sT0FBQSxDQUFTLGtCQUFULENBRlAsQ0FBQTtTQUdBLE1BQU0sQ0FBQyxLQUFQLEdBQW1CLElBQUEsSUFBQSxDQUFBLEVBSkE7QUFBQSxDQUFwQixDQWJBLENBQUE7Ozs7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNrSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQSxJQUFBLHVCQUFBOztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVMsU0FBVCxDQUFOLENBQUE7O0FBQUEsSUFDQSxHQUFPLE9BQUEsQ0FBUyxNQUFULENBRFAsQ0FBQTs7QUFBQSxHQUlBLEdBQU0sTUFBTSxDQUFDLElBQVAsR0FBa0IsSUFBQSxHQUFHLENBQUMsR0FBSixDQUFBLENBSnhCLENBQUE7O0FBQUEsT0FNQSxHQUNFO0FBQUEsRUFBQSxPQUFBLEVBQVEsS0FBUjtBQUFBLEVBQ0EsT0FBQSxFQUFRLFNBQUEsR0FBQTtXQUFHLElBQUEsQ0FBTSxHQUFOLEVBQUg7RUFBQSxDQURSO0FBQUEsRUFFQSxLQUFBLEVBQU0sU0FBQSxHQUFBO1dBQUcsSUFBQSxDQUFNLE1BQU4sRUFBSDtFQUFBLENBRk47QUFBQSxFQUdBLFFBQUEsRUFBUyxTQUFBLEdBQUE7V0FBRyxJQUFBLENBQU0sU0FBTixFQUFIO0VBQUEsQ0FIVDtBQUFBLEVBSUEsT0FBQSxFQUFRLFNBQUEsR0FBQTtXQUFHLElBQUEsQ0FBTSxRQUFOLEVBQUg7RUFBQSxDQUpSO0NBUEYsQ0FBQTs7QUFBQSxNQWFNLENBQUMsT0FBUCxHQUFpQixTQUFBLEdBQUE7QUFFaEIsTUFBQSxhQUFBO0FBQUEsRUFBQSxLQUFBLEdBQVEsR0FBRyxDQUFDLEdBQUosQ0FBUSxPQUFSLEVBQWtCLE9BQWxCLENBQVIsQ0FBQTtBQUFBLEVBR0EsTUFBQSxHQUFTLEdBQUcsQ0FBQyxTQUFKLENBQWUsWUFBZixDQUhULENBQUE7QUFBQSxFQUlBLE1BQU0sQ0FBQyxHQUFQLENBQVcsT0FBWCxFQUFxQixPQUFyQixDQUE0QixDQUFDLElBQTdCLENBQW1DLFFBQW5DLENBSkEsQ0FBQTtBQUFBLEVBS0EsTUFBTSxDQUFDLEdBQVAsQ0FBVyxPQUFYLEVBQXFCLEtBQXJCLENBQTBCLENBQUMsSUFBM0IsQ0FBaUMsTUFBakMsQ0FMQSxDQUFBO0FBQUEsRUFNQSxNQUFNLENBQUMsR0FBUCxDQUFXLE9BQVgsRUFBcUIsUUFBckIsQ0FBNkIsQ0FBQyxJQUE5QixDQUFvQyxTQUFwQyxDQU5BLENBQUE7QUFBQSxFQU9BLE1BQU0sQ0FBQyxHQUFQLENBQVcsT0FBWCxFQUFxQixPQUFyQixDQUE0QixDQUFDLElBQTdCLENBQW1DLFFBQW5DLENBUEEsQ0FBQTtTQVFBLE1BQU0sQ0FBQyxJQUFQLENBQUEsRUFWZ0I7QUFBQSxDQWJqQixDQUFBOzs7OztBQ0FBLE1BQU0sQ0FBQyxPQUFQLEdBRUk7QUFBQSxFQUFBLFFBQUEsRUFBVyxXQUFYO0NBRkosQ0FBQTs7Ozs7QUNBQSxJQUFBLE9BQUE7O0FBQUEsT0FBQSxHQUFVLE9BQUEsQ0FBUyxTQUFULENBQVYsQ0FBQTs7QUFBQSxNQUdNLENBQUMsT0FBUCxHQUFpQixPQUFPLENBQUMsTUFBUixDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLElBQVY7Q0FGZ0IsQ0FIakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxNQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVMsbUJBQVQsQ0FSVCxDQUFBOztBQUFBLE1BVU0sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFTLDRCQUFULENBQVY7QUFBQSxFQUVBLE1BQUEsRUFBUSxTQUFBLEdBQUEsQ0FGUjtDQUZnQixDQVZqQixDQUFBOzs7OztBQ0FBO0FBQUE7OztHQUFBO0FBQUEsSUFBQSxpQkFBQTs7QUFBQSxPQUlBLEdBQVUsT0FBQSxDQUFTLFNBQVQsQ0FKVixDQUFBOztBQUFBLFFBTUEsR0FBVyxTQUFBLEdBQUE7QUFDVixFQUFBLE9BQU8sQ0FBQyxVQUFZLENBQUEsbUJBQUEsQ0FBcEIsR0FBMEMsT0FBQSxDQUFTLGtCQUFULENBQTFDLENBQUE7QUFBQSxFQUNBLE9BQU8sQ0FBQyxVQUFZLENBQUEsUUFBQSxDQUFwQixHQUErQixPQUFBLENBQVMsT0FBVCxDQUQvQixDQUFBO0FBQUEsRUFFQSxPQUFPLENBQUMsVUFBWSxDQUFBLGNBQUEsQ0FBcEIsR0FBcUMsT0FBQSxDQUFTLGFBQVQsQ0FGckMsQ0FBQTtBQUFBLEVBR0EsT0FBTyxDQUFDLFVBQVksQ0FBQSxpQkFBQSxDQUFwQixHQUF3QyxPQUFBLENBQVMsZ0JBQVQsQ0FIeEMsQ0FBQTtBQUFBLEVBSUEsT0FBTyxDQUFDLFVBQVksQ0FBQSxnQkFBQSxDQUFwQixHQUF1QyxPQUFBLENBQVMsZUFBVCxDQUp2QyxDQUFBO0FBQUEsRUFLQSxPQUFPLENBQUMsVUFBWSxDQUFBLFVBQUEsQ0FBcEIsR0FBaUMsT0FBQSxDQUFTLFNBQVQsQ0FMakMsQ0FBQTtTQU9BLEtBUlU7QUFBQSxDQU5YLENBQUE7O0FBQUEsTUFnQk0sQ0FBQyxPQUFQLEdBQWlCLFFBQUEsQ0FBQSxDQWhCakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxZQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVMsbUJBQVQsQ0FSVCxDQUFBOztBQUFBLElBVUEsR0FBTyxPQUFBLENBQVMsTUFBVCxDQVZQLENBQUE7O0FBQUEsTUFZTSxDQUFDLE9BQVAsR0FBaUIsTUFBTSxDQUFDLE1BQVAsQ0FFaEI7QUFBQSxFQUFBLFFBQUEsRUFBVSxPQUFBLENBQVMsaUJBQVQsQ0FBVjtBQUFBLEVBRUEsTUFBQSxFQUFRLFNBQUEsR0FBQTtBQUVQLElBQUEsSUFBQyxDQUFBLEVBQUQsQ0FBSyxTQUFMLEVBQWUsU0FBQSxHQUFBO2FBQUcsSUFBQSxDQUFNLEdBQU4sRUFBSDtJQUFBLENBQWYsQ0FBQSxDQUFBO1dBQ0EsSUFBQyxDQUFBLEVBQUQsQ0FBSyxRQUFMLEVBQWMsU0FBQSxHQUFBO2FBQUcsSUFBQSxDQUFNLE9BQU4sRUFBSDtJQUFBLENBQWQsRUFITztFQUFBLENBRlI7Q0FGZ0IsQ0FaakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxNQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVMsa0JBQVQsQ0FSVCxDQUFBOztBQUFBLE1BV00sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFTLHVCQUFULENBQVY7QUFBQSxFQUVBLE1BQUEsRUFBUSxTQUFBLEdBQUE7V0FBRyxJQUFDLENBQUEsTUFBRCxDQUFBLEVBQUg7RUFBQSxDQUZSO0FBQUEsRUFJQSxRQUFBLEVBQVUsU0FBQSxHQUFBO0FBQ1QsUUFBQSxZQUFBO0FBQUEsSUFBQSxJQUFBLEdBQU8sSUFBQyxDQUFBLElBQUQsQ0FBTyxNQUFQLENBQVAsQ0FBQTtBQUFBLElBQ0EsTUFBQSxHQUFTLElBQUksQ0FBQyxjQUFMLENBQUEsQ0FEVCxDQUFBO1dBRUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxJQUFaLEVBQWtCLENBQWxCLEVBQXFCO0FBQUEsTUFBRSxLQUFBLEVBQU8sQ0FBVDtBQUFBLE1BQWEsbUJBQUEsRUFBb0IsTUFBakM7QUFBQSxNQUF5QyxJQUFBLEVBQUssTUFBTSxDQUFDLE9BQXJEO0tBQXJCLEVBSFM7RUFBQSxDQUpWO0NBRmdCLENBWGpCLENBQUE7Ozs7O0FDQUE7QUFBQTs7Ozs7R0FBQTtBQUFBLElBQUEsa0JBQUE7O0FBQUEsTUFRQSxHQUFTLE9BQUEsQ0FBUyxrQkFBVCxDQVJULENBQUE7O0FBQUEsSUFTQSxHQUFPLE9BQUEsQ0FBUyxNQUFULENBQWUsQ0FBQyxNQUFNLENBQUMsSUFUOUIsQ0FBQTs7QUFBQSxJQVVBLEdBQU8sT0FBQSxDQUFTLE1BQVQsQ0FBZSxDQUFDLEtBQUssQ0FBQyxJQVY3QixDQUFBOztBQUFBLE1BWU0sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFTLDBCQUFULENBQVY7QUFBQSxFQUVBLElBQUEsRUFDQztBQUFBLElBQUEsT0FBQSxFQUFTLENBQVQ7QUFBQSxJQUNBLENBQUEsRUFBRyxDQUFFLE1BQUYsRUFBVSxPQUFWLENBREg7QUFBQSxJQUVBLE1BQUEsRUFDQztBQUFBLE1BQUEsQ0FBQSxFQUNDO0FBQUEsUUFBQSxLQUFBLEVBQVEsU0FBUjtBQUFBLFFBQ0EsSUFBQSxFQUFPLGlCQURQO0FBQUEsUUFFQSxLQUFBLEVBQU8sQ0FBRSxHQUFGLEVBQU0sR0FBTixDQUZQO0FBQUEsUUFHQSxNQUFBLEVBQVEsS0FIUjtPQUREO0FBQUEsTUFLQSxDQUFBLEVBQ0M7QUFBQSxRQUFBLEtBQUEsRUFBUSxTQUFSO0FBQUEsUUFDQSxJQUFBLEVBQU8saUJBRFA7QUFBQSxRQUVBLE1BQUEsRUFBUSxLQUZSO09BTkQ7QUFBQSxNQVNBLENBQUEsRUFDQztBQUFBLFFBQUEsS0FBQSxFQUFRLFNBQVI7QUFBQSxRQUNBLElBQUEsRUFBTyxpQkFEUDtBQUFBLFFBRUEsTUFBQSxFQUFRLEtBRlI7T0FWRDtLQUhEO0dBSEQ7QUFBQSxFQW9CQSxNQUFBLEVBQVEsU0FBQSxHQUFBO1dBQUcsSUFBQyxDQUFBLE1BQUQsQ0FBQSxFQUFIO0VBQUEsQ0FwQlI7QUFBQSxFQXNCQSxVQUFBLEVBQVksU0FBQSxHQUFBO0FBQ1gsSUFBQSxJQUFDLENBQUEsU0FBRCxDQUFBLENBQUEsQ0FBQTtXQUVBLElBQUMsQ0FBQSxHQUFELENBQU0saUJBQU4sRUFBd0IsS0FBeEIsRUFIVztFQUFBLENBdEJaO0FBQUEsRUEyQkEsUUFBQSxFQUFVLFNBQUEsR0FBQTtBQUNULElBQUEsSUFBQyxDQUFBLEVBQUQsQ0FBSyxhQUFMLEVBQW1CLFNBQUEsR0FBQTthQUFHLElBQUMsQ0FBQSxTQUFELENBQUEsRUFBSDtJQUFBLENBQW5CLENBQUEsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLEVBQUQsQ0FBSyxhQUFMLEVBQW1CLFNBQUEsR0FBQTthQUFHLElBQUMsQ0FBQSxTQUFELENBQUEsRUFBSDtJQUFBLENBQW5CLENBREEsQ0FBQTtXQUdBLElBQUMsQ0FBQSxTQUFELENBQUEsRUFKUztFQUFBLENBM0JWO0FBQUEsRUFpQ0EsU0FBQSxFQUFXLFNBQUEsR0FBQTtBQUNWLFFBQUEsYUFBQTtBQUFBLElBQUEsT0FBQSxHQUFVLElBQUMsQ0FBQSxHQUFELENBQU0sU0FBTixDQUFWLENBQUE7QUFBQSxJQUNBLElBQUEsR0FBVSxPQUFBLEtBQVcsSUFBQSxDQUFLLElBQUMsQ0FBQSxHQUFELENBQU0sUUFBTixDQUFMLENBQW9CLENBQUMsTUFBbkMsR0FBK0MsQ0FBL0MsR0FBc0QsT0FBQSxJQUFTLENBRHRFLENBQUE7QUFFQSxJQUFBLElBQW9ELElBQUMsQ0FBQSxHQUFELENBQU0sU0FBTixDQUFBLEtBQXFCLENBQXpFO0FBQUEsTUFBQSxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQUEsR0FBUSxDQUFDLElBQUMsQ0FBQSxHQUFELENBQU0sU0FBTixDQUFELENBQVIsR0FBeUIsSUFBL0IsRUFBb0MsSUFBQyxDQUFBLEdBQUQsQ0FBTSxNQUFOLENBQXBDLENBQUEsQ0FBQTtLQUZBO0FBQUEsSUFHQSxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQUEsR0FBUyxJQUFULEdBQWMsSUFBcEIsRUFBeUIsSUFBQyxDQUFBLEdBQUQsQ0FBTSxNQUFOLENBQXpCLENBSEEsQ0FBQTtXQUlBLElBQUMsQ0FBQSxRQUFELENBQVUsSUFBVixFQUxVO0VBQUEsQ0FqQ1g7QUFBQSxFQXdDQSxTQUFBLEVBQVcsU0FBQSxHQUFBO0FBQ1YsUUFBQSxhQUFBO0FBQUEsSUFBQSxPQUFBLEdBQVUsSUFBQyxDQUFBLEdBQUQsQ0FBTSxTQUFOLENBQVYsQ0FBQTtBQUFBLElBQ0EsSUFBQSxHQUFVLE9BQUEsS0FBVyxDQUFkLEdBQXFCLElBQUEsQ0FBSyxJQUFDLENBQUEsR0FBRCxDQUFNLFFBQU4sQ0FBTCxDQUFvQixDQUFDLE1BQTFDLEdBQXNELE9BQUEsSUFBUyxDQUR0RSxDQUFBO0FBRUEsSUFBQSxJQUFvRCxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQU4sQ0FBQSxLQUFxQixDQUF6RTtBQUFBLE1BQUEsSUFBQyxDQUFBLEdBQUQsQ0FBTSxTQUFBLEdBQVEsQ0FBQyxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQU4sQ0FBRCxDQUFSLEdBQXlCLElBQS9CLEVBQW9DLElBQUMsQ0FBQSxHQUFELENBQU0sTUFBTixDQUFwQyxDQUFBLENBQUE7S0FGQTtBQUFBLElBR0EsSUFBQyxDQUFBLEdBQUQsQ0FBTSxTQUFBLEdBQVMsSUFBVCxHQUFjLElBQXBCLEVBQXlCLElBQUMsQ0FBQSxHQUFELENBQU0sTUFBTixDQUF6QixDQUhBLENBQUE7V0FJQSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQVYsRUFMVTtFQUFBLENBeENYO0FBQUEsRUErQ0EsUUFBQSxFQUFVLFNBQUMsS0FBRCxHQUFBO0FBQ1QsSUFBQSxJQUFrRCxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQU4sQ0FBQSxLQUFxQixDQUF2RTtBQUFBLE1BQUEsSUFBQyxDQUFBLEdBQUQsQ0FBTSxTQUFBLEdBQVEsQ0FBQyxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQU4sQ0FBRCxDQUFSLEdBQXlCLFNBQS9CLEVBQXlDLEtBQXpDLENBQUEsQ0FBQTtLQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQUEsR0FBUyxLQUFULEdBQWUsU0FBckIsRUFBK0IsSUFBL0IsQ0FEQSxDQUFBO1dBRUEsSUFBQyxDQUFBLEdBQUQsQ0FBSztBQUFBLE1BQUEsT0FBQSxFQUFTLEtBQVQ7S0FBTCxFQUhTO0VBQUEsQ0EvQ1Y7Q0FGZ0IsQ0FaakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxNQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVMsa0JBQVQsQ0FSVCxDQUFBOztBQUFBLE1BV00sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFTLHlCQUFULENBQVY7QUFBQSxFQUVBLE1BQUEsRUFBUSxTQUFBLEdBQUE7V0FBRyxJQUFDLENBQUEsTUFBRCxDQUFBLEVBQUg7RUFBQSxDQUZSO0FBQUEsRUFJQSxRQUFBLEVBQVUsU0FBQSxHQUFBLENBSlY7Q0FGZ0IsQ0FYakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxtQ0FBQTs7QUFBQSxNQVFBLEdBQVMsT0FBQSxDQUFTLG1CQUFULENBUlQsQ0FBQTs7QUFBQSxJQVNBLEdBQU8sT0FBQSxDQUFTLE1BQVQsQ0FUUCxDQUFBOztBQUFBLElBV0EsR0FBTyxPQUFBLENBQVMsTUFBVCxDQUFlLENBQUMsTUFBTSxDQUFDLElBWDlCLENBQUE7O0FBQUEsS0FZQSxHQUFRLE9BQUEsQ0FBUyxNQUFULENBQWUsQ0FBQyxNQUFNLENBQUMsS0FaL0IsQ0FBQTs7QUFBQSxRQWFBLEdBQVcsT0FBQSxDQUFTLGtCQUFULENBYlgsQ0FBQTs7QUFBQSxNQWVNLENBQUMsT0FBUCxHQUFpQixNQUFNLENBQUMsTUFBUCxDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLE9BQUEsQ0FBUyxtQkFBVCxDQUFWO0FBQUEsRUFFQSxRQUFBLEVBQ0M7QUFBQSxJQUFBLGFBQUEsRUFBZSxPQUFBLENBQVMsOEJBQVQsQ0FBZjtBQUFBLElBQ0EsSUFBQSxFQUFNLE9BQUEsQ0FBUyxvQkFBVCxDQUROO0dBSEQ7QUFBQSxFQU1BLElBQUEsRUFDQztBQUFBLElBQUEsT0FBQSxFQUFTLENBQVQ7QUFBQSxJQUNBLE1BQUEsRUFDQztBQUFBLE1BQUEsQ0FBQSxFQUFJLEtBQUo7QUFBQSxNQUNBLENBQUEsRUFBSSxRQURKO0FBQUEsTUFFQSxDQUFBLEVBQUksT0FGSjtLQUZEO0dBUEQ7QUFBQSxFQWFBLE1BQUEsRUFBUSxTQUFBLEdBQUE7QUFFUCxJQUFBLE1BQU0sQ0FBQyxTQUFQLEdBQW1CLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLENBQUQsR0FBQTtBQUNsQixRQUFBLElBQWdCLENBQUMsQ0FBQyxPQUFGLEtBQWEsRUFBN0I7QUFBQSxVQUFBLEtBQUMsQ0FBQSxTQUFELENBQUEsQ0FBQSxDQUFBO1NBQUE7QUFDQSxRQUFBLElBQWdCLENBQUMsQ0FBQyxPQUFGLEtBQWEsRUFBN0I7aUJBQUEsS0FBQyxDQUFBLFNBQUQsQ0FBQSxFQUFBO1NBRmtCO01BQUEsRUFBQTtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBbkIsQ0FBQTtBQUFBLElBSUEsSUFBQyxDQUFBLEVBQUQsQ0FBSyxhQUFMLEVBQW1CLFNBQUEsR0FBQTthQUFHLElBQUMsQ0FBQSxTQUFELENBQUEsRUFBSDtJQUFBLENBQW5CLENBSkEsQ0FBQTtBQUFBLElBS0EsSUFBQyxDQUFBLEVBQUQsQ0FBSyxhQUFMLEVBQW1CLFNBQUEsR0FBQTthQUFHLElBQUMsQ0FBQSxTQUFELENBQUEsRUFBSDtJQUFBLENBQW5CLENBTEEsQ0FBQTtXQU9BLElBQUMsQ0FBQSxPQUFELENBQVUsTUFBVixFQUFpQixDQUFBLFNBQUEsS0FBQSxHQUFBO2FBQUEsU0FBQyxRQUFELEdBQUE7QUFDaEIsUUFBQSxJQUFHLFFBQUg7aUJBQ0MsS0FBQSxDQUFNLEtBQUMsQ0FBQSxHQUFELENBQU0sUUFBTixDQUFOLEVBQXNCLFNBQUMsQ0FBRCxFQUFJLENBQUosR0FBQTtBQUFVLFlBQUEsSUFBdUMsQ0FBQSxLQUFLLFFBQTVDO0FBQUEscUJBQU8sS0FBQyxDQUFBLEdBQUQsQ0FBSztBQUFBLGdCQUFBLE9BQUEsRUFBUyxRQUFBLENBQVMsQ0FBVCxFQUFXLEVBQVgsQ0FBVDtlQUFMLENBQVAsQ0FBQTthQUFWO1VBQUEsQ0FBdEIsRUFERDtTQURnQjtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQWpCLEVBVE87RUFBQSxDQWJSO0FBQUEsRUEwQkEsUUFBQSxFQUFVLFNBQUEsR0FBQTtBQUdULFFBQUEsc0JBQUE7QUFBQSxJQUFBLElBQUEsR0FBTyxJQUFDLENBQUEsSUFBRCxDQUFPLE1BQVAsQ0FBUCxDQUFBO0FBQUEsSUFPQSxLQUFBLEdBQVEsSUFBQyxDQUFBLElBQUQsQ0FBTyxjQUFQLENBUFIsQ0FBQTtBQUFBLElBUUEsSUFBQSxHQUFPLElBQUMsQ0FBQSxJQUFELENBQU8sdUJBQVAsQ0FSUCxDQUFBO0FBQUEsSUFXQSxHQUFBLEdBQU0sUUFBUSxDQUFDLGFBQVQsQ0FBd0IsS0FBeEIsQ0FYTixDQUFBO0FBQUEsSUFZQSxRQUFBLENBQVMsR0FBVCxFQUFlLE1BQWYsQ0FaQSxDQUFBO1dBZUEsS0FBSyxDQUFDLFdBQU4sQ0FBa0IsR0FBbEIsRUFsQlM7RUFBQSxDQTFCVjtBQUFBLEVBZ0RBLFNBQUEsRUFBVyxTQUFBLEdBQUE7QUFDVixRQUFBLGFBQUE7QUFBQSxJQUFBLE9BQUEsR0FBVSxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQU4sQ0FBVixDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQVUsT0FBQSxLQUFXLElBQUEsQ0FBSyxJQUFDLENBQUEsR0FBRCxDQUFNLFFBQU4sQ0FBTCxDQUFvQixDQUFDLE1BQW5DLEdBQStDLENBQS9DLEdBQXNELE9BQUEsSUFBUyxDQUR0RSxDQUFBO1dBRUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFWLEVBSFU7RUFBQSxDQWhEWDtBQUFBLEVBcURBLFNBQUEsRUFBVyxTQUFBLEdBQUE7QUFDVixRQUFBLGFBQUE7QUFBQSxJQUFBLE9BQUEsR0FBVSxJQUFDLENBQUEsR0FBRCxDQUFNLFNBQU4sQ0FBVixDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQVUsT0FBQSxLQUFXLENBQWQsR0FBcUIsSUFBQSxDQUFLLElBQUMsQ0FBQSxHQUFELENBQU0sUUFBTixDQUFMLENBQW9CLENBQUMsTUFBMUMsR0FBc0QsT0FBQSxJQUFTLENBRHRFLENBQUE7V0FFQSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQVYsRUFIVTtFQUFBLENBckRYO0FBQUEsRUEwREEsUUFBQSxFQUFVLFNBQUMsS0FBRCxHQUFBO1dBQ1QsSUFBQSxDQUFNLEdBQUEsR0FBRSxDQUFDLElBQUMsQ0FBQSxHQUFELENBQU0sU0FBQSxHQUFTLEtBQWYsQ0FBRCxDQUFSLEVBRFM7RUFBQSxDQTFEVjtDQUZnQixDQWZqQixDQUFBOzs7OztBQ0FBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQUMsRUFBRCxFQUFLLFNBQUwsR0FBQTtBQUNoQixFQUFBLElBQUcsVUFBSDtBQUNDLElBQUEsSUFBRyxvQkFBSDthQUNDLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBYixDQUFpQixTQUFqQixFQUREO0tBQUEsTUFBQTthQUdDLEVBQUUsQ0FBQyxTQUFILElBQWlCLEdBQUEsR0FBSyxVQUh2QjtLQUREO0dBRGdCO0FBQUEsQ0FBakIsQ0FBQTs7Ozs7QUNBQSxJQUFBLCtCQUFBOztBQUFBLE9BQUEsR0FBVSxPQUFBLENBQVMsU0FBVCxDQUFWLENBQUE7O0FBQUEsUUFDQSxHQUFXLE9BQUEsQ0FBUyxVQUFULENBRFgsQ0FBQTs7QUFBQSxJQUVBLEdBQU8sT0FBQSxDQUFTLE1BQVQsQ0FGUCxDQUFBOztBQUFBLE1BSUEsR0FBUyxPQUFBLENBQVMsV0FBVCxDQUpULENBQUE7O0FBQUEsTUFNTSxDQUFDLE9BQVAsR0FBaUIsT0FBTyxDQUFDLE1BQVIsQ0FFaEI7QUFBQSxFQUFBLEVBQUEsRUFBSSxRQUFRLENBQUMsSUFBYjtBQUFBLEVBRUEsTUFBQSxFQUFRLElBRlI7QUFBQSxFQUlBLFFBQUEsRUFBVSxPQUFBLENBQVMsZ0JBQVQsQ0FKVjtBQUFBLEVBTUEsSUFBQSxFQUNDO0FBQUEsSUFBQSxJQUFBLEVBQU0sSUFBTjtBQUFBLElBQ0EsSUFBQSxFQUFNLElBRE47QUFBQSxJQUVBLEtBQUEsRUFBTyxJQUZQO0dBUEQ7QUFBQSxFQVdBLE1BQUEsRUFBUSxTQUFBLEdBQUE7QUFDUCxJQUFBLElBQUMsQ0FBQSxPQUFELENBQUEsQ0FBQSxDQUFBO1dBRUEsSUFBQyxDQUFBLFVBQUQsQ0FBQSxFQUhPO0VBQUEsQ0FYUjtBQUFBLEVBZ0JBLE9BQUEsRUFBUyxTQUFBLEdBQUE7QUFFUixRQUFBLEVBQUE7QUFBQSxJQUFBLEVBQUEsR0FBUyxJQUFBLFFBQUEsQ0FBVSxVQUFBLEdBQVUsTUFBTSxDQUFDLFFBQWpCLEdBQTBCLGtCQUFwQyxDQUFULENBQUE7V0FDQSxFQUFFLENBQUMsRUFBSCxDQUFPLE9BQVAsRUFBZSxDQUFBLFNBQUEsS0FBQSxHQUFBO2FBQUEsU0FBQyxRQUFELEdBQUE7ZUFFZCxPQUFPLENBQUMsR0FBUixDQUFhLEtBQWIsRUFBbUIsUUFBUSxDQUFDLEdBQVQsQ0FBQSxDQUFuQixFQUZjO01BQUEsRUFBQTtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBZixFQUdFLFNBQUMsR0FBRCxHQUFBO2FBQ0UsT0FBTyxDQUFDLEdBQVIsQ0FBYSxNQUFiLEVBQW9CLEdBQUcsQ0FBQyxJQUF4QixFQURGO0lBQUEsQ0FIRixFQUhRO0VBQUEsQ0FoQlQ7QUFBQSxFQXlCQSxVQUFBLEVBQVksU0FBQSxHQUFBO0FBQ1gsUUFBQSxJQUFBO0FBQUEsSUFBQSxJQUFBLEdBQU8sSUFBUCxDQUFBO0FBQUEsSUFFQSxJQUFBLENBQU0sR0FBTixFQUFVLFNBQUEsR0FBQTthQUNULElBQUksQ0FBQyxHQUFMLENBQVU7QUFBQSxRQUFBLE1BQUEsRUFBUSxLQUFSO09BQVYsRUFEUztJQUFBLENBQVYsQ0FGQSxDQUFBO0FBQUEsSUFLQSxJQUFBLENBQU0sU0FBTixFQUFnQixTQUFDLEdBQUQsR0FBQTthQUNmLElBQUksQ0FBQyxHQUFMLENBQVU7QUFBQSxRQUFBLE1BQUEsRUFBTyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQWxCO09BQVYsRUFEZTtJQUFBLENBQWhCLENBTEEsQ0FBQTtXQVFBLElBQUEsQ0FBSztBQUFBLE1BQUEsS0FBQSxFQUFPLEtBQVA7QUFBQSxNQUFjLFFBQUEsRUFBVSxJQUF4QjtBQUFBLE1BQThCLFFBQUEsRUFBVSxLQUF4QztLQUFMLEVBVFc7RUFBQSxDQXpCWjtDQUZnQixDQU5qQixDQUFBOzs7OztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcGpPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDLzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIjIHJlZ2lzdGVyIGFsbCBtb2R1bGVzXG5yZXF1aXJlIFwiLi9tb2R1bGUvaW5kZXhcIlxuXG4jIHJlcXVpcmUgR1NBUFxucmVxdWlyZSBcImdzYXBcIlxuXG4jIHJlcXVpcmUgUmFjdGl2ZSBwbHVnaW5zXG5yZXF1aXJlIFwicmFjdGl2ZS1ldmVudHMtdGFwXCJcbnJlcXVpcmUgXCJyYWN0aXZlLXRvdWNoXCJcbnJlcXVpcmUgXCJyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGVcIlxucmVxdWlyZSBcInJhY3RpdmUtdHJhbnNpdGlvbnMtZmx5XCJcbnJlcXVpcmUgXCJyYWN0aXZlLXRyYW5zaXRpb25zLXNsaWRlXCJcblxuIyB3YWl0IGZvciB3aGVuIHRoZSBkb20gaXMgcmVhZHkgYW5kIGxvYWQgbWFpbiB2aWV3XG5yZXF1aXJlKFwiZG9tcmVhZHlcIikgLT5cblx0cmVxdWlyZShcIi4vYXBwLWRlYnVnXCIpKCkgaWYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgaXMgXCJkZXZlbG9wbWVudFwiXG5cblx0VmlldyA9IHJlcXVpcmUgXCIuL3ZpZXcvbWFpbi12aWV3XCJcblx0d2luZG93Ll92aWV3ID0gbmV3IFZpZXcoKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3ZlbmRvci9kYXQuZ3VpJylcbm1vZHVsZS5leHBvcnRzLmNvbG9yID0gcmVxdWlyZSgnLi92ZW5kb3IvZGF0LmNvbG9yJykiLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBkYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdCB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb2xvciA9IGRhdC5jb2xvciB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC51dGlscyA9IGRhdC51dGlscyB8fCB7fTtcblxuZGF0LnV0aWxzLmNvbW1vbiA9IChmdW5jdGlvbiAoKSB7XG4gIFxuICB2YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgdmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuICAgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcbiAgICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICAgKi9cblxuICByZXR1cm4geyBcbiAgICBcbiAgICBCUkVBSzoge30sXG4gIFxuICAgIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZhdWx0czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgXG4gICAgfSxcbiAgICBcbiAgICBjb21wb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRyLCBzY29wZSkge1xuXG4gICAgICBcbiAgICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHsgXG4gICAgICAgIFxuICAgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7IC8vIElzIG51bWJlciBidXQgbm90IE5hTlxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgXG4gICAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZlcjogZnVuY3Rpb24oZm5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gICAgfSxcbiAgICBcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgICB9LFxuXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdWxsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfSxcbiAgICBcbiAgICBpc05hTjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaiswO1xuICAgIH0sXG4gICAgXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKycnO1xuICAgIH0sXG4gICAgXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgXG4gIH07XG4gICAgXG59KSgpO1xuXG5cbmRhdC5jb2xvci50b1N0cmluZyA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9yKSB7XG5cbiAgICBpZiAoY29sb3IuYSA9PSAxIHx8IGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5hKSkge1xuXG4gICAgICB2YXIgcyA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChjb2xvci5yKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZykgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIpICsgJywnICsgY29sb3IuYSArICcpJztcblxuICAgIH1cblxuICB9XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5Db2xvciA9IGRhdC5jb2xvci5Db2xvciA9IChmdW5jdGlvbiAoaW50ZXJwcmV0LCBtYXRoLCB0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyAnRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcblxuXG4gIH07XG5cbiAgQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsJ2cnLCdiJywnaCcsJ3MnLCd2JywnaGV4JywnYSddO1xuXG4gIGNvbW1vbi5leHRlbmQoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfSxcblxuICAgIHRvT3JpZ2luYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuXG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gbWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUkdCKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblxuICAgICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gbWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblxuICAgICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBtYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhyb3cgJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZSc7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlSFNWKGNvbG9yKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gbWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLFxuICAgICAgICB7XG4gICAgICAgICAgczogcmVzdWx0LnMsXG4gICAgICAgICAgdjogcmVzdWx0LnZcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICAgIH0gZWxzZSBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29sb3I7XG5cbn0pKGRhdC5jb2xvci5pbnRlcnByZXQgPSAoZnVuY3Rpb24gKHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgcmVzdWx0LCB0b1JldHVybjtcblxuICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0b1JldHVybiA9IGZhbHNlO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuXG4gICAgY29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbihmYW1pbHkpIHtcblxuICAgICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG5cbiAgICAgICAgY29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbihjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblxuICAgICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfTtcblxuICB2YXIgSU5URVJQUkVUQVRJT05TID0gW1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNTdHJpbmcsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgU0lYX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQjoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCQToge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE51bWJlcnNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzTnVtYmVyLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIEhFWDoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBcnJheXNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzQXJyYXksXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCQV9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNPYmplY3QsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgXTtcblxuICByZXR1cm4gaW50ZXJwcmV0O1xuXG5cbn0pKGRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbG9yLm1hdGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0bXBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcblxuICAgIGhzdl90b19yZ2I6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcblxuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblxuICAgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMS4wIC0gKGYgKiBzKSk7XG4gICAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKCgxLjAgLSBmKSAqIHMpKTtcbiAgICAgIHZhciBjID0gW1xuICAgICAgICBbdiwgdCwgcF0sXG4gICAgICAgIFtxLCB2LCBwXSxcbiAgICAgICAgW3AsIHYsIHRdLFxuICAgICAgICBbcCwgcSwgdl0sXG4gICAgICAgIFt0LCBwLCB2XSxcbiAgICAgICAgW3YsIHAsIHFdXG4gICAgICBdW2hpXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgICAgYjogY1syXSAqIDI1NVxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICByZ2JfdG9faHN2OiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICBoLCBzO1xuXG4gICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBOYU4sXG4gICAgICAgICAgczogMCxcbiAgICAgICAgICB2OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCAqIDM2MCxcbiAgICAgICAgczogcyxcbiAgICAgICAgdjogbWF4IC8gMjU1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZ2JfdG9faGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIChoZXggPj4gKGNvbXBvbmVudEluZGV4ICogOCkpICYgMHhGRjtcbiAgICB9LFxuXG4gICAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgKGhleCAmIH4gKDB4RkYgPDwgdG1wQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gIH1cblxufSkoKSxcbmRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pOyIsIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4vKiogQG5hbWVzcGFjZSAqL1xudmFyIGRhdCA9IG1vZHVsZS5leHBvcnRzID0gZGF0IHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0Lmd1aSA9IGRhdC5ndWkgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQudXRpbHMgPSBkYXQudXRpbHMgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29udHJvbGxlcnMgPSBkYXQuY29udHJvbGxlcnMgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuZG9tID0gZGF0LmRvbSB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb2xvciA9IGRhdC5jb2xvciB8fCB7fTtcblxuZGF0LnV0aWxzLmNzcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbG9hZDogZnVuY3Rpb24gKHVybCwgZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICBsaW5rLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9LFxuICAgIGluamVjdDogZnVuY3Rpb24oY3NzLCBkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBpbmplY3RlZC50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgIGluamVjdGVkLmlubmVySFRNTCA9IGNzcztcbiAgICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cblxuZGF0LnV0aWxzLmNvbW1vbiA9IChmdW5jdGlvbiAoKSB7XG4gIFxuICB2YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgdmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuICAgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcbiAgICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICAgKi9cblxuICByZXR1cm4geyBcbiAgICBcbiAgICBCUkVBSzoge30sXG4gIFxuICAgIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZhdWx0czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgXG4gICAgfSxcbiAgICBcbiAgICBjb21wb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRyLCBzY29wZSkge1xuXG4gICAgICBcbiAgICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHsgXG4gICAgICAgIFxuICAgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7IC8vIElzIG51bWJlciBidXQgbm90IE5hTlxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgXG4gICAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZlcjogZnVuY3Rpb24oZm5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gICAgfSxcbiAgICBcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgICB9LFxuXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdWxsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfSxcbiAgICBcbiAgICBpc05hTjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaiswO1xuICAgIH0sXG4gICAgXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKycnO1xuICAgIH0sXG4gICAgXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgXG4gIH07XG4gICAgXG59KSgpO1xuXG5cbmRhdC5jb250cm9sbGVycy5Db250cm9sbGVyID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIEFuIFwiYWJzdHJhY3RcIiBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgIC8qKlxuICAgICAqIFRob3NlIHdobyBleHRlbmQgdGhpcyBjbGFzcyB3aWxsIHB1dCB0aGVpciBET00gZWxlbWVudHMgaW4gaGVyZS5cbiAgICAgKiBAdHlwZSB7RE9NRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdG8gbWFuaXB1bGF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gbWFuaXB1bGF0ZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjaGFuZ2UuXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fb25DaGFuZ2UgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGZpbmlzaGluZyBjaGFuZ2UuXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG5cbiAgfTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlci5wcm90b3R5cGUgKi9cbiAgICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSB0aGF0IGEgZnVuY3Rpb24gZmlyZSBldmVyeSB0aW1lIHNvbWVvbmUgY2hhbmdlcyB0aGUgdmFsdWUgd2l0aFxuICAgICAgICAgKiB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuYyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZVxuICAgICAgICAgKiBpcyBtb2RpZmllZCB2aWEgdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UgPSBmbmM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgdGhhdCBhIGZ1bmN0aW9uIGZpcmUgZXZlcnkgdGltZSBzb21lb25lIFwiZmluaXNoZXNcIiBjaGFuZ2luZ1xuICAgICAgICAgKiB0aGUgdmFsdWUgd2loIHRoaXMgQ29udHJvbGxlci4gVXNlZnVsIGZvciB2YWx1ZXMgdGhhdCBjaGFuZ2VcbiAgICAgICAgICogaW5jcmVtZW50YWxseSBsaWtlIG51bWJlcnMgb3Igc3RyaW5ncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5jIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXJcbiAgICAgICAgICogc29tZW9uZSBcImZpbmlzaGVzXCIgY2hhbmdpbmcgdGhlIHZhbHVlIHZpYSB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgb25GaW5pc2hDaGFuZ2U6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIHRoZSB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaGVzIHRoZSB2aXN1YWwgZGlzcGxheSBvZiBhIENvbnRyb2xsZXIgaW4gb3JkZXIgdG8ga2VlcCBzeW5jXG4gICAgICAgICAqIHdpdGggdGhlIG9iamVjdCdzIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSB2YWx1ZSBoYXMgZGV2aWF0ZWQgZnJvbSBpbml0aWFsVmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGlzTW9kaWZpZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5nZXRWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIENvbnRyb2xsZXI7XG5cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmRvbS5kb20gPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHZhciBFVkVOVF9NQVAgPSB7XG4gICAgJ0hUTUxFdmVudHMnOiBbJ2NoYW5nZSddLFxuICAgICdNb3VzZUV2ZW50cyc6IFsnY2xpY2snLCdtb3VzZW1vdmUnLCdtb3VzZWRvd24nLCdtb3VzZXVwJywgJ21vdXNlb3ZlciddLFxuICAgICdLZXlib2FyZEV2ZW50cyc6IFsna2V5ZG93biddXG4gIH07XG5cbiAgdmFyIEVWRU5UX01BUF9JTlYgPSB7fTtcbiAgY29tbW9uLmVhY2goRVZFTlRfTUFQLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgY29tbW9uLmVhY2godiwgZnVuY3Rpb24oZSkge1xuICAgICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBDU1NfVkFMVUVfUElYRUxTID0gLyhcXGQrKFxcLlxcZCspPylweC87XG5cbiAgZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcblxuICAgIGlmICh2YWwgPT09ICcwJyB8fCBjb21tb24uaXNVbmRlZmluZWQodmFsKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goQ1NTX1ZBTFVFX1BJWEVMUyk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAuLi5lbXM/ICU/XG5cbiAgICByZXR1cm4gMDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlciBkYXQuZG9tXG4gICAqL1xuICB2YXIgZG9tID0ge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gc2VsZWN0YWJsZVxuICAgICAqL1xuICAgIG1ha2VTZWxlY3RhYmxlOiBmdW5jdGlvbihlbGVtLCBzZWxlY3RhYmxlKSB7XG5cbiAgICAgIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbS5zdHlsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcblxuICAgICAgZWxlbS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGVsZW0uc3R5bGUuS2h0bWxVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGhvcml6b250YWxcbiAgICAgKiBAcGFyYW0gdmVydGljYWxcbiAgICAgKi9cbiAgICBtYWtlRnVsbHNjcmVlbjogZnVuY3Rpb24oZWxlbSwgaG9yaXpvbnRhbCwgdmVydGljYWwpIHtcblxuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHZlcnRpY2FsKSkgdmVydGljYWwgPSB0cnVlO1xuXG4gICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgICBlbGVtLnN0eWxlLmJvdHRvbSA9IDA7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgZmFrZUV2ZW50OiBmdW5jdGlvbihlbGVtLCBldmVudFR5cGUsIHBhcmFtcywgYXV4KSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoY2xhc3NOYW1lKTtcbiAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XG4gICAgICAgICAgdmFyIGNsaWVudFkgPSBwYXJhbXMueSB8fCBwYXJhbXMuY2xpZW50WSB8fCAwO1xuICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlLCB3aW5kb3csIHBhcmFtcy5jbGlja0NvdW50IHx8IDEsXG4gICAgICAgICAgICAgIDAsIC8vc2NyZWVuIFhcbiAgICAgICAgICAgICAgMCwgLy9zY3JlZW4gWVxuICAgICAgICAgICAgICBjbGllbnRYLCAvL2NsaWVudCBYXG4gICAgICAgICAgICAgIGNsaWVudFksIC8vY2xpZW50IFlcbiAgICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XG4gICAgICAgICAgdmFyIGluaXQgPSBldnQuaW5pdEtleWJvYXJkRXZlbnQgfHwgZXZ0LmluaXRLZXlFdmVudDsgLy8gd2Via2l0IHx8IG1velxuICAgICAgICAgIGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXJDb2RlOiB1bmRlZmluZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csXG4gICAgICAgICAgICAgIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LFxuICAgICAgICAgICAgICBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LFxuICAgICAgICAgICAgICBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29tbW9uLmRlZmF1bHRzKGV2dCwgYXV4KTtcbiAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiBAcGFyYW0gYm9vbFxuICAgICAqL1xuICAgIGJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBib29sID0gYm9vbCB8fCBmYWxzZTtcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KVxuICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiBAcGFyYW0gYm9vbFxuICAgICAqL1xuICAgIHVuYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGJvb2wgPSBib29sIHx8IGZhbHNlO1xuICAgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpXG4gICAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgPT09IGNsYXNzTmFtZSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKS50ZXN0KGVsZW0uY2xhc3NOYW1lKSB8fCBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cbiAgICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWxlZnQnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3dpZHRoJ10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cbiAgICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1ib3R0b20nXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2hlaWdodCddKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldE9mZnNldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgdmFyIG9mZnNldCA9IHtsZWZ0OiAwLCB0b3A6MH07XG4gICAgICBpZiAoZWxlbS5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgICBvZmZzZXQudG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICB9IHdoaWxlIChlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3Bvc3RzLzI2ODQ1NjEvcmV2aXNpb25zXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmICk7XG4gICAgfVxuXG4gIH07XG5cbiAgcmV0dXJuIGRvbTtcblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIHNlbGVjdCBpbnB1dCB0byBhbHRlciB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB1c2luZyBhXG4gICAqIGxpc3Qgb2YgYWNjZXB0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmdbXX0gb3B0aW9ucyBBIG1hcCBvZiBsYWJlbHMgdG8gYWNjZXB0YWJsZSB2YWx1ZXMsIG9yXG4gICAqIGEgbGlzdCBvZiBhY2NlcHRhYmxlIHN0cmluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIG9wdGlvbnMpIHtcblxuICAgIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkcm9wIGRvd24gbWVudVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cbiAgICBpZiAoY29tbW9uLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgIGNvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgbWFwW2VsZW1lbnRdID0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucyA9IG1hcDtcbiAgICB9XG5cbiAgICBjb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cbiAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICAgIF90aGlzLl9fc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG5cbiAgICB9KTtcblxuICAgIC8vIEFja25vd2xlZGdlIG9yaWdpbmFsIHZhbHVlXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVzaXJlZFZhbHVlID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShkZXNpcmVkVmFsdWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19zZWxlY3QpO1xuXG4gIH07XG5cbiAgT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5taW5dIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5zdGVwXSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICB0aGlzLl9fbWluID0gcGFyYW1zLm1pbjtcbiAgICB0aGlzLl9fbWF4ID0gcGFyYW1zLm1heDtcbiAgICB0aGlzLl9fc3RlcCA9IHBhcmFtcy5zdGVwO1xuXG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fc3RlcCkpIHtcblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlID09IDApIHtcbiAgICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gMTsgLy8gV2hhdCBhcmUgd2UsIHBzeWNoaWNzP1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGV5IERvdWcsIGNoZWNrIHRoaXMgb3V0LlxuICAgICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyh0aGlzLmluaXRpYWxWYWx1ZSkvTWF0aC5MTjEwKSkvMTA7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSB0aGlzLl9fc3RlcDtcblxuICAgIH1cblxuICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyh0aGlzLl9faW1wbGllZFN0ZXApO1xuXG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlICovXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLl9fbWluO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX21heCAhPT0gdW5kZWZpbmVkICYmIHYgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fX21heDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fX3N0ZXAgIT09IHVuZGVmaW5lZCAmJiB2ICUgdGhpcy5fX3N0ZXAgIT0gMCkge1xuICAgICAgICAgICAgdiA9IE1hdGgucm91bmQodiAvIHRoaXMuX19zdGVwKSAqIHRoaXMuX19zdGVwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIG1pbmltdW0gdmFsdWUgZm9yIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgVGhlIG1pbmltdW0gdmFsdWUgZm9yXG4gICAgICAgICAqIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX21pbiA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBtYXhpbXVtIHZhbHVlIGZvciA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlIFRoZSBtYXhpbXVtIHZhbHVlIGZvclxuICAgICAgICAgKiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19tYXggPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgc3RlcCB2YWx1ZSB0aGF0IGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAgICAgICAqIGluY3JlbWVudHMgYnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwVmFsdWUgVGhlIHN0ZXAgdmFsdWUgZm9yXG4gICAgICAgICAqIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAgICAgICAqIEBkZWZhdWx0IGlmIG1pbmltdW0gYW5kIG1heGltdW0gc3BlY2lmaWVkIGluY3JlbWVudCBpcyAxJSBvZiB0aGVcbiAgICAgICAgICogZGlmZmVyZW5jZSBvdGhlcndpc2Ugc3RlcFZhbHVlIGlzIDFcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBzdGVwOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX3N0ZXAgPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIG51bURlY2ltYWxzKHgpIHtcbiAgICB4ID0geC50b1N0cmluZygpO1xuICAgIGlmICh4LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICByZXR1cm4geC5sZW5ndGggLSB4LmluZGV4T2YoJy4nKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94ID0gKGZ1bmN0aW9uIChOdW1iZXJDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyIGFuZFxuICAgKiBwcm92aWRlcyBhbiBpbnB1dCBlbGVtZW50IHdpdGggd2hpY2ggdG8gbWFuaXB1bGF0ZSBpdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWluXSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4XSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3RlcF0gSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXJCb3ggPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIHtOdW1iZXJ9IFByZXZpb3VzIG1vdXNlIHkgcG9zaXRpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdmFyIHByZXZfeTtcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG5cbiAgICAvLyBNYWtlcyBpdCBzbyBtYW51YWxseSBzcGVjaWZpZWQgdmFsdWVzIGFyZSBub3QgdHJ1bmNhdGVkLlxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAvLyBXaGVuIHByZXNzaW5nIGVudGlyZSwgeW91IGNhbiBiZSBhcyBwcmVjaXNlIGFzIHlvdSB3YW50LlxuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFjb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkgX3RoaXMuc2V0VmFsdWUoYXR0ZW1wdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBvbkNoYW5nZSgpO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIHByZXZfeSA9IGUuY2xpZW50WTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG5cbiAgICAgIHZhciBkaWZmID0gcHJldl95IC0gZS5jbGllbnRZO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuZ2V0VmFsdWUoKSArIGRpZmYgKiBfdGhpcy5fX2ltcGxpZWRTdGVwKTtcblxuICAgICAgcHJldl95ID0gZS5jbGllbnRZO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MgPSBOdW1iZXJDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLFxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID8gdGhpcy5nZXRWYWx1ZSgpIDogcm91bmRUb0RlY2ltYWwodGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9fcHJlY2lzaW9uKTtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgdmFyIHRlblRvID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHRlblRvKSAvIHRlblRvO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3g7XG5cbn0pKGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IChmdW5jdGlvbiAoTnVtYmVyQ29udHJvbGxlciwgZG9tLCBjc3MsIGNvbW1vbiwgc3R5bGVTaGVldCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyLCBjb250YWluc1xuICAgKiBhIG1pbmltdW0gYW5kIG1heGltdW0sIGFuZCBwcm92aWRlcyBhIHNsaWRlciBlbGVtZW50IHdpdGggd2hpY2ggdG9cbiAgICogbWFuaXB1bGF0ZSBpdC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgdGhlIHNsaWRlciBlbGVtZW50IGlzIG1hZGUgdXAgb2ZcbiAgICogPGNvZGU+Jmx0O2RpdiZndDs8L2NvZGU+IHRhZ3MsIDxzdHJvbmc+bm90PC9zdHJvbmc+IHRoZSBodG1sNVxuICAgKiA8Y29kZT4mbHQ7c2xpZGVyJmd0OzwvY29kZT4gZWxlbWVudC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5WYWx1ZSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFZhbHVlIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyU2xpZGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcblxuICAgIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBcblxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2JhY2tncm91bmQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19iYWNrZ3JvdW5kLCAnc2xpZGVyJyk7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG5cbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXG4gICAgICBvbk1vdXNlRHJhZyhlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIG9mZnNldCA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19iYWNrZ3JvdW5kKTtcbiAgICAgIHZhciB3aWR0aCA9IGRvbS5nZXRXaWR0aChfdGhpcy5fX2JhY2tncm91bmQpO1xuICAgICAgXG4gICAgICBfdGhpcy5zZXRWYWx1ZShcbiAgICAgICAgbWFwKGUuY2xpZW50WCwgb2Zmc2V0LmxlZnQsIG9mZnNldC5sZWZ0ICsgd2lkdGgsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLl9fYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLl9fZm9yZWdyb3VuZCk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19iYWNrZ3JvdW5kKTtcblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcyA9IE51bWJlckNvbnRyb2xsZXI7XG5cbiAgLyoqXG4gICAqIEluamVjdHMgZGVmYXVsdCBzdHlsZXNoZWV0IGZvciBzbGlkZXIgZWxlbWVudHMuXG4gICAqL1xuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnVzZURlZmF1bHRTdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICBjc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xuICB9O1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlLFxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGN0ID0gKHRoaXMuZ2V0VmFsdWUoKSAtIHRoaXMuX19taW4pLyh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICAgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QqMTAwKyclJztcbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cblxuICApO1xuXG4gIGZ1bmN0aW9uIG1hcCh2LCBpMSwgaTIsIG8xLCBvMikge1xuICAgIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlcjtcbiAgXG59KShkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNzcyxcbmRhdC51dGlscy5jb21tb24sXG5cIi5zbGlkZXIge1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAycHggNHB4IHJnYmEoMCwwLDAsMC4xNSk7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICBwYWRkaW5nOiAwIDAuNWVtO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnNsaWRlci1mZyB7XFxuICBwYWRkaW5nOiAxcHggMCAycHggMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIG1hcmdpbi1sZWZ0OiAtMC41ZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjVlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbSAwIDAgMWVtO1xcbn1cXG5cXG4uc2xpZGVyLWZnOmFmdGVyIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXI6ICAxcHggc29saWQgI2FhYTtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgbWFyZ2luLXJpZ2h0OiAtMWVtO1xcbiAgbWFyZ2luLXRvcDogLTFweDtcXG4gIGhlaWdodDogMC45ZW07XFxuICB3aWR0aDogMC45ZW07XFxufVwiKTtcblxuXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBHVUkgaW50ZXJmYWNlIHRvIGZpcmUgYSBzcGVjaWZpZWQgbWV0aG9kLCBhIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBGdW5jdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCB0ZXh0KSB7XG5cbiAgICBGdW5jdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fYnV0dG9uLmlubmVySFRNTCA9IHRleHQgPT09IHVuZGVmaW5lZCA/ICdGaXJlJyA6IHRleHQ7XG4gICAgZG9tLmJpbmQodGhpcy5fX2J1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19idXR0b24sICdidXR0b24nKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fYnV0dG9uKTtcblxuXG4gIH07XG5cbiAgRnVuY3Rpb25Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEZ1bmN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIHtcbiAgICAgICAgXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmdldFZhbHVlKCkuY2FsbCh0aGlzLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBGdW5jdGlvbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIGNoZWNrYm94IGlucHV0IHRvIGFsdGVyIHRoZSBib29sZWFuIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBCb29sZWFuQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgICB0aGlzLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcblxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hlY2tib3gpO1xuXG4gICAgLy8gTWF0Y2ggb3JpZ2luYWwgdmFsdWVcbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuXG4gIH07XG5cbiAgQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciB0b1JldHVybiA9IEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSB0cnVlOyAgICBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBCb29sZWFuQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb2xvci50b1N0cmluZyA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9yKSB7XG5cbiAgICBpZiAoY29sb3IuYSA9PSAxIHx8IGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5hKSkge1xuXG4gICAgICB2YXIgcyA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChjb2xvci5yKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZykgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIpICsgJywnICsgY29sb3IuYSArICcpJztcblxuICAgIH1cblxuICB9XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb2xvci5pbnRlcnByZXQgPSAoZnVuY3Rpb24gKHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgcmVzdWx0LCB0b1JldHVybjtcblxuICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0b1JldHVybiA9IGZhbHNlO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuXG4gICAgY29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbihmYW1pbHkpIHtcblxuICAgICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG5cbiAgICAgICAgY29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbihjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblxuICAgICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfTtcblxuICB2YXIgSU5URVJQUkVUQVRJT05TID0gW1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNTdHJpbmcsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgU0lYX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQjoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCQToge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE51bWJlcnNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzTnVtYmVyLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIEhFWDoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBcnJheXNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzQXJyYXksXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCQV9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNPYmplY3QsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgXTtcblxuICByZXR1cm4gaW50ZXJwcmV0O1xuXG5cbn0pKGRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5HVUkgPSBkYXQuZ3VpLkdVSSA9IChmdW5jdGlvbiAoY3NzLCBzYXZlRGlhbG9ndWVDb250ZW50cywgc3R5bGVTaGVldCwgY29udHJvbGxlckZhY3RvcnksIENvbnRyb2xsZXIsIEJvb2xlYW5Db250cm9sbGVyLCBGdW5jdGlvbkNvbnRyb2xsZXIsIE51bWJlckNvbnRyb2xsZXJCb3gsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIE9wdGlvbkNvbnRyb2xsZXIsIENvbG9yQ29udHJvbGxlciwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBDZW50ZXJlZERpdiwgZG9tLCBjb21tb24pIHtcblxuICBjc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xuXG4gIC8qKiBPdXRlci1tb3N0IGNsYXNzTmFtZSBmb3IgR1VJJ3MgKi9cbiAgdmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xuXG4gIHZhciBISURFX0tFWV9DT0RFID0gNzI7XG5cbiAgLyoqIFRoZSBvbmx5IHZhbHVlIHNoYXJlZCBiZXR3ZWVuIHRoZSBKUyBhbmQgU0NTUy4gVXNlIGNhdXRpb24uICovXG4gIHZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG5cbiAgdmFyIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSA9ICdEZWZhdWx0JztcblxuICB2YXIgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdyAmJiB3aW5kb3dbJ2xvY2FsU3RvcmFnZSddICE9PSBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgdmFyIFNBVkVfRElBTE9HVUU7XG5cbiAgLyoqIEhhdmUgd2UgeWV0IHRvIGNyZWF0ZSBhbiBhdXRvUGxhY2UgR1VJPyAqL1xuICB2YXIgYXV0b19wbGFjZV92aXJnaW4gPSB0cnVlO1xuXG4gIC8qKiBGaXhlZCBwb3NpdGlvbiBkaXYgdGhhdCBhdXRvIHBsYWNlIEdVSSdzIGdvIGluc2lkZSAqL1xuICB2YXIgYXV0b19wbGFjZV9jb250YWluZXI7XG5cbiAgLyoqIEFyZSB3ZSBoaWRpbmcgdGhlIEdVSSdzID8gKi9cbiAgdmFyIGhpZGUgPSBmYWxzZTtcblxuICAvKiogR1VJJ3Mgd2hpY2ggc2hvdWxkIGJlIGhpZGRlbiAqL1xuICB2YXIgaGlkZWFibGVfZ3VpcyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGxpZ2h0d2VpZ2h0IGNvbnRyb2xsZXIgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC4gSXQgYWxsb3dzIHlvdSB0byBlYXNpbHlcbiAgICogbWFuaXB1bGF0ZSB2YXJpYWJsZXMgYW5kIGZpcmUgZnVuY3Rpb25zIG9uIHRoZSBmbHkuXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5ndWlcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLm5hbWVdIFRoZSBuYW1lIG9mIHRoaXMgR1VJLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcy5sb2FkXSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNhdmVkIHN0YXRlIG9mXG4gICAqIHRoaXMgR1VJLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuYXV0bz10cnVlXVxuICAgKiBAcGFyYW0ge2RhdC5ndWkuR1VJfSBbcGFyYW1zLnBhcmVudF0gVGhlIEdVSSBJJ20gbmVzdGVkIGluLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuY2xvc2VkXSBJZiB0cnVlLCBzdGFydHMgY2xvc2VkXG4gICAqL1xuICB2YXIgR1VJID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogT3V0ZXJtb3N0IERPTSBFbGVtZW50XG4gICAgICogQHR5cGUgRE9NRWxlbWVudFxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX191bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG5cbiAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBDU1NfTkFNRVNQQUNFKTtcblxuICAgIC8qKlxuICAgICAqIE5lc3RlZCBHVUkncyBieSBuYW1lXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19mb2xkZXJzID0ge307XG5cbiAgICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygb2JqZWN0cyBJJ20gcmVtZW1iZXJpbmcgZm9yIHNhdmUsIG9ubHkgdXNlZCBpbiB0b3AgbGV2ZWwgR1VJXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTWFwcyB0aGUgaW5kZXggb2YgcmVtZW1iZXJlZCBvYmplY3RzIHRvIGEgbWFwIG9mIGNvbnRyb2xsZXJzLCBvbmx5IHVzZWRcbiAgICAgKiBpbiB0b3AgbGV2ZWwgR1VJLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFtcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnR5TmFtZTogQ29udHJvbGxlcixcbiAgICAgKiAgICBhbm90aGVyUHJvcGVydHlOYW1lOiBDb250cm9sbGVyXG4gICAgICogIH0sXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXJcbiAgICAgKiAgfVxuICAgICAqIF1cbiAgICAgKi9cbiAgICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzID0gW107XG5cbiAgICB0aGlzLl9fbGlzdGVuaW5nID0gW107XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBEZWZhdWx0IHBhcmFtZXRlcnNcbiAgICBwYXJhbXMgPSBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICBhdXRvUGxhY2U6IHRydWUsXG4gICAgICB3aWR0aDogR1VJLkRFRkFVTFRfV0lEVEhcbiAgICB9KTtcblxuICAgIHBhcmFtcyA9IGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICAgIGhpZGVhYmxlOiBwYXJhbXMuYXV0b1BsYWNlXG4gICAgfSk7XG5cblxuICAgIGlmICghY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5sb2FkKSkge1xuXG4gICAgICAvLyBFeHBsaWNpdCBwcmVzZXRcbiAgICAgIGlmIChwYXJhbXMucHJlc2V0KSBwYXJhbXMubG9hZC5wcmVzZXQgPSBwYXJhbXMucHJlc2V0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcGFyYW1zLmxvYWQgPSB7IHByZXNldDogREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FIH07XG5cbiAgICB9XG5cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5oaWRlYWJsZSkge1xuICAgICAgaGlkZWFibGVfZ3Vpcy5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgcm9vdCBsZXZlbCBHVUkncyBhcmUgcmVzaXphYmxlLlxuICAgIHBhcmFtcy5yZXNpemFibGUgPSBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcblxuXG4gICAgaWYgKHBhcmFtcy5hdXRvUGxhY2UgJiYgY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5zY3JvbGxhYmxlKSkge1xuICAgICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICAgIH1cbi8vICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5zY3JvbGxhYmxlID09PSB0cnVlO1xuXG4gICAgLy8gTm90IHBhcnQgb2YgcGFyYW1zIGJlY2F1c2UgSSBkb24ndCB3YW50IHBlb3BsZSBwYXNzaW5nIHRoaXMgaW4gdmlhXG4gICAgLy8gY29uc3RydWN0b3IuIFNob3VsZCBiZSBhICdyZW1lbWJlcmVkJyB2YWx1ZS5cbiAgICB2YXIgdXNlX2xvY2FsX3N0b3JhZ2UgPVxuICAgICAgICBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuXG4gICAgICAgIC8qKiBAbGVuZHMgZGF0Lmd1aS5HVUkucHJvdG90eXBlICovXG4gICAgICAgIHtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBwYXJlbnQgPGNvZGU+R1VJPC9jb2RlPlxuICAgICAgICAgICAqIEB0eXBlIGRhdC5ndWkuR1VJXG4gICAgICAgICAgICovXG4gICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2Nyb2xsYWJsZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBIYW5kbGVzIDxjb2RlPkdVSTwvY29kZT4ncyBlbGVtZW50IHBsYWNlbWVudCBmb3IgeW91XG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIGF1dG9QbGFjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBpZGVudGlmaWVyIGZvciBhIHNldCBvZiBzYXZlZCB2YWx1ZXNcbiAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwcmVzZXQ6IHtcblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHdpZHRoIG9mIDxjb2RlPkdVSTwvY29kZT4gZWxlbWVudFxuICAgICAgICAgICAqIEB0eXBlIE51bWJlclxuICAgICAgICAgICAqL1xuICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLndpZHRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBuYW1lIG9mIDxjb2RlPkdVSTwvY29kZT4uIFVzZWQgZm9yIGZvbGRlcnMuIGkuZVxuICAgICAgICAgICAqIGEgZm9sZGVyJ3MgbmFtZVxuICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBDaGVjayBmb3IgY29sbGlzaW9ucyBhbW9uZyBzaWJsaW5nIGZvbGRlcnNcbiAgICAgICAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICAgICAgICBpZiAodGl0bGVfcm93X25hbWUpIHtcbiAgICAgICAgICAgICAgICB0aXRsZV9yb3dfbmFtZS5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGV0aGVyIHRoZSA8Y29kZT5HVUk8L2NvZGU+IGlzIGNvbGxhcHNlZCBvciBub3RcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgY2xvc2VkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHY7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBhcmVuJ3QgZ29pbmcgdG8gcmVzcGVjdCB0aGUgQ1NTIHRyYW5zaXRpb24sXG4gICAgICAgICAgICAgIC8vIExldHMganVzdCBjaGVjayBvdXIgaGVpZ2h0IGFnYWluc3QgdGhlIHdpbmRvdyBoZWlnaHQgcmlnaHQgb2ZmXG4gICAgICAgICAgICAgIC8vIHRoZSBiYXQuXG4gICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcblxuICAgICAgICAgICAgICBpZiAoX3RoaXMuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gdiA/IEdVSS5URVhUX09QRU4gOiBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ29udGFpbnMgYWxsIHByZXNldHNcbiAgICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsb2FkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gdXNlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU3RvcmFnZSNsb2NhbFN0b3JhZ2VcIj5sb2NhbFN0b3JhZ2U8L2E+IGFzIHRoZSBtZWFucyBmb3JcbiAgICAgICAgICAgKiA8Y29kZT5yZW1lbWJlcjwvY29kZT5pbmdcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlOiB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1c2VfbG9jYWxfc3RvcmFnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICAgICAgICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgICAgICAgICAgICB1c2VfbG9jYWxfc3RvcmFnZSA9IGJvb2w7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSwgYm9vbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgIC8vIEFyZSB3ZSBhIHJvb3QgbGV2ZWwgR1VJP1xuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcblxuICAgICAgcGFyYW1zLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfTUFJTik7XG4gICAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBzdXBwb3NlZCB0byBiZSBsb2FkaW5nIGxvY2FsbHk/XG4gICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXG4gICAgICAgIGlmICh1c2VfbG9jYWxfc3RvcmFnZSkge1xuXG4gICAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzYXZlZF9ndWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG5cbiAgICAgICAgICBpZiAoc2F2ZWRfZ3VpKSB7XG4gICAgICAgICAgICBwYXJhbXMubG9hZCA9IEpTT04ucGFyc2Uoc2F2ZWRfZ3VpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19jbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CVVRUT04pO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XG5cbiAgICAgIGRvbS5iaW5kKHRoaXMuX19jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcblxuXG4gICAgICB9KTtcblxuXG4gICAgICAvLyBPaCwgeW91J3JlIGEgbmVzdGVkIEdVSSFcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAocGFyYW1zLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGl0bGVfcm93X25hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXJhbXMubmFtZSk7XG4gICAgICBkb20uYWRkQ2xhc3ModGl0bGVfcm93X25hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcblxuICAgICAgdmFyIHRpdGxlX3JvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVfcm93X25hbWUpO1xuXG4gICAgICB2YXIgb25fY2xpY2tfdGl0bGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aXRsZV9yb3csICd0aXRsZScpO1xuICAgICAgZG9tLmJpbmQodGl0bGVfcm93LCAnY2xpY2snLCBvbl9jbGlja190aXRsZSk7XG5cbiAgICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcblxuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuXG4gICAgICAgIGlmIChhdXRvX3BsYWNlX3Zpcmdpbikge1xuICAgICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9fcGxhY2VfY29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b19wbGFjZV9jb250YWluZXIsIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUik7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvX3BsYWNlX2NvbnRhaW5lcik7XG4gICAgICAgICAgYXV0b19wbGFjZV92aXJnaW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBpdCBpbiB0aGUgZG9tIGZvciB5b3UuXG4gICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIGF1dG8gc3R5bGVzXG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19BVVRPX1BMQUNFKTtcblxuICAgICAgfVxuXG5cbiAgICAgIC8vIE1ha2UgaXQgbm90IGVsYXN0aWMuXG4gICAgICBpZiAoIXRoaXMucGFyZW50KSBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcblxuICAgIH1cblxuICAgIGRvbS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKTsgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ29UcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuXG5cbiAgICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgICAgYWRkUmVzaXplSGFuZGxlKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVUb0xvY2FsU3RvcmFnZSgpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdndWknKSwgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZ2V0U2F2ZU9iamVjdCgpKSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgICAgIHJvb3Qud2lkdGggKz0gMTtcbiAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLnBhcmVudCkge1xuICAgICAgICByZXNldFdpZHRoKCk7XG4gICAgICB9XG5cbiAgfTtcblxuICBHVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaGlkZSA9ICFoaWRlO1xuICAgIGNvbW1vbi5lYWNoKGhpZGVhYmxlX2d1aXMsIGZ1bmN0aW9uKGd1aSkge1xuICAgICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUuekluZGV4ID0gaGlkZSA/IC05OTkgOiA5OTk7XG4gICAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gaGlkZSA/IDAgOiAxO1xuICAgIH0pO1xuICB9O1xuXG4gIEdVSS5DTEFTU19BVVRPX1BMQUNFID0gJ2EnO1xuICBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIgPSAnYWMnO1xuICBHVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbiAgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XID0gJ2NyJztcbiAgR1VJLkNMQVNTX1RPT19UQUxMID0gJ3RhbGxlci10aGFuLXdpbmRvdyc7XG4gIEdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbiAgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTiA9ICdjbG9zZS1idXR0b24nO1xuICBHVUkuQ0xBU1NfRFJBRyA9ICdkcmFnJztcblxuICBHVUkuREVGQVVMVF9XSURUSCA9IDI0NTtcbiAgR1VJLlRFWFRfQ0xPU0VEID0gJ0Nsb3NlIENvbnRyb2xzJztcbiAgR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcblxuICBkb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSAhPT0gJ3RleHQnICYmXG4gICAgICAgIChlLndoaWNoID09PSBISURFX0tFWV9DT0RFIHx8IGUua2V5Q29kZSA9PSBISURFX0tFWV9DT0RFKSkge1xuICAgICAgR1VJLnRvZ2dsZUhpZGUoKTtcbiAgICB9XG5cbiAgfSwgZmFsc2UpO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEdVSS5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0Lmd1aS5HVUkgKi9cbiAgICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSBUaGUgbmV3IGNvbnRyb2xsZXIgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db2xvckNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDb2xvcjogZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbG9yOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBjb250cm9sbGVyXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cbiAgICAgICAgICAvLyBUT0RPIGxpc3RlbmluZz9cbiAgICAgICAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoY29udHJvbGxlci5fX2xpKTtcbiAgICAgICAgICB0aGlzLl9fY29udHJvbGxlcnMuc2xpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlciksIDEpO1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0Lmd1aS5HVUl9IFRoZSBuZXcgZm9sZGVyLlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhpcyBHVUkgYWxyZWFkeSBoYXMgYSBmb2xkZXIgYnkgdGhlIHNwZWNpZmllZFxuICAgICAgICAgKiBuYW1lXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRm9sZGVyOiBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIHByZXZlbnQgY29sbGlzaW9ucyBvbiBuYW1lcyBpbiBvcmRlciB0byBoYXZlIGEga2V5XG4gICAgICAgICAgLy8gYnkgd2hpY2ggdG8gcmVtZW1iZXIgc2F2ZWQgdmFsdWVzXG4gICAgICAgICAgaWYgKHRoaXMuX19mb2xkZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICtcbiAgICAgICAgICAgICAgICAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdfZ3VpX3BhcmFtcyA9IHsgbmFtZTogbmFtZSwgcGFyZW50OiB0aGlzIH07XG5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHBhc3MgZG93biB0aGUgYXV0b1BsYWNlIHRyYWl0IHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0byBvcGVuL2Nsb3NlIGZvbGRlciBhY3Rpb25zIHRvXG4gICAgICAgICAgLy8gZW5zdXJlIHRoYXQgYSBzY3JvbGxiYXIgYXBwZWFycyBpZiB0aGUgd2luZG93IGlzIHRvbyBzaG9ydC5cbiAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5hdXRvUGxhY2UgPSB0aGlzLmF1dG9QbGFjZTtcblxuICAgICAgICAgIC8vIERvIHdlIGhhdmUgc2F2ZWQgYXBwZWFyYW5jZSBkYXRhIGZvciB0aGlzIGZvbGRlcj9cblxuICAgICAgICAgIGlmICh0aGlzLmxvYWQgJiYgLy8gQW55dGhpbmcgbG9hZGVkP1xuICAgICAgICAgICAgICB0aGlzLmxvYWQuZm9sZGVycyAmJiAvLyBXYXMgbXkgcGFyZW50IGEgZGVhZC1lbmQ/XG4gICAgICAgICAgICAgIHRoaXMubG9hZC5mb2xkZXJzW25hbWVdKSB7IC8vIERpZCBkYWRkeSByZW1lbWJlciBtZT9cblxuICAgICAgICAgICAgLy8gU3RhcnQgbWUgY2xvc2VkIGlmIEkgd2FzIGNsb3NlZFxuICAgICAgICAgICAgbmV3X2d1aV9wYXJhbXMuY2xvc2VkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0uY2xvc2VkO1xuXG4gICAgICAgICAgICAvLyBQYXNzIGRvd24gdGhlIGxvYWRlZCBkYXRhXG4gICAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5sb2FkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV07XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdfZ3VpX3BhcmFtcyk7XG4gICAgICAgICAgdGhpcy5fX2ZvbGRlcnNbbmFtZV0gPSBndWk7XG5cbiAgICAgICAgICB2YXIgbGkgPSBhZGRSb3codGhpcywgZ3VpLmRvbUVsZW1lbnQpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2ZvbGRlcicpO1xuICAgICAgICAgIHJldHVybiBndWk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcblxuICAgICAgICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcblxuICAgICAgICAgICAgdmFyIHRvcCA9IGRvbS5nZXRPZmZzZXQocm9vdC5fX3VsKS50b3A7XG4gICAgICAgICAgICB2YXIgaCA9IDA7XG5cbiAgICAgICAgICAgIGNvbW1vbi5lYWNoKHJvb3QuX191bC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmICghIChyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKVxuICAgICAgICAgICAgICAgIGggKz0gZG9tLmdldEhlaWdodChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCA8IGgpIHtcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgKyAncHgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByb290Ll9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQgPSByb290Ll9fdWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyb290Ll9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIHJvb3QuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHJvb3Qud2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIG9iamVjdHMgZm9yIHNhdmluZy4gVGhlIG9yZGVyIG9mIHRoZXNlIG9iamVjdHMgY2Fubm90IGNoYW5nZSBhc1xuICAgICAgICAgKiB0aGUgR1VJIGdyb3dzLiBXaGVuIHJlbWVtYmVyaW5nIG5ldyBvYmplY3RzLCBhcHBlbmQgdGhlbSB0byB0aGUgZW5kXG4gICAgICAgICAqIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC4uLn0gb2JqZWN0c1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm90IGNhbGxlZCBvbiBhIHRvcCBsZXZlbCBHVUkuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtZW1iZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChTQVZFX0RJQUxPR1VFKSkge1xuICAgICAgICAgICAgU0FWRV9ESUFMT0dVRSA9IG5ldyBDZW50ZXJlZERpdigpO1xuICAgICAgICAgICAgU0FWRV9ESUFMT0dVRS5kb21FbGVtZW50LmlubmVySFRNTCA9IHNhdmVEaWFsb2d1ZUNvbnRlbnRzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICBhZGRTYXZlTWVudShfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgICAgICAgIC8vIFNldCBzYXZlIHJvdyB3aWR0aFxuICAgICAgICAgICAgc2V0V2lkdGgodGhpcywgdGhpcy53aWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuZ3VpLkdVSX0gdGhlIHRvcG1vc3QgcGFyZW50IEdVSSBvZiBhIG5lc3RlZCBHVUkuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgICAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBndWk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mXG4gICAgICAgICAqIHRoaXMgR1VJIGFzIHdlbGwgYXMgaXRzIHJlbWVtYmVyZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTYXZlT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciB0b1JldHVybiA9IHRoaXMubG9hZDtcblxuICAgICAgICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuXG4gICAgICAgICAgLy8gQW0gSSByZW1lbWJlcmluZyBhbnkgdmFsdWVzP1xuICAgICAgICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICB0b1JldHVybi5wcmVzZXQgPSB0aGlzLnByZXNldDtcblxuICAgICAgICAgICAgaWYgKCF0b1JldHVybi5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9SZXR1cm4uZm9sZGVycyA9IHt9O1xuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbihlbGVtZW50LCBrZXkpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVBczogZnVuY3Rpb24ocHJlc2V0TmFtZSkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICAgICAgICAvLyBSZXRhaW4gZGVmYXVsdCB2YWx1ZXMgdXBvbiBmaXJzdCBzYXZlXG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtwcmVzZXROYW1lXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgICAgICAgdGhpcy5wcmVzZXQgPSBwcmVzZXROYW1lO1xuICAgICAgICAgIGFkZFByZXNldE9wdGlvbih0aGlzLCBwcmVzZXROYW1lLCB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHJldmVydDogZnVuY3Rpb24oZ3VpKSB7XG5cbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgcmV2ZXJ0IHdvcmsgb24gRGVmYXVsdC5cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRSb290KCkubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUoY29udHJvbGxlci5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjYWxsU2F2ZWRWYWx1ZShndWkgfHwgdGhpcy5nZXRSb290KCksIGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uKGZvbGRlcikge1xuICAgICAgICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFndWkpIHtcbiAgICAgICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLmdldFJvb3QoKSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdGVuOiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cbiAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09IDA7XG4gICAgICAgICAgdGhpcy5fX2xpc3RlbmluZy5wdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIGlmIChpbml0KSB1cGRhdGVEaXNwbGF5cyh0aGlzLl9fbGlzdGVuaW5nKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIGFkZChndWksIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IFwiICsgb2JqZWN0ICsgXCIgaGFzIG5vIHByb3BlcnR5IFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBjb250cm9sbGVyO1xuXG4gICAgaWYgKHBhcmFtcy5jb2xvcikge1xuXG4gICAgICBjb250cm9sbGVyID0gbmV3IENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QscHJvcGVydHldLmNvbmNhdChwYXJhbXMuZmFjdG9yeUFyZ3MpO1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJGYWN0b3J5LmFwcGx5KGd1aSwgZmFjdG9yeUFyZ3MpO1xuXG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgICBwYXJhbXMuYmVmb3JlID0gcGFyYW1zLmJlZm9yZS5fX2xpO1xuICAgIH1cblxuICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKTtcblxuICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG5cbiAgICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgICBuYW1lLmlubmVySFRNTCA9IGNvbnRyb2xsZXIucHJvcGVydHk7XG5cbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5hbWUpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sbGVyLmRvbUVsZW1lbnQpO1xuXG4gICAgdmFyIGxpID0gYWRkUm93KGd1aSwgY29udGFpbmVyLCBwYXJhbXMuYmVmb3JlKTtcblxuICAgIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgICBkb20uYWRkQ2xhc3MobGksIHR5cGVvZiBjb250cm9sbGVyLmdldFZhbHVlKCkpO1xuXG4gICAgYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcik7XG5cbiAgICBndWkuX19jb250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSByb3cgdG8gdGhlIGVuZCBvZiB0aGUgR1VJIG9yIGJlZm9yZSBhbm90aGVyIHJvdy5cbiAgICpcbiAgICogQHBhcmFtIGd1aVxuICAgKiBAcGFyYW0gW2RvbV0gSWYgc3BlY2lmaWVkLCBpbnNlcnRzIHRoZSBkb20gY29udGVudCBpbiB0aGUgbmV3IHJvd1xuICAgKiBAcGFyYW0gW2xpQmVmb3JlXSBJZiBzcGVjaWZpZWQsIHBsYWNlcyB0aGUgbmV3IHJvdyBiZWZvcmUgYW5vdGhlciByb3dcbiAgICovXG4gIGZ1bmN0aW9uIGFkZFJvdyhndWksIGRvbSwgbGlCZWZvcmUpIHtcbiAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGlmIChkb20pIGxpLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgaWYgKGxpQmVmb3JlKSB7XG4gICAgICBndWkuX191bC5pbnNlcnRCZWZvcmUobGksIHBhcmFtcy5iZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBndWkuX191bC5hcHBlbmRDaGlsZChsaSk7XG4gICAgfVxuICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgIHJldHVybiBsaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcblxuICAgIGNvbnRyb2xsZXIuX19saSA9IGxpO1xuICAgIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbnRyb2xsZXIsIHtcblxuICAgICAgb3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNBcnJheShvcHRpb25zKSB8fCBjb21tb24uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW29wdGlvbnNdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgbmFtZTogZnVuY3Rpb24odikge1xuICAgICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gdjtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9LFxuXG4gICAgICBsaXN0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250cm9sbGVyLl9fZ3VpLmxpc3Rlbihjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250cm9sbGVyLl9fZ3VpLnJlbW92ZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIEFsbCBzbGlkZXJzIHNob3VsZCBiZSBhY2NvbXBhbmllZCBieSBhIGJveC5cbiAgICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcblxuICAgICAgdmFyIGJveCA9IG5ldyBOdW1iZXJDb250cm9sbGVyQm94KGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuXG4gICAgICBjb21tb24uZWFjaChbJ3VwZGF0ZURpc3BsYXknLCAnb25DaGFuZ2UnLCAnb25GaW5pc2hDaGFuZ2UnXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBwYyA9IGNvbnRyb2xsZXJbbWV0aG9kXTtcbiAgICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICAgIGNvbnRyb2xsZXJbbWV0aG9kXSA9IGJveFttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIHBjLmFwcGx5KGNvbnRyb2xsZXIsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZG9tLmFkZENsYXNzKGxpLCAnaGFzLXNsaWRlcicpO1xuICAgICAgY29udHJvbGxlci5kb21FbGVtZW50Lmluc2VydEJlZm9yZShib3guZG9tRWxlbWVudCwgY29udHJvbGxlci5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlckJveCkge1xuXG4gICAgICB2YXIgciA9IGZ1bmN0aW9uKHJldHVybmVkKSB7XG5cbiAgICAgICAgLy8gSGF2ZSB3ZSBkZWZpbmVkIGJvdGggYm91bmRhcmllcz9cbiAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWluKSAmJiBjb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21heCkpIHtcblxuICAgICAgICAgIC8vIFdlbGwsIHRoZW4gbGV0cyBqdXN0IHJlcGxhY2UgdGhpcyB3aXRoIGEgc2xpZGVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbnRyb2xsZXIuX19taW4sIGNvbnRyb2xsZXIuX19tYXgsIGNvbnRyb2xsZXIuX19zdGVwXVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybmVkO1xuXG4gICAgICB9O1xuXG4gICAgICBjb250cm9sbGVyLm1pbiA9IGNvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICAgIGNvbnRyb2xsZXIubWF4ID0gY29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5tYXgpO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBCb29sZWFuQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudHMgZG91YmxlLXRvZ2dsZVxuICAgICAgfSlcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRnVuY3Rpb25Db250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fYnV0dG9uLCAnY2xpY2snKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChsaSwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQobGksICdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgICB9KTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkgPSBjb21tb24uY29tcG9zZShmdW5jdGlvbihyKSB7XG4gICAgICAgIGxpLnN0eWxlLmJvcmRlckxlZnRDb2xvciA9IGNvbnRyb2xsZXIuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG5cbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgfVxuXG4gICAgY29udHJvbGxlci5zZXRWYWx1ZSA9IGNvbW1vbi5jb21wb3NlKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGlmIChndWkuZ2V0Um9vdCgpLl9fcHJlc2V0X3NlbGVjdCAmJiBjb250cm9sbGVyLmlzTW9kaWZpZWQoKSkge1xuICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLmdldFJvb3QoKSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBjb250cm9sbGVyLnNldFZhbHVlKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpIHtcblxuICAgIC8vIEZpbmQgdGhlIHRvcG1vc3QgR1VJLCB0aGF0J3Mgd2hlcmUgcmVtZW1iZXJlZCBvYmplY3RzIGxpdmUuXG4gICAgdmFyIHJvb3QgPSBndWkuZ2V0Um9vdCgpO1xuXG4gICAgLy8gRG9lcyB0aGUgb2JqZWN0IHdlJ3JlIGNvbnRyb2xsaW5nIG1hdGNoIGFueXRoaW5nIHdlJ3ZlIGJlZW4gdG9sZCB0b1xuICAgIC8vIHJlbWVtYmVyP1xuICAgIHZhciBtYXRjaGVkX2luZGV4ID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2YoY29udHJvbGxlci5vYmplY3QpO1xuXG4gICAgLy8gV2h5IHllcywgaXQgZG9lcyFcbiAgICBpZiAobWF0Y2hlZF9pbmRleCAhPSAtMSkge1xuXG4gICAgICAvLyBMZXQgbWUgZmV0Y2ggYSBtYXAgb2YgY29udHJvbGxlcnMgZm9yIHRoY29tbW9uLmlzT2JqZWN0LlxuICAgICAgdmFyIGNvbnRyb2xsZXJfbWFwID1cbiAgICAgICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRfaW5kZXhdO1xuXG4gICAgICAvLyBPaHAsIEkgYmVsaWV2ZSB0aGlzIGlzIHRoZSBmaXJzdCBjb250cm9sbGVyIHdlJ3ZlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgIC8vIG9iamVjdC4gTGV0cyBtYWtlIHRoZSBtYXAgZnJlc2guXG4gICAgICBpZiAoY29udHJvbGxlcl9tYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250cm9sbGVyX21hcCA9IHt9O1xuICAgICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRfaW5kZXhdID1cbiAgICAgICAgICAgIGNvbnRyb2xsZXJfbWFwO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoaXMgY29udHJvbGxlclxuICAgICAgY29udHJvbGxlcl9tYXBbY29udHJvbGxlci5wcm9wZXJ0eV0gPSBjb250cm9sbGVyO1xuXG4gICAgICAvLyBPa2F5LCBub3cgaGF2ZSB3ZSBzYXZlZCBhbnkgdmFsdWVzIGZvciB0aGlzIGNvbnRyb2xsZXI/XG4gICAgICBpZiAocm9vdC5sb2FkICYmIHJvb3QubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgICAgdmFyIHByZXNldF9tYXAgPSByb290LmxvYWQucmVtZW1iZXJlZDtcblxuICAgICAgICAvLyBXaGljaCBwcmVzZXQgYXJlIHdlIHRyeWluZyB0byBsb2FkP1xuICAgICAgICB2YXIgcHJlc2V0O1xuXG4gICAgICAgIGlmIChwcmVzZXRfbWFwW2d1aS5wcmVzZXRdKSB7XG5cbiAgICAgICAgICBwcmVzZXQgPSBwcmVzZXRfbWFwW2d1aS5wcmVzZXRdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocHJlc2V0X21hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdKSB7XG5cbiAgICAgICAgICAvLyBVaGgsIHlvdSBjYW4gaGF2ZSB0aGUgZGVmYXVsdCBpbnN0ZWFkP1xuICAgICAgICAgIHByZXNldCA9IHByZXNldF9tYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gTmFkYS5cblxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBEaWQgdGhlIGxvYWRlZCBvYmplY3QgcmVtZW1iZXIgdGhjb21tb24uaXNPYmplY3Q/XG4gICAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZF9pbmRleF0gJiZcblxuICAgICAgICAgIC8vIERpZCB3ZSByZW1lbWJlciB0aGlzIHBhcnRpY3VsYXIgcHJvcGVydHk/XG4gICAgICAgICAgICBwcmVzZXRbbWF0Y2hlZF9pbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgLy8gV2UgZGlkIHJlbWVtYmVyIHNvbWV0aGluZyBmb3IgdGhpcyBndXkgLi4uXG4gICAgICAgICAgdmFyIHZhbHVlID0gcHJlc2V0W21hdGNoZWRfaW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuXG4gICAgICAgICAgLy8gQW5kIHRoYXQncyB3aGF0IGl0IGlzLlxuICAgICAgICAgIGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCBrZXkpIHtcbiAgICAvLyBUT0RPIGhvdyBkb2VzIHRoaXMgZGVhbCB3aXRoIG11bHRpcGxlIEdVSSdzP1xuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcblxuICAgIHZhciBkaXYgPSBndWkuX19zYXZlX3JvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICBkb20uYWRkQ2xhc3MoZ3VpLmRvbUVsZW1lbnQsICdoYXMtc2F2ZScpO1xuXG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG5cbiAgICBkb20uYWRkQ2xhc3MoZGl2LCAnc2F2ZS1yb3cnKTtcblxuICAgIHZhciBnZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBnZWFycy5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcblxuICAgIC8vIFRPRE8gcmVwbGFjZSB3aXRoIEZ1bmN0aW9uQ29udHJvbGxlclxuICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ3NhdmUnKTtcblxuICAgIHZhciBidXR0b24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbjIuaW5uZXJIVE1MID0gJ05ldyc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ3NhdmUtYXMnKTtcblxuICAgIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbjMuaW5uZXJIVE1MID0gJ1JldmVydCc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuXG4gICAgdmFyIHNlbGVjdCA9IGd1aS5fX3ByZXNldF9zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblxuICAgIGlmIChndWkubG9hZCAmJiBndWkubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgIGNvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwga2V5LCBrZXkgPT0gZ3VpLnByZXNldCk7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBkb20uYmluZChzZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblxuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuXG4gICAgfSk7XG5cbiAgICBkaXYuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoZ2VhcnMpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMyk7XG5cbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXG4gICAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG5cbiAgICAgIHNhdmVMb2NhbGx5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICB2YXIgbG9jYWxTdG9yYWdlQ2hlY2tCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtc3RvcmFnZScpO1xuXG4gICAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlQ2hlY2tCb3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvd0hpZGVFeHBsYWluKCkge1xuICAgICAgICBleHBsYWluLnN0eWxlLmRpc3BsYXkgPSBndWkudXNlTG9jYWxTdG9yYWdlID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgIH1cblxuICAgICAgc2hvd0hpZGVFeHBsYWluKCk7XG5cbiAgICAgIC8vIFRPRE86IFVzZSBhIGJvb2xlYW4gY29udHJvbGxlciwgZm9vbCFcbiAgICAgIGRvbS5iaW5kKGxvY2FsU3RvcmFnZUNoZWNrQm94LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgICAgc2hvd0hpZGVFeHBsYWluKCk7XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuXG4gICAgZG9tLmJpbmQobmV3Q29uc3RydWN0b3JUZXh0QXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5tZXRhS2V5ICYmIChlLndoaWNoID09PSA2NyB8fCBlLmtleUNvZGUgPT0gNjcpKSB7XG4gICAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoZ2VhcnMsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgICAgU0FWRV9ESUFMT0dVRS5zaG93KCk7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmZvY3VzKCk7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIGd1aS5zYXZlKCk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24yLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcmVzZXROYW1lID0gcHJvbXB0KCdFbnRlciBhIG5ldyBwcmVzZXQgbmFtZS4nKTtcbiAgICAgIGlmIChwcmVzZXROYW1lKSBndWkuc2F2ZUFzKHByZXNldE5hbWUpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBndWkucmV2ZXJ0KCk7XG4gICAgfSk7XG5cbi8vICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlKGd1aSkge1xuXG4gICAgZ3VpLl9fcmVzaXplX2hhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29tbW9uLmV4dGVuZChndWkuX19yZXNpemVfaGFuZGxlLnN0eWxlLCB7XG5cbiAgICAgIHdpZHRoOiAnNnB4JyxcbiAgICAgIG1hcmdpbkxlZnQ6ICctM3B4JyxcbiAgICAgIGhlaWdodDogJzIwMHB4JyxcbiAgICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuLy8gICAgICBib3JkZXI6ICcxcHggc29saWQgYmx1ZSdcblxuICAgIH0pO1xuXG4gICAgdmFyIHBtb3VzZVg7XG5cbiAgICBkb20uYmluZChndWkuX19yZXNpemVfaGFuZGxlLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG5cbiAgICBndWkuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZ3VpLl9fcmVzaXplX2hhbmRsZSwgZ3VpLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuXG4gICAgICBkb20uYWRkQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhZyhlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgZ3VpLndpZHRoICs9IHBtb3VzZVggLSBlLmNsaWVudFg7XG4gICAgICBndWkub25SZXNpemUoKTtcbiAgICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWdTdG9wKCkge1xuXG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFdpZHRoKGd1aSwgdykge1xuICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgLy8gQXV0byBwbGFjZWQgc2F2ZS1yb3dzIGFyZSBwb3NpdGlvbiBmaXhlZCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHNldCB0aGUgd2lkdGggbWFudWFsbHkgaWYgd2Ugd2FudCBpdCB0byBibGVlZCB0byB0aGUgZWRnZVxuICAgIGlmIChndWkuX19zYXZlX3JvdyAmJiBndWkuYXV0b1BsYWNlKSB7XG4gICAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIH1pZiAoZ3VpLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFByZXNldChndWksIHVzZUluaXRpYWxWYWx1ZXMpIHtcblxuICAgIHZhciB0b1JldHVybiA9IHt9O1xuXG4gICAgLy8gRm9yIGVhY2ggb2JqZWN0IEknbSByZW1lbWJlcmluZ1xuICAgIGNvbW1vbi5lYWNoKGd1aS5fX3JlbWVtYmVyZWRPYmplY3RzLCBmdW5jdGlvbih2YWwsIGluZGV4KSB7XG5cbiAgICAgIHZhciBzYXZlZF92YWx1ZXMgPSB7fTtcblxuICAgICAgLy8gVGhlIGNvbnRyb2xsZXJzIEkndmUgbWFkZSBmb3IgdGhjb21tb24uaXNPYmplY3QgYnkgcHJvcGVydHlcbiAgICAgIHZhciBjb250cm9sbGVyX21hcCA9XG4gICAgICAgICAgZ3VpLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW2luZGV4XTtcblxuICAgICAgLy8gUmVtZW1iZXIgZWFjaCB2YWx1ZSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgY29tbW9uLmVhY2goY29udHJvbGxlcl9tYXAsIGZ1bmN0aW9uKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICAgIHNhdmVkX3ZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2F2ZSB0aGUgdmFsdWVzIGZvciB0aGNvbW1vbi5pc09iamVjdFxuICAgICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRfdmFsdWVzO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFByZXNldE9wdGlvbihndWksIG5hbWUsIHNldFNlbGVjdGVkKSB7XG4gICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIG9wdC5pbm5lckhUTUwgPSBuYW1lO1xuICAgIG9wdC52YWx1ZSA9IG5hbWU7XG4gICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICAgIGlmIChzZXRTZWxlY3RlZCkge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByZXNldFNlbGVjdEluZGV4KGd1aSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09IGd1aS5wcmVzZXQpIHtcbiAgICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1ByZXNldE1vZGlmaWVkKGd1aSwgbW9kaWZpZWQpIHtcbiAgICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuLy8gICAgY29uc29sZS5sb2coJ21hcmsnLCBtb2RpZmllZCwgb3B0KTtcbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWUgKyBcIipcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpIHtcblxuXG4gICAgaWYgKGNvbnRyb2xsZXJBcnJheS5sZW5ndGggIT0gMCkge1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSk7XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIGNvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24oYykge1xuICAgICAgYy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIHJldHVybiBHVUk7XG5cbn0pKGRhdC51dGlscy5jc3MsXG5cIjxkaXYgaWQ9XFxcImRnLXNhdmVcXFwiIGNsYXNzPVxcXCJkZyBkaWFsb2d1ZVxcXCI+XFxuXFxuICBIZXJlJ3MgdGhlIG5ldyBsb2FkIHBhcmFtZXRlciBmb3IgeW91ciA8Y29kZT5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3I6XFxuXFxuICA8dGV4dGFyZWEgaWQ9XFxcImRnLW5ldy1jb25zdHJ1Y3RvclxcXCI+PC90ZXh0YXJlYT5cXG5cXG4gIDxkaXYgaWQ9XFxcImRnLXNhdmUtbG9jYWxseVxcXCI+XFxuXFxuICAgIDxpbnB1dCBpZD1cXFwiZGctbG9jYWwtc3RvcmFnZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiLz4gQXV0b21hdGljYWxseSBzYXZlXFxuICAgIHZhbHVlcyB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IG9uIGV4aXQuXFxuXFxuICAgIDxkaXYgaWQ9XFxcImRnLWxvY2FsLWV4cGxhaW5cXFwiPlRoZSB2YWx1ZXMgc2F2ZWQgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiB3aWxsXFxuICAgICAgb3ZlcnJpZGUgdGhvc2UgcGFzc2VkIHRvIDxjb2RlPmRhdC5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3IuIFRoaXMgbWFrZXMgaXRcXG4gICAgICBlYXNpZXIgdG8gd29yayBpbmNyZW1lbnRhbGx5LCBidXQgPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpcyBmcmFnaWxlLFxcbiAgICAgIGFuZCB5b3VyIGZyaWVuZHMgbWF5IG5vdCBzZWUgdGhlIHNhbWUgdmFsdWVzIHlvdSBkby5cXG4gICAgICBcXG4gICAgPC9kaXY+XFxuICAgIFxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCIsXG5cIi5kZyB1bHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO3dpZHRoOjEwMCU7Y2xlYXI6Ym90aH0uZGcuYWN7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjA7ei1pbmRleDowfS5kZzpub3QoLmFjKSAubWFpbntvdmVyZmxvdzpoaWRkZW59LmRnLm1haW57LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO2JvcmRlcjowO3Bvc2l0aW9uOmFic29sdXRlO2xpbmUtaGVpZ2h0OjE5cHg7aGVpZ2h0OjIwcHg7Y3Vyc29yOnBvaW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDAwfS5kZy5tYWluIC5jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTExfS5kZy5he2Zsb2F0OnJpZ2h0O21hcmdpbi1yaWdodDoxNXB4O292ZXJmbG93LXg6aGlkZGVufS5kZy5hLmhhcy1zYXZlIHVse21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZSB1bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3twb3NpdGlvbjpmaXhlZDt0b3A6MDt6LWluZGV4OjEwMDJ9LmRnIGxpey13ZWJraXQtdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0Oy1tb3otdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDt0cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0fS5kZyBsaTpub3QoLmZvbGRlcil7Y3Vyc29yOmF1dG87aGVpZ2h0OjI3cHg7bGluZS1oZWlnaHQ6MjdweDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowIDRweCAwIDVweH0uZGcgbGkuZm9sZGVye3BhZGRpbmc6MDtib3JkZXItbGVmdDo0cHggc29saWQgcmdiYSgwLDAsMCwwKX0uZGcgbGkudGl0bGV7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWxlZnQ6LTRweH0uZGcgLmNsb3NlZCBsaTpub3QoLnRpdGxlKSwuZGcgLmNsb3NlZCB1bCBsaSwuZGcgLmNsb3NlZCB1bCBsaSA+ICp7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjowfS5kZyAuY3J7Y2xlYXI6Ym90aDtwYWRkaW5nLWxlZnQ6M3B4O2hlaWdodDoyN3B4fS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3tmbG9hdDpsZWZ0O3dpZHRoOjYwJX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtib3JkZXI6MDttYXJnaW4tdG9wOjRweDtwYWRkaW5nOjNweDt3aWR0aDoxMDAlO2Zsb2F0OnJpZ2h0fS5kZyAuaGFzLXNsaWRlciBpbnB1dFt0eXBlPXRleHRde3dpZHRoOjMwJTttYXJnaW4tbGVmdDowfS5kZyAuc2xpZGVye2Zsb2F0OmxlZnQ7d2lkdGg6NjYlO21hcmdpbi1sZWZ0Oi01cHg7bWFyZ2luLXJpZ2h0OjA7aGVpZ2h0OjE5cHg7bWFyZ2luLXRvcDo0cHh9LmRnIC5zbGlkZXItZmd7aGVpZ2h0OjEwMCV9LmRnIC5jIGlucHV0W3R5cGU9Y2hlY2tib3hde21hcmdpbi10b3A6OXB4fS5kZyAuYyBzZWxlY3R7bWFyZ2luLXRvcDo1cHh9LmRnIC5jci5mdW5jdGlvbiwuZGcgLmNyLmZ1bmN0aW9uIC5wcm9wZXJ0eS1uYW1lLC5kZyAuY3IuZnVuY3Rpb24gKiwuZGcgLmNyLmJvb2xlYW4sLmRnIC5jci5ib29sZWFuICp7Y3Vyc29yOnBvaW50ZXJ9LmRnIC5zZWxlY3RvcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWxlZnQ6LTlweDttYXJnaW4tdG9wOjIzcHg7ei1pbmRleDoxMH0uZGcgLmM6aG92ZXIgLnNlbGVjdG9yLC5kZyAuc2VsZWN0b3IuZHJhZ3tkaXNwbGF5OmJsb2NrfS5kZyBsaS5zYXZlLXJvd3twYWRkaW5nOjB9LmRnIGxpLnNhdmUtcm93IC5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzowcHggNnB4fS5kZy5kaWFsb2d1ZXtiYWNrZ3JvdW5kLWNvbG9yOiMyMjI7d2lkdGg6NDYwcHg7cGFkZGluZzoxNXB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE1cHh9I2RnLW5ldy1jb25zdHJ1Y3RvcntwYWRkaW5nOjEwcHg7Y29sb3I6IzIyMjtmb250LWZhbWlseTpNb25hY28sIG1vbm9zcGFjZTtmb250LXNpemU6MTBweDtib3JkZXI6MDtyZXNpemU6bm9uZTtib3gtc2hhZG93Omluc2V0IDFweCAxcHggMXB4ICM4ODg7d29yZC13cmFwOmJyZWFrLXdvcmQ7bWFyZ2luOjEycHggMDtkaXNwbGF5OmJsb2NrO3dpZHRoOjQ0MHB4O292ZXJmbG93LXk6c2Nyb2xsO2hlaWdodDoxMDBweDtwb3NpdGlvbjpyZWxhdGl2ZX0jZGctbG9jYWwtZXhwbGFpbntkaXNwbGF5Om5vbmU7Zm9udC1zaXplOjExcHg7bGluZS1oZWlnaHQ6MTdweDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo4cHg7bWFyZ2luLXRvcDoxMHB4fSNkZy1sb2NhbC1leHBsYWluIGNvZGV7Zm9udC1zaXplOjEwcHh9I2RhdC1ndWktc2F2ZS1sb2NhbGx5e2Rpc3BsYXk6bm9uZX0uZGd7Y29sb3I6I2VlZTtmb250OjExcHggJ0x1Y2lkYSBHcmFuZGUnLCBzYW5zLXNlcmlmO3RleHQtc2hhZG93OjAgLTFweCAwICMxMTF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjVweDtiYWNrZ3JvdW5kOiMxYTFhMWF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lcntoZWlnaHQ6MDtkaXNwbGF5Om5vbmV9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6IzY3Njc2N30uZGcgbGk6bm90KC5mb2xkZXIpe2JhY2tncm91bmQ6IzFhMWExYTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMmMyYzJjfS5kZyBsaS5zYXZlLXJvd3tsaW5lLWhlaWdodDoyNXB4O2JhY2tncm91bmQ6I2RhZDVjYjtib3JkZXI6MH0uZGcgbGkuc2F2ZS1yb3cgc2VsZWN0e21hcmdpbi1sZWZ0OjVweDt3aWR0aDoxMDhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbnttYXJnaW4tbGVmdDo1cHg7bWFyZ2luLXRvcDoxcHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1zaXplOjlweDtsaW5lLWhlaWdodDo3cHg7cGFkZGluZzo0cHggNHB4IDVweCA0cHg7YmFja2dyb3VuZDojYzViZGFkO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAxcHggMCAjYjBhNThmO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4ZjtjdXJzb3I6cG9pbnRlcn0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbi5nZWFyc3tiYWNrZ3JvdW5kOiNjNWJkYWQgdXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXNBQUFBTkNBWUFBQUIvOVpRN0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBUUpKUkVGVWVOcGlZS0FVL1AvL1B3R0lDL0FwQ0FCaUJTQVcrSThBQ2xBY2dLeFE0VDlob01BRVVyeHgyUVNHTjYrZWdEWCsvdldUNGU3TjgyQU1Zb1BBeC9ldndXb1lvU1liQUNYMnM3S3hDeHpjc2V6RGgzZXZGb0RFQllURUVxeWNnZ1dBekE5QXVVU1FRZ2VZUGE5ZlB2Ni9ZV20vQWN4NUlQYjd0eS9mdytRWmJsdzY3dkRzOFIwWUh5UWhnT2J4K3lBSmtCcW1HNWRQUERoMWFQT0dSL2V1Z1cwRzR2bElvVElmeUZjQStRZWtoaEhKaFBkUXhiaUFJZ3VNQlRRWnJQRDcxMDhNNnJvV1lERlFpSUFBdjZBb3cvMWJGd1hnaXMrZjJMVUF5bndvSWFOY3o4WE54M0RsN01FSlVER1FweDlndFE4WUN1ZUIrRDI2T0VDQUFRRGFkdDdlNDZENDJRQUFBQUJKUlU1RXJrSmdnZz09KSAycHggMXB4IG5vLXJlcGVhdDtoZWlnaHQ6N3B4O3dpZHRoOjhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNiYWIxOWU7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmfS5kZyBsaS5mb2xkZXJ7Ym9yZGVyLWJvdHRvbTowfS5kZyBsaS50aXRsZXtwYWRkaW5nLWxlZnQ6MTZweDtiYWNrZ3JvdW5kOiMwMDAgdXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsSStoS2dGeG9DZ0FPdz09KSA2cHggMTBweCBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpfS5kZyAuY2xvc2VkIGxpLnRpdGxle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsR0lXcU1DYldBRUFPdz09KX0uZGcgLmNyLmJvb2xlYW57Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICM4MDY3ODd9LmRnIC5jci5mdW5jdGlvbntib3JkZXItbGVmdDozcHggc29saWQgI2U2MWQ1Zn0uZGcgLmNyLm51bWJlcntib3JkZXItbGVmdDozcHggc29saWQgIzJmYTFkNn0uZGcgLmNyLm51bWJlciBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMyZmExZDZ9LmRnIC5jci5zdHJpbmd7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMxZWQzNmZ9LmRnIC5jci5zdHJpbmcgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMWVkMzZmfS5kZyAuY3IuZnVuY3Rpb246aG92ZXIsLmRnIC5jci5ib29sZWFuOmhvdmVye2JhY2tncm91bmQ6IzExMX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtiYWNrZ3JvdW5kOiMzMDMwMzA7b3V0bGluZTpub25lfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpmb2N1c3tiYWNrZ3JvdW5kOiM0OTQ5NDk7Y29sb3I6I2ZmZn0uZGcgLmMgLnNsaWRlcntiYWNrZ3JvdW5kOiMzMDMwMzA7Y3Vyc29yOmV3LXJlc2l6ZX0uZGcgLmMgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiMyZmExZDZ9LmRnIC5jIC5zbGlkZXI6aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyAuc2xpZGVyOmhvdmVyIC5zbGlkZXItZmd7YmFja2dyb3VuZDojNDRhYmRhfVxcblwiLFxuZGF0LmNvbnRyb2xsZXJzLmZhY3RvcnkgPSAoZnVuY3Rpb24gKE9wdGlvbkNvbnRyb2xsZXIsIE51bWJlckNvbnRyb2xsZXJCb3gsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIFN0cmluZ0NvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgQm9vbGVhbkNvbnRyb2xsZXIsIGNvbW1vbikge1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXG4gICAgICAgIC8vIFByb3ZpZGluZyBvcHRpb25zP1xuICAgICAgICBpZiAoY29tbW9uLmlzQXJyYXkoYXJndW1lbnRzWzJdKSB8fCBjb21tb24uaXNPYmplY3QoYXJndW1lbnRzWzJdKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvdmlkaW5nIGEgbWFwP1xuXG4gICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoaW5pdGlhbFZhbHVlKSkge1xuXG4gICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIGNvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG5cbiAgICAgICAgICAgIC8vIEhhcyBtaW4gYW5kIG1heC5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10gfSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNGdW5jdGlvbihpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0Jvb2xlYW4oaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSkoZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCxcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuZGF0LmNvbnRyb2xsZXJzLlN0cmluZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIHRleHQgaW5wdXQgdG8gYWx0ZXIgdGhlIHN0cmluZyBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgU3RyaW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG5cbiAgfTtcblxuICBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBTdG9wcyB0aGUgY2FyZXQgZnJvbSBtb3Zpbmcgb24gYWNjb3VudCBvZjpcbiAgICAgICAgICAvLyBrZXl1cCAtPiBzZXRWYWx1ZSAtPiB1cGRhdGVEaXNwbGF5XG4gICAgICAgICAgaWYgKCFkb20uaXNBY3RpdmUodGhpcy5fX2lucHV0KSkge1xuICAgICAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94LFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG5kYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Db2xvckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgQ29sb3IsIGludGVycHJldCwgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIENvbG9yQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB0aGlzLl9fY29sb3IgPSBuZXcgQ29sb3IodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICB0aGlzLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcblxuICAgIHRoaXMuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5jbGFzc05hbWUgPSAnc2VsZWN0b3InO1xuXG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5jbGFzc05hbWUgPSAnc2F0dXJhdGlvbi1maWVsZCc7XG5cbiAgICB0aGlzLl9fZmllbGRfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgPSAnMnB4IHNvbGlkICc7XG5cbiAgICB0aGlzLl9faHVlX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9faHVlX2tub2IuY2xhc3NOYW1lID0gJ2h1ZS1rbm9iJztcblxuICAgIHRoaXMuX19odWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyA9ICcwIDFweCAxcHggJztcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykgeyAvLyBvbiBlbnRlclxuICAgICAgICBvbkJsdXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICBkb21cbiAgICAgICAgLmFkZENsYXNzKHRoaXMsICdkcmFnJylcbiAgICAgICAgLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHZhciB2YWx1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAodGhpcy5fX2NvbG9yLnYgPCAuNSA/ICcjZmZmJyA6ICcjMDAwJyksXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcbiAgICBcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19odWVfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMnB4JyxcbiAgICAgIGJvcmRlclJpZ2h0OiAnNHB4IHNvbGlkICNmZmYnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMHB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnM3B4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodmFsdWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuICAgIH0pO1xuICAgIFxuICAgIGxpbmVhckdyYWRpZW50KHZhbHVlX2ZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBjdXJzb3I6ICducy1yZXNpemUnXG4gICAgfSk7XG5cbiAgICBodWVHcmFkaWVudCh0aGlzLl9faHVlX2ZpZWxkKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4vLyAgICAgIHdpZHRoOiAnMTIwcHgnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbi8vICAgICAgcGFkZGluZzogJzRweCcsXG4vLyAgICAgIG1hcmdpbkJvdHRvbTogJzZweCcsXG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgwLDAsMCwwLjcpJ1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKHRoaXMuX19maWVsZF9rbm9iLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19odWVfZmllbGQsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kSCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdub25lJztcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRTVik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kU1YoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZFNWKTtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMudmFsdWUpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLl9fY29sb3IuX19zdGF0ZSA9IGk7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kSCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRIKTtcbiAgICB9XG5cbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZV9maWVsZCk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19maWVsZF9rbm9iKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9faHVlX2ZpZWxkKTtcbiAgICB0aGlzLl9faHVlX2ZpZWxkLmFwcGVuZENoaWxkKHRoaXMuX19odWVfa25vYik7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3NlbGVjdG9yKTtcblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZnVuY3Rpb24gc2V0U1YoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciB3ID0gZG9tLmdldFdpZHRoKF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgICB2YXIgbyA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICAgIHZhciBzID0gKGUuY2xpZW50WCAtIG8ubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCkgLyB3O1xuICAgICAgdmFyIHYgPSAxIC0gKGUuY2xpZW50WSAtIG8udG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC8gdztcblxuICAgICAgaWYgKHYgPiAxKSB2ID0gMTtcbiAgICAgIGVsc2UgaWYgKHYgPCAwKSB2ID0gMDtcblxuICAgICAgaWYgKHMgPiAxKSBzID0gMTtcbiAgICAgIGVsc2UgaWYgKHMgPCAwKSBzID0gMDtcblxuICAgICAgX3RoaXMuX19jb2xvci52ID0gdjtcbiAgICAgIF90aGlzLl9fY29sb3IucyA9IHM7XG5cbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblxuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgcyA9IGRvbS5nZXRIZWlnaHQoX3RoaXMuX19odWVfZmllbGQpO1xuICAgICAgdmFyIG8gPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9faHVlX2ZpZWxkKTtcbiAgICAgIHZhciBoID0gMSAtIChlLmNsaWVudFkgLSBvLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSAvIHM7XG5cbiAgICAgIGlmIChoID4gMSkgaCA9IDE7XG4gICAgICBlbHNlIGlmIChoIDwgMCkgaCA9IDA7XG5cbiAgICAgIF90aGlzLl9fY29sb3IuaCA9IGggKiAzNjA7XG5cbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgQ29sb3JDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIENvbG9yQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy5nZXRWYWx1ZSgpKTtcblxuICAgICAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuXG4gICAgICAgICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1pc21hdGNoIG9uIHRoZSBpbnRlcnByZXRlZCB2YWx1ZS5cblxuICAgICAgICAgICAgY29tbW9uLmVhY2goQ29sb3IuQ09NUE9ORU5UUywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIGlmICghY29tbW9uLmlzVW5kZWZpbmVkKGlbY29tcG9uZW50XSkgJiZcbiAgICAgICAgICAgICAgICAgICFjb21tb24uaXNVbmRlZmluZWQodGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkgJiZcbiAgICAgICAgICAgICAgICAgIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307IC8vIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBJZiBub3RoaW5nIGRpdmVyZ2VzLCB3ZSBrZWVwIG91ciBwcmV2aW91cyB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGZvciBzdGF0ZWZ1bG5lc3MsIG90aGVyd2lzZSB3ZSByZWNhbGN1bGF0ZSBmcmVzaFxuICAgICAgICAgICAgaWYgKG1pc21hdGNoKSB7XG4gICAgICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fdGVtcC5fX3N0YXRlLCB0aGlzLl9fY29sb3IuX19zdGF0ZSk7XG5cbiAgICAgICAgICB0aGlzLl9fdGVtcC5hID0gMTtcblxuICAgICAgICAgIHZhciBmbGlwID0gKHRoaXMuX19jb2xvci52IDwgLjUgfHwgdGhpcy5fX2NvbG9yLnMgPiAuNSkgPyAyNTUgOiAwO1xuICAgICAgICAgIHZhciBfZmxpcCA9IDI1NSAtIGZsaXA7XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAxMDAgKiAoMSAtIHRoaXMuX19jb2xvci52KSAtIDcgKyAncHgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fdGVtcC50b1N0cmluZygpLFxuICAgICAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKycpJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4J1xuXG4gICAgICAgICAgdGhpcy5fX3RlbXAucyA9IDE7XG4gICAgICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG5cbiAgICAgICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsnKScsXG4gICAgICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKycsLjcpJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG4gIFxuICB2YXIgdmVuZG9ycyA9IFsnLW1vei0nLCctby0nLCctd2Via2l0LScsJy1tcy0nLCcnXTtcbiAgXG4gIGZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICBjb21tb24uZWFjaCh2ZW5kb3JzLCBmdW5jdGlvbih2ZW5kb3IpIHtcbiAgICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogJyArIHZlbmRvciArICdsaW5lYXItZ3JhZGllbnQoJyt4KycsICcrYSsnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGh1ZUdyYWRpZW50KGVsZW0pIHtcbiAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgfVxuXG5cbiAgcmV0dXJuIENvbG9yQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC5jb2xvci5Db2xvciA9IChmdW5jdGlvbiAoaW50ZXJwcmV0LCBtYXRoLCB0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyAnRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcblxuXG4gIH07XG5cbiAgQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsJ2cnLCdiJywnaCcsJ3MnLCd2JywnaGV4JywnYSddO1xuXG4gIGNvbW1vbi5leHRlbmQoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfSxcblxuICAgIHRvT3JpZ2luYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuXG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gbWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUkdCKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblxuICAgICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gbWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblxuICAgICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBtYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhyb3cgJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZSc7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlSFNWKGNvbG9yKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gbWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLFxuICAgICAgICB7XG4gICAgICAgICAgczogcmVzdWx0LnMsXG4gICAgICAgICAgdjogcmVzdWx0LnZcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICAgIH0gZWxzZSBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29sb3I7XG5cbn0pKGRhdC5jb2xvci5pbnRlcnByZXQsXG5kYXQuY29sb3IubWF0aCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRtcENvbXBvbmVudDtcblxuICByZXR1cm4ge1xuXG4gICAgaHN2X3RvX3JnYjogZnVuY3Rpb24oaCwgcywgdikge1xuXG4gICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuXG4gICAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxLjAgLSAoZiAqIHMpKTtcbiAgICAgIHZhciB0ID0gdiAqICgxLjAgLSAoKDEuMCAtIGYpICogcykpO1xuICAgICAgdmFyIGMgPSBbXG4gICAgICAgIFt2LCB0LCBwXSxcbiAgICAgICAgW3EsIHYsIHBdLFxuICAgICAgICBbcCwgdiwgdF0sXG4gICAgICAgIFtwLCBxLCB2XSxcbiAgICAgICAgW3QsIHAsIHZdLFxuICAgICAgICBbdiwgcCwgcV1cbiAgICAgIF1baGldO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdICogMjU1LFxuICAgICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgICBiOiBjWzJdICogMjU1XG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIHJnYl90b19oc3Y6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblxuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgIGgsIHM7XG5cbiAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IE5hTixcbiAgICAgICAgICBzOiAwLFxuICAgICAgICAgIHY6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIgPT0gbWF4KSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBoICogMzYwLFxuICAgICAgICBzOiBzLFxuICAgICAgICB2OiBtYXggLyAyNTVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJnYl90b19oZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgICAgcmV0dXJuIGhleDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgICByZXR1cm4gKGhleCA+PiAoY29tcG9uZW50SW5kZXggKiA4KSkgJiAweEZGO1xuICAgIH0sXG5cbiAgICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCAoaGV4ICYgfiAoMHhGRiA8PCB0bXBDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgfVxuXG59KSgpLFxuZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29sb3IuaW50ZXJwcmV0LFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogcmVxdWlyZWpzIHZlcnNpb24gb2YgUGF1bCBJcmlzaCdzIFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKi9cblxuICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcblxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcblxuICAgICAgfTtcbn0pKCksXG5kYXQuZG9tLkNlbnRlcmVkRGl2ID0gKGZ1bmN0aW9uIChkb20sIGNvbW1vbikge1xuXG5cbiAgdmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLCB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDAnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuXG4gICAgZG9tLm1ha2VGdWxsc2NyZWVuKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG5cblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBkb20uYmluZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLmhpZGUoKTtcbiAgICB9KTtcblxuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgXG5cblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc1MiUnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG5cbiAgICB0aGlzLmxheW91dCgpO1xuXG4gICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICAgIH0pO1xuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuXG4gICAgfTtcblxuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4vLyAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzQ4JSc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmxlZnQgPSB3aW5kb3cuaW5uZXJXaWR0aC8yIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gd2luZG93LmlubmVySGVpZ2h0LzIgLSBkb20uZ2V0SGVpZ2h0KHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIGxvY2tTY3JvbGwoZSkge1xuICAgIGNvbnNvbGUubG9nKGUpO1xuICB9XG5cbiAgcmV0dXJuIENlbnRlcmVkRGl2O1xuXG59KShkYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTsiLCIvKiEgQGxpY2Vuc2UgRmlyZWJhc2UgdjIuMS4yIC0gTGljZW5zZTogaHR0cHM6Ly93d3cuZmlyZWJhc2UuY29tL3Rlcm1zL3Rlcm1zLW9mLXNlcnZpY2UuaHRtbCAqLyAoZnVuY3Rpb24oKSB7dmFyIGgsYWE9dGhpcztmdW5jdGlvbiBtKGEpe3JldHVybiB2b2lkIDAhPT1hfWZ1bmN0aW9uIGJhKCl7fWZ1bmN0aW9uIGNhKGEpe2EuTmI9ZnVuY3Rpb24oKXtyZXR1cm4gYS5rZj9hLmtmOmEua2Y9bmV3IGF9fVxuZnVuY3Rpb24gZGEoYSl7dmFyIGI9dHlwZW9mIGE7aWYoXCJvYmplY3RcIj09YilpZihhKXtpZihhIGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuXCJhcnJheVwiO2lmKGEgaW5zdGFuY2VvZiBPYmplY3QpcmV0dXJuIGI7dmFyIGM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO2lmKFwiW29iamVjdCBXaW5kb3ddXCI9PWMpcmV0dXJuXCJvYmplY3RcIjtpZihcIltvYmplY3QgQXJyYXldXCI9PWN8fFwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuc3BsaWNlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpcmV0dXJuXCJhcnJheVwiO2lmKFwiW29iamVjdCBGdW5jdGlvbl1cIj09Y3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuY2FsbCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSlyZXR1cm5cImZ1bmN0aW9uXCJ9ZWxzZSByZXR1cm5cIm51bGxcIjtcbmVsc2UgaWYoXCJmdW5jdGlvblwiPT1iJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgYS5jYWxsKXJldHVyblwib2JqZWN0XCI7cmV0dXJuIGJ9ZnVuY3Rpb24gZWEoYSl7cmV0dXJuXCJhcnJheVwiPT1kYShhKX1mdW5jdGlvbiBmYShhKXt2YXIgYj1kYShhKTtyZXR1cm5cImFycmF5XCI9PWJ8fFwib2JqZWN0XCI9PWImJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aH1mdW5jdGlvbiBwKGEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGdhKGEpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGhhKGEpe3JldHVyblwiZnVuY3Rpb25cIj09ZGEoYSl9ZnVuY3Rpb24gaWEoYSl7dmFyIGI9dHlwZW9mIGE7cmV0dXJuXCJvYmplY3RcIj09YiYmbnVsbCE9YXx8XCJmdW5jdGlvblwiPT1ifWZ1bmN0aW9uIGphKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfVxuZnVuY3Rpb24ga2EoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gcShhLGIsYyl7cT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCYmLTEhPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpP2phOmthO3JldHVybiBxLmFwcGx5KG51bGwsYXJndW1lbnRzKX12YXIgbGE9RGF0ZS5ub3d8fGZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfTtcbmZ1bmN0aW9uIG1hKGEsYil7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT1iLnByb3RvdHlwZTthLkpnPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBjO2EuRmc9ZnVuY3Rpb24oYSxjLGYpe3JldHVybiBiLnByb3RvdHlwZVtjXS5hcHBseShhLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSl9fTtmdW5jdGlvbiBuYShhKXthPVN0cmluZyhhKTtpZigvXlxccyokLy50ZXN0KGEpPzA6L15bXFxdLDp7fVxcc1xcdTIwMjhcXHUyMDI5XSokLy50ZXN0KGEucmVwbGFjZSgvXFxcXFtcIlxcXFxcXC9iZm5ydHVdL2csXCJAXCIpLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOVxceDAwLVxceDA4XFx4MGEtXFx4MWZdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLFwiXVwiKS5yZXBsYWNlKC8oPzpefDp8LCkoPzpbXFxzXFx1MjAyOFxcdTIwMjldKlxcWykrL2csXCJcIikpKXRyeXtyZXR1cm4gZXZhbChcIihcIithK1wiKVwiKX1jYXRjaChiKXt9dGhyb3cgRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RyaW5nOiBcIithKTt9ZnVuY3Rpb24gb2EoKXt0aGlzLkhkPXZvaWQgMH1cbmZ1bmN0aW9uIHBhKGEsYixjKXtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJzdHJpbmdcIjpxYShiLGMpO2JyZWFrO2Nhc2UgXCJudW1iZXJcIjpjLnB1c2goaXNGaW5pdGUoYikmJiFpc05hTihiKT9iOlwibnVsbFwiKTticmVhaztjYXNlIFwiYm9vbGVhblwiOmMucHVzaChiKTticmVhaztjYXNlIFwidW5kZWZpbmVkXCI6Yy5wdXNoKFwibnVsbFwiKTticmVhaztjYXNlIFwib2JqZWN0XCI6aWYobnVsbD09Yil7Yy5wdXNoKFwibnVsbFwiKTticmVha31pZihlYShiKSl7dmFyIGQ9Yi5sZW5ndGg7Yy5wdXNoKFwiW1wiKTtmb3IodmFyIGU9XCJcIixmPTA7ZjxkO2YrKyljLnB1c2goZSksZT1iW2ZdLHBhKGEsYS5IZD9hLkhkLmNhbGwoYixTdHJpbmcoZiksZSk6ZSxjKSxlPVwiLFwiO2MucHVzaChcIl1cIik7YnJlYWt9Yy5wdXNoKFwie1wiKTtkPVwiXCI7Zm9yKGYgaW4gYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixmKSYmKGU9YltmXSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYoYy5wdXNoKGQpLHFhKGYsYyksXG5jLnB1c2goXCI6XCIpLHBhKGEsYS5IZD9hLkhkLmNhbGwoYixmLGUpOmUsYyksZD1cIixcIikpO2MucHVzaChcIn1cIik7YnJlYWs7Y2FzZSBcImZ1bmN0aW9uXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZTogXCIrdHlwZW9mIGIpO319dmFyIHJhPXsnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIixcIi9cIjpcIlxcXFwvXCIsXCJcXGJcIjpcIlxcXFxiXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXHJcIjpcIlxcXFxyXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LHNhPS9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKT8vW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHVmZmZmXS9nOi9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceGZmXS9nO1xuZnVuY3Rpb24gcWEoYSxiKXtiLnB1c2goJ1wiJyxhLnJlcGxhY2Uoc2EsZnVuY3Rpb24oYSl7aWYoYSBpbiByYSlyZXR1cm4gcmFbYV07dmFyIGI9YS5jaGFyQ29kZUF0KDApLGU9XCJcXFxcdVwiOzE2PmI/ZSs9XCIwMDBcIjoyNTY+Yj9lKz1cIjAwXCI6NDA5Nj5iJiYoZSs9XCIwXCIpO3JldHVybiByYVthXT1lK2IudG9TdHJpbmcoMTYpfSksJ1wiJyl9O2Z1bmN0aW9uIHRhKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgSlNPTiYmbShKU09OLnBhcnNlKT9KU09OLnBhcnNlKGEpOm5hKGEpfWZ1bmN0aW9uIHIoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBKU09OJiZtKEpTT04uc3RyaW5naWZ5KSlhPUpTT04uc3RyaW5naWZ5KGEpO2Vsc2V7dmFyIGI9W107cGEobmV3IG9hLGEsYik7YT1iLmpvaW4oXCJcIil9cmV0dXJuIGF9O2Z1bmN0aW9uIHMoYSxiKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYil9ZnVuY3Rpb24gdChhLGIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGIpKXJldHVybiBhW2JdfWZ1bmN0aW9uIHVhKGEsYil7Zm9yKHZhciBjIGluIGEpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYykmJmIoYyxhW2NdKX1mdW5jdGlvbiB2YShhKXt2YXIgYj17fTt1YShhLGZ1bmN0aW9uKGEsZCl7YlthXT1kfSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIHdhKGEpe3RoaXMudWM9YTt0aGlzLkVkPVwiZmlyZWJhc2U6XCJ9aD13YS5wcm90b3R5cGU7aC5zZXQ9ZnVuY3Rpb24oYSxiKXtudWxsPT1iP3RoaXMudWMucmVtb3ZlSXRlbSh0aGlzLkVkK2EpOnRoaXMudWMuc2V0SXRlbSh0aGlzLkVkK2EscihiKSl9O2guZ2V0PWZ1bmN0aW9uKGEpe2E9dGhpcy51Yy5nZXRJdGVtKHRoaXMuRWQrYSk7cmV0dXJuIG51bGw9PWE/bnVsbDp0YShhKX07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7dGhpcy51Yy5yZW1vdmVJdGVtKHRoaXMuRWQrYSl9O2gubGY9ITE7aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVjLnRvU3RyaW5nKCl9O2Z1bmN0aW9uIHhhKCl7dGhpcy5vYz17fX14YS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7bnVsbD09Yj9kZWxldGUgdGhpcy5vY1thXTp0aGlzLm9jW2FdPWJ9O3hhLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHModGhpcy5vYyxhKT90aGlzLm9jW2FdOm51bGx9O3hhLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMub2NbYV19O3hhLnByb3RvdHlwZS5sZj0hMDtmdW5jdGlvbiB5YShhKXt0cnl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93W2FdKXt2YXIgYj13aW5kb3dbYV07Yi5zZXRJdGVtKFwiZmlyZWJhc2U6c2VudGluZWxcIixcImNhY2hlXCIpO2IucmVtb3ZlSXRlbShcImZpcmViYXNlOnNlbnRpbmVsXCIpO3JldHVybiBuZXcgd2EoYil9fWNhdGNoKGMpe31yZXR1cm4gbmV3IHhhfXZhciB6YT15YShcImxvY2FsU3RvcmFnZVwiKSx2PXlhKFwic2Vzc2lvblN0b3JhZ2VcIik7ZnVuY3Rpb24gQWEoYSxiLGMsZCxlKXt0aGlzLmhvc3Q9YS50b0xvd2VyQ2FzZSgpO3RoaXMuZG9tYWluPXRoaXMuaG9zdC5zdWJzdHIodGhpcy5ob3N0LmluZGV4T2YoXCIuXCIpKzEpO3RoaXMuQWI9Yjt0aGlzLnRiPWM7dGhpcy5EZz1kO3RoaXMuRGQ9ZXx8XCJcIjt0aGlzLk1hPXphLmdldChcImhvc3Q6XCIrYSl8fHRoaXMuaG9zdH1mdW5jdGlvbiBCYShhLGIpe2IhPT1hLk1hJiYoYS5NYT1iLFwicy1cIj09PWEuTWEuc3Vic3RyKDAsMikmJnphLnNldChcImhvc3Q6XCIrYS5ob3N0LGEuTWEpKX1BYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT0odGhpcy5BYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuaG9zdDt0aGlzLkRkJiYoYSs9XCI8XCIrdGhpcy5EZCtcIj5cIik7cmV0dXJuIGF9O2Z1bmN0aW9uIENhKCl7dGhpcy5TYT0tMX07ZnVuY3Rpb24gRGEoKXt0aGlzLlNhPS0xO3RoaXMuU2E9NjQ7dGhpcy5SPVtdO3RoaXMuYmU9W107dGhpcy5FZj1bXTt0aGlzLkFkPVtdO3RoaXMuQWRbMF09MTI4O2Zvcih2YXIgYT0xO2E8dGhpcy5TYTsrK2EpdGhpcy5BZFthXT0wO3RoaXMuVGQ9dGhpcy5TYj0wO3RoaXMucmVzZXQoKX1tYShEYSxDYSk7RGEucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5SWzBdPTE3MzI1ODQxOTM7dGhpcy5SWzFdPTQwMjMyMzM0MTc7dGhpcy5SWzJdPTI1NjIzODMxMDI7dGhpcy5SWzNdPTI3MTczMzg3ODt0aGlzLlJbNF09MzI4NTM3NzUyMDt0aGlzLlRkPXRoaXMuU2I9MH07XG5mdW5jdGlvbiBFYShhLGIsYyl7Y3x8KGM9MCk7dmFyIGQ9YS5FZjtpZihwKGIpKWZvcih2YXIgZT0wOzE2PmU7ZSsrKWRbZV09Yi5jaGFyQ29kZUF0KGMpPDwyNHxiLmNoYXJDb2RlQXQoYysxKTw8MTZ8Yi5jaGFyQ29kZUF0KGMrMik8PDh8Yi5jaGFyQ29kZUF0KGMrMyksYys9NDtlbHNlIGZvcihlPTA7MTY+ZTtlKyspZFtlXT1iW2NdPDwyNHxiW2MrMV08PDE2fGJbYysyXTw8OHxiW2MrM10sYys9NDtmb3IoZT0xNjs4MD5lO2UrKyl7dmFyIGY9ZFtlLTNdXmRbZS04XV5kW2UtMTRdXmRbZS0xNl07ZFtlXT0oZjw8MXxmPj4+MzEpJjQyOTQ5NjcyOTV9Yj1hLlJbMF07Yz1hLlJbMV07Zm9yKHZhciBnPWEuUlsyXSxrPWEuUlszXSxsPWEuUls0XSxuLGU9MDs4MD5lO2UrKyk0MD5lPzIwPmU/KGY9a15jJihnXmspLG49MTUxODUwMDI0OSk6KGY9Y15nXmssbj0xODU5Nzc1MzkzKTo2MD5lPyhmPWMmZ3xrJihjfGcpLG49MjQwMDk1OTcwOCk6KGY9Y15nXmssbj0zMzk1NDY5NzgyKSxmPShiPDxcbjV8Yj4+PjI3KStmK2wrbitkW2VdJjQyOTQ5NjcyOTUsbD1rLGs9ZyxnPShjPDwzMHxjPj4+MikmNDI5NDk2NzI5NSxjPWIsYj1mO2EuUlswXT1hLlJbMF0rYiY0Mjk0OTY3Mjk1O2EuUlsxXT1hLlJbMV0rYyY0Mjk0OTY3Mjk1O2EuUlsyXT1hLlJbMl0rZyY0Mjk0OTY3Mjk1O2EuUlszXT1hLlJbM10rayY0Mjk0OTY3Mjk1O2EuUls0XT1hLlJbNF0rbCY0Mjk0OTY3Mjk1fVxuRGEucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe20oYil8fChiPWEubGVuZ3RoKTtmb3IodmFyIGM9Yi10aGlzLlNhLGQ9MCxlPXRoaXMuYmUsZj10aGlzLlNiO2Q8Yjspe2lmKDA9PWYpZm9yKDtkPD1jOylFYSh0aGlzLGEsZCksZCs9dGhpcy5TYTtpZihwKGEpKWZvcig7ZDxiOyl7aWYoZVtmXT1hLmNoYXJDb2RlQXQoZCksKytmLCsrZCxmPT10aGlzLlNhKXtFYSh0aGlzLGUpO2Y9MDticmVha319ZWxzZSBmb3IoO2Q8YjspaWYoZVtmXT1hW2RdLCsrZiwrK2QsZj09dGhpcy5TYSl7RWEodGhpcyxlKTtmPTA7YnJlYWt9fXRoaXMuU2I9Zjt0aGlzLlRkKz1ifTtmdW5jdGlvbiBGYSgpe3JldHVybiBNYXRoLmZsb29yKDIxNDc0ODM2NDgqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpK01hdGguYWJzKE1hdGguZmxvb3IoMjE0NzQ4MzY0OCpNYXRoLnJhbmRvbSgpKV5sYSgpKS50b1N0cmluZygzNil9O3ZhciB3PUFycmF5LnByb3RvdHlwZSxHYT13LmluZGV4T2Y/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmluZGV4T2YuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtjPW51bGw9PWM/MDowPmM/TWF0aC5tYXgoMCxhLmxlbmd0aCtjKTpjO2lmKHAoYSkpcmV0dXJuIHAoYikmJjE9PWIubGVuZ3RoP2EuaW5kZXhPZihiLGMpOi0xO2Zvcig7YzxhLmxlbmd0aDtjKyspaWYoYyBpbiBhJiZhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sSGE9dy5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXt3LmZvckVhY2guY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1wKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKX0sSWE9dy5maWx0ZXI/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmZpbHRlci5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVtdLGY9MCxnPXAoYSk/XG5hLnNwbGl0KFwiXCIpOmEsaz0wO2s8ZDtrKyspaWYoayBpbiBnKXt2YXIgbD1nW2tdO2IuY2FsbChjLGwsayxhKSYmKGVbZisrXT1sKX1yZXR1cm4gZX0sSmE9dy5tYXA/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3Lm1hcC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPUFycmF5KGQpLGY9cChhKT9hLnNwbGl0KFwiXCIpOmEsZz0wO2c8ZDtnKyspZyBpbiBmJiYoZVtnXT1iLmNhbGwoYyxmW2ddLGcsYSkpO3JldHVybiBlfSxLYT13LnJlZHVjZT9mdW5jdGlvbihhLGIsYyxkKXtkJiYoYj1xKGIsZCkpO3JldHVybiB3LnJlZHVjZS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YztIYShhLGZ1bmN0aW9uKGMsZyl7ZT1iLmNhbGwoZCxlLGMsZyxhKX0pO3JldHVybiBlfSxMYT13LmV2ZXJ5P2Z1bmN0aW9uKGEsYixjKXtyZXR1cm4gdy5ldmVyeS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVxucChhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspaWYoZiBpbiBlJiYhYi5jYWxsKGMsZVtmXSxmLGEpKXJldHVybiExO3JldHVybiEwfTtmdW5jdGlvbiBNYShhLGIpe3ZhciBjPU5hKGEsYix2b2lkIDApO3JldHVybiAwPmM/bnVsbDpwKGEpP2EuY2hhckF0KGMpOmFbY119ZnVuY3Rpb24gTmEoYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXAoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpKXJldHVybiBmO3JldHVybi0xfWZ1bmN0aW9uIE9hKGEsYil7dmFyIGM9R2EoYSxiKTswPD1jJiZ3LnNwbGljZS5jYWxsKGEsYywxKX1mdW5jdGlvbiBQYShhLGIsYyl7cmV0dXJuIDI+PWFyZ3VtZW50cy5sZW5ndGg/dy5zbGljZS5jYWxsKGEsYik6dy5zbGljZS5jYWxsKGEsYixjKX1mdW5jdGlvbiBRYShhLGIpe2Euc29ydChifHxSYSl9ZnVuY3Rpb24gUmEoYSxiKXtyZXR1cm4gYT5iPzE6YTxiPy0xOjB9O3ZhciBTYTthOnt2YXIgVGE9YWEubmF2aWdhdG9yO2lmKFRhKXt2YXIgVWE9VGEudXNlckFnZW50O2lmKFVhKXtTYT1VYTticmVhayBhfX1TYT1cIlwifWZ1bmN0aW9uIFZhKGEpe3JldHVybi0xIT1TYS5pbmRleE9mKGEpfTt2YXIgV2E9VmEoXCJPcGVyYVwiKXx8VmEoXCJPUFJcIiksWGE9VmEoXCJUcmlkZW50XCIpfHxWYShcIk1TSUVcIiksWWE9VmEoXCJHZWNrb1wiKSYmLTE9PVNhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKSYmIShWYShcIlRyaWRlbnRcIil8fFZhKFwiTVNJRVwiKSksWmE9LTEhPVNhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKTsoZnVuY3Rpb24oKXt2YXIgYT1cIlwiLGI7aWYoV2EmJmFhLm9wZXJhKXJldHVybiBhPWFhLm9wZXJhLnZlcnNpb24saGEoYSk/YSgpOmE7WWE/Yj0vcnZcXDooW15cXCk7XSspKFxcKXw7KS86WGE/Yj0vXFxiKD86TVNJRXxydilbOiBdKFteXFwpO10rKShcXCl8OykvOlphJiYoYj0vV2ViS2l0XFwvKFxcUyspLyk7YiYmKGE9KGE9Yi5leGVjKFNhKSk/YVsxXTpcIlwiKTtyZXR1cm4gWGEmJihiPShiPWFhLmRvY3VtZW50KT9iLmRvY3VtZW50TW9kZTp2b2lkIDAsYj5wYXJzZUZsb2F0KGEpKT9TdHJpbmcoYik6YX0pKCk7dmFyICRhPW51bGwsYWI9bnVsbCxiYj1udWxsO2Z1bmN0aW9uIGNiKGEsYil7aWYoIWZhKGEpKXRocm93IEVycm9yKFwiZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyXCIpO2RiKCk7Zm9yKHZhciBjPWI/YWI6JGEsZD1bXSxlPTA7ZTxhLmxlbmd0aDtlKz0zKXt2YXIgZj1hW2VdLGc9ZSsxPGEubGVuZ3RoLGs9Zz9hW2UrMV06MCxsPWUrMjxhLmxlbmd0aCxuPWw/YVtlKzJdOjAsdT1mPj4yLGY9KGYmMyk8PDR8az4+NCxrPShrJjE1KTw8MnxuPj42LG49biY2MztsfHwobj02NCxnfHwoaz02NCkpO2QucHVzaChjW3VdLGNbZl0sY1trXSxjW25dKX1yZXR1cm4gZC5qb2luKFwiXCIpfVxuZnVuY3Rpb24gZGIoKXtpZighJGEpeyRhPXt9O2FiPXt9O2JiPXt9O2Zvcih2YXIgYT0wOzY1PmE7YSsrKSRhW2FdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSksYWJbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fLlwiLmNoYXJBdChhKSxiYlthYlthXV09YX19O3ZhciBlYj1mdW5jdGlvbigpe3ZhciBhPTE7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGErK319KCk7ZnVuY3Rpb24geShhLGIpe2lmKCFhKXRocm93IGZiKGIpO31mdW5jdGlvbiBmYihhKXtyZXR1cm4gRXJyb3IoXCJGaXJlYmFzZSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOlwiK2EpfVxuZnVuY3Rpb24gZ2IoYSl7dHJ5e3ZhciBiO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYXRvYiliPWF0b2IoYSk7ZWxzZXtkYigpO2Zvcih2YXIgYz1iYixkPVtdLGU9MDtlPGEubGVuZ3RoOyl7dmFyIGY9Y1thLmNoYXJBdChlKyspXSxnPWU8YS5sZW5ndGg/Y1thLmNoYXJBdChlKV06MDsrK2U7dmFyIGs9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTo2NDsrK2U7dmFyIGw9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTo2NDsrK2U7aWYobnVsbD09Znx8bnVsbD09Z3x8bnVsbD09a3x8bnVsbD09bCl0aHJvdyBFcnJvcigpO2QucHVzaChmPDwyfGc+PjQpOzY0IT1rJiYoZC5wdXNoKGc8PDQmMjQwfGs+PjIpLDY0IT1sJiZkLnB1c2goazw8NiYxOTJ8bCkpfWlmKDgxOTI+ZC5sZW5ndGgpYj1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZCk7ZWxzZXthPVwiXCI7Zm9yKGM9MDtjPGQubGVuZ3RoO2MrPTgxOTIpYSs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLFBhKGQsYyxcbmMrODE5MikpO2I9YX19cmV0dXJuIGJ9Y2F0Y2gobil7aGIoXCJiYXNlNjREZWNvZGUgZmFpbGVkOiBcIixuKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBpYihhKXt2YXIgYj1qYihhKTthPW5ldyBEYTthLnVwZGF0ZShiKTt2YXIgYj1bXSxjPTgqYS5UZDs1Nj5hLlNiP2EudXBkYXRlKGEuQWQsNTYtYS5TYik6YS51cGRhdGUoYS5BZCxhLlNhLShhLlNiLTU2KSk7Zm9yKHZhciBkPWEuU2EtMTs1Njw9ZDtkLS0pYS5iZVtkXT1jJjI1NSxjLz0yNTY7RWEoYSxhLmJlKTtmb3IoZD1jPTA7NT5kO2QrKylmb3IodmFyIGU9MjQ7MDw9ZTtlLT04KWJbY109YS5SW2RdPj5lJjI1NSwrK2M7cmV0dXJuIGNiKGIpfVxuZnVuY3Rpb24ga2IoYSl7Zm9yKHZhciBiPVwiXCIsYz0wO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYj1mYShhcmd1bWVudHNbY10pP2Ira2IuYXBwbHkobnVsbCxhcmd1bWVudHNbY10pOlwib2JqZWN0XCI9PT10eXBlb2YgYXJndW1lbnRzW2NdP2Ircihhcmd1bWVudHNbY10pOmIrYXJndW1lbnRzW2NdLGIrPVwiIFwiO3JldHVybiBifXZhciBsYj1udWxsLG1iPSEwO2Z1bmN0aW9uIGhiKGEpeyEwPT09bWImJihtYj0hMSxudWxsPT09bGImJiEwPT09di5nZXQoXCJsb2dnaW5nX2VuYWJsZWRcIikmJm5iKCEwKSk7aWYobGIpe3ZhciBiPWtiLmFwcGx5KG51bGwsYXJndW1lbnRzKTtsYihiKX19ZnVuY3Rpb24gb2IoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7aGIoYSxhcmd1bWVudHMpfX1cbmZ1bmN0aW9uIHBiKGEpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIGI9XCJGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogXCIra2IuYXBwbHkobnVsbCxhcmd1bWVudHMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZS5lcnJvcj9jb25zb2xlLmVycm9yKGIpOmNvbnNvbGUubG9nKGIpfX1mdW5jdGlvbiBxYihhKXt2YXIgYj1rYi5hcHBseShudWxsLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoXCJGSVJFQkFTRSBGQVRBTCBFUlJPUjogXCIrYik7fWZ1bmN0aW9uIHooYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXt2YXIgYj1cIkZJUkVCQVNFIFdBUk5JTkc6IFwiK2tiLmFwcGx5KG51bGwsYXJndW1lbnRzKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUud2Fybj9jb25zb2xlLndhcm4oYik6Y29uc29sZS5sb2coYil9fVxuZnVuY3Rpb24gcmIoYSl7dmFyIGI9XCJcIixjPVwiXCIsZD1cIlwiLGU9XCJcIixmPSEwLGc9XCJodHRwc1wiLGs9NDQzO2lmKHAoYSkpe3ZhciBsPWEuaW5kZXhPZihcIi8vXCIpOzA8PWwmJihnPWEuc3Vic3RyaW5nKDAsbC0xKSxhPWEuc3Vic3RyaW5nKGwrMikpO2w9YS5pbmRleE9mKFwiL1wiKTstMT09PWwmJihsPWEubGVuZ3RoKTtiPWEuc3Vic3RyaW5nKDAsbCk7ZT1cIlwiO2E9YS5zdWJzdHJpbmcobCkuc3BsaXQoXCIvXCIpO2ZvcihsPTA7bDxhLmxlbmd0aDtsKyspaWYoMDxhW2xdLmxlbmd0aCl7dmFyIG49YVtsXTt0cnl7bj1kZWNvZGVVUklDb21wb25lbnQobi5yZXBsYWNlKC9cXCsvZyxcIiBcIikpfWNhdGNoKHUpe31lKz1cIi9cIitufWE9Yi5zcGxpdChcIi5cIik7Mz09PWEubGVuZ3RoPyhjPWFbMV0sZD1hWzBdLnRvTG93ZXJDYXNlKCkpOjI9PT1hLmxlbmd0aCYmKGM9YVswXSk7bD1iLmluZGV4T2YoXCI6XCIpOzA8PWwmJihmPVwiaHR0cHNcIj09PWd8fFwid3NzXCI9PT1nLGs9Yi5zdWJzdHJpbmcobCsxKSxpc0Zpbml0ZShrKSYmXG4oaz1TdHJpbmcoaykpLGs9cChrKT8vXlxccyotPzB4L2kudGVzdChrKT9wYXJzZUludChrLDE2KTpwYXJzZUludChrLDEwKTpOYU4pfXJldHVybntob3N0OmIscG9ydDprLGRvbWFpbjpjLEFnOmQsQWI6ZixzY2hlbWU6ZyxQYzplfX1mdW5jdGlvbiBzYihhKXtyZXR1cm4gZ2EoYSkmJihhIT1hfHxhPT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl8fGE9PU51bWJlci5ORUdBVElWRV9JTkZJTklUWSl9XG5mdW5jdGlvbiB0YihhKXtpZihcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlKWEoKTtlbHNle3ZhciBiPSExLGM9ZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5P2J8fChiPSEwLGEoKSk6c2V0VGltZW91dChjLE1hdGguZmxvb3IoMTApKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcj8oZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixjLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixjLCExKSk6ZG9jdW1lbnQuYXR0YWNoRXZlbnQmJihkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmYygpfSksd2luZG93LmF0dGFjaEV2ZW50KFwib25sb2FkXCIsYykpfX1cbmZ1bmN0aW9uIHViKGEsYil7aWYoYT09PWIpcmV0dXJuIDA7aWYoXCJbTUlOX05BTUVdXCI9PT1hfHxcIltNQVhfTkFNRV1cIj09PWIpcmV0dXJuLTE7aWYoXCJbTUlOX05BTUVdXCI9PT1ifHxcIltNQVhfTkFNRV1cIj09PWEpcmV0dXJuIDE7dmFyIGM9dmIoYSksZD12YihiKTtyZXR1cm4gbnVsbCE9PWM/bnVsbCE9PWQ/MD09Yy1kP2EubGVuZ3RoLWIubGVuZ3RoOmMtZDotMTpudWxsIT09ZD8xOmE8Yj8tMToxfWZ1bmN0aW9uIHdiKGEsYil7aWYoYiYmYSBpbiBiKXJldHVybiBiW2FdO3Rocm93IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBrZXkgKFwiK2ErXCIpIGluIG9iamVjdDogXCIrcihiKSk7fVxuZnVuY3Rpb24geGIoYSl7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhfHxudWxsPT09YSlyZXR1cm4gcihhKTt2YXIgYj1bXSxjO2ZvcihjIGluIGEpYi5wdXNoKGMpO2Iuc29ydCgpO2M9XCJ7XCI7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspMCE9PWQmJihjKz1cIixcIiksYys9cihiW2RdKSxjKz1cIjpcIixjKz14YihhW2JbZF1dKTtyZXR1cm4gYytcIn1cIn1mdW5jdGlvbiB5YihhLGIpe2lmKGEubGVuZ3RoPD1iKXJldHVyblthXTtmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCs9YilkK2I+YT9jLnB1c2goYS5zdWJzdHJpbmcoZCxhLmxlbmd0aCkpOmMucHVzaChhLnN1YnN0cmluZyhkLGQrYikpO3JldHVybiBjfWZ1bmN0aW9uIHpiKGEsYil7aWYoZWEoYSkpZm9yKHZhciBjPTA7YzxhLmxlbmd0aDsrK2MpYihjLGFbY10pO2Vsc2UgQShhLGIpfVxuZnVuY3Rpb24gQWIoYSl7eSghc2IoYSksXCJJbnZhbGlkIEpTT04gbnVtYmVyXCIpO3ZhciBiLGMsZCxlOzA9PT1hPyhkPWM9MCxiPS1JbmZpbml0eT09PTEvYT8xOjApOihiPTA+YSxhPU1hdGguYWJzKGEpLGE+PU1hdGgucG93KDIsLTEwMjIpPyhkPU1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2coYSkvTWF0aC5MTjIpLDEwMjMpLGM9ZCsxMDIzLGQ9TWF0aC5yb3VuZChhKk1hdGgucG93KDIsNTItZCktTWF0aC5wb3coMiw1MikpKTooYz0wLGQ9TWF0aC5yb3VuZChhL01hdGgucG93KDIsLTEwNzQpKSkpO2U9W107Zm9yKGE9NTI7YTthLT0xKWUucHVzaChkJTI/MTowKSxkPU1hdGguZmxvb3IoZC8yKTtmb3IoYT0xMTthO2EtPTEpZS5wdXNoKGMlMj8xOjApLGM9TWF0aC5mbG9vcihjLzIpO2UucHVzaChiPzE6MCk7ZS5yZXZlcnNlKCk7Yj1lLmpvaW4oXCJcIik7Yz1cIlwiO2ZvcihhPTA7NjQ+YTthKz04KWQ9cGFyc2VJbnQoYi5zdWJzdHIoYSw4KSwyKS50b1N0cmluZygxNiksMT09PWQubGVuZ3RoJiZcbihkPVwiMFwiK2QpLGMrPWQ7cmV0dXJuIGMudG9Mb3dlckNhc2UoKX12YXIgQmI9L14tP1xcZHsxLDEwfSQvO2Z1bmN0aW9uIHZiKGEpe3JldHVybiBCYi50ZXN0KGEpJiYoYT1OdW1iZXIoYSksLTIxNDc0ODM2NDg8PWEmJjIxNDc0ODM2NDc+PWEpP2E6bnVsbH1mdW5jdGlvbiBDYihhKXt0cnl7YSgpfWNhdGNoKGIpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt6KFwiRXhjZXB0aW9uIHdhcyB0aHJvd24gYnkgdXNlciBjYWxsYmFjay5cIixiLnN0YWNrfHxcIlwiKTt0aHJvdyBiO30sTWF0aC5mbG9vcigwKSl9fWZ1bmN0aW9uIEIoYSxiKXtpZihoYShhKSl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLnNsaWNlKCk7Q2IoZnVuY3Rpb24oKXthLmFwcGx5KG51bGwsYyl9KX19O2Z1bmN0aW9uIERiKGEsYixjLGQpe3RoaXMubGU9Yjt0aGlzLk5kPWM7dGhpcy5GZD1kO3RoaXMuamQ9YX1EYi5wcm90b3R5cGUuUWI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLk5kLmNjKCk7cmV0dXJuXCJ2YWx1ZVwiPT09dGhpcy5qZD9hLnBhdGg6YS5wYXJlbnQoKS5wYXRofTtEYi5wcm90b3R5cGUucGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5qZH07RGIucHJvdG90eXBlLkxiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGUuTGIodGhpcyl9O0RiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLlFiKCkudG9TdHJpbmcoKStcIjpcIit0aGlzLmpkK1wiOlwiK3IodGhpcy5OZC5iZigpKX07ZnVuY3Rpb24gRWIoYSxiLGMpe3RoaXMubGU9YTt0aGlzLmVycm9yPWI7dGhpcy5wYXRoPWN9RWIucHJvdG90eXBlLlFiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aH07RWIucHJvdG90eXBlLnBlPWZ1bmN0aW9uKCl7cmV0dXJuXCJjYW5jZWxcIn07XG5FYi5wcm90b3R5cGUuTGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZS5MYih0aGlzKX07RWIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpK1wiOmNhbmNlbFwifTtmdW5jdGlvbiBDKGEsYixjLGQpe3RoaXMudHlwZT1hO3RoaXMuSGE9Yjt0aGlzLlVhPWM7dGhpcy5EZT1kO3RoaXMuRmQ9dm9pZCAwfWZ1bmN0aW9uIEZiKGEpe3JldHVybiBuZXcgQyhHYixhKX12YXIgR2I9XCJ2YWx1ZVwiO2Z1bmN0aW9uIEhiKGEsYixjKXt0aGlzLkhiPWE7dGhpcy5rYj1iO3RoaXMubWI9Y3x8bnVsbH1oPUhiLnByb3RvdHlwZTtoLndmPWZ1bmN0aW9uKGEpe3JldHVyblwidmFsdWVcIj09PWF9O2guY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLm4uZztyZXR1cm4gbmV3IERiKFwidmFsdWVcIix0aGlzLG5ldyBEKGEuSGEsYi5jYygpLGMpKX07aC5MYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm1iO2lmKFwiY2FuY2VsXCI9PT1hLnBlKCkpe3kodGhpcy5rYixcIlJhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFja1wiKTt2YXIgYz10aGlzLmtiO3JldHVybiBmdW5jdGlvbigpe2MuY2FsbChiLGEuZXJyb3IpfX12YXIgZD10aGlzLkhiO3JldHVybiBmdW5jdGlvbigpe2QuY2FsbChiLGEuTmQpfX07aC5ZZT1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmtiP25ldyBFYih0aGlzLGEsYik6bnVsbH07XG5oLm1hdGNoZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBIYj9hLkhiJiZ0aGlzLkhiP2EuSGI9PT10aGlzLkhiJiZhLm1iPT09dGhpcy5tYjohMDohMX07aC5oZj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5IYn07ZnVuY3Rpb24gSWIoYSxiLGMpe3RoaXMuZGE9YTt0aGlzLmtiPWI7dGhpcy5tYj1jfWg9SWIucHJvdG90eXBlO2gud2Y9ZnVuY3Rpb24oYSl7YT1cImNoaWxkcmVuX2FkZGVkXCI9PT1hP1wiY2hpbGRfYWRkZWRcIjphO3JldHVybihcImNoaWxkcmVuX3JlbW92ZWRcIj09PWE/XCJjaGlsZF9yZW1vdmVkXCI6YSlpbiB0aGlzLmRhfTtoLlllPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMua2I/bmV3IEViKHRoaXMsYSxiKTpudWxsfTtcbmguY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oYSxiKXt5KG51bGwhPWEuVWEsXCJDaGlsZCBldmVudHMgc2hvdWxkIGhhdmUgYSBjaGlsZE5hbWUuXCIpO3ZhciBjPWIuY2MoKS5vKGEuVWEpO3JldHVybiBuZXcgRGIoYS50eXBlLHRoaXMsbmV3IEQoYS5IYSxjLGIubi5nKSxhLkZkKX07aC5MYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm1iO2lmKFwiY2FuY2VsXCI9PT1hLnBlKCkpe3kodGhpcy5rYixcIlJhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFja1wiKTt2YXIgYz10aGlzLmtiO3JldHVybiBmdW5jdGlvbigpe2MuY2FsbChiLGEuZXJyb3IpfX12YXIgZD10aGlzLmRhW2EuamRdO3JldHVybiBmdW5jdGlvbigpe2QuY2FsbChiLGEuTmQsYS5GZCl9fTtcbmgubWF0Y2hlcz1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgSWIpe2lmKCF0aGlzLmRhfHwhYS5kYSlyZXR1cm4hMDtpZih0aGlzLm1iPT09YS5tYil7dmFyIGI9SmIoYS5kYSk7aWYoYj09PUpiKHRoaXMuZGEpKXtpZigxPT09Yil7dmFyIGI9S2IoYS5kYSksYz1LYih0aGlzLmRhKTtyZXR1cm4gYz09PWImJighYS5kYVtiXXx8IXRoaXMuZGFbY118fGEuZGFbYl09PT10aGlzLmRhW2NdKX1yZXR1cm4gTGIodGhpcy5kYSxmdW5jdGlvbihiLGMpe3JldHVybiBhLmRhW2NdPT09Yn0pfX19cmV0dXJuITF9O2guaGY9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuZGF9O2Z1bmN0aW9uIGpiKGEpe2Zvcih2YXIgYj1bXSxjPTAsZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hLmNoYXJDb2RlQXQoZCk7NTUyOTY8PWUmJjU2MzE5Pj1lJiYoZS09NTUyOTYsZCsrLHkoZDxhLmxlbmd0aCxcIlN1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLlwiKSxlPTY1NTM2KyhlPDwxMCkrKGEuY2hhckNvZGVBdChkKS01NjMyMCkpOzEyOD5lP2JbYysrXT1lOigyMDQ4PmU/YltjKytdPWU+PjZ8MTkyOig2NTUzNj5lP2JbYysrXT1lPj4xMnwyMjQ6KGJbYysrXT1lPj4xOHwyNDAsYltjKytdPWU+PjEyJjYzfDEyOCksYltjKytdPWU+PjYmNjN8MTI4KSxiW2MrK109ZSY2M3wxMjgpfXJldHVybiBifTtmdW5jdGlvbiBGKGEsYixjLGQpe3ZhciBlO2Q8Yj9lPVwiYXQgbGVhc3QgXCIrYjpkPmMmJihlPTA9PT1jP1wibm9uZVwiOlwibm8gbW9yZSB0aGFuIFwiK2MpO2lmKGUpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCBcIitkKygxPT09ZD9cIiBhcmd1bWVudC5cIjpcIiBhcmd1bWVudHMuXCIpK1wiIEV4cGVjdHMgXCIrZStcIi5cIik7fWZ1bmN0aW9uIEcoYSxiLGMpe3ZhciBkPVwiXCI7c3dpdGNoKGIpe2Nhc2UgMTpkPWM/XCJmaXJzdFwiOlwiRmlyc3RcIjticmVhaztjYXNlIDI6ZD1jP1wic2Vjb25kXCI6XCJTZWNvbmRcIjticmVhaztjYXNlIDM6ZD1jP1widGhpcmRcIjpcIlRoaXJkXCI7YnJlYWs7Y2FzZSA0OmQ9Yz9cImZvdXJ0aFwiOlwiRm91cnRoXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImVycm9yUHJlZml4IGNhbGxlZCB3aXRoIGFyZ3VtZW50TnVtYmVyID4gNC4gIE5lZWQgdG8gdXBkYXRlIGl0P1wiKTt9cmV0dXJuIGE9YStcIiBmYWlsZWQ6IFwiKyhkK1wiIGFyZ3VtZW50IFwiKX1cbmZ1bmN0aW9uIEgoYSxiLGMsZCl7aWYoKCFkfHxtKGMpKSYmIWhhKGMpKXRocm93IEVycm9yKEcoYSxiLGQpK1wibXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLlwiKTt9ZnVuY3Rpb24gTWIoYSxiLGMpe2lmKG0oYykmJighaWEoYyl8fG51bGw9PT1jKSl0aHJvdyBFcnJvcihHKGEsYiwhMCkrXCJtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuXCIpO307dmFyIE5iPS9bXFxbXFxdLiMkXFwvXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vLE9iPS9bXFxbXFxdLiMkXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vO2Z1bmN0aW9uIFBiKGEpe3JldHVybiBwKGEpJiYwIT09YS5sZW5ndGgmJiFOYi50ZXN0KGEpfWZ1bmN0aW9uIFFiKGEpe3JldHVybiBudWxsPT09YXx8cChhKXx8Z2EoYSkmJiFzYihhKXx8aWEoYSkmJnMoYSxcIi5zdlwiKX1mdW5jdGlvbiBSYihhLGIsYyl7YyYmIW0oYil8fFNiKEcoYSwxLGMpLGIpfVxuZnVuY3Rpb24gU2IoYSxiLGMsZCl7Y3x8KGM9MCk7dmFyIGU9ZHx8W107aWYoIW0oYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIHVuZGVmaW5lZFwiK1RiKGUpKTtpZihoYShiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgYSBmdW5jdGlvblwiK1RiKGUpK1wiIHdpdGggY29udGVudHM6IFwiK2IudG9TdHJpbmcoKSk7aWYoc2IoYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIFwiK2IudG9TdHJpbmcoKStUYihlKSk7aWYoMUUzPGMpdGhyb3cgbmV3IFR5cGVFcnJvcihhK1wiY29udGFpbnMgYSBjeWNsaWMgb2JqZWN0IHZhbHVlIChcIitlLnNsaWNlKDAsMTAwKS5qb2luKFwiLlwiKStcIi4uLilcIik7aWYocChiKSYmYi5sZW5ndGg+MTA0ODU3NjAvMyYmMTA0ODU3NjA8amIoYikubGVuZ3RoKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gMTA0ODU3NjAgdXRmOCBieXRlc1wiK1RiKGUpK1wiICgnXCIrYi5zdWJzdHJpbmcoMCw1MCkrXCIuLi4nKVwiKTtpZihpYShiKSl7dmFyIGY9XG4hMSxnPSExO3VhKGIsZnVuY3Rpb24oYixkKXtpZihcIi52YWx1ZVwiPT09YilmPSEwO2Vsc2UgaWYoXCIucHJpb3JpdHlcIiE9PWImJlwiLnN2XCIhPT1iJiYoZz0hMCwhUGIoYikpKXRocm93IEVycm9yKGErXCIgY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKFwiK2IrXCIpXCIrVGIoZSkrJy4gIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTtlLnB1c2goYik7U2IoYSxkLGMrMSxlKTtlLnBvcCgpfSk7aWYoZiYmZyl0aHJvdyBFcnJvcihhKycgY29udGFpbnMgXCIudmFsdWVcIiBjaGlsZCcrVGIoZSkrXCIgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLlwiKTt9fWZ1bmN0aW9uIFRiKGEpe3JldHVybiAwPT1hLmxlbmd0aD9cIlwiOlwiIGluIHByb3BlcnR5ICdcIithLmpvaW4oXCIuXCIpK1wiJ1wifVxuZnVuY3Rpb24gVWIoYSxiKXtpZighaWEoYil8fGVhKGIpKXRocm93IEVycm9yKEcoYSwxLCExKStcIiBtdXN0IGJlIGFuIE9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLlwiKTtpZihzKGIsXCIudmFsdWVcIikpdGhyb3cgRXJyb3IoRyhhLDEsITEpKycgbXVzdCBub3QgY29udGFpbiBcIi52YWx1ZVwiLiAgVG8gb3ZlcndyaXRlIHdpdGggYSBsZWFmIHZhbHVlLCBqdXN0IHVzZSAuc2V0KCkgaW5zdGVhZC4nKTtSYihhLGIsITEpfVxuZnVuY3Rpb24gVmIoYSxiLGMpe2lmKHNiKGMpKXRocm93IEVycm9yKEcoYSxiLCExKStcImlzIFwiK2MudG9TdHJpbmcoKStcIiwgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO2lmKCFRYihjKSl0aHJvdyBFcnJvcihHKGEsYiwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLlwiKTt9XG5mdW5jdGlvbiBXYihhLGIsYyl7aWYoIWN8fG0oYikpc3dpdGNoKGIpe2Nhc2UgXCJ2YWx1ZVwiOmNhc2UgXCJjaGlsZF9hZGRlZFwiOmNhc2UgXCJjaGlsZF9yZW1vdmVkXCI6Y2FzZSBcImNoaWxkX2NoYW5nZWRcIjpjYXNlIFwiY2hpbGRfbW92ZWRcIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKEcoYSwxLGMpKydtdXN0IGJlIGEgdmFsaWQgZXZlbnQgdHlwZTogXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCBcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLicpO319ZnVuY3Rpb24gWGIoYSxiLGMsZCl7aWYoKCFkfHxtKGMpKSYmIVBiKGMpKXRocm93IEVycm9yKEcoYSxiLGQpKyd3YXMgYW4gaW52YWxpZCBrZXk6IFwiJytjKydcIi4gIEZpcmViYXNlIGtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO31cbmZ1bmN0aW9uIFliKGEsYil7aWYoIXAoYil8fDA9PT1iLmxlbmd0aHx8T2IudGVzdChiKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJ3dhcyBhbiBpbnZhbGlkIHBhdGg6IFwiJytiKydcIi4gUGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO31mdW5jdGlvbiBaYihhLGIpe2lmKFwiLmluZm9cIj09PUkoYikpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IENhbid0IG1vZGlmeSBkYXRhIHVuZGVyIC8uaW5mby9cIik7fWZ1bmN0aW9uICRiKGEsYil7aWYoIXAoYikpdGhyb3cgRXJyb3IoRyhhLDEsITEpK1wibXVzdCBiZSBhIHZhbGlkIGNyZWRlbnRpYWwgKGEgc3RyaW5nKS5cIik7fWZ1bmN0aW9uIGFjKGEsYixjKXtpZighcChjKSl0aHJvdyBFcnJvcihHKGEsYiwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLlwiKTt9XG5mdW5jdGlvbiBKKGEsYixjLGQpe2lmKCFkfHxtKGMpKWlmKCFpYShjKXx8bnVsbD09PWMpdGhyb3cgRXJyb3IoRyhhLGIsZCkrXCJtdXN0IGJlIGEgdmFsaWQgb2JqZWN0LlwiKTt9ZnVuY3Rpb24gSyhhLGIsYyl7aWYoIWlhKGIpfHxudWxsPT09Ynx8IXMoYixjKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJ211c3QgY29udGFpbiB0aGUga2V5IFwiJytjKydcIicpO2lmKCFwKHQoYixjKSkpdGhyb3cgRXJyb3IoRyhhLDEsITEpKydtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicrYysnXCIgd2l0aCB0eXBlIFwic3RyaW5nXCInKTt9O2Z1bmN0aW9uIGJjKGEpe3RoaXMuZz1hfWg9YmMucHJvdG90eXBlO2guQz1mdW5jdGlvbihhLGIsYyxkLGUpe3koYS5CYyh0aGlzLmcpLFwiQSBub2RlIG11c3QgYmUgaW5kZXhlZCBpZiBvbmx5IGEgY2hpbGQgaXMgdXBkYXRlZFwiKTtkPWEuSyhiKTtpZihkLmVhKGMpKXJldHVybiBhO251bGwhPWUmJihjLmUoKT9hLkRhKGIpP2NjKGUsbmV3IEMoXCJjaGlsZF9yZW1vdmVkXCIsZCxiKSk6eShhLk0oKSxcIkEgY2hpbGQgcmVtb3ZlIHdpdGhvdXQgYW4gb2xkIGNoaWxkIG9ubHkgbWFrZXMgc2Vuc2Ugb24gYSBsZWFmIG5vZGVcIik6ZC5lKCk/Y2MoZSxuZXcgQyhcImNoaWxkX2FkZGVkXCIsYyxiKSk6Y2MoZSxuZXcgQyhcImNoaWxkX2NoYW5nZWRcIixjLGIsZCkpKTtyZXR1cm4gYS5NKCkmJmMuZSgpP2E6YS5QKGIsYyl9O1xuaC5vYT1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YyYmKGEuTSgpfHxhLlUoTCxmdW5jdGlvbihhLGUpe2IuRGEoYSl8fGNjKGMsbmV3IEMoXCJjaGlsZF9yZW1vdmVkXCIsZSxhKSl9KSxiLk0oKXx8Yi5VKEwsZnVuY3Rpb24oYixlKXtpZihhLkRhKGIpKXt2YXIgZj1hLksoYik7Zi5lYShlKXx8Y2MoYyxuZXcgQyhcImNoaWxkX2NoYW5nZWRcIixlLGIsZikpfWVsc2UgY2MoYyxuZXcgQyhcImNoaWxkX2FkZGVkXCIsZSxiKSl9KSk7cmV0dXJuIGIuRmIodGhpcy5nKX07aC5aPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZSgpP006YS5aKGIpfTtoLnlhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guTWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307ZnVuY3Rpb24gZGMoYSl7dGhpcy5yZT1uZXcgYmMoYS5nKTt0aGlzLmc9YS5nO3ZhciBiO2EuaWE/KGI9ZWMoYSksYj1hLmcuQWUoZmMoYSksYikpOmI9YS5nLkNlKCk7dGhpcy5WYz1iO2EucWE/KGI9Z2MoYSksYT1hLmcuQWUoaGMoYSksYikpOmE9YS5nLkJlKCk7dGhpcy53Yz1hfWg9ZGMucHJvdG90eXBlO2gubWF0Y2hlcz1mdW5jdGlvbihhKXtyZXR1cm4gMD49dGhpcy5nLmNvbXBhcmUodGhpcy5WYyxhKSYmMD49dGhpcy5nLmNvbXBhcmUoYSx0aGlzLndjKX07aC5DPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5tYXRjaGVzKG5ldyBOKGIsYykpfHwoYz1NKTtyZXR1cm4gdGhpcy5yZS5DKGEsYixjLGQsZSl9O2gub2E9ZnVuY3Rpb24oYSxiLGMpe2IuTSgpJiYoYj1NKTt2YXIgZD1iLkZiKHRoaXMuZyksZD1kLlooTSksZT10aGlzO2IuVShMLGZ1bmN0aW9uKGEsYil7ZS5tYXRjaGVzKG5ldyBOKGEsYikpfHwoZD1kLlAoYSxNKSl9KTtyZXR1cm4gdGhpcy5yZS5vYShhLGQsYyl9O1xuaC5aPWZ1bmN0aW9uKGEpe3JldHVybiBhfTtoLnlhPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guTWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZX07ZnVuY3Rpb24gaWMoYSxiKXtyZXR1cm4gdWIoYS5uYW1lLGIubmFtZSl9ZnVuY3Rpb24gamMoYSxiKXtyZXR1cm4gdWIoYSxiKX07ZnVuY3Rpb24ga2MoKXt9dmFyIGxjPXt9O2Z1bmN0aW9uIG1jKGEpe3JldHVybiBxKGEuY29tcGFyZSxhKX1rYy5wcm90b3R5cGUuamY9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMCE9PXRoaXMuY29tcGFyZShuZXcgTihcIltNSU5fTkFNRV1cIixhKSxuZXcgTihcIltNSU5fTkFNRV1cIixiKSl9O2tjLnByb3RvdHlwZS5DZT1mdW5jdGlvbigpe3JldHVybiBuY307ZnVuY3Rpb24gb2MoYSl7dGhpcy5VYj1hfW1hKG9jLGtjKTtoPW9jLnByb3RvdHlwZTtoLnVlPWZ1bmN0aW9uKGEpe3JldHVybiFhLksodGhpcy5VYikuZSgpfTtoLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLlkuSyh0aGlzLlViKSxkPWIuWS5LKHRoaXMuVWIpLGM9Yy5oZShkKTtyZXR1cm4gMD09PWM/dWIoYS5uYW1lLGIubmFtZSk6Y307aC5BZT1mdW5jdGlvbihhLGIpe3ZhciBjPU8oYSksYz1NLlAodGhpcy5VYixjKTtyZXR1cm4gbmV3IE4oYixjKX07XG5oLkJlPWZ1bmN0aW9uKCl7dmFyIGE9TS5QKHRoaXMuVWIscGMpO3JldHVybiBuZXcgTihcIltNQVhfTkFNRV1cIixhKX07aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLlVifTt2YXIgTD1uZXcgb2MoXCIucHJpb3JpdHlcIik7ZnVuY3Rpb24gcWMoKXt9bWEocWMsa2MpO2g9cWMucHJvdG90eXBlO2guY29tcGFyZT1mdW5jdGlvbihhLGIpe3JldHVybiB1YihhLm5hbWUsYi5uYW1lKX07aC51ZT1mdW5jdGlvbigpe3Rocm93IGZiKFwiS2V5SW5kZXguaXNEZWZpbmVkT24gbm90IGV4cGVjdGVkIHRvIGJlIGNhbGxlZC5cIik7fTtoLmpmPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guQ2U9ZnVuY3Rpb24oKXtyZXR1cm4gbmN9O2guQmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE4oXCJbTUFYX05BTUVdXCIsTSl9O2guQWU9ZnVuY3Rpb24oYSl7eShwKGEpLFwiS2V5SW5kZXggaW5kZXhWYWx1ZSBtdXN0IGFsd2F5cyBiZSBhIHN0cmluZy5cIik7cmV0dXJuIG5ldyBOKGEsTSl9O1xuaC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLmtleVwifTt2YXIgcmM9bmV3IHFjO2Z1bmN0aW9uIHNjKCl7fXNjLnByb3RvdHlwZS5lZj1mdW5jdGlvbigpe3JldHVybiBudWxsfTtzYy5wcm90b3R5cGUub2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07dmFyIHRjPW5ldyBzYztmdW5jdGlvbiB1YyhhLGIsYyl7dGhpcy5CZj1hO3RoaXMuSWE9Yjt0aGlzLnpkPWN9dWMucHJvdG90eXBlLmVmPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuSWEuRjtpZih2YyhiLGEpKXJldHVybiBiLmooKS5LKGEpO2I9bnVsbCE9dGhpcy56ZD9uZXcgd2ModGhpcy56ZCwhMCwhMSk6dGhpcy5JYS51KCk7cmV0dXJuIHRoaXMuQmYuVGEoYSxiKX07dWMucHJvdG90eXBlLm9lPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1udWxsIT10aGlzLnpkP3RoaXMuemQ6eGModGhpcy5JYSk7YT10aGlzLkJmLmNlKGQsYiwxLGMsYSk7cmV0dXJuIDA9PT1hLmxlbmd0aD9udWxsOmFbMF19O2Z1bmN0aW9uIHljKCl7dGhpcy5aYT17fX1cbmZ1bmN0aW9uIGNjKGEsYil7dmFyIGM9Yi50eXBlLGQ9Yi5VYTt5KFwiY2hpbGRfYWRkZWRcIj09Y3x8XCJjaGlsZF9jaGFuZ2VkXCI9PWN8fFwiY2hpbGRfcmVtb3ZlZFwiPT1jLFwiT25seSBjaGlsZCBjaGFuZ2VzIHN1cHBvcnRlZCBmb3IgdHJhY2tpbmdcIik7eShcIi5wcmlvcml0eVwiIT09ZCxcIk9ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuXCIpO3ZhciBlPXQoYS5aYSxkKTtpZihlKXt2YXIgZj1lLnR5cGU7aWYoXCJjaGlsZF9hZGRlZFwiPT1jJiZcImNoaWxkX3JlbW92ZWRcIj09ZilhLlphW2RdPW5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGIuSGEsZCxlLkhhKTtlbHNlIGlmKFwiY2hpbGRfcmVtb3ZlZFwiPT1jJiZcImNoaWxkX2FkZGVkXCI9PWYpZGVsZXRlIGEuWmFbZF07ZWxzZSBpZihcImNoaWxkX3JlbW92ZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5aYVtkXT1uZXcgQyhcImNoaWxkX3JlbW92ZWRcIixlLkRlLGQpO2Vsc2UgaWYoXCJjaGlsZF9jaGFuZ2VkXCI9PWMmJlxuXCJjaGlsZF9hZGRlZFwiPT1mKWEuWmFbZF09bmV3IEMoXCJjaGlsZF9hZGRlZFwiLGIuSGEsZCk7ZWxzZSBpZihcImNoaWxkX2NoYW5nZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5aYVtkXT1uZXcgQyhcImNoaWxkX2NoYW5nZWRcIixiLkhhLGQsZS5EZSk7ZWxzZSB0aHJvdyBmYihcIklsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogXCIrYitcIiBvY2N1cnJlZCBhZnRlciBcIitlKTt9ZWxzZSBhLlphW2RdPWJ9O2Z1bmN0aW9uIE4oYSxiKXt0aGlzLm5hbWU9YTt0aGlzLlk9Yn1mdW5jdGlvbiB6YyhhLGIpe3JldHVybiBuZXcgTihhLGIpfTtmdW5jdGlvbiBBYyhhKXt0aGlzLm1hPW5ldyBkYyhhKTt0aGlzLmc9YS5nO3koYS5rYSxcIk9ubHkgdmFsaWQgaWYgbGltaXQgaGFzIGJlZW4gc2V0XCIpO3RoaXMuc2E9YS5zYTt0aGlzLnpiPSEoXCJcIj09PWEuRWI/YS5pYTpcImxcIj09PWEuRWIpfWg9QWMucHJvdG90eXBlO2guQz1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMubWEubWF0Y2hlcyhuZXcgTihiLGMpKXx8KGM9TSk7cmV0dXJuIGEuSyhiKS5lYShjKT9hOmEudWIoKTx0aGlzLnNhP3RoaXMubWEuTWIoKS5DKGEsYixjLGQsZSk6QmModGhpcyxhLGIsYyxkLGUpfTtcbmgub2E9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2lmKGIuTSgpfHxiLmUoKSlkPU0uRmIodGhpcy5nKTtlbHNlIGlmKDIqdGhpcy5zYTxiLnViKCkmJmIuQmModGhpcy5nKSl7ZD1NLkZiKHRoaXMuZyk7Yj10aGlzLnpiP2IuUmIodGhpcy5tYS53Yyx0aGlzLmcpOmIuUGIodGhpcy5tYS5WYyx0aGlzLmcpO2Zvcih2YXIgZT0wOzA8Yi5OYS5sZW5ndGgmJmU8dGhpcy5zYTspe3ZhciBmPVAoYiksZztpZihnPXRoaXMuemI/MD49dGhpcy5nLmNvbXBhcmUodGhpcy5tYS5WYyxmKTowPj10aGlzLmcuY29tcGFyZShmLHRoaXMubWEud2MpKWQ9ZC5QKGYubmFtZSxmLlkpLGUrKztlbHNlIGJyZWFrfX1lbHNle2Q9Yi5GYih0aGlzLmcpO2Q9ZC5aKE0pO3ZhciBrLGwsbjtpZih0aGlzLnpiKXtiPWQuZ2YodGhpcy5nKTtrPXRoaXMubWEud2M7bD10aGlzLm1hLlZjO3ZhciB1PW1jKHRoaXMuZyk7bj1mdW5jdGlvbihhLGIpe3JldHVybiB1KGIsYSl9fWVsc2UgYj1kLk9iKHRoaXMuZyksaz10aGlzLm1hLlZjLFxubD10aGlzLm1hLndjLG49bWModGhpcy5nKTtmb3IodmFyIGU9MCx4PSExOzA8Yi5OYS5sZW5ndGg7KWY9UChiKSwheCYmMD49bihrLGYpJiYoeD0hMCksKGc9eCYmZTx0aGlzLnNhJiYwPj1uKGYsbCkpP2UrKzpkPWQuUChmLm5hbWUsTSl9cmV0dXJuIHRoaXMubWEuTWIoKS5vYShhLGQsYyl9O2guWj1mdW5jdGlvbihhKXtyZXR1cm4gYX07aC55YT1mdW5jdGlvbigpe3JldHVybiEwfTtoLk1iPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWEuTWIoKX07XG5mdW5jdGlvbiBCYyhhLGIsYyxkLGUsZil7dmFyIGc7aWYoYS56Yil7dmFyIGs9bWMoYS5nKTtnPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGsoYixhKX19ZWxzZSBnPW1jKGEuZyk7eShiLnViKCk9PWEuc2EsXCJcIik7dmFyIGw9bmV3IE4oYyxkKSxuPWEuemI/Q2MoYixhLmcpOkRjKGIsYS5nKSx1PWEubWEubWF0Y2hlcyhsKTtpZihiLkRhKGMpKXt2YXIgeD1iLksoYyksbj1lLm9lKGEuZyxuLGEuemIpO251bGwhPW4mJm4ubmFtZT09YyYmKG49ZS5vZShhLmcsbixhLnpiKSk7ZT1udWxsPT1uPzE6ZyhuLGwpO2lmKHUmJiFkLmUoKSYmMDw9ZSlyZXR1cm4gbnVsbCE9ZiYmY2MoZixuZXcgQyhcImNoaWxkX2NoYW5nZWRcIixkLGMseCkpLGIuUChjLGQpO251bGwhPWYmJmNjKGYsbmV3IEMoXCJjaGlsZF9yZW1vdmVkXCIseCxjKSk7Yj1iLlAoYyxNKTtyZXR1cm4gbnVsbCE9biYmYS5tYS5tYXRjaGVzKG4pPyhudWxsIT1mJiZjYyhmLG5ldyBDKFwiY2hpbGRfYWRkZWRcIixuLlksbi5uYW1lKSksYi5QKG4ubmFtZSxcbm4uWSkpOmJ9cmV0dXJuIGQuZSgpP2I6dSYmMDw9ZyhuLGwpPyhudWxsIT1mJiYoY2MoZixuZXcgQyhcImNoaWxkX3JlbW92ZWRcIixuLlksbi5uYW1lKSksY2MoZixuZXcgQyhcImNoaWxkX2FkZGVkXCIsZCxjKSkpLGIuUChjLGQpLlAobi5uYW1lLE0pKTpifTtmdW5jdGlvbiBFYygpe3RoaXMudmM9dGhpcy5xYT10aGlzLmtjPXRoaXMuaWE9dGhpcy5rYT0hMTt0aGlzLnNhPTA7dGhpcy5FYj1cIlwiO3RoaXMuQWM9bnVsbDt0aGlzLldiPVwiXCI7dGhpcy56Yz1udWxsO3RoaXMuVGI9XCJcIjt0aGlzLmc9TH12YXIgRmM9bmV3IEVjO2Z1bmN0aW9uIGZjKGEpe3koYS5pYSxcIk9ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLkFjfWZ1bmN0aW9uIGVjKGEpe3koYS5pYSxcIk9ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLmtjP2EuV2I6XCJbTUlOX05BTUVdXCJ9ZnVuY3Rpb24gaGMoYSl7eShhLnFhLFwiT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLnpjfWZ1bmN0aW9uIGdjKGEpe3koYS5xYSxcIk9ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS52Yz9hLlRiOlwiW01BWF9OQU1FXVwifVxuZnVuY3Rpb24gR2MoYSl7dmFyIGI9bmV3IEVjO2Iua2E9YS5rYTtiLnNhPWEuc2E7Yi5pYT1hLmlhO2IuQWM9YS5BYztiLmtjPWEua2M7Yi5XYj1hLldiO2IucWE9YS5xYTtiLnpjPWEuemM7Yi52Yz1hLnZjO2IuVGI9YS5UYjtiLmc9YS5nO3JldHVybiBifWg9RWMucHJvdG90eXBlO2gueGU9ZnVuY3Rpb24oYSl7dmFyIGI9R2ModGhpcyk7Yi5rYT0hMDtiLnNhPWE7Yi5FYj1cIlwiO3JldHVybiBifTtoLnllPWZ1bmN0aW9uKGEpe3ZhciBiPUdjKHRoaXMpO2Iua2E9ITA7Yi5zYT1hO2IuRWI9XCJsXCI7cmV0dXJuIGJ9O2guemU9ZnVuY3Rpb24oYSl7dmFyIGI9R2ModGhpcyk7Yi5rYT0hMDtiLnNhPWE7Yi5FYj1cInJcIjtyZXR1cm4gYn07aC5PZD1mdW5jdGlvbihhLGIpe3ZhciBjPUdjKHRoaXMpO2MuaWE9ITA7bShhKXx8KGE9bnVsbCk7Yy5BYz1hO251bGwhPWI/KGMua2M9ITAsYy5XYj1iKTooYy5rYz0hMSxjLldiPVwiXCIpO3JldHVybiBjfTtcbmguaGQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1HYyh0aGlzKTtjLnFhPSEwO20oYSl8fChhPW51bGwpO2MuemM9YTttKGIpPyhjLnZjPSEwLGMuVGI9Yik6KGMuSWc9ITEsYy5UYj1cIlwiKTtyZXR1cm4gY307ZnVuY3Rpb24gSGMoYSxiKXt2YXIgYz1HYyhhKTtjLmc9YjtyZXR1cm4gY31mdW5jdGlvbiBJYyhhKXt2YXIgYj17fTthLmlhJiYoYi5zcD1hLkFjLGEua2MmJihiLnNuPWEuV2IpKTthLnFhJiYoYi5lcD1hLnpjLGEudmMmJihiLmVuPWEuVGIpKTtpZihhLmthKXtiLmw9YS5zYTt2YXIgYz1hLkViO1wiXCI9PT1jJiYoYz1hLmlhP1wibFwiOlwiclwiKTtiLnZmPWN9YS5nIT09TCYmKGIuaT1hLmcudG9TdHJpbmcoKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gSmMoYSl7cmV0dXJuIShhLmlhfHxhLnFhfHxhLmthKX1oLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHIoSWModGhpcykpfTtmdW5jdGlvbiBRKGEsYixjLGQpe3RoaXMuaz1hO3RoaXMucGF0aD1iO3RoaXMubj1jO3RoaXMuYWM9ZH1cbmZ1bmN0aW9uIEtjKGEpe3ZhciBiPW51bGwsYz1udWxsO2EuaWEmJihiPWZjKGEpKTthLnFhJiYoYz1oYyhhKSk7aWYoYS5nPT09cmMpe2lmKGEuaWEpe2lmKFwiW01JTl9OQU1FXVwiIT1lYyhhKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLlwiKTtpZihudWxsIT1iJiZcInN0cmluZ1wiIT09dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLlwiKTt9aWYoYS5xYSl7aWYoXCJbTUFYX05BTUVdXCIhPWdjKGEpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuXCIpO2lmKG51bGwhPVxuYyYmXCJzdHJpbmdcIiE9PXR5cGVvZiBjKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSxvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy5cIik7fX1lbHNlIGlmKGEuZz09PUwpe2lmKG51bGwhPWImJiFRYihiKXx8bnVsbCE9YyYmIVFiKGMpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkgcHJpb3JpdHksIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlIChudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLlwiKTt9ZWxzZSBpZih5KGEuZyBpbnN0YW5jZW9mIG9jLFwidW5rbm93biBpbmRleCB0eXBlLlwiKSxudWxsIT1iJiZcIm9iamVjdFwiPT09dHlwZW9mIGJ8fG51bGwhPWMmJlwib2JqZWN0XCI9PT10eXBlb2YgYyl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgY2Fubm90IGJlIGFuIG9iamVjdC5cIik7XG59ZnVuY3Rpb24gTGMoYSl7aWYoYS5pYSYmYS5xYSYmYS5rYSYmKCFhLmthfHxcIlwiPT09YS5FYikpdGhyb3cgRXJyb3IoXCJRdWVyeTogQ2FuJ3QgY29tYmluZSBzdGFydEF0KCksIGVuZEF0KCksIGFuZCBsaW1pdCgpLiBVc2UgbGltaXRUb0ZpcnN0KCkgb3IgbGltaXRUb0xhc3QoKSBpbnN0ZWFkLlwiKTt9ZnVuY3Rpb24gTWMoYSxiKXtpZighMD09PWEuYWMpdGhyb3cgRXJyb3IoYitcIjogWW91IGNhbid0IGNvbWJpbmUgbXVsdGlwbGUgb3JkZXJCeSBjYWxscy5cIik7fVEucHJvdG90eXBlLmNjPWZ1bmN0aW9uKCl7RihcIlF1ZXJ5LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gbmV3IFIodGhpcy5rLHRoaXMucGF0aCl9O1EucHJvdG90eXBlLnJlZj1RLnByb3RvdHlwZS5jYztcblEucHJvdG90eXBlLnZiPWZ1bmN0aW9uKGEsYixjLGQpe0YoXCJRdWVyeS5vblwiLDIsNCxhcmd1bWVudHMubGVuZ3RoKTtXYihcIlF1ZXJ5Lm9uXCIsYSwhMSk7SChcIlF1ZXJ5Lm9uXCIsMixiLCExKTt2YXIgZT1OYyhcIlF1ZXJ5Lm9uXCIsYyxkKTtpZihcInZhbHVlXCI9PT1hKU9jKHRoaXMuayx0aGlzLG5ldyBIYihiLGUuY2FuY2VsfHxudWxsLGUuS2F8fG51bGwpKTtlbHNle3ZhciBmPXt9O2ZbYV09YjtPYyh0aGlzLmssdGhpcyxuZXcgSWIoZixlLmNhbmNlbCxlLkthKSl9cmV0dXJuIGJ9O1EucHJvdG90eXBlLm9uPVEucHJvdG90eXBlLnZiO1xuUS5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oYSxiLGMpe0YoXCJRdWVyeS5vZmZcIiwwLDMsYXJndW1lbnRzLmxlbmd0aCk7V2IoXCJRdWVyeS5vZmZcIixhLCEwKTtIKFwiUXVlcnkub2ZmXCIsMixiLCEwKTtNYihcIlF1ZXJ5Lm9mZlwiLDMsYyk7dmFyIGQ9bnVsbCxlPW51bGw7XCJ2YWx1ZVwiPT09YT9kPW5ldyBIYihifHxudWxsLG51bGwsY3x8bnVsbCk6YSYmKGImJihlPXt9LGVbYV09YiksZD1uZXcgSWIoZSxudWxsLGN8fG51bGwpKTtlPXRoaXMuaztkPVwiLmluZm9cIj09PUkodGhpcy5wYXRoKT9lLnFkLmdiKHRoaXMsZCk6ZS5OLmdiKHRoaXMsZCk7UGMoZS4kLHRoaXMucGF0aCxkKX07US5wcm90b3R5cGUub2ZmPVEucHJvdG90eXBlLlpiO1xuUS5wcm90b3R5cGUubGc9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGcpe2YmJihmPSExLGUuWmIoYSxjKSxiLmNhbGwoZC5LYSxnKSl9RihcIlF1ZXJ5Lm9uY2VcIiwyLDQsYXJndW1lbnRzLmxlbmd0aCk7V2IoXCJRdWVyeS5vbmNlXCIsYSwhMSk7SChcIlF1ZXJ5Lm9uY2VcIiwyLGIsITEpO3ZhciBkPU5jKFwiUXVlcnkub25jZVwiLGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10pLGU9dGhpcyxmPSEwO3RoaXMudmIoYSxjLGZ1bmN0aW9uKGIpe2UuWmIoYSxjKTtkLmNhbmNlbCYmZC5jYW5jZWwuY2FsbChkLkthLGIpfSl9O1EucHJvdG90eXBlLm9uY2U9US5wcm90b3R5cGUubGc7XG5RLnByb3RvdHlwZS54ZT1mdW5jdGlvbihhKXt6KFwiUXVlcnkubGltaXQoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFF1ZXJ5LmxpbWl0VG9GaXJzdCgpIG9yIFF1ZXJ5LmxpbWl0VG9MYXN0KCkgaW5zdGVhZC5cIik7RihcIlF1ZXJ5LmxpbWl0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXCIpO2lmKHRoaXMubi5rYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvcmxpbWl0VG9MYXN0LlwiKTt2YXIgYj10aGlzLm4ueGUoYSk7TGMoYik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYix0aGlzLmFjKX07US5wcm90b3R5cGUubGltaXQ9US5wcm90b3R5cGUueGU7XG5RLnByb3RvdHlwZS55ZT1mdW5jdGlvbihhKXtGKFwiUXVlcnkubGltaXRUb0ZpcnN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4ua2EpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS5cIik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsdGhpcy5uLnllKGEpLHRoaXMuYWMpfTtRLnByb3RvdHlwZS5saW1pdFRvRmlyc3Q9US5wcm90b3R5cGUueWU7XG5RLnByb3RvdHlwZS56ZT1mdW5jdGlvbihhKXtGKFwiUXVlcnkubGltaXRUb0xhc3RcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoIWdhKGEpfHxNYXRoLmZsb29yKGEpIT09YXx8MD49YSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0VG9MYXN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmthKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0xhc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS5cIik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsdGhpcy5uLnplKGEpLHRoaXMuYWMpfTtRLnByb3RvdHlwZS5saW1pdFRvTGFzdD1RLnByb3RvdHlwZS56ZTtcblEucHJvdG90eXBlLm1nPWZ1bmN0aW9uKGEpe0YoXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoXCIka2V5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2UgUXVlcnkub3JkZXJCeUtleSgpIGluc3RlYWQuJyk7aWYoXCIkcHJpb3JpdHlcIj09PWEpdGhyb3cgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJyk7WGIoXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIiwxLGEsITEpO01jKHRoaXMsXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIik7dmFyIGI9SGModGhpcy5uLG5ldyBvYyhhKSk7S2MoYik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYiwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlDaGlsZD1RLnByb3RvdHlwZS5tZztcblEucHJvdG90eXBlLm5nPWZ1bmN0aW9uKCl7RihcIlF1ZXJ5Lm9yZGVyQnlLZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7TWModGhpcyxcIlF1ZXJ5Lm9yZGVyQnlLZXlcIik7dmFyIGE9SGModGhpcy5uLHJjKTtLYyhhKTtyZXR1cm4gbmV3IFEodGhpcy5rLHRoaXMucGF0aCxhLCEwKX07US5wcm90b3R5cGUub3JkZXJCeUtleT1RLnByb3RvdHlwZS5uZztRLnByb3RvdHlwZS5vZz1mdW5jdGlvbigpe0YoXCJRdWVyeS5vcmRlckJ5UHJpb3JpdHlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7TWModGhpcyxcIlF1ZXJ5Lm9yZGVyQnlQcmlvcml0eVwiKTt2YXIgYT1IYyh0aGlzLm4sTCk7S2MoYSk7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYSwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlQcmlvcml0eT1RLnByb3RvdHlwZS5vZztcblEucHJvdG90eXBlLk9kPWZ1bmN0aW9uKGEsYil7RihcIlF1ZXJ5LnN0YXJ0QXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7UmIoXCJRdWVyeS5zdGFydEF0XCIsYSwhMCk7WGIoXCJRdWVyeS5zdGFydEF0XCIsMixiLCEwKTt2YXIgYz10aGlzLm4uT2QoYSxiKTtMYyhjKTtLYyhjKTtpZih0aGlzLm4uaWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5zdGFydEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0IG9yIGVxdWFsVG8pLlwiKTttKGEpfHwoYj1hPW51bGwpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGMsdGhpcy5hYyl9O1EucHJvdG90eXBlLnN0YXJ0QXQ9US5wcm90b3R5cGUuT2Q7XG5RLnByb3RvdHlwZS5oZD1mdW5jdGlvbihhLGIpe0YoXCJRdWVyeS5lbmRBdFwiLDAsMixhcmd1bWVudHMubGVuZ3RoKTtSYihcIlF1ZXJ5LmVuZEF0XCIsYSwhMCk7WGIoXCJRdWVyeS5lbmRBdFwiLDIsYiwhMCk7dmFyIGM9dGhpcy5uLmhkKGEsYik7TGMoYyk7S2MoYyk7aWYodGhpcy5uLnFhKXRocm93IEVycm9yKFwiUXVlcnkuZW5kQXQ6IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYyx0aGlzLmFjKX07US5wcm90b3R5cGUuZW5kQXQ9US5wcm90b3R5cGUuaGQ7XG5RLnByb3RvdHlwZS5UZj1mdW5jdGlvbihhLGIpe0YoXCJRdWVyeS5lcXVhbFRvXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1JiKFwiUXVlcnkuZXF1YWxUb1wiLGEsITEpO1hiKFwiUXVlcnkuZXF1YWxUb1wiLDIsYiwhMCk7aWYodGhpcy5uLmlhKXRocm93IEVycm9yKFwiUXVlcnkuZXF1YWxUbzogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO2lmKHRoaXMubi5xYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVxdWFsVG86IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7cmV0dXJuIHRoaXMuT2QoYSxiKS5oZChhLGIpfTtRLnByb3RvdHlwZS5lcXVhbFRvPVEucHJvdG90eXBlLlRmO1EucHJvdG90eXBlLkZhPWZ1bmN0aW9uKCl7dmFyIGE9eGIoSWModGhpcy5uKSk7cmV0dXJuXCJ7fVwiPT09YT9cImRlZmF1bHRcIjphfTtcbmZ1bmN0aW9uIE5jKGEsYixjKXt2YXIgZD17Y2FuY2VsOm51bGwsS2E6bnVsbH07aWYoYiYmYylkLmNhbmNlbD1iLEgoYSwzLGQuY2FuY2VsLCEwKSxkLkthPWMsTWIoYSw0LGQuS2EpO2Vsc2UgaWYoYilpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKWQuS2E9YjtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKWQuY2FuY2VsPWI7ZWxzZSB0aHJvdyBFcnJvcihHKGEsMywhMCkrXCIgbXVzdCBlaXRoZXIgYmUgYSBjYW5jZWwgY2FsbGJhY2sgb3IgYSBjb250ZXh0IG9iamVjdC5cIik7cmV0dXJuIGR9O2Z1bmN0aW9uIFMoYSxiKXtpZigxPT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLnc9YS5zcGxpdChcIi9cIik7Zm9yKHZhciBjPTAsZD0wO2Q8dGhpcy53Lmxlbmd0aDtkKyspMDx0aGlzLndbZF0ubGVuZ3RoJiYodGhpcy53W2NdPXRoaXMud1tkXSxjKyspO3RoaXMudy5sZW5ndGg9Yzt0aGlzLmNhPTB9ZWxzZSB0aGlzLnc9YSx0aGlzLmNhPWJ9ZnVuY3Rpb24gSShhKXtyZXR1cm4gYS5jYT49YS53Lmxlbmd0aD9udWxsOmEud1thLmNhXX1mdW5jdGlvbiBRYyhhKXtyZXR1cm4gYS53Lmxlbmd0aC1hLmNhfWZ1bmN0aW9uIFQoYSl7dmFyIGI9YS5jYTtiPGEudy5sZW5ndGgmJmIrKztyZXR1cm4gbmV3IFMoYS53LGIpfWZ1bmN0aW9uIFJjKGEpe3JldHVybiBhLmNhPGEudy5sZW5ndGg/YS53W2Eudy5sZW5ndGgtMV06bnVsbH1cblMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVwiXCIsYj10aGlzLmNhO2I8dGhpcy53Lmxlbmd0aDtiKyspXCJcIiE9PXRoaXMud1tiXSYmKGErPVwiL1wiK3RoaXMud1tiXSk7cmV0dXJuIGF8fFwiL1wifTtTLnByb3RvdHlwZS5wYXJlbnQ9ZnVuY3Rpb24oKXtpZih0aGlzLmNhPj10aGlzLncubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgYT1bXSxiPXRoaXMuY2E7Yjx0aGlzLncubGVuZ3RoLTE7YisrKWEucHVzaCh0aGlzLndbYl0pO3JldHVybiBuZXcgUyhhLDApfTtcblMucHJvdG90eXBlLm89ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9dGhpcy5jYTtjPHRoaXMudy5sZW5ndGg7YysrKWIucHVzaCh0aGlzLndbY10pO2lmKGEgaW5zdGFuY2VvZiBTKWZvcihjPWEuY2E7YzxhLncubGVuZ3RoO2MrKyliLnB1c2goYS53W2NdKTtlbHNlIGZvcihhPWEuc3BsaXQoXCIvXCIpLGM9MDtjPGEubGVuZ3RoO2MrKykwPGFbY10ubGVuZ3RoJiZiLnB1c2goYVtjXSk7cmV0dXJuIG5ldyBTKGIsMCl9O1MucHJvdG90eXBlLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYT49dGhpcy53Lmxlbmd0aH07dmFyIFU9bmV3IFMoXCJcIik7ZnVuY3Rpb24gVihhLGIpe3ZhciBjPUkoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7aWYoYz09PUkoYikpcmV0dXJuIFYoVChhKSxUKGIpKTt0aHJvdyBFcnJvcihcIklOVEVSTkFMIEVSUk9SOiBpbm5lclBhdGggKFwiK2IrXCIpIGlzIG5vdCB3aXRoaW4gb3V0ZXJQYXRoIChcIithK1wiKVwiKTt9XG5TLnByb3RvdHlwZS5lYT1mdW5jdGlvbihhKXtpZihRYyh0aGlzKSE9PVFjKGEpKXJldHVybiExO2Zvcih2YXIgYj10aGlzLmNhLGM9YS5jYTtiPD10aGlzLncubGVuZ3RoO2IrKyxjKyspaWYodGhpcy53W2JdIT09YS53W2NdKXJldHVybiExO3JldHVybiEwfTtTLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNhLGM9YS5jYTtpZihRYyh0aGlzKT5RYyhhKSlyZXR1cm4hMTtmb3IoO2I8dGhpcy53Lmxlbmd0aDspe2lmKHRoaXMud1tiXSE9PWEud1tjXSlyZXR1cm4hMTsrK2I7KytjfXJldHVybiEwfTtmdW5jdGlvbiBTYygpe3RoaXMuY2hpbGRyZW49e307dGhpcy5iZD0wO3RoaXMudmFsdWU9bnVsbH1mdW5jdGlvbiBUYyhhLGIsYyl7dGhpcy51ZD1hP2E6XCJcIjt0aGlzLk9jPWI/YjpudWxsO3RoaXMuQT1jP2M6bmV3IFNjfWZ1bmN0aW9uIFVjKGEsYil7Zm9yKHZhciBjPWIgaW5zdGFuY2VvZiBTP2I6bmV3IFMoYiksZD1hLGU7bnVsbCE9PShlPUkoYykpOylkPW5ldyBUYyhlLGQsdChkLkEuY2hpbGRyZW4sZSl8fG5ldyBTYyksYz1UKGMpO3JldHVybiBkfWg9VGMucHJvdG90eXBlO2guemE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5BLnZhbHVlfTtmdW5jdGlvbiBWYyhhLGIpe3koXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiLFwiQ2Fubm90IHNldCB2YWx1ZSB0byB1bmRlZmluZWRcIik7YS5BLnZhbHVlPWI7V2MoYSl9aC5jbGVhcj1mdW5jdGlvbigpe3RoaXMuQS52YWx1ZT1udWxsO3RoaXMuQS5jaGlsZHJlbj17fTt0aGlzLkEuYmQ9MDtXYyh0aGlzKX07XG5oLmxkPWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5BLmJkfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuemEoKSYmIXRoaXMubGQoKX07aC5VPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7QSh0aGlzLkEuY2hpbGRyZW4sZnVuY3Rpb24oYyxkKXthKG5ldyBUYyhkLGIsYykpfSl9O2Z1bmN0aW9uIFhjKGEsYixjLGQpe2MmJiFkJiZiKGEpO2EuVShmdW5jdGlvbihhKXtYYyhhLGIsITAsZCl9KTtjJiZkJiZiKGEpfWZ1bmN0aW9uIFljKGEsYil7Zm9yKHZhciBjPWEucGFyZW50KCk7bnVsbCE9PWMmJiFiKGMpOyljPWMucGFyZW50KCl9aC5wYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTKG51bGw9PT10aGlzLk9jP3RoaXMudWQ6dGhpcy5PYy5wYXRoKCkrXCIvXCIrdGhpcy51ZCl9O2gubmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVkfTtoLnBhcmVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLk9jfTtcbmZ1bmN0aW9uIFdjKGEpe2lmKG51bGwhPT1hLk9jKXt2YXIgYj1hLk9jLGM9YS51ZCxkPWEuZSgpLGU9cyhiLkEuY2hpbGRyZW4sYyk7ZCYmZT8oZGVsZXRlIGIuQS5jaGlsZHJlbltjXSxiLkEuYmQtLSxXYyhiKSk6ZHx8ZXx8KGIuQS5jaGlsZHJlbltjXT1hLkEsYi5BLmJkKyssV2MoYikpfX07ZnVuY3Rpb24gWmMoYSxiKXt0aGlzLkphPWE7dGhpcy51YT1iP2I6JGN9aD1aYy5wcm90b3R5cGU7aC5MYT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgWmModGhpcy5KYSx0aGlzLnVhLkxhKGEsYix0aGlzLkphKS5YKG51bGwsbnVsbCwhMSxudWxsLG51bGwpKX07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBaYyh0aGlzLkphLHRoaXMudWEucmVtb3ZlKGEsdGhpcy5KYSkuWChudWxsLG51bGwsITEsbnVsbCxudWxsKSl9O2guZ2V0PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjPXRoaXMudWE7IWMuZSgpOyl7Yj10aGlzLkphKGEsYy5rZXkpO2lmKDA9PT1iKXJldHVybiBjLnZhbHVlOzA+Yj9jPWMubGVmdDowPGImJihjPWMucmlnaHQpfXJldHVybiBudWxsfTtcbmZ1bmN0aW9uIGFkKGEsYil7Zm9yKHZhciBjLGQ9YS51YSxlPW51bGw7IWQuZSgpOyl7Yz1hLkphKGIsZC5rZXkpO2lmKDA9PT1jKXtpZihkLmxlZnQuZSgpKXJldHVybiBlP2Uua2V5Om51bGw7Zm9yKGQ9ZC5sZWZ0OyFkLnJpZ2h0LmUoKTspZD1kLnJpZ2h0O3JldHVybiBkLmtleX0wPmM/ZD1kLmxlZnQ6MDxjJiYoZT1kLGQ9ZC5yaWdodCl9dGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZmluZCBwcmVkZWNlc3NvciBrZXkgZm9yIGEgbm9uZXhpc3RlbnQga2V5LiAgV2hhdCBnaXZlcz9cIik7fWguZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVhLmUoKX07aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVhLmNvdW50KCl9O2guSWM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51YS5JYygpfTtoLlhiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudWEuWGIoKX07aC5mYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy51YS5mYShhKX07XG5oLk9iPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYmQodGhpcy51YSxudWxsLHRoaXMuSmEsITEsYSl9O2guUGI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGJkKHRoaXMudWEsYSx0aGlzLkphLCExLGIpfTtoLlJiPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBiZCh0aGlzLnVhLGEsdGhpcy5KYSwhMCxiKX07aC5nZj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGJkKHRoaXMudWEsbnVsbCx0aGlzLkphLCEwLGEpfTtmdW5jdGlvbiBiZChhLGIsYyxkLGUpe3RoaXMuSWQ9ZXx8bnVsbDt0aGlzLnZlPWQ7dGhpcy5OYT1bXTtmb3IoZT0xOyFhLmUoKTspaWYoZT1iP2MoYS5rZXksYik6MSxkJiYoZSo9LTEpLDA+ZSlhPXRoaXMudmU/YS5sZWZ0OmEucmlnaHQ7ZWxzZSBpZigwPT09ZSl7dGhpcy5OYS5wdXNoKGEpO2JyZWFrfWVsc2UgdGhpcy5OYS5wdXNoKGEpLGE9dGhpcy52ZT9hLnJpZ2h0OmEubGVmdH1cbmZ1bmN0aW9uIFAoYSl7aWYoMD09PWEuTmEubGVuZ3RoKXJldHVybiBudWxsO3ZhciBiPWEuTmEucG9wKCksYztjPWEuSWQ/YS5JZChiLmtleSxiLnZhbHVlKTp7a2V5OmIua2V5LHZhbHVlOmIudmFsdWV9O2lmKGEudmUpZm9yKGI9Yi5sZWZ0OyFiLmUoKTspYS5OYS5wdXNoKGIpLGI9Yi5yaWdodDtlbHNlIGZvcihiPWIucmlnaHQ7IWIuZSgpOylhLk5hLnB1c2goYiksYj1iLmxlZnQ7cmV0dXJuIGN9ZnVuY3Rpb24gY2QoYSl7aWYoMD09PWEuTmEubGVuZ3RoKXJldHVybiBudWxsO3ZhciBiO2I9YS5OYTtiPWJbYi5sZW5ndGgtMV07cmV0dXJuIGEuSWQ/YS5JZChiLmtleSxiLnZhbHVlKTp7a2V5OmIua2V5LHZhbHVlOmIudmFsdWV9fWZ1bmN0aW9uIGRkKGEsYixjLGQsZSl7dGhpcy5rZXk9YTt0aGlzLnZhbHVlPWI7dGhpcy5jb2xvcj1udWxsIT1jP2M6ITA7dGhpcy5sZWZ0PW51bGwhPWQ/ZDokYzt0aGlzLnJpZ2h0PW51bGwhPWU/ZTokY31oPWRkLnByb3RvdHlwZTtcbmguWD1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiBuZXcgZGQobnVsbCE9YT9hOnRoaXMua2V5LG51bGwhPWI/Yjp0aGlzLnZhbHVlLG51bGwhPWM/Yzp0aGlzLmNvbG9yLG51bGwhPWQ/ZDp0aGlzLmxlZnQsbnVsbCE9ZT9lOnRoaXMucmlnaHQpfTtoLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVmdC5jb3VudCgpKzErdGhpcy5yaWdodC5jb3VudCgpfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5mYT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5sZWZ0LmZhKGEpfHxhKHRoaXMua2V5LHRoaXMudmFsdWUpfHx0aGlzLnJpZ2h0LmZhKGEpfTtmdW5jdGlvbiBlZChhKXtyZXR1cm4gYS5sZWZ0LmUoKT9hOmVkKGEubGVmdCl9aC5JYz1mdW5jdGlvbigpe3JldHVybiBlZCh0aGlzKS5rZXl9O2guWGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodC5lKCk/dGhpcy5rZXk6dGhpcy5yaWdodC5YYigpfTtcbmguTGE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7ZT10aGlzO2Q9YyhhLGUua2V5KTtlPTA+ZD9lLlgobnVsbCxudWxsLG51bGwsZS5sZWZ0LkxhKGEsYixjKSxudWxsKTowPT09ZD9lLlgobnVsbCxiLG51bGwsbnVsbCxudWxsKTplLlgobnVsbCxudWxsLG51bGwsbnVsbCxlLnJpZ2h0LkxhKGEsYixjKSk7cmV0dXJuIGZkKGUpfTtmdW5jdGlvbiBnZChhKXtpZihhLmxlZnQuZSgpKXJldHVybiAkYzthLmxlZnQuYmEoKXx8YS5sZWZ0LmxlZnQuYmEoKXx8KGE9aGQoYSkpO2E9YS5YKG51bGwsbnVsbCxudWxsLGdkKGEubGVmdCksbnVsbCk7cmV0dXJuIGZkKGEpfVxuaC5yZW1vdmU9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkO2M9dGhpcztpZigwPmIoYSxjLmtleSkpYy5sZWZ0LmUoKXx8Yy5sZWZ0LmJhKCl8fGMubGVmdC5sZWZ0LmJhKCl8fChjPWhkKGMpKSxjPWMuWChudWxsLG51bGwsbnVsbCxjLmxlZnQucmVtb3ZlKGEsYiksbnVsbCk7ZWxzZXtjLmxlZnQuYmEoKSYmKGM9amQoYykpO2MucmlnaHQuZSgpfHxjLnJpZ2h0LmJhKCl8fGMucmlnaHQubGVmdC5iYSgpfHwoYz1rZChjKSxjLmxlZnQubGVmdC5iYSgpJiYoYz1qZChjKSxjPWtkKGMpKSk7aWYoMD09PWIoYSxjLmtleSkpe2lmKGMucmlnaHQuZSgpKXJldHVybiAkYztkPWVkKGMucmlnaHQpO2M9Yy5YKGQua2V5LGQudmFsdWUsbnVsbCxudWxsLGdkKGMucmlnaHQpKX1jPWMuWChudWxsLG51bGwsbnVsbCxudWxsLGMucmlnaHQucmVtb3ZlKGEsYikpfXJldHVybiBmZChjKX07aC5iYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbG9yfTtcbmZ1bmN0aW9uIGZkKGEpe2EucmlnaHQuYmEoKSYmIWEubGVmdC5iYSgpJiYoYT1sZChhKSk7YS5sZWZ0LmJhKCkmJmEubGVmdC5sZWZ0LmJhKCkmJihhPWpkKGEpKTthLmxlZnQuYmEoKSYmYS5yaWdodC5iYSgpJiYoYT1rZChhKSk7cmV0dXJuIGF9ZnVuY3Rpb24gaGQoYSl7YT1rZChhKTthLnJpZ2h0LmxlZnQuYmEoKSYmKGE9YS5YKG51bGwsbnVsbCxudWxsLG51bGwsamQoYS5yaWdodCkpLGE9bGQoYSksYT1rZChhKSk7cmV0dXJuIGF9ZnVuY3Rpb24gbGQoYSl7cmV0dXJuIGEucmlnaHQuWChudWxsLG51bGwsYS5jb2xvcixhLlgobnVsbCxudWxsLCEwLG51bGwsYS5yaWdodC5sZWZ0KSxudWxsKX1mdW5jdGlvbiBqZChhKXtyZXR1cm4gYS5sZWZ0LlgobnVsbCxudWxsLGEuY29sb3IsbnVsbCxhLlgobnVsbCxudWxsLCEwLGEubGVmdC5yaWdodCxudWxsKSl9XG5mdW5jdGlvbiBrZChhKXtyZXR1cm4gYS5YKG51bGwsbnVsbCwhYS5jb2xvcixhLmxlZnQuWChudWxsLG51bGwsIWEubGVmdC5jb2xvcixudWxsLG51bGwpLGEucmlnaHQuWChudWxsLG51bGwsIWEucmlnaHQuY29sb3IsbnVsbCxudWxsKSl9ZnVuY3Rpb24gbWQoKXt9aD1tZC5wcm90b3R5cGU7aC5YPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2guTGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGRkKGEsYixudWxsKX07aC5yZW1vdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiAwfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07aC5mYT1mdW5jdGlvbigpe3JldHVybiExfTtoLkljPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O2guWGI9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07aC5iYT1mdW5jdGlvbigpe3JldHVybiExfTt2YXIgJGM9bmV3IG1kO2Z1bmN0aW9uIG5kKGEsYil7dGhpcy5EPWE7eShtKHRoaXMuRCkmJm51bGwhPT10aGlzLkQsXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTt0aGlzLmhhPWJ8fE07b2QodGhpcy5oYSk7dGhpcy5zYj1udWxsfWg9bmQucHJvdG90eXBlO2guTT1mdW5jdGlvbigpe3JldHVybiEwfTtoLkw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYX07aC5aPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbmQodGhpcy5ELGEpfTtoLks9ZnVuY3Rpb24oYSl7cmV0dXJuXCIucHJpb3JpdHlcIj09PWE/dGhpcy5oYTpNfTtoLnJhPWZ1bmN0aW9uKGEpe3JldHVybiBhLmUoKT90aGlzOlwiLnByaW9yaXR5XCI9PT1JKGEpP3RoaXMuaGE6TX07aC5EYT1mdW5jdGlvbigpe3JldHVybiExfTtoLmZmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuaC5QPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCIucHJpb3JpdHlcIj09PWE/dGhpcy5aKGIpOmIuZSgpJiZcIi5wcmlvcml0eVwiIT09YT90aGlzOk0uUChhLGIpLloodGhpcy5oYSl9O2guQz1mdW5jdGlvbihhLGIpe3ZhciBjPUkoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7aWYoYi5lKCkmJlwiLnByaW9yaXR5XCIhPT1jKXJldHVybiB0aGlzO3koXCIucHJpb3JpdHlcIiE9PWN8fDE9PT1RYyhhKSxcIi5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aFwiKTtyZXR1cm4gdGhpcy5QKGMsTS5DKFQoYSksYikpfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC51Yj1mdW5jdGlvbigpe3JldHVybiAwfTtoLkk9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJiF0aGlzLkwoKS5lKCk/e1wiLnZhbHVlXCI6dGhpcy56YSgpLFwiLnByaW9yaXR5XCI6dGhpcy5MKCkuSSgpfTp0aGlzLnphKCl9O1xuaC5oYXNoPWZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuc2Ipe3ZhciBhPVwiXCI7dGhpcy5oYS5lKCl8fChhKz1cInByaW9yaXR5OlwiK3BkKHRoaXMuaGEuSSgpKStcIjpcIik7dmFyIGI9dHlwZW9mIHRoaXMuRCxhPWErKGIrXCI6XCIpLGE9XCJudW1iZXJcIj09PWI/YStBYih0aGlzLkQpOmErdGhpcy5EO3RoaXMuc2I9aWIoYSl9cmV0dXJuIHRoaXMuc2J9O2guemE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5EfTtoLmhlPWZ1bmN0aW9uKGEpe2lmKGE9PT1NKXJldHVybiAxO2lmKGEgaW5zdGFuY2VvZiBXKXJldHVybi0xO3koYS5NKCksXCJVbmtub3duIG5vZGUgdHlwZVwiKTt2YXIgYj10eXBlb2YgYS5ELGM9dHlwZW9mIHRoaXMuRCxkPUdhKHFkLGIpLGU9R2EocWQsYyk7eSgwPD1kLFwiVW5rbm93biBsZWFmIHR5cGU6IFwiK2IpO3koMDw9ZSxcIlVua25vd24gbGVhZiB0eXBlOiBcIitjKTtyZXR1cm4gZD09PWU/XCJvYmplY3RcIj09PWM/MDp0aGlzLkQ8YS5EPy0xOnRoaXMuRD09PWEuRD8wOjE6ZS1kfTtcbnZhciBxZD1bXCJvYmplY3RcIixcImJvb2xlYW5cIixcIm51bWJlclwiLFwic3RyaW5nXCJdO25kLnByb3RvdHlwZS5GYj1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtuZC5wcm90b3R5cGUuQmM9ZnVuY3Rpb24oKXtyZXR1cm4hMH07bmQucHJvdG90eXBlLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpcz8hMDphLk0oKT90aGlzLkQ9PT1hLkQmJnRoaXMuaGEuZWEoYS5oYSk6ITF9O25kLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiByKHRoaXMuSSghMCkpfTtmdW5jdGlvbiByZChhLGIpe3RoaXMucGQ9YTt0aGlzLlZiPWJ9cmQucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXt2YXIgYj10KHRoaXMucGQsYSk7aWYoIWIpdGhyb3cgRXJyb3IoXCJObyBpbmRleCBkZWZpbmVkIGZvciBcIithKTtyZXR1cm4gYj09PWxjP251bGw6Yn07ZnVuY3Rpb24gc2QoYSxiLGMpe3ZhciBkPXRkKGEucGQsZnVuY3Rpb24oZCxmKXt2YXIgZz10KGEuVmIsZik7eShnLFwiTWlzc2luZyBpbmRleCBpbXBsZW1lbnRhdGlvbiBmb3IgXCIrZik7aWYoZD09PWxjKXtpZihnLnVlKGIuWSkpe2Zvcih2YXIgaz1bXSxsPWMuT2IoemMpLG49UChsKTtuOyluLm5hbWUhPWIubmFtZSYmay5wdXNoKG4pLG49UChsKTtrLnB1c2goYik7cmV0dXJuIHVkKGssbWMoZykpfXJldHVybiBsY31nPWMuZ2V0KGIubmFtZSk7az1kO2cmJihrPWsucmVtb3ZlKG5ldyBOKGIubmFtZSxnKSkpO3JldHVybiBrLkxhKGIsYi5ZKX0pO3JldHVybiBuZXcgcmQoZCxhLlZiKX1cbmZ1bmN0aW9uIHZkKGEsYixjKXt2YXIgZD10ZChhLnBkLGZ1bmN0aW9uKGEpe2lmKGE9PT1sYylyZXR1cm4gYTt2YXIgZD1jLmdldChiLm5hbWUpO3JldHVybiBkP2EucmVtb3ZlKG5ldyBOKGIubmFtZSxkKSk6YX0pO3JldHVybiBuZXcgcmQoZCxhLlZiKX12YXIgd2Q9bmV3IHJkKHtcIi5wcmlvcml0eVwiOmxjfSx7XCIucHJpb3JpdHlcIjpMfSk7ZnVuY3Rpb24gVyhhLGIsYyl7dGhpcy5tPWE7KHRoaXMuaGE9YikmJm9kKHRoaXMuaGEpO3RoaXMub2I9Yzt0aGlzLnNiPW51bGx9aD1XLnByb3RvdHlwZTtoLk09ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5MPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGF8fE19O2guWj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFcodGhpcy5tLGEsdGhpcy5vYil9O2guSz1mdW5jdGlvbihhKXtpZihcIi5wcmlvcml0eVwiPT09YSlyZXR1cm4gdGhpcy5MKCk7YT10aGlzLm0uZ2V0KGEpO3JldHVybiBudWxsPT09YT9NOmF9O2gucmE9ZnVuY3Rpb24oYSl7dmFyIGI9SShhKTtyZXR1cm4gbnVsbD09PWI/dGhpczp0aGlzLksoYikucmEoVChhKSl9O2guRGE9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT10aGlzLm0uZ2V0KGEpfTtcbmguUD1mdW5jdGlvbihhLGIpe3koYixcIldlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2Rlc1wiKTtpZihcIi5wcmlvcml0eVwiPT09YSlyZXR1cm4gdGhpcy5aKGIpO3ZhciBjPW5ldyBOKGEsYiksZDtiLmUoKT8oZD10aGlzLm0ucmVtb3ZlKGEpLGM9dmQodGhpcy5vYixjLHRoaXMubSkpOihkPXRoaXMubS5MYShhLGIpLGM9c2QodGhpcy5vYixjLHRoaXMubSkpO3JldHVybiBuZXcgVyhkLHRoaXMuaGEsYyl9O2guQz1mdW5jdGlvbihhLGIpe3ZhciBjPUkoYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7eShcIi5wcmlvcml0eVwiIT09SShhKXx8MT09PVFjKGEpLFwiLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoXCIpO3ZhciBkPXRoaXMuSyhjKS5DKFQoYSksYik7cmV0dXJuIHRoaXMuUChjLGQpfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tLmUoKX07aC51Yj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm0uY291bnQoKX07dmFyIHhkPS9eKDB8WzEtOV1cXGQqKSQvO1xuaD1XLnByb3RvdHlwZTtoLkk9ZnVuY3Rpb24oYSl7aWYodGhpcy5lKCkpcmV0dXJuIG51bGw7dmFyIGI9e30sYz0wLGQ9MCxlPSEwO3RoaXMuVShMLGZ1bmN0aW9uKGYsZyl7YltmXT1nLkkoYSk7YysrO2UmJnhkLnRlc3QoZik/ZD1NYXRoLm1heChkLE51bWJlcihmKSk6ZT0hMX0pO2lmKCFhJiZlJiZkPDIqYyl7dmFyIGY9W10sZztmb3IoZyBpbiBiKWZbZ109YltnXTtyZXR1cm4gZn1hJiYhdGhpcy5MKCkuZSgpJiYoYltcIi5wcmlvcml0eVwiXT10aGlzLkwoKS5JKCkpO3JldHVybiBifTtoLmhhc2g9ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5zYil7dmFyIGE9XCJcIjt0aGlzLkwoKS5lKCl8fChhKz1cInByaW9yaXR5OlwiK3BkKHRoaXMuTCgpLkkoKSkrXCI6XCIpO3RoaXMuVShMLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yy5oYXNoKCk7XCJcIiE9PWQmJihhKz1cIjpcIitiK1wiOlwiK2QpfSk7dGhpcy5zYj1cIlwiPT09YT9cIlwiOmliKGEpfXJldHVybiB0aGlzLnNifTtcbmguZmY9ZnVuY3Rpb24oYSxiLGMpe3JldHVybihjPXlkKHRoaXMsYykpPyhhPWFkKGMsbmV3IE4oYSxiKSkpP2EubmFtZTpudWxsOmFkKHRoaXMubSxhKX07ZnVuY3Rpb24gQ2MoYSxiKXt2YXIgYztjPShjPXlkKGEsYikpPyhjPWMuSWMoKSkmJmMubmFtZTphLm0uSWMoKTtyZXR1cm4gYz9uZXcgTihjLGEubS5nZXQoYykpOm51bGx9ZnVuY3Rpb24gRGMoYSxiKXt2YXIgYztjPShjPXlkKGEsYikpPyhjPWMuWGIoKSkmJmMubmFtZTphLm0uWGIoKTtyZXR1cm4gYz9uZXcgTihjLGEubS5nZXQoYykpOm51bGx9aC5VPWZ1bmN0aW9uKGEsYil7dmFyIGM9eWQodGhpcyxhKTtyZXR1cm4gYz9jLmZhKGZ1bmN0aW9uKGEpe3JldHVybiBiKGEubmFtZSxhLlkpfSk6dGhpcy5tLmZhKGIpfTtoLk9iPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlBiKGEuQ2UoKSxhKX07XG5oLlBiPWZ1bmN0aW9uKGEsYil7dmFyIGM9eWQodGhpcyxiKTtpZihjKXJldHVybiBjLlBiKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmb3IodmFyIGM9dGhpcy5tLlBiKGEubmFtZSx6YyksZD1jZChjKTtudWxsIT1kJiYwPmIuY29tcGFyZShkLGEpOylQKGMpLGQ9Y2QoYyk7cmV0dXJuIGN9O2guZ2Y9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuUmIoYS5CZSgpLGEpfTtoLlJiPWZ1bmN0aW9uKGEsYil7dmFyIGM9eWQodGhpcyxiKTtpZihjKXJldHVybiBjLlJiKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmb3IodmFyIGM9dGhpcy5tLlJiKGEubmFtZSx6YyksZD1jZChjKTtudWxsIT1kJiYwPGIuY29tcGFyZShkLGEpOylQKGMpLGQ9Y2QoYyk7cmV0dXJuIGN9O2guaGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZSgpP2EuZSgpPzA6LTE6YS5NKCl8fGEuZSgpPzE6YT09PXBjPy0xOjB9O1xuaC5GYj1mdW5jdGlvbihhKXtpZihhPT09cmN8fHpkKHRoaXMub2IuVmIsYS50b1N0cmluZygpKSlyZXR1cm4gdGhpczt2YXIgYj10aGlzLm9iLGM9dGhpcy5tO3koYSE9PXJjLFwiS2V5SW5kZXggYWx3YXlzIGV4aXN0cyBhbmQgaXNuJ3QgbWVhbnQgdG8gYmUgYWRkZWQgdG8gdGhlIEluZGV4TWFwLlwiKTtmb3IodmFyIGQ9W10sZT0hMSxjPWMuT2IoemMpLGY9UChjKTtmOyllPWV8fGEudWUoZi5ZKSxkLnB1c2goZiksZj1QKGMpO2Q9ZT91ZChkLG1jKGEpKTpsYztlPWEudG9TdHJpbmcoKTtjPUFkKGIuVmIpO2NbZV09YTthPUFkKGIucGQpO2FbZV09ZDtyZXR1cm4gbmV3IFcodGhpcy5tLHRoaXMuaGEsbmV3IHJkKGEsYykpfTtoLkJjPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09cmN8fHpkKHRoaXMub2IuVmIsYS50b1N0cmluZygpKX07XG5oLmVhPWZ1bmN0aW9uKGEpe2lmKGE9PT10aGlzKXJldHVybiEwO2lmKGEuTSgpKXJldHVybiExO2lmKHRoaXMuTCgpLmVhKGEuTCgpKSYmdGhpcy5tLmNvdW50KCk9PT1hLm0uY291bnQoKSl7dmFyIGI9dGhpcy5PYihMKTthPWEuT2IoTCk7Zm9yKHZhciBjPVAoYiksZD1QKGEpO2MmJmQ7KXtpZihjLm5hbWUhPT1kLm5hbWV8fCFjLlkuZWEoZC5ZKSlyZXR1cm4hMTtjPVAoYik7ZD1QKGEpfXJldHVybiBudWxsPT09YyYmbnVsbD09PWR9cmV0dXJuITF9O2Z1bmN0aW9uIHlkKGEsYil7cmV0dXJuIGI9PT1yYz9udWxsOmEub2IuZ2V0KGIudG9TdHJpbmcoKSl9aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiByKHRoaXMuSSghMCkpfTtmdW5jdGlvbiBPKGEsYil7aWYobnVsbD09PWEpcmV0dXJuIE07dmFyIGM9bnVsbDtcIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiLnByaW9yaXR5XCJpbiBhP2M9YVtcIi5wcmlvcml0eVwiXTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGImJihjPWIpO3kobnVsbD09PWN8fFwic3RyaW5nXCI9PT10eXBlb2YgY3x8XCJudW1iZXJcIj09PXR5cGVvZiBjfHxcIm9iamVjdFwiPT09dHlwZW9mIGMmJlwiLnN2XCJpbiBjLFwiSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiBcIit0eXBlb2YgYyk7XCJvYmplY3RcIj09PXR5cGVvZiBhJiZcIi52YWx1ZVwiaW4gYSYmbnVsbCE9PWFbXCIudmFsdWVcIl0mJihhPWFbXCIudmFsdWVcIl0pO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8XCIuc3ZcImluIGEpcmV0dXJuIG5ldyBuZChhLE8oYykpO2lmKGEgaW5zdGFuY2VvZiBBcnJheSl7dmFyIGQ9TSxlPWE7QShlLGZ1bmN0aW9uKGEsYil7aWYocyhlLGIpJiZcIi5cIiE9PWIuc3Vic3RyaW5nKDAsMSkpe3ZhciBjPU8oYSk7aWYoYy5NKCl8fCFjLmUoKSlkPVxuZC5QKGIsYyl9fSk7cmV0dXJuIGQuWihPKGMpKX12YXIgZj1bXSxnPSExLGs9YTt1YShrLGZ1bmN0aW9uKGEpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYXx8XCIuXCIhPT1hLnN1YnN0cmluZygwLDEpKXt2YXIgYj1PKGtbYV0pO2IuZSgpfHwoZz1nfHwhYi5MKCkuZSgpLGYucHVzaChuZXcgTihhLGIpKSl9fSk7dmFyIGw9dWQoZixpYyxmdW5jdGlvbihhKXtyZXR1cm4gYS5uYW1lfSxqYyk7aWYoZyl7dmFyIG49dWQoZixtYyhMKSk7cmV0dXJuIG5ldyBXKGwsTyhjKSxuZXcgcmQoe1wiLnByaW9yaXR5XCI6bn0se1wiLnByaW9yaXR5XCI6TH0pKX1yZXR1cm4gbmV3IFcobCxPKGMpLHdkKX12YXIgQmQ9TWF0aC5sb2coMik7ZnVuY3Rpb24gQ2QoYSl7dGhpcy5jb3VudD1wYXJzZUludChNYXRoLmxvZyhhKzEpL0JkLDEwKTt0aGlzLiRlPXRoaXMuY291bnQtMTt0aGlzLk5mPWErMSZwYXJzZUludChBcnJheSh0aGlzLmNvdW50KzEpLmpvaW4oXCIxXCIpLDIpfVxuZnVuY3Rpb24gRGQoYSl7dmFyIGI9IShhLk5mJjE8PGEuJGUpO2EuJGUtLTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHVkKGEsYixjLGQpe2Z1bmN0aW9uIGUoYixkKXt2YXIgZj1kLWI7aWYoMD09ZilyZXR1cm4gbnVsbDtpZigxPT1mKXt2YXIgbj1hW2JdLHU9Yz9jKG4pOm47cmV0dXJuIG5ldyBkZCh1LG4uWSwhMSxudWxsLG51bGwpfXZhciBuPXBhcnNlSW50KGYvMiwxMCkrYixmPWUoYixuKSx4PWUobisxLGQpLG49YVtuXSx1PWM/YyhuKTpuO3JldHVybiBuZXcgZGQodSxuLlksITEsZix4KX1hLnNvcnQoYik7dmFyIGY9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZChiLGcpe3ZhciBrPXUtYix4PXU7dS09Yjt2YXIgeD1lKGsrMSx4KSxrPWFba10sRT1jP2Moayk6ayx4PW5ldyBkZChFLGsuWSxnLG51bGwseCk7Zj9mLmxlZnQ9eDpuPXg7Zj14fWZvcih2YXIgZj1udWxsLG49bnVsbCx1PWEubGVuZ3RoLHg9MDt4PGIuY291bnQ7Kyt4KXt2YXIgRT1EZChiKSxpZD1NYXRoLnBvdygyLGIuY291bnQtKHgrMSkpO0U/ZChpZCwhMSk6KGQoaWQsITEpLGQoaWQsITApKX1yZXR1cm4gbn0obmV3IENkKGEubGVuZ3RoKSk7XG5yZXR1cm4gbnVsbCE9PWY/bmV3IFpjKGR8fGIsZik6bmV3IFpjKGR8fGIpfWZ1bmN0aW9uIHBkKGEpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYT9cIm51bWJlcjpcIitBYihhKTpcInN0cmluZzpcIithfWZ1bmN0aW9uIG9kKGEpe2lmKGEuTSgpKXt2YXIgYj1hLkkoKTt5KFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBifHxcIm9iamVjdFwiPT09dHlwZW9mIGImJnMoYixcIi5zdlwiKSxcIlByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLlwiKX1lbHNlIHkoYT09PXBjfHxhLmUoKSxcInByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS5cIik7eShhPT09cGN8fGEuTCgpLmUoKSxcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpfXZhciBNPW5ldyBXKG5ldyBaYyhqYyksbnVsbCx3ZCk7ZnVuY3Rpb24gRWQoKXtXLmNhbGwodGhpcyxuZXcgWmMoamMpLE0sd2QpfW1hKEVkLFcpO2g9RWQucHJvdG90eXBlO1xuaC5oZT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/MDoxfTtoLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpc307aC5MPWZ1bmN0aW9uKCl7dGhyb3cgZmIoXCJXaHkgaXMgdGhpcyBjYWxsZWQ/XCIpO307aC5LPWZ1bmN0aW9uKCl7cmV0dXJuIE19O2guZT1mdW5jdGlvbigpe3JldHVybiExfTt2YXIgcGM9bmV3IEVkLG5jPW5ldyBOKFwiW01JTl9OQU1FXVwiLE0pO2Z1bmN0aW9uIEQoYSxiLGMpe3RoaXMuQT1hO3RoaXMuVj1iO3RoaXMuZz1jfUQucHJvdG90eXBlLkk9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LnZhbFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkkoKX07RC5wcm90b3R5cGUudmFsPUQucHJvdG90eXBlLkk7RC5wcm90b3R5cGUuYmY9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmV4cG9ydFZhbFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkkoITApfTtELnByb3RvdHlwZS5leHBvcnRWYWw9RC5wcm90b3R5cGUuYmY7RC5wcm90b3R5cGUuV2Y9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmV4aXN0c1wiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4hdGhpcy5BLmUoKX07RC5wcm90b3R5cGUuZXhpc3RzPUQucHJvdG90eXBlLldmO1xuRC5wcm90b3R5cGUubz1mdW5jdGlvbihhKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmNoaWxkXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO2dhKGEpJiYoYT1TdHJpbmcoYSkpO1liKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmNoaWxkXCIsYSk7dmFyIGI9bmV3IFMoYSksYz10aGlzLlYubyhiKTtyZXR1cm4gbmV3IEQodGhpcy5BLnJhKGIpLGMsTCl9O0QucHJvdG90eXBlLmNoaWxkPUQucHJvdG90eXBlLm87RC5wcm90b3R5cGUuRGE9ZnVuY3Rpb24oYSl7RihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtZYihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZFwiLGEpO3ZhciBiPW5ldyBTKGEpO3JldHVybiF0aGlzLkEucmEoYikuZSgpfTtELnByb3RvdHlwZS5oYXNDaGlsZD1ELnByb3RvdHlwZS5EYTtcbkQucHJvdG90eXBlLkw9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmdldFByaW9yaXR5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuTCgpLkkoKX07RC5wcm90b3R5cGUuZ2V0UHJpb3JpdHk9RC5wcm90b3R5cGUuTDtELnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGEpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZm9yRWFjaFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmZvckVhY2hcIiwxLGEsITEpO2lmKHRoaXMuQS5NKCkpcmV0dXJuITE7dmFyIGI9dGhpcztyZXR1cm4hIXRoaXMuQS5VKHRoaXMuZyxmdW5jdGlvbihjLGQpe3JldHVybiBhKG5ldyBEKGQsYi5WLm8oYyksTCkpfSl9O0QucHJvdG90eXBlLmZvckVhY2g9RC5wcm90b3R5cGUuZm9yRWFjaDtcbkQucHJvdG90eXBlLmxkPWZ1bmN0aW9uKCl7RihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLk0oKT8hMTohdGhpcy5BLmUoKX07RC5wcm90b3R5cGUuaGFzQ2hpbGRyZW49RC5wcm90b3R5cGUubGQ7RC5wcm90b3R5cGUubmFtZT1mdW5jdGlvbigpe3ooXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubmFtZSgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2UuRGF0YVNuYXBzaG90LmtleSgpIGluc3RlYWQuXCIpO0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubmFtZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5rZXkoKX07RC5wcm90b3R5cGUubmFtZT1ELnByb3RvdHlwZS5uYW1lO0QucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3Qua2V5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLlYua2V5KCl9O1xuRC5wcm90b3R5cGUua2V5PUQucHJvdG90eXBlLmtleTtELnByb3RvdHlwZS51Yj1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubnVtQ2hpbGRyZW5cIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS51YigpfTtELnByb3RvdHlwZS5udW1DaGlsZHJlbj1ELnByb3RvdHlwZS51YjtELnByb3RvdHlwZS5jYz1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLlZ9O0QucHJvdG90eXBlLnJlZj1ELnByb3RvdHlwZS5jYztmdW5jdGlvbiBGZChhKXt5KGVhKGEpJiYwPGEubGVuZ3RoLFwiUmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXlcIik7dGhpcy5GZj1hO3RoaXMuR2M9e319RmQucHJvdG90eXBlLlZkPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuR2NbYV18fFtdLGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLnFjLmFwcGx5KGNbZF0uS2EsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX07RmQucHJvdG90eXBlLnZiPWZ1bmN0aW9uKGEsYixjKXtHZCh0aGlzLGEpO3RoaXMuR2NbYV09dGhpcy5HY1thXXx8W107dGhpcy5HY1thXS5wdXNoKHtxYzpiLEthOmN9KTsoYT10aGlzLnFlKGEpKSYmYi5hcHBseShjLGEpfTtGZC5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oYSxiLGMpe0dkKHRoaXMsYSk7YT10aGlzLkdjW2FdfHxbXTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLnFjPT09YiYmKCFjfHxjPT09YVtkXS5LYSkpe2Euc3BsaWNlKGQsMSk7YnJlYWt9fTtcbmZ1bmN0aW9uIEdkKGEsYil7eShNYShhLkZmLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09Yn0pLFwiVW5rbm93biBldmVudDogXCIrYil9O2Z1bmN0aW9uIEhkKCl7RmQuY2FsbCh0aGlzLFtcInZpc2libGVcIl0pO3ZhciBhLGI7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyJiYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5oaWRkZW4/KGI9XCJ2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cImhpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbj8oYj1cIm1venZpc2liaWxpdHljaGFuZ2VcIixhPVwibW96SGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4/KGI9XCJtc3Zpc2liaWxpdHljaGFuZ2VcIixhPVwibXNIaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4mJihiPVwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJ3ZWJraXRIaWRkZW5cIikpO3RoaXMubWM9ITA7aWYoYil7dmFyIGM9dGhpcztkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGIsXG5mdW5jdGlvbigpe3ZhciBiPSFkb2N1bWVudFthXTtiIT09Yy5tYyYmKGMubWM9YixjLlZkKFwidmlzaWJsZVwiLGIpKX0sITEpfX1tYShIZCxGZCk7Y2EoSGQpO0hkLnByb3RvdHlwZS5xZT1mdW5jdGlvbihhKXt5KFwidmlzaWJsZVwiPT09YSxcIlVua25vd24gZXZlbnQgdHlwZTogXCIrYSk7cmV0dXJuW3RoaXMubWNdfTtmdW5jdGlvbiBJZCgpe0ZkLmNhbGwodGhpcyxbXCJvbmxpbmVcIl0pO3RoaXMuTGM9ITA7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBhPXRoaXM7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIixmdW5jdGlvbigpe2EuTGN8fGEuVmQoXCJvbmxpbmVcIiwhMCk7YS5MYz0hMH0sITEpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLGZ1bmN0aW9uKCl7YS5MYyYmYS5WZChcIm9ubGluZVwiLCExKTthLkxjPSExfSwhMSl9fW1hKElkLEZkKTtjYShJZCk7SWQucHJvdG90eXBlLnFlPWZ1bmN0aW9uKGEpe3koXCJvbmxpbmVcIj09PWEsXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiK2EpO3JldHVyblt0aGlzLkxjXX07ZnVuY3Rpb24gQShhLGIpe2Zvcih2YXIgYyBpbiBhKWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpfWZ1bmN0aW9uIHRkKGEsYil7dmFyIGM9e30sZDtmb3IoZCBpbiBhKWNbZF09Yi5jYWxsKHZvaWQgMCxhW2RdLGQsYSk7cmV0dXJuIGN9ZnVuY3Rpb24gTGIoYSxiKXtmb3IodmFyIGMgaW4gYSlpZighYi5jYWxsKHZvaWQgMCxhW2NdLGMsYSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gSmIoYSl7dmFyIGI9MCxjO2ZvcihjIGluIGEpYisrO3JldHVybiBifWZ1bmN0aW9uIEtiKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiBifWZ1bmN0aW9uIEpkKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWFbZF07cmV0dXJuIGJ9ZnVuY3Rpb24gS2QoYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109ZDtyZXR1cm4gYn1mdW5jdGlvbiB6ZChhLGIpe2Zvcih2YXIgYyBpbiBhKWlmKGFbY109PWIpcmV0dXJuITA7cmV0dXJuITF9XG5mdW5jdGlvbiBMZChhLGIsYyl7Zm9yKHZhciBkIGluIGEpaWYoYi5jYWxsKGMsYVtkXSxkLGEpKXJldHVybiBkfWZ1bmN0aW9uIE1kKGEsYil7dmFyIGM9TGQoYSxiLHZvaWQgMCk7cmV0dXJuIGMmJmFbY119ZnVuY3Rpb24gTmQoYSl7Zm9yKHZhciBiIGluIGEpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gT2QoYSxiKXtyZXR1cm4gYiBpbiBhP2FbYl06dm9pZCAwfWZ1bmN0aW9uIEFkKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSliW2NdPWFbY107cmV0dXJuIGJ9dmFyIFBkPVwiY29uc3RydWN0b3IgaGFzT3duUHJvcGVydHkgaXNQcm90b3R5cGVPZiBwcm9wZXJ0eUlzRW51bWVyYWJsZSB0b0xvY2FsZVN0cmluZyB0b1N0cmluZyB2YWx1ZU9mXCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gUWQoYSxiKXtmb3IodmFyIGMsZCxlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7ZD1hcmd1bWVudHNbZV07Zm9yKGMgaW4gZClhW2NdPWRbY107Zm9yKHZhciBmPTA7ZjxQZC5sZW5ndGg7ZisrKWM9UGRbZl0sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsYykmJihhW2NdPWRbY10pfX07ZnVuY3Rpb24gUmQoKXt0aGlzLnRjPXt9fWZ1bmN0aW9uIFNkKGEsYixjKXttKGMpfHwoYz0xKTtzKGEudGMsYil8fChhLnRjW2JdPTApO2EudGNbYl0rPWN9UmQucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3JldHVybiBBZCh0aGlzLnRjKX07ZnVuY3Rpb24gVGQoYSl7dGhpcy5QZj1hO3RoaXMucmQ9bnVsbH1UZC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5QZi5nZXQoKSxiPUFkKGEpO2lmKHRoaXMucmQpZm9yKHZhciBjIGluIHRoaXMucmQpYltjXS09dGhpcy5yZFtjXTt0aGlzLnJkPWE7cmV0dXJuIGJ9O2Z1bmN0aW9uIFVkKGEsYil7dGhpcy56Zj17fTt0aGlzLlBkPW5ldyBUZChhKTt0aGlzLlM9Yjt2YXIgYz0xRTQrMkU0Kk1hdGgucmFuZG9tKCk7c2V0VGltZW91dChxKHRoaXMudGYsdGhpcyksTWF0aC5mbG9vcihjKSl9VWQucHJvdG90eXBlLnRmPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5QZC5nZXQoKSxiPXt9LGM9ITEsZDtmb3IoZCBpbiBhKTA8YVtkXSYmcyh0aGlzLnpmLGQpJiYoYltkXT1hW2RdLGM9ITApO2MmJihhPXRoaXMuUyxhLmphJiYoYj17YzpifSxhLmYoXCJyZXBvcnRTdGF0c1wiLGIpLGEuQ2EoXCJzXCIsYikpKTtzZXRUaW1lb3V0KHEodGhpcy50Zix0aGlzKSxNYXRoLmZsb29yKDZFNSpNYXRoLnJhbmRvbSgpKSl9O3ZhciBWZD17fSxXZD17fTtmdW5jdGlvbiBYZChhKXthPWEudG9TdHJpbmcoKTtWZFthXXx8KFZkW2FdPW5ldyBSZCk7cmV0dXJuIFZkW2FdfWZ1bmN0aW9uIFlkKGEsYil7dmFyIGM9YS50b1N0cmluZygpO1dkW2NdfHwoV2RbY109YigpKTtyZXR1cm4gV2RbY119O3ZhciBaZD1udWxsO1widW5kZWZpbmVkXCIhPT10eXBlb2YgTW96V2ViU29ja2V0P1pkPU1veldlYlNvY2tldDpcInVuZGVmaW5lZFwiIT09dHlwZW9mIFdlYlNvY2tldCYmKFpkPVdlYlNvY2tldCk7ZnVuY3Rpb24gJGQoYSxiLGMpe3RoaXMuaWU9YTt0aGlzLmY9b2IodGhpcy5pZSk7dGhpcy5mcmFtZXM9dGhpcy5DYz1udWxsO3RoaXMuaWI9dGhpcy5qYj10aGlzLlRlPTA7dGhpcy5SYT1YZChiKTt0aGlzLiRhPShiLkFiP1wid3NzOi8vXCI6XCJ3czovL1wiKStiLk1hK1wiLy53cz92PTVcIjtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGxvY2F0aW9uJiZsb2NhdGlvbi5ocmVmJiYtMSE9PWxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImZpcmViYXNlaW8uY29tXCIpJiYodGhpcy4kYSs9XCImcj1mXCIpO2IuaG9zdCE9PWIuTWEmJih0aGlzLiRhPXRoaXMuJGErXCImbnM9XCIrYi50Yik7YyYmKHRoaXMuJGE9dGhpcy4kYStcIiZzPVwiK2MpfXZhciBhZTtcbiRkLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7dGhpcy5mYj1iO3RoaXMuaGc9YTt0aGlzLmYoXCJXZWJzb2NrZXQgY29ubmVjdGluZyB0byBcIit0aGlzLiRhKTt0aGlzLnhjPSExO3phLnNldChcInByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlXCIsITApO3RyeXt0aGlzLnRhPW5ldyBaZCh0aGlzLiRhKX1jYXRjaChjKXt0aGlzLmYoXCJFcnJvciBpbnN0YW50aWF0aW5nIFdlYlNvY2tldC5cIik7dmFyIGQ9Yy5tZXNzYWdlfHxjLmRhdGE7ZCYmdGhpcy5mKGQpO3RoaXMuZWIoKTtyZXR1cm59dmFyIGU9dGhpczt0aGlzLnRhLm9ub3Blbj1mdW5jdGlvbigpe2UuZihcIldlYnNvY2tldCBjb25uZWN0ZWQuXCIpO2UueGM9ITB9O3RoaXMudGEub25jbG9zZT1mdW5jdGlvbigpe2UuZihcIldlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkaXNjb25uZWN0ZWQuXCIpO2UudGE9bnVsbDtlLmViKCl9O3RoaXMudGEub25tZXNzYWdlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPT1lLnRhKWlmKGE9YS5kYXRhLGUuaWIrPVxuYS5sZW5ndGgsU2QoZS5SYSxcImJ5dGVzX3JlY2VpdmVkXCIsYS5sZW5ndGgpLGJlKGUpLG51bGwhPT1lLmZyYW1lcyljZShlLGEpO2Vsc2V7YTp7eShudWxsPT09ZS5mcmFtZXMsXCJXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXJcIik7aWYoNj49YS5sZW5ndGgpe3ZhciBiPU51bWJlcihhKTtpZighaXNOYU4oYikpe2UuVGU9YjtlLmZyYW1lcz1bXTthPW51bGw7YnJlYWsgYX19ZS5UZT0xO2UuZnJhbWVzPVtdfW51bGwhPT1hJiZjZShlLGEpfX07dGhpcy50YS5vbmVycm9yPWZ1bmN0aW9uKGEpe2UuZihcIldlYlNvY2tldCBlcnJvci4gIENsb3NpbmcgY29ubmVjdGlvbi5cIik7KGE9YS5tZXNzYWdlfHxhLmRhdGEpJiZlLmYoYSk7ZS5lYigpfX07JGQucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7fTtcbiRkLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7dmFyIGE9ITE7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQpe3ZhciBiPW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQgKFswLTldezAsfVxcLlswLTldezAsfSkvKTtiJiYxPGIubGVuZ3RoJiY0LjQ+cGFyc2VGbG9hdChiWzFdKSYmKGE9ITApfXJldHVybiFhJiZudWxsIT09WmQmJiFhZX07JGQucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeT0yOyRkLmhlYWx0aHlUaW1lb3V0PTNFNDtoPSRkLnByb3RvdHlwZTtoLnNkPWZ1bmN0aW9uKCl7emEucmVtb3ZlKFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIil9O2Z1bmN0aW9uIGNlKGEsYil7YS5mcmFtZXMucHVzaChiKTtpZihhLmZyYW1lcy5sZW5ndGg9PWEuVGUpe3ZhciBjPWEuZnJhbWVzLmpvaW4oXCJcIik7YS5mcmFtZXM9bnVsbDtjPXRhKGMpO2EuaGcoYyl9fVxuaC5zZW5kPWZ1bmN0aW9uKGEpe2JlKHRoaXMpO2E9cihhKTt0aGlzLmpiKz1hLmxlbmd0aDtTZCh0aGlzLlJhLFwiYnl0ZXNfc2VudFwiLGEubGVuZ3RoKTthPXliKGEsMTYzODQpOzE8YS5sZW5ndGgmJnRoaXMudGEuc2VuZChTdHJpbmcoYS5sZW5ndGgpKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLnRhLnNlbmQoYVtiXSl9O2guVWM9ZnVuY3Rpb24oKXt0aGlzLnFiPSEwO3RoaXMuQ2MmJihjbGVhckludGVydmFsKHRoaXMuQ2MpLHRoaXMuQ2M9bnVsbCk7dGhpcy50YSYmKHRoaXMudGEuY2xvc2UoKSx0aGlzLnRhPW51bGwpfTtoLmViPWZ1bmN0aW9uKCl7dGhpcy5xYnx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBjbG9zaW5nIGl0c2VsZlwiKSx0aGlzLlVjKCksdGhpcy5mYiYmKHRoaXMuZmIodGhpcy54YyksdGhpcy5mYj1udWxsKSl9O2guY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnFifHwodGhpcy5mKFwiV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZFwiKSx0aGlzLlVjKCkpfTtcbmZ1bmN0aW9uIGJlKGEpe2NsZWFySW50ZXJ2YWwoYS5DYyk7YS5DYz1zZXRJbnRlcnZhbChmdW5jdGlvbigpe2EudGEmJmEudGEuc2VuZChcIjBcIik7YmUoYSl9LE1hdGguZmxvb3IoNDVFMykpfTtmdW5jdGlvbiBkZShhKXt0aGlzLiRiPWE7dGhpcy5DZD1bXTt0aGlzLkpiPTA7dGhpcy5nZT0tMTt0aGlzLndiPW51bGx9ZnVuY3Rpb24gZWUoYSxiLGMpe2EuZ2U9YjthLndiPWM7YS5nZTxhLkpiJiYoYS53YigpLGEud2I9bnVsbCl9ZnVuY3Rpb24gZmUoYSxiLGMpe2ZvcihhLkNkW2JdPWM7YS5DZFthLkpiXTspe3ZhciBkPWEuQ2RbYS5KYl07ZGVsZXRlIGEuQ2RbYS5KYl07Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDsrK2UpaWYoZFtlXSl7dmFyIGY9YTtDYihmdW5jdGlvbigpe2YuJGIoZFtlXSl9KX1pZihhLkpiPT09YS5nZSl7YS53YiYmKGNsZWFyVGltZW91dChhLndiKSxhLndiKCksYS53Yj1udWxsKTticmVha31hLkpiKyt9fTtmdW5jdGlvbiBnZSgpe3RoaXMuc2V0PXt9fWg9Z2UucHJvdG90eXBlO2guYWRkPWZ1bmN0aW9uKGEsYil7dGhpcy5zZXRbYV09bnVsbCE9PWI/YjohMH07aC5jb250YWlucz1mdW5jdGlvbihhKXtyZXR1cm4gcyh0aGlzLnNldCxhKX07aC5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuY29udGFpbnMoYSk/dGhpcy5zZXRbYV06dm9pZCAwfTtoLnJlbW92ZT1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5zZXRbYV19O2guY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLnNldD17fX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIE5kKHRoaXMuc2V0KX07aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiBKYih0aGlzLnNldCl9O2Z1bmN0aW9uIGhlKGEsYil7QShhLnNldCxmdW5jdGlvbihhLGQpe2IoZCxhKX0pfTtmdW5jdGlvbiBpZShhLGIsYyl7dGhpcy5pZT1hO3RoaXMuZj1vYihhKTt0aGlzLmliPXRoaXMuamI9MDt0aGlzLlJhPVhkKGIpO3RoaXMuTWQ9Yzt0aGlzLnhjPSExO3RoaXMuWmM9ZnVuY3Rpb24oYSl7Yi5ob3N0IT09Yi5NYSYmKGEubnM9Yi50Yik7dmFyIGM9W10sZjtmb3IoZiBpbiBhKWEuaGFzT3duUHJvcGVydHkoZikmJmMucHVzaChmK1wiPVwiK2FbZl0pO3JldHVybihiLkFiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrYi5NYStcIi8ubHA/XCIrYy5qb2luKFwiJlwiKX19dmFyIGplLGtlO1xuaWUucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiKXt0aGlzLlplPTA7dGhpcy5nYT1iO3RoaXMubWY9bmV3IGRlKGEpO3RoaXMucWI9ITE7dmFyIGM9dGhpczt0aGlzLmxiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtjLmYoXCJUaW1lZCBvdXQgdHJ5aW5nIHRvIGNvbm5lY3QuXCIpO2MuZWIoKTtjLmxiPW51bGx9LE1hdGguZmxvb3IoM0U0KSk7dGIoZnVuY3Rpb24oKXtpZighYy5xYil7Yy5QYT1uZXcgbGUoZnVuY3Rpb24oYSxiLGQsayxsKXttZShjLGFyZ3VtZW50cyk7aWYoYy5QYSlpZihjLmxiJiYoY2xlYXJUaW1lb3V0KGMubGIpLGMubGI9bnVsbCksYy54Yz0hMCxcInN0YXJ0XCI9PWEpYy5pZD1iLGMucmY9ZDtlbHNlIGlmKFwiY2xvc2VcIj09PWEpYj8oYy5QYS5LZD0hMSxlZShjLm1mLGIsZnVuY3Rpb24oKXtjLmViKCl9KSk6Yy5lYigpO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbnJlY29nbml6ZWQgY29tbWFuZCByZWNlaXZlZDogXCIrYSk7fSxmdW5jdGlvbihhLGIpe21lKGMsYXJndW1lbnRzKTtcbmZlKGMubWYsYSxiKX0sZnVuY3Rpb24oKXtjLmViKCl9LGMuWmMpO3ZhciBhPXtzdGFydDpcInRcIn07YS5zZXI9TWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7Yy5QYS5XZCYmKGEuY2I9Yy5QYS5XZCk7YS52PVwiNVwiO2MuTWQmJihhLnM9Yy5NZCk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsb2NhdGlvbiYmbG9jYXRpb24uaHJlZiYmLTEhPT1sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJmaXJlYmFzZWlvLmNvbVwiKSYmKGEucj1cImZcIik7YT1jLlpjKGEpO2MuZihcIkNvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byBcIithKTtuZShjLlBhLGEsZnVuY3Rpb24oKXt9KX19KX07XG5pZS5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLlBhLGI9dGhpcy5yZjthLmNnPXRoaXMuaWQ7YS5kZz1iO2ZvcihhLmFlPSEwO29lKGEpOyk7YT10aGlzLmlkO2I9dGhpcy5yZjt0aGlzLlliPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7dmFyIGM9e2RmcmFtZTpcInRcIn07Yy5pZD1hO2MucHc9Yjt0aGlzLlliLnNyYz10aGlzLlpjKGMpO3RoaXMuWWIuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuWWIpfTtpZS5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVybiFrZSYmIShcIm9iamVjdFwiPT09dHlwZW9mIHdpbmRvdyYmd2luZG93LmNocm9tZSYmd2luZG93LmNocm9tZS5leHRlbnNpb24mJiEvXmNocm9tZS8udGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZikpJiYhKFwib2JqZWN0XCI9PT10eXBlb2YgV2luZG93cyYmXCJvYmplY3RcIj09PXR5cGVvZiBXaW5kb3dzLkVnKSYmKGplfHwhMCl9O2g9aWUucHJvdG90eXBlO1xuaC5zZD1mdW5jdGlvbigpe307aC5VYz1mdW5jdGlvbigpe3RoaXMucWI9ITA7dGhpcy5QYSYmKHRoaXMuUGEuY2xvc2UoKSx0aGlzLlBhPW51bGwpO3RoaXMuWWImJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuWWIpLHRoaXMuWWI9bnVsbCk7dGhpcy5sYiYmKGNsZWFyVGltZW91dCh0aGlzLmxiKSx0aGlzLmxiPW51bGwpfTtoLmViPWZ1bmN0aW9uKCl7dGhpcy5xYnx8KHRoaXMuZihcIkxvbmdwb2xsIGlzIGNsb3NpbmcgaXRzZWxmXCIpLHRoaXMuVWMoKSx0aGlzLmdhJiYodGhpcy5nYSh0aGlzLnhjKSx0aGlzLmdhPW51bGwpKX07aC5jbG9zZT1mdW5jdGlvbigpe3RoaXMucWJ8fCh0aGlzLmYoXCJMb25ncG9sbCBpcyBiZWluZyBjbG9zZWQuXCIpLHRoaXMuVWMoKSl9O1xuaC5zZW5kPWZ1bmN0aW9uKGEpe2E9cihhKTt0aGlzLmpiKz1hLmxlbmd0aDtTZCh0aGlzLlJhLFwiYnl0ZXNfc2VudFwiLGEubGVuZ3RoKTthPWpiKGEpO2E9Y2IoYSwhMCk7YT15YihhLDE4NDApO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz10aGlzLlBhO2MuUWMucHVzaCh7dGc6dGhpcy5aZSxCZzphLmxlbmd0aCxhZjphW2JdfSk7Yy5hZSYmb2UoYyk7dGhpcy5aZSsrfX07ZnVuY3Rpb24gbWUoYSxiKXt2YXIgYz1yKGIpLmxlbmd0aDthLmliKz1jO1NkKGEuUmEsXCJieXRlc19yZWNlaXZlZFwiLGMpfVxuZnVuY3Rpb24gbGUoYSxiLGMsZCl7dGhpcy5aYz1kO3RoaXMuZmI9Yzt0aGlzLkllPW5ldyBnZTt0aGlzLlFjPVtdO3RoaXMua2U9TWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7dGhpcy5LZD0hMDt0aGlzLldkPWViKCk7d2luZG93W1wicExQQ29tbWFuZFwiK3RoaXMuV2RdPWE7d2luZG93W1wicFJUTFBDQlwiK3RoaXMuV2RdPWI7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtpZihkb2N1bWVudC5ib2R5KXtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO3RyeXthLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnR8fGhiKFwiTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWRcIil9Y2F0Y2goZSl7YS5zcmM9XCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIrZG9jdW1lbnQuZG9tYWluK1wiJztkb2N1bWVudC5jbG9zZSgpO30pKCkpXCJ9fWVsc2UgdGhyb3dcIkRvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS5cIjtcbmEuY29udGVudERvY3VtZW50P2EuYWI9YS5jb250ZW50RG9jdW1lbnQ6YS5jb250ZW50V2luZG93P2EuYWI9YS5jb250ZW50V2luZG93LmRvY3VtZW50OmEuZG9jdW1lbnQmJihhLmFiPWEuZG9jdW1lbnQpO3RoaXMuQmE9YTthPVwiXCI7dGhpcy5CYS5zcmMmJlwiamF2YXNjcmlwdDpcIj09PXRoaXMuQmEuc3JjLnN1YnN0cigwLDExKSYmKGE9JzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJytkb2N1bWVudC5kb21haW4rJ1wiO1xceDNjL3NjcmlwdD4nKTthPVwiPGh0bWw+PGJvZHk+XCIrYStcIjwvYm9keT48L2h0bWw+XCI7dHJ5e3RoaXMuQmEuYWIub3BlbigpLHRoaXMuQmEuYWIud3JpdGUoYSksdGhpcy5CYS5hYi5jbG9zZSgpfWNhdGNoKGYpe2hiKFwiZnJhbWUgd3JpdGluZyBleGNlcHRpb25cIiksZi5zdGFjayYmaGIoZi5zdGFjayksaGIoZil9fVxubGUucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5hZT0hMTtpZih0aGlzLkJhKXt0aGlzLkJhLmFiLmJvZHkuaW5uZXJIVE1MPVwiXCI7dmFyIGE9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bnVsbCE9PWEuQmEmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEuQmEpLGEuQmE9bnVsbCl9LE1hdGguZmxvb3IoMCkpfXZhciBiPXRoaXMuZmI7YiYmKHRoaXMuZmI9bnVsbCxiKCkpfTtcbmZ1bmN0aW9uIG9lKGEpe2lmKGEuYWUmJmEuS2QmJmEuSWUuY291bnQoKTwoMDxhLlFjLmxlbmd0aD8yOjEpKXthLmtlKys7dmFyIGI9e307Yi5pZD1hLmNnO2IucHc9YS5kZztiLnNlcj1hLmtlO2Zvcih2YXIgYj1hLlpjKGIpLGM9XCJcIixkPTA7MDxhLlFjLmxlbmd0aDspaWYoMTg3MD49YS5RY1swXS5hZi5sZW5ndGgrMzArYy5sZW5ndGgpe3ZhciBlPWEuUWMuc2hpZnQoKSxjPWMrXCImc2VnXCIrZCtcIj1cIitlLnRnK1wiJnRzXCIrZCtcIj1cIitlLkJnK1wiJmRcIitkK1wiPVwiK2UuYWY7ZCsrfWVsc2UgYnJlYWs7cGUoYSxiK2MsYS5rZSk7cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gcGUoYSxiLGMpe2Z1bmN0aW9uIGQoKXthLkllLnJlbW92ZShjKTtvZShhKX1hLkllLmFkZChjKTt2YXIgZT1zZXRUaW1lb3V0KGQsTWF0aC5mbG9vcigyNUUzKSk7bmUoYSxiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUpO2QoKX0pfVxuZnVuY3Rpb24gbmUoYSxiLGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0cnl7aWYoYS5LZCl7dmFyIGQ9YS5CYS5hYi5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2QudHlwZT1cInRleHQvamF2YXNjcmlwdFwiO2QuYXN5bmM9ITA7ZC5zcmM9YjtkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe3ZhciBhPWQucmVhZHlTdGF0ZTthJiZcImxvYWRlZFwiIT09YSYmXCJjb21wbGV0ZVwiIT09YXx8KGQub25sb2FkPWQub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsZC5wYXJlbnROb2RlJiZkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksYygpKX07ZC5vbmVycm9yPWZ1bmN0aW9uKCl7aGIoXCJMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiBcIitiKTthLktkPSExO2EuY2xvc2UoKX07YS5CYS5hYi5ib2R5LmFwcGVuZENoaWxkKGQpfX1jYXRjaChlKXt9fSxNYXRoLmZsb29yKDEpKX07ZnVuY3Rpb24gcWUoYSl7cmUodGhpcyxhKX12YXIgc2U9W2llLCRkXTtmdW5jdGlvbiByZShhLGIpe3ZhciBjPSRkJiYkZC5pc0F2YWlsYWJsZSgpLGQ9YyYmISh6YS5sZnx8ITA9PT16YS5nZXQoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiKSk7Yi5EZyYmKGN8fHooXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpLGQ9ITApO2lmKGQpYS5YYz1bJGRdO2Vsc2V7dmFyIGU9YS5YYz1bXTt6YihzZSxmdW5jdGlvbihhLGIpe2ImJmIuaXNBdmFpbGFibGUoKSYmZS5wdXNoKGIpfSl9fWZ1bmN0aW9uIHRlKGEpe2lmKDA8YS5YYy5sZW5ndGgpcmV0dXJuIGEuWGNbMF07dGhyb3cgRXJyb3IoXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTt9O2Z1bmN0aW9uIHVlKGEsYixjLGQsZSxmKXt0aGlzLmlkPWE7dGhpcy5mPW9iKFwiYzpcIit0aGlzLmlkK1wiOlwiKTt0aGlzLiRiPWM7dGhpcy5LYz1kO3RoaXMuZ2E9ZTt0aGlzLkdlPWY7dGhpcy5PPWI7dGhpcy5CZD1bXTt0aGlzLlhlPTA7dGhpcy5BZj1uZXcgcWUoYik7dGhpcy5RYT0wO3RoaXMuZihcIkNvbm5lY3Rpb24gY3JlYXRlZFwiKTt2ZSh0aGlzKX1cbmZ1bmN0aW9uIHZlKGEpe3ZhciBiPXRlKGEuQWYpO2EuSj1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLlhlKyssYS5PKTthLktlPWIucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeXx8MDt2YXIgYz13ZShhLGEuSiksZD14ZShhLGEuSik7YS5ZYz1hLko7YS5UYz1hLko7YS5CPW51bGw7YS5yYj0hMTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5KJiZhLkoub3BlbihjLGQpfSxNYXRoLmZsb29yKDApKTtiPWIuaGVhbHRoeVRpbWVvdXR8fDA7MDxiJiYoYS5uZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5uZD1udWxsO2EucmJ8fChhLkomJjEwMjQwMDxhLkouaWI/KGEuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgcmVjZWl2ZWQgXCIrYS5KLmliK1wiIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuXCIpLGEucmI9ITAsYS5KLnNkKCkpOmEuSiYmMTAyNDA8YS5KLmpiP2EuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCBcIitcbmEuSi5qYitcIiBieXRlcy4gIExlYXZpbmcgY29ubmVjdGlvbiBhbGl2ZS5cIik6KGEuZihcIkNsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC5cIiksYS5jbG9zZSgpKSl9LE1hdGguZmxvb3IoYikpKX1mdW5jdGlvbiB4ZShhLGIpe3JldHVybiBmdW5jdGlvbihjKXtiPT09YS5KPyhhLko9bnVsbCxjfHwwIT09YS5RYT8xPT09YS5RYSYmYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBsb3N0LlwiKTooYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuXCIpLFwicy1cIj09PWEuTy5NYS5zdWJzdHIoMCwyKSYmKHphLnJlbW92ZShcImhvc3Q6XCIrYS5PLmhvc3QpLGEuTy5NYT1hLk8uaG9zdCkpLGEuY2xvc2UoKSk6Yj09PWEuQj8oYS5mKFwiU2Vjb25kYXJ5IGNvbm5lY3Rpb24gbG9zdC5cIiksYz1hLkIsYS5CPW51bGwsYS5ZYyE9PWMmJmEuVGMhPT1jfHxhLmNsb3NlKCkpOmEuZihcImNsb3NpbmcgYW4gb2xkIGNvbm5lY3Rpb25cIil9fVxuZnVuY3Rpb24gd2UoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoMiE9YS5RYSlpZihiPT09YS5UYyl7dmFyIGQ9d2IoXCJ0XCIsYyk7Yz13YihcImRcIixjKTtpZihcImNcIj09ZCl7aWYoZD13YihcInRcIixjKSxcImRcImluIGMpaWYoYz1jLmQsXCJoXCI9PT1kKXt2YXIgZD1jLnRzLGU9Yy52LGY9Yy5oO2EuTWQ9Yy5zO0JhKGEuTyxmKTswPT1hLlFhJiYoYS5KLnN0YXJ0KCkseWUoYSxhLkosZCksXCI1XCIhPT1lJiZ6KFwiUHJvdG9jb2wgdmVyc2lvbiBtaXNtYXRjaCBkZXRlY3RlZFwiKSxjPWEuQWYsKGM9MTxjLlhjLmxlbmd0aD9jLlhjWzFdOm51bGwpJiZ6ZShhLGMpKX1lbHNlIGlmKFwiblwiPT09ZCl7YS5mKFwicmVjdmQgZW5kIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5XCIpO2EuVGM9YS5CO2ZvcihjPTA7YzxhLkJkLmxlbmd0aDsrK2MpYS54ZChhLkJkW2NdKTthLkJkPVtdO0FlKGEpfWVsc2VcInNcIj09PWQ/KGEuZihcIkNvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLlwiKSxcbmEuR2UmJihhLkdlKGMpLGEuR2U9bnVsbCksYS5nYT1udWxsLGEuY2xvc2UoKSk6XCJyXCI9PT1kPyhhLmYoXCJSZXNldCBwYWNrZXQgcmVjZWl2ZWQuICBOZXcgaG9zdDogXCIrYyksQmEoYS5PLGMpLDE9PT1hLlFhP2EuY2xvc2UoKTooQmUoYSksdmUoYSkpKTpcImVcIj09PWQ/cGIoXCJTZXJ2ZXIgRXJyb3I6IFwiK2MpOlwib1wiPT09ZD8oYS5mKFwiZ290IHBvbmcgb24gcHJpbWFyeS5cIiksQ2UoYSksRGUoYSkpOnBiKFwiVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiBcIitkKX1lbHNlXCJkXCI9PWQmJmEueGQoYyl9ZWxzZSBpZihiPT09YS5CKWlmKGQ9d2IoXCJ0XCIsYyksYz13YihcImRcIixjKSxcImNcIj09ZClcInRcImluIGMmJihjPWMudCxcImFcIj09PWM/RWUoYSk6XCJyXCI9PT1jPyhhLmYoXCJHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXRcIiksYS5CLmNsb3NlKCksYS5ZYyE9PWEuQiYmYS5UYyE9PWEuQnx8YS5jbG9zZSgpKTpcIm9cIj09PWMmJihhLmYoXCJnb3QgcG9uZyBvbiBzZWNvbmRhcnkuXCIpLFxuYS55Zi0tLEVlKGEpKSk7ZWxzZSBpZihcImRcIj09ZClhLkJkLnB1c2goYyk7ZWxzZSB0aHJvdyBFcnJvcihcIlVua25vd24gcHJvdG9jb2wgbGF5ZXI6IFwiK2QpO2Vsc2UgYS5mKFwibWVzc2FnZSBvbiBvbGQgY29ubmVjdGlvblwiKX19dWUucHJvdG90eXBlLkNhPWZ1bmN0aW9uKGEpe0ZlKHRoaXMse3Q6XCJkXCIsZDphfSl9O2Z1bmN0aW9uIEFlKGEpe2EuWWM9PT1hLkImJmEuVGM9PT1hLkImJihhLmYoXCJjbGVhbmluZyB1cCBhbmQgcHJvbW90aW5nIGEgY29ubmVjdGlvbjogXCIrYS5CLmllKSxhLko9YS5CLGEuQj1udWxsKX1cbmZ1bmN0aW9uIEVlKGEpezA+PWEueWY/KGEuZihcIlNlY29uZGFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXCIpLGEucmI9ITAsYS5CLnNkKCksYS5CLnN0YXJ0KCksYS5mKFwic2VuZGluZyBjbGllbnQgYWNrIG9uIHNlY29uZGFyeVwiKSxhLkIuc2VuZCh7dDpcImNcIixkOnt0OlwiYVwiLGQ6e319fSksYS5mKFwiRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5XCIpLGEuSi5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJuXCIsZDp7fX19KSxhLlljPWEuQixBZShhKSk6KGEuZihcInNlbmRpbmcgcGluZyBvbiBzZWNvbmRhcnkuXCIpLGEuQi5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJwXCIsZDp7fX19KSl9dWUucHJvdG90eXBlLnhkPWZ1bmN0aW9uKGEpe0NlKHRoaXMpO3RoaXMuJGIoYSl9O2Z1bmN0aW9uIENlKGEpe2EucmJ8fChhLktlLS0sMD49YS5LZSYmKGEuZihcIlByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLnJiPSEwLGEuSi5zZCgpKSl9XG5mdW5jdGlvbiB6ZShhLGIpe2EuQj1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLlhlKyssYS5PLGEuTWQpO2EueWY9Yi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5fHwwO2EuQi5vcGVuKHdlKGEsYS5CKSx4ZShhLGEuQikpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLkImJihhLmYoXCJUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuXCIpLGEuQi5jbG9zZSgpKX0sTWF0aC5mbG9vcig2RTQpKX1mdW5jdGlvbiB5ZShhLGIsYyl7YS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC5cIik7YS5KPWI7YS5RYT0xO2EuS2MmJihhLktjKGMpLGEuS2M9bnVsbCk7MD09PWEuS2U/KGEuZihcIlByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLnJiPSEwKTpzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7RGUoYSl9LE1hdGguZmxvb3IoNUUzKSl9XG5mdW5jdGlvbiBEZShhKXthLnJifHwxIT09YS5RYXx8KGEuZihcInNlbmRpbmcgcGluZyBvbiBwcmltYXJ5LlwiKSxGZShhLHt0OlwiY1wiLGQ6e3Q6XCJwXCIsZDp7fX19KSl9ZnVuY3Rpb24gRmUoYSxiKXtpZigxIT09YS5RYSl0aHJvd1wiQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkXCI7YS5ZYy5zZW5kKGIpfXVlLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpezIhPT10aGlzLlFhJiYodGhpcy5mKFwiQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLlwiKSx0aGlzLlFhPTIsQmUodGhpcyksdGhpcy5nYSYmKHRoaXMuZ2EoKSx0aGlzLmdhPW51bGwpKX07ZnVuY3Rpb24gQmUoYSl7YS5mKFwiU2h1dHRpbmcgZG93biBhbGwgY29ubmVjdGlvbnNcIik7YS5KJiYoYS5KLmNsb3NlKCksYS5KPW51bGwpO2EuQiYmKGEuQi5jbG9zZSgpLGEuQj1udWxsKTthLm5kJiYoY2xlYXJUaW1lb3V0KGEubmQpLGEubmQ9bnVsbCl9O2Z1bmN0aW9uIEdlKGEpe3ZhciBiPXt9LGM9e30sZD17fSxlPVwiXCI7dHJ5e3ZhciBmPWEuc3BsaXQoXCIuXCIpLGI9dGEoZ2IoZlswXSl8fFwiXCIpLGM9dGEoZ2IoZlsxXSl8fFwiXCIpLGU9ZlsyXSxkPWMuZHx8e307ZGVsZXRlIGMuZH1jYXRjaChnKXt9cmV0dXJue0dnOmIsZmU6YyxkYXRhOmQseGc6ZX19ZnVuY3Rpb24gSGUoYSl7YT1HZShhKS5mZTtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJmEuaGFzT3duUHJvcGVydHkoXCJpYXRcIik/dChhLFwiaWF0XCIpOm51bGx9ZnVuY3Rpb24gSWUoYSl7YT1HZShhKTt2YXIgYj1hLmZlO3JldHVybiEhYS54ZyYmISFiJiZcIm9iamVjdFwiPT09dHlwZW9mIGImJmIuaGFzT3duUHJvcGVydHkoXCJpYXRcIil9O2Z1bmN0aW9uIEplKGEsYixjLGQpe3RoaXMuaWQ9S2UrKzt0aGlzLmY9b2IoXCJwOlwiK3RoaXMuaWQrXCI6XCIpO3RoaXMuQ2I9ITA7dGhpcy5BYT17fTt0aGlzLmxhPVtdO3RoaXMuTmM9MDt0aGlzLkpjPVtdO3RoaXMuamE9ITE7dGhpcy5XYT0xRTM7dGhpcy50ZD0zRTU7dGhpcy55ZD1iO3RoaXMud2Q9Yzt0aGlzLkhlPWQ7dGhpcy5PPWE7dGhpcy5PZT1udWxsO3RoaXMuU2M9e307dGhpcy5zZz0wO3RoaXMuRGM9dGhpcy53ZT1udWxsO0xlKHRoaXMsMCk7SGQuTmIoKS52YihcInZpc2libGVcIix0aGlzLmtnLHRoaXMpOy0xPT09YS5ob3N0LmluZGV4T2YoXCJmYmxvY2FsXCIpJiZJZC5OYigpLnZiKFwib25saW5lXCIsdGhpcy5pZyx0aGlzKX12YXIgS2U9MCxNZT0wO2g9SmUucHJvdG90eXBlO1xuaC5DYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Kyt0aGlzLnNnO2E9e3I6ZCxhOmEsYjpifTt0aGlzLmYocihhKSk7eSh0aGlzLmphLFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO3RoaXMuT2EuQ2EoYSk7YyYmKHRoaXMuU2NbZF09Yyl9O2Z1bmN0aW9uIE5lKGEsYixjLGQsZSl7dmFyIGY9Yi5GYSgpLGc9Yi5wYXRoLnRvU3RyaW5nKCk7YS5mKFwiTGlzdGVuIGNhbGxlZCBmb3IgXCIrZytcIiBcIitmKTthLkFhW2ddPWEuQWFbZ118fHt9O3koIWEuQWFbZ11bZl0sXCJsaXN0ZW4oKSBjYWxsZWQgdHdpY2UgZm9yIHNhbWUgcGF0aC9xdWVyeUlkLlwiKTtiPXtIOmUsbWQ6YyxwZzpJYyhiLm4pLHRhZzpkfTthLkFhW2ddW2ZdPWI7YS5qYSYmT2UoYSxnLGYsYil9XG5mdW5jdGlvbiBPZShhLGIsYyxkKXthLmYoXCJMaXN0ZW4gb24gXCIrYitcIiBmb3IgXCIrYyk7dmFyIGU9e3A6Yn07ZC50YWcmJihlLnE9ZC5wZyxlLnQ9ZC50YWcpO2UuaD1kLm1kKCk7YS5DYShcInFcIixlLGZ1bmN0aW9uKGUpe2lmKChhLkFhW2JdJiZhLkFhW2JdW2NdKT09PWQpe2EuZihcImxpc3RlbiByZXNwb25zZVwiLGUpO3ZhciBnPWUucztcIm9rXCIhPT1nJiZQZShhLGIsYyk7ZT1lLmQ7ZC5IJiZkLkgoZyxlKX19KX1oLlE9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuSWI9e1JmOmEsY2Y6ITEscWM6YixhZDpjfTt0aGlzLmYoXCJBdXRoZW50aWNhdGluZyB1c2luZyBjcmVkZW50aWFsOiBcIithKTtRZSh0aGlzKTsoYj00MD09YS5sZW5ndGgpfHwoYT1HZShhKS5mZSxiPVwib2JqZWN0XCI9PT10eXBlb2YgYSYmITA9PT10KGEsXCJhZG1pblwiKSk7YiYmKHRoaXMuZihcIkFkbWluIGF1dGggY3JlZGVudGlhbCBkZXRlY3RlZC4gIFJlZHVjaW5nIG1heCByZWNvbm5lY3QgdGltZS5cIiksdGhpcy50ZD0zRTQpfTtcbmguVWU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuSWI7dGhpcy5qYSYmdGhpcy5DYShcInVuYXV0aFwiLHt9LGZ1bmN0aW9uKGIpe2EoYi5zLGIuZCl9KX07ZnVuY3Rpb24gUWUoYSl7dmFyIGI9YS5JYjthLmphJiZiJiZhLkNhKFwiYXV0aFwiLHtjcmVkOmIuUmZ9LGZ1bmN0aW9uKGMpe3ZhciBkPWMucztjPWMuZHx8XCJlcnJvclwiO1wib2tcIiE9PWQmJmEuSWI9PT1iJiZkZWxldGUgYS5JYjtiLmNmP1wib2tcIiE9PWQmJmIuYWQmJmIuYWQoZCxjKTooYi5jZj0hMCxiLnFjJiZiLnFjKGQsYykpfSl9ZnVuY3Rpb24gUmUoYSxiLGMsZCl7YS5qYT9TZShhLFwib1wiLGIsYyxkKTphLkpjLnB1c2goe1BjOmIsYWN0aW9uOlwib1wiLGRhdGE6YyxIOmR9KX1mdW5jdGlvbiBUZShhLGIsYyxkKXthLmphP1NlKGEsXCJvbVwiLGIsYyxkKTphLkpjLnB1c2goe1BjOmIsYWN0aW9uOlwib21cIixkYXRhOmMsSDpkfSl9XG5oLkZlPWZ1bmN0aW9uKGEsYil7dGhpcy5qYT9TZSh0aGlzLFwib2NcIixhLG51bGwsYik6dGhpcy5KYy5wdXNoKHtQYzphLGFjdGlvbjpcIm9jXCIsZGF0YTpudWxsLEg6Yn0pfTtmdW5jdGlvbiBTZShhLGIsYyxkLGUpe2M9e3A6YyxkOmR9O2EuZihcIm9uRGlzY29ubmVjdCBcIitiLGMpO2EuQ2EoYixjLGZ1bmN0aW9uKGEpe2UmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGEucyxhLmQpfSxNYXRoLmZsb29yKDApKX0pfWgucHV0PWZ1bmN0aW9uKGEsYixjLGQpe1VlKHRoaXMsXCJwXCIsYSxiLGMsZCl9O2Z1bmN0aW9uIFZlKGEsYixjLGQpe1VlKGEsXCJtXCIsYixjLGQsdm9pZCAwKX1mdW5jdGlvbiBVZShhLGIsYyxkLGUsZil7ZD17cDpjLGQ6ZH07bShmKSYmKGQuaD1mKTthLmxhLnB1c2goe2FjdGlvbjpiLHVmOmQsSDplfSk7YS5OYysrO2I9YS5sYS5sZW5ndGgtMTthLmphP1dlKGEsYik6YS5mKFwiQnVmZmVyaW5nIHB1dDogXCIrYyl9XG5mdW5jdGlvbiBXZShhLGIpe3ZhciBjPWEubGFbYl0uYWN0aW9uLGQ9YS5sYVtiXS51ZixlPWEubGFbYl0uSDthLmxhW2JdLnFnPWEuamE7YS5DYShjLGQsZnVuY3Rpb24oZCl7YS5mKGMrXCIgcmVzcG9uc2VcIixkKTtkZWxldGUgYS5sYVtiXTthLk5jLS07MD09PWEuTmMmJihhLmxhPVtdKTtlJiZlKGQucyxkLmQpfSl9XG5oLnhkPWZ1bmN0aW9uKGEpe2lmKFwiclwiaW4gYSl7dGhpcy5mKFwiZnJvbSBzZXJ2ZXI6IFwiK3IoYSkpO3ZhciBiPWEucixjPXRoaXMuU2NbYl07YyYmKGRlbGV0ZSB0aGlzLlNjW2JdLGMoYS5iKSl9ZWxzZXtpZihcImVycm9yXCJpbiBhKXRocm93XCJBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogXCIrYS5lcnJvcjtcImFcImluIGEmJihiPWEuYSxjPWEuYix0aGlzLmYoXCJoYW5kbGVTZXJ2ZXJNZXNzYWdlXCIsYixjKSxcImRcIj09PWI/dGhpcy55ZChjLnAsYy5kLCExLGMudCk6XCJtXCI9PT1iP3RoaXMueWQoYy5wLGMuZCwhMCxjLnQpOlwiY1wiPT09Yj9YZSh0aGlzLGMucCxjLnEpOlwiYWNcIj09PWI/KGE9Yy5zLGI9Yy5kLGM9dGhpcy5JYixkZWxldGUgdGhpcy5JYixjJiZjLmFkJiZjLmFkKGEsYikpOlwic2RcIj09PWI/dGhpcy5PZT90aGlzLk9lKGMpOlwibXNnXCJpbiBjJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUubG9nKFwiRklSRUJBU0U6IFwiK2MubXNnLnJlcGxhY2UoXCJcXG5cIixcblwiXFxuRklSRUJBU0U6IFwiKSk6cGIoXCJVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIityKGIpK1wiXFxuQXJlIHlvdSB1c2luZyB0aGUgbGF0ZXN0IGNsaWVudD9cIikpfX07aC5LYz1mdW5jdGlvbihhKXt0aGlzLmYoXCJjb25uZWN0aW9uIHJlYWR5XCIpO3RoaXMuamE9ITA7dGhpcy5EYz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLkhlKHtzZXJ2ZXJUaW1lT2Zmc2V0OmEtKG5ldyBEYXRlKS5nZXRUaW1lKCl9KTtZZSh0aGlzKTt0aGlzLndkKCEwKX07ZnVuY3Rpb24gTGUoYSxiKXt5KCFhLk9hLFwiU2NoZWR1bGluZyBhIGNvbm5lY3Qgd2hlbiB3ZSdyZSBhbHJlYWR5IGNvbm5lY3RlZC9pbmc/XCIpO2EuS2ImJmNsZWFyVGltZW91dChhLktiKTthLktiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthLktiPW51bGw7WmUoYSl9LE1hdGguZmxvb3IoYikpfVxuaC5rZz1mdW5jdGlvbihhKXthJiYhdGhpcy5tYyYmdGhpcy5XYT09PXRoaXMudGQmJih0aGlzLmYoXCJXaW5kb3cgYmVjYW1lIHZpc2libGUuICBSZWR1Y2luZyBkZWxheS5cIiksdGhpcy5XYT0xRTMsdGhpcy5PYXx8TGUodGhpcywwKSk7dGhpcy5tYz1hfTtoLmlnPWZ1bmN0aW9uKGEpe2E/KHRoaXMuZihcIkJyb3dzZXIgd2VudCBvbmxpbmUuICBSZWNvbm5lY3RpbmcuXCIpLHRoaXMuV2E9MUUzLHRoaXMuQ2I9ITAsdGhpcy5PYXx8TGUodGhpcywwKSk6KHRoaXMuZihcIkJyb3dzZXIgd2VudCBvZmZsaW5lLiAgS2lsbGluZyBjb25uZWN0aW9uOyBkb24ndCByZWNvbm5lY3QuXCIpLHRoaXMuQ2I9ITEsdGhpcy5PYSYmdGhpcy5PYS5jbG9zZSgpKX07XG5oLm9mPWZ1bmN0aW9uKCl7dGhpcy5mKFwiZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkXCIpO3RoaXMuamE9ITE7dGhpcy5PYT1udWxsO2Zvcih2YXIgYT0wO2E8dGhpcy5sYS5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLmxhW2FdO2ImJlwiaFwiaW4gYi51ZiYmYi5xZyYmKGIuSCYmYi5IKFwiZGlzY29ubmVjdFwiKSxkZWxldGUgdGhpcy5sYVthXSx0aGlzLk5jLS0pfTA9PT10aGlzLk5jJiYodGhpcy5sYT1bXSk7aWYodGhpcy5DYil0aGlzLm1jP3RoaXMuRGMmJigzRTQ8KG5ldyBEYXRlKS5nZXRUaW1lKCktdGhpcy5EYyYmKHRoaXMuV2E9MUUzKSx0aGlzLkRjPW51bGwpOih0aGlzLmYoXCJXaW5kb3cgaXNuJ3QgdmlzaWJsZS4gIERlbGF5aW5nIHJlY29ubmVjdC5cIiksdGhpcy5XYT10aGlzLnRkLHRoaXMud2U9KG5ldyBEYXRlKS5nZXRUaW1lKCkpLGE9TWF0aC5tYXgoMCx0aGlzLldhLSgobmV3IERhdGUpLmdldFRpbWUoKS10aGlzLndlKSksYSo9TWF0aC5yYW5kb20oKSx0aGlzLmYoXCJUcnlpbmcgdG8gcmVjb25uZWN0IGluIFwiK1xuYStcIm1zXCIpLExlKHRoaXMsYSksdGhpcy5XYT1NYXRoLm1pbih0aGlzLnRkLDEuMyp0aGlzLldhKTtlbHNlIGZvcih2YXIgYyBpbiB0aGlzLlNjKWRlbGV0ZSB0aGlzLlNjW2NdO3RoaXMud2QoITEpfTtmdW5jdGlvbiBaZShhKXtpZihhLkNiKXthLmYoXCJNYWtpbmcgYSBjb25uZWN0aW9uIGF0dGVtcHRcIik7YS53ZT0obmV3IERhdGUpLmdldFRpbWUoKTthLkRjPW51bGw7dmFyIGI9cShhLnhkLGEpLGM9cShhLktjLGEpLGQ9cShhLm9mLGEpLGU9YS5pZCtcIjpcIitNZSsrO2EuT2E9bmV3IHVlKGUsYS5PLGIsYyxkLGZ1bmN0aW9uKGIpe3ooYitcIiAoXCIrYS5PLnRvU3RyaW5nKCkrXCIpXCIpO2EuQ2I9ITF9KX19aC5wYj1mdW5jdGlvbigpe3RoaXMuQ2I9ITE7dGhpcy5PYT90aGlzLk9hLmNsb3NlKCk6KHRoaXMuS2ImJihjbGVhclRpbWVvdXQodGhpcy5LYiksdGhpcy5LYj1udWxsKSx0aGlzLmphJiZ0aGlzLm9mKCkpfTtcbmguaGM9ZnVuY3Rpb24oKXt0aGlzLkNiPSEwO3RoaXMuV2E9MUUzO3RoaXMuT2F8fExlKHRoaXMsMCl9O2Z1bmN0aW9uIFhlKGEsYixjKXtjPWM/SmEoYyxmdW5jdGlvbihhKXtyZXR1cm4geGIoYSl9KS5qb2luKFwiJFwiKTpcImRlZmF1bHRcIjsoYT1QZShhLGIsYykpJiZhLkgmJmEuSChcInBlcm1pc3Npb25fZGVuaWVkXCIpfWZ1bmN0aW9uIFBlKGEsYixjKXtiPShuZXcgUyhiKSkudG9TdHJpbmcoKTt2YXIgZD1hLkFhW2JdW2NdO2RlbGV0ZSBhLkFhW2JdW2NdOzA9PT1KYihhLkFhW2JdKSYmZGVsZXRlIGEuQWFbYl07cmV0dXJuIGR9ZnVuY3Rpb24gWWUoYSl7UWUoYSk7QShhLkFhLGZ1bmN0aW9uKGIsZCl7QShiLGZ1bmN0aW9uKGIsYyl7T2UoYSxkLGMsYil9KX0pO2Zvcih2YXIgYj0wO2I8YS5sYS5sZW5ndGg7YisrKWEubGFbYl0mJldlKGEsYik7Zm9yKDthLkpjLmxlbmd0aDspYj1hLkpjLnNoaWZ0KCksU2UoYSxiLmFjdGlvbixiLlBjLGIuZGF0YSxiLkgpfTtmdW5jdGlvbiAkZSgpe3RoaXMubT10aGlzLkQ9bnVsbH0kZS5wcm90b3R5cGUuZGM9ZnVuY3Rpb24oYSxiKXtpZihhLmUoKSl0aGlzLkQ9Yix0aGlzLm09bnVsbDtlbHNlIGlmKG51bGwhPT10aGlzLkQpdGhpcy5EPXRoaXMuRC5DKGEsYik7ZWxzZXtudWxsPT10aGlzLm0mJih0aGlzLm09bmV3IGdlKTt2YXIgYz1JKGEpO3RoaXMubS5jb250YWlucyhjKXx8dGhpcy5tLmFkZChjLG5ldyAkZSk7Yz10aGlzLm0uZ2V0KGMpO2E9VChhKTtjLmRjKGEsYil9fTtcbmZ1bmN0aW9uIGFmKGEsYil7aWYoYi5lKCkpcmV0dXJuIGEuRD1udWxsLGEubT1udWxsLCEwO2lmKG51bGwhPT1hLkQpe2lmKGEuRC5NKCkpcmV0dXJuITE7dmFyIGM9YS5EO2EuRD1udWxsO2MuVShMLGZ1bmN0aW9uKGIsYyl7YS5kYyhuZXcgUyhiKSxjKX0pO3JldHVybiBhZihhLGIpfXJldHVybiBudWxsIT09YS5tPyhjPUkoYiksYj1UKGIpLGEubS5jb250YWlucyhjKSYmYWYoYS5tLmdldChjKSxiKSYmYS5tLnJlbW92ZShjKSxhLm0uZSgpPyhhLm09bnVsbCwhMCk6ITEpOiEwfWZ1bmN0aW9uIGJmKGEsYixjKXtudWxsIT09YS5EP2MoYixhLkQpOmEuVShmdW5jdGlvbihhLGUpe3ZhciBmPW5ldyBTKGIudG9TdHJpbmcoKStcIi9cIithKTtiZihlLGYsYyl9KX0kZS5wcm90b3R5cGUuVT1mdW5jdGlvbihhKXtudWxsIT09dGhpcy5tJiZoZSh0aGlzLm0sZnVuY3Rpb24oYixjKXthKGIsYyl9KX07ZnVuY3Rpb24gY2YoKXt0aGlzLkpkPU19Y2YucHJvdG90eXBlLmo9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuSmQucmEoYSl9O2NmLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLkpkLnRvU3RyaW5nKCl9O2Z1bmN0aW9uIGRmKCl7dGhpcy5uYj1bXX1mdW5jdGlvbiBlZihhLGIpe2Zvcih2YXIgYz1udWxsLGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXSxmPWUuUWIoKTtudWxsPT09Y3x8Zi5lYShjLlFiKCkpfHwoYS5uYi5wdXNoKGMpLGM9bnVsbCk7bnVsbD09PWMmJihjPW5ldyBmZihmKSk7Yy5hZGQoZSl9YyYmYS5uYi5wdXNoKGMpfWZ1bmN0aW9uIFBjKGEsYixjKXtlZihhLGMpO2dmKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEuZWEoYil9KX1mdW5jdGlvbiBoZihhLGIsYyl7ZWYoYSxjKTtnZihhLGZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnRhaW5zKGIpfHxiLmNvbnRhaW5zKGEpfSl9XG5mdW5jdGlvbiBnZihhLGIpe2Zvcih2YXIgYz0hMCxkPTA7ZDxhLm5iLmxlbmd0aDtkKyspe3ZhciBlPWEubmJbZF07aWYoZSlpZihlPWUuUWIoKSxiKGUpKXtmb3IodmFyIGU9YS5uYltkXSxmPTA7ZjxlLmtkLmxlbmd0aDtmKyspe3ZhciBnPWUua2RbZl07aWYobnVsbCE9PWcpe2Uua2RbZl09bnVsbDt2YXIgaz1nLkxiKCk7bGImJmhiKFwiZXZlbnQ6IFwiK2cudG9TdHJpbmcoKSk7Q2Ioayl9fWEubmJbZF09bnVsbH1lbHNlIGM9ITF9YyYmKGEubmI9W10pfWZ1bmN0aW9uIGZmKGEpe3RoaXMuRWE9YTt0aGlzLmtkPVtdfWZmLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy5rZC5wdXNoKGEpfTtmZi5wcm90b3R5cGUuUWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5FYX07dmFyIGpmPVwiYXV0aC5maXJlYmFzZS5jb21cIjtmdW5jdGlvbiBrZihhLGIsYyl7dGhpcy5jZD1hfHx7fTt0aGlzLlVkPWJ8fHt9O3RoaXMuWGE9Y3x8e307dGhpcy5jZC5yZW1lbWJlcnx8KHRoaXMuY2QucmVtZW1iZXI9XCJkZWZhdWx0XCIpfXZhciBsZj1bXCJyZW1lbWJlclwiLFwicmVkaXJlY3RUb1wiXTtmdW5jdGlvbiBtZihhKXt2YXIgYj17fSxjPXt9O3VhKGF8fHt9LGZ1bmN0aW9uKGEsZSl7MDw9R2EobGYsYSk/YlthXT1lOmNbYV09ZX0pO3JldHVybiBuZXcga2YoYix7fSxjKX07dmFyIG5mPXtORVRXT1JLX0VSUk9SOlwiVW5hYmxlIHRvIGNvbnRhY3QgdGhlIEZpcmViYXNlIHNlcnZlci5cIixTRVJWRVJfRVJST1I6XCJBbiB1bmtub3duIHNlcnZlciBlcnJvciBvY2N1cnJlZC5cIixUUkFOU1BPUlRfVU5BVkFJTEFCTEU6XCJUaGVyZSBhcmUgbm8gbG9naW4gdHJhbnNwb3J0cyBhdmFpbGFibGUgZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kLlwiLFJFUVVFU1RfSU5URVJSVVBURUQ6XCJUaGUgYnJvd3NlciByZWRpcmVjdGVkIHRoZSBwYWdlIGJlZm9yZSB0aGUgbG9naW4gcmVxdWVzdCBjb3VsZCBjb21wbGV0ZS5cIixVU0VSX0NBTkNFTExFRDpcIlRoZSB1c2VyIGNhbmNlbGxlZCBhdXRoZW50aWNhdGlvbi5cIn07ZnVuY3Rpb24gWChhKXt2YXIgYj1FcnJvcih0KG5mLGEpLGEpO2IuY29kZT1hO3JldHVybiBifTtmdW5jdGlvbiBvZigpe3ZhciBhPXdpbmRvdy5vcGVuZXIuZnJhbWVzLGI7Zm9yKGI9YS5sZW5ndGgtMTswPD1iO2ItLSl0cnl7aWYoYVtiXS5sb2NhdGlvbi5wcm90b2NvbD09PXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmYVtiXS5sb2NhdGlvbi5ob3N0PT09d2luZG93LmxvY2F0aW9uLmhvc3QmJlwiX193aW5jaGFuX3JlbGF5X2ZyYW1lXCI9PT1hW2JdLm5hbWUpcmV0dXJuIGFbYl19Y2F0Y2goYyl7fXJldHVybiBudWxsfWZ1bmN0aW9uIHBmKGEsYixjKXthLmF0dGFjaEV2ZW50P2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyk6YS5hZGRFdmVudExpc3RlbmVyJiZhLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKX1mdW5jdGlvbiBxZihhLGIsYyl7YS5kZXRhY2hFdmVudD9hLmRldGFjaEV2ZW50KFwib25cIitiLGMpOmEucmVtb3ZlRXZlbnRMaXN0ZW5lciYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiByZihhKXsvXmh0dHBzPzpcXC9cXC8vLnRlc3QoYSl8fChhPXdpbmRvdy5sb2NhdGlvbi5ocmVmKTt2YXIgYj0vXihodHRwcz86XFwvXFwvW1xcLV9hLXpBLVpcXC4wLTk6XSspLy5leGVjKGEpO3JldHVybiBiP2JbMV06YX1mdW5jdGlvbiBzZihhKXt2YXIgYj1cIlwiO3RyeXthPWEucmVwbGFjZShcIiNcIixcIlwiKTt2YXIgYz17fSxkPWEucmVwbGFjZSgvXlxcPy8sXCJcIikuc3BsaXQoXCImXCIpO2ZvcihhPTA7YTxkLmxlbmd0aDthKyspaWYoZFthXSl7dmFyIGU9ZFthXS5zcGxpdChcIj1cIik7Y1tlWzBdXT1lWzFdfWMmJnMoYyxcIl9fZmlyZWJhc2VfcmVxdWVzdF9rZXlcIikmJihiPXQoYyxcIl9fZmlyZWJhc2VfcmVxdWVzdF9rZXlcIikpfWNhdGNoKGYpe31yZXR1cm4gYn1cbmZ1bmN0aW9uIHRmKGEpe3ZhciBiPVtdLGM7Zm9yKGMgaW4gYSlpZihzKGEsYykpe3ZhciBkPXQoYSxjKTtpZihlYShkKSlmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyliLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChkW2VdKSk7ZWxzZSBiLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudCh0KGEsYykpKX1yZXR1cm4gYj9cIiZcIitiLmpvaW4oXCImXCIpOlwiXCJ9ZnVuY3Rpb24gdWYoKXt2YXIgYT1yYihqZik7cmV0dXJuIGEuc2NoZW1lK1wiOi8vXCIrYS5ob3N0K1wiL3YyXCJ9ZnVuY3Rpb24gdmYoYSl7cmV0dXJuIHVmKCkrXCIvXCIrYStcIi9hdXRoL2NoYW5uZWxcIn07ZnVuY3Rpb24gd2YoKXtyZXR1cm4hISh3aW5kb3cuY29yZG92YXx8d2luZG93LnBob25lZ2FwfHx3aW5kb3cuUGhvbmVHYXApJiYvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KX1mdW5jdGlvbiB4Zigpe3ZhciBhPW5hdmlnYXRvci51c2VyQWdlbnQ7aWYoXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIj09PW5hdmlnYXRvci5hcHBOYW1lKXtpZigoYT1hLm1hdGNoKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLykpJiYxPGEubGVuZ3RoKXJldHVybiA4PD1wYXJzZUZsb2F0KGFbMV0pfWVsc2UgaWYoLTE8YS5pbmRleE9mKFwiVHJpZGVudFwiKSYmKGE9YS5tYXRjaCgvcnY6KFswLTldezIsMn1bXFwuMC05XXswLH0pLykpJiYxPGEubGVuZ3RoKXJldHVybiA4PD1wYXJzZUZsb2F0KGFbMV0pO3JldHVybiExfTtmdW5jdGlvbiB5ZihhKXthLm1ldGhvZHx8KGEubWV0aG9kPVwiR0VUXCIpO2EuaGVhZGVyc3x8KGEuaGVhZGVycz17fSk7YS5oZWFkZXJzLmNvbnRlbnRfdHlwZXx8KGEuaGVhZGVycy5jb250ZW50X3R5cGU9XCJhcHBsaWNhdGlvbi9qc29uXCIpO2EuaGVhZGVycy5jb250ZW50X3R5cGU9YS5oZWFkZXJzLmNvbnRlbnRfdHlwZS50b0xvd2VyQ2FzZSgpO3RoaXMub3B0aW9ucz1hfVxueWYucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoKXtjJiYoYyhYKFwiUkVRVUVTVF9JTlRFUlJVUFRFRFwiKSksYz1udWxsKX12YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3QsZj10aGlzLm9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCksZztwZih3aW5kb3csXCJiZWZvcmV1bmxvYWRcIixkKTtlLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKGMmJjQ9PT1lLnJlYWR5U3RhdGUpe3ZhciBhO2lmKDIwMDw9ZS5zdGF0dXMmJjMwMD5lLnN0YXR1cyl7dHJ5e2E9dGEoZS5yZXNwb25zZVRleHQpfWNhdGNoKGIpe31jKG51bGwsYSl9ZWxzZSA1MDA8PWUuc3RhdHVzJiY2MDA+ZS5zdGF0dXM/YyhYKFwiU0VSVkVSX0VSUk9SXCIpKTpjKFgoXCJORVRXT1JLX0VSUk9SXCIpKTtjPW51bGw7cWYod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCl9fTtpZihcIkdFVFwiPT09ZilhKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt0ZihiKSxnPW51bGw7ZWxzZXt2YXIgaz10aGlzLm9wdGlvbnMuaGVhZGVycy5jb250ZW50X3R5cGU7XG5cImFwcGxpY2F0aW9uL2pzb25cIj09PWsmJihnPXIoYikpO1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI9PT1rJiYoZz10ZihiKSl9ZS5vcGVuKGYsYSwhMCk7YT17XCJYLVJlcXVlc3RlZC1XaXRoXCI6XCJYTUxIdHRwUmVxdWVzdFwiLEFjY2VwdDpcImFwcGxpY2F0aW9uL2pzb247dGV4dC9wbGFpblwifTtRZChhLHRoaXMub3B0aW9ucy5oZWFkZXJzKTtmb3IodmFyIGwgaW4gYSllLnNldFJlcXVlc3RIZWFkZXIobCxhW2xdKTtlLnNlbmQoZyl9O3lmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuISF3aW5kb3cuWE1MSHR0cFJlcXVlc3QmJlwic3RyaW5nXCI9PT10eXBlb2YobmV3IFhNTEh0dHBSZXF1ZXN0KS5yZXNwb25zZVR5cGUmJighKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL01TSUUvKXx8bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudC8pKXx8eGYoKSl9O3lmLnByb3RvdHlwZS5zYz1mdW5jdGlvbigpe3JldHVyblwianNvblwifTtmdW5jdGlvbiB6ZihhKXt0aGlzLmZjPUZhKCkrRmEoKStGYSgpO3RoaXMucGY9YX1cbnpmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoWChcIlVTRVJfQ0FOQ0VMTEVEXCIpKSxjPW51bGwpfXZhciBlPXRoaXMsZj1yYihqZiksZztiLnJlcXVlc3RJZD10aGlzLmZjO2IucmVkaXJlY3RUbz1mLnNjaGVtZStcIjovL1wiK2YuaG9zdCtcIi9ibGFuay9wYWdlLmh0bWxcIjthKz0vXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCI7YSs9dGYoYik7KGc9d2luZG93Lm9wZW4oYSxcIl9ibGFua1wiLFwibG9jYXRpb249bm9cIikpJiZoYShnLmFkZEV2ZW50TGlzdGVuZXIpPyhnLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIixmdW5jdGlvbihhKXt2YXIgYjtpZihiPWEmJmEudXJsKWE6e3ZhciBuPWEudXJsO3RyeXt2YXIgdT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTt1LmhyZWY9bjtiPXUuaG9zdD09PWYuaG9zdCYmXCIvYmxhbmsvcGFnZS5odG1sXCI9PT11LnBhdGhuYW1lO2JyZWFrIGF9Y2F0Y2goeCl7fWI9ITF9YiYmKGE9c2YoYS51cmwpLGcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImV4aXRcIixcbmQpLGcuY2xvc2UoKSxhPW5ldyBrZihudWxsLG51bGwse3JlcXVlc3RJZDplLmZjLHJlcXVlc3RLZXk6YX0pLGUucGYucmVxdWVzdFdpdGhDcmVkZW50aWFsKFwiL2F1dGgvc2Vzc2lvblwiLGEsYyksYz1udWxsKX0pLGcuYWRkRXZlbnRMaXN0ZW5lcihcImV4aXRcIixkKSk6YyhYKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKX07emYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gd2YoKX07emYucHJvdG90eXBlLnNjPWZ1bmN0aW9uKCl7cmV0dXJuXCJyZWRpcmVjdFwifTtmdW5jdGlvbiBBZihhKXtpZighYS53aW5kb3dfZmVhdHVyZXN8fC0xIT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmVubmVjL1wiKXx8LTEhPT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94L1wiKSYmLTEhPT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpKWEud2luZG93X2ZlYXR1cmVzPXZvaWQgMDthLndpbmRvd19uYW1lfHwoYS53aW5kb3dfbmFtZT1cIl9ibGFua1wiKTt0aGlzLm9wdGlvbnM9YX1cbkFmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe2cmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGcpLGc9dm9pZCAwKTt1JiYodT1jbGVhckludGVydmFsKHUpKTtxZih3aW5kb3csXCJtZXNzYWdlXCIsZSk7cWYod2luZG93LFwidW5sb2FkXCIsZCk7aWYobiYmIWEpdHJ5e24uY2xvc2UoKX1jYXRjaChiKXtrLnBvc3RNZXNzYWdlKFwiZGllXCIsbCl9bj1rPXZvaWQgMH1mdW5jdGlvbiBlKGEpe2lmKGEub3JpZ2luPT09bCl0cnl7dmFyIGI9dGEoYS5kYXRhKTtcInJlYWR5XCI9PT1iLmE/ay5wb3N0TWVzc2FnZSh4LGwpOlwiZXJyb3JcIj09PWIuYT8oZCghMSksYyYmKGMoYi5kKSxjPW51bGwpKTpcInJlc3BvbnNlXCI9PT1iLmEmJihkKGIuZm9yY2VLZWVwV2luZG93T3BlbiksYyYmKGMobnVsbCxiLmQpLGM9bnVsbCkpfWNhdGNoKGUpe319dmFyIGY9eGYoKSxnLGs7aWYoIXRoaXMub3B0aW9ucy5yZWxheV91cmwpcmV0dXJuIGMoRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50czogb3JpZ2luIG9mIHVybCBhbmQgcmVsYXlfdXJsIG11c3QgbWF0Y2hcIikpO1xudmFyIGw9cmYoYSk7aWYobCE9PXJmKHRoaXMub3B0aW9ucy5yZWxheV91cmwpKWMmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKEVycm9yKFwiaW52YWxpZCBhcmd1bWVudHM6IG9yaWdpbiBvZiB1cmwgYW5kIHJlbGF5X3VybCBtdXN0IG1hdGNoXCIpKX0sMCk7ZWxzZXtmJiYoZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpLGcuc2V0QXR0cmlidXRlKFwic3JjXCIsdGhpcy5vcHRpb25zLnJlbGF5X3VybCksZy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGcuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwiX193aW5jaGFuX3JlbGF5X2ZyYW1lXCIpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZyksaz1nLmNvbnRlbnRXaW5kb3cpO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK3RmKGIpO3ZhciBuPXdpbmRvdy5vcGVuKGEsdGhpcy5vcHRpb25zLndpbmRvd19uYW1lLHRoaXMub3B0aW9ucy53aW5kb3dfZmVhdHVyZXMpO2t8fChrPW4pO3ZhciB1PXNldEludGVydmFsKGZ1bmN0aW9uKCl7biYmbi5jbG9zZWQmJlxuKGQoITEpLGMmJihjKFgoXCJVU0VSX0NBTkNFTExFRFwiKSksYz1udWxsKSl9LDUwMCkseD1yKHthOlwicmVxdWVzdFwiLGQ6Yn0pO3BmKHdpbmRvdyxcInVubG9hZFwiLGQpO3BmKHdpbmRvdyxcIm1lc3NhZ2VcIixlKX19O1xuQWYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm5cInBvc3RNZXNzYWdlXCJpbiB3aW5kb3cmJiEvXmZpbGU6XFwvLy50ZXN0KGxvY2F0aW9uLmhyZWYpJiYhKHdmKCl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1dpbmRvd3MgUGhvbmUvKXx8d2luZG93LldpbmRvd3MmJi9ebXMtYXBweDovLnRlc3QobG9jYXRpb24uaHJlZil8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaSl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0NyaU9TLyl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1R3aXR0ZXIgZm9yIGlQaG9uZS8pfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GQkFOXFwvRkJJT1MvKXx8d2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lKSYmIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1BoYW50b21KUy8pfTtBZi5wcm90b3R5cGUuc2M9ZnVuY3Rpb24oKXtyZXR1cm5cInBvcHVwXCJ9O2Z1bmN0aW9uIEJmKGEpe2EuY2FsbGJhY2tfcGFyYW1ldGVyfHwoYS5jYWxsYmFja19wYXJhbWV0ZXI9XCJjYWxsYmFja1wiKTt0aGlzLm9wdGlvbnM9YTt3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wPXdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnB8fHt9fVxuQmYucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoKXtjJiYoYyhYKFwiUkVRVUVTVF9JTlRFUlJVUFRFRFwiKSksYz1udWxsKX1mdW5jdGlvbiBlKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnBbZl09dm9pZCAwO05kKHdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnApJiYod2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucD12b2lkIDApO3RyeXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChmKTthJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9Y2F0Y2goYil7fX0sMSk7cWYod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCl9dmFyIGY9XCJmblwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpK01hdGguZmxvb3IoOTk5OTkqTWF0aC5yYW5kb20oKSk7Ylt0aGlzLm9wdGlvbnMuY2FsbGJhY2tfcGFyYW1ldGVyXT1cIl9fZmlyZWJhc2VfYXV0aF9qc29ucC5cIitmO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK3RmKGIpO1xucGYod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCk7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucFtmXT1mdW5jdGlvbihhKXtjJiYoYyhudWxsLGEpLGM9bnVsbCk7ZSgpfTtDZihmLGEsYyl9O1xuZnVuY3Rpb24gQ2YoYSxiLGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0cnl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmlkPWE7ZC5hc3luYz0hMDtkLnNyYz1iO2Qub25lcnJvcj1mdW5jdGlvbigpe3ZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO251bGwhPT1iJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7YyYmYyhYKFwiTkVUV09SS19FUlJPUlwiKSl9O3ZhciBlPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKTsoZSYmMCE9ZS5sZW5ndGg/ZVswXTpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKGQpfWNhdGNoKGYpe2MmJmMoWChcIk5FVFdPUktfRVJST1JcIikpfX0sMCl9QmYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hd2YoKX07QmYucHJvdG90eXBlLnNjPWZ1bmN0aW9uKCl7cmV0dXJuXCJqc29uXCJ9O2Z1bmN0aW9uIERmKGEsYil7dGhpcy5KZT1bXCJzZXNzaW9uXCIsYS5EZCxhLnRiXS5qb2luKFwiOlwiKTt0aGlzLlJkPWJ9RGYucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe2lmKCFiKWlmKHRoaXMuUmQubGVuZ3RoKWI9dGhpcy5SZFswXTtlbHNlIHRocm93IEVycm9yKFwiZmIubG9naW4uU2Vzc2lvbk1hbmFnZXIgOiBObyBzdG9yYWdlIG9wdGlvbnMgYXZhaWxhYmxlIVwiKTtiLnNldCh0aGlzLkplLGEpfTtEZi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7dmFyIGE9SmEodGhpcy5SZCxxKHRoaXMuWmYsdGhpcykpLGE9SWEoYSxmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9PWF9KTtRYShhLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIEhlKGMudG9rZW4pLUhlKGEudG9rZW4pfSk7cmV0dXJuIDA8YS5sZW5ndGg/YS5zaGlmdCgpOm51bGx9O0RmLnByb3RvdHlwZS5aZj1mdW5jdGlvbihhKXt0cnl7dmFyIGI9YS5nZXQodGhpcy5KZSk7aWYoYiYmYi50b2tlbilyZXR1cm4gYn1jYXRjaChjKXt9cmV0dXJuIG51bGx9O1xuRGYucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztIYSh0aGlzLlJkLGZ1bmN0aW9uKGIpe2IucmVtb3ZlKGEuSmUpfSl9O2Z1bmN0aW9uIEVmKGEpe3RoaXMuZmM9RmEoKStGYSgpK0ZhKCk7dGhpcy5wZj1hfUVmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7di5zZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIsdGhpcy5mYyk7di5zZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIsdGhpcy5mYyk7Yi5yZXF1ZXN0SWQ9dGhpcy5mYztiLnJlZGlyZWN0VG89Yi5yZWRpcmVjdFRvfHx3aW5kb3cubG9jYXRpb24uaHJlZjthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt0ZihiKTt3aW5kb3cubG9jYXRpb249YX07RWYuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hL15maWxlOlxcLy8udGVzdChsb2NhdGlvbi5ocmVmKSYmIXdmKCl9O0VmLnByb3RvdHlwZS5zYz1mdW5jdGlvbigpe3JldHVyblwicmVkaXJlY3RcIn07ZnVuY3Rpb24gRmYoYSxiLGMsZCl7RmQuY2FsbCh0aGlzLFtcImF1dGhfc3RhdHVzXCJdKTt0aGlzLk89YTt0aGlzLldlPWI7dGhpcy5DZz1jO3RoaXMuRWU9ZDt0aGlzLmljPW5ldyBEZihhLFt6YSx2XSk7dGhpcy5oYj1udWxsO0dmKHRoaXMpfW1hKEZmLEZkKTtoPUZmLnByb3RvdHlwZTtoLm5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGJ8fG51bGx9O2Z1bmN0aW9uIEdmKGEpe3YuZ2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiKSYmSGYoYSk7dmFyIGI9YS5pYy5nZXQoKTtiJiZiLnRva2VuPyhJZihhLGIpLGEuV2UoYi50b2tlbixmdW5jdGlvbihjLGQpe0pmKGEsYyxkLCExLGIudG9rZW4sYil9LGZ1bmN0aW9uKGIsZCl7S2YoYSxcInJlc3VtZVNlc3Npb24oKVwiLGIsZCl9KSk6SWYoYSxudWxsKX1cbmZ1bmN0aW9uIExmKGEsYixjLGQsZSxmKXtcImZpcmViYXNlaW8tZGVtby5jb21cIj09PWEuTy5kb21haW4mJnooXCJGaXJlYmFzZSBhdXRoZW50aWNhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIG9uIGRlbW8gRmlyZWJhc2VzICgqLmZpcmViYXNlaW8tZGVtby5jb20pLiBUbyBzZWN1cmUgeW91ciBGaXJlYmFzZSwgY3JlYXRlIGEgcHJvZHVjdGlvbiBGaXJlYmFzZSBhdCBodHRwczovL3d3dy5maXJlYmFzZS5jb20uXCIpO2EuV2UoYixmdW5jdGlvbihmLGspe0pmKGEsZixrLCEwLGIsYyxkfHx7fSxlKX0sZnVuY3Rpb24oYixjKXtLZihhLFwiYXV0aCgpXCIsYixjLGYpfSl9ZnVuY3Rpb24gTWYoYSxiKXthLmljLmNsZWFyKCk7SWYoYSxudWxsKTthLkNnKGZ1bmN0aW9uKGEsZCl7aWYoXCJva1wiPT09YSlCKGIsbnVsbCk7ZWxzZXt2YXIgZT0oYXx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGY9ZTtkJiYoZis9XCI6IFwiK2QpO2Y9RXJyb3IoZik7Zi5jb2RlPWU7QihiLGYpfX0pfVxuZnVuY3Rpb24gSmYoYSxiLGMsZCxlLGYsZyxrKXtcIm9rXCI9PT1iPyhkJiYoYj1jLmF1dGgsZi5hdXRoPWIsZi5leHBpcmVzPWMuZXhwaXJlcyxmLnRva2VuPUllKGUpP2U6XCJcIixjPW51bGwsYiYmcyhiLFwidWlkXCIpP2M9dChiLFwidWlkXCIpOnMoZixcInVpZFwiKSYmKGM9dChmLFwidWlkXCIpKSxmLnVpZD1jLGM9XCJjdXN0b21cIixiJiZzKGIsXCJwcm92aWRlclwiKT9jPXQoYixcInByb3ZpZGVyXCIpOnMoZixcInByb3ZpZGVyXCIpJiYoYz10KGYsXCJwcm92aWRlclwiKSksZi5wcm92aWRlcj1jLGEuaWMuY2xlYXIoKSxJZShlKSYmKGc9Z3x8e30sYz16YSxcInNlc3Npb25Pbmx5XCI9PT1nLnJlbWVtYmVyJiYoYz12KSxcIm5vbmVcIiE9PWcucmVtZW1iZXImJmEuaWMuc2V0KGYsYykpLElmKGEsZikpLEIoayxudWxsLGYpKTooYS5pYy5jbGVhcigpLElmKGEsbnVsbCksZj1hPShifHxcImVycm9yXCIpLnRvVXBwZXJDYXNlKCksYyYmKGYrPVwiOiBcIitjKSxmPUVycm9yKGYpLGYuY29kZT1hLEIoayxmKSl9XG5mdW5jdGlvbiBLZihhLGIsYyxkLGUpe3ooYitcIiB3YXMgY2FuY2VsZWQ6IFwiK2QpO2EuaWMuY2xlYXIoKTtJZihhLG51bGwpO2E9RXJyb3IoZCk7YS5jb2RlPWMudG9VcHBlckNhc2UoKTtCKGUsYSl9ZnVuY3Rpb24gTmYoYSxiLGMsZCxlKXtPZihhKTtjPW5ldyBrZihkfHx7fSx7fSxjfHx7fSk7UGYoYSxbeWYsQmZdLFwiL2F1dGgvXCIrYixjLGUpfVxuZnVuY3Rpb24gUWYoYSxiLGMsZCl7T2YoYSk7dmFyIGU9W0FmLHpmXTtjPW1mKGMpO1wiYW5vbnltb3VzXCI9PT1ifHxcInBhc3N3b3JkXCI9PT1iP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtCKGQsWChcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9LDApOihjLlVkLndpbmRvd19mZWF0dXJlcz1cIm1lbnViYXI9eWVzLG1vZGFsPXllcyxhbHdheXNSYWlzZWQ9eWVzbG9jYXRpb249eWVzLHJlc2l6YWJsZT15ZXMsc2Nyb2xsYmFycz15ZXMsc3RhdHVzPXllcyxoZWlnaHQ9NjI1LHdpZHRoPTYyNSx0b3A9XCIrKFwib2JqZWN0XCI9PT10eXBlb2Ygc2NyZWVuPy41KihzY3JlZW4uaGVpZ2h0LTYyNSk6MCkrXCIsbGVmdD1cIisoXCJvYmplY3RcIj09PXR5cGVvZiBzY3JlZW4/LjUqKHNjcmVlbi53aWR0aC02MjUpOjApLGMuVWQucmVsYXlfdXJsPXZmKGEuTy50YiksYy5VZC5yZXF1ZXN0V2l0aENyZWRlbnRpYWw9cShhLmdjLGEpLFBmKGEsZSxcIi9hdXRoL1wiK2IsYyxkKSl9XG5mdW5jdGlvbiBIZihhKXt2YXIgYj12LmdldChcInJlZGlyZWN0X3JlcXVlc3RfaWRcIik7aWYoYil7dmFyIGM9di5nZXQoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiKTt2LnJlbW92ZShcInJlZGlyZWN0X3JlcXVlc3RfaWRcIik7di5yZW1vdmUoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiKTt2YXIgZD1beWYsQmZdLGI9e3JlcXVlc3RJZDpiLHJlcXVlc3RLZXk6c2YoZG9jdW1lbnQubG9jYXRpb24uaGFzaCl9LGM9bmV3IGtmKGMse30sYik7dHJ5e2RvY3VtZW50LmxvY2F0aW9uLmhhc2g9ZG9jdW1lbnQubG9jYXRpb24uaGFzaC5yZXBsYWNlKC8mX19maXJlYmFzZV9yZXF1ZXN0X2tleT0oW2EtekEtejAtOV0qKS8sXCJcIil9Y2F0Y2goZSl7fVBmKGEsZCxcIi9hdXRoL3Nlc3Npb25cIixjKX19aC5qZT1mdW5jdGlvbihhLGIpe09mKHRoaXMpO3ZhciBjPW1mKGEpO2MuWGEuX21ldGhvZD1cIlBPU1RcIjt0aGlzLmdjKFwiL3VzZXJzXCIsYyxmdW5jdGlvbihhLGMpe2E/QihiLGEpOkIoYixhLGMpfSl9O1xuaC5MZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7T2YodGhpcyk7dmFyIGQ9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZW1haWwpLGU9bWYoYSk7ZS5YYS5fbWV0aG9kPVwiREVMRVRFXCI7dGhpcy5nYyhkLGUsZnVuY3Rpb24oYSxkKXshYSYmZCYmZC51aWQmJmMuaGImJmMuaGIudWlkJiZjLmhiLnVpZD09PWQudWlkJiZNZihjKTtCKGIsYSl9KX07aC5lZT1mdW5jdGlvbihhLGIpe09mKHRoaXMpO3ZhciBjPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLmVtYWlsKStcIi9wYXNzd29yZFwiLGQ9bWYoYSk7ZC5YYS5fbWV0aG9kPVwiUFVUXCI7ZC5YYS5wYXNzd29yZD1hLm5ld1Bhc3N3b3JkO3RoaXMuZ2MoYyxkLGZ1bmN0aW9uKGEpe0IoYixhKX0pfTtcbmguZGU9ZnVuY3Rpb24oYSxiKXtPZih0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5vbGRFbWFpbCkrXCIvZW1haWxcIixkPW1mKGEpO2QuWGEuX21ldGhvZD1cIlBVVFwiO2QuWGEuZW1haWw9YS5uZXdFbWFpbDtkLlhhLnBhc3N3b3JkPWEucGFzc3dvcmQ7dGhpcy5nYyhjLGQsZnVuY3Rpb24oYSl7QihiLGEpfSl9O2guTWU9ZnVuY3Rpb24oYSxiKXtPZih0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5lbWFpbCkrXCIvcGFzc3dvcmRcIixkPW1mKGEpO2QuWGEuX21ldGhvZD1cIlBPU1RcIjt0aGlzLmdjKGMsZCxmdW5jdGlvbihhKXtCKGIsYSl9KX07aC5nYz1mdW5jdGlvbihhLGIsYyl7UmYodGhpcyxbeWYsQmZdLGEsYixjKX07XG5mdW5jdGlvbiBQZihhLGIsYyxkLGUpe1JmKGEsYixjLGQsZnVuY3Rpb24oYixjKXshYiYmYyYmYy50b2tlbiYmYy51aWQ/TGYoYSxjLnRva2VuLGMsZC5jZCxmdW5jdGlvbihhLGIpe2E/QihlLGEpOkIoZSxudWxsLGIpfSk6QihlLGJ8fFgoXCJVTktOT1dOX0VSUk9SXCIpKX0pfVxuZnVuY3Rpb24gUmYoYSxiLGMsZCxlKXtiPUlhKGIsZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuaXNBdmFpbGFibGUmJmEuaXNBdmFpbGFibGUoKX0pOzA9PT1iLmxlbmd0aD9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7QihlLFgoXCJUUkFOU1BPUlRfVU5BVkFJTEFCTEVcIikpfSwwKTooYj1uZXcgKGIuc2hpZnQoKSkoZC5VZCksZD12YShkLlhhKSxkLnY9XCJqcy0yLjEuMlwiLGQudHJhbnNwb3J0PWIuc2MoKSxkLnN1cHByZXNzX3N0YXR1c19jb2Rlcz0hMCxhPXVmKCkrXCIvXCIrYS5PLnRiK2MsYi5vcGVuKGEsZCxmdW5jdGlvbihhLGIpe2lmKGEpQihlLGEpO2Vsc2UgaWYoYiYmYi5lcnJvcil7dmFyIGM9RXJyb3IoYi5lcnJvci5tZXNzYWdlKTtjLmNvZGU9Yi5lcnJvci5jb2RlO2MuZGV0YWlscz1iLmVycm9yLmRldGFpbHM7QihlLGMpfWVsc2UgQihlLG51bGwsYil9KSl9XG5mdW5jdGlvbiBJZihhLGIpe3ZhciBjPW51bGwhPT1hLmhifHxudWxsIT09YjthLmhiPWI7YyYmYS5WZChcImF1dGhfc3RhdHVzXCIsYik7YS5FZShudWxsIT09Yil9aC5xZT1mdW5jdGlvbihhKXt5KFwiYXV0aF9zdGF0dXNcIj09PWEsJ2luaXRpYWwgZXZlbnQgbXVzdCBiZSBvZiB0eXBlIFwiYXV0aF9zdGF0dXNcIicpO3JldHVyblt0aGlzLmhiXX07ZnVuY3Rpb24gT2YoYSl7dmFyIGI9YS5PO2lmKFwiZmlyZWJhc2Vpby5jb21cIiE9PWIuZG9tYWluJiZcImZpcmViYXNlaW8tZGVtby5jb21cIiE9PWIuZG9tYWluJiZcImF1dGguZmlyZWJhc2UuY29tXCI9PT1qZil0aHJvdyBFcnJvcihcIlRoaXMgY3VzdG9tIEZpcmViYXNlIHNlcnZlciAoJ1wiK2EuTy5kb21haW4rXCInKSBkb2VzIG5vdCBzdXBwb3J0IGRlbGVnYXRlZCBsb2dpbi5cIik7fTtmdW5jdGlvbiBTZihhLGIpe3JldHVybiBhJiZcIm9iamVjdFwiPT09dHlwZW9mIGE/KHkoXCIuc3ZcImluIGEsXCJVbmV4cGVjdGVkIGxlYWYgbm9kZSBvciBwcmlvcml0eSBjb250ZW50c1wiKSxiW2FbXCIuc3ZcIl1dKTphfWZ1bmN0aW9uIFRmKGEsYil7dmFyIGM9bmV3ICRlO2JmKGEsbmV3IFMoXCJcIiksZnVuY3Rpb24oYSxlKXtjLmRjKGEsVWYoZSxiKSl9KTtyZXR1cm4gY31mdW5jdGlvbiBVZihhLGIpe3ZhciBjPWEuTCgpLkkoKSxjPVNmKGMsYiksZDtpZihhLk0oKSl7dmFyIGU9U2YoYS56YSgpLGIpO3JldHVybiBlIT09YS56YSgpfHxjIT09YS5MKCkuSSgpP25ldyBuZChlLE8oYykpOmF9ZD1hO2MhPT1hLkwoKS5JKCkmJihkPWQuWihuZXcgbmQoYykpKTthLlUoTCxmdW5jdGlvbihhLGMpe3ZhciBlPVVmKGMsYik7ZSE9PWMmJihkPWQuUChhLGUpKX0pO3JldHVybiBkfTtmdW5jdGlvbiB3YyhhLGIsYyl7dGhpcy5BPWE7dGhpcy5hYT1iO3RoaXMueWM9Y31mdW5jdGlvbiBWZihhKXtyZXR1cm4gYS5hYX1mdW5jdGlvbiB2YyhhLGIpe3JldHVybiBhLmFhJiYhYS55Y3x8YS5BLkRhKGIpfXdjLnByb3RvdHlwZS5qPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQX07ZnVuY3Rpb24gV2YoYSxiKXt0aGlzLkY9YTt0aGlzLkxkPWJ9ZnVuY3Rpb24gWGYoYSxiLGMsZCl7cmV0dXJuIG5ldyBXZihuZXcgd2MoYixjLGQpLGEuTGQpfWZ1bmN0aW9uIFlmKGEpe3JldHVybiBhLkYuYWE/YS5GLmooKTpudWxsfVdmLnByb3RvdHlwZS51PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuTGR9O2Z1bmN0aW9uIHhjKGEpe3JldHVybiBhLkxkLmFhP2EuTGQuaigpOm51bGx9O2Z1bmN0aW9uIFpmKGEsYil7dGhpcy5ZZD1hO3RoaXMuT2Y9Yn1mdW5jdGlvbiAkZihhKXt0aGlzLkc9YX1cbiRmLnByb3RvdHlwZS5ZYT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgeWMsZjtpZihiLnR5cGU9PT1hZyliLnNvdXJjZS5tZT9jPWJnKHRoaXMsYSxiLnBhdGgsYi5HYSxjLGQsZSk6KHkoYi5zb3VyY2UuZGYsXCJVbmtub3duIHNvdXJjZS5cIiksZj1iLnNvdXJjZS5TZSxjPWNnKHRoaXMsYSxiLnBhdGgsYi5HYSxjLGQsZixlKSk7ZWxzZSBpZihiLnR5cGU9PT1kZyliLnNvdXJjZS5tZT9jPWVnKHRoaXMsYSxiLnBhdGgsYi5jaGlsZHJlbixjLGQsZSk6KHkoYi5zb3VyY2UuZGYsXCJVbmtub3duIHNvdXJjZS5cIiksZj1iLnNvdXJjZS5TZSxjPWZnKHRoaXMsYSxiLnBhdGgsYi5jaGlsZHJlbixjLGQsZixlKSk7ZWxzZSBpZihiLnR5cGU9PT1nZylpZihiLk5lKWlmKGY9Yi5wYXRoLG51bGwhPWMuamMoZikpYz1hO2Vsc2V7Yj1uZXcgdWMoYyxhLGQpO2Q9YS5GLmooKTtpZihmLmUoKXx8XCIucHJpb3JpdHlcIj09PUkoZikpVmYoYS51KCkpP2I9Yy5wYSh4YyhhKSk6KGI9YS51KCkuaigpLFxueShiIGluc3RhbmNlb2YgVyxcInNlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZVwiKSxiPWMucGMoYikpLGI9dGhpcy5HLm9hKGQsYixlKTtlbHNle2Y9SShmKTt2YXIgZz1jLlRhKGYsYS51KCkpO251bGw9PWcmJnZjKGEudSgpLGYpJiYoZz1kLksoZikpO2I9bnVsbCE9Zz90aGlzLkcuQyhkLGYsZyxiLGUpOmEuRi5qKCkuRGEoZik/dGhpcy5HLkMoZCxmLE0sYixlKTpkO2IuZSgpJiZWZihhLnUoKSkmJihkPWMucGEoeGMoYSkpLGQuTSgpJiYoYj10aGlzLkcub2EoYixkLGUpKSl9ZD1WZihhLnUoKSl8fG51bGwhPWMuamMoVSk7Yz1YZihhLGIsZCx0aGlzLkcueWEoKSl9ZWxzZSBjPWhnKHRoaXMsYSxiLnBhdGgsYyxkLGUpO2Vsc2UgaWYoYi50eXBlPT09aWcpZD1iLnBhdGgsYj1hLnUoKSxmPWIuaigpLGc9Yi5hYXx8ZC5lKCksYz1qZyh0aGlzLG5ldyBXZihhLkYsbmV3IHdjKGYsZyxiLnljKSksZCxjLHRjLGUpO2Vsc2UgdGhyb3cgZmIoXCJVbmtub3duIG9wZXJhdGlvbiB0eXBlOiBcIitcbmIudHlwZSk7ZT1KZChlLlphKTtkPWM7Yj1kLkY7Yi5hYSYmKGY9Yi5qKCkuTSgpfHxiLmooKS5lKCksZz1ZZihhKSwoMDxlLmxlbmd0aHx8IWEuRi5hYXx8ZiYmIWIuaigpLmVhKGcpfHwhYi5qKCkuTCgpLmVhKGcuTCgpKSkmJmUucHVzaChGYihZZihkKSkpKTtyZXR1cm4gbmV3IFpmKGMsZSl9O1xuZnVuY3Rpb24gamcoYSxiLGMsZCxlLGYpe3ZhciBnPWIuRjtpZihudWxsIT1kLmpjKGMpKXJldHVybiBiO3ZhciBrO2lmKGMuZSgpKXkoVmYoYi51KCkpLFwiSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YVwiKSxhLkcueWEoKT8oZT14YyhiKSxkPWQucGMoZSBpbnN0YW5jZW9mIFc/ZTpNKSk6ZD1kLnBhKHhjKGIpKSxmPWEuRy5vYShiLkYuaigpLGQsZik7ZWxzZXt2YXIgbD1JKGMpO2lmKFwiLnByaW9yaXR5XCI9PWwpeSgxPT1RYyhjKSxcIkNhbid0IGhhdmUgYSBwcmlvcml0eSB3aXRoIGFkZGl0aW9uYWwgcGF0aCBjb21wb25lbnRzXCIpLGY9Zy5qKCksaz1iLnUoKS5qKCksZD1kLiRjKGMsZixrKSxmPW51bGwhPWQ/YS5HLlooZixkKTpnLmooKTtlbHNle3ZhciBuPVQoYyk7dmMoZyxsKT8oaz1iLnUoKS5qKCksZD1kLiRjKGMsZy5qKCksayksZD1udWxsIT1kP2cuaigpLksobCkuQyhuLGQpOmcuaigpLksobCkpOmQ9ZC5UYShsLGIudSgpKTtcbmY9bnVsbCE9ZD9hLkcuQyhnLmooKSxsLGQsZSxmKTpnLmooKX19cmV0dXJuIFhmKGIsZixnLmFhfHxjLmUoKSxhLkcueWEoKSl9ZnVuY3Rpb24gY2coYSxiLGMsZCxlLGYsZyxrKXt2YXIgbD1iLnUoKTtnPWc/YS5HOmEuRy5NYigpO2lmKGMuZSgpKWQ9Zy5vYShsLmooKSxkLG51bGwpO2Vsc2UgaWYoZy55YSgpJiYhbC55YylkPWwuaigpLkMoYyxkKSxkPWcub2EobC5qKCksZCxudWxsKTtlbHNle3ZhciBuPUkoYyk7aWYoKGMuZSgpPyFsLmFhfHxsLnljOiF2YyhsLEkoYykpKSYmMTxRYyhjKSlyZXR1cm4gYjtkPWwuaigpLksobikuQyhUKGMpLGQpO2Q9XCIucHJpb3JpdHlcIj09bj9nLloobC5qKCksZCk6Zy5DKGwuaigpLG4sZCx0YyxudWxsKX1sPWwuYWF8fGMuZSgpO2I9bmV3IFdmKGIuRixuZXcgd2MoZCxsLGcueWEoKSkpO3JldHVybiBqZyhhLGIsYyxlLG5ldyB1YyhlLGIsZiksayl9XG5mdW5jdGlvbiBiZyhhLGIsYyxkLGUsZixnKXt2YXIgaz1iLkY7ZT1uZXcgdWMoZSxiLGYpO2lmKGMuZSgpKWc9YS5HLm9hKGIuRi5qKCksZCxnKSxhPVhmKGIsZywhMCxhLkcueWEoKSk7ZWxzZSBpZihmPUkoYyksXCIucHJpb3JpdHlcIj09PWYpZz1hLkcuWihiLkYuaigpLGQpLGE9WGYoYixnLGsuYWEsay55Yyk7ZWxzZXt2YXIgbD1UKGMpO2M9ay5qKCkuSyhmKTtpZighbC5lKCkpe3ZhciBuPWUuZWYoZik7ZD1udWxsIT1uP1wiLnByaW9yaXR5XCI9PT1SYyhsKSYmbi5yYShsLnBhcmVudCgpKS5lKCk/bjpuLkMobCxkKTpNfWMuZWEoZCk/YT1iOihnPWEuRy5DKGsuaigpLGYsZCxlLGcpLGE9WGYoYixnLGsuYWEsYS5HLnlhKCkpKX1yZXR1cm4gYX1cbmZ1bmN0aW9uIGVnKGEsYixjLGQsZSxmLGcpe3ZhciBrPWI7a2coZCxmdW5jdGlvbihkLG4pe3ZhciB1PWMubyhkKTt2YyhiLkYsSSh1KSkmJihrPWJnKGEsayx1LG4sZSxmLGcpKX0pO2tnKGQsZnVuY3Rpb24oZCxuKXt2YXIgdT1jLm8oZCk7dmMoYi5GLEkodSkpfHwoaz1iZyhhLGssdSxuLGUsZixnKSl9KTtyZXR1cm4ga31mdW5jdGlvbiBsZyhhLGIpe2tnKGIsZnVuY3Rpb24oYixkKXthPWEuQyhiLGQpfSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBmZyhhLGIsYyxkLGUsZixnLGspe2lmKGIudSgpLmooKS5lKCkmJiFWZihiLnUoKSkpcmV0dXJuIGI7dmFyIGw9YjtjPWMuZSgpP2Q6bWcobmcsYyxkKTt2YXIgbj1iLnUoKS5qKCk7Yy5jaGlsZHJlbi5mYShmdW5jdGlvbihjLGQpe2lmKG4uRGEoYykpe3ZhciBFPWIudSgpLmooKS5LKGMpLEU9bGcoRSxkKTtsPWNnKGEsbCxuZXcgUyhjKSxFLGUsZixnLGspfX0pO2MuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYyxkKXt2YXIgRT0hVmYoYi51KCkpJiZudWxsPT1kLnZhbHVlO24uRGEoYyl8fEV8fChFPWIudSgpLmooKS5LKGMpLEU9bGcoRSxkKSxsPWNnKGEsbCxuZXcgUyhjKSxFLGUsZixnLGspKX0pO3JldHVybiBsfVxuZnVuY3Rpb24gaGcoYSxiLGMsZCxlLGYpe2lmKG51bGwhPWQuamMoYykpcmV0dXJuIGI7dmFyIGc9bmV3IHVjKGQsYixlKSxrPWU9Yi5GLmooKTtpZihWZihiLnUoKSkpe2lmKGMuZSgpKWU9ZC5wYSh4YyhiKSksaz1hLkcub2EoYi5GLmooKSxlLGYpO2Vsc2UgaWYoXCIucHJpb3JpdHlcIj09PUkoYykpe3ZhciBsPWQuVGEoSShjKSxiLnUoKSk7bnVsbD09bHx8ZS5lKCl8fGUuTCgpLmVhKGwpfHwoaz1hLkcuWihlLGwpKX1lbHNlIGw9SShjKSxlPWQuVGEobCxiLnUoKSksbnVsbCE9ZSYmKGs9YS5HLkMoYi5GLmooKSxsLGUsZyxmKSk7ZT0hMH1lbHNlIGIuRi5hYT8oaz1lLGU9WWYoYiksZS5NKCl8fGUuVShMLGZ1bmN0aW9uKGMpe3ZhciBlPWQuVGEoYyxiLnUoKSk7bnVsbCE9ZSYmKGs9YS5HLkMoayxjLGUsZyxmKSl9KSxlPSEwKTooIWMuZSgpJiYobD1JKGMpLDE9PVFjKGMpfHx2YyhiLkYsbCkpJiYoYz1kLlRhKGwsYi51KCkpLG51bGwhPWMmJihrPWEuRy5DKGUsbCxjLGcsZikpKSxcbmU9ITEpO3JldHVybiBYZihiLGssZSxhLkcueWEoKSl9O2Z1bmN0aW9uIG9nKGEpe3RoaXMuVj1hO3RoaXMuZz1hLm4uZ31mdW5jdGlvbiBwZyhhLGIsYyxkKXt2YXIgZT1bXSxmPVtdO0hhKGIsZnVuY3Rpb24oYil7XCJjaGlsZF9jaGFuZ2VkXCI9PT1iLnR5cGUmJmEuZy5qZihiLkRlLGIuSGEpJiZmLnB1c2gobmV3IEMoXCJjaGlsZF9tb3ZlZFwiLGIuSGEsYi5VYSkpfSk7cWcoYSxlLFwiY2hpbGRfcmVtb3ZlZFwiLGIsZCxjKTtxZyhhLGUsXCJjaGlsZF9hZGRlZFwiLGIsZCxjKTtxZyhhLGUsXCJjaGlsZF9tb3ZlZFwiLGYsZCxjKTtxZyhhLGUsXCJjaGlsZF9jaGFuZ2VkXCIsYixkLGMpO3FnKGEsZSxHYixiLGQsYyk7cmV0dXJuIGV9ZnVuY3Rpb24gcWcoYSxiLGMsZCxlLGYpe2Q9SWEoZCxmdW5jdGlvbihhKXtyZXR1cm4gYS50eXBlPT09Y30pO1FhKGQscShhLlFmLGEpKTtIYShkLGZ1bmN0aW9uKGMpe3ZhciBkPXJnKGEsYyxmKTtIYShlLGZ1bmN0aW9uKGUpe2Uud2YoYy50eXBlKSYmYi5wdXNoKGUuY3JlYXRlRXZlbnQoZCxhLlYpKX0pfSl9XG5mdW5jdGlvbiByZyhhLGIsYyl7XCJ2YWx1ZVwiIT09Yi50eXBlJiZcImNoaWxkX3JlbW92ZWRcIiE9PWIudHlwZSYmKGIuRmQ9Yy5mZihiLlVhLGIuSGEsYS5nKSk7cmV0dXJuIGJ9b2cucHJvdG90eXBlLlFmPWZ1bmN0aW9uKGEsYil7aWYobnVsbD09YS5VYXx8bnVsbD09Yi5VYSl0aHJvdyBmYihcIlNob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy5cIik7cmV0dXJuIHRoaXMuZy5jb21wYXJlKG5ldyBOKGEuVWEsYS5IYSksbmV3IE4oYi5VYSxiLkhhKSl9O2Z1bmN0aW9uIHNnKGEsYil7dGhpcy5WPWE7dmFyIGM9YS5uLGQ9bmV3IGJjKGMuZyksYz1KYyhjKT9uZXcgYmMoYy5nKTpjLmthP25ldyBBYyhjKTpuZXcgZGMoYyk7dGhpcy5zZj1uZXcgJGYoYyk7dmFyIGU9Yi51KCksZj1iLkYsZz1kLm9hKE0sZS5qKCksbnVsbCksaz1jLm9hKE0sZi5qKCksbnVsbCk7dGhpcy5JYT1uZXcgV2YobmV3IHdjKGssZi5hYSxjLnlhKCkpLG5ldyB3YyhnLGUuYWEsZC55YSgpKSk7dGhpcy5WYT1bXTt0aGlzLlVmPW5ldyBvZyhhKX1mdW5jdGlvbiB0ZyhhKXtyZXR1cm4gYS5WfWg9c2cucHJvdG90eXBlO2gudT1mdW5jdGlvbigpe3JldHVybiB0aGlzLklhLnUoKS5qKCl9O2guYmI9ZnVuY3Rpb24oYSl7dmFyIGI9eGModGhpcy5JYSk7cmV0dXJuIGImJihKYyh0aGlzLlYubil8fCFhLmUoKSYmIWIuSyhJKGEpKS5lKCkpP2IucmEoYSk6bnVsbH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLlZhLmxlbmd0aH07aC5HYj1mdW5jdGlvbihhKXt0aGlzLlZhLnB1c2goYSl9O1xuaC5nYj1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO2lmKGIpe3kobnVsbD09YSxcIkEgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXCIpO3ZhciBkPXRoaXMuVi5wYXRoO0hhKHRoaXMuVmEsZnVuY3Rpb24oYSl7KGE9YS5ZZShiLGQpKSYmYy5wdXNoKGEpfSl9aWYoYSl7Zm9yKHZhciBlPVtdLGY9MDtmPHRoaXMuVmEubGVuZ3RoOysrZil7dmFyIGc9dGhpcy5WYVtmXTtpZighZy5tYXRjaGVzKGEpKWUucHVzaChnKTtlbHNlIGlmKGEuaGYoKSl7ZT1lLmNvbmNhdCh0aGlzLlZhLnNsaWNlKGYrMSkpO2JyZWFrfX10aGlzLlZhPWV9ZWxzZSB0aGlzLlZhPVtdO3JldHVybiBjfTtcbmguWWE9ZnVuY3Rpb24oYSxiLGMpe2EudHlwZT09PWRnJiZudWxsIT09YS5zb3VyY2UueWImJih5KHhjKHRoaXMuSWEpLFwiV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzXCIpLHkoWWYodGhpcy5JYSksXCJNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlXCIpKTt2YXIgZD10aGlzLklhO2E9dGhpcy5zZi5ZYShkLGEsYixjKTtiPXRoaXMuc2Y7Yz1hLllkO3koYy5GLmooKS5CYyhiLkcuZyksXCJFdmVudCBzbmFwIG5vdCBpbmRleGVkXCIpO3koYy51KCkuaigpLkJjKGIuRy5nKSxcIlNlcnZlciBzbmFwIG5vdCBpbmRleGVkXCIpO3koVmYoYS5ZZC51KCkpfHwhVmYoZC51KCkpLFwiT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFja1wiKTt0aGlzLklhPWEuWWQ7cmV0dXJuIHVnKHRoaXMsYS5PZixhLllkLkYuaigpLG51bGwpfTtcbmZ1bmN0aW9uIHZnKGEsYil7dmFyIGM9YS5JYS5GLGQ9W107Yy5qKCkuTSgpfHxjLmooKS5VKEwsZnVuY3Rpb24oYSxiKXtkLnB1c2gobmV3IEMoXCJjaGlsZF9hZGRlZFwiLGIsYSkpfSk7Yy5hYSYmZC5wdXNoKEZiKGMuaigpKSk7cmV0dXJuIHVnKGEsZCxjLmooKSxiKX1mdW5jdGlvbiB1ZyhhLGIsYyxkKXtyZXR1cm4gcGcoYS5VZixiLGMsZD9bZF06YS5WYSl9O2Z1bmN0aW9uIHdnKGEsYil7dGhpcy52YWx1ZT1hO3RoaXMuY2hpbGRyZW49Ynx8eGd9dmFyIHhnPW5ldyBaYyhmdW5jdGlvbihhLGIpe3JldHVybiBhPT09Yj8wOmE8Yj8tMToxfSksbmc9bmV3IHdnKG51bGwpO2Z1bmN0aW9uIHlnKGEpe3ZhciBiPW5nO0EoYSxmdW5jdGlvbihhLGQpe2I9Yi5zZXQobmV3IFMoZCksYSl9KTtyZXR1cm4gYn1oPXdnLnByb3RvdHlwZTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMudmFsdWUmJnRoaXMuY2hpbGRyZW4uZSgpfTtmdW5jdGlvbiB6ZyhhLGIsYyl7aWYobnVsbCE9YS52YWx1ZSYmYyhhLnZhbHVlKSlyZXR1cm57cGF0aDpVLHZhbHVlOmEudmFsdWV9O2lmKGIuZSgpKXJldHVybiBudWxsO3ZhciBkPUkoYik7YT1hLmNoaWxkcmVuLmdldChkKTtyZXR1cm4gbnVsbCE9PWE/KGI9emcoYSxUKGIpLGMpLG51bGwhPWI/e3BhdGg6KG5ldyBTKGQpKS5vKGIucGF0aCksdmFsdWU6Yi52YWx1ZX06bnVsbCk6bnVsbH1cbmZ1bmN0aW9uIEFnKGEsYil7cmV0dXJuIHpnKGEsYixmdW5jdGlvbigpe3JldHVybiEwfSl9aC5zdWJ0cmVlPWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiB0aGlzO3ZhciBiPXRoaXMuY2hpbGRyZW4uZ2V0KEkoYSkpO3JldHVybiBudWxsIT09Yj9iLnN1YnRyZWUoVChhKSk6bmd9O2guc2V0PWZ1bmN0aW9uKGEsYil7aWYoYS5lKCkpcmV0dXJuIG5ldyB3ZyhiLHRoaXMuY2hpbGRyZW4pO3ZhciBjPUkoYSksZD0odGhpcy5jaGlsZHJlbi5nZXQoYyl8fG5nKS5zZXQoVChhKSxiKSxjPXRoaXMuY2hpbGRyZW4uTGEoYyxkKTtyZXR1cm4gbmV3IHdnKHRoaXMudmFsdWUsYyl9O1xuaC5yZW1vdmU9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXMuY2hpbGRyZW4uZSgpP25nOm5ldyB3ZyhudWxsLHRoaXMuY2hpbGRyZW4pO3ZhciBiPUkoYSksYz10aGlzLmNoaWxkcmVuLmdldChiKTtyZXR1cm4gYz8oYT1jLnJlbW92ZShUKGEpKSxiPWEuZSgpP3RoaXMuY2hpbGRyZW4ucmVtb3ZlKGIpOnRoaXMuY2hpbGRyZW4uTGEoYixhKSxudWxsPT09dGhpcy52YWx1ZSYmYi5lKCk/bmc6bmV3IHdnKHRoaXMudmFsdWUsYikpOnRoaXN9O2guZ2V0PWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiB0aGlzLnZhbHVlO3ZhciBiPXRoaXMuY2hpbGRyZW4uZ2V0KEkoYSkpO3JldHVybiBiP2IuZ2V0KFQoYSkpOm51bGx9O1xuZnVuY3Rpb24gbWcoYSxiLGMpe2lmKGIuZSgpKXJldHVybiBjO3ZhciBkPUkoYik7Yj1tZyhhLmNoaWxkcmVuLmdldChkKXx8bmcsVChiKSxjKTtkPWIuZSgpP2EuY2hpbGRyZW4ucmVtb3ZlKGQpOmEuY2hpbGRyZW4uTGEoZCxiKTtyZXR1cm4gbmV3IHdnKGEudmFsdWUsZCl9ZnVuY3Rpb24gQmcoYSxiKXtyZXR1cm4gQ2coYSxVLGIpfWZ1bmN0aW9uIENnKGEsYixjKXt2YXIgZD17fTthLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsZil7ZFthXT1DZyhmLGIubyhhKSxjKX0pO3JldHVybiBjKGIsYS52YWx1ZSxkKX1mdW5jdGlvbiBEZyhhLGIsYyl7cmV0dXJuIEVnKGEsYixVLGMpfWZ1bmN0aW9uIEVnKGEsYixjLGQpe3ZhciBlPWEudmFsdWU/ZChjLGEudmFsdWUpOiExO2lmKGUpcmV0dXJuIGU7aWYoYi5lKCkpcmV0dXJuIG51bGw7ZT1JKGIpO3JldHVybihhPWEuY2hpbGRyZW4uZ2V0KGUpKT9FZyhhLFQoYiksYy5vKGUpLGQpOm51bGx9XG5mdW5jdGlvbiBGZyhhLGIsYyl7aWYoIWIuZSgpKXt2YXIgZD0hMDthLnZhbHVlJiYoZD1jKFUsYS52YWx1ZSkpOyEwPT09ZCYmKGQ9SShiKSwoYT1hLmNoaWxkcmVuLmdldChkKSkmJkdnKGEsVChiKSxVLm8oZCksYykpfX1mdW5jdGlvbiBHZyhhLGIsYyxkKXtpZihiLmUoKSlyZXR1cm4gYTthLnZhbHVlJiZkKGMsYS52YWx1ZSk7dmFyIGU9SShiKTtyZXR1cm4oYT1hLmNoaWxkcmVuLmdldChlKSk/R2coYSxUKGIpLGMubyhlKSxkKTpuZ31mdW5jdGlvbiBrZyhhLGIpe0hnKGEsVSxiKX1mdW5jdGlvbiBIZyhhLGIsYyl7YS5jaGlsZHJlbi5mYShmdW5jdGlvbihhLGUpe0hnKGUsYi5vKGEpLGMpfSk7YS52YWx1ZSYmYyhiLGEudmFsdWUpfWZ1bmN0aW9uIElnKGEsYil7YS5jaGlsZHJlbi5mYShmdW5jdGlvbihhLGQpe2QudmFsdWUmJmIoYSxkLnZhbHVlKX0pfVxuaC50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPXt9O2tnKHRoaXMsZnVuY3Rpb24oYixjKXthW2IudG9TdHJpbmcoKV09Yy50b1N0cmluZygpfSk7cmV0dXJuIHIoYSl9O2Z1bmN0aW9uIEpnKCl7dGhpcy52YT17fX1oPUpnLnByb3RvdHlwZTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gTmQodGhpcy52YSl9O2guWWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEuc291cmNlLnliO2lmKG51bGwhPT1kKXJldHVybiBkPXQodGhpcy52YSxkKSx5KG51bGwhPWQsXCJTeW5jVHJlZSBnYXZlIHVzIGFuIG9wIGZvciBhbiBpbnZhbGlkIHF1ZXJ5LlwiKSxkLllhKGEsYixjKTt2YXIgZT1bXTtBKHRoaXMudmEsZnVuY3Rpb24oZCl7ZT1lLmNvbmNhdChkLllhKGEsYixjKSl9KTtyZXR1cm4gZX07aC5HYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEuRmEoKSxnPXQodGhpcy52YSxmKTtpZighZyl7dmFyIGc9Yy5wYShlP2Q6bnVsbCksaz0hMTtnP2s9ITA6KGc9ZCBpbnN0YW5jZW9mIFc/Yy5wYyhkKTpNLGs9ITEpO2c9bmV3IHNnKGEsbmV3IFdmKG5ldyB3YyhnLGssITEpLG5ldyB3YyhkLGUsITEpKSk7dGhpcy52YVtmXT1nfWcuR2IoYik7cmV0dXJuIHZnKGcsYil9O1xuaC5nYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5GYSgpLGU9W10sZj1bXSxnPW51bGwhPUtnKHRoaXMpO2lmKFwiZGVmYXVsdFwiPT09ZCl7dmFyIGs9dGhpcztBKHRoaXMudmEsZnVuY3Rpb24oYSxkKXtmPWYuY29uY2F0KGEuZ2IoYixjKSk7YS5lKCkmJihkZWxldGUgay52YVtkXSxKYyhhLlYubil8fGUucHVzaChhLlYpKX0pfWVsc2V7dmFyIGw9dCh0aGlzLnZhLGQpO2wmJihmPWYuY29uY2F0KGwuZ2IoYixjKSksbC5lKCkmJihkZWxldGUgdGhpcy52YVtkXSxKYyhsLlYubil8fGUucHVzaChsLlYpKSl9ZyYmbnVsbD09S2codGhpcykmJmUucHVzaChuZXcgUihhLmssYS5wYXRoKSk7cmV0dXJue3JnOmUsVmY6Zn19O2Z1bmN0aW9uIExnKGEpe3JldHVybiBJYShKZChhLnZhKSxmdW5jdGlvbihhKXtyZXR1cm4hSmMoYS5WLm4pfSl9aC5iYj1mdW5jdGlvbihhKXt2YXIgYj1udWxsO0EodGhpcy52YSxmdW5jdGlvbihjKXtiPWJ8fGMuYmIoYSl9KTtyZXR1cm4gYn07XG5mdW5jdGlvbiBNZyhhLGIpe2lmKEpjKGIubikpcmV0dXJuIEtnKGEpO3ZhciBjPWIuRmEoKTtyZXR1cm4gdChhLnZhLGMpfWZ1bmN0aW9uIEtnKGEpe3JldHVybiBNZChhLnZhLGZ1bmN0aW9uKGEpe3JldHVybiBKYyhhLlYubil9KXx8bnVsbH07ZnVuY3Rpb24gTmcoYSl7dGhpcy5XPWF9dmFyIE9nPW5ldyBOZyhuZXcgd2cobnVsbCkpO2Z1bmN0aW9uIFBnKGEsYixjKXtpZihiLmUoKSlyZXR1cm4gbmV3IE5nKG5ldyB3ZyhjKSk7dmFyIGQ9QWcoYS5XLGIpO2lmKG51bGwhPWQpe3ZhciBlPWQucGF0aCxkPWQudmFsdWU7Yj1WKGUsYik7ZD1kLkMoYixjKTtyZXR1cm4gbmV3IE5nKGEuVy5zZXQoZSxkKSl9YT1tZyhhLlcsYixuZXcgd2coYykpO3JldHVybiBuZXcgTmcoYSl9ZnVuY3Rpb24gUWcoYSxiLGMpe3ZhciBkPWE7dWEoYyxmdW5jdGlvbihhLGMpe2Q9UGcoZCxiLm8oYSksYyl9KTtyZXR1cm4gZH1OZy5wcm90b3R5cGUuR2Q9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIE9nO2E9bWcodGhpcy5XLGEsbmcpO3JldHVybiBuZXcgTmcoYSl9O2Z1bmN0aW9uIFJnKGEsYil7dmFyIGM9QWcoYS5XLGIpO3JldHVybiBudWxsIT1jP2EuVy5nZXQoYy5wYXRoKS5yYShWKGMucGF0aCxiKSk6bnVsbH1cbmZ1bmN0aW9uIFNnKGEpe3ZhciBiPVtdLGM9YS5XLnZhbHVlO251bGwhPWM/Yy5NKCl8fGMuVShMLGZ1bmN0aW9uKGEsYyl7Yi5wdXNoKG5ldyBOKGEsYykpfSk6YS5XLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsYyl7bnVsbCE9Yy52YWx1ZSYmYi5wdXNoKG5ldyBOKGEsYy52YWx1ZSkpfSk7cmV0dXJuIGJ9ZnVuY3Rpb24gVGcoYSxiKXtpZihiLmUoKSlyZXR1cm4gYTt2YXIgYz1SZyhhLGIpO3JldHVybiBudWxsIT1jP25ldyBOZyhuZXcgd2coYykpOm5ldyBOZyhhLlcuc3VidHJlZShiKSl9TmcucHJvdG90eXBlLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5XLmUoKX07TmcucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEpe3JldHVybiBVZyhVLHRoaXMuVyxhKX07XG5mdW5jdGlvbiBVZyhhLGIsYyl7aWYobnVsbCE9Yi52YWx1ZSlyZXR1cm4gYy5DKGEsYi52YWx1ZSk7dmFyIGQ9bnVsbDtiLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGIsZil7XCIucHJpb3JpdHlcIj09PWI/KHkobnVsbCE9PWYudmFsdWUsXCJQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2Rlc1wiKSxkPWYudmFsdWUpOmM9VWcoYS5vKGIpLGYsYyl9KTtjLnJhKGEpLmUoKXx8bnVsbD09PWR8fChjPWMuQyhhLm8oXCIucHJpb3JpdHlcIiksZCkpO3JldHVybiBjfTtmdW5jdGlvbiBWZygpe3RoaXMuVD1PZzt0aGlzLndhPVtdO3RoaXMuRWM9LTF9aD1WZy5wcm90b3R5cGU7XG5oLkdkPWZ1bmN0aW9uKGEpe3ZhciBiPU5hKHRoaXMud2EsZnVuY3Rpb24oYil7cmV0dXJuIGIuWmQ9PT1hfSk7eSgwPD1iLFwicmVtb3ZlV3JpdGUgY2FsbGVkIHdpdGggbm9uZXhpc3RlbnQgd3JpdGVJZC5cIik7dmFyIGM9dGhpcy53YVtiXTt0aGlzLndhLnNwbGljZShiLDEpO2Zvcih2YXIgZD1jLnZpc2libGUsZT0hMSxmPXRoaXMud2EubGVuZ3RoLTE7ZCYmMDw9Zjspe3ZhciBnPXRoaXMud2FbZl07Zy52aXNpYmxlJiYoZj49YiYmV2coZyxjLnBhdGgpP2Q9ITE6Yy5wYXRoLmNvbnRhaW5zKGcucGF0aCkmJihlPSEwKSk7Zi0tfWlmKGQpe2lmKGUpdGhpcy5UPVhnKHRoaXMud2EsWWcsVSksdGhpcy5FYz0wPHRoaXMud2EubGVuZ3RoP3RoaXMud2FbdGhpcy53YS5sZW5ndGgtMV0uWmQ6LTE7ZWxzZSBpZihjLkdhKXRoaXMuVD10aGlzLlQuR2QoYy5wYXRoKTtlbHNle3ZhciBrPXRoaXM7QShjLmNoaWxkcmVuLGZ1bmN0aW9uKGEsYil7ay5UPWsuVC5HZChjLnBhdGgubyhiKSl9KX1yZXR1cm4gYy5wYXRofXJldHVybiBudWxsfTtcbmgucGE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoY3x8ZCl7dmFyIGU9VGcodGhpcy5ULGEpO3JldHVybiFkJiZlLmUoKT9iOmR8fG51bGwhPWJ8fG51bGwhPVJnKGUsVSk/KGU9WGcodGhpcy53YSxmdW5jdGlvbihiKXtyZXR1cm4oYi52aXNpYmxlfHxkKSYmKCFjfHwhKDA8PUdhKGMsYi5aZCkpKSYmKGIucGF0aC5jb250YWlucyhhKXx8YS5jb250YWlucyhiLnBhdGgpKX0sYSksYj1ifHxNLGUuYXBwbHkoYikpOm51bGx9ZT1SZyh0aGlzLlQsYSk7aWYobnVsbCE9ZSlyZXR1cm4gZTtlPVRnKHRoaXMuVCxhKTtyZXR1cm4gZS5lKCk/YjpudWxsIT1ifHxudWxsIT1SZyhlLFUpPyhiPWJ8fE0sZS5hcHBseShiKSk6bnVsbH07XG5oLnBjPWZ1bmN0aW9uKGEsYil7dmFyIGM9TSxkPVJnKHRoaXMuVCxhKTtpZihkKWQuTSgpfHxkLlUoTCxmdW5jdGlvbihhLGIpe2M9Yy5QKGEsYil9KTtlbHNlIGlmKGIpe3ZhciBlPVRnKHRoaXMuVCxhKTtiLlUoTCxmdW5jdGlvbihhLGIpe3ZhciBkPVRnKGUsbmV3IFMoYSkpLmFwcGx5KGIpO2M9Yy5QKGEsZCl9KTtIYShTZyhlKSxmdW5jdGlvbihhKXtjPWMuUChhLm5hbWUsYS5ZKX0pfWVsc2UgZT1UZyh0aGlzLlQsYSksSGEoU2coZSksZnVuY3Rpb24oYSl7Yz1jLlAoYS5uYW1lLGEuWSl9KTtyZXR1cm4gY307aC4kYz1mdW5jdGlvbihhLGIsYyxkKXt5KGN8fGQsXCJFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcIik7YT1hLm8oYik7aWYobnVsbCE9UmcodGhpcy5ULGEpKXJldHVybiBudWxsO2E9VGcodGhpcy5ULGEpO3JldHVybiBhLmUoKT9kLnJhKGIpOmEuYXBwbHkoZC5yYShiKSl9O1xuaC5UYT1mdW5jdGlvbihhLGIsYyl7YT1hLm8oYik7dmFyIGQ9UmcodGhpcy5ULGEpO3JldHVybiBudWxsIT1kP2Q6dmMoYyxiKT9UZyh0aGlzLlQsYSkuYXBwbHkoYy5qKCkuSyhiKSk6bnVsbH07aC5qYz1mdW5jdGlvbihhKXtyZXR1cm4gUmcodGhpcy5ULGEpfTtoLmNlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZzthPVRnKHRoaXMuVCxhKTtnPVJnKGEsVSk7aWYobnVsbD09ZylpZihudWxsIT1iKWc9YS5hcHBseShiKTtlbHNlIHJldHVybltdO2c9Zy5GYihmKTtpZihnLmUoKXx8Zy5NKCkpcmV0dXJuW107Yj1bXTthPW1jKGYpO2U9ZT9nLlJiKGMsZik6Zy5QYihjLGYpO2ZvcihmPVAoZSk7ZiYmYi5sZW5ndGg8ZDspMCE9PWEoZixjKSYmYi5wdXNoKGYpLGY9UChlKTtyZXR1cm4gYn07XG5mdW5jdGlvbiBXZyhhLGIpe3JldHVybiBhLkdhP2EucGF0aC5jb250YWlucyhiKTohIUxkKGEuY2hpbGRyZW4sZnVuY3Rpb24oYyxkKXtyZXR1cm4gYS5wYXRoLm8oZCkuY29udGFpbnMoYil9KX1mdW5jdGlvbiBZZyhhKXtyZXR1cm4gYS52aXNpYmxlfVxuZnVuY3Rpb24gWGcoYSxiLGMpe2Zvcih2YXIgZD1PZyxlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV07aWYoYihmKSl7dmFyIGc9Zi5wYXRoO2lmKGYuR2EpYy5jb250YWlucyhnKT8oZz1WKGMsZyksZD1QZyhkLGcsZi5HYSkpOmcuY29udGFpbnMoYykmJihnPVYoZyxjKSxkPVBnKGQsVSxmLkdhLnJhKGcpKSk7ZWxzZSBpZihmLmNoaWxkcmVuKWlmKGMuY29udGFpbnMoZykpZz1WKGMsZyksZD1RZyhkLGcsZi5jaGlsZHJlbik7ZWxzZXtpZihnLmNvbnRhaW5zKGMpKWlmKGc9VihnLGMpLGcuZSgpKWQ9UWcoZCxVLGYuY2hpbGRyZW4pO2Vsc2UgaWYoZj10KGYuY2hpbGRyZW4sSShnKSkpZj1mLnJhKFQoZykpLGQ9UGcoZCxVLGYpfWVsc2UgdGhyb3cgZmIoXCJXcml0ZVJlY29yZCBzaG91bGQgaGF2ZSAuc25hcCBvciAuY2hpbGRyZW5cIik7fX1yZXR1cm4gZH1mdW5jdGlvbiBaZyhhLGIpe3RoaXMuRGI9YTt0aGlzLlc9Yn1oPVpnLnByb3RvdHlwZTtcbmgucGE9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLlcucGEodGhpcy5EYixhLGIsYyl9O2gucGM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuVy5wYyh0aGlzLkRiLGEpfTtoLiRjPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5XLiRjKHRoaXMuRGIsYSxiLGMpfTtoLmpjPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlcuamModGhpcy5EYi5vKGEpKX07aC5jZT1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiB0aGlzLlcuY2UodGhpcy5EYixhLGIsYyxkLGUpfTtoLlRhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuVy5UYSh0aGlzLkRiLGEsYil9O2gubz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFpnKHRoaXMuRGIubyhhKSx0aGlzLlcpfTtmdW5jdGlvbiAkZyhhLGIsYyl7dGhpcy50eXBlPWFnO3RoaXMuc291cmNlPWE7dGhpcy5wYXRoPWI7dGhpcy5HYT1jfSRnLnByb3RvdHlwZS5NYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wYXRoLmUoKT9uZXcgJGcodGhpcy5zb3VyY2UsVSx0aGlzLkdhLksoYSkpOm5ldyAkZyh0aGlzLnNvdXJjZSxUKHRoaXMucGF0aCksdGhpcy5HYSl9OyRnLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBvdmVyd3JpdGU6IFwiK3RoaXMuR2EudG9TdHJpbmcoKStcIilcIn07ZnVuY3Rpb24gYWgoYSxiKXt0aGlzLnR5cGU9Z2c7dGhpcy5zb3VyY2U9Ymg7dGhpcy5wYXRoPWE7dGhpcy5OZT1ifWFoLnByb3RvdHlwZS5NYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGguZSgpP3RoaXM6bmV3IGFoKFQodGhpcy5wYXRoKSx0aGlzLk5lKX07YWgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIGFjayB3cml0ZSByZXZlcnQ9XCIrdGhpcy5OZStcIilcIn07ZnVuY3Rpb24gY2goYSxiKXt0aGlzLnR5cGU9aWc7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yn1jaC5wcm90b3R5cGUuTWM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRoLmUoKT9uZXcgY2godGhpcy5zb3VyY2UsVSk6bmV3IGNoKHRoaXMuc291cmNlLFQodGhpcy5wYXRoKSl9O2NoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBsaXN0ZW5fY29tcGxldGUpXCJ9O2Z1bmN0aW9uIGRoKGEsYixjKXt0aGlzLnR5cGU9ZGc7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLmNoaWxkcmVuPWN9ZGgucHJvdG90eXBlLk1jPWZ1bmN0aW9uKGEpe2lmKHRoaXMucGF0aC5lKCkpcmV0dXJuIGE9dGhpcy5jaGlsZHJlbi5zdWJ0cmVlKG5ldyBTKGEpKSxhLmUoKT9udWxsOmEudmFsdWU/bmV3ICRnKHRoaXMuc291cmNlLFUsYS52YWx1ZSk6bmV3IGRoKHRoaXMuc291cmNlLFUsYSk7eShJKHRoaXMucGF0aCk9PT1hLFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7cmV0dXJuIG5ldyBkaCh0aGlzLnNvdXJjZSxUKHRoaXMucGF0aCksdGhpcy5jaGlsZHJlbil9O2RoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBtZXJnZTogXCIrdGhpcy5jaGlsZHJlbi50b1N0cmluZygpK1wiKVwifTt2YXIgYWc9MCxkZz0xLGdnPTIsaWc9MztmdW5jdGlvbiBlaChhLGIsYyxkKXt0aGlzLm1lPWE7dGhpcy5kZj1iO3RoaXMueWI9Yzt0aGlzLlNlPWQ7eSghZHx8YixcIlRhZ2dlZCBxdWVyaWVzIG11c3QgYmUgZnJvbSBzZXJ2ZXIuXCIpfXZhciBiaD1uZXcgZWgoITAsITEsbnVsbCwhMSksZmg9bmV3IGVoKCExLCEwLG51bGwsITEpO2VoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1lP1widXNlclwiOnRoaXMuU2U/XCJzZXJ2ZXIocXVlcnlJRD1cIit0aGlzLnliK1wiKVwiOlwic2VydmVyXCJ9O2Z1bmN0aW9uIGdoKGEpe3RoaXMubmE9bmc7dGhpcy54Yj1uZXcgVmc7dGhpcy5XYz17fTt0aGlzLmJjPXt9O3RoaXMuRmM9YX1mdW5jdGlvbiBoaChhLGIsYyxkLGUpe3ZhciBmPWEueGIsZz1lO3koZD5mLkVjLFwiU3RhY2tpbmcgYW4gb2xkZXIgd3JpdGUgb24gdG9wIG9mIG5ld2VyIG9uZXNcIik7bShnKXx8KGc9ITApO2Yud2EucHVzaCh7cGF0aDpiLEdhOmMsWmQ6ZCx2aXNpYmxlOmd9KTtnJiYoZi5UPVBnKGYuVCxiLGMpKTtmLkVjPWQ7cmV0dXJuIGU/aWgoYSxuZXcgJGcoYmgsYixjKSk6W119ZnVuY3Rpb24gamgoYSxiLGMsZCl7dmFyIGU9YS54Yjt5KGQ+ZS5FYyxcIlN0YWNraW5nIGFuIG9sZGVyIG1lcmdlIG9uIHRvcCBvZiBuZXdlciBvbmVzXCIpO2Uud2EucHVzaCh7cGF0aDpiLGNoaWxkcmVuOmMsWmQ6ZCx2aXNpYmxlOiEwfSk7ZS5UPVFnKGUuVCxiLGMpO2UuRWM9ZDtjPXlnKGMpO3JldHVybiBpaChhLG5ldyBkaChiaCxiLGMpKX1cbmZ1bmN0aW9uIGtoKGEsYixjKXtjPWN8fCExO2I9YS54Yi5HZChiKTtyZXR1cm4gbnVsbD09Yj9bXTppaChhLG5ldyBhaChiLGMpKX1mdW5jdGlvbiBsaChhLGIsYyl7Yz15ZyhjKTtyZXR1cm4gaWgoYSxuZXcgZGgoZmgsYixjKSl9ZnVuY3Rpb24gbWgoYSxiLGMsZCl7ZD1PZChhLldjLFwiX1wiK2QpO2lmKG51bGwhPWQpe3ZhciBlPW5oKGQpO2Q9ZS5wYXRoO2U9ZS55YjtiPVYoZCxiKTtjPW5ldyAkZyhuZXcgZWgoITEsITAsZSwhMCksYixjKTtyZXR1cm4gb2goYSxkLGMpfXJldHVybltdfWZ1bmN0aW9uIHBoKGEsYixjLGQpe2lmKGQ9T2QoYS5XYyxcIl9cIitkKSl7dmFyIGU9bmgoZCk7ZD1lLnBhdGg7ZT1lLnliO2I9VihkLGIpO2M9eWcoYyk7Yz1uZXcgZGgobmV3IGVoKCExLCEwLGUsITApLGIsYyk7cmV0dXJuIG9oKGEsZCxjKX1yZXR1cm5bXX1cbmdoLnByb3RvdHlwZS5HYj1mdW5jdGlvbihhLGIpe3ZhciBjPWEucGF0aCxkPW51bGwsZT0hMTtGZyh0aGlzLm5hLGMsZnVuY3Rpb24oYSxiKXt2YXIgZj1WKGEsYyk7ZD1iLmJiKGYpO2U9ZXx8bnVsbCE9S2coYik7cmV0dXJuIWR9KTt2YXIgZj10aGlzLm5hLmdldChjKTtmPyhlPWV8fG51bGwhPUtnKGYpLGQ9ZHx8Zi5iYihVKSk6KGY9bmV3IEpnLHRoaXMubmE9dGhpcy5uYS5zZXQoYyxmKSk7dmFyIGc7bnVsbCE9ZD9nPSEwOihnPSExLGQ9TSxJZyh0aGlzLm5hLnN1YnRyZWUoYyksZnVuY3Rpb24oYSxiKXt2YXIgYz1iLmJiKFUpO2MmJihkPWQuUChhLGMpKX0pKTt2YXIgaz1udWxsIT1NZyhmLGEpO2lmKCFrJiYhSmMoYS5uKSl7dmFyIGw9cWgoYSk7eSghKGwgaW4gdGhpcy5iYyksXCJWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZ1wiKTt2YXIgbj1yaCsrO3RoaXMuYmNbbF09bjt0aGlzLldjW1wiX1wiK25dPWx9Zz1mLkdiKGEsYixuZXcgWmcoYyx0aGlzLnhiKSxcbmQsZyk7a3x8ZXx8KGY9TWcoZixhKSxnPWcuY29uY2F0KHNoKHRoaXMsYSxmKSkpO3JldHVybiBnfTtcbmdoLnByb3RvdHlwZS5nYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5wYXRoLGU9dGhpcy5uYS5nZXQoZCksZj1bXTtpZihlJiYoXCJkZWZhdWx0XCI9PT1hLkZhKCl8fG51bGwhPU1nKGUsYSkpKXtmPWUuZ2IoYSxiLGMpO2UuZSgpJiYodGhpcy5uYT10aGlzLm5hLnJlbW92ZShkKSk7ZT1mLnJnO2Y9Zi5WZjtiPS0xIT09TmEoZSxmdW5jdGlvbihhKXtyZXR1cm4gSmMoYS5uKX0pO3ZhciBnPURnKHRoaXMubmEsZCxmdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1LZyhiKX0pO2lmKGImJiFnJiYoZD10aGlzLm5hLnN1YnRyZWUoZCksIWQuZSgpKSlmb3IodmFyIGQ9dGgoZCksaz0wO2s8ZC5sZW5ndGg7KytrKXt2YXIgbD1kW2tdLG49bC5WLGw9dWgodGhpcyxsKTt0aGlzLkZjLlBlKG4sdmgodGhpcyxuKSxsLm1kLGwuSCl9aWYoIWcmJjA8ZS5sZW5ndGgmJiFjKWlmKGIpdGhpcy5GYy5RZChhLG51bGwpO2Vsc2V7dmFyIHU9dGhpcztIYShlLGZ1bmN0aW9uKGEpe2EuRmEoKTt2YXIgYj11LmJjW3FoKGEpXTtcbnUuRmMuUWQoYSxiKX0pfXdoKHRoaXMsZSl9cmV0dXJuIGZ9O2doLnByb3RvdHlwZS5wYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMueGIsZD1EZyh0aGlzLm5hLGEsZnVuY3Rpb24oYixjKXt2YXIgZD1WKGIsYSk7aWYoZD1jLmJiKGQpKXJldHVybiBkfSk7cmV0dXJuIGMucGEoYSxkLGIsITApfTtmdW5jdGlvbiB0aChhKXtyZXR1cm4gQmcoYSxmdW5jdGlvbihhLGMsZCl7aWYoYyYmbnVsbCE9S2coYykpcmV0dXJuW0tnKGMpXTt2YXIgZT1bXTtjJiYoZT1MZyhjKSk7QShkLGZ1bmN0aW9uKGEpe2U9ZS5jb25jYXQoYSl9KTtyZXR1cm4gZX0pfWZ1bmN0aW9uIHdoKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDsrK2Mpe3ZhciBkPWJbY107aWYoIUpjKGQubikpe3ZhciBkPXFoKGQpLGU9YS5iY1tkXTtkZWxldGUgYS5iY1tkXTtkZWxldGUgYS5XY1tcIl9cIitlXX19fVxuZnVuY3Rpb24gc2goYSxiLGMpe3ZhciBkPWIucGF0aCxlPXZoKGEsYik7Yz11aChhLGMpO2I9YS5GYy5QZShiLGUsYy5tZCxjLkgpO2Q9YS5uYS5zdWJ0cmVlKGQpO2lmKGUpeShudWxsPT1LZyhkLnZhbHVlKSxcIklmIHdlJ3JlIGFkZGluZyBhIHF1ZXJ5LCBpdCBzaG91bGRuJ3QgYmUgc2hhZG93ZWRcIik7ZWxzZSBmb3IoZT1CZyhkLGZ1bmN0aW9uKGEsYixjKXtpZighYS5lKCkmJmImJm51bGwhPUtnKGIpKXJldHVyblt0ZyhLZyhiKSldO3ZhciBkPVtdO2ImJihkPWQuY29uY2F0KEphKExnKGIpLGZ1bmN0aW9uKGEpe3JldHVybiBhLlZ9KSkpO0EoYyxmdW5jdGlvbihhKXtkPWQuY29uY2F0KGEpfSk7cmV0dXJuIGR9KSxkPTA7ZDxlLmxlbmd0aDsrK2QpYz1lW2RdLGEuRmMuUWQoYyx2aChhLGMpKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHVoKGEsYil7dmFyIGM9Yi5WLGQ9dmgoYSxjKTtyZXR1cm57bWQ6ZnVuY3Rpb24oKXtyZXR1cm4oYi51KCl8fE0pLmhhc2goKX0sSDpmdW5jdGlvbihiLGYpe2lmKFwib2tcIj09PWIpe2lmKGYmJlwib2JqZWN0XCI9PT10eXBlb2YgZiYmcyhmLFwid1wiKSl7dmFyIGc9dChmLFwid1wiKTtlYShnKSYmMDw9R2EoZyxcIm5vX2luZGV4XCIpJiZ6KFwiVXNpbmcgYW4gdW5zcGVjaWZpZWQgaW5kZXguIENvbnNpZGVyIGFkZGluZyBcIisoJ1wiLmluZGV4T25cIjogXCInK2Mubi5nLnRvU3RyaW5nKCkrJ1wiJykrXCIgYXQgXCIrYy5wYXRoLnRvU3RyaW5nKCkrXCIgdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXCIpfWlmKGQpe3ZhciBrPWMucGF0aDtpZihnPU9kKGEuV2MsXCJfXCIrZCkpdmFyIGw9bmgoZyksZz1sLnBhdGgsbD1sLnliLGs9VihnLGspLGs9bmV3IGNoKG5ldyBlaCghMSwhMCxsLCEwKSxrKSxnPW9oKGEsZyxrKTtlbHNlIGc9W119ZWxzZSBnPWloKGEsbmV3IGNoKGZoLFxuYy5wYXRoKSk7cmV0dXJuIGd9Zz1cIlVua25vd24gRXJyb3JcIjtcInRvb19iaWdcIj09PWI/Zz1cIlRoZSBkYXRhIHJlcXVlc3RlZCBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgdGhhdCBjYW4gYmUgYWNjZXNzZWQgd2l0aCBhIHNpbmdsZSByZXF1ZXN0LlwiOlwicGVybWlzc2lvbl9kZW5pZWRcIj09Yj9nPVwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiOlwidW5hdmFpbGFibGVcIj09YiYmKGc9XCJUaGUgc2VydmljZSBpcyB1bmF2YWlsYWJsZVwiKTtnPUVycm9yKGIrXCI6IFwiK2cpO2cuY29kZT1iLnRvVXBwZXJDYXNlKCk7cmV0dXJuIGEuZ2IoYyxudWxsLGcpfX19ZnVuY3Rpb24gcWgoYSl7cmV0dXJuIGEucGF0aC50b1N0cmluZygpK1wiJFwiK2EuRmEoKX1cbmZ1bmN0aW9uIG5oKGEpe3ZhciBiPWEuaW5kZXhPZihcIiRcIik7eSgtMSE9PWImJmI8YS5sZW5ndGgtMSxcIkJhZCBxdWVyeUtleS5cIik7cmV0dXJue3liOmEuc3Vic3RyKGIrMSkscGF0aDpuZXcgUyhhLnN1YnN0cigwLGIpKX19ZnVuY3Rpb24gdmgoYSxiKXt2YXIgYz1xaChiKTtyZXR1cm4gdChhLmJjLGMpfXZhciByaD0xO2Z1bmN0aW9uIG9oKGEsYixjKXt2YXIgZD1hLm5hLmdldChiKTt5KGQsXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO3JldHVybiBkLllhKGMsbmV3IFpnKGIsYS54YiksbnVsbCl9ZnVuY3Rpb24gaWgoYSxiKXtyZXR1cm4geGgoYSxiLGEubmEsbnVsbCxuZXcgWmcoVSxhLnhiKSl9XG5mdW5jdGlvbiB4aChhLGIsYyxkLGUpe2lmKGIucGF0aC5lKCkpcmV0dXJuIHloKGEsYixjLGQsZSk7dmFyIGY9Yy5nZXQoVSk7bnVsbD09ZCYmbnVsbCE9ZiYmKGQ9Zi5iYihVKSk7dmFyIGc9W10saz1JKGIucGF0aCksbD1iLk1jKGspO2lmKChjPWMuY2hpbGRyZW4uZ2V0KGspKSYmbCl2YXIgbj1kP2QuSyhrKTpudWxsLGs9ZS5vKGspLGc9Zy5jb25jYXQoeGgoYSxsLGMsbixrKSk7ZiYmKGc9Zy5jb25jYXQoZi5ZYShiLGUsZCkpKTtyZXR1cm4gZ31mdW5jdGlvbiB5aChhLGIsYyxkLGUpe3ZhciBmPWMuZ2V0KFUpO251bGw9PWQmJm51bGwhPWYmJihkPWYuYmIoVSkpO3ZhciBnPVtdO2MuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYyxmKXt2YXIgbj1kP2QuSyhjKTpudWxsLHU9ZS5vKGMpLHg9Yi5NYyhjKTt4JiYoZz1nLmNvbmNhdCh5aChhLHgsZixuLHUpKSl9KTtmJiYoZz1nLmNvbmNhdChmLllhKGIsZSxkKSkpO3JldHVybiBnfTtmdW5jdGlvbiB6aChhKXt0aGlzLk89YTt0aGlzLlJhPVhkKGEpO3RoaXMuJD1uZXcgZGY7dGhpcy52ZD0xO3RoaXMuUz1uZXcgSmUodGhpcy5PLHEodGhpcy55ZCx0aGlzKSxxKHRoaXMud2QsdGhpcykscSh0aGlzLkhlLHRoaXMpKTt0aGlzLnpnPVlkKGEscShmdW5jdGlvbigpe3JldHVybiBuZXcgVWQodGhpcy5SYSx0aGlzLlMpfSx0aGlzKSk7dGhpcy5sYz1uZXcgVGM7dGhpcy5zZT1uZXcgY2Y7dmFyIGI9dGhpczt0aGlzLnFkPW5ldyBnaCh7UGU6ZnVuY3Rpb24oYSxkLGUsZil7ZD1bXTtlPWIuc2UuaihhLnBhdGgpO2UuZSgpfHwoZD1paChiLnFkLG5ldyAkZyhmaCxhLnBhdGgsZSkpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmKFwib2tcIil9LDApKTtyZXR1cm4gZH0sUWQ6YmF9KTtBaCh0aGlzLFwiY29ubmVjdGVkXCIsITEpO3RoaXMuZ2E9bmV3ICRlO3RoaXMuUT1uZXcgRmYoYSxxKHRoaXMuUy5RLHRoaXMuUykscSh0aGlzLlMuVWUsdGhpcy5TKSxxKHRoaXMuRWUsdGhpcykpO3RoaXMuZ2Q9XG4wO3RoaXMudGU9bnVsbDt0aGlzLk49bmV3IGdoKHtQZTpmdW5jdGlvbihhLGQsZSxmKXtOZShiLlMsYSxlLGQsZnVuY3Rpb24oZCxlKXt2YXIgbD1mKGQsZSk7aGYoYi4kLGEucGF0aCxsKX0pO3JldHVybltdfSxRZDpmdW5jdGlvbihhLGQpe3ZhciBlPWIuUyxmPWEucGF0aC50b1N0cmluZygpLGc9YS5GYSgpO2UuZihcIlVubGlzdGVuIGNhbGxlZCBmb3IgXCIrZitcIiBcIitnKTtpZihQZShlLGYsZykmJmUuamEpe3ZhciBrPUljKGEubik7ZS5mKFwiVW5saXN0ZW4gb24gXCIrZitcIiBmb3IgXCIrZyk7Zj17cDpmfTtkJiYoZi5xPWssZi50PWQpO2UuQ2EoXCJuXCIsZil9fX0pfWg9emgucHJvdG90eXBlO2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5PLkFiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrdGhpcy5PLmhvc3R9O2gubmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLk8udGJ9O1xuZnVuY3Rpb24gQmgoYSl7YT1hLnNlLmoobmV3IFMoXCIuaW5mby9zZXJ2ZXJUaW1lT2Zmc2V0XCIpKS5JKCl8fDA7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCkrYX1mdW5jdGlvbiBDaChhKXthPWE9e3RpbWVzdGFtcDpCaChhKX07YS50aW1lc3RhbXA9YS50aW1lc3RhbXB8fChuZXcgRGF0ZSkuZ2V0VGltZSgpO3JldHVybiBhfWgueWQ9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5nZCsrO3ZhciBlPW5ldyBTKGEpO2I9dGhpcy50ZT90aGlzLnRlKGEsYik6YjthPVtdO2Q/Yz8oYj10ZChiLGZ1bmN0aW9uKGEpe3JldHVybiBPKGEpfSksYT1waCh0aGlzLk4sZSxiLGQpKTooYj1PKGIpLGE9bWgodGhpcy5OLGUsYixkKSk6Yz8oZD10ZChiLGZ1bmN0aW9uKGEpe3JldHVybiBPKGEpfSksYT1saCh0aGlzLk4sZSxkKSk6KGQ9TyhiKSxhPWloKHRoaXMuTixuZXcgJGcoZmgsZSxkKSkpO2Q9ZTswPGEubGVuZ3RoJiYoZD1EaCh0aGlzLGUpKTtoZih0aGlzLiQsZCxhKX07XG5oLndkPWZ1bmN0aW9uKGEpe0FoKHRoaXMsXCJjb25uZWN0ZWRcIixhKTshMT09PWEmJkVoKHRoaXMpfTtoLkhlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7emIoYSxmdW5jdGlvbihhLGQpe0FoKGIsZCxhKX0pfTtoLkVlPWZ1bmN0aW9uKGEpe0FoKHRoaXMsXCJhdXRoZW50aWNhdGVkXCIsYSl9O2Z1bmN0aW9uIEFoKGEsYixjKXtiPW5ldyBTKFwiLy5pbmZvL1wiK2IpO2M9TyhjKTt2YXIgZD1hLnNlO2QuSmQ9ZC5KZC5DKGIsYyk7Yz1paChhLnFkLG5ldyAkZyhmaCxiLGMpKTtoZihhLiQsYixjKX1cbmguQmI9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5mKFwic2V0XCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmIsSGc6Y30pO3ZhciBlPUNoKHRoaXMpO2I9TyhiLGMpO3ZhciBlPVVmKGIsZSksZj10aGlzLnZkKyssZT1oaCh0aGlzLk4sYSxlLGYsITApO2VmKHRoaXMuJCxlKTt2YXIgZz10aGlzO3RoaXMuUy5wdXQoYS50b1N0cmluZygpLGIuSSghMCksZnVuY3Rpb24oYixjKXt2YXIgZT1cIm9rXCI9PT1iO2V8fHooXCJzZXQgYXQgXCIrYStcIiBmYWlsZWQ6IFwiK2IpO2U9a2goZy5OLGYsIWUpO2hmKGcuJCxhLGUpO0ZoKGQsYixjKX0pO2U9R2godGhpcyxhKTtEaCh0aGlzLGUpO2hmKHRoaXMuJCxlLFtdKX07XG5oLnVwZGF0ZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5mKFwidXBkYXRlXCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmJ9KTt2YXIgZD0hMCxlPUNoKHRoaXMpLGY9e307QShiLGZ1bmN0aW9uKGEsYil7ZD0hMTt2YXIgYz1PKGEpO2ZbYl09VWYoYyxlKX0pO2lmKGQpaGIoXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpLEZoKGMsXCJva1wiKTtlbHNle3ZhciBnPXRoaXMudmQrKyxrPWpoKHRoaXMuTixhLGYsZyk7ZWYodGhpcy4kLGspO3ZhciBsPXRoaXM7VmUodGhpcy5TLGEudG9TdHJpbmcoKSxiLGZ1bmN0aW9uKGIsZCl7eShcIm9rXCI9PT1ifHxcInBlcm1pc3Npb25fZGVuaWVkXCI9PT1iLFwibWVyZ2UgYXQgXCIrYStcIiBmYWlsZWQuXCIpO3ZhciBlPVwib2tcIj09PWI7ZXx8eihcInVwZGF0ZSBhdCBcIithK1wiIGZhaWxlZDogXCIrYik7dmFyIGU9a2gobC5OLGcsIWUpLGY9YTswPGUubGVuZ3RoJiYoZj1EaChsLGEpKTtoZihsLiQsZixlKTtGaChjLGIsZCl9KTtcbmI9R2godGhpcyxhKTtEaCh0aGlzLGIpO2hmKHRoaXMuJCxhLFtdKX19O2Z1bmN0aW9uIEVoKGEpe2EuZihcIm9uRGlzY29ubmVjdEV2ZW50c1wiKTt2YXIgYj1DaChhKSxjPVtdO2JmKFRmKGEuZ2EsYiksVSxmdW5jdGlvbihiLGUpe2M9Yy5jb25jYXQoaWgoYS5OLG5ldyAkZyhmaCxiLGUpKSk7dmFyIGY9R2goYSxiKTtEaChhLGYpfSk7YS5nYT1uZXcgJGU7aGYoYS4kLFUsYyl9aC5GZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5TLkZlKGEudG9TdHJpbmcoKSxmdW5jdGlvbihkLGUpe1wib2tcIj09PWQmJmFmKGMuZ2EsYSk7RmgoYixkLGUpfSl9O2Z1bmN0aW9uIEhoKGEsYixjLGQpe3ZhciBlPU8oYyk7UmUoYS5TLGIudG9TdHJpbmcoKSxlLkkoITApLGZ1bmN0aW9uKGMsZyl7XCJva1wiPT09YyYmYS5nYS5kYyhiLGUpO0ZoKGQsYyxnKX0pfVxuZnVuY3Rpb24gSWgoYSxiLGMsZCxlKXt2YXIgZj1PKGMsZCk7UmUoYS5TLGIudG9TdHJpbmcoKSxmLkkoITApLGZ1bmN0aW9uKGMsZCl7XCJva1wiPT09YyYmYS5nYS5kYyhiLGYpO0ZoKGUsYyxkKX0pfWZ1bmN0aW9uIEpoKGEsYixjLGQpe3ZhciBlPSEwLGY7Zm9yKGYgaW4gYyllPSExO2U/KGhiKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKSxGaChkLFwib2tcIikpOlRlKGEuUyxiLnRvU3RyaW5nKCksYyxmdW5jdGlvbihlLGYpe2lmKFwib2tcIj09PWUpZm9yKHZhciBsIGluIGMpe3ZhciBuPU8oY1tsXSk7YS5nYS5kYyhiLm8obCksbil9RmgoZCxlLGYpfSl9ZnVuY3Rpb24gT2MoYSxiLGMpe2M9XCIuaW5mb1wiPT09SShiLnBhdGgpP2EucWQuR2IoYixjKTphLk4uR2IoYixjKTtQYyhhLiQsYi5wYXRoLGMpfWgucGI9ZnVuY3Rpb24oKXt0aGlzLlMucGIoKX07aC5oYz1mdW5jdGlvbigpe3RoaXMuUy5oYygpfTtcbmguUWU9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXthPyh0aGlzLlBkfHwodGhpcy5QZD1uZXcgVGQodGhpcy5SYSkpLGE9dGhpcy5QZC5nZXQoKSk6YT10aGlzLlJhLmdldCgpO3ZhciBiPUthKEtkKGEpLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGgubWF4KGIubGVuZ3RoLGEpfSwwKSxjO2ZvcihjIGluIGEpe2Zvcih2YXIgZD1hW2NdLGU9Yy5sZW5ndGg7ZTxiKzI7ZSsrKWMrPVwiIFwiO2NvbnNvbGUubG9nKGMrZCl9fX07aC5SZT1mdW5jdGlvbihhKXtTZCh0aGlzLlJhLGEpO3RoaXMuemcuemZbYV09ITB9O2guZj1mdW5jdGlvbihhKXtoYihcInI6XCIrdGhpcy5TLmlkK1wiOlwiLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIEZoKGEsYixjKXthJiZDYihmdW5jdGlvbigpe2lmKFwib2tcIj09YilhKG51bGwpO2Vsc2V7dmFyIGQ9KGJ8fFwiZXJyb3JcIikudG9VcHBlckNhc2UoKSxlPWQ7YyYmKGUrPVwiOiBcIitjKTtlPUVycm9yKGUpO2UuY29kZT1kO2EoZSl9fSl9O2Z1bmN0aW9uIEtoKGEsYixjLGQsZSl7ZnVuY3Rpb24gZigpe31hLmYoXCJ0cmFuc2FjdGlvbiBvbiBcIitiKTt2YXIgZz1uZXcgUihhLGIpO2cudmIoXCJ2YWx1ZVwiLGYpO2M9e3BhdGg6Yix1cGRhdGU6YyxIOmQsc3RhdHVzOm51bGwscWY6ZWIoKSxWZTplLHhmOjAsWGQ6ZnVuY3Rpb24oKXtnLlpiKFwidmFsdWVcIixmKX0sJGQ6bnVsbCx4YTpudWxsLGRkOm51bGwsZWQ6bnVsbCxmZDpudWxsfTtkPWEuTi5wYShiLHZvaWQgMCl8fE07Yy5kZD1kO2Q9Yy51cGRhdGUoZC5JKCkpO2lmKG0oZCkpe1NiKFwidHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkIFwiLGQpO2Muc3RhdHVzPTE7ZT1VYyhhLmxjLGIpO3ZhciBrPWUuemEoKXx8W107ay5wdXNoKGMpO1ZjKGUsayk7XCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCYmcyhkLFwiLnByaW9yaXR5XCIpPyhrPXQoZCxcIi5wcmlvcml0eVwiKSx5KFFiKGspLFwiSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLlwiKSk6XG5rPShhLk4ucGEoYil8fE0pLkwoKS5JKCk7ZT1DaChhKTtkPU8oZCxrKTtlPVVmKGQsZSk7Yy5lZD1kO2MuZmQ9ZTtjLnhhPWEudmQrKztjPWhoKGEuTixiLGUsYy54YSxjLlZlKTtoZihhLiQsYixjKTtMaChhKX1lbHNlIGMuWGQoKSxjLmVkPW51bGwsYy5mZD1udWxsLGMuSCYmKGE9bmV3IEQoYy5kZCxuZXcgUihhLGMucGF0aCksTCksYy5IKG51bGwsITEsYSkpfWZ1bmN0aW9uIExoKGEsYil7dmFyIGM9Ynx8YS5sYztifHxNaChhLGMpO2lmKG51bGwhPT1jLnphKCkpe3ZhciBkPU5oKGEsYyk7eSgwPGQubGVuZ3RoLFwiU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZVwiKTtMYShkLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5zdGF0dXN9KSYmT2goYSxjLnBhdGgoKSxkKX1lbHNlIGMubGQoKSYmYy5VKGZ1bmN0aW9uKGIpe0xoKGEsYil9KX1cbmZ1bmN0aW9uIE9oKGEsYixjKXtmb3IodmFyIGQ9SmEoYyxmdW5jdGlvbihhKXtyZXR1cm4gYS54YX0pLGU9YS5OLnBhKGIsZCl8fE0sZD1lLGU9ZS5oYXNoKCksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1jW2ZdO3koMT09PWcuc3RhdHVzLFwidHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLlwiKTtnLnN0YXR1cz0yO2cueGYrKzt2YXIgaz1WKGIsZy5wYXRoKSxkPWQuQyhrLGcuZWQpfWQ9ZC5JKCEwKTthLlMucHV0KGIudG9TdHJpbmcoKSxkLGZ1bmN0aW9uKGQpe2EuZihcInRyYW5zYWN0aW9uIHB1dCByZXNwb25zZVwiLHtwYXRoOmIudG9TdHJpbmcoKSxzdGF0dXM6ZH0pO3ZhciBlPVtdO2lmKFwib2tcIj09PWQpe2Q9W107Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKyl7Y1tmXS5zdGF0dXM9MztlPWUuY29uY2F0KGtoKGEuTixjW2ZdLnhhKSk7aWYoY1tmXS5IKXt2YXIgZz1jW2ZdLmZkLGs9bmV3IFIoYSxjW2ZdLnBhdGgpO2QucHVzaChxKGNbZl0uSCxcbm51bGwsbnVsbCwhMCxuZXcgRChnLGssTCkpKX1jW2ZdLlhkKCl9TWgoYSxVYyhhLmxjLGIpKTtMaChhKTtoZihhLiQsYixlKTtmb3IoZj0wO2Y8ZC5sZW5ndGg7ZisrKUNiKGRbZl0pfWVsc2V7aWYoXCJkYXRhc3RhbGVcIj09PWQpZm9yKGY9MDtmPGMubGVuZ3RoO2YrKyljW2ZdLnN0YXR1cz00PT09Y1tmXS5zdGF0dXM/NToxO2Vsc2UgZm9yKHooXCJ0cmFuc2FjdGlvbiBhdCBcIitiLnRvU3RyaW5nKCkrXCIgZmFpbGVkOiBcIitkKSxmPTA7ZjxjLmxlbmd0aDtmKyspY1tmXS5zdGF0dXM9NSxjW2ZdLiRkPWQ7RGgoYSxiKX19LGUpfWZ1bmN0aW9uIERoKGEsYil7dmFyIGM9UGgoYSxiKSxkPWMucGF0aCgpLGM9TmgoYSxjKTtRaChhLGMsZCk7cmV0dXJuIGR9XG5mdW5jdGlvbiBRaChhLGIsYyl7aWYoMCE9PWIubGVuZ3RoKXtmb3IodmFyIGQ9W10sZT1bXSxmPUphKGIsZnVuY3Rpb24oYSl7cmV0dXJuIGEueGF9KSxnPTA7ZzxiLmxlbmd0aDtnKyspe3ZhciBrPWJbZ10sbD1WKGMsay5wYXRoKSxuPSExLHU7eShudWxsIT09bCxcInJlcnVuVHJhbnNhY3Rpb25zVW5kZXJOb2RlXzogcmVsYXRpdmVQYXRoIHNob3VsZCBub3QgYmUgbnVsbC5cIik7aWYoNT09PWsuc3RhdHVzKW49ITAsdT1rLiRkLGU9ZS5jb25jYXQoa2goYS5OLGsueGEsITApKTtlbHNlIGlmKDE9PT1rLnN0YXR1cylpZigyNTw9ay54ZiluPSEwLHU9XCJtYXhyZXRyeVwiLGU9ZS5jb25jYXQoa2goYS5OLGsueGEsITApKTtlbHNle3ZhciB4PWEuTi5wYShrLnBhdGgsZil8fE07ay5kZD14O3ZhciBFPWJbZ10udXBkYXRlKHguSSgpKTttKEUpPyhTYihcInRyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCBcIixFKSxsPU8oRSksXCJvYmplY3RcIj09PXR5cGVvZiBFJiZudWxsIT1FJiZzKEUsXG5cIi5wcmlvcml0eVwiKXx8KGw9bC5aKHguTCgpKSkseD1rLnhhLEU9Q2goYSksRT1VZihsLEUpLGsuZWQ9bCxrLmZkPUUsay54YT1hLnZkKyssT2EoZix4KSxlPWUuY29uY2F0KGhoKGEuTixrLnBhdGgsRSxrLnhhLGsuVmUpKSxlPWUuY29uY2F0KGtoKGEuTix4LCEwKSkpOihuPSEwLHU9XCJub2RhdGFcIixlPWUuY29uY2F0KGtoKGEuTixrLnhhLCEwKSkpfWhmKGEuJCxjLGUpO2U9W107biYmKGJbZ10uc3RhdHVzPTMsc2V0VGltZW91dChiW2ddLlhkLE1hdGguZmxvb3IoMCkpLGJbZ10uSCYmKFwibm9kYXRhXCI9PT11PyhrPW5ldyBSKGEsYltnXS5wYXRoKSxkLnB1c2gocShiW2ddLkgsbnVsbCxudWxsLCExLG5ldyBEKGJbZ10uZGQsayxMKSkpKTpkLnB1c2gocShiW2ddLkgsbnVsbCxFcnJvcih1KSwhMSxudWxsKSkpKX1NaChhLGEubGMpO2ZvcihnPTA7ZzxkLmxlbmd0aDtnKyspQ2IoZFtnXSk7TGgoYSl9fVxuZnVuY3Rpb24gUGgoYSxiKXtmb3IodmFyIGMsZD1hLmxjO251bGwhPT0oYz1JKGIpKSYmbnVsbD09PWQuemEoKTspZD1VYyhkLGMpLGI9VChiKTtyZXR1cm4gZH1mdW5jdGlvbiBOaChhLGIpe3ZhciBjPVtdO1JoKGEsYixjKTtjLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5xZi1iLnFmfSk7cmV0dXJuIGN9ZnVuY3Rpb24gUmgoYSxiLGMpe3ZhciBkPWIuemEoKTtpZihudWxsIT09ZClmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyljLnB1c2goZFtlXSk7Yi5VKGZ1bmN0aW9uKGIpe1JoKGEsYixjKX0pfWZ1bmN0aW9uIE1oKGEsYil7dmFyIGM9Yi56YSgpO2lmKGMpe2Zvcih2YXIgZD0wLGU9MDtlPGMubGVuZ3RoO2UrKykzIT09Y1tlXS5zdGF0dXMmJihjW2RdPWNbZV0sZCsrKTtjLmxlbmd0aD1kO1ZjKGIsMDxjLmxlbmd0aD9jOm51bGwpfWIuVShmdW5jdGlvbihiKXtNaChhLGIpfSl9XG5mdW5jdGlvbiBHaChhLGIpe3ZhciBjPVBoKGEsYikucGF0aCgpLGQ9VWMoYS5sYyxiKTtZYyhkLGZ1bmN0aW9uKGIpe1NoKGEsYil9KTtTaChhLGQpO1hjKGQsZnVuY3Rpb24oYil7U2goYSxiKX0pO3JldHVybiBjfVxuZnVuY3Rpb24gU2goYSxiKXt2YXIgYz1iLnphKCk7aWYobnVsbCE9PWMpe2Zvcih2YXIgZD1bXSxlPVtdLGY9LTEsZz0wO2c8Yy5sZW5ndGg7ZysrKTQhPT1jW2ddLnN0YXR1cyYmKDI9PT1jW2ddLnN0YXR1cz8oeShmPT09Zy0xLFwiQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS5cIiksZj1nLGNbZ10uc3RhdHVzPTQsY1tnXS4kZD1cInNldFwiKTooeSgxPT09Y1tnXS5zdGF0dXMsXCJVbmV4cGVjdGVkIHRyYW5zYWN0aW9uIHN0YXR1cyBpbiBhYm9ydFwiKSxjW2ddLlhkKCksZT1lLmNvbmNhdChraChhLk4sY1tnXS54YSwhMCkpLGNbZ10uSCYmZC5wdXNoKHEoY1tnXS5ILG51bGwsRXJyb3IoXCJzZXRcIiksITEsbnVsbCkpKSk7LTE9PT1mP1ZjKGIsbnVsbCk6Yy5sZW5ndGg9ZisxO2hmKGEuJCxiLnBhdGgoKSxlKTtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKUNiKGRbZ10pfX07ZnVuY3Rpb24gVGgoKXt0aGlzLmVjPXt9fWNhKFRoKTtUaC5wcm90b3R5cGUucGI9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5lYyl0aGlzLmVjW2FdLnBiKCl9O1RoLnByb3RvdHlwZS5pbnRlcnJ1cHQ9VGgucHJvdG90eXBlLnBiO1RoLnByb3RvdHlwZS5oYz1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLmVjKXRoaXMuZWNbYV0uaGMoKX07VGgucHJvdG90eXBlLnJlc3VtZT1UaC5wcm90b3R5cGUuaGM7ZnVuY3Rpb24gVWgoYSl7dmFyIGI9dGhpczt0aGlzLnJjPWE7dGhpcy5TZD1cIipcIjt4ZigpP3RoaXMuSGM9dGhpcy5vZD1vZigpOih0aGlzLkhjPXdpbmRvdy5vcGVuZXIsdGhpcy5vZD13aW5kb3cpO2lmKCFiLkhjKXRocm93XCJVbmFibGUgdG8gZmluZCByZWxheSBmcmFtZVwiO3BmKHRoaXMub2QsXCJtZXNzYWdlXCIscSh0aGlzLiRiLHRoaXMpKTtwZih0aGlzLm9kLFwibWVzc2FnZVwiLHEodGhpcy5uZix0aGlzKSk7dHJ5e1ZoKHRoaXMse2E6XCJyZWFkeVwifSl9Y2F0Y2goYyl7cGYodGhpcy5IYyxcImxvYWRcIixmdW5jdGlvbigpe1ZoKGIse2E6XCJyZWFkeVwifSl9KX1wZih3aW5kb3csXCJ1bmxvYWRcIixxKHRoaXMuamcsdGhpcykpfWZ1bmN0aW9uIFZoKGEsYil7Yj1yKGIpO3hmKCk/YS5IYy5kb1Bvc3QoYixhLlNkKTphLkhjLnBvc3RNZXNzYWdlKGIsYS5TZCl9XG5VaC5wcm90b3R5cGUuJGI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjO3RyeXtjPXRhKGEuZGF0YSl9Y2F0Y2goZCl7fWMmJlwicmVxdWVzdFwiPT09Yy5hJiYocWYod2luZG93LFwibWVzc2FnZVwiLHRoaXMuJGIpLHRoaXMuU2Q9YS5vcmlnaW4sdGhpcy5yYyYmc2V0VGltZW91dChmdW5jdGlvbigpe2IucmMoYi5TZCxjLmQsZnVuY3Rpb24oYSxjKXtiLk1mPSFjO2IucmM9dm9pZCAwO1ZoKGIse2E6XCJyZXNwb25zZVwiLGQ6YSxmb3JjZUtlZXBXaW5kb3dPcGVuOmN9KX0pfSwwKSl9O1VoLnByb3RvdHlwZS5qZz1mdW5jdGlvbigpe3RyeXtxZih0aGlzLm9kLFwibWVzc2FnZVwiLHRoaXMubmYpfWNhdGNoKGEpe310aGlzLnJjJiYoVmgodGhpcyx7YTpcImVycm9yXCIsZDpcInVua25vd24gY2xvc2VkIHdpbmRvd1wifSksdGhpcy5yYz12b2lkIDApO3RyeXt3aW5kb3cuY2xvc2UoKX1jYXRjaChiKXt9fTtVaC5wcm90b3R5cGUubmY9ZnVuY3Rpb24oYSl7aWYodGhpcy5NZiYmXCJkaWVcIj09PWEuZGF0YSl0cnl7d2luZG93LmNsb3NlKCl9Y2F0Y2goYil7fX07dmFyIFk9e1hmOmZ1bmN0aW9uKCl7amU9YWU9ITB9fTtZLmZvcmNlTG9uZ1BvbGxpbmc9WS5YZjtZLllmPWZ1bmN0aW9uKCl7a2U9ITB9O1kuZm9yY2VXZWJTb2NrZXRzPVkuWWY7WS53Zz1mdW5jdGlvbihhLGIpe2Euay5TLk9lPWJ9O1kuc2V0U2VjdXJpdHlEZWJ1Z0NhbGxiYWNrPVkud2c7WS5RZT1mdW5jdGlvbihhLGIpe2Euay5RZShiKX07WS5zdGF0cz1ZLlFlO1kuUmU9ZnVuY3Rpb24oYSxiKXthLmsuUmUoYil9O1kuc3RhdHNJbmNyZW1lbnRDb3VudGVyPVkuUmU7WS5nZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLmdkfTtZLmRhdGFVcGRhdGVDb3VudD1ZLmdkO1kuYWc9ZnVuY3Rpb24oYSxiKXthLmsudGU9Yn07WS5pbnRlcmNlcHRTZXJ2ZXJEYXRhPVkuYWc7WS5nZz1mdW5jdGlvbihhKXtuZXcgVWgoYSl9O1kub25Qb3B1cE9wZW49WS5nZztZLnVnPWZ1bmN0aW9uKGEpe2pmPWF9O1kuc2V0QXV0aGVudGljYXRpb25TZXJ2ZXI9WS51ZztmdW5jdGlvbiBaKGEsYil7dGhpcy5SYz1hO3RoaXMuRWE9Yn1aLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7RihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuY2FuY2VsXCIsMSxhLCEwKTt0aGlzLlJjLkZlKHRoaXMuRWEsYXx8bnVsbCl9O1oucHJvdG90eXBlLmNhbmNlbD1aLnByb3RvdHlwZS5jYW5jZWw7Wi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe0YoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIix0aGlzLkVhKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsMSxhLCEwKTtIaCh0aGlzLlJjLHRoaXMuRWEsbnVsbCxhKX07Wi5wcm90b3R5cGUucmVtb3ZlPVoucHJvdG90eXBlLnJlbW92ZTtcbloucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwyLGIsITApO0hoKHRoaXMuUmMsdGhpcy5FYSxhLGIpfTtaLnByb3RvdHlwZS5zZXQ9Wi5wcm90b3R5cGUuc2V0O1xuWi5wcm90b3R5cGUuQmI9ZnVuY3Rpb24oYSxiLGMpe0YoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLGEsITEpO1ZiKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMixiKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMyxjLCEwKTtJaCh0aGlzLlJjLHRoaXMuRWEsYSxiLGMpfTtaLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9Wi5wcm90b3R5cGUuQmI7XG5aLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsdGhpcy5FYSk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLDIsYiwhMCk7SmgodGhpcy5SYyxcbnRoaXMuRWEsYSxiKX07Wi5wcm90b3R5cGUudXBkYXRlPVoucHJvdG90eXBlLnVwZGF0ZTt2YXIgJD17fTskLm5jPUplOyQuRGF0YUNvbm5lY3Rpb249JC5uYztKZS5wcm90b3R5cGUueWc9ZnVuY3Rpb24oYSxiKXt0aGlzLkNhKFwicVwiLHtwOmF9LGIpfTskLm5jLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW49JC5uYy5wcm90b3R5cGUueWc7SmUucHJvdG90eXBlLlNmPWZ1bmN0aW9uKGEsYil7dGhpcy5DYShcImVjaG9cIix7ZDphfSxiKX07JC5uYy5wcm90b3R5cGUuZWNobz0kLm5jLnByb3RvdHlwZS5TZjtKZS5wcm90b3R5cGUuaW50ZXJydXB0PUplLnByb3RvdHlwZS5wYjskLkRmPXVlOyQuUmVhbFRpbWVDb25uZWN0aW9uPSQuRGY7dWUucHJvdG90eXBlLnNlbmRSZXF1ZXN0PXVlLnByb3RvdHlwZS5DYTt1ZS5wcm90b3R5cGUuY2xvc2U9dWUucHJvdG90eXBlLmNsb3NlO1xuJC4kZj1mdW5jdGlvbihhKXt2YXIgYj1KZS5wcm90b3R5cGUucHV0O0plLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYyxkLGUsZil7bShmKSYmKGY9YSgpKTtiLmNhbGwodGhpcyxjLGQsZSxmKX07cmV0dXJuIGZ1bmN0aW9uKCl7SmUucHJvdG90eXBlLnB1dD1ifX07JC5oaWphY2tIYXNoPSQuJGY7JC5DZj1BYTskLkNvbm5lY3Rpb25UYXJnZXQ9JC5DZjskLkZhPWZ1bmN0aW9uKGEpe3JldHVybiBhLkZhKCl9OyQucXVlcnlJZGVudGlmaWVyPSQuRmE7JC5iZz1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLlMuQWF9OyQubGlzdGVucz0kLmJnO3ZhciBXaD1mdW5jdGlvbigpe3ZhciBhPTAsYj1bXTtyZXR1cm4gZnVuY3Rpb24oYyl7dmFyIGQ9Yz09PWE7YT1jO2Zvcih2YXIgZT1BcnJheSg4KSxmPTc7MDw9ZjtmLS0pZVtmXT1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYyU2NCksYz1NYXRoLmZsb29yKGMvNjQpO3koMD09PWMsXCJDYW5ub3QgcHVzaCBhdCB0aW1lID09IDBcIik7Yz1lLmpvaW4oXCJcIik7aWYoZCl7Zm9yKGY9MTE7MDw9ZiYmNjM9PT1iW2ZdO2YtLSliW2ZdPTA7YltmXSsrfWVsc2UgZm9yKGY9MDsxMj5mO2YrKyliW2ZdPU1hdGguZmxvb3IoNjQqTWF0aC5yYW5kb20oKSk7Zm9yKGY9MDsxMj5mO2YrKyljKz1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYltmXSk7eSgyMD09PWMubGVuZ3RoLFwiTmV4dFB1c2hJZDogTGVuZ3RoIHNob3VsZCBiZSAyMC5cIik7XG5yZXR1cm4gY319KCk7ZnVuY3Rpb24gUihhLGIpe3ZhciBjLGQsZTtpZihhIGluc3RhbmNlb2YgemgpYz1hLGQ9YjtlbHNle0YoXCJuZXcgRmlyZWJhc2VcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7ZD1yYihhcmd1bWVudHNbMF0pO2M9ZC5BZztcImZpcmViYXNlXCI9PT1kLmRvbWFpbiYmcWIoZC5ob3N0K1wiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWRcIik7Y3x8cWIoXCJDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tXCIpO2QuQWJ8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24mJndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmLTEhPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSYmeihcIkluc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuIFBsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuXCIpO1xuYz1uZXcgQWEoZC5ob3N0LGQuQWIsYyxcIndzXCI9PT1kLnNjaGVtZXx8XCJ3c3NcIj09PWQuc2NoZW1lKTtkPW5ldyBTKGQuUGMpO2U9ZC50b1N0cmluZygpO3ZhciBmOyEoZj0hcChjLmhvc3QpfHwwPT09Yy5ob3N0Lmxlbmd0aHx8IVBiKGMudGIpKSYmKGY9MCE9PWUubGVuZ3RoKSYmKGUmJihlPWUucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sXCIvXCIpKSxmPSEocChlKSYmMCE9PWUubGVuZ3RoJiYhT2IudGVzdChlKSkpO2lmKGYpdGhyb3cgRXJyb3IoRyhcIm5ldyBGaXJlYmFzZVwiLDEsITEpKydtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCB0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO2lmKGIpaWYoYiBpbnN0YW5jZW9mIFRoKWU9YjtlbHNlIGlmKHAoYikpZT1UaC5OYigpLGMuRGQ9YjtlbHNlIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgYSB2YWxpZCBGaXJlYmFzZS5Db250ZXh0IGZvciBzZWNvbmQgYXJndW1lbnQgdG8gbmV3IEZpcmViYXNlKClcIik7XG5lbHNlIGU9VGguTmIoKTtmPWMudG9TdHJpbmcoKTt2YXIgZz10KGUuZWMsZik7Z3x8KGc9bmV3IHpoKGMpLGUuZWNbZl09Zyk7Yz1nfVEuY2FsbCh0aGlzLGMsZCxGYywhMSl9bWEoUixRKTt2YXIgWGg9UixZaD1bXCJGaXJlYmFzZVwiXSxaaD1hYTtZaFswXWluIFpofHwhWmguZXhlY1NjcmlwdHx8WmguZXhlY1NjcmlwdChcInZhciBcIitZaFswXSk7Zm9yKHZhciAkaDtZaC5sZW5ndGgmJigkaD1ZaC5zaGlmdCgpKTspIVloLmxlbmd0aCYmbShYaCk/WmhbJGhdPVhoOlpoPVpoWyRoXT9aaFskaF06WmhbJGhdPXt9O1IucHJvdG90eXBlLm5hbWU9ZnVuY3Rpb24oKXt6KFwiRmlyZWJhc2UubmFtZSgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2Uua2V5KCkgaW5zdGVhZC5cIik7RihcIkZpcmViYXNlLm5hbWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMua2V5KCl9O1IucHJvdG90eXBlLm5hbWU9Ui5wcm90b3R5cGUubmFtZTtcblIucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMucGF0aC5lKCk/bnVsbDpSYyh0aGlzLnBhdGgpfTtSLnByb3RvdHlwZS5rZXk9Ui5wcm90b3R5cGUua2V5O1IucHJvdG90eXBlLm89ZnVuY3Rpb24oYSl7RihcIkZpcmViYXNlLmNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKGdhKGEpKWE9U3RyaW5nKGEpO2Vsc2UgaWYoIShhIGluc3RhbmNlb2YgUykpaWYobnVsbD09PUkodGhpcy5wYXRoKSl7dmFyIGI9YTtiJiYoYj1iLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLFwiL1wiKSk7WWIoXCJGaXJlYmFzZS5jaGlsZFwiLGIpfWVsc2UgWWIoXCJGaXJlYmFzZS5jaGlsZFwiLGEpO3JldHVybiBuZXcgUih0aGlzLmssdGhpcy5wYXRoLm8oYSkpfTtSLnByb3RvdHlwZS5jaGlsZD1SLnByb3RvdHlwZS5vO1xuUi5wcm90b3R5cGUucGFyZW50PWZ1bmN0aW9uKCl7RihcIkZpcmViYXNlLnBhcmVudFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt2YXIgYT10aGlzLnBhdGgucGFyZW50KCk7cmV0dXJuIG51bGw9PT1hP251bGw6bmV3IFIodGhpcy5rLGEpfTtSLnByb3RvdHlwZS5wYXJlbnQ9Ui5wcm90b3R5cGUucGFyZW50O1IucHJvdG90eXBlLnJvb3Q9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzO251bGwhPT1hLnBhcmVudCgpOylhPWEucGFyZW50KCk7cmV0dXJuIGF9O1IucHJvdG90eXBlLnJvb3Q9Ui5wcm90b3R5cGUucm9vdDtcblIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7RihcIkZpcmViYXNlLnRvU3RyaW5nXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3ZhciBhO2lmKG51bGw9PT10aGlzLnBhcmVudCgpKWE9dGhpcy5rLnRvU3RyaW5nKCk7ZWxzZXthPXRoaXMucGFyZW50KCkudG9TdHJpbmcoKStcIi9cIjt2YXIgYj10aGlzLmtleSgpO2ErPWVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYikpfXJldHVybiBhfTtSLnByb3RvdHlwZS50b1N0cmluZz1SLnByb3RvdHlwZS50b1N0cmluZztSLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2Uuc2V0XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uuc2V0XCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5zZXRcIiwyLGIsITApO3RoaXMuay5CYih0aGlzLnBhdGgsYSxudWxsLGJ8fG51bGwpfTtSLnByb3RvdHlwZS5zZXQ9Ui5wcm90b3R5cGUuc2V0O1xuUi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLnVwZGF0ZVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnVwZGF0ZVwiLHRoaXMucGF0aCk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2UudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLnVwZGF0ZVwiLDIsYiwhMCk7aWYocyhhLFwiLnByaW9yaXR5XCIpKXRocm93IEVycm9yKFwidXBkYXRlKCkgZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgdXBkYXRpbmcgLnByaW9yaXR5LlwiKTtcbnRoaXMuay51cGRhdGUodGhpcy5wYXRoLGEsYnx8bnVsbCl9O1IucHJvdG90eXBlLnVwZGF0ZT1SLnByb3RvdHlwZS51cGRhdGU7Ui5wcm90b3R5cGUuQmI9ZnVuY3Rpb24oYSxiLGMpe0YoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLnBhdGgpO1JiKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsYSwhMSk7VmIoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwyLGIpO0goXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwzLGMsITApO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5rZXkoKXx8XCIua2V5c1wiPT09dGhpcy5rZXkoKSl0aHJvd1wiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogXCIrdGhpcy5rZXkoKStcIiBpcyBhIHJlYWQtb25seSBvYmplY3QuXCI7dGhpcy5rLkJiKHRoaXMucGF0aCxhLGIsY3x8bnVsbCl9O1IucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eT1SLnByb3RvdHlwZS5CYjtcblIucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXtGKFwiRmlyZWJhc2UucmVtb3ZlXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2UucmVtb3ZlXCIsdGhpcy5wYXRoKTtIKFwiRmlyZWJhc2UucmVtb3ZlXCIsMSxhLCEwKTt0aGlzLnNldChudWxsLGEpfTtSLnByb3RvdHlwZS5yZW1vdmU9Ui5wcm90b3R5cGUucmVtb3ZlO1xuUi5wcm90b3R5cGUudHJhbnNhY3Rpb249ZnVuY3Rpb24oYSxiLGMpe0YoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDEsMyxhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsdGhpcy5wYXRoKTtIKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwxLGEsITEpO0goXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDIsYiwhMCk7aWYobShjKSYmXCJib29sZWFuXCIhPXR5cGVvZiBjKXRocm93IEVycm9yKEcoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDMsITApK1wibXVzdCBiZSBhIGJvb2xlYW4uXCIpO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5rZXkoKXx8XCIua2V5c1wiPT09dGhpcy5rZXkoKSl0aHJvd1wiRmlyZWJhc2UudHJhbnNhY3Rpb24gZmFpbGVkOiBcIit0aGlzLmtleSgpK1wiIGlzIGEgcmVhZC1vbmx5IG9iamVjdC5cIjtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMmJihjPSEwKTtLaCh0aGlzLmssdGhpcy5wYXRoLGEsYnx8bnVsbCxjKX07Ui5wcm90b3R5cGUudHJhbnNhY3Rpb249Ui5wcm90b3R5cGUudHJhbnNhY3Rpb247XG5SLnByb3RvdHlwZS52Zz1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsdGhpcy5wYXRoKTtWYihcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMSxhKTtIKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwyLGIsITApO3RoaXMuay5CYih0aGlzLnBhdGgubyhcIi5wcmlvcml0eVwiKSxhLG51bGwsYil9O1IucHJvdG90eXBlLnNldFByaW9yaXR5PVIucHJvdG90eXBlLnZnO1IucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UucHVzaFwiLDAsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnB1c2hcIix0aGlzLnBhdGgpO1JiKFwiRmlyZWJhc2UucHVzaFwiLGEsITApO0goXCJGaXJlYmFzZS5wdXNoXCIsMixiLCEwKTt2YXIgYz1CaCh0aGlzLmspLGM9V2goYyksYz10aGlzLm8oYyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiZudWxsIT09YSYmYy5zZXQoYSxiKTtyZXR1cm4gY307XG5SLnByb3RvdHlwZS5wdXNoPVIucHJvdG90eXBlLnB1c2g7Ui5wcm90b3R5cGUuZmI9ZnVuY3Rpb24oKXtaYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdFwiLHRoaXMucGF0aCk7cmV0dXJuIG5ldyBaKHRoaXMuayx0aGlzLnBhdGgpfTtSLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3Q9Ui5wcm90b3R5cGUuZmI7Ui5wcm90b3R5cGUuUT1mdW5jdGlvbihhLGIsYyl7eihcIkZpcmViYXNlUmVmLmF1dGgoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZpcmViYXNlUmVmLmF1dGhXaXRoQ3VzdG9tVG9rZW4oKSBpbnN0ZWFkLlwiKTtGKFwiRmlyZWJhc2UuYXV0aFwiLDEsMyxhcmd1bWVudHMubGVuZ3RoKTskYihcIkZpcmViYXNlLmF1dGhcIixhKTtIKFwiRmlyZWJhc2UuYXV0aFwiLDIsYiwhMCk7SChcIkZpcmViYXNlLmF1dGhcIiwzLGIsITApO0xmKHRoaXMuay5RLGEse30se3JlbWVtYmVyOlwibm9uZVwifSxiLGMpfTtSLnByb3RvdHlwZS5hdXRoPVIucHJvdG90eXBlLlE7XG5SLnByb3RvdHlwZS5VZT1mdW5jdGlvbihhKXtGKFwiRmlyZWJhc2UudW5hdXRoXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS51bmF1dGhcIiwxLGEsITApO01mKHRoaXMuay5RLGEpfTtSLnByb3RvdHlwZS51bmF1dGg9Ui5wcm90b3R5cGUuVWU7Ui5wcm90b3R5cGUubmU9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuZ2V0QXV0aFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5rLlEubmUoKX07Ui5wcm90b3R5cGUuZ2V0QXV0aD1SLnByb3RvdHlwZS5uZTtSLnByb3RvdHlwZS5mZz1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5vbkF1dGhcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7SChcIkZpcmViYXNlLm9uQXV0aFwiLDEsYSwhMSk7TWIoXCJGaXJlYmFzZS5vbkF1dGhcIiwyLGIpO3RoaXMuay5RLnZiKFwiYXV0aF9zdGF0dXNcIixhLGIpfTtSLnByb3RvdHlwZS5vbkF1dGg9Ui5wcm90b3R5cGUuZmc7XG5SLnByb3RvdHlwZS5lZz1mdW5jdGlvbihhLGIpe0YoXCJGaXJlYmFzZS5vZmZBdXRoXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS5vZmZBdXRoXCIsMSxhLCExKTtNYihcIkZpcmViYXNlLm9mZkF1dGhcIiwyLGIpO3RoaXMuay5RLlpiKFwiYXV0aF9zdGF0dXNcIixhLGIpfTtSLnByb3RvdHlwZS5vZmZBdXRoPVIucHJvdG90eXBlLmVnO1IucHJvdG90eXBlLkhmPWZ1bmN0aW9uKGEsYixjKXtGKFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTskYihcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIixhKTtIKFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwzLGMsITApO0xmKHRoaXMuay5RLGEse30sY3x8e30sYil9O1IucHJvdG90eXBlLmF1dGhXaXRoQ3VzdG9tVG9rZW49Ui5wcm90b3R5cGUuSGY7XG5SLnByb3RvdHlwZS5JZj1mdW5jdGlvbihhLGIsYyl7RihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTthYyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDEsYSk7SChcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDMsYywhMCk7UWYodGhpcy5rLlEsYSxjLGIpfTtSLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoUG9wdXA9Ui5wcm90b3R5cGUuSWY7XG5SLnByb3RvdHlwZS5KZj1mdW5jdGlvbihhLGIsYyl7RihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTthYyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDEsYSk7SChcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLDMsYywhMCk7dmFyIGQ9dGhpcy5rLlE7T2YoZCk7dmFyIGU9W0VmXSxmPW1mKGMpO1wiYW5vbnltb3VzXCI9PT1hfHxcImZpcmViYXNlXCI9PT1hP0IoYixYKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKToodi5zZXQoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiLGYuY2QpLFBmKGQsZSxcIi9hdXRoL1wiK2EsZixiKSl9O1IucHJvdG90eXBlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdD1SLnByb3RvdHlwZS5KZjtcblIucHJvdG90eXBlLktmPWZ1bmN0aW9uKGEsYixjLGQpe0YoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwzLDQsYXJndW1lbnRzLmxlbmd0aCk7YWMoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwxLGEpO0goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwzLGMsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiw0LGQsITApO3AoYik/KGFjKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMixiKSxOZih0aGlzLmsuUSxhK1wiL3Rva2VuXCIse2FjY2Vzc190b2tlbjpifSxkLGMpKTooSihcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDIsYiwhMSksTmYodGhpcy5rLlEsYStcIi90b2tlblwiLGIsZCxjKSl9O1IucHJvdG90eXBlLmF1dGhXaXRoT0F1dGhUb2tlbj1SLnByb3RvdHlwZS5LZjtcblIucHJvdG90eXBlLkdmPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2UuYXV0aEFub255bW91c2x5XCIsMSxhLCExKTtKKFwiRmlyZWJhc2UuYXV0aEFub255bW91c2x5XCIsMixiLCEwKTtOZih0aGlzLmsuUSxcImFub255bW91c1wiLHt9LGIsYSl9O1IucHJvdG90eXBlLmF1dGhBbm9ueW1vdXNseT1SLnByb3RvdHlwZS5HZjtcblIucHJvdG90eXBlLkxmPWZ1bmN0aW9uKGEsYixjKXtGKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtKKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIixhLFwiZW1haWxcIik7SyhcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIixhLFwicGFzc3dvcmRcIik7SChcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDIsYiwhMSk7SihcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDMsYywhMCk7TmYodGhpcy5rLlEsXCJwYXNzd29yZFwiLGEsYyxiKX07Ui5wcm90b3R5cGUuYXV0aFdpdGhQYXNzd29yZD1SLnByb3RvdHlwZS5MZjtcblIucHJvdG90eXBlLmplPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0goXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMixiLCExKTt0aGlzLmsuUS5qZShhLGIpfTtSLnByb3RvdHlwZS5jcmVhdGVVc2VyPVIucHJvdG90eXBlLmplO1IucHJvdG90eXBlLkxlPWZ1bmN0aW9uKGEsYil7RihcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0goXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMixiLCExKTt0aGlzLmsuUS5MZShhLGIpfTtcblIucHJvdG90eXBlLnJlbW92ZVVzZXI9Ui5wcm90b3R5cGUuTGU7Ui5wcm90b3R5cGUuZWU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIixhLFwiZW1haWxcIik7SyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsYSxcIm9sZFBhc3N3b3JkXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLGEsXCJuZXdQYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIiwyLGIsITEpO3RoaXMuay5RLmVlKGEsYil9O1IucHJvdG90eXBlLmNoYW5nZVBhc3N3b3JkPVIucHJvdG90eXBlLmVlO1xuUi5wcm90b3R5cGUuZGU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIixhLFwib2xkRW1haWxcIik7SyhcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsYSxcIm5ld0VtYWlsXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLGEsXCJwYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIiwyLGIsITEpO3RoaXMuay5RLmRlKGEsYil9O1IucHJvdG90eXBlLmNoYW5nZUVtYWlsPVIucHJvdG90eXBlLmRlO1xuUi5wcm90b3R5cGUuTWU9ZnVuY3Rpb24oYSxiKXtGKFwiRmlyZWJhc2UucmVzZXRQYXNzd29yZFwiLDIsMixhcmd1bWVudHMubGVuZ3RoKTtKKFwiRmlyZWJhc2UucmVzZXRQYXNzd29yZFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIixhLFwiZW1haWxcIik7SChcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwyLGIsITEpO3RoaXMuay5RLk1lKGEsYil9O1IucHJvdG90eXBlLnJlc2V0UGFzc3dvcmQ9Ui5wcm90b3R5cGUuTWU7Ui5nb09mZmxpbmU9ZnVuY3Rpb24oKXtGKFwiRmlyZWJhc2UuZ29PZmZsaW5lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1RoLk5iKCkucGIoKX07Ui5nb09ubGluZT1mdW5jdGlvbigpe0YoXCJGaXJlYmFzZS5nb09ubGluZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtUaC5OYigpLmhjKCl9O1xuZnVuY3Rpb24gbmIoYSxiKXt5KCFifHwhMD09PWF8fCExPT09YSxcIkNhbid0IHR1cm4gb24gY3VzdG9tIGxvZ2dlcnMgcGVyc2lzdGVudGx5LlwiKTshMD09PWE/KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBjb25zb2xlLmxvZz9sYj1xKGNvbnNvbGUubG9nLGNvbnNvbGUpOlwib2JqZWN0XCI9PT10eXBlb2YgY29uc29sZS5sb2cmJihsYj1mdW5jdGlvbihhKXtjb25zb2xlLmxvZyhhKX0pKSxiJiZ2LnNldChcImxvZ2dpbmdfZW5hYmxlZFwiLCEwKSk6YT9sYj1hOihsYj1udWxsLHYucmVtb3ZlKFwibG9nZ2luZ19lbmFibGVkXCIpKX1SLmVuYWJsZUxvZ2dpbmc9bmI7Ui5TZXJ2ZXJWYWx1ZT17VElNRVNUQU1QOntcIi5zdlwiOlwidGltZXN0YW1wXCJ9fTtSLlNES19WRVJTSU9OPVwiMi4xLjJcIjtSLklOVEVSTkFMPVk7Ui5Db250ZXh0PVRoO1IuVEVTVF9BQ0NFU1M9JDt9KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBGaXJlYmFzZTtcbiIsIlxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnYXBwZW5kJyA6IHJlcXVpcmUoJy4vYXJyYXkvYXBwZW5kJyksXG4gICAgJ2NvbGxlY3QnIDogcmVxdWlyZSgnLi9hcnJheS9jb2xsZWN0JyksXG4gICAgJ2NvbWJpbmUnIDogcmVxdWlyZSgnLi9hcnJheS9jb21iaW5lJyksXG4gICAgJ2NvbXBhY3QnIDogcmVxdWlyZSgnLi9hcnJheS9jb21wYWN0JyksXG4gICAgJ2NvbnRhaW5zJyA6IHJlcXVpcmUoJy4vYXJyYXkvY29udGFpbnMnKSxcbiAgICAnZGlmZmVyZW5jZScgOiByZXF1aXJlKCcuL2FycmF5L2RpZmZlcmVuY2UnKSxcbiAgICAnZXF1YWxzJyA6IHJlcXVpcmUoJy4vYXJyYXkvZXF1YWxzJyksXG4gICAgJ2V2ZXJ5JyA6IHJlcXVpcmUoJy4vYXJyYXkvZXZlcnknKSxcbiAgICAnZmlsdGVyJyA6IHJlcXVpcmUoJy4vYXJyYXkvZmlsdGVyJyksXG4gICAgJ2ZpbmQnIDogcmVxdWlyZSgnLi9hcnJheS9maW5kJyksXG4gICAgJ2ZpbmRJbmRleCcgOiByZXF1aXJlKCcuL2FycmF5L2ZpbmRJbmRleCcpLFxuICAgICdmaW5kTGFzdCcgOiByZXF1aXJlKCcuL2FycmF5L2ZpbmRMYXN0JyksXG4gICAgJ2ZpbmRMYXN0SW5kZXgnIDogcmVxdWlyZSgnLi9hcnJheS9maW5kTGFzdEluZGV4JyksXG4gICAgJ2ZsYXR0ZW4nIDogcmVxdWlyZSgnLi9hcnJheS9mbGF0dGVuJyksXG4gICAgJ2ZvckVhY2gnIDogcmVxdWlyZSgnLi9hcnJheS9mb3JFYWNoJyksXG4gICAgJ2dyb3VwQnknIDogcmVxdWlyZSgnLi9hcnJheS9ncm91cEJ5JyksXG4gICAgJ2luZGV4T2YnIDogcmVxdWlyZSgnLi9hcnJheS9pbmRleE9mJyksXG4gICAgJ2luc2VydCcgOiByZXF1aXJlKCcuL2FycmF5L2luc2VydCcpLFxuICAgICdpbnRlcnNlY3Rpb24nIDogcmVxdWlyZSgnLi9hcnJheS9pbnRlcnNlY3Rpb24nKSxcbiAgICAnaW52b2tlJyA6IHJlcXVpcmUoJy4vYXJyYXkvaW52b2tlJyksXG4gICAgJ2pvaW4nIDogcmVxdWlyZSgnLi9hcnJheS9qb2luJyksXG4gICAgJ2xhc3QnIDogcmVxdWlyZSgnLi9hcnJheS9sYXN0JyksXG4gICAgJ2xhc3RJbmRleE9mJyA6IHJlcXVpcmUoJy4vYXJyYXkvbGFzdEluZGV4T2YnKSxcbiAgICAnbWFwJyA6IHJlcXVpcmUoJy4vYXJyYXkvbWFwJyksXG4gICAgJ21heCcgOiByZXF1aXJlKCcuL2FycmF5L21heCcpLFxuICAgICdtaW4nIDogcmVxdWlyZSgnLi9hcnJheS9taW4nKSxcbiAgICAncGljaycgOiByZXF1aXJlKCcuL2FycmF5L3BpY2snKSxcbiAgICAncGx1Y2snIDogcmVxdWlyZSgnLi9hcnJheS9wbHVjaycpLFxuICAgICdyYW5nZScgOiByZXF1aXJlKCcuL2FycmF5L3JhbmdlJyksXG4gICAgJ3JlZHVjZScgOiByZXF1aXJlKCcuL2FycmF5L3JlZHVjZScpLFxuICAgICdyZWR1Y2VSaWdodCcgOiByZXF1aXJlKCcuL2FycmF5L3JlZHVjZVJpZ2h0JyksXG4gICAgJ3JlamVjdCcgOiByZXF1aXJlKCcuL2FycmF5L3JlamVjdCcpLFxuICAgICdyZW1vdmUnIDogcmVxdWlyZSgnLi9hcnJheS9yZW1vdmUnKSxcbiAgICAncmVtb3ZlQWxsJyA6IHJlcXVpcmUoJy4vYXJyYXkvcmVtb3ZlQWxsJyksXG4gICAgJ3NodWZmbGUnIDogcmVxdWlyZSgnLi9hcnJheS9zaHVmZmxlJyksXG4gICAgJ3NsaWNlJyA6IHJlcXVpcmUoJy4vYXJyYXkvc2xpY2UnKSxcbiAgICAnc29tZScgOiByZXF1aXJlKCcuL2FycmF5L3NvbWUnKSxcbiAgICAnc29ydCcgOiByZXF1aXJlKCcuL2FycmF5L3NvcnQnKSxcbiAgICAnc29ydEJ5JyA6IHJlcXVpcmUoJy4vYXJyYXkvc29ydEJ5JyksXG4gICAgJ3NwbGl0JyA6IHJlcXVpcmUoJy4vYXJyYXkvc3BsaXQnKSxcbiAgICAndGFrZScgOiByZXF1aXJlKCcuL2FycmF5L3Rha2UnKSxcbiAgICAndG9Mb29rdXAnIDogcmVxdWlyZSgnLi9hcnJheS90b0xvb2t1cCcpLFxuICAgICd1bmlvbicgOiByZXF1aXJlKCcuL2FycmF5L3VuaW9uJyksXG4gICAgJ3VuaXF1ZScgOiByZXF1aXJlKCcuL2FycmF5L3VuaXF1ZScpLFxuICAgICd4b3InIDogcmVxdWlyZSgnLi9hcnJheS94b3InKSxcbiAgICAnemlwJyA6IHJlcXVpcmUoJy4vYXJyYXkvemlwJylcbn07XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGFuIGFycmF5IHRvIHRoZSBlbmQgb2YgYW5vdGhlci5cbiAgICAgKiBUaGUgZmlyc3QgYXJyYXkgd2lsbCBiZSBtb2RpZmllZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHBlbmQoYXJyMSwgYXJyMikge1xuICAgICAgICBpZiAoYXJyMiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWQgPSBhcnIxLmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbiA9IGFycjIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBhcnIxW3BhZCArIGldID0gYXJyMltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyMTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhcHBlbmQ7XG5cbiIsInZhciBhcHBlbmQgPSByZXF1aXJlKCcuL2FwcGVuZCcpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSBhbmQgY29uY2F0ZW5hdGVzIHRoZSByZXN1bHQgYXJyYXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbGxlY3QoYXJyLCBjYWxsYmFjaywgdGhpc09iail7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kKHJlc3VsdHMsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29sbGVjdDtcblxuXG4iLCJ2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJy4vaW5kZXhPZicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgYW4gYXJyYXkgd2l0aCBhbGwgdGhlIGl0ZW1zIG9mIGFub3RoZXIuXG4gICAgICogRG9lcyBub3QgYWxsb3cgZHVwbGljYXRlcyBhbmQgaXMgY2FzZSBhbmQgdHlwZSBzZW5zaXRpdmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tYmluZShhcnIxLCBhcnIyKSB7XG4gICAgICAgIGlmIChhcnIyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyMi5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChpbmRleE9mKGFycjEsIGFycjJbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGFycjEucHVzaChhcnIyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnIxO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbWJpbmU7XG5cbiIsInZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBudWxsL3VuZGVmaW5lZCBpdGVtcyBmcm9tIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoYXJyLCBmdW5jdGlvbih2YWwpe1xuICAgICAgICAgICAgcmV0dXJuICh2YWwgIT0gbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29tcGFjdDtcblxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCcuL2luZGV4T2YnKTtcblxuICAgIC8qKlxuICAgICAqIElmIGFycmF5IGNvbnRhaW5zIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhhcnIsIHZhbCkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZihhcnIsIHZhbCkgIT09IC0xO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zO1xuXG4iLCJ2YXIgdW5pcXVlID0gcmVxdWlyZSgnLi91bmlxdWUnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIHNvbWUgPSByZXF1aXJlKCcuL3NvbWUnKTtcbnZhciBjb250YWlucyA9IHJlcXVpcmUoJy4vY29udGFpbnMnKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IEFycmF5IHdpdGggZWxlbWVudHMgdGhhdCBhcmVuJ3QgcHJlc2VudCBpbiB0aGUgb3RoZXIgQXJyYXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpZmZlcmVuY2UoYXJyKSB7XG4gICAgICAgIHZhciBhcnJzID0gc2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcih1bmlxdWUoYXJyKSwgZnVuY3Rpb24obmVlZGxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXNvbWUoYXJycywgZnVuY3Rpb24oaGF5c3RhY2spe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRpZmZlcmVuY2U7XG5cblxuIiwidmFyIGlzID0gcmVxdWlyZSgnLi4vbGFuZy9pcycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcbnZhciBldmVyeSA9IHJlcXVpcmUoJy4vZXZlcnknKTtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIGlmIGJvdGggYXJyYXlzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYiwgY2FsbGJhY2spe1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGlzO1xuXG4gICAgICAgIGlmICghaXNBcnJheShhKSB8fCAhaXNBcnJheShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZXJ5KGEsIG1ha2VDb21wYXJlKGNhbGxiYWNrKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUNvbXBhcmUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSBpbiB0aGlzICYmIGNhbGxiYWNrKHZhbHVlLCB0aGlzW2ldKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVxdWFscztcblxuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgZXZlcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShhcnIsIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIC8vIHdlIGl0ZXJhdGUgb3ZlciBzcGFyc2UgaXRlbXMgc2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIG1ha2UgaXRcbiAgICAgICAgICAgIC8vIHdvcmsgcHJvcGVybHkgb24gSUUgNy04LiBzZWUgIzY0XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKGFycltpXSwgaSwgYXJyKSApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBldmVyeTtcblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IGZpbHRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihhcnIsIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGgsIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaSwgYXJyKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcblxuXG4iLCJ2YXIgZmluZEluZGV4ID0gcmVxdWlyZSgnLi9maW5kSW5kZXgnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgY3JpdGVyaWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGFyciwgaXRlcmF0b3IsIHRoaXNPYmope1xuICAgICAgICB2YXIgaWR4ID0gZmluZEluZGV4KGFyciwgaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICByZXR1cm4gaWR4ID49IDA/IGFycltpZHhdIDogdm9pZCgwKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG5cblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyBjcml0ZXJpYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKXtcbiAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcihhcnJbaV0sIGksIGFycikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcblxuIiwidmFyIGZpbmRMYXN0SW5kZXggPSByZXF1aXJlKCcuL2ZpbmRMYXN0SW5kZXgnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGFzdCBpdGVtIHRoYXQgbWF0Y2hlcyBjcml0ZXJpYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0KGFyciwgaXRlcmF0b3IsIHRoaXNPYmope1xuICAgICAgICB2YXIgaWR4ID0gZmluZExhc3RJbmRleChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwPyBhcnJbaWR4XSA6IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kTGFzdDtcblxuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSB0aGF0IG1hdGNoZXMgY3JpdGVyaWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFyciwgaXRlcmF0b3IsIHRoaXNPYmope1xuICAgICAgICBpdGVyYXRvciA9IG1ha2VJdGVyYXRvcihpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcihhcnJbbl0sIG4sIGFycikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbmRMYXN0SW5kZXg7XG5cblxuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcbnZhciBhcHBlbmQgPSByZXF1aXJlKCcuL2FwcGVuZCcpO1xuXG4gICAgLypcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZmxhdHRlbiB0byBhIGRlc3RpbmF0aW9uIGFycmF5LlxuICAgICAqIFVzZWQgdG8gcmVtb3ZlIHRoZSBuZWVkIHRvIGNyZWF0ZSBpbnRlcm1lZGlhdGUgYXJyYXlzIHdoaWxlIGZsYXR0ZW5pbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlblRvKGFyciwgcmVzdWx0LCBsZXZlbCkge1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGFwcGVuZChyZXN1bHQsIGFycik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmbGF0dGVuVG8odmFsdWUsIHJlc3VsdCwgbGV2ZWwgLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYW4gYXJyYXkuXG4gICAgICogQSBuZXcgYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIGlzIHJldHVybmVkLlxuICAgICAqIElmIGBzaGFsbG93YCBpcyB0cnVlLCBpdCB3aWxsIG9ubHkgZmxhdHRlbiBvbmUgbGV2ZWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnIsIGxldmVsKSB7XG4gICAgICAgIGxldmVsID0gbGV2ZWwgPT0gbnVsbD8gLTEgOiBsZXZlbDtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5UbyhhcnIsIFtdLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuXG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBmb3JFYWNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChhcnIsIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgc3BhcnNlIGl0ZW1zIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyB3b3JrIHByb3Blcmx5IG9uIElFIDctOC4gc2VlICM2NFxuICAgICAgICAgICAgaWYgKCBjYWxsYmFjay5jYWxsKHRoaXNPYmosIGFycltpXSwgaSwgYXJyKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cblxuIiwidmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9hcnJheS9mb3JFYWNoJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9pZGVudGl0eScpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEJ1Y2tldCB0aGUgYXJyYXkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdyb3VwQnkoYXJyLCBjYXRlZ29yaXplLCB0aGlzT2JqKSB7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKSB7XG4gICAgICAgICAgICBjYXRlZ29yaXplID0gbWFrZUl0ZXJhdG9yKGNhdGVnb3JpemUsIHRoaXNPYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBpZGVudGl0eSBmdW5jdGlvbi5cbiAgICAgICAgICAgIGNhdGVnb3JpemUgPSBpZGVudGl0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWNrZXRzID0ge307XG4gICAgICAgIGZvckVhY2goYXJyLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gY2F0ZWdvcml6ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghKGJ1Y2tldCBpbiBidWNrZXRzKSkge1xuICAgICAgICAgICAgICAgIGJ1Y2tldHNbYnVja2V0XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWNrZXRzW2J1Y2tldF0ucHVzaChlbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1Y2tldHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBncm91cEJ5O1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEFycmF5LmluZGV4T2ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFyciwgaXRlbSwgZnJvbUluZGV4KSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCB8fCAwO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgaSA9IGZyb21JbmRleCA8IDAgPyBsZW4gKyBmcm9tSW5kZXggOiBmcm9tSW5kZXg7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgc3BhcnNlIGl0ZW1zIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyB3b3JrIHByb3Blcmx5IG9uIElFIDctOC4gc2VlICM2NFxuICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbmRleE9mO1xuXG4iLCJ2YXIgZGlmZmVyZW5jZSA9IHJlcXVpcmUoJy4vZGlmZmVyZW5jZScpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGl0ZW0gaW50byBhcnJheSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChhcnIsIHJlc3RfaXRlbXMpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBkaWZmZXJlbmNlKHNsaWNlKGFyZ3VtZW50cywgMSksIGFycik7XG4gICAgICAgIGlmIChkaWZmLmxlbmd0aCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJyLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbnNlcnQ7XG5cbiIsInZhciB1bmlxdWUgPSByZXF1aXJlKCcuL3VuaXF1ZScpO1xudmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgZXZlcnkgPSByZXF1aXJlKCcuL2V2ZXJ5Jyk7XG52YXIgY29udGFpbnMgPSByZXF1aXJlKCcuL2NvbnRhaW5zJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuL3NsaWNlJyk7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBBcnJheSB3aXRoIGVsZW1lbnRzIGNvbW1vbiB0byBhbGwgQXJyYXlzLlxuICAgICAqIC0gYmFzZWQgb24gdW5kZXJzY29yZS5qcyBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGFycnMgPSBzbGljZShhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyKHVuaXF1ZShhcnIpLCBmdW5jdGlvbihuZWVkbGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVyeShhcnJzLCBmdW5jdGlvbihoYXlzdGFjayl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWlucyhoYXlzdGFjaywgbmVlZGxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW50ZXJzZWN0aW9uO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIENhbGwgYG1ldGhvZE5hbWVgIG9uIGVhY2ggaXRlbSBvZiB0aGUgYXJyYXkgcGFzc2luZyBjdXN0b20gYXJndW1lbnRzIGlmXG4gICAgICogbmVlZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShhcnIsIG1ldGhvZE5hbWUsIHZhcl9hcmdzKXtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpO1xuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoLCB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICB2YWx1ZVttZXRob2ROYW1lXS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW52b2tlO1xuXG4iLCJ2YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxuICAgIGZ1bmN0aW9uIGlzVmFsaWRTdHJpbmcodmFsKSB7XG4gICAgICAgIHJldHVybiAodmFsICE9IG51bGwgJiYgdmFsICE9PSAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSm9pbnMgc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpZWQgc2VwYXJhdG9yIGluc2VydGVkIGJldHdlZW4gZWFjaCB2YWx1ZS5cbiAgICAgKiBOdWxsIHZhbHVlcyBhbmQgZW1wdHkgc3RyaW5ncyB3aWxsIGJlIGV4Y2x1ZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oaXRlbXMsIHNlcGFyYXRvcikge1xuICAgICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJyc7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoaXRlbXMsIGlzVmFsaWRTdHJpbmcpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpvaW47XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsYXN0IGVsZW1lbnQgb2YgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnIpe1xuICAgICAgICBpZiAoYXJyID09IG51bGwgfHwgYXJyLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBsYXN0SW5kZXhPZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFyciwgaXRlbSwgZnJvbUluZGV4KSB7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPT0gbnVsbCB8fCBmcm9tSW5kZXggPj0gbGVuKT8gbGVuIC0gMSA6IGZyb21JbmRleDtcbiAgICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDApPyBsZW4gKyBmcm9tSW5kZXggOiBmcm9tSW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGZyb21JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgc3BhcnNlIGl0ZW1zIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyB3b3JrIHByb3Blcmx5IG9uIElFIDctOC4gc2VlICM2NFxuICAgICAgICAgICAgaWYgKGFycltmcm9tSW5kZXhdID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21JbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbGFzdEluZGV4T2Y7XG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBtYXBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBjYWxsYmFjayhhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYXA7XG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWF4aW11bSB2YWx1ZSBpbnNpZGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyLCBpdGVyYXRvciwgdGhpc09iail7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKGFyci5sZW5ndGggJiYgIWl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbWFrZUl0ZXJhdG9yKGl0ZXJhdG9yLCB0aGlzT2JqKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wO1xuXG4gICAgICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBpdGVyYXRvcih2YWx1ZSwgaSwgYXJyKTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcCA+IGNvbXBhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWluaW11bSB2YWx1ZSBpbnNpZGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyLCBpdGVyYXRvciwgdGhpc09iail7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoICYmICFpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IG1ha2VJdGVyYXRvcihpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0ZW1wO1xuXG4gICAgICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBpdGVyYXRvcih2YWx1ZSwgaSwgYXJyKTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcCA8IGNvbXBhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWluO1xuXG5cbiIsInZhciByYW5kSW50ID0gcmVxdWlyZSgnLi4vcmFuZG9tL3JhbmRJbnQnKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSByYW5kb20gaXRlbShzKSBmcm9tIHRoZSBBcnJheSBhbmQgcmV0dXJuIGl0LlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgb2YgaXRlbXMgaWYgW25JdGVtc10gaXMgcHJvdmlkZWQgb3IgYSBzaW5nbGUgaXRlbSBpZlxuICAgICAqIGl0IGlzbid0IHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrKGFyciwgbkl0ZW1zKXtcbiAgICAgICAgaWYgKG5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZiAobkl0ZW1zID4gMCAmJiBhcnIgJiYgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5JdGVtcyA9IG5JdGVtcyA+IGFyci5sZW5ndGg/IGFyci5sZW5ndGggOiBuSXRlbXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5JdGVtcy0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCBwaWNrT25lKGFycikgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXJyICYmIGFyci5sZW5ndGgpPyBwaWNrT25lKGFycikgOiB2b2lkKDApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcGlja09uZShhcnIpe1xuICAgICAgICB2YXIgaWR4ID0gcmFuZEludCgwLCBhcnIubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGlkeCwgMSlbMF07XG4gICAgfVxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG5cblxuIiwidmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGEgbGlzdCBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGx1Y2soYXJyLCBwcm9wTmFtZSl7XG4gICAgICAgIHJldHVybiBtYXAoYXJyLCBwcm9wTmFtZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwbHVjaztcblxuXG4iLCJ2YXIgY291bnRTdGVwcyA9IHJlcXVpcmUoJy4uL21hdGgvY291bnRTdGVwcycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBvZiBudW1iZXJzIGluc2lkZSByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBuU3RlcHMgPSBjb3VudFN0ZXBzKHN0b3AgLSBzdGFydCwgc3RlcCksXG4gICAgICAgICAgICBpID0gc3RhcnQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPD0gc3RvcCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICBpICs9IHN0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZ2U7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSByZWR1Y2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoYXJyLCBmbiwgaW5pdFZhbCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgYXJncy5sZW5ndGggc2luY2UgaW5pdFZhbCBtaWdodCBiZSBcInVuZGVmaW5lZFwiIHNlZSAjZ2gtNTdcbiAgICAgICAgdmFyIGhhc0luaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMixcbiAgICAgICAgICAgIHJlc3VsdCA9IGluaXRWYWw7XG5cbiAgICAgICAgaWYgKGFyciA9PSBudWxsIHx8ICFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0luaXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0luaXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgaGFzSW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHJlc3VsdCwgYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSByZWR1Y2VSaWdodFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGFyciwgZm4sIGluaXRWYWwpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFyZ3MubGVuZ3RoIHNpbmNlIGluaXRWYWwgbWlnaHQgYmUgXCJ1bmRlZmluZWRcIiBzZWUgI2doLTU3XG4gICAgICAgIHZhciBoYXNJbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG5cbiAgICAgICAgaWYgKGFyciA9PSBudWxsIHx8ICFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzSW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0VmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gYXJyLmxlbmd0aCwgcmVzdWx0ID0gaW5pdFZhbCwgdmFsdWU7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHNwYXJzZSBpdGVtcyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gbWFrZSBpdFxuICAgICAgICAgICAgLy8gd29yayBwcm9wZXJseSBvbiBJRSA3LTguIHNlZSAjNjRcbiAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYgKCFoYXNJbml0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaGFzSW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHJlc3VsdCwgdmFsdWUsIGksIGFycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlZHVjZVJpZ2h0O1xuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgcmVqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGFyciwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aCwgdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjayh2YWx1ZSwgaSwgYXJyKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlamVjdDtcblxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCcuL2luZGV4T2YnKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNpbmdsZSBpdGVtIGZyb20gdGhlIGFycmF5LlxuICAgICAqIChpdCB3b24ndCByZW1vdmUgZHVwbGljYXRlcywganVzdCBhIHNpbmdsZSBpdGVtKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnIsIGl0ZW0pe1xuICAgICAgICB2YXIgaWR4ID0gaW5kZXhPZihhcnIsIGl0ZW0pO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkgYXJyLnNwbGljZShpZHgsIDEpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVtb3ZlO1xuXG4iLCJ2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJy4vaW5kZXhPZicpO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBpbnN0YW5jZXMgb2YgYW4gaXRlbSBmcm9tIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbChhcnIsIGl0ZW0pe1xuICAgICAgICB2YXIgaWR4ID0gaW5kZXhPZihhcnIsIGl0ZW0pO1xuICAgICAgICB3aGlsZSAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgaWR4ID0gaW5kZXhPZihhcnIsIGl0ZW0sIGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZUFsbDtcblxuIiwidmFyIHJhbmRJbnQgPSByZXF1aXJlKCcuLi9yYW5kb20vcmFuZEludCcpO1xuXG4gICAgLyoqXG4gICAgICogU2h1ZmZsZSBhcnJheSBpdGVtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGFycikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgcm5kO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aCwgdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbMF0gPSBhcnJbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJuZCA9IHJhbmRJbnQoMCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdHNbcm5kXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzW3JuZF0gPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNodWZmbGU7XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHNsaWNlIG9mIHNvdXJjZSBhcnJheSBvciBhcnJheS1saWtlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIGVuZCl7XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KGxlbiArIHN0YXJ0LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4oc3RhcnQsIGxlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGxlbjtcbiAgICAgICAgfSBlbHNlIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1heChsZW4gKyBlbmQsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycltzdGFydCsrXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc2xpY2U7XG5cblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNvbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGFyciwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIC8vIHdlIGl0ZXJhdGUgb3ZlciBzcGFyc2UgaXRlbXMgc2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIG1ha2UgaXRcbiAgICAgICAgICAgIC8vIHdvcmsgcHJvcGVybHkgb24gSUUgNy04LiBzZWUgIzY0XG4gICAgICAgICAgICBpZiAoIGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKSApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNvbWU7XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogTWVyZ2Ugc29ydCAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXJnZV9zb3J0KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChhcnIsIGNvbXBhcmVGbikge1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlRm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcGFyZUZuID0gZGVmYXVsdENvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWlkLCBsZWZ0LCByaWdodDtcblxuICAgICAgICBtaWQgICA9IH5+KGFyci5sZW5ndGggLyAyKTtcbiAgICAgICAgbGVmdCAgPSBtZXJnZVNvcnQoIGFyci5zbGljZSgwLCBtaWQpLCBjb21wYXJlRm4gKTtcbiAgICAgICAgcmlnaHQgPSBtZXJnZVNvcnQoIGFyci5zbGljZShtaWQsIGFyci5sZW5ndGgpLCBjb21wYXJlRm4gKTtcblxuICAgICAgICByZXR1cm4gbWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmVGbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IChhID4gYj8gMSA6IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJlRm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChsZWZ0Lmxlbmd0aCAmJiByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlRm4obGVmdFswXSwgcmlnaHRbMF0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAwIGl0IHNob3VsZCBwcmVzZXJ2ZSBzYW1lIG9yZGVyIChzdGFibGUpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVmdC5zaGlmdCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmlnaHQuc2hpZnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbGVmdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXJnZVNvcnQ7XG5cblxuIiwidmFyIHNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKlxuICAgICAqIFNvcnQgYXJyYXkgYnkgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoYXJyLCBjYWxsYmFjaywgY29udGV4dCl7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCBjb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gc29ydChhcnIsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIGEgPSBjYWxsYmFjayhhKTtcbiAgICAgICAgICAgIGIgPSBjYWxsYmFjayhiKTtcbiAgICAgICAgICAgIHJldHVybiAoYSA8IGIpID8gLTEgOiAoKGEgPiBiKSA/IDEgOiAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb3J0Qnk7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhcnJheSBpbnRvIGEgZml4ZWQgbnVtYmVyIG9mIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KGFycmF5LCBzZWdtZW50cykge1xuICAgICAgICBzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDI7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChhcnJheSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5MZW5ndGggPSBNYXRoLmZsb29yKGFycmF5Lmxlbmd0aCAvIHNlZ21lbnRzKSxcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IGFycmF5Lmxlbmd0aCAlIHNlZ21lbnRzLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICBzZWdtZW50SW5kZXggPSAwLFxuICAgICAgICAgICAgc2VnbWVudExlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgc2VnbWVudExlbmd0aCA9IG1pbkxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzZWdtZW50SW5kZXggPCByZW1haW5kZXIpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50TGVuZ3RoKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChhcnJheS5zbGljZShpLCBpICsgc2VnbWVudExlbmd0aCkpO1xuXG4gICAgICAgICAgICBzZWdtZW50SW5kZXgrKztcbiAgICAgICAgICAgIGkgKz0gc2VnbWVudExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNwbGl0O1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYSBjYWxsYmFjayBhIHNldCBhbW91bnQgb2YgdGltZXNcbiAgICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKG4sIGNhbGxiYWNrLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICBpZiggIXRoaXNPYmogKXtcbiAgICAgICAgICAgIHdoaWxlKCsraSA8IG4pe1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGNhbGxiYWNrKGksIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUoKytpIDwgbil7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gY2FsbGJhY2suY2FsbCh0aGlzT2JqLCBpLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdGFrZTtcblxuXG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2xhbmcvaXNGdW5jdGlvbicpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBob2xkcyBhIGxvb2t1cCBmb3IgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG9va3VwKGFyciwga2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aCwgdmFsdWU7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5KHZhbHVlKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRbdmFsdWVba2V5XV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9Mb29rdXA7XG5cbiIsInZhciB1bmlxdWUgPSByZXF1aXJlKCcuL3VuaXF1ZScpO1xudmFyIGFwcGVuZCA9IHJlcXVpcmUoJy4vYXBwZW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb25jYXQgbXVsdGlwbGUgYXJyYXlzIGFuZCByZW1vdmUgZHVwbGljYXRlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW9uKGFycnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgYXBwZW5kKHJlc3VsdHMsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5pcXVlKHJlc3VsdHMpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5pb247XG5cblxuIiwidmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgdW5pcXVlIGl0ZW1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlKGFyciwgY29tcGFyZSl7XG4gICAgICAgIGNvbXBhcmUgPSBjb21wYXJlIHx8IGlzRXF1YWw7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoYXJyLCBmdW5jdGlvbihpdGVtLCBpLCBhcnIpe1xuICAgICAgICAgICAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXBhcmUoaXRlbSwgYXJyW2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpe1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZTtcblxuXG4iLCJ2YXIgdW5pcXVlID0gcmVxdWlyZSgnLi91bmlxdWUnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIGNvbnRhaW5zID0gcmVxdWlyZSgnLi9jb250YWlucycpO1xuXG5cbiAgICAvKipcbiAgICAgKiBFeGNsdXNpdmUgT1IuIFJldHVybnMgaXRlbXMgdGhhdCBhcmUgcHJlc2VudCBpbiBhIHNpbmdsZSBhcnJheS5cbiAgICAgKiAtIGxpa2UgcHR5aG9uJ3MgYHN5bW1ldHJpY19kaWZmZXJlbmNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcihhcnIxLCBhcnIyKSB7XG4gICAgICAgIGFycjEgPSB1bmlxdWUoYXJyMSk7XG4gICAgICAgIGFycjIgPSB1bmlxdWUoYXJyMik7XG5cbiAgICAgICAgdmFyIGExID0gZmlsdGVyKGFycjEsIGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgICAgIHJldHVybiAhY29udGFpbnMoYXJyMiwgaXRlbSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGEyID0gZmlsdGVyKGFycjIsIGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgICAgIHJldHVybiAhY29udGFpbnMoYXJyMSwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYTEuY29uY2F0KGEyKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHhvcjtcblxuXG4iLCJ2YXIgbWF4ID0gcmVxdWlyZSgnLi9tYXgnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RoKGFycikge1xuICAgICAgICByZXR1cm4gYXJyID09IG51bGwgPyAwIDogYXJyLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdG9nZXRoZXIgdGhlIHZhbHVlcyBvZiBlYWNoIG9mIHRoZSBhcnJheXMgd2l0aCB0aGUgdmFsdWVzIGF0IHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwKGFycil7XG4gICAgICAgIHZhciBsZW4gPSBhcnIgPyBtYXgobWFwKGFyZ3VtZW50cywgZ2V0TGVuZ3RoKSkgOiAwLFxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBqc2hpbnQgbG9vcGZ1bmM6IHRydWVcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChtYXAoYXJndW1lbnRzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGl0ZW1baV07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHppcDtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2NvbnRhaW5zJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9jb250YWlucycpLFxuICAgICdldmVyeScgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vZXZlcnknKSxcbiAgICAnZmlsdGVyJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9maWx0ZXInKSxcbiAgICAnZmluZCcgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vZmluZCcpLFxuICAgICdmb3JFYWNoJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9mb3JFYWNoJyksXG4gICAgJ21ha2VfJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9tYWtlXycpLFxuICAgICdtYXAnIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL21hcCcpLFxuICAgICdtYXgnIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL21heCcpLFxuICAgICdtaW4nIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL21pbicpLFxuICAgICdwbHVjaycgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vcGx1Y2snKSxcbiAgICAncmVkdWNlJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9yZWR1Y2UnKSxcbiAgICAncmVqZWN0JyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9yZWplY3QnKSxcbiAgICAnc2l6ZScgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vc2l6ZScpLFxuICAgICdzb21lJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9zb21lJylcbn07XG5cblxuIiwidmFyIG1ha2UgPSByZXF1aXJlKCcuL21ha2VfJyk7XG52YXIgYXJyQ29udGFpbnMgPSByZXF1aXJlKCcuLi9hcnJheS9jb250YWlucycpO1xudmFyIG9iakNvbnRhaW5zID0gcmVxdWlyZSgnLi4vb2JqZWN0L2NvbnRhaW5zJyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyQ29udGFpbnMsIG9iakNvbnRhaW5zKTtcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJFdmVyeSA9IHJlcXVpcmUoJy4uL2FycmF5L2V2ZXJ5Jyk7XG52YXIgb2JqRXZlcnkgPSByZXF1aXJlKCcuLi9vYmplY3QvZXZlcnknKTtcblxuICAgIC8qKlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZShhcnJFdmVyeSwgb2JqRXZlcnkpO1xuXG5cbiIsInZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogZmlsdGVyIGNvbGxlY3Rpb24gdmFsdWVzLCByZXR1cm5zIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihsaXN0LCBpdGVyYXRvciwgdGhpc09iaikge1xuICAgICAgICBpdGVyYXRvciA9IG1ha2VJdGVyYXRvcihpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmICghbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcih2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZmlsdGVyO1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyckZpbmQgPSByZXF1aXJlKCcuLi9hcnJheS9maW5kJyk7XG52YXIgb2JqRmluZCA9IHJlcXVpcmUoJy4uL29iamVjdC9maW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHZhbHVlIHRoYXQgcmV0dXJucyB0cnVlIG9uIGl0ZXJhdG9yIGNoZWNrLlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZShhcnJGaW5kLCBvYmpGaW5kKTtcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJGb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xudmFyIG9iakZvckVhY2ggPSByZXF1aXJlKCcuLi9vYmplY3QvZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyRm9yRWFjaCwgb2JqRm9yRWFjaCk7XG5cblxuIiwidmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIG1ldGhvZCB1c2VkIHRvIGNyZWF0ZSBvdGhlciBjb2xsZWN0aW9uIG1vZHVsZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUNvbGxlY3Rpb25NZXRob2QoYXJyTWV0aG9kLCBvYmpNZXRob2QsIGRlZmF1bHRSZXR1cm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoYXJnc1swXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRSZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcnJheS1saWtlIGlzIHRyZWF0ZWQgYXMgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGFyZ3NbMF0ubGVuZ3RoID09PSAnbnVtYmVyJyk/IGFyck1ldGhvZC5hcHBseShudWxsLCBhcmdzKSA6IG9iak1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VDb2xsZWN0aW9uTWV0aG9kO1xuXG5cbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcbnZhciB2YWx1ZXMgPSByZXF1aXJlKCcuLi9vYmplY3QvdmFsdWVzJyk7XG52YXIgYXJyTWFwID0gcmVxdWlyZSgnLi4vYXJyYXkvbWFwJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogTWFwIGNvbGxlY3Rpb24gdmFsdWVzLCByZXR1cm5zIEFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChsaXN0LCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIC8vIGxpc3QubGVuZ3RoIHRvIGNoZWNrIGFycmF5LWxpa2Ugb2JqZWN0LCBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICAvLyB3ZSBzaW1wbHkgbWFwIGFsbCB0aGUgb2JqZWN0IHZhbHVlc1xuICAgICAgICBpZiggaXNPYmplY3QobGlzdCkgJiYgbGlzdC5sZW5ndGggPT0gbnVsbCApe1xuICAgICAgICAgICAgbGlzdCA9IHZhbHVlcyhsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyTWFwKGxpc3QsIGZ1bmN0aW9uICh2YWwsIGtleSwgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbCwga2V5LCBsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXA7XG5cblxuIiwidmFyIG1ha2UgPSByZXF1aXJlKCcuL21ha2VfJyk7XG52YXIgYXJyTWF4ID0gcmVxdWlyZSgnLi4vYXJyYXkvbWF4Jyk7XG52YXIgb2JqTWF4ID0gcmVxdWlyZSgnLi4vb2JqZWN0L21heCcpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IG1heGltdW0gdmFsdWUgaW5zaWRlIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyTWF4LCBvYmpNYXgpO1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyck1pbiA9IHJlcXVpcmUoJy4uL2FycmF5L21pbicpO1xudmFyIG9iak1pbiA9IHJlcXVpcmUoJy4uL29iamVjdC9taW4nKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBtaW5pbXVtIHZhbHVlIGluc2lkZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZShhcnJNaW4sIG9iak1pbik7XG5cblxuIiwidmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGEgbGlzdCBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGx1Y2sobGlzdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBtYXAobGlzdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBsdWNrO1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyclJlZHVjZSA9IHJlcXVpcmUoJy4uL2FycmF5L3JlZHVjZScpO1xudmFyIG9ialJlZHVjZSA9IHJlcXVpcmUoJy4uL29iamVjdC9yZWR1Y2UnKTtcblxuICAgIC8qKlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZShhcnJSZWR1Y2UsIG9ialJlZHVjZSk7XG5cblxuIiwidmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvciBjb2xsZWN0aW9uL2ZpbHRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChsaXN0LCBpdGVyYXRvciwgdGhpc09iaikge1xuICAgICAgICBpdGVyYXRvciA9IG1ha2VJdGVyYXRvcihpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgIHJldHVybiBmaWx0ZXIobGlzdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gIWl0ZXJhdG9yKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIH0sIHRoaXNPYmopO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVqZWN0O1xuXG5cbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG52YXIgb2JqU2l6ZSA9IHJlcXVpcmUoJy4uL29iamVjdC9zaXplJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29sbGVjdGlvbiBzaXplXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShsaXN0KSB7XG4gICAgICAgIGlmICghbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobGlzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqU2l6ZShsaXN0KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpemU7XG5cblxuIiwidmFyIG1ha2UgPSByZXF1aXJlKCcuL21ha2VfJyk7XG52YXIgYXJyU29tZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NvbWUnKTtcbnZhciBvYmpTb21lID0gcmVxdWlyZSgnLi4vb2JqZWN0L3NvbWUnKTtcblxuICAgIC8qKlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZShhcnJTb21lLCBvYmpTb21lKTtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2RheU9mVGhlWWVhcicgOiByZXF1aXJlKCcuL2RhdGUvZGF5T2ZUaGVZZWFyJyksXG4gICAgJ2RpZmYnIDogcmVxdWlyZSgnLi9kYXRlL2RpZmYnKSxcbiAgICAnaTE4bl8nIDogcmVxdWlyZSgnLi9kYXRlL2kxOG5fJyksXG4gICAgJ2lzTGVhcFllYXInIDogcmVxdWlyZSgnLi9kYXRlL2lzTGVhcFllYXInKSxcbiAgICAnaXNTYW1lJyA6IHJlcXVpcmUoJy4vZGF0ZS9pc1NhbWUnKSxcbiAgICAncGFyc2VJc28nIDogcmVxdWlyZSgnLi9kYXRlL3BhcnNlSXNvJyksXG4gICAgJ3F1YXJ0ZXInIDogcmVxdWlyZSgnLi9kYXRlL3F1YXJ0ZXInKSxcbiAgICAnc3RhcnRPZicgOiByZXF1aXJlKCcuL2RhdGUvc3RhcnRPZicpLFxuICAgICdzdHJmdGltZScgOiByZXF1aXJlKCcuL2RhdGUvc3RyZnRpbWUnKSxcbiAgICAndGltZXpvbmVBYmJyJyA6IHJlcXVpcmUoJy4vZGF0ZS90aW1lem9uZUFiYnInKSxcbiAgICAndGltZXpvbmVPZmZzZXQnIDogcmVxdWlyZSgnLi9kYXRlL3RpbWV6b25lT2Zmc2V0JyksXG4gICAgJ3RvdGFsRGF5c0luTW9udGgnIDogcmVxdWlyZSgnLi9kYXRlL3RvdGFsRGF5c0luTW9udGgnKSxcbiAgICAndG90YWxEYXlzSW5ZZWFyJyA6IHJlcXVpcmUoJy4vZGF0ZS90b3RhbERheXNJblllYXInKSxcbiAgICAnd2Vla09mVGhlWWVhcicgOiByZXF1aXJlKCcuL2RhdGUvd2Vla09mVGhlWWVhcicpXG59O1xuXG5cbiIsInZhciBpc0RhdGUgPSByZXF1aXJlKCcuLi9sYW5nL2lzRGF0ZScpO1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBkYXkgb2YgdGhlIHllYXIgKDEuLjM2NilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkYXlPZlRoZVllYXIoZGF0ZSl7XG4gICAgICAgIHJldHVybiAoRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKSAtXG4gICAgICAgICAgICAgICAgRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSkgLyA4NjQwMDAwMCArIDE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkYXlPZlRoZVllYXI7XG5cblxuIiwidmFyIHRvdGFsRGF5c0luTW9udGggPSByZXF1aXJlKCcuL3RvdGFsRGF5c0luTW9udGgnKTtcbnZhciB0b3RhbERheXNJblllYXIgPSByZXF1aXJlKCcuL3RvdGFsRGF5c0luWWVhcicpO1xudmFyIGNvbnZlcnQgPSByZXF1aXJlKCcuLi90aW1lL2NvbnZlcnQnKTtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzIChyYW5nZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmKHN0YXJ0LCBlbmQsIHVuaXROYW1lKXtcbiAgICAgICAgLy8gc29ydCB0aGUgZGF0ZXMgdG8gbWFrZSBpdCBlYXNpZXIgdG8gcHJvY2VzcyAoc3BlY2lhbGx5IHllYXIvbW9udGgpXG4gICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgdmFyIHN3YXAgPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgZW5kID0gc3dhcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHVuaXROYW1lID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBnZXRNb250aHNEaWZmKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXROYW1lID09PSAneWVhcicpe1xuICAgICAgICAgICAgb3V0cHV0ID0gZ2V0WWVhcnNEaWZmKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXROYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1bml0TmFtZSA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGltZXpvbmUgZGlmZmVyZW5jZSBiZWNhdXNlIG9mIGRheWxpZ2h0IHNhdmluZ3MgdGltZVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9VdGMoc3RhcnQpO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRvVXRjKGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgPSBjb252ZXJ0KGVuZCAtIHN0YXJ0LCAnbXMnLCB1bml0TmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiB0b1V0YyhkKXtcbiAgICAgICAgLy8gd2UgaWdub3JlIHRpbWV6b25lIGRpZmZlcmVuY2VzIG9uIHB1cnBvc2UgYmVjYXVzZSBvZiBkYXlsaWdodFxuICAgICAgICAvLyBzYXZpbmdzIHRpbWUsIG90aGVyd2lzZSBpdCB3b3VsZCByZXR1cm4gZnJhY3Rpb25hbCBkYXlzL3dlZWtzIGV2ZW5cbiAgICAgICAgLy8gaWYgYSBmdWxsIGRheSBlbGFwc2VkLiBlZzpcbiAgICAgICAgLy8gV2VkIEZlYiAxMiAyMDE0IDAwOjAwOjAwIEdNVC0wMjAwIChCUlNUKVxuICAgICAgICAvLyBTdW4gRmViIDE2IDIwMTQgMDA6MDA6MDAgR01ULTAzMDAgKEJSVClcbiAgICAgICAgLy8gZGlmZiBzaG91bGQgYmUgNCBkYXlzIGFuZCBub3QgNC4wNDE2NjY2NjY2NjY2NjdcbiAgICAgICAgcmV0dXJuIERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuZ2V0SG91cnMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0U2Vjb25kcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZC5nZXRNaWxsaXNlY29uZHMoKSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRNb250aHNEaWZmKHN0YXJ0LCBlbmQpe1xuICAgICAgICByZXR1cm4gZ2V0RWxhcHNlZE1vbnRocyhzdGFydCwgZW5kKSArXG4gICAgICAgICAgICAgICBnZXRFbGFwc2VkWWVhcnMoc3RhcnQsIGVuZCkgKiAxMiArXG4gICAgICAgICAgICAgICBnZXRGcmFjdGlvbmFsTW9udGgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRZZWFyc0RpZmYoc3RhcnQsIGVuZCl7XG4gICAgICAgIHZhciBlbGFwc2VkWWVhcnMgPSBnZXRFbGFwc2VkWWVhcnMoc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiBlbGFwc2VkWWVhcnMgKyBnZXRGcmFjdGlvbmFsWWVhcihzdGFydCwgZW5kLCBlbGFwc2VkWWVhcnMpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0RWxhcHNlZE1vbnRocyhzdGFydCwgZW5kKXtcbiAgICAgICAgdmFyIG1vbnRoRGlmZiA9IGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKTtcbiAgICAgICAgaWYgKG1vbnRoRGlmZiA8IDApIHtcbiAgICAgICAgICAgIG1vbnRoRGlmZiArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsZXNzIHRoYW4gYSBmdWxsIG1vbnRoXG4gICAgICAgIGlmIChzdGFydC5nZXREYXRlKCkgPiBlbmQuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICAgICBtb250aERpZmYgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9udGhEaWZmO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0RWxhcHNlZFllYXJzKHN0YXJ0LCBlbmQpe1xuICAgICAgICB2YXIgeWVhckRpZmYgPSBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIC8vIGxlc3MgdGhhbiBhIGZ1bGwgeWVhclxuICAgICAgICBpZiAoc3RhcnQuZ2V0TW9udGgoKSA+IGVuZC5nZXRNb250aCgpKSB7XG4gICAgICAgICAgICB5ZWFyRGlmZiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyRGlmZjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxNb250aChzdGFydCwgZW5kKXtcbiAgICAgICAgdmFyIGZyYWN0aW9uYWxEaWZmID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0RGF5ID0gc3RhcnQuZ2V0RGF0ZSgpO1xuICAgICAgICB2YXIgZW5kRGF5ID0gZW5kLmdldERhdGUoKTtcblxuICAgICAgICBpZiAoc3RhcnREYXkgIT09IGVuZERheSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VG90YWxEYXlzID0gdG90YWxEYXlzSW5Nb250aChzdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kVG90YWxEYXlzID0gdG90YWxEYXlzSW5Nb250aChlbmQpO1xuICAgICAgICAgICAgdmFyIHRvdGFsRGF5cztcbiAgICAgICAgICAgIHZhciBkYXlzRWxhcHNlZDtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0RGF5ID4gZW5kRGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gZWc6IEphbiAyOSAtIEZlYiAyNyAoMjkgZGF5cyBlbGFwc2VkIGJ1dCBub3QgYSBmdWxsIG1vbnRoKVxuICAgICAgICAgICAgICAgIHZhciBiYXNlRGF5ID0gc3RhcnRUb3RhbERheXMgLSBzdGFydERheTtcbiAgICAgICAgICAgICAgICBkYXlzRWxhcHNlZCA9IGVuZERheSArIGJhc2VEYXk7XG4gICAgICAgICAgICAgICAgLy8gdG90YWwgZGF5cyBzaG91bGQgYmUgcmVsYXRpdmUgdG8gMXN0IGRheSBvZiBuZXh0IG1vbnRoIGlmXG4gICAgICAgICAgICAgICAgLy8gc3RhcnREYXkgPiBlbmRUb3RhbERheXNcbiAgICAgICAgICAgICAgICB0b3RhbERheXMgPSAoc3RhcnREYXkgPiBlbmRUb3RhbERheXMpP1xuICAgICAgICAgICAgICAgICAgICBlbmRUb3RhbERheXMgKyBiYXNlRGF5ICsgMSA6IHN0YXJ0RGF5ICsgYmFzZURheTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZnJhY3Rpb25hbCBpcyBvbmx5IGJhc2VkIG9uIGVuZE1vbnRoIGVnOiBKYW4gMTIgLSBGZWIgMThcbiAgICAgICAgICAgICAgICAvLyAoNiBmcmFjdGlvbmFsIGRheXMsIDI4IGRheXMgdW50aWwgbmV4dCBmdWxsIG1vbnRoKVxuICAgICAgICAgICAgICAgIGRheXNFbGFwc2VkID0gZW5kRGF5IC0gc3RhcnREYXk7XG4gICAgICAgICAgICAgICAgdG90YWxEYXlzID0gZW5kVG90YWxEYXlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFjdGlvbmFsRGlmZiA9IGRheXNFbGFwc2VkIC8gdG90YWxEYXlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyYWN0aW9uYWxEaWZmO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbFllYXIoc3RhcnQsIGVuZCwgZWxhcHNlZFllYXJzKXtcbiAgICAgICAgdmFyIGJhc2UgPSBlbGFwc2VkWWVhcnM/XG4gICAgICAgICAgICBuZXcgRGF0ZShlbmQuZ2V0RnVsbFllYXIoKSwgc3RhcnQuZ2V0TW9udGgoKSwgc3RhcnQuZ2V0RGF0ZSgpKSA6XG4gICAgICAgICAgICBzdGFydDtcbiAgICAgICAgdmFyIGVsYXBzZWREYXlzID0gZGlmZihiYXNlLCBlbmQsICdkYXknKTtcbiAgICAgICAgcmV0dXJuIGVsYXBzZWREYXlzIC8gdG90YWxEYXlzSW5ZZWFyKGVuZCk7XG4gICAgfVxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRpZmY7XG5cblxuIiwiXG4gICAgLy8gZW4tVVMgKEVuZ2xpc2gsIFVuaXRlZCBTdGF0ZXMpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIFwiYW1cIiA6IFwiQU1cIixcbiAgICAgICAgXCJwbVwiIDogXCJQTVwiLFxuXG4gICAgICAgIFwieFwiOiBcIiVtLyVkLyV5XCIsXG4gICAgICAgIFwiWFwiOiBcIiVIOiVNOiVTXCIsXG4gICAgICAgIFwiY1wiOiBcIiVhICVkICViICVZICVJOiVNOiVTICVwICVaXCIsXG5cbiAgICAgICAgXCJtb250aHNcIiA6IFtcbiAgICAgICAgICAgIFwiSmFudWFyeVwiLFxuICAgICAgICAgICAgXCJGZWJydWFyeVwiLFxuICAgICAgICAgICAgXCJNYXJjaFwiLFxuICAgICAgICAgICAgXCJBcHJpbFwiLFxuICAgICAgICAgICAgXCJNYXlcIixcbiAgICAgICAgICAgIFwiSnVuZVwiLFxuICAgICAgICAgICAgXCJKdWx5XCIsXG4gICAgICAgICAgICBcIkF1Z3VzdFwiLFxuICAgICAgICAgICAgXCJTZXB0ZW1iZXJcIixcbiAgICAgICAgICAgIFwiT2N0b2JlclwiLFxuICAgICAgICAgICAgXCJOb3ZlbWJlclwiLFxuICAgICAgICAgICAgXCJEZWNlbWJlclwiXG4gICAgICAgIF0sXG5cbiAgICAgICAgXCJtb250aHNfYWJiclwiIDogW1xuICAgICAgICAgICAgXCJKYW5cIixcbiAgICAgICAgICAgIFwiRmViXCIsXG4gICAgICAgICAgICBcIk1hclwiLFxuICAgICAgICAgICAgXCJBcHJcIixcbiAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICBcIkp1blwiLFxuICAgICAgICAgICAgXCJKdWxcIixcbiAgICAgICAgICAgIFwiQXVnXCIsXG4gICAgICAgICAgICBcIlNlcFwiLFxuICAgICAgICAgICAgXCJPY3RcIixcbiAgICAgICAgICAgIFwiTm92XCIsXG4gICAgICAgICAgICBcIkRlY1wiXG4gICAgICAgIF0sXG5cbiAgICAgICAgXCJkYXlzXCIgOiBbXG4gICAgICAgICAgICBcIlN1bmRheVwiLFxuICAgICAgICAgICAgXCJNb25kYXlcIixcbiAgICAgICAgICAgIFwiVHVlc2RheVwiLFxuICAgICAgICAgICAgXCJXZWRuZXNkYXlcIixcbiAgICAgICAgICAgIFwiVGh1cnNkYXlcIixcbiAgICAgICAgICAgIFwiRnJpZGF5XCIsXG4gICAgICAgICAgICBcIlNhdHVyZGF5XCJcbiAgICAgICAgXSxcblxuICAgICAgICBcImRheXNfYWJiclwiIDogW1xuICAgICAgICAgICAgXCJTdW5cIixcbiAgICAgICAgICAgIFwiTW9uXCIsXG4gICAgICAgICAgICBcIlR1ZVwiLFxuICAgICAgICAgICAgXCJXZWRcIixcbiAgICAgICAgICAgIFwiVGh1XCIsXG4gICAgICAgICAgICBcIkZyaVwiLFxuICAgICAgICAgICAgXCJTYXRcIlxuICAgICAgICBdXG4gICAgfTtcblxuIiwidmFyIG1peEluID0gcmVxdWlyZSgnLi4vb2JqZWN0L21peEluJyk7XG52YXIgZW5VUyA9IHJlcXVpcmUoJy4vaTE4bi9lbi1VUycpO1xuXG4gICAgLy8gd2UgYWxzbyB1c2UgbWl4SW4gdG8gbWFrZSBzdXJlIHdlIGRvbid0IGFmZmVjdCB0aGUgb3JpZ2luYWwgbG9jYWxlXG4gICAgdmFyIGFjdGl2ZUxvY2FsZSA9IG1peEluKHt9LCBlblVTLCB7XG4gICAgICAgIC8vIHdlIGV4cG9zZSBhIFwic2V0XCIgbWV0aG9kIHRvIGFsbG93IG92ZXJyaWRpbmcgdGhlIGdsb2JhbCBsb2NhbGVcbiAgICAgICAgc2V0IDogZnVuY3Rpb24obG9jYWxlRGF0YSl7XG4gICAgICAgICAgICBtaXhJbihhY3RpdmVMb2NhbGUsIGxvY2FsZURhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGFjdGl2ZUxvY2FsZTtcblxuXG4iLCJ2YXIgaXNEYXRlID0gcmVxdWlyZSgnLi4vbGFuZy9pc0RhdGUnKTtcblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyBpZiBpdCdzIGEgbGVhcCB5ZWFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcihmdWxsWWVhcil7XG4gICAgICAgIGlmIChpc0RhdGUoZnVsbFllYXIpKSB7XG4gICAgICAgICAgICBmdWxsWWVhciA9IGZ1bGxZZWFyLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bGxZZWFyICUgNDAwID09PSAwIHx8IChmdWxsWWVhciAlIDEwMCAhPT0gMCAmJiBmdWxsWWVhciAlIDQgPT09IDApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNMZWFwWWVhcjtcblxuXG4iLCJ2YXIgc3RhcnRPZiA9IHJlcXVpcmUoJy4vc3RhcnRPZicpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZGF0ZSBpcyBcInNhbWVcIiB3aXRoIG9wdGlvbmFsIHBlcmlvZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FtZShkYXRlMSwgZGF0ZTIsIHBlcmlvZCl7XG4gICAgICAgIGlmIChwZXJpb2QpIHtcbiAgICAgICAgICAgIGRhdGUxID0gc3RhcnRPZihkYXRlMSwgcGVyaW9kKTtcbiAgICAgICAgICAgIGRhdGUyID0gc3RhcnRPZihkYXRlMiwgcGVyaW9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyKGRhdGUxKSA9PT0gTnVtYmVyKGRhdGUyKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzU2FtZTtcblxuXG4iLCJ2YXIgc29tZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NvbWUnKTtcblxuICAgIHZhciBkYXRlUGF0dGVybnMgPSBbXG4gICAgICAgIC9eKFswLTldezR9KSQvLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlZWVlcbiAgICAgICAgL14oWzAtOV17NH0pLShbMC05XXsyfSkkLywgICAgICAgICAgICAgLy8gWVlZWS1NTSAoWVlZWU1NIG5vdCBhbGxvd2VkKVxuICAgICAgICAvXihbMC05XXs0fSktPyhbMC05XXsyfSktPyhbMC05XXsyfSkkLyAvLyBZWVlZLU1NLUREIG9yIFlZWVlNTUREXG4gICAgXTtcbiAgICB2YXIgT1JEX0RBVEUgPSAvXihbMC05XXs0fSktPyhbMC05XXszfSkkLzsgLy8gWVlZWS1ERERcblxuICAgIHZhciB0aW1lUGF0dGVybnMgPSBbXG4gICAgICAgIC9eKFswLTldezJ9KD86XFwuWzAtOV0qKT8pJC8sICAgICAgICAgICAgICAgICAgICAgIC8vIEhILmhoXG4gICAgICAgIC9eKFswLTldezJ9KTo/KFswLTldezJ9KD86XFwuWzAtOV0qKT8pJC8sICAgICAgICAgIC8vIEhIOk1NLm1tXG4gICAgICAgIC9eKFswLTldezJ9KTo/KFswLTldezJ9KTo/KFswLTldezJ9KFxcLlswLTldKik/KSQvIC8vIEhIOk1NOlNTLnNzXG4gICAgXTtcblxuICAgIHZhciBEQVRFX1RJTUUgPSAvXiguKylUKC4rKSQvO1xuICAgIHZhciBUSU1FX1pPTkUgPSAvXiguKykoWytcXC1dKShbMC05XXsyfSk6PyhbMC05XXsyfSkkLztcblxuICAgIGZ1bmN0aW9uIG1hdGNoQWxsKHN0ciwgcGF0dGVybnMpIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICB2YXIgZm91bmQgPSBzb21lKHBhdHRlcm5zLCBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gISEobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3VuZCA/IG1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG5cbiAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgeWVhciB0byBhdm9pZCBEYXRlLlVUQyBtYWtpbmcgZGF0ZXMgPCAxMDAgcmVsYXRpdmUgdG9cbiAgICAgICAgLy8gMTkwMFxuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuXG4gICAgICAgIHZhciB2YWxpZCA9XG4gICAgICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiZcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSA9PT0gbW9udGggJiZcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDRGF0ZSgpID09PSBkYXk7XG4gICAgICAgIHJldHVybiB2YWxpZCA/ICtkYXRlIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3JkaW5hbERhdGUoc3RyKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IE9SRF9EQVRFLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKG1hdGNoICkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSArbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgZGF5ID0gK21hdGNoWzJdLFxuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAwLCBkYXkpKTtcblxuICAgICAgICAgICAgaWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PT0geWVhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiArZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VEYXRlKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXk7XG5cbiAgICAgICAgbWF0Y2ggPSBtYXRjaEFsbChzdHIsIGRhdGVQYXR0ZXJucyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gT3JkaW5hbCBkYXRlcyBhcmUgdmVyaWZpZWQgZGlmZmVyZW50bHkuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPcmRpbmFsRGF0ZShzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeWVhciA9IChtYXRjaFsxXSA9PT0gdm9pZCAwKSA/IDAgOiArbWF0Y2hbMV07XG4gICAgICAgIG1vbnRoID0gKG1hdGNoWzJdID09PSB2b2lkIDApID8gMCA6ICttYXRjaFsyXSAtIDE7XG4gICAgICAgIGRheSA9IChtYXRjaFszXSA9PT0gdm9pZCAwKSA/IDEgOiArbWF0Y2hbM107XG5cbiAgICAgICAgcmV0dXJuIGdldERhdGUoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGltZShociwgbWluLCBzZWMpIHtcbiAgICAgICAgdmFyIHZhbGlkID1cbiAgICAgICAgICAgIChociA8IDI0ICYmIGhyID49IDAgJiZcbiAgICAgICAgICAgICBtaW4gPCA2MCAmJiBtaW4gPj0gMCAmJlxuICAgICAgICAgICAgIHNlYyA8IDYwICYmIG1pbiA+PSAwKSB8fFxuICAgICAgICAgICAgKGhyID09PSAyNCAmJiBtaW4gPT09IDAgJiYgc2VjID09PSAwKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKGhyICogNjAgKyBtaW4pICogNjAgKyBzZWMpICogMTAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9mZnNldChzdHIpIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICdaJykge1xuICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IFRJTUVfWk9ORS5leGVjKHN0cik7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG91cnMgPSArbWF0Y2hbM10sXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSAobWF0Y2hbNF0gPT09IHZvaWQgMCkgPyAwIDogK21hdGNoWzRdLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBnZXRUaW1lKGhvdXJzLCBtaW51dGVzLCAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCAqPSAtMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBvZmZzZXQ6IG9mZnNldCwgdGltZTogbWF0Y2hbMV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIHRpbWUgem9uZSBzcGVjaWZpZWQsIGFzc3VtZSBVVENcbiAgICAgICAgcmV0dXJuIHsgb2Zmc2V0OiAwLCB0aW1lOiBzdHIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRpbWUoc3RyKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlT2Zmc2V0KHN0cik7XG5cbiAgICAgICAgc3RyID0gb2Zmc2V0LnRpbWU7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldC5vZmZzZXQ7XG4gICAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2ggPSBtYXRjaEFsbChzdHIsIHRpbWVQYXR0ZXJucyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBob3VycyA9IChtYXRjaFsxXSA9PT0gdm9pZCAwKSA/IDAgOiArbWF0Y2hbMV0sXG4gICAgICAgICAgICBtaW51dGVzID0gKG1hdGNoWzJdID09PSB2b2lkIDApID8gMCA6ICttYXRjaFsyXSxcbiAgICAgICAgICAgIHNlY29uZHMgPSAobWF0Y2hbM10gPT09IHZvaWQgMCkgPyAwIDogK21hdGNoWzNdO1xuXG4gICAgICAgIHJldHVybiBnZXRUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSAtIG9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhbiBJU084NjAxIGZvcm1hdHRlZCBkYXRlIHN0cmluZywgYW5kIHJldHVybiBhIERhdGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSVNPODYwMShzdHIpe1xuICAgICAgICB2YXIgbWF0Y2ggPSBEQVRFX1RJTUUuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAvLyBObyB0aW1lIHNwZWNpZmllZFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGF0ZShzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRGF0ZShtYXRjaFsxXSkgKyBwYXJzZVRpbWUobWF0Y2hbMl0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGFyc2VJU084NjAxO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogZ2V0cyBkYXRlIHF1YXJ0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFydGVyKGRhdGUpe1xuICAgICAgICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIGlmIChtb250aCA8IDMpIHJldHVybiAxO1xuICAgICAgICBpZiAobW9udGggPCA2KSByZXR1cm4gMjtcbiAgICAgICAgaWYgKG1vbnRoIDwgOSkgcmV0dXJuIDM7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcXVhcnRlcjtcblxuXG4iLCJ2YXIgY2xvbmUgPSByZXF1aXJlKCcuLi9sYW5nL2Nsb25lJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSBuZXcgRGF0ZSBvYmplY3QgcmVwcmVzZW50aW5nIHN0YXJ0IG9mIHBlcmlvZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0T2YoZGF0ZSwgcGVyaW9kKXtcbiAgICAgICAgZGF0ZSA9IGNsb25lKGRhdGUpO1xuXG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgcmVtb3ZlZCBcImJyZWFrXCIgZnJvbSBzd2l0Y2ggc2luY2Ugc3RhcnQgb2ZcbiAgICAgICAgLy8gbW9udGgveWVhci9ldGMgc2hvdWxkIGFsc28gcmVzZXQgdGhlIGZvbGxvd2luZyBwZXJpb2RzXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBkYXRlLnNldE1vbnRoKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICBkYXRlLnNldEhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRNaW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICBkYXRlLnNldFNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJysgcGVyaW9kICsnXCIgaXMgbm90IGEgdmFsaWQgcGVyaW9kJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZWVrIGlzIHRoZSBvbmx5IGNhc2UgdGhhdCBzaG91bGQgcmVzZXQgdGhlIHdlZWtEYXkgYW5kIG1heWJlIGV2ZW5cbiAgICAgICAgLy8gb3ZlcmZsb3cgdG8gcHJldmlvdXMgbW9udGhcbiAgICAgICAgaWYgKHBlcmlvZCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB2YXIgd2Vla0RheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICB2YXIgYmFzZURhdGUgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrRGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtEYXkgPj0gYmFzZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9zdGFydCBvZiB0aGUgd2VlayBpcyBvbiBwcmV2aW91cyBtb250aFxuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGRhdGUuZ2V0RGF5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzdGFydE9mO1xuXG5cbiIsInZhciBwYWQgPSByZXF1aXJlKCcuLi9udW1iZXIvcGFkJyk7XG52YXIgbHBhZCA9IHJlcXVpcmUoJy4uL3N0cmluZy9scGFkJyk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vaTE4bl8nKTtcbnZhciBkYXlPZlRoZVllYXIgPSByZXF1aXJlKCcuL2RheU9mVGhlWWVhcicpO1xudmFyIHRpbWV6b25lT2Zmc2V0ID0gcmVxdWlyZSgnLi90aW1lem9uZU9mZnNldCcpO1xudmFyIHRpbWV6b25lQWJiciA9IHJlcXVpcmUoJy4vdGltZXpvbmVBYmJyJyk7XG52YXIgd2Vla09mVGhlWWVhciA9IHJlcXVpcmUoJy4vd2Vla09mVGhlWWVhcicpO1xuXG4gICAgdmFyIF9jb21iaW5hdGlvbnMgPSB7XG4gICAgICAgICdEJzogJyVtLyVkLyV5JyxcbiAgICAgICAgJ0YnOiAnJVktJW0tJWQnLFxuICAgICAgICAncic6ICclSTolTTolUyAlcCcsXG4gICAgICAgICdSJzogJyVIOiVNJyxcbiAgICAgICAgJ1QnOiAnJUg6JU06JVMnLFxuICAgICAgICAneCc6ICdsb2NhbGUnLFxuICAgICAgICAnWCc6ICdsb2NhbGUnLFxuICAgICAgICAnYyc6ICdsb2NhbGUnXG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogZm9ybWF0IGRhdGUgYmFzZWQgb24gc3RyZnRpbWUgZm9ybWF0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyZnRpbWUoZGF0ZSwgZm9ybWF0LCBsb2NhbGVEYXRhKXtcbiAgICAgICAgbG9jYWxlRGF0YSA9IGxvY2FsZURhdGEgIHx8IGkxOG47XG4gICAgICAgIHZhciByZVRva2VuID0gLyUoW2EteiVdKS9naTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlSXRlcmF0b3IoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihtYXRjaCwgdG9rZW4pe1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihkYXRlLCB0b2tlbiwgbG9jYWxlRGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdFxuICAgICAgICAgICAgLnJlcGxhY2UocmVUb2tlbiwgbWFrZUl0ZXJhdG9yKGV4cGFuZENvbWJpbmF0aW9ucykpXG4gICAgICAgICAgICAucmVwbGFjZShyZVRva2VuLCBtYWtlSXRlcmF0b3IoY29udmVydFRva2VuKSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBleHBhbmRDb21iaW5hdGlvbnMoZGF0ZSwgdG9rZW4sIGwxMG4pe1xuICAgICAgICBpZiAodG9rZW4gaW4gX2NvbWJpbmF0aW9ucykge1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gX2NvbWJpbmF0aW9uc1t0b2tlbl07XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kZWQgPT09ICdsb2NhbGUnPyBsMTBuW3Rva2VuXSA6IGV4cGFuZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICclJysgdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb2tlbihkYXRlLCB0b2tlbiwgbDEwbil7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pe1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwxMG4uZGF5c19hYmJyW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwxMG4uZGF5c1tkYXRlLmdldERheSgpXTtcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwxMG4ubW9udGhzX2FiYnJbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgICAgIHJldHVybiBsMTBuLm1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIDEwMCksIDIpO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSwgMik7XG4gICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKGRhdGUuZ2V0RGF0ZSgpLCAyLCAnICcpO1xuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldEhvdXJzKCksIDIpO1xuICAgICAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldEhvdXJzKCkgJSAxMiwgMik7XG4gICAgICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKGRheU9mVGhlWWVhcihkYXRlKSwgMyk7XG4gICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbHBhZChkYXRlLmdldEhvdXJzKCkgJSAxMiwgMik7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRNaW51dGVzKCksIDIpO1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKSA+PSAxMj8gbDEwbi5wbSA6IGwxMG4uYW07XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRva2VuKGRhdGUsICdwJywgbDEwbikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKGRhdGUuZ2V0U2Vjb25kcygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx0JztcbiAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXkgPT09IDA/IDcgOiBkYXk7XG4gICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKHdlZWtPZlRoZVllYXIoZGF0ZSksIDIpO1xuICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKHdlZWtPZlRoZVllYXIoZGF0ZSwgMSksIDIpO1xuICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWV6b25lT2Zmc2V0KGRhdGUpO1xuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWV6b25lQWJicihkYXRlKTtcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGtlZXAgdW5yZWNvZ25pemVkIHRva2Vuc1xuICAgICAgICAgICAgICAgIHJldHVybiAnJScrIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0cmZ0aW1lO1xuXG5cbiIsInZhciB0aW1lem9uZU9mZnNldCA9IHJlcXVpcmUoJy4vdGltZXpvbmVPZmZzZXQnKTtcblxuICAgIC8qKlxuICAgICAqIEFiYnJldmlhdGVkIHRpbWUgem9uZSBuYW1lIG9yIHNpbWlsYXIgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXpvbmVBYmJyKGRhdGUpe1xuICAgICAgICAvLyBEYXRlLnRvU3RyaW5nIGdpdmVzIGRpZmZlcmVudCByZXN1bHRzIGRlcGVuZGluZyBvbiB0aGVcbiAgICAgICAgLy8gYnJvd3Nlci9zeXN0ZW0gc28gd2UgZmFsbGJhY2sgdG8gdGltZXpvbmUgb2Zmc2V0XG4gICAgICAgIC8vIGNocm9tZTogJ01vbiBBcHIgMDggMjAxMyAwOTowMjowNCBHTVQtMDMwMCAoQlJUKSdcbiAgICAgICAgLy8gSUU6ICdNb24gQXByIDggMDk6MDI6MDQgVVRDLTAzMDAgMjAxMydcbiAgICAgICAgdmFyIHR6ID0gL1xcKChbQS1aXXszLDR9KVxcKS8uZXhlYyhkYXRlLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdHo/IHR6WzFdIDogdGltZXpvbmVPZmZzZXQoZGF0ZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW1lem9uZUFiYnI7XG5cblxuIiwidmFyIHBhZCA9IHJlcXVpcmUoJy4uL251bWJlci9wYWQnKTtcblxuICAgIC8qKlxuICAgICAqIHRpbWUgem9uZSBhcyBob3VyIGFuZCBtaW51dGUgb2Zmc2V0IGZyb20gVVRDIChlLmcuICswOTAwKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWV6b25lT2Zmc2V0KGRhdGUpe1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgICAgICAgdmFyIGggPSBwYWQoTWF0aC5mbG9vcihhYnMgLyA2MCksIDIpO1xuICAgICAgICB2YXIgbSA9IHBhZChhYnMgJSA2MCwgMik7XG4gICAgICAgIHJldHVybiAob2Zmc2V0ID4gMD8gJy0nIDogJysnKSArIGggKyBtO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdGltZXpvbmVPZmZzZXQ7XG5cblxuIiwidmFyIGlzRGF0ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNEYXRlJyk7XG52YXIgaXNMZWFwWWVhciA9IHJlcXVpcmUoJy4vaXNMZWFwWWVhcicpO1xuXG4gICAgdmFyIERBWVNfSU5fTU9OVEggPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSB0b3RhbCBhbW91bnQgb2YgZGF5cyBpbiB0aGUgbW9udGggKGNvbnNpZGVyaW5nIGxlYXAgeWVhcnMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG90YWxEYXlzSW5Nb250aChmdWxsWWVhciwgbW9udGhJbmRleCl7XG4gICAgICAgIGlmIChpc0RhdGUoZnVsbFllYXIpKSB7XG4gICAgICAgICAgICBtb250aEluZGV4ID0gZnVsbFllYXIuZ2V0TW9udGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb250aEluZGV4ID09PSAxICYmIGlzTGVhcFllYXIoZnVsbFllYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gMjk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gREFZU19JTl9NT05USFttb250aEluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdG90YWxEYXlzSW5Nb250aDtcblxuXG4iLCJ2YXIgaXNMZWFwWWVhciA9IHJlcXVpcmUoJy4vaXNMZWFwWWVhcicpO1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBhbW91bnQgb2YgZGF5cyBpbiB0aGUgeWVhciBmb2xsb3dpbmcgdGhlIGdyZWdvcmlhbiBjYWxlbmRhclxuICAgICAqIGFuZCBsZWFwIHllYXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG90YWxEYXlzSW5ZZWFyKGZ1bGxZZWFyKXtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoZnVsbFllYXIpPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b3RhbERheXNJblllYXI7XG5cblxuIiwidmFyIGRheU9mVGhlWWVhciA9IHJlcXVpcmUoJy4vZGF5T2ZUaGVZZWFyJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHdlZWsgb2YgdGhlIHllYXIgYmFzZWQgb24gZ2l2ZW4gZmlyc3REYXlPZldlZWtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWVrT2ZUaGVZZWFyKGRhdGUsIGZpcnN0RGF5T2ZXZWVrKXtcbiAgICAgICAgZmlyc3REYXlPZldlZWsgPSBmaXJzdERheU9mV2VlayA9PSBudWxsPyAwIDogZmlyc3REYXlPZldlZWs7XG4gICAgICAgIHZhciBkb3kgPSBkYXlPZlRoZVllYXIoZGF0ZSk7XG4gICAgICAgIHZhciBkb3cgPSAoNyArIGRhdGUuZ2V0RGF5KCkgLSBmaXJzdERheU9mV2VlaykgJSA3O1xuICAgICAgICB2YXIgcmVsYXRpdmVXZWVrRGF5ID0gNiAtIGZpcnN0RGF5T2ZXZWVrIC0gZG93O1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoZG95ICsgcmVsYXRpdmVXZWVrRGF5KSAvIDcpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gd2Vla09mVGhlWWVhcjtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2F3YWl0RGVsYXknIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9hd2FpdERlbGF5JyksXG4gICAgJ2JpbmQnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9iaW5kJyksXG4gICAgJ2NvbXBvc2UnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wb3NlJyksXG4gICAgJ2NvbnN0YW50JyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uc3RhbnQnKSxcbiAgICAnZGVib3VuY2UnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9kZWJvdW5jZScpLFxuICAgICdmdW5jJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vZnVuYycpLFxuICAgICdpZGVudGl0eScgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL2lkZW50aXR5JyksXG4gICAgJ21ha2VJdGVyYXRvcl8nIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyksXG4gICAgJ3BhcnRpYWwnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9wYXJ0aWFsJyksXG4gICAgJ3Byb3AnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9wJyksXG4gICAgJ3NlcmllcycgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL3NlcmllcycpLFxuICAgICd0aHJvdHRsZScgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL3Rocm90dGxlJyksXG4gICAgJ3RpbWVvdXQnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi90aW1lb3V0JyksXG4gICAgJ3RpbWVzJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vdGltZXMnKSxcbiAgICAnd3JhcCcgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL3dyYXAnKVxufTtcblxuXG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgnLi4vdGltZS9ub3cnKTtcbnZhciB0aW1lb3V0ID0gcmVxdWlyZSgnLi90aW1lb3V0Jyk7XG52YXIgYXBwZW5kID0gcmVxdWlyZSgnLi4vYXJyYXkvYXBwZW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSBtaW5pbXVtIGRlbGF5IGZvciBjYWxsYmFja3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhd2FpdERlbGF5KCBjYWxsYmFjaywgZGVsYXkgKXtcbiAgICAgICAgdmFyIGJhc2VUaW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGFsbCBicm93c2VycyB3aWxsIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkgKGF2b2lkIGhhcmRcbiAgICAgICAgICAgIC8vIHRvIGNhdGNoIGVycm9ycykgbm90IHVzaW5nIFwiMFwiIGJlY2F1c2Ugb2Ygb2xkIGJyb3dzZXJzIGFuZCBhbHNvXG4gICAgICAgICAgICAvLyBzaW5jZSBuZXcgYnJvd3NlcnMgaW5jcmVhc2UgdGhlIHZhbHVlIHRvIGJlIGF0IGxlYXN0IFwiNFwiXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aW1lcnMuaHRtbCNkb20td2luZG93dGltZXJzLXNldHRpbWVvdXRcbiAgICAgICAgICAgIHZhciBtcyA9IE1hdGgubWF4KGJhc2VUaW1lIC0gbm93KCksIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXQuYXBwbHkodGhpcywgYXBwZW5kKFtjYWxsYmFjaywgbXMsIHRoaXNdLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGF3YWl0RGVsYXk7XG5cblxuIiwidmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIGluIHRoZSBnaXZlbiBjb250ZXh0LCBvcHRpb25hbGx5IGFkZGluZyBhbnkgYWRkaXRpb25hbCBzdXBwbGllZCBwYXJhbWV0ZXJzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZ3VtZW50cyBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICBGdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAgIEV4ZWN1dGlvbiBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7cmVzdH0gYXJncyAgICBBcmd1bWVudHMgKDAuLi5uIGFyZ3VtZW50cykuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFdyYXBwZWQgRnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmbiwgY29udGV4dCwgYXJncyl7XG4gICAgICAgIHZhciBhcmdzQXJyID0gc2xpY2UoYXJndW1lbnRzLCAyKTsgLy9jdXJyaWVkIGFyZ3NcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJnc0Fyci5jb25jYXQoc2xpY2UoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmluZDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNvbXBvc2VzIG11bHRpcGxlIGZ1bmN0aW9ucywgcGFzc2luZyByZXN1bHRzIHRvXG4gICAgICogZWFjaCBvdGhlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKXtcbiAgICAgICAgICAgIC8vIG9ubHkgY2FyZXMgYWJvdXQgdGhlIGZpcnN0IGFyZ3VtZW50IHNpbmNlIHRoZSBjaGFpbiBjYW4gb25seVxuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGEgc2luZ2xlIHJldHVybiB2YWx1ZSBhbnl3YXkuIEl0IHNob3VsZCBzdGFydCBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCBmbi5cbiAgICAgICAgICAgIHZhciBuID0gZm5zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICBhcmcgPSBmbnNbbl0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgIH07XG4gICAgIH1cblxuICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbXBvc2U7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIERlYm91bmNlIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZuLCB0aHJlc2hvbGQsIGlzQXNhcCl7XG4gICAgICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG4gICAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpe1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVsYXllZCgpe1xuICAgICAgICAgICAgICAgIGlmICghIGlzQXNhcCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBc2FwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkZWxheWVkLCB0aHJlc2hvbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkZWJvdW5jZWQuY2FuY2VsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FsbCBhIG1ldGhvZCBvbiB0aGUgcGFzc2VkIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmMobmFtZSl7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmope1xuICAgICAgICAgICAgcmV0dXJuIG9ialtuYW1lXSgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuYztcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbCl7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxuXG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG52YXIgcHJvcCA9IHJlcXVpcmUoJy4vcHJvcCcpO1xudmFyIGRlZXBNYXRjaGVzID0gcmVxdWlyZSgnLi4vb2JqZWN0L2RlZXBNYXRjaGVzJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhcmd1bWVudCBpbnRvIGEgdmFsaWQgaXRlcmF0b3IuXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IG9uIG1vc3QgYXJyYXkvb2JqZWN0L2NvbGxlY3Rpb24gbWV0aG9kcyB0aGF0IHJlY2VpdmVzIGFcbiAgICAgKiBjYWxsYmFjay9pdGVyYXRvciBwcm92aWRpbmcgYSBzaG9ydGN1dCBzeW50YXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUl0ZXJhdG9yKHNyYywgdGhpc09iail7XG4gICAgICAgIGlmIChzcmMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCh0eXBlb2Ygc3JjKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gaXMgdGhlIGZpcnN0IHRvIGltcHJvdmUgcGVyZiAobW9zdCBjb21tb24gY2FzZSlcbiAgICAgICAgICAgICAgICAvLyBhbHNvIGF2b2lkIHVzaW5nIGBGdW5jdGlvbiNjYWxsYCBpZiBub3QgbmVlZGVkLCB3aGljaCBib29zdHNcbiAgICAgICAgICAgICAgICAvLyBwZXJmIGEgbG90IGluIHNvbWUgY2FzZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB0aGlzT2JqICE9PSAndW5kZWZpbmVkJyk/IGZ1bmN0aW9uKHZhbCwgaSwgYXJyKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNyYy5jYWxsKHRoaXNPYmosIHZhbCwgaSwgYXJyKTtcbiAgICAgICAgICAgICAgICB9IDogc3JjO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZXBNYXRjaGVzKHZhbCwgc3JjKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3Aoc3JjKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUl0ZXJhdG9yO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChmKSB7XG4gICAgICAgIHZhciBhcyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXMuY29uY2F0KHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbaV0gPT09IHBhcnRpYWwuXykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJncy5zcGxpY2UoLTEpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnRpYWwuXyA9IHt9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJ0aWFsO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBhIHByb3BlcnR5IG9mIHRoZSBwYXNzZWQgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcChuYW1lKXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iail7XG4gICAgICAgICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcHJvcDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBhIGxpc3Qgb2YgZnVuY3Rpb25zIGluIHNlcXVlbmNlXG4gICAgICogcGFzc2luZyB0aGUgc2FtZSBhcmd1bWVudHMgdG8gZWFjaCBvbmUuICh1c2VmdWwgZm9yIGJhdGNoIHByb2Nlc3NpbmdcbiAgICAgKiBpdGVtcyBkdXJpbmcgYSBmb3JFYWNoIGxvb3ApXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VyaWVzKCl7XG4gICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIG4gPSBmbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgICAgICAgICAgZm5zW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc2VyaWVzO1xuXG5cbiIsInZhciBub3cgPSByZXF1aXJlKCcuLi90aW1lL25vdycpO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIGRlbGF5KXtcbiAgICAgICAgdmFyIGNvbnRleHQsIHRpbWVvdXQsIHJlc3VsdCwgYXJncyxcbiAgICAgICAgICAgIGRpZmYsIHByZXZDYWxsID0gMDtcbiAgICAgICAgZnVuY3Rpb24gZGVsYXllZCgpe1xuICAgICAgICAgICAgcHJldkNhbGwgPSBub3coKTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGhyb3R0bGVkKCl7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBkaWZmID0gZGVsYXkgLSAobm93KCkgLSBwcmV2Q2FsbCk7XG4gICAgICAgICAgICBpZiAoZGlmZiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGRlbGF5ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoISB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZGVsYXllZCwgZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhyb3R0bGVkO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG5cblxuIiwidmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIERlbGF5cyB0aGUgY2FsbCBvZiBhIGZ1bmN0aW9uIHdpdGhpbiBhIGdpdmVuIGNvbnRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZW91dChmbiwgbWlsbGlzLCBjb250ZXh0KXtcblxuICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSwgbWlsbGlzKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRpbWVvdXQ7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgY2FsbGJhY2sgYSBzZXQgYW1vdW50IG9mIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNPYmope1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgaWYgKCBjYWxsYmFjay5jYWxsKHRoaXNPYmosIGkpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdGltZXM7XG5cblxuIiwidmFyIHBhcnRpYWwgPSByZXF1aXJlKCcuL3BhcnRpYWwnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAgICAqIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAoZm4sIHdyYXBwZXIpe1xuICAgICAgICByZXR1cm4gcGFydGlhbCh3cmFwcGVyLCBmbik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3cmFwO1xuXG5cbiIsIi8qKkBsaWNlbnNlXG4gKiBtb3V0IHYwLjExLjAgfCBodHRwOi8vbW91dGpzLmNvbSB8IE1JVCBsaWNlbnNlXG4gKi9cblxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnVkVSU0lPTicgOiAnMC4xMS4wJyxcbiAgICAnYXJyYXknIDogcmVxdWlyZSgnLi9hcnJheScpLFxuICAgICdjb2xsZWN0aW9uJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpLFxuICAgICdkYXRlJyA6IHJlcXVpcmUoJy4vZGF0ZScpLFxuICAgICdmdW5jdGlvbicgOiByZXF1aXJlKCcuL2Z1bmN0aW9uJyksXG4gICAgJ2xhbmcnIDogcmVxdWlyZSgnLi9sYW5nJyksXG4gICAgJ21hdGgnIDogcmVxdWlyZSgnLi9tYXRoJyksXG4gICAgJ251bWJlcicgOiByZXF1aXJlKCcuL251bWJlcicpLFxuICAgICdvYmplY3QnIDogcmVxdWlyZSgnLi9vYmplY3QnKSxcbiAgICAncXVlcnlTdHJpbmcnIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZycpLFxuICAgICdyYW5kb20nIDogcmVxdWlyZSgnLi9yYW5kb20nKSxcbiAgICAnc3RyaW5nJyA6IHJlcXVpcmUoJy4vc3RyaW5nJyksXG4gICAgJ3RpbWUnIDogcmVxdWlyZSgnLi90aW1lJyksXG4gICAgJ2ZuJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24nKVxufTtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ0dMT0JBTCcgOiByZXF1aXJlKCcuL2xhbmcvR0xPQkFMJyksXG4gICAgJ2Nsb25lJyA6IHJlcXVpcmUoJy4vbGFuZy9jbG9uZScpLFxuICAgICdjcmVhdGVPYmplY3QnIDogcmVxdWlyZSgnLi9sYW5nL2NyZWF0ZU9iamVjdCcpLFxuICAgICdjdG9yQXBwbHknIDogcmVxdWlyZSgnLi9sYW5nL2N0b3JBcHBseScpLFxuICAgICdkZWVwQ2xvbmUnIDogcmVxdWlyZSgnLi9sYW5nL2RlZXBDbG9uZScpLFxuICAgICdkZWVwRXF1YWxzJyA6IHJlcXVpcmUoJy4vbGFuZy9kZWVwRXF1YWxzJyksXG4gICAgJ2RlZmF1bHRzJyA6IHJlcXVpcmUoJy4vbGFuZy9kZWZhdWx0cycpLFxuICAgICdpbmhlcml0UHJvdG90eXBlJyA6IHJlcXVpcmUoJy4vbGFuZy9pbmhlcml0UHJvdG90eXBlJyksXG4gICAgJ2lzJyA6IHJlcXVpcmUoJy4vbGFuZy9pcycpLFxuICAgICdpc0FyZ3VtZW50cycgOiByZXF1aXJlKCcuL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICAnaXNBcnJheScgOiByZXF1aXJlKCcuL2xhbmcvaXNBcnJheScpLFxuICAgICdpc0Jvb2xlYW4nIDogcmVxdWlyZSgnLi9sYW5nL2lzQm9vbGVhbicpLFxuICAgICdpc0RhdGUnIDogcmVxdWlyZSgnLi9sYW5nL2lzRGF0ZScpLFxuICAgICdpc0VtcHR5JyA6IHJlcXVpcmUoJy4vbGFuZy9pc0VtcHR5JyksXG4gICAgJ2lzRmluaXRlJyA6IHJlcXVpcmUoJy4vbGFuZy9pc0Zpbml0ZScpLFxuICAgICdpc0Z1bmN0aW9uJyA6IHJlcXVpcmUoJy4vbGFuZy9pc0Z1bmN0aW9uJyksXG4gICAgJ2lzSW50ZWdlcicgOiByZXF1aXJlKCcuL2xhbmcvaXNJbnRlZ2VyJyksXG4gICAgJ2lzS2luZCcgOiByZXF1aXJlKCcuL2xhbmcvaXNLaW5kJyksXG4gICAgJ2lzTmFOJyA6IHJlcXVpcmUoJy4vbGFuZy9pc05hTicpLFxuICAgICdpc051bGwnIDogcmVxdWlyZSgnLi9sYW5nL2lzTnVsbCcpLFxuICAgICdpc051bWJlcicgOiByZXF1aXJlKCcuL2xhbmcvaXNOdW1iZXInKSxcbiAgICAnaXNPYmplY3QnIDogcmVxdWlyZSgnLi9sYW5nL2lzT2JqZWN0JyksXG4gICAgJ2lzUGxhaW5PYmplY3QnIDogcmVxdWlyZSgnLi9sYW5nL2lzUGxhaW5PYmplY3QnKSxcbiAgICAnaXNQcmltaXRpdmUnIDogcmVxdWlyZSgnLi9sYW5nL2lzUHJpbWl0aXZlJyksXG4gICAgJ2lzUmVnRXhwJyA6IHJlcXVpcmUoJy4vbGFuZy9pc1JlZ0V4cCcpLFxuICAgICdpc1N0cmluZycgOiByZXF1aXJlKCcuL2xhbmcvaXNTdHJpbmcnKSxcbiAgICAnaXNVbmRlZmluZWQnIDogcmVxdWlyZSgnLi9sYW5nL2lzVW5kZWZpbmVkJyksXG4gICAgJ2lzbnQnIDogcmVxdWlyZSgnLi9sYW5nL2lzbnQnKSxcbiAgICAna2luZE9mJyA6IHJlcXVpcmUoJy4vbGFuZy9raW5kT2YnKSxcbiAgICAndG9BcnJheScgOiByZXF1aXJlKCcuL2xhbmcvdG9BcnJheScpLFxuICAgICd0b051bWJlcicgOiByZXF1aXJlKCcuL2xhbmcvdG9OdW1iZXInKSxcbiAgICAndG9TdHJpbmcnIDogcmVxdWlyZSgnLi9sYW5nL3RvU3RyaW5nJylcbn07XG5cblxuIiwiXG5cbiAgICAvLyBSZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBjb250ZXh0ICh3b3JrcyBvbiBFUzMgYW5kIEVTNS1zdHJpY3QgbW9kZSlcbiAgICAvL2pzaGludCAtVzA2MSwgLVcwNjRcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cblxuIiwidmFyIGtpbmRPZiA9IHJlcXVpcmUoJy4va2luZE9mJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpO1xudmFyIG1peEluID0gcmVxdWlyZSgnLi4vb2JqZWN0L21peEluJyk7XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSBuYXRpdmUgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsKXtcbiAgICAgICAgc3dpdGNoIChraW5kT2YodmFsKSkge1xuICAgICAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVPYmplY3QodmFsKTtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheSh2YWwpO1xuICAgICAgICAgICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAodmFsKTtcbiAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGUodmFsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lT2JqZWN0KHNvdXJjZSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4SW4oe30sIHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocikge1xuICAgICAgICB2YXIgZmxhZ3MgPSAnJztcbiAgICAgICAgZmxhZ3MgKz0gci5tdWx0aWxpbmUgPyAnbScgOiAnJztcbiAgICAgICAgZmxhZ3MgKz0gci5nbG9iYWwgPyAnZycgOiAnJztcbiAgICAgICAgZmxhZ3MgKz0gci5pZ25vcmVDYXNlID8gJ2knIDogJyc7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHIuc291cmNlLCBmbGFncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCtkYXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gYXJyLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuXG4iLCJ2YXIgbWl4SW4gPSByZXF1aXJlKCcuLi9vYmplY3QvbWl4SW4nKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBPYmplY3QgdXNpbmcgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgc2V0dGluZyBjdXN0b20gcHJvcGVydGllcy5cbiAgICAgKiAtIE1peCBiZXR3ZWVuIERvdWdsYXMgQ3JvY2tmb3JkIFByb3RvdHlwYWwgSW5oZXJpdGFuY2UgPGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vcHJvdG90eXBhbC5odG1sPiBhbmQgdGhlIEVjbWFTY3JpcHQgNSBgT2JqZWN0LmNyZWF0ZSgpYCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudCAgICBQYXJlbnQgT2JqZWN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdIE9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ3JlYXRlZCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0KHBhcmVudCwgcHJvcHMpe1xuICAgICAgICBmdW5jdGlvbiBGKCl7fVxuICAgICAgICBGLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIG1peEluKG5ldyBGKCksIHByb3BzKTtcblxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU9iamVjdDtcblxuXG4iLCJcblxuICAgIGZ1bmN0aW9uIEYoKXt9XG5cbiAgICAvKipcbiAgICAgKiBEbyBmbi5hcHBseSBvbiBhIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN0b3JBcHBseShjdG9yLCBhcmdzKSB7XG4gICAgICAgIEYucHJvdG90eXBlID0gY3Rvci5wcm90b3R5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBGKCk7XG4gICAgICAgIGN0b3IuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjdG9yQXBwbHk7XG5cblxuIiwidmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xudmFyIGZvck93biA9IHJlcXVpcmUoJy4uL29iamVjdC9mb3JPd24nKTtcbnZhciBraW5kT2YgPSByZXF1aXJlKCcuL2tpbmRPZicpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNsb25lIG5hdGl2ZSB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwQ2xvbmUodmFsLCBpbnN0YW5jZUNsb25lKSB7XG4gICAgICAgIHN3aXRjaCAoIGtpbmRPZih2YWwpICkge1xuICAgICAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVPYmplY3QodmFsLCBpbnN0YW5jZUNsb25lKTtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheSh2YWwsIGluc3RhbmNlQ2xvbmUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUodmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lT2JqZWN0KHNvdXJjZSwgaW5zdGFuY2VDbG9uZSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgICAgICBmb3JPd24oc291cmNlLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IGRlZXBDbG9uZSh2YWwsIGluc3RhbmNlQ2xvbmUpO1xuICAgICAgICAgICAgfSwgb3V0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2VDbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlQ2xvbmUoc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5KGFyciwgaW5zdGFuY2VDbG9uZSkge1xuICAgICAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIHZhbDtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGRlZXBDbG9uZShhcnJbaV0sIGluc3RhbmNlQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWVwQ2xvbmU7XG5cblxuXG4iLCJ2YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xudmFyIG9iakVxdWFscyA9IHJlcXVpcmUoJy4uL29iamVjdC9lcXVhbHMnKTtcbnZhciBhcnJFcXVhbHMgPSByZXF1aXJlKCcuLi9hcnJheS9lcXVhbHMnKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNoZWNrcyBmb3Igc2FtZSBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVlcEVxdWFscyhhLCBiLCBjYWxsYmFjayl7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgaXM7XG5cbiAgICAgICAgdmFyIGJvdGhPYmplY3RzID0gaXNPYmplY3QoYSkgJiYgaXNPYmplY3QoYik7XG4gICAgICAgIHZhciBib3RoQXJyYXlzID0gIWJvdGhPYmplY3RzICYmIGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKTtcblxuICAgICAgICBpZiAoIWJvdGhPYmplY3RzICYmICFib3RoQXJyYXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpe1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBFcXVhbHMoYSwgYiwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldGhvZCA9IGJvdGhPYmplY3RzID8gb2JqRXF1YWxzIDogYXJyRXF1YWxzO1xuICAgICAgICByZXR1cm4gbWV0aG9kKGEsIGIsIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVlcEVxdWFscztcblxuXG4iLCJ2YXIgdG9BcnJheSA9IHJlcXVpcmUoJy4vdG9BcnJheScpO1xudmFyIGZpbmQgPSByZXF1aXJlKCcuLi9hcnJheS9maW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZmlyc3Qgbm9uIHZvaWQgYXJndW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyh2YXJfYXJncyl7XG4gICAgICAgIHJldHVybiBmaW5kKHRvQXJyYXkoYXJndW1lbnRzKSwgbm9uVm9pZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9uVm9pZCh2YWwpe1xuICAgICAgICByZXR1cm4gdmFsICE9IG51bGw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcblxuXG4iLCJ2YXIgY3JlYXRlT2JqZWN0ID0gcmVxdWlyZSgnLi9jcmVhdGVPYmplY3QnKTtcblxuICAgIC8qKlxuICAgICogSW5oZXJpdCBwcm90b3R5cGUgZnJvbSBhbm90aGVyIE9iamVjdC5cbiAgICAqIC0gaW5zcGlyZWQgYnkgTmljaG9sYXMgWmFja2FzIDxodHRwOi8vbmN6b25saW5lLm5ldD4gU29sdXRpb25cbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGlsZCBDaGlsZCBvYmplY3RcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnQgICAgUGFyZW50IE9iamVjdFxuICAgICovXG4gICAgZnVuY3Rpb24gaW5oZXJpdFByb3RvdHlwZShjaGlsZCwgcGFyZW50KXtcbiAgICAgICAgdmFyIHAgPSBjcmVhdGVPYmplY3QocGFyZW50LnByb3RvdHlwZSk7XG4gICAgICAgIHAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgICAgY2hpbGQucHJvdG90eXBlID0gcDtcbiAgICAgICAgY2hpbGQuc3VwZXJfID0gcGFyZW50O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGluaGVyaXRQcm90b3R5cGU7XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYm90aCBhcmd1bWVudHMgYXJlIGVnYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXMoeCwgeSl7XG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIGJvcnJvd2VkIGZyb20gaGFybW9ueTplZ2FsIHNwZWNcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAvLyAwID09PSAtMCwgYnV0IHRoZXkgYXJlIG5vdCBpZGVudGljYWxcbiAgICAgICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOYU4gIT09IE5hTiwgYnV0IHRoZXkgYXJlIGlkZW50aWNhbC5cbiAgICAgICAgLy8gTmFOcyBhcmUgdGhlIG9ubHkgbm9uLXJlZmxleGl2ZSB2YWx1ZSwgaS5lLiwgaWYgeCAhPT0geCxcbiAgICAgICAgLy8gdGhlbiB4IGlzIGEgTmFOLlxuICAgICAgICAvLyBpc05hTiBpcyBicm9rZW46IGl0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBudW1iZXIsIHNvXG4gICAgICAgIC8vIGlzTmFOKFwiZm9vXCIpID0+IHRydWVcbiAgICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzO1xuXG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgdmFyIGlzQXJncyA9IGlzS2luZChhcmd1bWVudHMsICdBcmd1bWVudHMnKT9cbiAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdBcmd1bWVudHMnKTtcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKXtcbiAgICAgICAgICAgICAgICAvLyBBcmd1bWVudHMgaXMgYW4gT2JqZWN0IG9uIElFN1xuICAgICAgICAgICAgICAgIHJldHVybiAhISh2YWwgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwgJ2NhbGxlZScpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzQXJncztcblxuIiwidmFyIGlzS2luZCA9IHJlcXVpcmUoJy4vaXNLaW5kJyk7XG4gICAgLyoqXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdBcnJheScpO1xuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnQm9vbGVhbicpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzQm9vbGVhbjtcblxuIiwidmFyIGlzS2luZCA9IHJlcXVpcmUoJy4vaXNLaW5kJyk7XG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ0RhdGUnKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0RhdGU7XG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuLi9vYmplY3QvZm9yT3duJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWwpe1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsID09ICdvYmplY3QnIHNvIHdlIGNoZWNrIGl0IGZpcnN0XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNBcnJheSh2YWwpICkge1xuICAgICAgICAgICAgcmV0dXJuICF2YWwubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yT3duKHZhbCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGJyZWFrIGxvb3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0VtcHR5O1xuXG5cbiIsInZhciBpc051bWJlciA9IHJlcXVpcmUoJy4vaXNOdW1iZXInKTtcbnZhciBHTE9CQUwgPSByZXF1aXJlKCcuL0dMT0JBTCcpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgZmluaXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsKXtcbiAgICAgICAgdmFyIGlzID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwgIT09ICcnKSB7XG4gICAgICAgICAgICBpcyA9IEdMT0JBTC5pc0Zpbml0ZSggcGFyc2VGbG9hdCh2YWwpICk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIodmFsKSl7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHVzZSBpc051bWJlciBiZWNhdXNlIG9mIE51bWJlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgaXMgPSBHTE9CQUwuaXNGaW5pdGUoIHZhbCApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpcztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzRmluaXRlO1xuXG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG4iLCJ2YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2lzTnVtYmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbCl7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWwpICYmICh2YWwgJSAxID09PSAwKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzSW50ZWdlcjtcblxuXG4iLCJ2YXIga2luZE9mID0gcmVxdWlyZSgnLi9raW5kT2YnKTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB2YWx1ZSBpcyBmcm9tIGEgc3BlY2lmaWMgXCJraW5kXCIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLaW5kKHZhbCwga2luZCl7XG4gICAgICAgIHJldHVybiBraW5kT2YodmFsKSA9PT0ga2luZDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0tpbmQ7XG5cbiIsInZhciBpc051bWJlciA9IHJlcXVpcmUoJy4vaXNOdW1iZXInKTtcbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuLi9udW1iZXIvaXNOYU4nKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHZhbHVlIGlzIE5hTiBmb3IgcmVhbHpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWwpe1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgZmFjdCB0aGF0IE5hTiAhPT0gTmFOXG4gICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBhIG51bWJlciB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBob3N0IG9iamVjdHNcbiAgICAgICAgLy8gYWxzbyBuZWVkIHRvIGNvZXJjZSBUb051bWJlciB0byBhdm9pZCBlZGdlIGNhc2UgYG5ldyBOdW1iZXIoTmFOKWBcbiAgICAgICAgcmV0dXJuICFpc051bWJlcih2YWwpIHx8ICRpc05hTihOdW1iZXIodmFsKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc05hTjtcblxuXG4iLCJcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsKXtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc051bGw7XG5cblxuIiwidmFyIGlzS2luZCA9IHJlcXVpcmUoJy4vaXNLaW5kJyk7XG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnTnVtYmVyJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ09iamVjdCcpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKCEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgaXMgYSBwcmltaXRpdmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgICAgICAvLyBVc2luZyBzd2l0Y2ggZmFsbHRocm91Z2ggYmVjYXVzZSBpdCdzIHNpbXBsZSB0byByZWFkIGFuZCBpc1xuICAgICAgICAvLyBnZW5lcmFsbHkgZmFzdDogaHR0cDovL2pzcGVyZi5jb20vdGVzdGluZy12YWx1ZS1pcy1wcmltaXRpdmUvNVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNQcmltaXRpdmU7XG5cblxuIiwidmFyIGlzS2luZCA9IHJlcXVpcmUoJy4vaXNLaW5kJyk7XG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnUmVnRXhwJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNSZWdFeHA7XG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ1N0cmluZycpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuXG4iLCJcbiAgICB2YXIgVU5ERUY7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmKHZhbCl7XG4gICAgICAgIHJldHVybiB2YWwgPT09IFVOREVGO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzVW5kZWY7XG5cbiIsInZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGJvdGggdmFsdWVzIGFyZSBub3QgaWRlbnRpY2FsL2VnYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc250KHgsIHkpe1xuICAgICAgICByZXR1cm4gIWlzKHgsIHkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNudDtcblxuXG4iLCJcblxuICAgIHZhciBfcktpbmQgPSAvXlxcW29iamVjdCAoLiopXFxdJC8sXG4gICAgICAgIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIFVOREVGO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgXCJraW5kXCIgb2YgdmFsdWUuIChlLmcuIFwiU3RyaW5nXCIsIFwiTnVtYmVyXCIsIGV0YylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnTnVsbCc7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBVTkRFRikge1xuICAgICAgICAgICAgcmV0dXJuICdVbmRlZmluZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9yS2luZC5leGVjKCBfdG9TdHJpbmcuY2FsbCh2YWwpIClbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBraW5kT2Y7XG5cbiIsInZhciBraW5kT2YgPSByZXF1aXJlKCcuL2tpbmRPZicpO1xudmFyIEdMT0JBTCA9IHJlcXVpcmUoJy4vR0xPQkFMJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0IGludG8gYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbCl7XG4gICAgICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgICAgIGtpbmQgPSBraW5kT2YodmFsKSxcbiAgICAgICAgICAgIG47XG5cbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIHZhbC5sZW5ndGggPT0gbnVsbCB8fCBraW5kID09PSAnU3RyaW5nJyB8fCBraW5kID09PSAnRnVuY3Rpb24nIHx8IGtpbmQgPT09ICdSZWdFeHAnIHx8IHZhbCA9PT0gR0xPQkFMICkge1xuICAgICAgICAgICAgICAgIC8vc3RyaW5nLCByZWdleHAsIGZ1bmN0aW9uIGhhdmUgLmxlbmd0aCBidXQgdXNlciBwcm9iYWJseSBqdXN0IHdhbnRcbiAgICAgICAgICAgICAgICAvL3RvIHdyYXAgdmFsdWUgaW50byBhbiBhcnJheS4uXG4gICAgICAgICAgICAgICAgcmV0W3JldC5sZW5ndGhdID0gdmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL3dpbmRvdyByZXR1cm5zIHRydWUgb24gaXNPYmplY3QgaW4gSUU3IGFuZCBtYXkgaGF2ZSBsZW5ndGhcbiAgICAgICAgICAgICAgICAvL3Byb3BlcnR5LiBgdHlwZW9mIE5vZGVMaXN0YCByZXR1cm5zIGBmdW5jdGlvbmAgb24gU2FmYXJpIHNvXG4gICAgICAgICAgICAgICAgLy93ZSBjYW4ndCB1c2UgaXQgKCM1OClcbiAgICAgICAgICAgICAgICBuID0gdmFsLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtuXSA9IHZhbFtuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4gICAgLyoqXG4gICAgICogY292ZXJ0IHZhbHVlIGludG8gbnVtYmVyIGlmIG51bWVyaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWwpe1xuICAgICAgICAvLyBudW1iZXJpYyB2YWx1ZXMgc2hvdWxkIGNvbWUgZmlyc3QgYmVjYXVzZSBvZiAtMFxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHJldHVybiB2YWw7XG4gICAgICAgIC8vIHdlIHdhbnQgYWxsIGZhbHN5IHZhbHVlcyAoYmVzaWRlcyAtMCkgdG8gcmV0dXJuIHplcm8gdG8gYXZvaWRcbiAgICAgICAgLy8gaGVhZGFjaGVzXG4gICAgICAgIGlmICghdmFsKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAvLyBhcnJheXMgYXJlIGVkZ2UgY2FzZXMuIGBOdW1iZXIoWzRdKSA9PT0gNGBcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsKSkgcmV0dXJuIE5hTjtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBUeXBlY2FzdCBhIHZhbHVlIHRvIGEgU3RyaW5nLCB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdmFsdWUgZm9yIG51bGwgb3JcbiAgICAgKiB1bmRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsKXtcbiAgICAgICAgcmV0dXJuIHZhbCA9PSBudWxsID8gJycgOiB2YWwudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuXG5cbiIsIlxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnY2VpbCcgOiByZXF1aXJlKCcuL21hdGgvY2VpbCcpLFxuICAgICdjbGFtcCcgOiByZXF1aXJlKCcuL21hdGgvY2xhbXAnKSxcbiAgICAnY291bnRTdGVwcycgOiByZXF1aXJlKCcuL21hdGgvY291bnRTdGVwcycpLFxuICAgICdmbG9vcicgOiByZXF1aXJlKCcuL21hdGgvZmxvb3InKSxcbiAgICAnaW5SYW5nZScgOiByZXF1aXJlKCcuL21hdGgvaW5SYW5nZScpLFxuICAgICdpc05lYXInIDogcmVxdWlyZSgnLi9tYXRoL2lzTmVhcicpLFxuICAgICdsZXJwJyA6IHJlcXVpcmUoJy4vbWF0aC9sZXJwJyksXG4gICAgJ2xvb3AnIDogcmVxdWlyZSgnLi9tYXRoL2xvb3AnKSxcbiAgICAnbWFwJyA6IHJlcXVpcmUoJy4vbWF0aC9tYXAnKSxcbiAgICAnbm9ybScgOiByZXF1aXJlKCcuL21hdGgvbm9ybScpLFxuICAgICdyb3VuZCcgOiByZXF1aXJlKCcuL21hdGgvcm91bmQnKVxufTtcblxuXG4iLCJcbiAgICAvKipcbiAgICAgKiBSb3VuZCB2YWx1ZSB1cCB3aXRoIGEgY3VzdG9tIHJhZGl4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNlaWwodmFsLCBzdGVwKXtcbiAgICAgICAgc3RlcCA9IE1hdGguYWJzKHN0ZXAgfHwgMSk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodmFsIC8gc3RlcCkgKiBzdGVwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY2VpbDtcblxuIiwiXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHZhbHVlIGluc2lkZSByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KXtcbiAgICAgICAgcmV0dXJuIHZhbCA8IG1pbj8gbWluIDogKHZhbCA+IG1heD8gbWF4IDogdmFsKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbGFtcDtcblxuIiwiXG4gICAgLyoqXG4gICAgKiBDb3VudCBudW1iZXIgb2YgZnVsbCBzdGVwcy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNvdW50U3RlcHModmFsLCBzdGVwLCBvdmVyZmxvdyl7XG4gICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gc3RlcCk7XG5cbiAgICAgICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICUgb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY291bnRTdGVwcztcblxuIiwiXG4gICAgLyoqXG4gICAgKiBGbG9vciB2YWx1ZSB0byBmdWxsIHN0ZXBzLlxuICAgICovXG4gICAgZnVuY3Rpb24gZmxvb3IodmFsLCBzdGVwKXtcbiAgICAgICAgc3RlcCA9IE1hdGguYWJzKHN0ZXAgfHwgMSk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbCAvIHN0ZXApICogc3RlcDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmbG9vcjtcblxuIiwiXG4gICAgLyoqXG4gICAgKiBDaGVja3MgaWYgdmFsdWUgaXMgaW5zaWRlIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UodmFsLCBtaW4sIG1heCwgdGhyZXNob2xkKXtcbiAgICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDA7XG4gICAgICAgIHJldHVybiAodmFsICsgdGhyZXNob2xkID49IG1pbiAmJiB2YWwgLSB0aHJlc2hvbGQgPD0gbWF4KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGluUmFuZ2U7XG5cbiIsIlxuICAgIC8qKlxuICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgY2xvc2UgdG8gdGFyZ2V0LlxuICAgICovXG4gICAgZnVuY3Rpb24gaXNOZWFyKHZhbCwgdGFyZ2V0LCB0aHJlc2hvbGQpe1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKHZhbCAtIHRhcmdldCkgPD0gdGhyZXNob2xkKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc05lYXI7XG5cbiIsIlxuICAgIC8qKlxuICAgICogTGluZWFyIGludGVycG9sYXRpb24uXG4gICAgKiBJTVBPUlRBTlQ6d2lsbCByZXR1cm4gYEluZmluaXR5YCBpZiBudW1iZXJzIG92ZXJmbG93IE51bWJlci5NQVhfVkFMVUVcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAocmF0aW8sIHN0YXJ0LCBlbmQpe1xuICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcmF0aW87XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsZXJwO1xuXG4iLCJcbiAgICAvKipcbiAgICAqIExvb3BzIHZhbHVlIGluc2lkZSByYW5nZS5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb3AodmFsLCBtaW4sIG1heCl7XG4gICAgICAgIHJldHVybiB2YWwgPCBtaW4/IG1heCA6ICh2YWwgPiBtYXg/IG1pbiA6IHZhbCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsb29wO1xuXG4iLCJ2YXIgbGVycCA9IHJlcXVpcmUoJy4vbGVycCcpO1xudmFyIG5vcm0gPSByZXF1aXJlKCcuL25vcm0nKTtcbiAgICAvKipcbiAgICAqIE1hcHMgYSBudW1iZXIgZnJvbSBvbmUgc2NhbGUgdG8gYW5vdGhlci5cbiAgICAqIEBleGFtcGxlIG1hcCgzLCAwLCA0LCAtMSwgMSkgLT4gMC41XG4gICAgKi9cbiAgICBmdW5jdGlvbiBtYXAodmFsLCBtaW4xLCBtYXgxLCBtaW4yLCBtYXgyKXtcbiAgICAgICAgcmV0dXJuIGxlcnAoIG5vcm0odmFsLCBtaW4xLCBtYXgxKSwgbWluMiwgbWF4MiApO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hcDtcblxuIiwiXG4gICAgLyoqXG4gICAgKiBHZXRzIG5vcm1hbGl6ZWQgcmF0aW8gb2YgdmFsdWUgaW5zaWRlIHJhbmdlLlxuICAgICovXG4gICAgZnVuY3Rpb24gbm9ybSh2YWwsIG1pbiwgbWF4KXtcbiAgICAgICAgaWYgKHZhbCA8IG1pbiB8fCB2YWwgPiBtYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSAoJyArIHZhbCArICcpIG11c3QgYmUgYmV0d2VlbiAnICsgbWluICsgJyBhbmQgJyArIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsID09PSBtYXggPyAxIDogKHZhbCAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBub3JtO1xuXG4iLCJcbiAgICAvKipcbiAgICAgKiBSb3VuZCBudW1iZXIgdG8gYSBzcGVjaWZpYyByYWRpeFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdW5kKHZhbHVlLCByYWRpeCl7XG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTsgLy8gZGVmYXVsdCByb3VuZCAxXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gcmFkaXgpICogcmFkaXg7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByb3VuZDtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ01BWF9JTlQnIDogcmVxdWlyZSgnLi9udW1iZXIvTUFYX0lOVCcpLFxuICAgICdNQVhfU0FGRV9JTlRFR0VSJyA6IHJlcXVpcmUoJy4vbnVtYmVyL01BWF9TQUZFX0lOVEVHRVInKSxcbiAgICAnTUFYX1VJTlQnIDogcmVxdWlyZSgnLi9udW1iZXIvTUFYX1VJTlQnKSxcbiAgICAnTUlOX0lOVCcgOiByZXF1aXJlKCcuL251bWJlci9NSU5fSU5UJyksXG4gICAgJ2FiYnJldmlhdGUnIDogcmVxdWlyZSgnLi9udW1iZXIvYWJicmV2aWF0ZScpLFxuICAgICdjdXJyZW5jeUZvcm1hdCcgOiByZXF1aXJlKCcuL251bWJlci9jdXJyZW5jeUZvcm1hdCcpLFxuICAgICdlbmZvcmNlUHJlY2lzaW9uJyA6IHJlcXVpcmUoJy4vbnVtYmVyL2VuZm9yY2VQcmVjaXNpb24nKSxcbiAgICAnaXNOYU4nIDogcmVxdWlyZSgnLi9udW1iZXIvaXNOYU4nKSxcbiAgICAnbnRoJyA6IHJlcXVpcmUoJy4vbnVtYmVyL250aCcpLFxuICAgICdvcmRpbmFsJyA6IHJlcXVpcmUoJy4vbnVtYmVyL29yZGluYWwnKSxcbiAgICAncGFkJyA6IHJlcXVpcmUoJy4vbnVtYmVyL3BhZCcpLFxuICAgICdyb2wnIDogcmVxdWlyZSgnLi9udW1iZXIvcm9sJyksXG4gICAgJ3JvcicgOiByZXF1aXJlKCcuL251bWJlci9yb3InKSxcbiAgICAnc2lnbicgOiByZXF1aXJlKCcuL251bWJlci9zaWduJyksXG4gICAgJ3RvSW50JyA6IHJlcXVpcmUoJy4vbnVtYmVyL3RvSW50JyksXG4gICAgJ3RvVUludCcgOiByZXF1aXJlKCcuL251bWJlci90b1VJbnQnKSxcbiAgICAndG9VSW50MzEnIDogcmVxdWlyZSgnLi9udW1iZXIvdG9VSW50MzEnKVxufTtcblxuXG4iLCIvKipcbiAqIEBjb25zdGFudCBNYXhpbXVtIDMyLWJpdCBzaWduZWQgaW50ZWdlciB2YWx1ZS4gKDJeMzEgLSAxKVxuICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IDIxNDc0ODM2NDc7XG5cbiIsIlxuXG4gICAgLy8gbWF4aW11bSBzYWZlIGludGVnZXIgKE1hdGgucG93KDIsIDUzKSAtIDEpXG4gICAgLy8gc2VlOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlclxuICAgIG1vZHVsZS5leHBvcnRzID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuXG4iLCIvKipcbiAqIEBjb25zdGFudCBNYXhpbXVtIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2V0IHZhbHVlICgyXjMyIC0gMSlcbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSA0Mjk0OTY3Mjk1O1xuXG4iLCIvKipcbiAqIEBjb25zdGFudCBNaW5pbXVtIDMyLWJpdCBzaWduZWQgaW50ZWdlciB2YWx1ZSAoLTJeMzEpLlxuICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IC0yMTQ3NDgzNjQ4O1xuXG4iLCJ2YXIgZW5mb3JjZVByZWNpc2lvbiA9IHJlcXVpcmUoJy4vZW5mb3JjZVByZWNpc2lvbicpO1xuXG4gICAgdmFyIF9kZWZhdWx0RGljdCA9IHtcbiAgICAgICAgdGhvdXNhbmQgOiAnSycsXG4gICAgICAgIG1pbGxpb24gOiAnTScsXG4gICAgICAgIGJpbGxpb24gOiAnQidcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWJicmV2aWF0ZSBudW1iZXIgaWYgYmlnZ2VyIHRoYW4gMTAwMC4gKGVnOiAyLjVLLCAxNy41TSwgMy40QiwgLi4uKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFiYnJldmlhdGVOdW1iZXIodmFsLCBuRGVjaW1hbHMsIGRpY3Qpe1xuICAgICAgICBuRGVjaW1hbHMgPSBuRGVjaW1hbHMgIT0gbnVsbD8gbkRlY2ltYWxzIDogMTtcbiAgICAgICAgZGljdCA9IGRpY3QgfHwgX2RlZmF1bHREaWN0O1xuICAgICAgICB2YWwgPSBlbmZvcmNlUHJlY2lzaW9uKHZhbCwgbkRlY2ltYWxzKTtcblxuICAgICAgICB2YXIgc3RyLCBtb2Q7XG5cbiAgICAgICAgaWYgKHZhbCA8IDEwMDAwMDApIHtcbiAgICAgICAgICAgIG1vZCA9IGVuZm9yY2VQcmVjaXNpb24odmFsIC8gMTAwMCwgbkRlY2ltYWxzKTtcbiAgICAgICAgICAgIC8vIG1pZ2h0IG92ZXJmbG93IHRvIG5leHQgc2NhbGUgZHVyaW5nIHJvdW5kaW5nXG4gICAgICAgICAgICBzdHIgPSBtb2QgPCAxMDAwPyBtb2QgKyBkaWN0LnRob3VzYW5kIDogMSArIGRpY3QubWlsbGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCAxMDAwMDAwMDAwKSB7XG4gICAgICAgICAgICBtb2QgPSBlbmZvcmNlUHJlY2lzaW9uKHZhbCAvIDEwMDAwMDAsIG5EZWNpbWFscyk7XG4gICAgICAgICAgICBzdHIgPSBtb2QgPCAxMDAwPyBtb2QgKyBkaWN0Lm1pbGxpb24gOiAxICsgZGljdC5iaWxsaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gZW5mb3JjZVByZWNpc2lvbih2YWwgLyAxMDAwMDAwMDAwLCBuRGVjaW1hbHMpICsgZGljdC5iaWxsaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGFiYnJldmlhdGVOdW1iZXI7XG5cblxuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi4vbGFuZy90b051bWJlcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgbnVtYmVyIGludG8gY3VycmVuY3kgZm9ybWF0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycmVuY3lGb3JtYXQodmFsLCBuRGVjaW1hbERpZ2l0cywgZGVjaW1hbFNlcGFyYXRvciwgdGhvdXNhbmRzU2VwYXJhdG9yKSB7XG4gICAgICAgIHZhbCA9IHRvTnVtYmVyKHZhbCk7XG4gICAgICAgIG5EZWNpbWFsRGlnaXRzID0gbkRlY2ltYWxEaWdpdHMgPT0gbnVsbD8gMiA6IG5EZWNpbWFsRGlnaXRzO1xuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yID0gZGVjaW1hbFNlcGFyYXRvciA9PSBudWxsPyAnLicgOiBkZWNpbWFsU2VwYXJhdG9yO1xuICAgICAgICB0aG91c2FuZHNTZXBhcmF0b3IgPSB0aG91c2FuZHNTZXBhcmF0b3IgPT0gbnVsbD8gJywnIDogdGhvdXNhbmRzU2VwYXJhdG9yO1xuXG4gICAgICAgIC8vY2FuJ3QgdXNlIGVuZm9yY2UgcHJlY2lzaW9uIHNpbmNlIGl0IHJldHVybnMgYSBudW1iZXIgYW5kIHdlIGFyZVxuICAgICAgICAvL2RvaW5nIGEgUmVnRXhwIG92ZXIgdGhlIHN0cmluZ1xuICAgICAgICB2YXIgZml4ZWQgPSB2YWwudG9GaXhlZChuRGVjaW1hbERpZ2l0cyksXG4gICAgICAgICAgICAvL3NlcGFyYXRlIGJlZ2luIFskMV0sIG1pZGRsZSBbJDJdIGFuZCBkZWNpbWFsIGRpZ2l0cyBbJDRdXG4gICAgICAgICAgICBwYXJ0cyA9IG5ldyBSZWdFeHAoJ14oLT9cXFxcZHsxLDN9KSgoPzpcXFxcZHszfSkrKShcXFxcLihcXFxcZHsnKyBuRGVjaW1hbERpZ2l0cyArJ30pKT8kJykuZXhlYyggZml4ZWQgKTtcblxuICAgICAgICBpZihwYXJ0cyl7IC8vdmFsID49IDEwMDAgfHwgdmFsIDw9IC0xMDAwXG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMV0gKyBwYXJ0c1syXS5yZXBsYWNlKC9cXGR7M30vZywgdGhvdXNhbmRzU2VwYXJhdG9yICsgJyQmJykgKyAocGFydHNbNF0gPyBkZWNpbWFsU2VwYXJhdG9yICsgcGFydHNbNF0gOiAnJyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkLnJlcGxhY2UoJy4nLCBkZWNpbWFsU2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY3VycmVuY3lGb3JtYXQ7XG5cblxuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi4vbGFuZy90b051bWJlcicpO1xuICAgIC8qKlxuICAgICAqIEVuZm9yY2UgYSBzcGVjaWZpYyBhbW91bnQgb2YgZGVjaW1hbCBkaWdpdHMgYW5kIGFsc28gZml4IGZsb2F0aW5nXG4gICAgICogcG9pbnQgcm91bmRpbmcgaXNzdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZm9yY2VQcmVjaXNpb24odmFsLCBuRGVjaW1hbERpZ2l0cyl7XG4gICAgICAgIHZhbCA9IHRvTnVtYmVyKHZhbCk7XG4gICAgICAgIHZhciBwb3cgPSBNYXRoLnBvdygxMCwgbkRlY2ltYWxEaWdpdHMpO1xuICAgICAgICByZXR1cm4gKyhNYXRoLnJvdW5kKHZhbCAqIHBvdykgLyBwb3cpLnRvRml4ZWQobkRlY2ltYWxEaWdpdHMpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVuZm9yY2VQcmVjaXNpb247XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogRVM2IE51bWJlci5pc05hTlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbCl7XG4gICAgICAgIC8vIGpzaGludCBlcWVxZXE6ZmFsc2VcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCAhPSB2YWw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc05hTjtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgXCJudGhcIiBvZiBudW1iZXIgKDEgPSBcInN0XCIsIDIgPSBcIm5kXCIsIDMgPSBcInJkXCIsIDQuLjEwID0gXCJ0aFwiLCAuLi4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGkpIHtcbiAgICAgICAgdmFyIHQgPSAoaSAlIDEwMCk7XG4gICAgICAgIGlmICh0ID49IDEwICYmIHQgPD0gMjApIHtcbiAgICAgICAgICAgIHJldHVybiAndGgnO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChpICUgMTApIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3N0JztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25kJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JkJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG50aDtcblxuXG4iLCJ2YXIgdG9JbnQgPSByZXF1aXJlKCcuL3RvSW50Jyk7XG52YXIgbnRoID0gcmVxdWlyZSgnLi9udGgnKTtcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIG51bWJlciBpbnRvIG9yZGluYWwgZm9ybSAoMXN0LCAybmQsIDNyZCwgNHRoLCAuLi4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkaW5hbChuKXtcbiAgICAgICBuID0gdG9JbnQobik7XG4gICAgICAgcmV0dXJuIG4gKyBudGgobik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBvcmRpbmFsO1xuXG5cbiIsInZhciBscGFkID0gcmVxdWlyZSgnLi4vc3RyaW5nL2xwYWQnKTtcbnZhciB0b051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvdG9OdW1iZXInKTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBwYWRkaW5nIHplcm9zIGlmIG4ubGVuZ3RoIDwgbWluTGVuZ3RoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChuLCBtaW5MZW5ndGgsIGNoYXIpe1xuICAgICAgICBuID0gdG9OdW1iZXIobik7XG4gICAgICAgIHJldHVybiBscGFkKCcnKyBuLCBtaW5MZW5ndGgsIGNoYXIgfHwgJzAnKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhZDtcblxuXG4iLCJcbiAgICAvKipcbiAgICAgKiBCaXR3aXNlIGNpcmN1bGFyIHNoaWZ0IGxlZnRcbiAgICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NpcmN1bGFyX3NoaWZ0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcm9sKHZhbCwgc2hpZnQpe1xuICAgICAgICByZXR1cm4gKHZhbCA8PCBzaGlmdCkgfCAodmFsID4+ICgzMiAtIHNoaWZ0KSk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcm9sO1xuXG4iLCJcbiAgICAvKipcbiAgICAgKiBCaXR3aXNlIGNpcmN1bGFyIHNoaWZ0IHJpZ2h0XG4gICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaXJjdWxhcl9zaGlmdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvcih2YWwsIHNoaWZ0KXtcbiAgICAgICAgcmV0dXJuICh2YWwgPj4gc2hpZnQpIHwgKHZhbCA8PCAoMzIgLSBzaGlmdCkpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJvcjtcblxuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi4vbGFuZy90b051bWJlcicpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHNpZ24gb2YgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24odmFsKSB7XG4gICAgICAgIHZhciBudW0gPSB0b051bWJlcih2YWwpO1xuICAgICAgICBpZiAobnVtID09PSAwKSByZXR1cm4gbnVtOyAvLyArMCBhbmQgKzAgPT09IDBcbiAgICAgICAgaWYgKGlzTmFOKG51bSkpIHJldHVybiBudW07IC8vIE5hTlxuICAgICAgICByZXR1cm4gbnVtIDwgMD8gLTEgOiAxO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc2lnbjtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFwiQ29udmVydFwiIHZhbHVlIGludG8gYW4gMzItYml0IGludGVnZXIuXG4gICAgICogV29ya3MgbGlrZSBgTWF0aC5mbG9vcmAgaWYgdmFsID4gMCBhbmQgYE1hdGguY2VpbGAgaWYgdmFsIDwgMC5cbiAgICAgKiBJTVBPUlRBTlQ6IHZhbCB3aWxsIHdyYXAgYXQgMl4zMSBhbmQgLTJeMzEuXG4gICAgICogUGVyZiB0ZXN0czogaHR0cDovL2pzcGVyZi5jb20vdnMtdnMtcGFyc2VpbnQtYml0d2lzZS1vcGVyYXRvcnMvN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50KHZhbCl7XG4gICAgICAgIC8vIHdlIGRvIG5vdCB1c2UgbGFuZy90b051bWJlciBiZWNhdXNlIG9mIHBlcmYgYW5kIGFsc28gYmVjYXVzZSBpdFxuICAgICAgICAvLyBkb2Vzbid0IGJyZWFrIHRoZSBmdW5jdGlvbmFsaXR5XG4gICAgICAgIHJldHVybiB+fnZhbDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvSW50O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogXCJDb252ZXJ0XCIgdmFsdWUgaW50byBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIElNUE9SVEFOVDogVmFsdWUgd2lsbCB3cmFwIGF0IDJeMzIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VSW50KHZhbCl7XG4gICAgICAgIC8vIHdlIGRvIG5vdCB1c2UgbGFuZy90b051bWJlciBiZWNhdXNlIG9mIHBlcmYgYW5kIGFsc28gYmVjYXVzZSBpdFxuICAgICAgICAvLyBkb2Vzbid0IGJyZWFrIHRoZSBmdW5jdGlvbmFsaXR5XG4gICAgICAgIHJldHVybiB2YWwgPj4+IDA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b1VJbnQ7XG5cblxuIiwidmFyIE1BWF9JTlQgPSByZXF1aXJlKCcuL01BWF9JTlQnKTtcblxuICAgIC8qKlxuICAgICAqIFwiQ29udmVydFwiIHZhbHVlIGludG8gYW4gMzEtYml0IHVuc2lnbmVkIGludGVnZXIgKHNpbmNlIDEgYml0IGlzIHVzZWQgZm9yIHNpZ24pLlxuICAgICAqIElNUE9SVEFOVDogdmFsdWUgd2lsIHdyYXAgYXQgMl4zMSwgaWYgbmVnYXRpdmUgd2lsbCByZXR1cm4gMC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VJbnQzMSh2YWwpe1xuICAgICAgICAvLyB3ZSBkbyBub3QgdXNlIGxhbmcvdG9OdW1iZXIgYmVjYXVzZSBvZiBwZXJmIGFuZCBhbHNvIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gZG9lc24ndCBicmVhayB0aGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICByZXR1cm4gKHZhbCA8PSAwKT8gMCA6ICh2YWwgPiBNQVhfSU5UPyB+fih2YWwgJSAoTUFYX0lOVCArIDEpKSA6IH5+dmFsKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvVUludDMxO1xuXG5cbiIsIlxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnYmluZEFsbCcgOiByZXF1aXJlKCcuL29iamVjdC9iaW5kQWxsJyksXG4gICAgJ2NvbnRhaW5zJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2NvbnRhaW5zJyksXG4gICAgJ2RlZXBGaWxsSW4nIDogcmVxdWlyZSgnLi9vYmplY3QvZGVlcEZpbGxJbicpLFxuICAgICdkZWVwTWF0Y2hlcycgOiByZXF1aXJlKCcuL29iamVjdC9kZWVwTWF0Y2hlcycpLFxuICAgICdkZWVwTWl4SW4nIDogcmVxdWlyZSgnLi9vYmplY3QvZGVlcE1peEluJyksXG4gICAgJ2VxdWFscycgOiByZXF1aXJlKCcuL29iamVjdC9lcXVhbHMnKSxcbiAgICAnZXZlcnknIDogcmVxdWlyZSgnLi9vYmplY3QvZXZlcnknKSxcbiAgICAnZmlsbEluJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2ZpbGxJbicpLFxuICAgICdmaWx0ZXInIDogcmVxdWlyZSgnLi9vYmplY3QvZmlsdGVyJyksXG4gICAgJ2ZpbmQnIDogcmVxdWlyZSgnLi9vYmplY3QvZmluZCcpLFxuICAgICdmb3JJbicgOiByZXF1aXJlKCcuL29iamVjdC9mb3JJbicpLFxuICAgICdmb3JPd24nIDogcmVxdWlyZSgnLi9vYmplY3QvZm9yT3duJyksXG4gICAgJ2Z1bmN0aW9ucycgOiByZXF1aXJlKCcuL29iamVjdC9mdW5jdGlvbnMnKSxcbiAgICAnZ2V0JyA6IHJlcXVpcmUoJy4vb2JqZWN0L2dldCcpLFxuICAgICdoYXMnIDogcmVxdWlyZSgnLi9vYmplY3QvaGFzJyksXG4gICAgJ2hhc093bicgOiByZXF1aXJlKCcuL29iamVjdC9oYXNPd24nKSxcbiAgICAna2V5cycgOiByZXF1aXJlKCcuL29iamVjdC9rZXlzJyksXG4gICAgJ21hcCcgOiByZXF1aXJlKCcuL29iamVjdC9tYXAnKSxcbiAgICAnbWF0Y2hlcycgOiByZXF1aXJlKCcuL29iamVjdC9tYXRjaGVzJyksXG4gICAgJ21heCcgOiByZXF1aXJlKCcuL29iamVjdC9tYXgnKSxcbiAgICAnbWVyZ2UnIDogcmVxdWlyZSgnLi9vYmplY3QvbWVyZ2UnKSxcbiAgICAnbWluJyA6IHJlcXVpcmUoJy4vb2JqZWN0L21pbicpLFxuICAgICdtaXhJbicgOiByZXF1aXJlKCcuL29iamVjdC9taXhJbicpLFxuICAgICduYW1lc3BhY2UnIDogcmVxdWlyZSgnLi9vYmplY3QvbmFtZXNwYWNlJyksXG4gICAgJ29taXQnIDogcmVxdWlyZSgnLi9vYmplY3Qvb21pdCcpLFxuICAgICdwaWNrJyA6IHJlcXVpcmUoJy4vb2JqZWN0L3BpY2snKSxcbiAgICAncGx1Y2snIDogcmVxdWlyZSgnLi9vYmplY3QvcGx1Y2snKSxcbiAgICAncmVkdWNlJyA6IHJlcXVpcmUoJy4vb2JqZWN0L3JlZHVjZScpLFxuICAgICdyZWplY3QnIDogcmVxdWlyZSgnLi9vYmplY3QvcmVqZWN0JyksXG4gICAgJ3Jlc3VsdCcgOiByZXF1aXJlKCcuL29iamVjdC9yZXN1bHQnKSxcbiAgICAnc2V0JyA6IHJlcXVpcmUoJy4vb2JqZWN0L3NldCcpLFxuICAgICdzaXplJyA6IHJlcXVpcmUoJy4vb2JqZWN0L3NpemUnKSxcbiAgICAnc29tZScgOiByZXF1aXJlKCcuL29iamVjdC9zb21lJyksXG4gICAgJ3Vuc2V0JyA6IHJlcXVpcmUoJy4vb2JqZWN0L3Vuc2V0JyksXG4gICAgJ3ZhbHVlcycgOiByZXF1aXJlKCcuL29iamVjdC92YWx1ZXMnKVxufTtcblxuXG4iLCJ2YXIgZnVuY3Rpb25zID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vYmluZCcpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9hcnJheS9mb3JFYWNoJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuLi9hcnJheS9zbGljZScpO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiB0aGUgb2JqZWN0IHRvIGJlIHJ1biBpbiBpdCdzIG93biBjb250ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqLCByZXN0X21ldGhvZE5hbWVzKXtcbiAgICAgICAgdmFyIGtleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMT9cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UoYXJndW1lbnRzLCAxKSA6IGZ1bmN0aW9ucyhvYmopO1xuICAgICAgICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmluZEFsbDtcblxuXG4iLCJ2YXIgc29tZSA9IHJlcXVpcmUoJy4vc29tZScpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgb2JqZWN0IGNvbnRhaW5zIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMob2JqLCBuZWVkbGUpIHtcbiAgICAgICAgcmV0dXJuIHNvbWUob2JqLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsID09PSBuZWVkbGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb250YWlucztcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc1BsYWluT2JqZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWVwbHkgY29weSBtaXNzaW5nIHByb3BlcnRpZXMgaW4gdGhlIHRhcmdldCBmcm9tIHRoZSBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwRmlsbEluKHRhcmdldCwgZGVmYXVsdHMpe1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIG9iajtcblxuICAgICAgICB3aGlsZSgrK2kgPCBuKSB7XG4gICAgICAgICAgICBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgLy8ganNoaW50IGxvb3BmdW5jOiB0cnVlXG4gICAgICAgICAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24obmV3VmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChjdXJWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVlcEZpbGxJbihjdXJWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVlcEZpbGxJbjtcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG5cbiAgICBmdW5jdGlvbiBjb250YWluc01hdGNoKGFycmF5LCBwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBpID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGRlZXBNYXRjaGVzKGFycmF5W2ldLCBwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoQXJyYXkodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBpID0gLTEsIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IHBhdHRlcm5MZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbnNNYXRjaCh0YXJnZXQsIHBhdHRlcm5baV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hPYmplY3QodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBmb3JPd24ocGF0dGVybiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICghZGVlcE1hdGNoZXModGFyZ2V0W2tleV0sIHZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZmFsc2UgdG8gYnJlYWsgb3V0IG9mIGZvck93biBlYXJseVxuICAgICAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNoZWNrIGlmIHRoZSBvYmplY3RzIG1hdGNoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBNYXRjaGVzKHRhcmdldCwgcGF0dGVybil7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEFycmF5KHRhcmdldCwgcGF0dGVybik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE9iamVjdCh0YXJnZXQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gcGF0dGVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVlcE1hdGNoZXM7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNQbGFpbk9iamVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogTWl4ZXMgb2JqZWN0cyBpbnRvIHRoZSB0YXJnZXQgb2JqZWN0LCByZWN1cnNpdmVseSBtaXhpbmcgZXhpc3RpbmcgY2hpbGRcbiAgICAgKiBvYmplY3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBNaXhJbih0YXJnZXQsIG9iamVjdHMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBvYmo7XG5cbiAgICAgICAgd2hpbGUoKytpIDwgbil7XG4gICAgICAgICAgICBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgZm9yT3duKG9iaiwgY29weVByb3AsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcHlQcm9wKHZhbCwga2V5KSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXNba2V5XTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsKSAmJiBpc1BsYWluT2JqZWN0KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgZGVlcE1peEluKGV4aXN0aW5nLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1trZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWVwTWl4SW47XG5cblxuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4vaGFzT3duJyk7XG52YXIgZXZlcnkgPSByZXF1aXJlKCcuL2V2ZXJ5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9sYW5nL2lzJyk7XG5cbiAgICAvLyBNYWtlcyBhIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdGhlIG9iamVjdCB2YWx1ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGNvbXBhcmVcbiAgICAvLyBvcGVyYXRpb24gY2FsbGJhY2suXG4gICAgZnVuY3Rpb24gbWFrZUNvbXBhcmUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNPd24odGhpcywga2V5KSAmJiBjYWxsYmFjayh2YWx1ZSwgdGhpc1trZXldKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1Byb3BlcnRpZXModmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duKHRoaXMsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHR3byBvYmplY3RzIGhhdmUgdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGlzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QoYSkgfHwgIWlzT2JqZWN0KGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGV2ZXJ5KGEsIG1ha2VDb21wYXJlKGNhbGxiYWNrKSwgYikgJiZcbiAgICAgICAgICAgICAgICBldmVyeShiLCBjaGVja1Byb3BlcnRpZXMsIGEpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVxdWFscztcblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGV2ZXJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkob2JqLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgLy8gd2UgY29uc2lkZXIgYW55IGZhbHN5IHZhbHVlcyBhcyBcImZhbHNlXCIgb24gcHVycG9zZSBzbyBzaG9ydGhhbmRcbiAgICAgICAgICAgIC8vIHN5bnRheCBjYW4gYmUgdXNlZCB0byBjaGVjayBwcm9wZXJ0eSBleGlzdGVuY2VcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsLCBrZXksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZXZlcnk7XG5cblxuIiwidmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9hcnJheS9mb3JFYWNoJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuLi9hcnJheS9zbGljZScpO1xudmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IG1pc3NpbmcgcHJvcGVydGllcyBpbiB0aGUgb2JqIGZyb20gdGhlIGRlZmF1bHRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGxJbihvYmosIHZhcl9kZWZhdWx0cyl7XG4gICAgICAgIGZvckVhY2goc2xpY2UoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oYmFzZSl7XG4gICAgICAgICAgICBmb3JPd24oYmFzZSwgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbGxJbjtcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyB3aGVyZSB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgICAqIHRydWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyVmFsdWVzKG9iaiwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iaikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbHRlclZhbHVlcztcblxuIiwidmFyIHNvbWUgPSByZXF1aXJlKCcuL3NvbWUnKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIGNyaXRlcmlhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChvYmosIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgc29tZShvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy9icmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG5cblxuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4vaGFzT3duJyk7XG5cbiAgICB2YXIgX2hhc0RvbnRFbnVtQnVnLFxuICAgICAgICBfZG9udEVudW1zO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tEb250RW51bSgpe1xuICAgICAgICBfZG9udEVudW1zID0gW1xuICAgICAgICAgICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgICAgICAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgICAgICAgICAnY29uc3RydWN0b3InXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgIF9oYXNEb250RW51bUJ1ZyA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHsndG9TdHJpbmcnOiBudWxsfSkge1xuICAgICAgICAgICAgX2hhc0RvbnRFbnVtQnVnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIEFycmF5L2ZvckVhY2ggYnV0IHdvcmtzIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgYW5kIGZpeGVzIERvbid0XG4gICAgICogRW51bSBidWcgb24gSUUuXG4gICAgICogYmFzZWQgb246IGh0dHA6Ly93aGF0dGhlaGVhZHNhaWQuY29tLzIwMTAvMTAvYS1zYWZlci1vYmplY3Qta2V5cy1jb21wYXRpYmlsaXR5LWltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqLCBmbiwgdGhpc09iail7XG4gICAgICAgIHZhciBrZXksIGkgPSAwO1xuICAgICAgICAvLyBubyBuZWVkIHRvIGNoZWNrIGlmIGFyZ3VtZW50IGlzIGEgcmVhbCBvYmplY3QgdGhhdCB3YXkgd2UgY2FuIHVzZVxuICAgICAgICAvLyBpdCBmb3IgYXJyYXlzLCBmdW5jdGlvbnMsIGRhdGUsIGV0Yy5cblxuICAgICAgICAvL3Bvc3QtcG9uZSBjaGVjayB0aWxsIG5lZWRlZFxuICAgICAgICBpZiAoX2hhc0RvbnRFbnVtQnVnID09IG51bGwpIGNoZWNrRG9udEVudW0oKTtcblxuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChleGVjKGZuLCBvYmosIGtleSwgdGhpc09iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChfaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgIHZhciBjdG9yID0gb2JqLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgIGlzUHJvdG8gPSAhIWN0b3IgJiYgb2JqID09PSBjdG9yLnByb3RvdHlwZTtcblxuICAgICAgICAgICAgd2hpbGUgKGtleSA9IF9kb250RW51bXNbaSsrXSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBjb25zdHJ1Y3RvciwgaWYgaXQgaXMgYSBwcm90b3R5cGUgb2JqZWN0IHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBub24tZW51bWVyYWJsZSB1bmxlc3MgZGVmaW5lZCBvdGhlcndpc2UgKGFuZFxuICAgICAgICAgICAgICAgIC8vIGVudW1lcmF0ZWQgYWJvdmUpLiAgRm9yIG5vbi1wcm90b3R5cGUgb2JqZWN0cywgaXQgd2lsbCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gdG8gYmUgZGVmaW5lZCBvbiB0aGlzIG9iamVjdCwgc2luY2UgaXQgY2Fubm90IGJlIGRlZmluZWQgb25cbiAgICAgICAgICAgICAgICAvLyBhbnkgcHJvdG90eXBlIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGb3Igb3RoZXIgW1tEb250RW51bV1dIHByb3BlcnRpZXMsIGNoZWNrIGlmIHRoZSB2YWx1ZSBpc1xuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCB0aGFuIE9iamVjdCBwcm90b3R5cGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoa2V5ICE9PSAnY29uc3RydWN0b3InIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIWlzUHJvdG8gJiYgaGFzT3duKG9iaiwga2V5KSkpICYmXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldICE9PSBPYmplY3QucHJvdG90eXBlW2tleV1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4ZWMoZm4sIG9iaiwga2V5LCB0aGlzT2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlYyhmbiwgb2JqLCBrZXksIHRoaXNPYmope1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzT2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZm9ySW47XG5cblxuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4vaGFzT3duJyk7XG52YXIgZm9ySW4gPSByZXF1aXJlKCcuL2ZvckluJyk7XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIEFycmF5L2ZvckVhY2ggYnV0IHdvcmtzIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgYW5kIGZpeGVzIERvbid0XG4gICAgICogRW51bSBidWcgb24gSUUuXG4gICAgICogYmFzZWQgb246IGh0dHA6Ly93aGF0dGhlaGVhZHNhaWQuY29tLzIwMTAvMTAvYS1zYWZlci1vYmplY3Qta2V5cy1jb21wYXRpYmlsaXR5LWltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iaiwgZm4sIHRoaXNPYmope1xuICAgICAgICBmb3JJbihvYmosIGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpc09iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmb3JPd247XG5cblxuIiwidmFyIGZvckluID0gcmVxdWlyZSgnLi9mb3JJbicpO1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgbGlzdCBvZiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqKXtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9ySW4ob2JqLCBmdW5jdGlvbih2YWwsIGtleSl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5cy5zb3J0KCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbnM7XG5cblxuIiwidmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vbGFuZy9pc1ByaW1pdGl2ZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IFwibmVzdGVkXCIgb2JqZWN0IHByb3BlcnR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iaiwgcHJvcCl7XG4gICAgICAgIHZhciBwYXJ0cyA9IHByb3Auc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIGxhc3QgPSBwYXJ0cy5wb3AoKTtcblxuICAgICAgICB3aGlsZSAocHJvcCA9IHBhcnRzLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9ialtsYXN0XTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdldDtcblxuXG4iLCJ2YXIgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKTtcblxuICAgIHZhciBVTkRFRjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG9iamVjdCBoYXMgbmVzdGVkIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmosIHByb3Ape1xuICAgICAgICByZXR1cm4gZ2V0KG9iaiwgcHJvcCkgIT09IFVOREVGO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGFzO1xuXG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBTYWZlciBPYmplY3QuaGFzT3duUHJvcGVydHlcbiAgICAgKi9cbiAgICAgZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCl7XG4gICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gICAgIH1cblxuICAgICBtb2R1bGUuZXhwb3J0cyA9IGhhc093bjtcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBvYmplY3Qga2V5c1xuICAgICAqL1xuICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbih2YWwsIGtleSl7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdoZXJlIGFsbCB0aGUgdmFsdWVzIGFyZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAgICAgKiBgY2FsbGJhY2tgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbih2YWwsIGtleSwgb2JqKSB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IGNhbGxiYWNrKHZhbCwga2V5LCBvYmopO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hcFZhbHVlcztcblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgYSBvYmplY3QgY29udGFpbnMgYWxsIGdpdmVuIHByb3BlcnRpZXMvdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyh0YXJnZXQsIHByb3BzKXtcbiAgICAgICAgLy8gY2FuJ3QgdXNlIFwib2JqZWN0L2V2ZXJ5XCIgYmVjYXVzZSBvZiBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBmb3JPd24ocHJvcHMsIGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgICAgICAgIGlmICh0YXJnZXRba2V5XSAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gYnJlYWsgbG9vcCBhdCBmaXJzdCBkaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWF0Y2hlcztcblxuXG4iLCJ2YXIgYXJyTWF4ID0gcmVxdWlyZSgnLi4vYXJyYXkvbWF4Jyk7XG52YXIgdmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWF4aW11bSB2YWx1ZSBpbnNpZGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChvYmosIGNvbXBhcmVGbikge1xuICAgICAgICByZXR1cm4gYXJyTWF4KHZhbHVlcyhvYmopLCBjb21wYXJlRm4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG4iLCJ2YXIgaGFzT3duID0gcmVxdWlyZSgnLi9oYXNPd24nKTtcbnZhciBkZWVwQ2xvbmUgPSByZXF1aXJlKCcuLi9sYW5nL2RlZXBDbG9uZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogRGVlcCBtZXJnZSBvYmplY3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgICAgICB2YXIgaSA9IDEsXG4gICAgICAgICAgICBrZXksIHZhbCwgb2JqLCB0YXJnZXQ7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IG1vZGlmeSBzb3VyY2UgZWxlbWVudCBhbmQgaXQncyBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIG9iamVjdHMgYXJlIHBhc3NlZCBieSByZWZlcmVuY2VcbiAgICAgICAgdGFyZ2V0ID0gZGVlcENsb25lKCBhcmd1bWVudHNbMF0gKTtcblxuICAgICAgICB3aGlsZSAob2JqID0gYXJndW1lbnRzW2krK10pIHtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmICggISBoYXNPd24ob2JqLCBrZXkpICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWwgPSBvYmpba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICggaXNPYmplY3QodmFsKSAmJiBpc09iamVjdCh0YXJnZXRba2V5XSkgKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jZXB0aW9uLCBkZWVwIG1lcmdlIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRba2V5XSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgYXJyYXlzLCByZWdleHAsIGRhdGUsIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGRlZXBDbG9uZSh2YWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuXG5cbiIsInZhciBhcnJNaW4gPSByZXF1aXJlKCcuLi9hcnJheS9taW4nKTtcbnZhciB2YWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtaW5pbXVtIHZhbHVlIGluc2lkZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKG9iaiwgaXRlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGFyck1pbih2YWx1ZXMob2JqKSwgaXRlcmF0b3IpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWluO1xuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcblxuICAgIC8qKlxuICAgICogQ29tYmluZSBwcm9wZXJ0aWVzIGZyb20gYWxsIHRoZSBvYmplY3RzIGludG8gZmlyc3Qgb25lLlxuICAgICogLSBUaGlzIG1ldGhvZCBhZmZlY3RzIHRhcmdldCBvYmplY3QgaW4gcGxhY2UsIGlmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBPYmplY3QgcGFzcyBhbiBlbXB0eSBvYmplY3QgYXMgZmlyc3QgcGFyYW0uXG4gICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0ICAgIFRhcmdldCBPYmplY3RcbiAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fSBvYmplY3RzICAgIE9iamVjdHMgdG8gYmUgY29tYmluZWQgKDAuLi5uIG9iamVjdHMpLlxuICAgICogQHJldHVybiB7b2JqZWN0fSBUYXJnZXQgT2JqZWN0LlxuICAgICovXG4gICAgZnVuY3Rpb24gbWl4SW4odGFyZ2V0LCBvYmplY3RzKXtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBvYmo7XG4gICAgICAgIHdoaWxlKCsraSA8IG4pe1xuICAgICAgICAgICAgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yT3duKG9iaiwgY29weVByb3AsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3B5UHJvcCh2YWwsIGtleSl7XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1peEluO1xuXG4iLCJ2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2FycmF5L2ZvckVhY2gnKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBuZXN0ZWQgb2JqZWN0IGlmIG5vbi1leGlzdGVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hbWVzcGFjZShvYmosIHBhdGgpe1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBvYmo7XG4gICAgICAgIGZvckVhY2gocGF0aC5zcGxpdCgnLicpLCBmdW5jdGlvbihrZXkpe1xuICAgICAgICAgICAgaWYgKCFvYmpba2V5XSkge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuYW1lc3BhY2U7XG5cblxuIiwidmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcbnZhciBjb250YWlucyA9IHJlcXVpcmUoJy4uL2FycmF5L2NvbnRhaW5zJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3QsIGZpbHRlcmVkIHRvIG9ubHkgY29udGFpbiBwcm9wZXJ0aWVzIGV4Y2VwdCB0aGUgYmxhY2tsaXN0ZWQga2V5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0KG9iaiwgdmFyX2tleXMpe1xuICAgICAgICB2YXIga2V5cyA9IHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICdzdHJpbmcnPyBhcmd1bWVudHNbMV0gOiBzbGljZShhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgb3V0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiAhY29udGFpbnMoa2V5cywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgb3V0W3Byb3BlcnR5XSA9IG9ialtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG9taXQ7XG5cblxuIiwidmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCwgZmlsdGVyZWQgdG8gb25seSBoYXZlIHZhbHVlcyBmb3IgdGhlIHdoaXRlbGlzdGVkIGtleXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmosIHZhcl9rZXlzKXtcbiAgICAgICAgdmFyIGtleXMgPSB0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAnc3RyaW5nJz8gYXJndW1lbnRzWzFdIDogc2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIG91dCA9IHt9LFxuICAgICAgICAgICAgaSA9IDAsIGtleTtcbiAgICAgICAgd2hpbGUgKGtleSA9IGtleXNbaSsrXSkge1xuICAgICAgICAgICAgb3V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGljaztcblxuXG4iLCJ2YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcbnZhciBwcm9wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vcHJvcCcpO1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBhIGxpc3Qgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKG9iaiwgcHJvcE5hbWUpe1xuICAgICAgICByZXR1cm4gbWFwKG9iaiwgcHJvcChwcm9wTmFtZSkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGx1Y2s7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgc2l6ZSA9IHJlcXVpcmUoJy4vc2l6ZScpO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHJlZHVjZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShvYmosIGNhbGxiYWNrLCBtZW1vLCB0aGlzT2JqKSB7XG4gICAgICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG5cbiAgICAgICAgaWYgKCFzaXplKG9iaikgJiYgIWluaXRpYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVkdWNlIG9mIGVtcHR5IG9iamVjdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGxpc3QpIHtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBjYWxsYmFjay5jYWxsKHRoaXNPYmosIG1lbW8sIHZhbHVlLCBrZXksIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcblxuXG4iLCJ2YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgcmVqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KG9iaiwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICByZXR1cm4gZmlsdGVyKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICB9LCB0aGlzT2JqKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlamVjdDtcblxuXG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2xhbmcvaXNGdW5jdGlvbicpO1xuXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iaiwgcHJvcCkge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBvYmpbcHJvcF07XG5cbiAgICAgICAgaWYocHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ocHJvcGVydHkpID8gcHJvcGVydHkuY2FsbChvYmopIDogcHJvcGVydHk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG5cbiIsInZhciBuYW1lc3BhY2UgPSByZXF1aXJlKCcuL25hbWVzcGFjZScpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IFwibmVzdGVkXCIgb2JqZWN0IHByb3BlcnR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iaiwgcHJvcCwgdmFsKXtcbiAgICAgICAgdmFyIHBhcnRzID0gKC9eKC4rKVxcLiguKykkLykuZXhlYyhwcm9wKTtcbiAgICAgICAgaWYgKHBhcnRzKXtcbiAgICAgICAgICAgIG5hbWVzcGFjZShvYmosIHBhcnRzWzFdKVtwYXJ0c1syXV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNldDtcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBvYmplY3Qgc2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUob2JqKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc2l6ZTtcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc29tZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUob2JqLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh2YWwsIGtleSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNvbWU7XG5cblxuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vaGFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBVbnNldCBvYmplY3QgcHJvcGVydHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqLCBwcm9wKXtcbiAgICAgICAgaWYgKGhhcyhvYmosIHByb3ApKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBwcm9wLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgbGFzdCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgd2hpbGUgKHByb3AgPSBwYXJ0cy5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChkZWxldGUgb2JqW2xhc3RdKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgcHJvcGVydHkgZG9lc24ndCBleGlzdCB0cmVhdCBhcyBkZWxldGVkXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5zZXQ7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb2JqZWN0IHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFscztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2NvbnRhaW5zJyA6IHJlcXVpcmUoJy4vcXVlcnlTdHJpbmcvY29udGFpbnMnKSxcbiAgICAnZGVjb2RlJyA6IHJlcXVpcmUoJy4vcXVlcnlTdHJpbmcvZGVjb2RlJyksXG4gICAgJ2VuY29kZScgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2VuY29kZScpLFxuICAgICdnZXRQYXJhbScgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2dldFBhcmFtJyksXG4gICAgJ2dldFF1ZXJ5JyA6IHJlcXVpcmUoJy4vcXVlcnlTdHJpbmcvZ2V0UXVlcnknKSxcbiAgICAncGFyc2UnIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZy9wYXJzZScpLFxuICAgICdzZXRQYXJhbScgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL3NldFBhcmFtJylcbn07XG5cblxuIiwidmFyIGdldFF1ZXJ5ID0gcmVxdWlyZSgnLi9nZXRRdWVyeScpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHF1ZXJ5IHN0cmluZyBjb250YWlucyBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnModXJsLCBwYXJhbU5hbWUpIHtcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKFxcXFw/fCYpJysgcGFyYW1OYW1lICsnPScsICdnJyk7IC8vbWF0Y2hlcyBgP3BhcmFtPWAgb3IgYCZwYXJhbT1gXG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KGdldFF1ZXJ5KHVybCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29udGFpbnM7XG5cbiIsInZhciB0eXBlY2FzdCA9IHJlcXVpcmUoJy4uL3N0cmluZy90eXBlY2FzdCcpO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy9pc1N0cmluZycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9vYmplY3QvaGFzT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgcXVlcnkgc3RyaW5nIGludG8gYW4gb2JqZWN0IG9mIGtleXMgPT4gdmFscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNvZGUocXVlcnlTdHIsIHNob3VsZFR5cGVjYXN0KSB7XG4gICAgICAgIHZhciBxdWVyeUFyciA9IChxdWVyeVN0ciB8fCAnJykucmVwbGFjZSgnPycsICcnKS5zcGxpdCgnJicpLFxuICAgICAgICAgICAgY291bnQgPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHF1ZXJ5QXJyLmxlbmd0aCxcbiAgICAgICAgICAgIG9iaiA9IHt9LFxuICAgICAgICAgICAgaXRlbSwgcFZhbHVlLCBwTmFtZSwgdG9TZXQ7XG5cbiAgICAgICAgd2hpbGUgKCsrY291bnQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBxdWVyeUFycltjb3VudF0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIHBOYW1lID0gaXRlbVswXTtcbiAgICAgICAgICAgIGlmICghcE5hbWUgfHwgIXBOYW1lLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwVmFsdWUgPSBzaG91bGRUeXBlY2FzdCA9PT0gZmFsc2UgPyBpdGVtWzFdIDogdHlwZWNhc3QoaXRlbVsxXSk7XG4gICAgICAgICAgICB0b1NldCA9IGlzU3RyaW5nKHBWYWx1ZSkgPyBkZWNvZGVVUklDb21wb25lbnQocFZhbHVlKSA6IHBWYWx1ZTtcbiAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLHBOYW1lKSl7XG4gICAgICAgICAgICAgICAgaWYoaXNBcnJheShvYmpbcE5hbWVdKSl7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwTmFtZV0ucHVzaCh0b1NldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW3BOYW1lXSA9IFtvYmpbcE5hbWVdLHRvU2V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtwTmFtZV0gPSB0b1NldDtcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuLi9vYmplY3QvZm9yT3duJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9hcnJheS9mb3JFYWNoJyk7XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlKG9iail7XG4gICAgICAgIHZhciBxdWVyeSA9IFtdLFxuICAgICAgICAgICAgYXJyVmFsdWVzLCByZWc7XG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIGFyclZhbHVlcyA9IGtleSArICc9JztcbiAgICAgICAgICAgICAgICByZWcgPSBuZXcgUmVnRXhwKCcmJytrZXkrJys9JCcpO1xuICAgICAgICAgICAgICAgIGZvckVhY2godmFsLCBmdW5jdGlvbiAoYVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyclZhbHVlcyArPSBlbmNvZGVVUklDb21wb25lbnQoYVZhbHVlKSArICcmJyArIGtleSArICc9JztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBxdWVyeS5wdXNoKGFyclZhbHVlcy5yZXBsYWNlKHJlZywgJycpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBxdWVyeS5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAocXVlcnkubGVuZ3RoKSA/ICc/JyArIHF1ZXJ5LmpvaW4oJyYnKSA6ICcnO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xuXG4iLCJ2YXIgdHlwZWNhc3QgPSByZXF1aXJlKCcuLi9zdHJpbmcvdHlwZWNhc3QnKTtcbnZhciBnZXRRdWVyeSA9IHJlcXVpcmUoJy4vZ2V0UXVlcnknKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBxdWVyeSBwYXJhbWV0ZXIgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGFyYW0odXJsLCBwYXJhbSwgc2hvdWxkVHlwZWNhc3Qpe1xuICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKFxcXFw/fCYpJysgcGFyYW0gKyAnPShbXiZdKiknKSwgLy9tYXRjaGVzIGA/cGFyYW09dmFsdWVgIG9yIGAmcGFyYW09dmFsdWVgLCB2YWx1ZSA9ICQyXG4gICAgICAgICAgICByZXN1bHQgPSByZWdleHAuZXhlYyggZ2V0UXVlcnkodXJsKSApLFxuICAgICAgICAgICAgdmFsID0gKHJlc3VsdCAmJiByZXN1bHRbMl0pPyByZXN1bHRbMl0gOiBudWxsO1xuICAgICAgICByZXR1cm4gc2hvdWxkVHlwZWNhc3QgPT09IGZhbHNlPyB2YWwgOiB0eXBlY2FzdCh2YWwpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0UGFyYW07XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogR2V0cyBmdWxsIHF1ZXJ5IGFzIHN0cmluZyB3aXRoIGFsbCBzcGVjaWFsIGNoYXJzIGRlY29kZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UXVlcnkodXJsKSB7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC8jLiovLCAnJyk7IC8vcmVtb3ZlcyBoYXNoICh0byBhdm9pZCBnZXR0aW5nIGhhc2ggcXVlcnkpXG4gICAgICAgIHZhciBxdWVyeVN0cmluZyA9IC9cXD9bYS16QS1aMC05XFw9XFwmXFwlXFwkXFwtXFxfXFwuXFwrXFwhXFwqXFwnXFwoXFwpXFwsXSsvLmV4ZWModXJsKTsgLy92YWxpZCBjaGFycyBhY2NvcmRpbmcgdG86IGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzE3MzgudHh0XG4gICAgICAgIHJldHVybiAocXVlcnlTdHJpbmcpPyBkZWNvZGVVUklDb21wb25lbnQocXVlcnlTdHJpbmdbMF0pIDogJyc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnZXRRdWVyeTtcblxuIiwidmFyIGRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG52YXIgZ2V0UXVlcnkgPSByZXF1aXJlKCcuL2dldFF1ZXJ5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcXVlcnkgc3RyaW5nLCBwYXJzZXMgYW5kIGRlY29kZXMgaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UodXJsLCBzaG91bGRUeXBlY2FzdCkge1xuICAgICAgICByZXR1cm4gZGVjb2RlKGdldFF1ZXJ5KHVybCksIHNob3VsZFR5cGVjYXN0KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogU2V0IHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRQYXJhbSh1cmwsIHBhcmFtTmFtZSwgdmFsdWUpe1xuICAgICAgICB1cmwgPSB1cmwgfHwgJyc7XG5cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnKFxcXFw/fCYpJysgcGFyYW1OYW1lICsnPVteJl0qJyApO1xuICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbU5hbWUgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXG4gICAgICAgIGlmICggcmUudGVzdCh1cmwpICkge1xuICAgICAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKHJlLCAnJDEnKyBwYXJhbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCc9JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9ICcmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmwgKyBwYXJhbTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZXRQYXJhbTtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2Nob2ljZScgOiByZXF1aXJlKCcuL3JhbmRvbS9jaG9pY2UnKSxcbiAgICAnZ3VpZCcgOiByZXF1aXJlKCcuL3JhbmRvbS9ndWlkJyksXG4gICAgJ3JhbmQnIDogcmVxdWlyZSgnLi9yYW5kb20vcmFuZCcpLFxuICAgICdyYW5kQml0JyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRCaXQnKSxcbiAgICAncmFuZEJvb2wnIDogcmVxdWlyZSgnLi9yYW5kb20vcmFuZEJvb2wnKSxcbiAgICAncmFuZEhleCcgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kSGV4JyksXG4gICAgJ3JhbmRJbnQnIDogcmVxdWlyZSgnLi9yYW5kb20vcmFuZEludCcpLFxuICAgICdyYW5kU2lnbicgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kU2lnbicpLFxuICAgICdyYW5kU3RyaW5nJyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRTdHJpbmcnKSxcbiAgICAncmFuZG9tJyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRvbScpXG59O1xuXG5cbiIsInZhciByYW5kSW50ID0gcmVxdWlyZSgnLi9yYW5kSW50Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBlbGVtZW50IGZyb20gdGhlIHN1cHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIG9yIGZyb20gdGhlIGFycmF5IChpZiBzaW5nbGUgYXJndW1lbnQgaXMgYW4gYXJyYXkpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNob2ljZShpdGVtcykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShpdGVtcykpPyBpdGVtcyA6IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIHRhcmdldFsgcmFuZEludCgwLCB0YXJnZXQubGVuZ3RoIC0gMSkgXTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNob2ljZTtcblxuXG4iLCJ2YXIgcmFuZEhleCA9IHJlcXVpcmUoJy4vcmFuZEhleCcpO1xudmFyIGNob2ljZSA9IHJlcXVpcmUoJy4vY2hvaWNlJyk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcHNldWRvLXJhbmRvbSBndWlkIChVVUlEIHY0KVxuICAgKiBJTVBPUlRBTlQ6IGl0J3Mgbm90IHRvdGFsbHkgXCJzYWZlXCIgc2luY2UgcmFuZEhleC9jaG9pY2UgdXNlcyBNYXRoLnJhbmRvbVxuICAgKiBieSBkZWZhdWx0IGFuZCBzZXF1ZW5jZXMgY2FuIGJlIHByZWRpY3RlZCBpbiBzb21lIGNhc2VzLiBTZWUgdGhlXG4gICAqIFwicmFuZG9tL3JhbmRvbVwiIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mbyBhYm91dCBpdCBhbmQgaG93IHRvIHJlcGxhY2VcbiAgICogdGhlIGRlZmF1bHQgUFJORy5cbiAgICovXG4gIGZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgcmFuZEhleCg4KSsnLScrXG4gICAgICAgIHJhbmRIZXgoNCkrJy0nK1xuICAgICAgICAvLyB2NCBVVUlEIGFsd2F5cyBjb250YWluIFwiNFwiIGF0IHRoaXMgcG9zaXRpb24gdG8gc3BlY2lmeSBpdCB3YXNcbiAgICAgICAgLy8gcmFuZG9tbHkgZ2VuZXJhdGVkXG4gICAgICAgICc0JyArIHJhbmRIZXgoMykgKyctJytcbiAgICAgICAgLy8gdjQgVVVJRCBhbHdheXMgY29udGFpbiBjaGFycyBbYSxiLDgsOV0gYXQgdGhpcyBwb3NpdGlvblxuICAgICAgICBjaG9pY2UoOCwgOSwgJ2EnLCAnYicpICsgcmFuZEhleCgzKSsnLScrXG4gICAgICAgIHJhbmRIZXgoMTIpXG4gICAgKTtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IGd1aWQ7XG5cbiIsInZhciByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xudmFyIE1JTl9JTlQgPSByZXF1aXJlKCcuLi9udW1iZXIvTUlOX0lOVCcpO1xudmFyIE1BWF9JTlQgPSByZXF1aXJlKCcuLi9udW1iZXIvTUFYX0lOVCcpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByYW5kb20gbnVtYmVyIGluc2lkZSByYW5nZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmQobWluLCBtYXgpe1xuICAgICAgICBtaW4gPSBtaW4gPT0gbnVsbD8gTUlOX0lOVCA6IG1pbjtcbiAgICAgICAgbWF4ID0gbWF4ID09IG51bGw/IE1BWF9JTlQgOiBtYXg7XG4gICAgICAgIHJldHVybiBtaW4gKyAobWF4IC0gbWluKSAqIHJhbmRvbSgpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZDtcblxuIiwidmFyIHJhbmRCb29sID0gcmVxdWlyZSgnLi9yYW5kQm9vbCcpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByYW5kb20gYml0ICgwIG9yIDEpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tQml0KCkge1xuICAgICAgICByZXR1cm4gcmFuZEJvb2woKT8gMSA6IDA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CaXQ7XG5cbiIsInZhciByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIHJhbmRvbSBib29sZWFuIHZhbHVlICh0cnVlIG9yIGZhbHNlKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRCb29sKCl7XG4gICAgICAgIHJldHVybiByYW5kb20oKSA+PSAwLjU7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByYW5kQm9vbDtcblxuXG4iLCJ2YXIgY2hvaWNlID0gcmVxdWlyZSgnLi9jaG9pY2UnKTtcblxuICAgIHZhciBfY2hhcnMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBoZXhhZGVjaW1hbCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kSGV4KHNpemUpe1xuICAgICAgICBzaXplID0gc2l6ZSAmJiBzaXplID4gMD8gc2l6ZSA6IDY7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgc3RyICs9IGNob2ljZShfY2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByYW5kSGV4O1xuXG5cbiIsInZhciBNSU5fSU5UID0gcmVxdWlyZSgnLi4vbnVtYmVyL01JTl9JTlQnKTtcbnZhciBNQVhfSU5UID0gcmVxdWlyZSgnLi4vbnVtYmVyL01BWF9JTlQnKTtcbnZhciByYW5kID0gcmVxdWlyZSgnLi9yYW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHJhbmRvbSBpbnRlZ2VyIGluc2lkZSByYW5nZSBvciBzbmFwIHRvIG1pbi9tYXggdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRJbnQobWluLCBtYXgpe1xuICAgICAgICBtaW4gPSBtaW4gPT0gbnVsbD8gTUlOX0lOVCA6IH5+bWluO1xuICAgICAgICBtYXggPSBtYXggPT0gbnVsbD8gTUFYX0lOVCA6IH5+bWF4O1xuICAgICAgICAvLyBjYW4ndCBiZSBtYXggKyAwLjUgb3RoZXJ3aXNlIGl0IHdpbGwgcm91bmQgdXAgaWYgYHJhbmRgXG4gICAgICAgIC8vIHJldHVybnMgYG1heGAgY2F1c2luZyBpdCB0byBvdmVyZmxvdyByYW5nZS5cbiAgICAgICAgLy8gLTAuNSBhbmQgKyAwLjQ5IGFyZSByZXF1aXJlZCB0byBhdm9pZCBiaWFzIGNhdXNlZCBieSByb3VuZGluZ1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCggcmFuZChtaW4gLSAwLjUsIG1heCArIDAuNDk5OTk5OTk5OTk5KSApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZEludDtcblxuIiwidmFyIHJhbmRCb29sID0gcmVxdWlyZSgnLi9yYW5kQm9vbCcpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByYW5kb20gc2lnbiAoLTEgb3IgMSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb21TaWduKCkge1xuICAgICAgICByZXR1cm4gcmFuZEJvb2woKT8gMSA6IC0xO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tU2lnbjtcblxuIiwidmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi4vbGFuZy9pc051bWJlcicpO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy9pc1N0cmluZycpO1xudmFyIHJhbmRJbnQgPSByZXF1aXJlKCcuL3JhbmRJbnQnKTtcblxuICAgIHZhciBkZWZhdWx0RGljdGlvbmFyeSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcblxuICAgIGZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGgsIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgaWYoIWlzTnVtYmVyKGxlbmd0aCkgfHwgbGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICBsZW5ndGggPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWlzU3RyaW5nKGRpY3Rpb25hcnkpIHx8IGRpY3Rpb25hcnkubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIGRpY3Rpb25hcnkgPSBkZWZhdWx0RGljdGlvbmFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGRvbWFpbiA9IGRpY3Rpb25hcnkubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZShsZW5ndGgtLSkge1xuICAgICAgICAgIHJlc3VsdCArPSBkaWN0aW9uYXJ5W3JhbmRJbnQoMCwgZG9tYWluKV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21TdHJpbmc7XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogSnVzdCBhIHdyYXBwZXIgdG8gTWF0aC5yYW5kb20uIE5vIG1ldGhvZHMgaW5zaWRlIG1vdXQvcmFuZG9tIHNob3VsZCBjYWxsXG4gICAgICogTWF0aC5yYW5kb20oKSBkaXJlY3RseSBzbyB3ZSBjYW4gaW5qZWN0IHRoZSBwc2V1ZG8tcmFuZG9tIG51bWJlclxuICAgICAqIGdlbmVyYXRvciBpZiBuZWVkZWQgKGllLiBpbiBjYXNlIHdlIG5lZWQgYSBzZWVkZWQgcmFuZG9tIG9yIGEgYmV0dGVyXG4gICAgICogYWxnb3JpdGhtIHRoYW4gdGhlIG5hdGl2ZSBvbmUpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKCl7XG4gICAgICAgIHJldHVybiByYW5kb20uZ2V0KCk7XG4gICAgfVxuXG4gICAgLy8gd2UgZXhwb3NlIHRoZSBtZXRob2Qgc28gaXQgY2FuIGJlIHN3YXBwZWQgaWYgbmVlZGVkXG4gICAgcmFuZG9tLmdldCA9IE1hdGgucmFuZG9tO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb207XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdXSElURV9TUEFDRVMnIDogcmVxdWlyZSgnLi9zdHJpbmcvV0hJVEVfU1BBQ0VTJyksXG4gICAgJ2NhbWVsQ2FzZScgOiByZXF1aXJlKCcuL3N0cmluZy9jYW1lbENhc2UnKSxcbiAgICAnY29udGFpbnMnIDogcmVxdWlyZSgnLi9zdHJpbmcvY29udGFpbnMnKSxcbiAgICAnY3JvcCcgOiByZXF1aXJlKCcuL3N0cmluZy9jcm9wJyksXG4gICAgJ2VuZHNXaXRoJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2VuZHNXaXRoJyksXG4gICAgJ2VzY2FwZUh0bWwnIDogcmVxdWlyZSgnLi9zdHJpbmcvZXNjYXBlSHRtbCcpLFxuICAgICdlc2NhcGVSZWdFeHAnIDogcmVxdWlyZSgnLi9zdHJpbmcvZXNjYXBlUmVnRXhwJyksXG4gICAgJ2VzY2FwZVVuaWNvZGUnIDogcmVxdWlyZSgnLi9zdHJpbmcvZXNjYXBlVW5pY29kZScpLFxuICAgICdoeXBoZW5hdGUnIDogcmVxdWlyZSgnLi9zdHJpbmcvaHlwaGVuYXRlJyksXG4gICAgJ2luc2VydCcgOiByZXF1aXJlKCcuL3N0cmluZy9pbnNlcnQnKSxcbiAgICAnaW50ZXJwb2xhdGUnIDogcmVxdWlyZSgnLi9zdHJpbmcvaW50ZXJwb2xhdGUnKSxcbiAgICAnbG93ZXJDYXNlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2xvd2VyQ2FzZScpLFxuICAgICdscGFkJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2xwYWQnKSxcbiAgICAnbHRyaW0nIDogcmVxdWlyZSgnLi9zdHJpbmcvbHRyaW0nKSxcbiAgICAnbWFrZVBhdGgnIDogcmVxdWlyZSgnLi9zdHJpbmcvbWFrZVBhdGgnKSxcbiAgICAnbm9ybWFsaXplTGluZUJyZWFrcycgOiByZXF1aXJlKCcuL3N0cmluZy9ub3JtYWxpemVMaW5lQnJlYWtzJyksXG4gICAgJ3Bhc2NhbENhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvcGFzY2FsQ2FzZScpLFxuICAgICdwcm9wZXJDYXNlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3Byb3BlckNhc2UnKSxcbiAgICAncmVtb3ZlTm9uQVNDSUknIDogcmVxdWlyZSgnLi9zdHJpbmcvcmVtb3ZlTm9uQVNDSUknKSxcbiAgICAncmVtb3ZlTm9uV29yZCcgOiByZXF1aXJlKCcuL3N0cmluZy9yZW1vdmVOb25Xb3JkJyksXG4gICAgJ3JlcGVhdCcgOiByZXF1aXJlKCcuL3N0cmluZy9yZXBlYXQnKSxcbiAgICAncmVwbGFjZScgOiByZXF1aXJlKCcuL3N0cmluZy9yZXBsYWNlJyksXG4gICAgJ3JlcGxhY2VBY2NlbnRzJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3JlcGxhY2VBY2NlbnRzJyksXG4gICAgJ3JwYWQnIDogcmVxdWlyZSgnLi9zdHJpbmcvcnBhZCcpLFxuICAgICdydHJpbScgOiByZXF1aXJlKCcuL3N0cmluZy9ydHJpbScpLFxuICAgICdzZW50ZW5jZUNhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvc2VudGVuY2VDYXNlJyksXG4gICAgJ3NsdWdpZnknIDogcmVxdWlyZSgnLi9zdHJpbmcvc2x1Z2lmeScpLFxuICAgICdzdGFydHNXaXRoJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3N0YXJ0c1dpdGgnKSxcbiAgICAnc3RyaXBIdG1sVGFncycgOiByZXF1aXJlKCcuL3N0cmluZy9zdHJpcEh0bWxUYWdzJyksXG4gICAgJ3RyaW0nIDogcmVxdWlyZSgnLi9zdHJpbmcvdHJpbScpLFxuICAgICd0cnVuY2F0ZScgOiByZXF1aXJlKCcuL3N0cmluZy90cnVuY2F0ZScpLFxuICAgICd0eXBlY2FzdCcgOiByZXF1aXJlKCcuL3N0cmluZy90eXBlY2FzdCcpLFxuICAgICd1bkNhbWVsQ2FzZScgOiByZXF1aXJlKCcuL3N0cmluZy91bkNhbWVsQ2FzZScpLFxuICAgICd1bmRlcnNjb3JlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3VuZGVyc2NvcmUnKSxcbiAgICAndW5lc2NhcGVIdG1sJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3VuZXNjYXBlSHRtbCcpLFxuICAgICd1bmVzY2FwZVVuaWNvZGUnIDogcmVxdWlyZSgnLi9zdHJpbmcvdW5lc2NhcGVVbmljb2RlJyksXG4gICAgJ3VuaHlwaGVuYXRlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3VuaHlwaGVuYXRlJyksXG4gICAgJ3VwcGVyQ2FzZScgOiByZXF1aXJlKCcuL3N0cmluZy91cHBlckNhc2UnKVxufTtcblxuXG4iLCJcbiAgICAvKipcbiAgICAgKiBDb250YWlucyBhbGwgVW5pY29kZSB3aGl0ZS1zcGFjZXMuIFRha2VuIGZyb21cbiAgICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1doaXRlc3BhY2VfY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gW1xuICAgICAgICAnICcsICdcXG4nLCAnXFxyJywgJ1xcdCcsICdcXGYnLCAnXFx2JywgJ1xcdTAwQTAnLCAnXFx1MTY4MCcsICdcXHUxODBFJyxcbiAgICAgICAgJ1xcdTIwMDAnLCAnXFx1MjAwMScsICdcXHUyMDAyJywgJ1xcdTIwMDMnLCAnXFx1MjAwNCcsICdcXHUyMDA1JywgJ1xcdTIwMDYnLFxuICAgICAgICAnXFx1MjAwNycsICdcXHUyMDA4JywgJ1xcdTIwMDknLCAnXFx1MjAwQScsICdcXHUyMDI4JywgJ1xcdTIwMjknLCAnXFx1MjAyRicsXG4gICAgICAgICdcXHUyMDVGJywgJ1xcdTMwMDAnXG4gICAgXTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHJlcGxhY2VBY2NlbnRzID0gcmVxdWlyZSgnLi9yZXBsYWNlQWNjZW50cycpO1xudmFyIHJlbW92ZU5vbldvcmQgPSByZXF1aXJlKCcuL3JlbW92ZU5vbldvcmQnKTtcbnZhciB1cHBlckNhc2UgPSByZXF1aXJlKCcuL3VwcGVyQ2FzZScpO1xudmFyIGxvd2VyQ2FzZSA9IHJlcXVpcmUoJy4vbG93ZXJDYXNlJyk7XG4gICAgLyoqXG4gICAgKiBDb252ZXJ0IHN0cmluZyB0byBjYW1lbENhc2UgdGV4dC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBzdHIgPSByZXBsYWNlQWNjZW50cyhzdHIpO1xuICAgICAgICBzdHIgPSByZW1vdmVOb25Xb3JkKHN0cilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFwtX10vZywgJyAnKSAvL2NvbnZlcnQgYWxsIGh5cGhlbnMgYW5kIHVuZGVyc2NvcmVzIHRvIHNwYWNlc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcc1thLXpdL2csIHVwcGVyQ2FzZSkgLy9jb252ZXJ0IGZpcnN0IGNoYXIgb2YgZWFjaCB3b3JkIHRvIFVQUEVSQ0FTRVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJycpIC8vcmVtb3ZlIHNwYWNlc1xuICAgICAgICAgICAgLnJlcGxhY2UoL15bQS1aXS9nLCBsb3dlckNhc2UpOyAvL2NvbnZlcnQgZmlyc3QgY2hhciB0byBsb3dlcmNhc2VcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjYW1lbENhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBhIGdpdmVuIHN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgc3Vic3RyaW5nLCBmcm9tSW5kZXgpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBzdWJzdHJpbmcgPSB0b1N0cmluZyhzdWJzdHJpbmcpO1xuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2Yoc3Vic3RyaW5nLCBmcm9tSW5kZXgpICE9PSAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciB0cnVuY2F0ZSA9IHJlcXVpcmUoJy4vdHJ1bmNhdGUnKTtcbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZSBzdHJpbmcgYXQgZnVsbCB3b3Jkcy5cbiAgICAgKi9cbiAgICAgZnVuY3Rpb24gY3JvcChzdHIsIG1heENoYXJzLCBhcHBlbmQpIHtcbiAgICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgICByZXR1cm4gdHJ1bmNhdGUoc3RyLCBtYXhDaGFycywgYXBwZW5kLCB0cnVlKTtcbiAgICAgfVxuXG4gICAgIG1vZHVsZS5leHBvcnRzID0gY3JvcDtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzdHJpbmcgZW5kcyB3aXRoIHNwZWNpZmllZCBzdWZmaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3VmZml4ID0gdG9TdHJpbmcoc3VmZml4KTtcblxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2Yoc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZW5kc1dpdGg7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgYSBzdHJpbmcgZm9yIGluc2VydGlvbiBpbnRvIEhUTUwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMzk7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVIdG1sO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBSZWdFeHAgc3RyaW5nIGNoYXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHN0cikucmVwbGFjZSgvXFxXL2csJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZXNjYXBlUmVnRXhwO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBzdHJpbmcgaW50byB1bmljb2RlIHNlcXVlbmNlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVVuaWNvZGUoc3RyLCBzaG91bGRFc2NhcGVQcmludGFibGUpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHNcXFNdL2csIGZ1bmN0aW9uKGNoKXtcbiAgICAgICAgICAgIC8vIHNraXAgcHJpbnRhYmxlIEFTQ0lJIGNoYXJzIGlmIHdlIHNob3VsZCBub3QgZXNjYXBlIHRoZW1cbiAgICAgICAgICAgIGlmICghc2hvdWxkRXNjYXBlUHJpbnRhYmxlICYmICgvW1xceDIwLVxceDdFXS8pLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgdXNlIFwiMDAwXCIgYW5kIHNsaWNlKC00KSBmb3IgYnJldml0eSwgbmVlZCB0byBwYWQgemVyb3MsXG4gICAgICAgICAgICAvLyB1bmljb2RlIGVzY2FwZSBhbHdheXMgaGF2ZSA0IGNoYXJzIGFmdGVyIFwiXFx1XCJcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUnKyAoJzAwMCcrIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZXNjYXBlVW5pY29kZTtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgc2x1Z2lmeSA9IHJlcXVpcmUoJy4vc2x1Z2lmeScpO1xudmFyIHVuQ2FtZWxDYXNlID0gcmVxdWlyZSgnLi91bkNhbWVsQ2FzZScpO1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIGh5cGhlbnMsIHNwbGl0IGNhbWVsQ2FzZSB0ZXh0LCByZW1vdmUgbm9uLXdvcmQgY2hhcnMsIHJlbW92ZSBhY2NlbnRzIGFuZCBjb252ZXJ0IHRvIGxvd2VyIGNhc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHlwaGVuYXRlKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHN0ciA9IHVuQ2FtZWxDYXNlKHN0cik7XG4gICAgICAgIHJldHVybiBzbHVnaWZ5KHN0ciwgXCItXCIpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG4iLCJ2YXIgY2xhbXAgPSByZXF1aXJlKCcuLi9tYXRoL2NsYW1wJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgc3RyaW5nIGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHN0cmluZywgaW5kZXgsIHBhcnRpYWwpe1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gc3RyaW5nLmxlbmd0aCArIGluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBjbGFtcChpbmRleCwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgaW5kZXgpICsgcGFydGlhbCArIHN0cmluZy5zdWJzdHIoaW5kZXgpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW5zZXJ0O1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuLi9vYmplY3QvZ2V0Jyk7XG5cbiAgICB2YXIgc3RhY2hlID0gL1xce1xceyhbXlxcfV0rKVxcfVxcfS9nOyAvL211c3RhY2hlLWxpa2VcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyBpbnRlcnBvbGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUodGVtcGxhdGUsIHJlcGxhY2VtZW50cywgc3ludGF4KXtcbiAgICAgICAgdGVtcGxhdGUgPSB0b1N0cmluZyh0ZW1wbGF0ZSk7XG4gICAgICAgIHZhciByZXBsYWNlRm4gPSBmdW5jdGlvbihtYXRjaCwgcHJvcCl7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcoIGdldChyZXBsYWNlbWVudHMsIHByb3ApICk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHN5bnRheCB8fCBzdGFjaGUsIHJlcGxhY2VGbik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZTtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogXCJTYWZlclwiIFN0cmluZy50b0xvd2VyQ2FzZSgpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG93ZXJDYXNlKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxvd2VyQ2FzZTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vcmVwZWF0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWQgc3RyaW5nIHdpdGggYGNoYXJgIGlmIGl0cycgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiBgbWluTGVuYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxwYWQoc3RyLCBtaW5MZW4sIGNoKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGNoID0gY2ggfHwgJyAnO1xuXG4gICAgICAgIHJldHVybiAoc3RyLmxlbmd0aCA8IG1pbkxlbikgP1xuICAgICAgICAgICAgcmVwZWF0KGNoLCBtaW5MZW4gLSBzdHIubGVuZ3RoKSArIHN0ciA6IHN0cjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxwYWQ7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIFdISVRFX1NQQUNFUyA9IHJlcXVpcmUoJy4vV0hJVEVfU1BBQ0VTJyk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNoYXJzIGZyb20gYmVnaW5uaW5nIG9mIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsdHJpbShzdHIsIGNoYXJzKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGNoYXJzID0gY2hhcnMgfHwgV0hJVEVfU1BBQ0VTO1xuXG4gICAgICAgIHZhciBzdGFydCA9IDAsXG4gICAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoLFxuICAgICAgICAgICAgY2hhckxlbiA9IGNoYXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZSxcbiAgICAgICAgICAgIGksIGM7XG5cbiAgICAgICAgd2hpbGUgKGZvdW5kICYmIHN0YXJ0IDwgbGVuKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgYyA9IHN0ci5jaGFyQXQoc3RhcnQpO1xuXG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgY2hhckxlbikge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBjaGFyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoc3RhcnQgPj0gbGVuKSA/ICcnIDogc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGx0cmltO1xuXG4iLCJ2YXIgam9pbiA9IHJlcXVpcmUoJy4uL2FycmF5L2pvaW4nKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBHcm91cCBhcmd1bWVudHMgYXMgcGF0aCBzZWdtZW50cywgaWYgYW55IG9mIHRoZSBhcmdzIGlzIGBudWxsYCBvciBhblxuICAgICAqIGVtcHR5IHN0cmluZyBpdCB3aWxsIGJlIGlnbm9yZWQgZnJvbSByZXN1bHRpbmcgcGF0aC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlUGF0aCh2YXJfYXJncyl7XG4gICAgICAgIHZhciByZXN1bHQgPSBqb2luKHNsaWNlKGFyZ3VtZW50cyksICcvJyk7XG4gICAgICAgIC8vIG5lZWQgdG8gZGlzY29uc2lkZXIgZHVwbGljYXRlICcvJyBhZnRlciBwcm90b2NvbCAoZWc6ICdodHRwOi8vJylcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC8oW146XFwvXXxeKVxcL3syLH0vZywgJyQxLycpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZVBhdGg7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbGluZS1icmVha3MgZnJvbSBET1MvTUFDIHRvIGEgc2luZ2xlIHN0YW5kYXJkIChVTklYIGJ5IGRlZmF1bHQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTGluZUJyZWFrcyhzdHIsIGxpbmVFbmQpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgbGluZUVuZCA9IGxpbmVFbmQgfHwgJ1xcbic7XG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCBsaW5lRW5kKSAvLyBET1NcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgbGluZUVuZCkgICAvLyBNYWNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgbGluZUVuZCk7ICAvLyBVbml4XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemVMaW5lQnJlYWtzO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBjYW1lbENhc2UgPSByZXF1aXJlKCcuL2NhbWVsQ2FzZScpO1xudmFyIHVwcGVyQ2FzZSA9IHJlcXVpcmUoJy4vdXBwZXJDYXNlJyk7XG4gICAgLyoqXG4gICAgICogY2FtZWxDYXNlICsgVVBQRVJDQVNFIGZpcnN0IGNoYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXNjYWxDYXNlKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHJldHVybiBjYW1lbENhc2Uoc3RyKS5yZXBsYWNlKC9eW2Etel0vLCB1cHBlckNhc2UpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGFzY2FsQ2FzZTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIGxvd2VyQ2FzZSA9IHJlcXVpcmUoJy4vbG93ZXJDYXNlJyk7XG52YXIgdXBwZXJDYXNlID0gcmVxdWlyZSgnLi91cHBlckNhc2UnKTtcbiAgICAvKipcbiAgICAgKiBVUFBFUkNBU0UgZmlyc3QgY2hhciBvZiBlYWNoIHdvcmQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVyQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gbG93ZXJDYXNlKHN0cikucmVwbGFjZSgvXlxcd3xcXHNcXHcvZywgdXBwZXJDYXNlKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHByb3BlckNhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbm9uLXByaW50YWJsZSBBU0NJSSBjaGFyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZU5vbkFTQ0lJKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG5cbiAgICAgICAgLy8gTWF0Y2hlcyBub24tcHJpbnRhYmxlIEFTQ0lJIGNoYXJzIC1cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BU0NJSSNBU0NJSV9wcmludGFibGVfY2hhcmFjdGVyc1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teXFx4MjAtXFx4N0VdL2csICcnKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZU5vbkFTQ0lJO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLy8gVGhpcyBwYXR0ZXJuIGlzIGdlbmVyYXRlZCBieSB0aGUgX2J1aWxkL3BhdHRlcm4tcmVtb3ZlTm9uV29yZC5qcyBzY3JpcHRcbiAgICB2YXIgUEFUVEVSTiA9IC9bXlxceDIwXFx4MkQwLTlBLVpcXHg1RmEtelxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHhGRl0vZztcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBub24td29yZCBjaGFycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVOb25Xb3JkKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShQQVRURVJOLCAnJyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZW1vdmVOb25Xb3JkO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgdG9JbnQgPSByZXF1aXJlKCcuLi9udW1iZXIvdG9JbnQnKTtcblxuICAgIC8qKlxuICAgICAqIFJlcGVhdCBzdHJpbmcgbiB0aW1lc1xuICAgICAqL1xuICAgICBmdW5jdGlvbiByZXBlYXQoc3RyLCBuKXtcbiAgICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgICBuID0gdG9JbnQobik7XG4gICAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBNYXRoLmZsb29yKG4gLyAyKTtcbiAgICAgICAgICAgIHN0ciArPSBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgfVxuXG4gICAgIG1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy90b0FycmF5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHN0cmluZyhzKSB3aXRoIHRoZSByZXBsYWNlbWVudChzKSBpbiB0aGUgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc3RyLCBzZWFyY2gsIHJlcGxhY2VtZW50cykge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBzZWFyY2ggPSB0b0FycmF5KHNlYXJjaCk7XG4gICAgICAgIHJlcGxhY2VtZW50cyA9IHRvQXJyYXkocmVwbGFjZW1lbnRzKTtcblxuICAgICAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoLmxlbmd0aCxcbiAgICAgICAgICAgIHJlcGxhY2VtZW50c0xlbmd0aCA9IHJlcGxhY2VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50c0xlbmd0aCAhPT0gMSAmJiBzZWFyY2hMZW5ndGggIT09IHJlcGxhY2VtZW50c0xlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmVxdWFsIG51bWJlciBvZiBzZWFyY2hlcyBhbmQgcmVwbGFjZW1lbnRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgc2VhcmNoTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IHJlcGxhY2VtZW50IGZvciBhbGwgc2VhcmNoZXMgaWYgb25seSBvbmVcbiAgICAgICAgICAgIC8vIHJlcGxhY2VtZW50IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShcbiAgICAgICAgICAgICAgICBzZWFyY2hbaV0sXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzWyhyZXBsYWNlbWVudHNMZW5ndGggPT09IDEpID8gMCA6IGldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXBsYWNlO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAqIFJlcGxhY2VzIGFsbCBhY2NlbnRlZCBjaGFycyB3aXRoIHJlZ3VsYXIgb25lc1xuICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZUFjY2VudHMoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcblxuICAgICAgICAvLyB2ZXJpZmllcyBpZiB0aGUgU3RyaW5nIGhhcyBhY2NlbnRzIGFuZCByZXBsYWNlIHRoZW1cbiAgICAgICAgaWYgKHN0ci5zZWFyY2goL1tcXHhDMC1cXHhGRl0vZykgPiAtMSkge1xuICAgICAgICAgICAgc3RyID0gc3RyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4QzAtXFx4QzVdL2csIFwiQVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEM2XS9nLCBcIkFFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4QzddL2csIFwiQ1wiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEM4LVxceENCXS9nLCBcIkVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhDQy1cXHhDRl0vZywgXCJJXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RDBdL2csIFwiRFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEQxXS9nLCBcIk5cIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhEMi1cXHhENlxceEQ4XS9nLCBcIk9cIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhEOS1cXHhEQ10vZywgXCJVXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RERdL2csIFwiWVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceERFXS9nLCBcIlBcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhFMC1cXHhFNV0vZywgXCJhXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RTZdL2csIFwiYWVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhFN10vZywgXCJjXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RTgtXFx4RUJdL2csIFwiZVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEVDLVxceEVGXS9nLCBcImlcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhGMV0vZywgXCJuXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RjItXFx4RjZcXHhGOF0vZywgXCJvXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RjktXFx4RkNdL2csIFwidVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEZFXS9nLCBcInBcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhGRFxceEZGXS9nLCBcInlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXBsYWNlQWNjZW50cztcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vcmVwZWF0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWQgc3RyaW5nIHdpdGggYGNoYXJgIGlmIGl0cycgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiBgbWluTGVuYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJwYWQoc3RyLCBtaW5MZW4sIGNoKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGNoID0gY2ggfHwgJyAnO1xuICAgICAgICByZXR1cm4gKHN0ci5sZW5ndGggPCBtaW5MZW4pPyBzdHIgKyByZXBlYXQoY2gsIG1pbkxlbiAtIHN0ci5sZW5ndGgpIDogc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcnBhZDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgV0hJVEVfU1BBQ0VTID0gcmVxdWlyZSgnLi9XSElURV9TUEFDRVMnKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY2hhcnMgZnJvbSBlbmQgb2Ygc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ0cmltKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgY2hhcnMgPSBjaGFycyB8fCBXSElURV9TUEFDRVM7XG5cbiAgICAgICAgdmFyIGVuZCA9IHN0ci5sZW5ndGggLSAxLFxuICAgICAgICAgICAgY2hhckxlbiA9IGNoYXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZSxcbiAgICAgICAgICAgIGksIGM7XG5cbiAgICAgICAgd2hpbGUgKGZvdW5kICYmIGVuZCA+PSAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgYyA9IHN0ci5jaGFyQXQoZW5kKTtcblxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGNoYXJMZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gY2hhcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChlbmQgPj0gMCkgPyBzdHIuc3Vic3RyaW5nKDAsIGVuZCArIDEpIDogJyc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBydHJpbTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIGxvd2VyQ2FzZSA9IHJlcXVpcmUoJy4vbG93ZXJDYXNlJyk7XG52YXIgdXBwZXJDYXNlID0gcmVxdWlyZSgnLi91cHBlckNhc2UnKTtcbiAgICAvKipcbiAgICAgKiBVUFBFUkNBU0UgZmlyc3QgY2hhciBvZiBlYWNoIHNlbnRlbmNlIGFuZCBsb3dlcmNhc2Ugb3RoZXIgY2hhcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VudGVuY2VDYXNlKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBmaXJzdCBjaGFyIG9mIGVhY2ggc2VudGVuY2UgKG5ldyBsaW5lIG9yIGFmdGVyICcuXFxzKycpIHRvXG4gICAgICAgIC8vIFVQUEVSQ0FTRVxuICAgICAgICByZXR1cm4gbG93ZXJDYXNlKHN0cikucmVwbGFjZSgvKF5cXHcpfFxcLlxccysoXFx3KS9nbSwgdXBwZXJDYXNlKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZW50ZW5jZUNhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciByZXBsYWNlQWNjZW50cyA9IHJlcXVpcmUoJy4vcmVwbGFjZUFjY2VudHMnKTtcbnZhciByZW1vdmVOb25Xb3JkID0gcmVxdWlyZSgnLi9yZW1vdmVOb25Xb3JkJyk7XG52YXIgdHJpbSA9IHJlcXVpcmUoJy4vdHJpbScpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdG8gbG93ZXIgY2FzZSwgcmVtb3ZlIGFjY2VudHMsIHJlbW92ZSBub24td29yZCBjaGFycyBhbmRcbiAgICAgKiByZXBsYWNlIHNwYWNlcyB3aXRoIHRoZSBzcGVjaWZpZWQgZGVsaW1ldGVyLlxuICAgICAqIERvZXMgbm90IHNwbGl0IGNhbWVsQ2FzZSB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsdWdpZnkoc3RyLCBkZWxpbWV0ZXIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuXG4gICAgICAgIGlmIChkZWxpbWV0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsaW1ldGVyID0gXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gcmVwbGFjZUFjY2VudHMoc3RyKTtcbiAgICAgICAgc3RyID0gcmVtb3ZlTm9uV29yZChzdHIpO1xuICAgICAgICBzdHIgPSB0cmltKHN0cikgLy9zaG91bGQgY29tZSBhZnRlciByZW1vdmVOb25Xb3JkXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyArL2csIGRlbGltZXRlcikgLy9yZXBsYWNlIHNwYWNlcyB3aXRoIGRlbGltZXRlclxuICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNsdWdpZnk7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3RyaW5nIHN0YXJ0cyB3aXRoIHNwZWNpZmllZCBwcmVmaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBwcmVmaXggPSB0b1N0cmluZyhwcmVmaXgpO1xuXG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihwcmVmaXgpID09PSAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc3RhcnRzV2l0aDtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBIVE1MIHRhZ3MgZnJvbSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBIdG1sVGFncyhzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvPFtePl0qPi9nLCAnJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gc3RyaXBIdG1sVGFncztcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIFdISVRFX1NQQUNFUyA9IHJlcXVpcmUoJy4vV0hJVEVfU1BBQ0VTJyk7XG52YXIgbHRyaW0gPSByZXF1aXJlKCcuL2x0cmltJyk7XG52YXIgcnRyaW0gPSByZXF1aXJlKCcuL3J0cmltJyk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHdoaXRlLXNwYWNlcyBmcm9tIGJlZ2lubmluZyBhbmQgZW5kIG9mIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgY2hhcnMgPSBjaGFycyB8fCBXSElURV9TUEFDRVM7XG4gICAgICAgIHJldHVybiBsdHJpbShydHJpbShzdHIsIGNoYXJzKSwgY2hhcnMpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdHJpbTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHRyaW0gPSByZXF1aXJlKCcuL3RyaW0nKTtcbiAgICAvKipcbiAgICAgKiBMaW1pdCBudW1iZXIgb2YgY2hhcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyLCBtYXhDaGFycywgYXBwZW5kLCBvbmx5RnVsbFdvcmRzKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgYXBwZW5kID0gYXBwZW5kIHx8ICcuLi4nO1xuICAgICAgICBtYXhDaGFycyA9IG9ubHlGdWxsV29yZHM/IG1heENoYXJzICsgMSA6IG1heENoYXJzO1xuXG4gICAgICAgIHN0ciA9IHRyaW0oc3RyKTtcbiAgICAgICAgaWYoc3RyLmxlbmd0aCA8PSBtYXhDaGFycyl7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgbWF4Q2hhcnMgLSBhcHBlbmQubGVuZ3RoKTtcbiAgICAgICAgLy9jcm9wIGF0IGxhc3Qgc3BhY2Ugb3IgcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgc3RyID0gb25seUZ1bGxXb3Jkcz8gc3RyLnN1YnN0cigwLCBzdHIubGFzdEluZGV4T2YoJyAnKSkgOiB0cmltKHN0cik7XG4gICAgICAgIHJldHVybiBzdHIgKyBhcHBlbmQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdHJ1bmNhdGU7XG5cbiIsIlxuXG4gICAgdmFyIFVOREVGO1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHN0cmluZyBhbmQgY29udmVydCBpdCBpbnRvIGEgbmF0aXZlIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHR5cGVjYXN0KHZhbCkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgaWYgKCB2YWwgPT09IG51bGwgfHwgdmFsID09PSAnbnVsbCcgKSB7XG4gICAgICAgICAgICByID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICggdmFsID09PSAndHJ1ZScgKSB7XG4gICAgICAgICAgICByID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICggdmFsID09PSAnZmFsc2UnICkge1xuICAgICAgICAgICAgciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCB2YWwgPT09IFVOREVGIHx8IHZhbCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICByID0gVU5ERUY7XG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbCA9PT0gJycgfHwgaXNOYU4odmFsKSApIHtcbiAgICAgICAgICAgIC8vaXNOYU4oJycpIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgIHIgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3BhcnNlRmxvYXQobnVsbCB8fCAnJykgcmV0dXJucyBOYU5cbiAgICAgICAgICAgIHIgPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlY2FzdDtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuXG4gICAgdmFyIENBTUVMX0NBU0VfQk9SREVSID0gLyhbYS16XFx4RTAtXFx4RkZdKShbQS1aXFx4QzBcXHhERl0pL2c7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgc3BhY2UgYmV0d2VlbiBjYW1lbENhc2UgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bkNhbWVsQ2FzZShzdHIsIGRlbGltaXRlcil7XG4gICAgICAgIGlmIChkZWxpbWl0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsaW1pdGVyID0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gam9pbihzdHIsIGMxLCBjMikge1xuICAgICAgICAgICAgcmV0dXJuIGMxICsgZGVsaW1pdGVyICsgYzI7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShDQU1FTF9DQVNFX0JPUkRFUiwgam9pbik7XG4gICAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpOyAvL2FkZCBzcGFjZSBiZXR3ZWVuIGNhbWVsQ2FzZSB0ZXh0XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5DYW1lbENhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBzbHVnaWZ5ID0gcmVxdWlyZSgnLi9zbHVnaWZ5Jyk7XG52YXIgdW5DYW1lbENhc2UgPSByZXF1aXJlKCcuL3VuQ2FtZWxDYXNlJyk7XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgc3BhY2VzIHdpdGggdW5kZXJzY29yZXMsIHNwbGl0IGNhbWVsQ2FzZSB0ZXh0LCByZW1vdmUgbm9uLXdvcmQgY2hhcnMsIHJlbW92ZSBhY2NlbnRzIGFuZCBjb252ZXJ0IHRvIGxvd2VyIGNhc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5kZXJzY29yZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBzdHIgPSB1bkNhbWVsQ2FzZShzdHIpO1xuICAgICAgICByZXR1cm4gc2x1Z2lmeShzdHIsIFwiX1wiKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1bmRlcnNjb3JlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBVbmVzY2FwZXMgSFRNTCBzcGVjaWFsIGNoYXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mYW1wOy9nICwgJyYnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyZsdDsvZyAgLCAnPCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvJmd0Oy9nICAsICc+JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mIzAqMzk7L2cgLCBcIidcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJyk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1bmVzY2FwZUh0bWw7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgdW5pY29kZSBjaGFyIHNlcXVlbmNlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlVW5pY29kZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFx1WzAtOWEtZl17NH0vZywgZnVuY3Rpb24oY2gpe1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChjaC5zbGljZSgyKSwgMTYpO1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5lc2NhcGVVbmljb2RlO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBoeXBoZW5zIHdpdGggc3BhY2VzLiAob25seSBoeXBoZW5zIGJldHdlZW4gd29yZCBjaGFycylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmh5cGhlbmF0ZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhcXHcpKC0pKFxcdykvZywgJyQxICQzJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5oeXBoZW5hdGU7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBcIlNhZmVyXCIgU3RyaW5nLnRvVXBwZXJDYXNlKClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cHBlckNhc2Uoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVwcGVyQ2FzZTtcblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdjb252ZXJ0JyA6IHJlcXVpcmUoJy4vdGltZS9jb252ZXJ0JyksXG4gICAgJ25vdycgOiByZXF1aXJlKCcuL3RpbWUvbm93JyksXG4gICAgJ3BhcnNlTXMnIDogcmVxdWlyZSgnLi90aW1lL3BhcnNlTXMnKSxcbiAgICAndG9UaW1lU3RyaW5nJyA6IHJlcXVpcmUoJy4vdGltZS90b1RpbWVTdHJpbmcnKVxufTtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgdGltZSBpbnRvIGFub3RoZXIgdW5pdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQodmFsLCBzb3VyY2VVbml0TmFtZSwgZGVzdGluYXRpb25Vbml0TmFtZSl7XG4gICAgICAgIGRlc3RpbmF0aW9uVW5pdE5hbWUgPSBkZXN0aW5hdGlvblVuaXROYW1lIHx8ICdtcyc7XG4gICAgICAgIHJldHVybiAodmFsICogZ2V0VW5pdChzb3VyY2VVbml0TmFtZSkpIC8gZ2V0VW5pdChkZXN0aW5hdGlvblVuaXROYW1lKTtcbiAgICB9XG5cblxuICAgIC8vVE9ETzogbWF5YmUgZXh0cmFjdCB0byBhIHNlcGFyYXRlIG1vZHVsZVxuICAgIGZ1bmN0aW9uIGdldFVuaXQodW5pdE5hbWUpe1xuICAgICAgICBzd2l0Y2godW5pdE5hbWUpe1xuICAgICAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgICByZXR1cm4gMTAwMDtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgcmV0dXJuIDYwMDAwO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICAgcmV0dXJuIDM2MDAwMDA7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgIHJldHVybiA4NjQwMDAwMDtcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgIHJldHVybiA2MDQ4MDAwMDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCInKyB1bml0TmFtZSArICdcIiBpcyBub3QgYSB2YWxpZCB1bml0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29udmVydDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IHRpbWUgaW4gbWlsaXNlY29uZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3coKXtcbiAgICAgICAgLy8geWVzLCB3ZSBkZWZlciB0aGUgd29yayB0byBhbm90aGVyIGZ1bmN0aW9uIHRvIGFsbG93IG1vY2tpbmcgaXRcbiAgICAgICAgLy8gZHVyaW5nIHRoZSB0ZXN0c1xuICAgICAgICByZXR1cm4gbm93LmdldCgpO1xuICAgIH1cblxuICAgIG5vdy5nZXQgPSAodHlwZW9mIERhdGUubm93ID09PSAnZnVuY3Rpb24nKT8gRGF0ZS5ub3cgOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBub3c7XG5cblxuIiwidmFyIGNvdW50U3RlcHMgPSByZXF1aXJlKCcuLi9tYXRoL2NvdW50U3RlcHMnKTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRpbWVzdGFtcCBpbnRvIGFuIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZU1zKG1zKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA6IGNvdW50U3RlcHMobXMsIDEsIDEwMDApLFxuICAgICAgICAgICAgc2Vjb25kcyAgICAgIDogY291bnRTdGVwcyhtcywgMTAwMCwgNjApLFxuICAgICAgICAgICAgbWludXRlcyAgICAgIDogY291bnRTdGVwcyhtcywgNjAwMDAsIDYwKSxcbiAgICAgICAgICAgIGhvdXJzICAgICAgICA6IGNvdW50U3RlcHMobXMsIDM2MDAwMDAsIDI0KSxcbiAgICAgICAgICAgIGRheXMgICAgICAgICA6IGNvdW50U3RlcHMobXMsIDg2NDAwMDAwKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGFyc2VNcztcblxuIiwidmFyIGNvdW50U3RlcHMgPSByZXF1aXJlKCcuLi9tYXRoL2NvdW50U3RlcHMnKTtcbnZhciBwYWQgPSByZXF1aXJlKCcuLi9udW1iZXIvcGFkJyk7XG5cbiAgICB2YXIgSE9VUiA9IDM2MDAwMDAsXG4gICAgICAgIE1JTlVURSA9IDYwMDAwLFxuICAgICAgICBTRUNPTkQgPSAxMDAwO1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRpbWVzdGFtcCBpbnRvIGEgdGltZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9UaW1lU3RyaW5nKG1zKXtcbiAgICAgICAgdmFyIGggPSBtcyA8IEhPVVIgICA/IDAgOiBjb3VudFN0ZXBzKG1zLCBIT1VSKSxcbiAgICAgICAgICAgIG0gPSBtcyA8IE1JTlVURSA/IDAgOiBjb3VudFN0ZXBzKG1zLCBNSU5VVEUsIDYwKSxcbiAgICAgICAgICAgIHMgPSBtcyA8IFNFQ09ORCA/IDAgOiBjb3VudFN0ZXBzKG1zLCBTRUNPTkQsIDYwKSxcbiAgICAgICAgICAgIHN0ciA9ICcnO1xuXG4gICAgICAgIHN0ciArPSBoPyBoICsgJzonIDogJyc7XG4gICAgICAgIHN0ciArPSBwYWQobSwgMikgKyAnOic7XG4gICAgICAgIHN0ciArPSBwYWQocywgMik7XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b1RpbWVTdHJpbmc7XG5cbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIl1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkXVxuICAnKFtcXFxcLy5dKT8oPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpKFsrKj9dKT8nLFxuICAvLyBNYXRjaCByZWdleHAgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIGFsd2F5cyBlc2NhcGVkLlxuICAnKFsuKyo/PV4hOiR7fSgpW1xcXFxdfFxcXFwvXSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBncm91cFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpO1xufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7UmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSc7XG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICAgICAgaSxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogIGZhbHNlLFxuICAgICAgICByZXBlYXQ6ICAgIGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cyk7XG59XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgc3BlY2lmaWMgdGFncyB3aXRoIHJlZ2V4cCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VQYXRoIChwYXRoLCBrZXlzKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSAoXywgZXNjYXBlZCwgcHJlZml4LCBrZXksIGNhcHR1cmUsIGdyb3VwLCBzdWZmaXgsIGVzY2FwZSkge1xuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG5cbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlO1xuICAgIH1cblxuICAgIHZhciByZXBlYXQgICA9IHN1ZmZpeCA9PT0gJysnIHx8IHN1ZmZpeCA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IHN1ZmZpeCA9PT0gJz8nIHx8IHN1ZmZpeCA9PT0gJyonO1xuXG4gICAga2V5cy5wdXNoKHtcbiAgICAgIG5hbWU6ICAgICAga2V5IHx8IGluZGV4KyssXG4gICAgICBkZWxpbWl0ZXI6IHByZWZpeCB8fCAnLycsXG4gICAgICBvcHRpb25hbDogIG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiAgICByZXBlYXRcbiAgICB9KTtcblxuICAgIHByZWZpeCA9IHByZWZpeCA/ICgnXFxcXCcgKyBwcmVmaXgpIDogJyc7XG4gICAgY2FwdHVyZSA9IGVzY2FwZUdyb3VwKGNhcHR1cmUgfHwgZ3JvdXAgfHwgJ1teJyArIChwcmVmaXggfHwgJ1xcXFwvJykgKyAnXSs/Jyk7XG5cbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICBjYXB0dXJlID0gY2FwdHVyZSArICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgcGFyYW1ldGVyIHN1cHBvcnQuXG4gICAgcmV0dXJuIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gIH1cblxuICByZXR1cm4gcGF0aC5yZXBsYWNlKFBBVEhfUkVHRVhQLCByZXBsYWNlKTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhTdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgICAgICAgICBba2V5c11cbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgICAgW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBrZXlzID0ga2V5cyB8fCBbXTtcblxuICBpZiAoIWlzQXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0ga2V5cztcbiAgICBrZXlzID0gW107XG4gIH0gZWxzZSBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9IHJlcGxhY2VQYXRoKHBhdGgsIGtleXMpO1xuICB2YXIgZW5kc1dpdGhTbGFzaCA9IHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJztcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhTbGFzaCA/IHJvdXRlLnNsaWNlKDAsIC0yKSA6IHJvdXRlKSArICcoPzpcXFxcLyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoU2xhc2ggPyAnJyA6ICcoPz1cXFxcL3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiZGF0ID0gcmVxdWlyZSBcImRhdC1ndWlcIlxucGFnZSA9IHJlcXVpcmUgXCJwYWdlXCJcblxuXG5ndWkgPSB3aW5kb3cuX2d1aSA9IG5ldyBkYXQuR1VJKClcblxub3B0aW9ucyA9XG5cdFwiZGVidWdcIjogZmFsc2Vcblx0XCJpbmRleFwiOiAtPiBwYWdlIFwiL1wiXG5cdFwiZGF5XCI6IC0+IHBhZ2UgXCIvZGF5XCJcblx0XCJkaWdlc3RcIjogLT4gcGFnZSBcIi9kaWdlc3RcIlxuXHRcIm5pZ2h0XCI6IC0+IHBhZ2UgXCIvbmlnaHRcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IC0+XG5cdCMgZGVidWdcblx0ZGVidWcgPSBndWkuYWRkKG9wdGlvbnMsIFwiZGVidWdcIilcblxuXHQjIG5hdmlnYXRpb25cblx0Zm9sZGVyID0gZ3VpLmFkZEZvbGRlcihcIm5hdmlnYXRpb25cIilcblx0Zm9sZGVyLmFkZChvcHRpb25zLCBcImluZGV4XCIpLm5hbWUoXCIvaW5kZXhcIilcblx0Zm9sZGVyLmFkZChvcHRpb25zLCBcImRheVwiKS5uYW1lKFwiL2RheVwiKVxuXHRmb2xkZXIuYWRkKG9wdGlvbnMsIFwiZGlnZXN0XCIpLm5hbWUoXCIvZGlnZXN0XCIpXG5cdGZvbGRlci5hZGQob3B0aW9ucywgXCJuaWdodFwiKS5uYW1lKFwiL25pZ2h0XCIpXG5cdGZvbGRlci5vcGVuKClcbiIsIm1vZHVsZS5leHBvcnRzID1cblxuICAgIGZpcmViYXNlOiBcImFsaWNlbHVrZVwiXG4iLCJSYWN0aXZlID0gcmVxdWlyZSBcInJhY3RpdmVcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gUmFjdGl2ZS5leHRlbmRcblxuXHRpc29sYXRlZDogdHJ1ZVxuIiwiIyMjXG5cdEBtb2R1bGU6ICAgYWJzdHJhY3Qtc2NlbmVcblx0QGF1dGhvcjogICBsdWtlaGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9hYnN0cmFjdC1zY2VuZS5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL2Fic3RyYWN0LXNjZW5lLmh0bWxcbiMjI1xuXG5cbk1vZHVsZSA9IHJlcXVpcmUgXCIuL2Fic3RyYWN0LW1vZHVsZVwiXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlLmV4dGVuZFxuXG5cdHRlbXBsYXRlOiByZXF1aXJlIFwibW9kdWxlL2Fic3RyYWN0LXNjZW5lLmh0bWxcIlxuXG5cdG9uaW5pdDogLT5cblx0XHRcbiIsIiMjI1xuXHRUSElTIEZJTEUgSVMgR0VORVJBVEVEIEFVVE9NQVRJQ0FMTFkgQU5EIElUIFdJTExcblx0QkUgUkVQTEFDRUQgSUYgQSBORVcgTU9EVUxFIElTIEFEREVEIE9SIERFTEVURUQuXG4jIyNcblJhY3RpdmUgPSByZXF1aXJlIFwicmFjdGl2ZVwiXG5cbnJlZ2lzdGVyID0gLT5cblx0UmFjdGl2ZS5jb21wb25lbnRzW1widWktYWJzdHJhY3Qtc2NlbmVcIl0gPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1zY2VuZVwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLW5hdlwiXSA9IHJlcXVpcmUgXCIuL25hdlwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLXNjZW5lLWRheVwiXSA9IHJlcXVpcmUgXCIuL3NjZW5lLWRheVwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLXNjZW5lLWRpZ2VzdFwiXSA9IHJlcXVpcmUgXCIuL3NjZW5lLWRpZ2VzdFwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLXNjZW5lLW5pZ2h0XCJdID0gcmVxdWlyZSBcIi4vc2NlbmUtbmlnaHRcIlxuXHRSYWN0aXZlLmNvbXBvbmVudHNbXCJ1aS1zdGFnZVwiXSA9IHJlcXVpcmUgXCIuL3N0YWdlXCJcblx0XG5cdHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcigpIiwiIyMjXG5cdEBtb2R1bGU6ICAgbmF2XG5cdEBhdXRob3I6ICAgTHVrZSBIZWRnZXIgPGx1a2UuaGVkZ2VyQGdtYWlsLmNvbT5cblx0QGNzczogICAgICAuL3NvdXJjZS9jc3MvbW9kdWxlL25hdi5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL25hdi5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1tb2R1bGVcIlxuXG5wYWdlID0gcmVxdWlyZSBcInBhZ2VcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9uYXYuaHRtbFwiXG5cblx0b25pbml0OiAtPlxuXG5cdFx0QG9uIFwidG9JbmRleFwiLCAtPiBwYWdlIFwiL1wiXG5cdFx0QG9uIFwidG9UZXN0XCIsIC0+IHBhZ2UgXCIvdGVzdFwiXG4iLCIjIyNcblx0QG1vZHVsZTogICBzY2VuZS1kYXlcblx0QGF1dGhvcjogICBsdWtlaGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9zY2VuZS1kYXkuc3R5bFxuXHRAaHRtbDogICAgIC4vc291cmNlL3RlbXBsYXRlL21vZHVsZS9zY2VuZS1kYXkuaHRtbFxuIyMjXG5cblxuTW9kdWxlID0gcmVxdWlyZSBcIi4vYWJzdHJhY3Qtc2NlbmVcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlLmV4dGVuZFxuXG5cdHRlbXBsYXRlOiByZXF1aXJlIFwibW9kdWxlL3NjZW5lLWRheS5odG1sXCJcblxuXHRvbmluaXQ6IC0+IEBfc3VwZXIoKVxuXG5cdG9ucmVuZGVyOiAtPlxuXHRcdHBhdGggPSBAZmluZChcInBhdGhcIilcblx0XHRsZW5ndGggPSBwYXRoLmdldFRvdGFsTGVuZ3RoKClcblx0XHRUd2Vlbk1heC50byhwYXRoLCAyLCB7IGRlbGF5OiAxLCAnc3Ryb2tlLWRhc2hvZmZzZXQnOiBsZW5ndGgsIGVhc2U6Qm91bmNlLmVhc2VPdXQgfSlcbiIsIiMjI1xuXHRAbW9kdWxlOiAgIHNjZW5lLWRpZ2VzdFxuXHRAYXV0aG9yOiAgIGx1a2VoZWRnZXIgPGx1a2UuaGVkZ2VyQGdtYWlsLmNvbT5cblx0QGNzczogICAgICAuL3NvdXJjZS9jc3MvbW9kdWxlL3NjZW5lLWRpZ2VzdC5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLWRpZ2VzdC5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1zY2VuZVwiXG5rZXlzID0gcmVxdWlyZShcIm1vdXRcIikub2JqZWN0LmtleXNcbmxhc3QgPSByZXF1aXJlKFwibW91dFwiKS5hcnJheS5sYXN0XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlLmV4dGVuZFxuXG5cdHRlbXBsYXRlOiByZXF1aXJlIFwibW9kdWxlL3NjZW5lLWRpZ2VzdC5odG1sXCJcblxuXHRkYXRhOlxuXHRcdGN1cnJlbnQ6IDBcblx0XHR4OiBbXCIxMDAlXCIsIFwiLTIwMCVcIl1cblx0XHRzbGlkZXM6XG5cdFx0XHQxOlxuXHRcdFx0XHR0aXRsZTogXCJzbGlkZSAxXCJcblx0XHRcdFx0Ym9keTogXCJ0aGlzIGlzIHNsaWRlIDFcIlxuXHRcdFx0XHRsaW5rczogW1wiYVwiLFwiYlwiXVxuXHRcdFx0XHRhY3RpdmU6IGZhbHNlXG5cdFx0XHQyOlxuXHRcdFx0XHR0aXRsZTogXCJzbGlkZSAyXCJcblx0XHRcdFx0Ym9keTogXCJ0aGlzIGlzIHNsaWRlIDJcIlxuXHRcdFx0XHRhY3RpdmU6IGZhbHNlXG5cdFx0XHQzOlxuXHRcdFx0XHR0aXRsZTogXCJzbGlkZSAzXCJcblx0XHRcdFx0Ym9keTogXCJ0aGlzIGlzIHNsaWRlIDNcIlxuXHRcdFx0XHRhY3RpdmU6IGZhbHNlXG5cblx0b25pbml0OiAtPiBAX3N1cGVyKClcblxuXHRvbnRlYXJkb3duOiAtPlxuXHRcdEBwcmV2U2xpZGUoKVxuXHRcdCMgVE9ETyAtIHRoZXJlIGlzIGEgbWlub3IgaXNzdWUgd2hlbiBtb3ZpbmcgZnJvbSBkaWdlc3QtPmRheSB3aGVyZSBkaWdlc3QgaXMgbm90IHZpc2libGUgKGJlaGluZCBkYXkpIHNvIGNhbm5vdCBzZWUgb3V0cm8gdHJhbnNpdGlvblxuXHRcdEBzZXQgXCJzbGlkZXMuKi5hY3RpdmVcIiwgZmFsc2VcblxuXHRvbnJlbmRlcjogLT5cblx0XHRAb24gXCJnb05leHRTbGlkZVwiLCAtPiBAbmV4dFNsaWRlKClcblx0XHRAb24gXCJnb1ByZXZTbGlkZVwiLCAtPiBAcHJldlNsaWRlKClcblxuXHRcdEBuZXh0U2xpZGUoKVxuXG5cdG5leHRTbGlkZTogLT5cblx0XHRjdXJyZW50ID0gQGdldChcImN1cnJlbnRcIilcblx0XHRuZXh0ID0gaWYgY3VycmVudCBpcyBrZXlzKEBnZXQoXCJzbGlkZXNcIikpLmxlbmd0aCB0aGVuIDEgZWxzZSBjdXJyZW50Kz0xXG5cdFx0QHNldCBcInNsaWRlcy4je0BnZXQoXCJjdXJyZW50XCIpfS54XCIsIEBnZXQoXCJ4WzFdXCIpIGlmIEBnZXQoXCJjdXJyZW50XCIpIGlzbnQgMFxuXHRcdEBzZXQgXCJzbGlkZXMuI3tuZXh0fS54XCIsIEBnZXQoXCJ4WzBdXCIpXG5cdFx0QHNldFNsaWRlIG5leHRcblxuXHRwcmV2U2xpZGU6IC0+XG5cdFx0Y3VycmVudCA9IEBnZXQoXCJjdXJyZW50XCIpXG5cdFx0cHJldiA9IGlmIGN1cnJlbnQgaXMgMSB0aGVuIGtleXMoQGdldChcInNsaWRlc1wiKSkubGVuZ3RoIGVsc2UgY3VycmVudC09MVxuXHRcdEBzZXQgXCJzbGlkZXMuI3tAZ2V0KFwiY3VycmVudFwiKX0ueFwiLCBAZ2V0KFwieFswXVwiKSBpZiBAZ2V0KFwiY3VycmVudFwiKSBpc250IDBcblx0XHRAc2V0IFwic2xpZGVzLiN7cHJldn0ueFwiLCBAZ2V0KFwieFsxXVwiKVxuXHRcdEBzZXRTbGlkZSBwcmV2XG5cblx0c2V0U2xpZGU6IChzbGlkZSkgLT5cblx0XHRAc2V0IFwic2xpZGVzLiN7QGdldChcImN1cnJlbnRcIil9LmFjdGl2ZVwiLCBmYWxzZSBpZiBAZ2V0KFwiY3VycmVudFwiKSBpc250IDBcblx0XHRAc2V0IFwic2xpZGVzLiN7c2xpZGV9LmFjdGl2ZVwiLCB0cnVlXG5cdFx0QHNldCBjdXJyZW50OiBzbGlkZVxuIiwiIyMjXG5cdEBtb2R1bGU6ICAgc2NlbmUtbmlnaHRcblx0QGF1dGhvcjogICBsdWtlaGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9zY2VuZS1uaWdodC5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLW5pZ2h0Lmh0bWxcbiMjI1xuXG5cbk1vZHVsZSA9IHJlcXVpcmUgXCIuL2Fic3RyYWN0LXNjZW5lXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9zY2VuZS1uaWdodC5odG1sXCJcblxuXHRvbmluaXQ6IC0+IEBfc3VwZXIoKVxuXG5cdG9ucmVuZGVyOiAtPlxuIiwiIyMjXG5cdEBtb2R1bGU6ICAgc3RhZ2Vcblx0QGF1dGhvcjogICBsdWtlaGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9zdGFnZS5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3N0YWdlLmh0bWxcbiMjI1xuXG5cbk1vZHVsZSA9IHJlcXVpcmUgXCIuL2Fic3RyYWN0LW1vZHVsZVwiXG5wYWdlID0gcmVxdWlyZSBcInBhZ2VcIlxuXG5rZXlzID0gcmVxdWlyZShcIm1vdXRcIikub2JqZWN0LmtleXNcbmZvckluID0gcmVxdWlyZShcIm1vdXRcIikub2JqZWN0LmZvckluXG5BZGRDbGFzcyA9IHJlcXVpcmUgXCIuLi91dGlsL2FkZENsYXNzXCJcblxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGUuZXh0ZW5kXG5cblx0dGVtcGxhdGU6IHJlcXVpcmUgXCJtb2R1bGUvc3RhZ2UuaHRtbFwiXG5cblx0cGFydGlhbHM6XG5cdFx0c3RhZ2VDb250cm9sczogcmVxdWlyZSBcInBhcnRpYWxzL3N0YWdlLWNvbnRyb2xzLmh0bWxcIlxuXHRcdGZhcm06IHJlcXVpcmUgXCJwYXJ0aWFscy9mYXJtLmh0bWxcIlxuXG5cdGRhdGE6XG5cdFx0Y3VycmVudDogMFxuXHRcdHNjZW5lczpcblx0XHRcdDE6IFwiZGF5XCJcblx0XHRcdDI6IFwiZGlnZXN0XCJcblx0XHRcdDM6IFwibmlnaHRcIlxuXG5cdG9uaW5pdDogLT5cblxuXHRcdHdpbmRvdy5vbmtleWRvd24gPSAoZSkgPT5cblx0XHRcdEBwcmV2U2NlbmUoKSBpZiBlLmtleUNvZGUgaXMgMzhcblx0XHRcdEBuZXh0U2NlbmUoKSBpZiBlLmtleUNvZGUgaXMgNDBcblxuXHRcdEBvbiBcImdvTmV4dFNjZW5lXCIsIC0+IEBuZXh0U2NlbmUoKVxuXHRcdEBvbiBcImdvUHJldlNjZW5lXCIsIC0+IEBwcmV2U2NlbmUoKVxuXG5cdFx0QG9ic2VydmUgXCJ2aWV3XCIsIChuZXdWYWx1ZSkgPT5cblx0XHRcdGlmIG5ld1ZhbHVlXG5cdFx0XHRcdGZvckluKEBnZXQoXCJzY2VuZXNcIiksICh2LCBrKSA9PiByZXR1cm4gQHNldCBjdXJyZW50OiBwYXJzZUludChrLDEwKSBpZiB2IGlzIG5ld1ZhbHVlKVxuXG5cdG9ucmVuZGVyOiAtPlxuXG5cdFx0IyBzdW5cblx0XHRsaW5lID0gQGZpbmQoXCJsaW5lXCIpXG5cdFx0IyBUT0RPIC0gdGhpcyBkb250IHdvcmshXG5cdFx0IyBjb25zb2xlLmxvZyBsaW5lLmdldFRvdGFsTGVuZ3RoKClcblx0XHQjIGxlbmd0aCA9IGxpbmUuZ2V0VG90YWxMZW5ndGgoKVxuXHRcdCMgVHdlZW5NYXgudG8obGluZSwgMiwgeyBkZWxheTogMSwgJ3N0cm9rZS1kYXNob2Zmc2V0JzogbGVuZ3RoLCBlYXNlOkJvdW5jZS5lYXNlT3V0IH0pXG5cblx0XHQjIFRPRE8gLSBmbGFncyB0ZXN0XG5cdFx0Y2FibGUgPSBAZmluZChcIi5jYWJsZS0tbGVmdFwiKVxuXHRcdGxlZnQgPSBAZmluZChcIi5jYWJsZS0tbGVmdCBzdmcgcGF0aFwiKVxuXHRcdCMgbGVuID0gbGVmdC5nZXRUb3RhbExlbmd0aCgpXG5cdFx0IyBwb2ludCA9IGxlZnQuZ2V0UG9pbnRBdExlbmd0aChsZW4pXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBcImRpdlwiXG5cdFx0QWRkQ2xhc3MgZGl2LCBcImZsYWdcIlxuXHRcdCMgZGl2LnN0eWxlLnRvcCA9IFwiI3twb2ludC55fXB4XCJcblx0XHQjIGRpdi5zdHlsZS5sZWZ0ID0gXCIje3BvaW50Lnh9cHhcIlxuXHRcdGNhYmxlLmFwcGVuZENoaWxkIGRpdlxuXHRcdCMgVE9ETyAtIGRvbnQgdXNlIHN2Zy5wYXRoIHRvIHBsb3QgZmxhZ3MgLSBpbnN0ZWFkIGdldCBwYXRoLndpZHRoIC8gZmxhZy53aWR0aCA9IGhvdyBtYW55IGZsYWdzIHRvIGFkZFxuXHRcdCMgYWRkIGZsYWdzIHNpZGUgYnkgc2lkZSwgd2hhdCBhYm91dCByb3RhdGlvbj9cblxuXHRuZXh0U2NlbmU6IC0+XG5cdFx0Y3VycmVudCA9IEBnZXQoXCJjdXJyZW50XCIpXG5cdFx0bmV4dCA9IGlmIGN1cnJlbnQgaXMga2V5cyhAZ2V0KFwic2NlbmVzXCIpKS5sZW5ndGggdGhlbiAxIGVsc2UgY3VycmVudCs9MVxuXHRcdEBzZXRTY2VuZSBuZXh0XG5cblx0cHJldlNjZW5lOiAtPlxuXHRcdGN1cnJlbnQgPSBAZ2V0KFwiY3VycmVudFwiKVxuXHRcdHByZXYgPSBpZiBjdXJyZW50IGlzIDEgdGhlbiBrZXlzKEBnZXQoXCJzY2VuZXNcIikpLmxlbmd0aCBlbHNlIGN1cnJlbnQtPTFcblx0XHRAc2V0U2NlbmUgcHJldlxuXG5cdHNldFNjZW5lOiAoc2NlbmUpIC0+XG5cdFx0cGFnZSBcIi8je0BnZXQoXCJzY2VuZXMuI3tzY2VuZX1cIil9XCJcbiIsIm1vZHVsZS5leHBvcnRzID0gKGVsLCBjbGFzc05hbWUpIC0+XG5cdGlmIGVsP1xuXHRcdGlmIGVsLmNsYXNzTGlzdD9cblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuXHRcdGVsc2Vcblx0XHRcdGVsLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWVcbiIsIlJhY3RpdmUgPSByZXF1aXJlIFwicmFjdGl2ZVwiXG5GaXJlYmFzZSA9IHJlcXVpcmUgXCJmaXJlYmFzZVwiXG5wYWdlID0gcmVxdWlyZSBcInBhZ2VcIlxuXG5jb25maWcgPSByZXF1aXJlIFwiLi4vY29uZmlnXCJcblxubW9kdWxlLmV4cG9ydHMgPSBSYWN0aXZlLmV4dGVuZFxuXG5cdGVsOiBkb2N1bWVudC5ib2R5XG5cblx0YXBwZW5kOiB0cnVlXG5cblx0dGVtcGxhdGU6IHJlcXVpcmUgXCJtYWluLXZpZXcuaHRtbFwiXG5cblx0ZGF0YTpcblx0XHR2aWV3OiBudWxsXG5cdFx0Y29kZTogbnVsbFxuXHRcdGd1ZXN0OiBudWxsXG5cblx0b25pbml0OiAoKSAtPlxuXHRcdEBnZXREYXRhKClcblxuXHRcdEBzZXRfcm91dGVyKClcblxuXHRnZXREYXRhOiAtPlxuXHRcdCMgVE9ETyAtIGxvYWQgZGF0YS9ndWVzdHMgdG8gZmlyZWJhc2UgdGhlbiBnZXQgZGIuY2hpbGQoXCJndWVzdHNcIikub24oXCJ2YWx1ZVwiLCAuLi4pXG5cdFx0ZGIgPSBuZXcgRmlyZWJhc2UgXCJodHRwczovLyN7Y29uZmlnLmZpcmViYXNlfS5maXJlYmFzZWlvLmNvbS9cIlxuXHRcdGRiLm9uIFwidmFsdWVcIiwgKHNuYXBzaG90KSA9PlxuXHRcdFx0IyBUT0RPIC0gY2hlY2sgZ3Vlc3QgY29kZSBhZ2FpbnN0IGd1ZXN0c1xuXHRcdFx0Y29uc29sZS5sb2cgXCJvazpcIiwgc25hcHNob3QudmFsKClcblx0XHQsIChlcnIpIC0+XG5cdFx0ICAgIGNvbnNvbGUubG9nIFwiZXJyOlwiLCBlcnIuY29kZVxuXG5cdHNldF9yb3V0ZXI6IC0+XG5cdFx0c2VsZiA9IEBcblxuXHRcdHBhZ2UgXCIvXCIsIC0+XG5cdFx0XHRzZWxmLnNldCBcInZpZXdcIjogXCJkYXlcIlxuXG5cdFx0cGFnZSBcIi86c2NlbmVcIiwgKGN0eCkgLT5cblx0XHRcdHNlbGYuc2V0IFwidmlld1wiOiBjdHgucGFyYW1zLnNjZW5lXG5cblx0XHRwYWdlIGNsaWNrOiBmYWxzZSwgZGlzcGF0Y2g6IHRydWUsIGhhc2hiYW5nOiBmYWxzZVxuIiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIndyYXBwZXJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbXCJza3kgXCIse1widFwiOjIsXCJyXCI6XCJ2aWV3XCJ9XX19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwidWktc3RhZ2VcIixcImFcIjp7XCJ2aWV3XCI6W3tcInRcIjoyLFwiclwiOlwidmlld1wifV19fV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiYWJzdHJhY3Qtc2NlbmVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaDFcIixcImZcIjpbXCJhYnN0cmFjdC1zY2VuZSA6KVwiXX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcIm5hdlwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhXCIsXCJ2XCI6e1widGFwXCI6XCJ0b0luZGV4XCJ9LFwiZlwiOltcIkhvbWVcIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiYVwiLFwidlwiOntcInRhcFwiOlwidG9UZXN0XCJ9LFwiZlwiOltcIlRlc3RcIl19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzY2VuZSBzY2VuZS1kYXlcIn0sXCJ0MVwiOlwiZmFkZVwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInN2Z1wiLFwiYVwiOntcIndpZHRoXCI6XCIyMDBweFwiLFwiaGVpZ2h0XCI6XCIyMDBweFwiLFwidmVyc2lvblwiOlwiMS4xXCIsXCJ4bWxuc1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicGF0aFwiLFwiYVwiOntcImRcIjpcIk0xMCAxMCBDIDIwIDIwLCA0MCAyMCwgNTAgMTBcIixcInN0cm9rZVwiOlwiYmxhY2tcIixcImZpbGxcIjpcInRyYW5zcGFyZW50XCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImdyZWV0aW5nXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImgyXCIsXCJmXCI6W1wiSG93ZHkhIFlvdSdyZSBpbnZpdGVkIHRvIFdvb2RzdG9jayAyMDE1XCJdfV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzY2VuZSBzY2VuZS1kaWdlc3RcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNob3d0aW1lXCJ9LFwidlwiOntcInN3aXBlcmlnaHRcIjpcImdvUHJldlNsaWRlXCIsXCJzd2lwZWxlZnRcIjpcImdvTmV4dFNsaWRlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzaG93dGltZV9fY29udHJvbHNcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImNsYXNzXCI6XCJzaG93dGltZV9fY29udHJvbC0tcHJldlwifSxcInZcIjp7XCJ0YXBcIjpcImdvUHJldlNsaWRlXCJ9LFwiZlwiOltcIuKGkFwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpcInNob3d0aW1lX19jb250cm9sLS1uZXh0XCJ9LFwidlwiOntcInRhcFwiOlwiZ29OZXh0U2xpZGVcIn0sXCJmXCI6W1wi4oaSXCJdfV19LFwiIFwiLHtcInRcIjo0LFwiclwiOlwic2xpZGVzXCIsXCJpXCI6XCJzbGlkZVwiLFwiZlwiOlt7XCJ0XCI6NCxcInJcIjpcImFjdGl2ZVwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W1wic2xpZGUtLVwiLHtcInRcIjoyLFwiclwiOlwic2xpZGVcIn1dfSxcInQwXCI6e1wiblwiOlwiZmx5XCIsXCJkXCI6W1wieyB4OidcIix7XCJ0XCI6MixcInJcIjpcInhcIn0sXCInLCB5OicwJScsIG9wYWNpdHk6MSB9XCJdfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJoMVwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcInRpdGxlXCJ9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiYm9keVwifV19LFwiIFwiLHtcInRcIjo0LFwiclwiOlwibGlua3NcIixcImZcIjpbe1widFwiOjIsXCJyXCI6XCIuXCJ9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiZmxvd2VyXCJ9fV19XX1dfV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzY2VuZSBzY2VuZS1uaWdodFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJoMVwiLFwiZlwiOltcInNjZW5lLW5pZ2h0IDopXCJdfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic3RhZ2VcIn0sXCJmXCI6W3tcInRcIjo4LFwiclwiOlwic3RhZ2VDb250cm9sc1wifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzdW5cIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3ZnXCIsXCJhXCI6e1widmVyc2lvblwiOlwiMS4xXCIsXCJpZFwiOlwiTGF5ZXJfMVwiLFwieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ4bWxuczp4bGlua1wiOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwieFwiOlwiMHB4XCIsXCJ5XCI6XCIwcHhcIixcInZpZXdCb3hcIjpcIjAgMCAxMDAgMTAwXCIsXCJlbmFibGUtYmFja2dyb3VuZFwiOlwibmV3IDAgMCAxMDAgMTAwXCIsXCJ4bWw6c3BhY2VcIjpcInByZXNlcnZlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImNpcmNsZVwiLFwiYVwiOntcImN4XCI6XCI1MFwiLFwiY3lcIjpcIjQ5LjlcIixcInJcIjpcIjI1XCIsXCJmaWxsXCI6XCIjRkRCODEzXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjIzXCIsXCJ5MVwiOlwiNDkuNVwiLFwieDJcIjpcIjJcIixcInkyXCI6XCI0OS41XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjk4XCIsXCJ5MVwiOlwiNDkuNVwiLFwieDJcIjpcIjc3XCIsXCJ5MlwiOlwiNDkuNVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI0OS41XCIsXCJ5MVwiOlwiNzdcIixcIngyXCI6XCI0OS41XCIsXCJ5MlwiOlwiOThcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiNDkuNVwiLFwieTFcIjpcIjJcIixcIngyXCI6XCI0OS41XCIsXCJ5MlwiOlwiMjNcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiMzAuNlwiLFwieTFcIjpcIjY4LjdcIixcIngyXCI6XCIxNS43XCIsXCJ5MlwiOlwiODMuNlwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI4My42XCIsXCJ5MVwiOlwiMTUuN1wiLFwieDJcIjpcIjY4LjdcIixcInkyXCI6XCIzMC42XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjY4LjdcIixcInkxXCI6XCI2OS40XCIsXCJ4MlwiOlwiODMuNlwiLFwieTJcIjpcIjg0LjNcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiMTUuN1wiLFwieTFcIjpcIjE2LjRcIixcIngyXCI6XCIzMC42XCIsXCJ5MlwiOlwiMzEuM1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCIyNC45XCIsXCJ5MVwiOlwiNTkuOVwiLFwieDJcIjpcIjUuNVwiLFwieTJcIjpcIjY3LjlcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiOTQuMlwiLFwieTFcIjpcIjMxLjJcIixcIngyXCI6XCI3NC44XCIsXCJ5MlwiOlwiMzkuMlwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI1OS45XCIsXCJ5MVwiOlwiNzUuMVwiLFwieDJcIjpcIjY3LjlcIixcInkyXCI6XCI5NC41XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjMxLjJcIixcInkxXCI6XCI1LjhcIixcIngyXCI6XCIzOS4yXCIsXCJ5MlwiOlwiMjUuMlwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCIzOS4yXCIsXCJ5MVwiOlwiNzQuOFwiLFwieDJcIjpcIjMxLjJcIixcInkyXCI6XCI5NC4yXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjY3LjlcIixcInkxXCI6XCI1LjVcIixcIngyXCI6XCI1OS45XCIsXCJ5MlwiOlwiMjQuOVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI3NC44XCIsXCJ5MVwiOlwiNjAuOFwiLFwieDJcIjpcIjk0LjJcIixcInkyXCI6XCI2OC44XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjUuNVwiLFwieTFcIjpcIjMyLjFcIixcIngyXCI6XCIyNC45XCIsXCJ5MlwiOlwiNDAuMVwifX1dfV19LFwiIFwiLHtcInRcIjo0LFwieFwiOntcInJcIjpbXCJ2aWV3XCJdLFwic1wiOlwiXzA9PVxcXCJkYXlcXFwiXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInVpLXNjZW5lLWRheVwifV19LFwiIFwiLHtcInRcIjo0LFwieFwiOntcInJcIjpbXCJ2aWV3XCJdLFwic1wiOlwiXzA9PVxcXCJkaWdlc3RcXFwiXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInVpLXNjZW5lLWRpZ2VzdFwifV19LFwiIFwiLHtcInRcIjo0LFwieFwiOntcInJcIjpbXCJ2aWV3XCJdLFwic1wiOlwiXzA9PVxcXCJuaWdodFxcXCJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwidWktc2NlbmUtbmlnaHRcIn1dfSxcIiBcIix7XCJ4XCI6e1wiclwiOltcInZpZXdcIl0sXCJzXCI6XCJ7dmlldzpfMH1cIn0sXCJmXCI6W3tcInRcIjo4LFwiclwiOlwiZmFybVwifV0sXCJ0XCI6NCxcIm5cIjo1M31dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbXCJmYXJtLS1cIix7XCJ0XCI6MixcInJcIjpcInZpZXdcIn1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiZmllbGRcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNhbWJlclwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzdmdcIixcImFcIjp7XCJ2ZXJzaW9uXCI6XCIxLjFcIixcImlkXCI6XCJMYXllcl8xXCIsXCJ4bWxuc1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcInhtbG5zOnhsaW5rXCI6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXCJ4XCI6XCIwcHhcIixcInlcIjpcIjBweFwiLFwidmlld0JveFwiOlwiMCAwIDU5My4yIDI4LjhcIixcImVuYWJsZS1iYWNrZ3JvdW5kXCI6XCJuZXcgMCAwIDU5My4yIDI4LjhcIixcInhtbDpzcGFjZVwiOlwicHJlc2VydmVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicGF0aFwiLFwiYVwiOntcImZpbGxcIjpcIiM3QUI0OTBcIixcInN0cm9rZVwiOlwiIzdBQjQ5MFwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJkXCI6XCJNNTkzLjIsMjkuM0gwYzAsMCwwLjUtMywwLTIwYzQzLjQsMjMuMSw1MTguNy0yNC43LDU5My4yLDBcXG4gICAgICAgICAgICBDNTkyLjcsMjIuNiw1OTMuMiwyOS4zLDU5My4yLDI5LjN6XCJ9fV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJidW50aW5nXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJjYWJsZS0tbGVmdFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzdmdcIixcImFcIjp7XCJ2ZXJzaW9uXCI6XCIxLjFcIixcImlkXCI6XCJMYXllcl8xXCIsXCJ4bWxuc1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcInhtbG5zOnhsaW5rXCI6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXCJ4XCI6XCIwcHhcIixcInlcIjpcIjBweFwiLFwidmlld0JveFwiOlwiMCA3IDYwMCAyOVwiLFwiZW5hYmxlLWJhY2tncm91bmRcIjpcIm5ldyAwIDcgNjAwIDI5XCIsXCJ4bWw6c3BhY2VcIjpcInByZXNlcnZlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInBhdGhcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiMwMDAwMDBcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwiZFwiOlwiTTAsN0wwLDdjMjY4LjcsNTEuNiw2MDAsMTIuNSw2MDAsMGwwLDBcIn19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJwb2xlXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJjYWJsZS0tcmlnaHRcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3ZnXCIsXCJhXCI6e1widmVyc2lvblwiOlwiMS4xXCIsXCJpZFwiOlwiTGF5ZXJfMVwiLFwieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ4bWxuczp4bGlua1wiOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwieFwiOlwiMHB4XCIsXCJ5XCI6XCIwcHhcIixcInZpZXdCb3hcIjpcIjAgNyA2MDAgMjlcIixcImVuYWJsZS1iYWNrZ3JvdW5kXCI6XCJuZXcgMCA3IDYwMCAyOVwiLFwieG1sOnNwYWNlXCI6XCJwcmVzZXJ2ZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwYXRoXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjMDAwMDAwXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcImRcIjpcIk0wLDdMMCw3YzI2OC43LDUxLjYsNjAwLDEyLjUsNjAwLDBsMCwwXCJ9fV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJ0cmVlc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZS0tZGFya1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZS0tZGFya1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJ0ZW50c1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVudFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY2FudmFzXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJhd25pbmdcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXBzXCJ9fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVudC0tYmx1ZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY2FudmFzXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJhd25pbmdcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXBzXCJ9fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVudC0tcGlua1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY2FudmFzXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJhd25pbmdcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXBzXCJ9fV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmaXJlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJsb2dzXCJ9fV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImFcIixcImFcIjp7XCJjbGFzc1wiOlwic3RhZ2VfX2NvbnRyb2wtLXByZXZcIn0sXCJ2XCI6e1widGFwXCI6XCJnb1ByZXZTY2VuZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzdmdcIixcImFcIjp7XCJ2ZXJzaW9uXCI6XCIxLjFcIixcImlkXCI6XCJMYXllcl8xXCIsXCJ4bWxuc1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcInhtbG5zOnhsaW5rXCI6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXCJ4XCI6XCIwcHhcIixcInlcIjpcIjBweFwiLFwidmlld0JveFwiOlwiMCAwIDcwIDMyLjFcIixcImVuYWJsZS1iYWNrZ3JvdW5kXCI6XCJuZXcgMCAwIDcwIDMyLjFcIixcInhtbDpzcGFjZVwiOlwicHJlc2VydmVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicGF0aFwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiIzAwMDAwMFwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJkXCI6XCJNMC42LDMxLjZMMzMuOCwxLjJjMC43LTAuNiwxLjctMC42LDIuNCwwbDMzLjEsMzAuNFwifX1dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImNsYXNzXCI6XCJzdGFnZV9fY29udHJvbC0tbmV4dFwifSxcInZcIjp7XCJ0YXBcIjpcImdvTmV4dFNjZW5lXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInN2Z1wiLFwiYVwiOntcInZlcnNpb25cIjpcIjEuMVwiLFwiaWRcIjpcIkxheWVyXzFcIixcInhtbG5zXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwieG1sbnM6eGxpbmtcIjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcInhcIjpcIjBweFwiLFwieVwiOlwiMHB4XCIsXCJ2aWV3Qm94XCI6XCIwIDAgNzAgMzIuMVwiLFwiZW5hYmxlLWJhY2tncm91bmRcIjpcIm5ldyAwIDAgNzAgMzIuMVwiLFwieG1sOnNwYWNlXCI6XCJwcmVzZXJ2ZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwYXRoXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjMDAwMDAwXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcImRcIjpcIk02OS4zLDAuN0wzNi4xLDMxLjJjLTAuNywwLjYtMS43LDAuNi0yLjQsMEwwLjYsMC43XCJ9fV19XX1dfSIsIi8qIVxuICAqIGRvbXJlYWR5IChjKSBEdXN0aW4gRGlheiAyMDE0IC0gTGljZW5zZSBNSVRcbiAgKi9cbiFmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIHRoaXNbbmFtZV0gPSBkZWZpbml0aW9uKClcblxufSgnZG9tcmVhZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZucyA9IFtdLCBsaXN0ZW5lclxuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIGhhY2sgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsXG4gICAgLCBkb21Db250ZW50TG9hZGVkID0gJ0RPTUNvbnRlbnRMb2FkZWQnXG4gICAgLCBsb2FkZWQgPSAoaGFjayA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChkb2MucmVhZHlTdGF0ZSlcblxuXG4gIGlmICghbG9hZGVkKVxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lcilcbiAgICBsb2FkZWQgPSAxXG4gICAgd2hpbGUgKGxpc3RlbmVyID0gZm5zLnNoaWZ0KCkpIGxpc3RlbmVyKClcbiAgfSlcblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgbG9hZGVkID8gZm4oKSA6IGZucy5wdXNoKGZuKVxuICB9XG5cbn0pO1xuIiwiLyohXG4gKiBWRVJTSU9OOiAxLjE2LjFcbiAqIERBVEU6IDIwMTUtMDMtMTNcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKiBcbiAqIEluY2x1ZGVzIGFsbCBvZiB0aGUgZm9sbG93aW5nOiBUd2VlbkxpdGUsIFR3ZWVuTWF4LCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4LCBFYXNlUGFjaywgQ1NTUGx1Z2luLCBSb3VuZFByb3BzUGx1Z2luLCBCZXppZXJQbHVnaW4sIEF0dHJQbHVnaW4sIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW5cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKiovXG52YXIgX2dzU2NvcGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3c7IC8vaGVscHMgZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlXG4oX2dzU2NvcGUuX2dzUXVldWUgfHwgKF9nc1Njb3BlLl9nc1F1ZXVlID0gW10pKS5wdXNoKCBmdW5jdGlvbigpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUd2Vlbk1heFwiLCBbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lLCBUd2VlbkxpdGUpIHtcblxuXHRcdHZhciBfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIFtdLnNsaWNlIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0VHdlZW5NYXggPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5jYWxsKHRoaXMsIHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTsgLy9lbnN1cmVzIHRoYXQgaWYgdGhlcmUgaXMgYW55IHJlcGVhdCwgdGhlIHRvdGFsRHVyYXRpb24gd2lsbCBnZXQgcmVjYWxjdWxhdGVkIHRvIGFjY3VyYXRlbHkgcmVwb3J0IGl0LlxuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTWF4LnByb3RvdHlwZS5yZW5kZXI7IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0cCA9IFR3ZWVuTWF4LnByb3RvdHlwZSA9IFR3ZWVuTGl0ZS50byh7fSwgMC4xLCB7fSksXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdO1xuXG5cdFx0VHdlZW5NYXgudmVyc2lvbiA9IFwiMS4xNi4xXCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTWF4O1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdFR3ZWVuTWF4LmtpbGxUd2VlbnNPZiA9IFR3ZWVuTWF4LmtpbGxEZWxheWVkQ2FsbHNUbyA9IFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXguZ2V0VHdlZW5zT2YgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXgubGFnU21vb3RoaW5nID0gVHdlZW5MaXRlLmxhZ1Ntb290aGluZztcblx0XHRUd2Vlbk1heC50aWNrZXIgPSBUd2VlbkxpdGUudGlja2VyO1xuXHRcdFR3ZWVuTWF4LnJlbmRlciA9IFR3ZWVuTGl0ZS5yZW5kZXI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5MaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnVwZGF0ZVRvID0gZnVuY3Rpb24odmFycywgcmVzZXREdXJhdGlvbikge1xuXHRcdFx0dmFyIGN1clJhdGlvID0gdGhpcy5yYXRpbyxcblx0XHRcdFx0aW1tZWRpYXRlID0gdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCB2YXJzLmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0cDtcblx0XHRcdGlmIChyZXNldER1cmF0aW9uICYmIHRoaXMuX3N0YXJ0VGltZSA8IHRoaXMuX3RpbWVsaW5lLl90aW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX3RpbWVsaW5lLl90aW1lO1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuaW5zZXJ0KHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdGlmIChyZXNldER1cmF0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCAmJiB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpOyAvL2luIGNhc2UgYSBwbHVnaW4gbGlrZSBNb3Rpb25CbHVyIG11c3QgcGVyZm9ybSBzb21lIGNsZWFudXAgdGFza3Ncblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgLyB0aGlzLl9kdXJhdGlvbiA+IDAuOTk4KSB7IC8vaWYgdGhlIHR3ZWVuIGhhcyBmaW5pc2hlZCAob3IgY29tZSBleHRyZW1lbHkgY2xvc2UgdG8gZmluaXNoaW5nKSwgd2UganVzdCBuZWVkIHRvIHJld2luZCBpdCB0byAwIGFuZCB0aGVuIHJlbmRlciBpdCBhZ2FpbiBhdCB0aGUgZW5kIHdoaWNoIGZvcmNlcyBpdCB0byByZS1pbml0aWFsaXplIChwYXJzaW5nIHRoZSBuZXcgdmFycykuIFdlIGFsbG93IHR3ZWVucyB0aGF0IGFyZSBjbG9zZSB0byBmaW5pc2hpbmcgKGJ1dCBoYXZlbid0IHF1aXRlIGZpbmlzaGVkKSB0byB3b3JrIHRoaXMgd2F5IHRvbyBiZWNhdXNlIG90aGVyd2lzZSwgdGhlIHZhbHVlcyBhcmUgc28gc21hbGwgd2hlbiBkZXRlcm1pbmluZyB3aGVyZSB0byBwcm9qZWN0IHRoZSBzdGFydGluZyB2YWx1ZXMgdGhhdCBiaW5hcnkgbWF0aCBpc3N1ZXMgY3JlZXAgaW4gYW5kIGNhbiBtYWtlIHRoZSB0d2VlbiBhcHBlYXIgdG8gcmVuZGVyIGluY29ycmVjdGx5IHdoZW4gcnVuIGJhY2t3YXJkcy4gXG5cdFx0XHRcdFx0XHR2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIoMCwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPiAwIHx8IGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRcdFx0dmFyIGludiA9IDEgLyAoMSAtIGN1clJhdGlvKSxcblx0XHRcdFx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULCBlbmRWYWx1ZTtcblx0XHRcdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHB0LnMgKyBwdC5jOyBcblx0XHRcdFx0XHRcdFx0cHQuYyAqPSBpbnY7XG5cdFx0XHRcdFx0XHRcdHB0LnMgPSBlbmRWYWx1ZSAtIHB0LmM7XG5cdFx0XHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFx0XHRcblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSBpZiAodGhpcy5fZHVyYXRpb24gPT09IDAgJiYgdGhpcy52YXJzLnJlcGVhdCkgeyAvL3plcm8gZHVyYXRpb24gdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IGhhdmUgcmVuZGVyKCkgY2FsbGVkIGZyb20gVHdlZW5MaXRlJ3MgY29uc3RydWN0b3IsIGJlZm9yZSBUd2Vlbk1heCdzIGNvbnN0cnVjdG9yIGhhcyBmaW5pc2hlZCBzZXR0aW5nIF9yZXBlYXQsIF9yZXBlYXREZWxheSwgYW5kIF95b3lvIHdoaWNoIGFyZSBjcml0aWNhbCBpbiBkZXRlcm1pbmluZyB0b3RhbER1cmF0aW9uKCkgc28gd2UgbmVlZCB0byBjYWxsIGludmFsaWRhdGUoKSB3aGljaCBpcyBhIGxvdy1rYiB3YXkgdG8gZ2V0IHRob3NlIHNldCBwcm9wZXJseS5cblx0XHRcdFx0dGhpcy5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0cHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRwcmV2VG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLCBcblx0XHRcdFx0cHJldkN5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRpc0NvbXBsZXRlLCBjYWxsYmFjaywgcHQsIGN5Y2xlRHVyYXRpb24sIHIsIHR5cGUsIHBvdywgcmF3UHJldlRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1cikge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDEpIDogMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRmb3JjZSA9IChmb3JjZSB8fCB0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGFydFRpbWUgPT09IHRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbikgeyAvL2lmIGEgemVyby1kdXJhdGlvbiB0d2VlbiBpcyBhdCB0aGUgVkVSWSBlbmQgb2YgYSB0aW1lbGluZSBhbmQgdGhhdCB0aW1lbGluZSByZW5kZXJzIGF0IGl0cyBlbmQsIGl0IHdpbGwgdHlwaWNhbGx5IGFkZCBhIHRpbnkgYml0IG9mIGN1c2hpb24gdG8gdGhlIHJlbmRlciB0aW1lIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIGZyb20gZ2V0dGluZyBpbiB0aGUgd2F5IG9mIHR3ZWVucyByZW5kZXJpbmcgdGhlaXIgVkVSWSBlbmQuIElmIHdlIHRoZW4gcmV2ZXJzZSgpIHRoYXQgdGltZWxpbmUsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHdpbGwgdHJpZ2dlciBpdHMgb25SZXZlcnNlQ29tcGxldGUgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHkgdGhlIHBsYXloZWFkIGRpZG4ndCBwYXNzIG92ZXIgaXQgYWdhaW4uIEl0J3MgYSB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZSB3ZSBtdXN0IGFjY29tbW9kYXRlLlxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwIHx8IHByZXZSYXdQcmV2VGltZSA8IDAgfHwgcHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSkge1xuXHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgIT09IDAgfHwgKGR1cmF0aW9uID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA+IDApKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID49IDApIHtcblx0XHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHsgLy9pZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG5cdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGltZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9ICh0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSA+PiAwOyAvL29yaWdpbmFsbHkgX3RvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24gYnV0IGZsb2F0aW5nIHBvaW50IGVycm9ycyBjYXVzZWQgcHJvYmxlbXMsIHNvIEkgbm9ybWFsaXplZCBpdC4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IEZsYXNoIHJlcG9ydHMgaXQgYXMgMC43OTk5OTk5OSEpXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSAwKSBpZiAodGhpcy5fY3ljbGUgPT09IHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgLSAodGhpcy5fY3ljbGUgKiBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb24gLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Vhc2VUeXBlKSB7XG5cdFx0XHRcdFx0ciA9IHRoaXMuX3RpbWUgLyBkdXJhdGlvbjtcblx0XHRcdFx0XHR0eXBlID0gdGhpcy5fZWFzZVR5cGU7XG5cdFx0XHRcdFx0cG93ID0gdGhpcy5fZWFzZVBvd2VyO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxIHx8ICh0eXBlID09PSAzICYmIHIgPj0gMC41KSkge1xuXHRcdFx0XHRcdFx0ciA9IDEgLSByO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocG93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRyICo9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDIpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSA0KSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSAvIGR1cmF0aW9uIDwgMC41KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gciAvIDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gKHIgLyAyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdGlmIChwcmV2VGltZSA9PT0gdGhpcy5fdGltZSAmJiAhZm9yY2UgJiYgcHJldkN5Y2xlID09PSB0aGlzLl9jeWNsZSkge1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gdGhpcy5fdG90YWxUaW1lKSBpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHsgLy9zbyB0aGF0IG9uVXBkYXRlIGZpcmVzIGV2ZW4gZHVyaW5nIHRoZSByZXBlYXREZWxheSAtIGFzIGxvbmcgYXMgdGhlIHRvdGFsVGltZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdHJpZ2dlciBvblVwZGF0ZS5cblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fZ2MpIHsgLy9pbW1lZGlhdGVSZW5kZXIgdHdlZW5zIHR5cGljYWxseSB3b24ndCBpbml0aWFsaXplIHVudGlsIHRoZSBwbGF5aGVhZCBhZHZhbmNlcyAoX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDApIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IG92ZXJ3cml0aW5nIG9jY3VycyBwcm9wZXJseS4gQWxzbywgaWYgYWxsIG9mIHRoZSB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiAod2hpY2ggd291bGQgY2F1c2UgX2djIHRvIGJlIHRydWUsIGFzIHNldCBpbiBfaW5pdCgpKSwgd2Ugc2hvdWxkbid0IGNvbnRpbnVlIG90aGVyd2lzZSBhbiBvblN0YXJ0IGNhbGxiYWNrIGNvdWxkIGJlIGNhbGxlZCBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWZvcmNlICYmIHRoaXMuX2ZpcnN0UFQgJiYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSkgeyAvL3dlIHN0aWNrIGl0IGluIHRoZSBxdWV1ZSBmb3IgcmVuZGVyaW5nIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgdGljayAtIHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gYmVjYXVzZSBicm93c2VycyBpbnZhbGlkYXRlIHN0eWxlcyBhbmQgZm9yY2UgYSByZWNhbGN1bGF0aW9uIGlmIHlvdSByZWFkLCB3cml0ZSwgYW5kIHRoZW4gcmVhZCBzdHlsZSBkYXRhIChzbyBpdCdzIGJldHRlciB0byByZWFkL3JlYWQvcmVhZC93cml0ZS93cml0ZS93cml0ZSB0aGFuIHJlYWQvd3JpdGUvcmVhZC93cml0ZS9yZWFkL3dyaXRlKS4gVGhlIGRvd24gc2lkZSwgb2YgY291cnNlLCBpcyB0aGF0IHVzdWFsbHkgeW91IFdBTlQgdGhpbmdzIHRvIHJlbmRlciBpbW1lZGlhdGVseSBiZWNhdXNlIHlvdSBtYXkgaGF2ZSBjb2RlIHJ1bm5pbmcgcmlnaHQgYWZ0ZXIgdGhhdCB3aGljaCBkZXBlbmRzIG9uIHRoZSBjaGFuZ2UuIExpa2UgaW1hZ2luZSBydW5uaW5nIFR3ZWVuTGl0ZS5zZXQoLi4uKSBhbmQgdGhlbiBpbW1lZGlhdGVseSBhZnRlciB0aGF0LCBjcmVhdGluZyBhIG5vdGhlciB0d2VlbiB0aGF0IGFuaW1hdGVzIHRoZSBzYW1lIHByb3BlcnR5IHRvIGFub3RoZXIgdmFsdWU7IHRoZSBzdGFydGluZyB2YWx1ZXMgb2YgdGhhdCAybmQgdHdlZW4gd291bGRuJ3QgYmUgYWNjdXJhdGUgaWYgbGF6eSBpcyB0cnVlLlxuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBwcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSBwcmV2VG90YWxUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gcHJldkN5Y2xlO1xuXHRcdFx0XHRcdFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fbGF6eSA9IFt0aW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vX2Vhc2UgaXMgaW5pdGlhbGx5IHNldCB0byBkZWZhdWx0RWFzZSwgc28gbm93IHRoYXQgaW5pdCgpIGhhcyBydW4sIF9lYXNlIGlzIHNldCBwcm9wZXJseSBhbmQgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcmF0aW8uIE92ZXJhbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjb25kaXRpb25hbCBsb2dpYyBlYXJsaWVyIGluIHRoZSBtZXRob2QgdG8gYXZvaWQgaGF2aW5nIHRvIHNldCByYXRpbyB0d2ljZSBiZWNhdXNlIHdlIG9ubHkgaW5pdCgpIG9uY2UgYnV0IHJlbmRlclRpbWUoKSBnZXRzIGNhbGxlZCBWRVJZIGZyZXF1ZW50bHkuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lICYmICFpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgYSB0d2VlbiAoYXMgb3Bwb3NlZCB0byB0aGUgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgdGhlIHRpbWVsaW5lIGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHR3ZWVuIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLlxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgPT09IDIgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0XHQvL3RoaXMuaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHRcdHRoaXMuX2luaXQoKTsgLy93aWxsIGp1c3QgYXBwbHkgb3ZlcndyaXRpbmcgc2luY2UgX2luaXR0ZWQgb2YgKDIpIG1lYW5zIGl0IHdhcyBhIGZyb20oKSB0d2VlbiB0aGF0IGhhZCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIl9kdW1teUdTXCI7IC8vaWYgbm8gY2FsbGJhY2sgaXMgZGVmaW5lZCwgdXNlIGEgZHVtbXkgdmFsdWUganVzdCBzbyB0aGF0IHRoZSBjb25kaXRpb24gYXQgdGhlIGVuZCBldmFsdWF0ZXMgYXMgdHJ1ZSBiZWNhdXNlIF9zdGFydEF0IHNob3VsZCByZW5kZXIgQUZURVIgdGhlIG5vcm1hbCByZW5kZXIgbG9vcCB3aGVuIHRoZSB0aW1lIGlzIG5lZ2F0aXZlLiBXZSBjb3VsZCBoYW5kbGUgdGhpcyBpbiBhIG1vcmUgaW50dWl0aXZlIHdheSwgb2YgY291cnNlLCBidXQgdGhlIHJlbmRlciBsb29wIGlzIHRoZSBNT1NUIGltcG9ydGFudCB0aGluZyB0byBvcHRpbWl6ZSwgc28gdGhpcyB0ZWNobmlxdWUgYWxsb3dzIHVzIHRvIGF2b2lkIGFkZGluZyBleHRyYSBjb25kaXRpb25hbCBsb2dpYyBpbiBhIGhpZ2gtZnJlcXVlbmN5IGFyZWEuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gMCB8fCBkdXJhdGlvbiA9PT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdHRoaXMudmFycy5vblN0YXJ0LmFwcGx5KHRoaXMudmFycy5vblN0YXJ0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0VGltZSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHByZXZUb3RhbFRpbWUgfHwgaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gcHJldkN5Y2xlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAoIXRoaXMuX2djKSBpZiAodGhpcy52YXJzLm9uUmVwZWF0KSB7XG5cdFx0XHRcdHRoaXMudmFycy5vblJlcGVhdC5hcHBseSh0aGlzLnZhcnMub25SZXBlYXRTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25SZXBlYXRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djIHx8IGZvcmNlKSB7IC8vY2hlY2sgZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRUaW1lKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMudmFyc1tjYWxsYmFja10uYXBwbHkodGhpcy52YXJzW2NhbGxiYWNrICsgXCJTY29wZVwiXSB8fCB0aGlzLCB0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlBhcmFtc1wiXSB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiByYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0pIHsgLy90aGUgb25Db21wbGV0ZSBvciBvblJldmVyc2VDb21wbGV0ZSBjb3VsZCB0cmlnZ2VyIG1vdmVtZW50IG9mIHRoZSBwbGF5aGVhZCBhbmQgZm9yIHplcm8tZHVyYXRpb24gdHdlZW5zICh3aGljaCBtdXN0IGRpc2Nlcm4gZGlyZWN0aW9uKSB0aGF0IGxhbmQgZGlyZWN0bHkgYmFjayBvbiB0aGVpciBzdGFydCB0aW1lLCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgYWdhaW4gb24gdGhlIG5leHQgcmVuZGVyLiBUaGluayBvZiBzZXZlcmFsIGFkZFBhdXNlKCkncyBpbiBhIHRpbWVsaW5lIHRoYXQgZm9yY2VzIHRoZSBwbGF5aGVhZCB0byBhIGNlcnRhaW4gc3BvdCwgYnV0IHdoYXQgaWYgaXQncyBhbHJlYWR5IHBhdXNlZCBhbmQgYW5vdGhlciB0d2VlbiBpcyB0d2VlbmluZyB0aGUgXCJ0aW1lXCIgb2YgdGhlIHRpbWVsaW5lPyBFYWNoIHRpbWUgaXQgbW92ZXMgW2ZvcndhcmRdIHBhc3QgdGhhdCBzcG90LCBpdCB3b3VsZCBtb3ZlIGJhY2ssIGFuZCBzaW5jZSBzdXBwcmVzc0V2ZW50cyBpcyB0cnVlLCBpdCdkIHJlc2V0IF9yYXdQcmV2VGltZSB0byBfdGlueU51bSBzbyB0aGF0IHdoZW4gaXQgYmVnaW5zIGFnYWluLCB0aGUgY2FsbGJhY2sgd291bGQgZmlyZSAoc28gdWx0aW1hdGVseSBpdCBjb3VsZCBib3VuY2UgYmFjayBhbmQgZm9ydGggZHVyaW5nIHRoYXQgdHdlZW4pLiBBZ2FpbiwgdGhpcyBpcyBhIHZlcnkgdW5jb21tb24gc2NlbmFyaW8sIGJ1dCBwb3NzaWJsZSBub25ldGhlbGVzcy5cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuLy8tLS0tIFNUQVRJQyBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcblx0XHRUd2Vlbk1heC50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCBkdXJhdGlvbiwgdG9WYXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJUbyA9IFR3ZWVuTWF4LmFsbFRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdHZhciBkZWxheSA9IHZhcnMuZGVsYXkgfHwgMCxcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRmaW5hbENvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKHZhcnMub25Db21wbGV0ZSkge1xuXHRcdFx0XHRcdFx0dmFycy5vbkNvbXBsZXRlLmFwcGx5KHZhcnMub25Db21wbGV0ZVNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9uQ29tcGxldGVBbGwuYXBwbHkob25Db21wbGV0ZUFsbFNjb3BlIHx8IHRoaXMsIG9uQ29tcGxldGVBbGxQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRsLCBjb3B5LCBpLCBwO1xuXHRcdFx0aWYgKCFfaXNBcnJheSh0YXJnZXRzKSkge1xuXHRcdFx0XHRpZiAodHlwZW9mKHRhcmdldHMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0dGFyZ2V0cyA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXRzKSB8fCB0YXJnZXRzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNTZWxlY3Rvcih0YXJnZXRzKSkge1xuXHRcdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRhcmdldHMgPSB0YXJnZXRzIHx8IFtdO1xuXHRcdFx0aWYgKHN0YWdnZXIgPCAwKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHRcdHRhcmdldHMucmV2ZXJzZSgpO1xuXHRcdFx0XHRzdGFnZ2VyICo9IC0xO1xuXHRcdFx0fVxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoIC0gMTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPD0gbDsgaSsrKSB7XG5cdFx0XHRcdGNvcHkgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb3B5LmRlbGF5ID0gZGVsYXk7XG5cdFx0XHRcdGlmIChpID09PSBsICYmIG9uQ29tcGxldGVBbGwpIHtcblx0XHRcdFx0XHRjb3B5Lm9uQ29tcGxldGUgPSBmaW5hbENvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0gPSBuZXcgVHdlZW5NYXgodGFyZ2V0c1tpXSwgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0XHRkZWxheSArPSBzdGFnZ2VyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyRnJvbSA9IFR3ZWVuTWF4LmFsbEZyb20gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5NYXguc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlckZyb21UbyA9IFR3ZWVuTWF4LmFsbEZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBUd2Vlbk1heC5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXHRcdFx0XHRcblx0XHRUd2Vlbk1heC5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgdXNlRnJhbWVzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KGNhbGxiYWNrLCAwLCB7ZGVsYXk6ZGVsYXksIG9uQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBvbkNvbXBsZXRlU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6c2NvcGUsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIDAsIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguaXNUd2VlbmluZyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIChUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0LCB0cnVlKS5sZW5ndGggPiAwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBfZ2V0Q2hpbGRyZW5PZiA9IGZ1bmN0aW9uKHRpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0XHR0d2VlbiA9IHRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KF9nZXRDaGlsZHJlbk9mKHR3ZWVuLCBpbmNsdWRlVGltZWxpbmVzKSk7XG5cdFx0XHRcdFx0XHRjbnQgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sIFxuXHRcdFx0Z2V0QWxsVHdlZW5zID0gVHdlZW5NYXguZ2V0QWxsVHdlZW5zID0gZnVuY3Rpb24oaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHRyZXR1cm4gX2dldENoaWxkcmVuT2YoQW5pbWF0aW9uLl9yb290VGltZWxpbmUsIGluY2x1ZGVUaW1lbGluZXMpLmNvbmNhdCggX2dldENoaWxkcmVuT2YoQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUsIGluY2x1ZGVUaW1lbGluZXMpICk7XG5cdFx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmtpbGxBbGwgPSBmdW5jdGlvbihjb21wbGV0ZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0aWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdFx0XHRcdHR3ZWVucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGVsYXllZENhbGxzID09IG51bGwpIHtcblx0XHRcdFx0ZGVsYXllZENhbGxzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBhID0gZ2V0QWxsVHdlZW5zKCh0aW1lbGluZXMgIT0gZmFsc2UpKSxcblx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRhbGxUcnVlID0gKHR3ZWVucyAmJiBkZWxheWVkQ2FsbHMgJiYgdGltZWxpbmVzKSxcblx0XHRcdFx0aXNEQywgdHdlZW4sIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHR3ZWVuID0gYVtpXTtcblx0XHRcdFx0aWYgKGFsbFRydWUgfHwgKHR3ZWVuIGluc3RhbmNlb2YgU2ltcGxlVGltZWxpbmUpIHx8ICgoaXNEQyA9ICh0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpICYmIGRlbGF5ZWRDYWxscykgfHwgKHR3ZWVucyAmJiAhaXNEQykpIHtcblx0XHRcdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnRvdGFsVGltZSh0d2Vlbi5fcmV2ZXJzZWQgPyAwIDogdHdlZW4udG90YWxEdXJhdGlvbigpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmtpbGxDaGlsZFR3ZWVuc09mID0gZnVuY3Rpb24ocGFyZW50LCBjb21wbGV0ZSkge1xuXHRcdFx0aWYgKHBhcmVudCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IFR3ZWVuTGl0ZUludGVybmFscy50d2Vlbkxvb2t1cCxcblx0XHRcdFx0YSwgY3VyUGFyZW50LCBwLCBpLCBsO1xuXHRcdFx0aWYgKHR5cGVvZihwYXJlbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHBhcmVudCA9IFR3ZWVuTGl0ZS5zZWxlY3RvcihwYXJlbnQpIHx8IHBhcmVudDtcblx0XHRcdH1cblx0XHRcdGlmIChfaXNTZWxlY3RvcihwYXJlbnQpKSB7XG5cdFx0XHRcdHBhcmVudCA9IF9zbGljZShwYXJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc0FycmF5KHBhcmVudCkpIHtcblx0XHRcdFx0aSA9IHBhcmVudC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFR3ZWVuTWF4LmtpbGxDaGlsZFR3ZWVuc09mKHBhcmVudFtpXSwgY29tcGxldGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGEgPSBbXTtcblx0XHRcdGZvciAocCBpbiB0bCkge1xuXHRcdFx0XHRjdXJQYXJlbnQgPSB0bFtwXS50YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdFx0d2hpbGUgKGN1clBhcmVudCkge1xuXHRcdFx0XHRcdGlmIChjdXJQYXJlbnQgPT09IHBhcmVudCkge1xuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KHRsW3BdLnR3ZWVucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1clBhcmVudCA9IGN1clBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsID0gYS5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0XHRcdGFbaV0udG90YWxUaW1lKGFbaV0udG90YWxEdXJhdGlvbigpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBfY2hhbmdlUGF1c2UgPSBmdW5jdGlvbihwYXVzZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0dHdlZW5zID0gKHR3ZWVucyAhPT0gZmFsc2UpO1xuXHRcdFx0ZGVsYXllZENhbGxzID0gKGRlbGF5ZWRDYWxscyAhPT0gZmFsc2UpO1xuXHRcdFx0dGltZWxpbmVzID0gKHRpbWVsaW5lcyAhPT0gZmFsc2UpO1xuXHRcdFx0dmFyIGEgPSBnZXRBbGxUd2VlbnModGltZWxpbmVzKSxcblx0XHRcdFx0YWxsVHJ1ZSA9ICh0d2VlbnMgJiYgZGVsYXllZENhbGxzICYmIHRpbWVsaW5lcyksXG5cdFx0XHRcdGkgPSBhLmxlbmd0aCxcblx0XHRcdFx0aXNEQywgdHdlZW47XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0dHdlZW4gPSBhW2ldO1xuXHRcdFx0XHRpZiAoYWxsVHJ1ZSB8fCAodHdlZW4gaW5zdGFuY2VvZiBTaW1wbGVUaW1lbGluZSkgfHwgKChpc0RDID0gKHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkgJiYgZGVsYXllZENhbGxzKSB8fCAodHdlZW5zICYmICFpc0RDKSkge1xuXHRcdFx0XHRcdHR3ZWVuLnBhdXNlZChwYXVzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnBhdXNlQWxsID0gZnVuY3Rpb24odHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0X2NoYW5nZVBhdXNlKHRydWUsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgucmVzdW1lQWxsID0gZnVuY3Rpb24odHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0X2NoYW5nZVBhdXNlKGZhbHNlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5NYXguZ2xvYmFsVGltZVNjYWxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciB0bCA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lLFxuXHRcdFx0XHR0ID0gVHdlZW5MaXRlLnRpY2tlci50aW1lO1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0bC5fdGltZVNjYWxlO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBfdGlueU51bTsgLy9jYW4ndCBhbGxvdyB6ZXJvIGJlY2F1c2UgaXQnbGwgdGhyb3cgdGhlIG1hdGggb2ZmXG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRsLl9zdGFydFRpbWUpICogdGwuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdHRsID0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmU7XG5cdFx0XHR0ID0gVHdlZW5MaXRlLnRpY2tlci5mcmFtZTtcblx0XHRcdHRsLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGwuX3N0YXJ0VGltZSkgKiB0bC5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0dGwuX3RpbWVTY2FsZSA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lLl90aW1lU2NhbGUgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHRcdFxuXHRcbi8vLS0tLSBHRVRURVJTIC8gU0VUVEVSUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy5kdXJhdGlvbigpICogKCh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSksIGZhbHNlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsVGltZSAvIHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIGZhbHNlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlID0gKHRoaXMuX2R1cmF0aW9uIC0gdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlICs9IHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjsgLy9kb24ndCBzZXQgX2RpcnR5ID0gZmFsc2UgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSByZXBlYXRzIHRoYXQgaGF2ZW4ndCBiZWVuIGZhY3RvcmVkIGludG8gdGhlIF90b3RhbER1cmF0aW9uIHlldC4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIGEgcmVwZWF0ZWQgVHdlZW5NYXggYW5kIHRoZW4gaW1tZWRpYXRlbHkgY2hlY2sgaXRzIGR1cmF0aW9uKCksIGl0IHdvdWxkIGNhY2hlIHRoZSB2YWx1ZSBhbmQgdGhlIHRvdGFsRHVyYXRpb24gd291bGQgbm90IGJlIGNvcnJlY3QsIHRodXMgcmVwZWF0cyB3b3VsZG4ndCB0YWtlIGVmZmVjdC5cblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmR1cmF0aW9uLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdC8vaW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlc1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsRHVyYXRpb24gPSAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0aGlzLl9kdXJhdGlvbiAqICh0aGlzLl9yZXBlYXQgKyAxKSArICh0aGlzLl9yZXBlYXREZWxheSAqIHRoaXMuX3JlcGVhdCk7XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyB0aGlzIDogdGhpcy5kdXJhdGlvbiggKHZhbHVlIC0gKHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JlcGVhdERlbGF5KSkgLyAodGhpcy5fcmVwZWF0ICsgMSkgKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAucmVwZWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAucmVwZWF0RGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHJldHVybiBUd2Vlbk1heDtcblx0XHRcblx0fSwgdHJ1ZSk7XG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpbWVsaW5lTGl0ZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTGl0ZVwiLCBbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lLCBUd2VlbkxpdGUpIHtcblxuXHRcdHZhciBUaW1lbGluZUxpdGUgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdFNpbXBsZVRpbWVsaW5lLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX2xhYmVscyA9IHt9O1xuXHRcdFx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICh0aGlzLnZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICh0aGlzLnZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9zb3J0Q2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdFx0dmFsLCBwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdikge1xuXHRcdFx0XHRcdHZhbCA9IHZbcF07XG5cdFx0XHRcdFx0aWYgKF9pc0FycmF5KHZhbCkpIGlmICh2YWwuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dltwXSA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc0FycmF5KHYudHdlZW5zKSkge1xuXHRcdFx0XHRcdHRoaXMuYWRkKHYudHdlZW5zLCAwLCB2LmFsaWduLCB2LnN0YWdnZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pbnRlcm5hbHMgPSBUaW1lbGluZUxpdGUuX2ludGVybmFscyA9IHt9LFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNTZWxlY3Rvcixcblx0XHRcdF9pc0FycmF5ID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzQXJyYXksXG5cdFx0XHRfbGF6eVR3ZWVucyA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVJlbmRlcixcblx0XHRcdF9ibGFua0FycmF5ID0gW10sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2NvcHkgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdHZhciBjb3B5ID0ge30sIHA7XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0XHR9LFxuXHRcdFx0X3BhdXNlQ2FsbGJhY2sgPSBfaW50ZXJuYWxzLnBhdXNlQ2FsbGJhY2sgPSBmdW5jdGlvbih0d2VlbiwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdFx0dmFyIHRsID0gdHdlZW4uX3RpbWVsaW5lLFxuXHRcdFx0XHRcdHRpbWUgPSB0bC5fdG90YWxUaW1lLFxuXHRcdFx0XHRcdHN0YXJ0VGltZSA9IHR3ZWVuLl9zdGFydFRpbWUsXG5cdFx0XHRcdFx0cmV2ZXJzZWQgPSAodHdlZW4uX3Jhd1ByZXZUaW1lIDwgMCB8fCAodHdlZW4uX3Jhd1ByZXZUaW1lID09PSAwICYmIHRsLl9yZXZlcnNlZCkpLC8vZG9uJ3QgdXNlIHR3ZWVuLnJhdGlvIGJlY2F1c2UgaWYgdGhlIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgb24gdG9wIG9mIHRoZSBhZGRQYXVzZSgpLCByYXRpbyB3aWxsIGJlIDEgZXZlbiBpZiB0aGUgbWFzdGVyIHRpbWVsaW5lIHdhcyByZXZlcnNlZCAod2hpY2ggaXMgY29ycmVjdCkuIFRoZSBrZXkgaGVyZSBpcyB0byBzZW5zZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBwbGF5aGVhZC5cblx0XHRcdFx0XHRuZXh0ID0gcmV2ZXJzZWQgPyAwIDogX3RpbnlOdW0sXG5cdFx0XHRcdFx0cHJldiA9IHJldmVyc2VkID8gX3RpbnlOdW0gOiAwLFxuXHRcdFx0XHRcdHNpYmxpbmc7XG5cdFx0XHRcdGlmIChjYWxsYmFjayB8fCAhdGhpcy5fZm9yY2luZ1BsYXloZWFkKSB7IC8vaWYgdGhlIHVzZXIgY2FsbHMgYSBtZXRob2QgdGhhdCBtb3ZlcyB0aGUgcGxheWhlYWQgKGxpa2UgcHJvZ3Jlc3MoKSBvciB0aW1lKCkpLCBpdCBzaG91bGQgaG9ub3IgdGhhdCBhbmQgc2tpcCBhbnkgcGF1c2VzIChhbHRob3VnaCBpZiB0aGVyZSdzIGEgY2FsbGJhY2sgcG9zaXRpb25lZCBhdCB0aGF0IHBhdXNlLCBpdCBtdXN0IGp1bXAgdGhlcmUgYW5kIG1ha2UgdGhlIGNhbGwgdG8gZW5zdXJlIHRoZSB0aW1lIGlzIEVYQUNUTFkgd2hhdCBpdCBpcyBzdXBwb3NlZCB0byBiZSwgYW5kIHRoZW4gcHJvY2VlZCB0byB3aGVyZSB0aGUgcGxheWhlYWQgaXMgYmVpbmcgZm9yY2VkKS4gT3RoZXJ3aXNlLCBpbWFnaW5lIHBsYWNpbmcgYSBwYXVzZSBpbiB0aGUgbWlkZGxlIG9mIGEgdGltZWxpbmUgYW5kIHRoZW4gZG9pbmcgdGltZWxpbmUucHJvZ3Jlc3MoMC45KSAtIGl0IHdvdWxkIGdldCBzdHVjayB3aGVyZSB0aGUgcGF1c2UgaXMuXG5cdFx0XHRcdFx0dGwucGF1c2Uoc3RhcnRUaW1lKTtcblx0XHRcdFx0XHQvL25vdyBmaW5kIHNpYmxpbmcgdHdlZW5zIHRoYXQgYXJlIEVYQUNUTFkgYXQgdGhlIHNhbWUgc3BvdCBvbiB0aGUgdGltZWxpbmUgYW5kIGFkanVzdCB0aGUgX3Jhd1ByZXZUaW1lIHNvIHRoYXQgdGhleSBmaXJlIChvciBkb24ndCBmaXJlKSBjb3JyZWN0bHkgb24gdGhlIG5leHQgcmVuZGVyLiBUaGlzIGlzIHByaW1hcmlseSB0byBhY2NvbW1vZGF0ZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucy9jYWxsYmFja3MgdGhhdCBhcmUgcG9zaXRpb25lZCByaWdodCBvbiB0b3Agb2YgYSBwYXVzZS4gRm9yIGV4YW1wbGUsIHRsLnRvKC4uLikuY2FsbCguLi4pLmFkZFBhdXNlKC4uLikuY2FsbCguLi4pIC0gbm90aWNlIHRoYXQgdGhlcmUncyBhIGNhbGwoKSBvbiBlYWNoIHNpZGUgb2YgdGhlIHBhdXNlLCBzbyB3aGVuIGl0J3MgcnVubmluZyBmb3J3YXJkIGl0IHNob3VsZCBjYWxsIHRoZSBmaXJzdCBvbmUgYW5kIHRoZW4gcGF1c2UsIGFuZCB0aGVuIHdoZW4gcmVzdW1lZCwgY2FsbCB0aGUgb3RoZXIuIFplcm8tZHVyYXRpb24gdHdlZW5zIHVzZSBfcmF3UHJldlRpbWUgdG8gc2Vuc2UgbW9tZW50dW0gZmlndXJlIG91dCBpZiBldmVudHMgd2VyZSBzdXBwcmVzc2VkIHdoZW4gYXJyaXZpbmcgZGlyZWN0bHkgb24gdG9wIG9mIHRoYXQgdGltZS5cblx0XHRcdFx0XHRzaWJsaW5nID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0d2hpbGUgKHNpYmxpbmcgJiYgc2libGluZy5fc3RhcnRUaW1lID09PSBzdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdHNpYmxpbmcuX3Jhd1ByZXZUaW1lID0gcHJldjtcblx0XHRcdFx0XHRcdHNpYmxpbmcgPSBzaWJsaW5nLl9wcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzaWJsaW5nID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0d2hpbGUgKHNpYmxpbmcgJiYgc2libGluZy5fc3RhcnRUaW1lID09PSBzdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdHNpYmxpbmcuX3Jhd1ByZXZUaW1lID0gbmV4dDtcblx0XHRcdFx0XHRcdHNpYmxpbmcgPSBzaWJsaW5nLl9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KHNjb3BlIHx8IHRsLCBwYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fZm9yY2luZ1BsYXloZWFkIHx8ICF0bC5fcGF1c2VkKSB7IC8vdGhlIGNhbGxiYWNrIGNvdWxkIGhhdmUgY2FsbGVkIHJlc3VtZSgpLlxuXHRcdFx0XHRcdFx0dGwuc2Vlayh0aW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIFtdLnNsaWNlIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0cCA9IFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKTtcblxuXHRcdFRpbWVsaW5lTGl0ZS52ZXJzaW9uID0gXCIxLjE2LjFcIjtcblx0XHRwLmNvbnN0cnVjdG9yID0gVGltZWxpbmVMaXRlO1xuXHRcdHAua2lsbCgpLl9nYyA9IHAuX2ZvcmNpbmdQbGF5aGVhZCA9IGZhbHNlO1xuXG5cdFx0LyogbWlnaHQgdXNlIGxhdGVyLi4uXG5cdFx0Ly90cmFuc2xhdGVzIGEgbG9jYWwgdGltZSBpbnNpZGUgYW4gYW5pbWF0aW9uIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRpbWUgb24gdGhlIHJvb3QvZ2xvYmFsIHRpbWVsaW5lLCBmYWN0b3JpbmcgaW4gYWxsIG5lc3RpbmcgYW5kIHRpbWVTY2FsZXMuXG5cdFx0ZnVuY3Rpb24gbG9jYWxUb0dsb2JhbCh0aW1lLCBhbmltYXRpb24pIHtcblx0XHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdFx0dGltZSA9ICh0aW1lIC8gYW5pbWF0aW9uLl90aW1lU2NhbGUpICsgYW5pbWF0aW9uLl9zdGFydFRpbWU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aW1lO1xuXHRcdH1cblxuXHRcdC8vdHJhbnNsYXRlcyB0aGUgc3VwcGxpZWQgdGltZSBvbiB0aGUgcm9vdC9nbG9iYWwgdGltZWxpbmUgaW50byB0aGUgY29ycmVzcG9uZGluZyBsb2NhbCB0aW1lIGluc2lkZSBhIHBhcnRpY3VsYXIgYW5pbWF0aW9uLCBmYWN0b3JpbmcgaW4gYWxsIG5lc3RpbmcgYW5kIHRpbWVTY2FsZXNcblx0XHRmdW5jdGlvbiBnbG9iYWxUb0xvY2FsKHRpbWUsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHNjYWxlID0gMTtcblx0XHRcdHRpbWUgLT0gbG9jYWxUb0dsb2JhbCgwLCBhbmltYXRpb24pO1xuXHRcdFx0d2hpbGUgKGFuaW1hdGlvbikge1xuXHRcdFx0XHRzY2FsZSAqPSBhbmltYXRpb24uX3RpbWVTY2FsZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbWUgKiBzY2FsZTtcblx0XHR9XG5cdFx0Ki9cblxuXHRcdHAudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0dmFyIEVuZ2luZSA9ICh2YXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlO1xuXHRcdFx0cmV0dXJuIGR1cmF0aW9uID8gdGhpcy5hZGQoIG5ldyBFbmdpbmUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksIHBvc2l0aW9uKSA6IHRoaXMuc2V0KHRhcmdldCwgdmFycywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCAoKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGUpLmZyb20odGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuXHRcdFx0dmFyIEVuZ2luZSA9ICh0b1ZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGU7XG5cdFx0XHRyZXR1cm4gZHVyYXRpb24gPyB0aGlzLmFkZCggRW5naW5lLmZyb21Ubyh0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSwgcG9zaXRpb24pIDogdGhpcy5zZXQodGFyZ2V0LCB0b1ZhcnMsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFyIHRsID0gbmV3IFRpbWVsaW5lTGl0ZSh7b25Db21wbGV0ZTpvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlUGFyYW1zOm9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVTY29wZTpvbkNvbXBsZXRlQWxsU2NvcGUsIHNtb290aENoaWxkVGltaW5nOnRoaXMuc21vb3RoQ2hpbGRUaW1pbmd9KSxcblx0XHRcdFx0aTtcblx0XHRcdGlmICh0eXBlb2YodGFyZ2V0cykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dGFyZ2V0cyA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXRzKSB8fCB0YXJnZXRzO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0cyA9IHRhcmdldHMgfHwgW107XG5cdFx0XHRpZiAoX2lzU2VsZWN0b3IodGFyZ2V0cykpIHsgLy9zZW5zZXMgaWYgdGhlIHRhcmdldHMgb2JqZWN0IGlzIGEgc2VsZWN0b3IuIElmIGl0IGlzLCB3ZSBzaG91bGQgdHJhbnNsYXRlIGl0IGludG8gYW4gYXJyYXkuXG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHR9XG5cdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0aWYgKHN0YWdnZXIgPCAwKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHRcdHRhcmdldHMucmV2ZXJzZSgpO1xuXHRcdFx0XHRzdGFnZ2VyICo9IC0xO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHZhcnMuc3RhcnRBdCkge1xuXHRcdFx0XHRcdHZhcnMuc3RhcnRBdCA9IF9jb3B5KHZhcnMuc3RhcnRBdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGwudG8odGFyZ2V0c1tpXSwgZHVyYXRpb24sIF9jb3B5KHZhcnMpLCBpICogc3RhZ2dlcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodGwsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cblx0XHRwLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiwgMCwgdHJ1ZSk7XG5cdFx0XHRpZiAodmFycy5pbW1lZGlhdGVSZW5kZXIgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9IChwb3NpdGlvbiA9PT0gdGhpcy5fdGltZSAmJiAhdGhpcy5fcGF1c2VkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmFkZCggbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIDAsIHZhcnMpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdFRpbWVsaW5lTGl0ZS5leHBvcnRSb290ID0gZnVuY3Rpb24odmFycywgaWdub3JlRGVsYXllZENhbGxzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdGlmICh2YXJzLnNtb290aENoaWxkVGltaW5nID09IG51bGwpIHtcblx0XHRcdFx0dmFycy5zbW9vdGhDaGlsZFRpbWluZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSBuZXcgVGltZWxpbmVMaXRlKHZhcnMpLFxuXHRcdFx0XHRyb290ID0gdGwuX3RpbWVsaW5lLFxuXHRcdFx0XHR0d2VlbiwgbmV4dDtcblx0XHRcdGlmIChpZ25vcmVEZWxheWVkQ2FsbHMgPT0gbnVsbCkge1xuXHRcdFx0XHRpZ25vcmVEZWxheWVkQ2FsbHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cm9vdC5fcmVtb3ZlKHRsLCB0cnVlKTtcblx0XHRcdHRsLl9zdGFydFRpbWUgPSAwO1xuXHRcdFx0dGwuX3Jhd1ByZXZUaW1lID0gdGwuX3RpbWUgPSB0bC5fdG90YWxUaW1lID0gcm9vdC5fdGltZTtcblx0XHRcdHR3ZWVuID0gcm9vdC5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRpZiAoIWlnbm9yZURlbGF5ZWRDYWxscyB8fCAhKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlICYmIHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkge1xuXHRcdFx0XHRcdHRsLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0fVxuXHRcdFx0cm9vdC5hZGQodGwsIDApO1xuXHRcdFx0cmV0dXJuIHRsO1xuXHRcdH07XG5cblx0XHRwLmFkZCA9IGZ1bmN0aW9uKHZhbHVlLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHZhciBjdXJUaW1lLCBsLCBpLCBjaGlsZCwgdGwsIGJlZm9yZVJhd1RpbWU7XG5cdFx0XHRpZiAodHlwZW9mKHBvc2l0aW9uKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24sIDAsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuXHRcdFx0XHRpZiAoKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHx8ICh2YWx1ZSAmJiB2YWx1ZS5wdXNoICYmIF9pc0FycmF5KHZhbHVlKSkpIHtcblx0XHRcdFx0XHRhbGlnbiA9IGFsaWduIHx8IFwibm9ybWFsXCI7XG5cdFx0XHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdFx0XHRjdXJUaW1lID0gcG9zaXRpb247XG5cdFx0XHRcdFx0bCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoX2lzQXJyYXkoY2hpbGQgPSB2YWx1ZVtpXSkpIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBuZXcgVGltZWxpbmVMaXRlKHt0d2VlbnM6Y2hpbGR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuYWRkKGNoaWxkLCBjdXJUaW1lKTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoY2hpbGQpICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZihjaGlsZCkgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoYWxpZ24gPT09IFwic2VxdWVuY2VcIikge1xuXHRcdFx0XHRcdFx0XHRcdGN1clRpbWUgPSBjaGlsZC5fc3RhcnRUaW1lICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIGNoaWxkLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFsaWduID09PSBcInN0YXJ0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZC5fc3RhcnRUaW1lIC09IGNoaWxkLmRlbGF5KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN1clRpbWUgKz0gc3RhZ2dlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFkZExhYmVsKHZhbHVlLCBwb3NpdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgdmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93KFwiQ2Fubm90IGFkZCBcIiArIHZhbHVlICsgXCIgaW50byB0aGUgdGltZWxpbmU7IGl0IGlzIG5vdCBhIHR3ZWVuLCB0aW1lbGluZSwgZnVuY3Rpb24sIG9yIHN0cmluZy5cIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0U2ltcGxlVGltZWxpbmUucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIHZhbHVlLCBwb3NpdGlvbik7XG5cblx0XHRcdC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXHRcdFx0aWYgKHRoaXMuX2djIHx8IHRoaXMuX3RpbWUgPT09IHRoaXMuX2R1cmF0aW9uKSBpZiAoIXRoaXMuX3BhdXNlZCkgaWYgKHRoaXMuX2R1cmF0aW9uIDwgdGhpcy5kdXJhdGlvbigpKSB7XG5cdFx0XHRcdC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9ycyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQuLi5cblx0XHRcdFx0dGwgPSB0aGlzO1xuXHRcdFx0XHRiZWZvcmVSYXdUaW1lID0gKHRsLnJhd1RpbWUoKSA+IHZhbHVlLl9zdGFydFRpbWUpOyAvL2lmIHRoZSB0d2VlbiBpcyBwbGFjZWQgb24gdGhlIHRpbWVsaW5lIHNvIHRoYXQgaXQgc3RhcnRzIEJFRk9SRSB0aGUgY3VycmVudCByYXdUaW1lLCB3ZSBzaG91bGQgYWxpZ24gdGhlIHBsYXloZWFkIChtb3ZlIHRoZSB0aW1lbGluZSkuIFRoaXMgaXMgYmVjYXVzZSBzb21ldGltZXMgdXNlcnMgd2lsbCBjcmVhdGUgYSB0aW1lbGluZSwgbGV0IGl0IGZpbmlzaCwgYW5kIG11Y2ggbGF0ZXIgYXBwZW5kIGEgdHdlZW4gYW5kIGV4cGVjdCBpdCB0byBydW4gaW5zdGVhZCBvZiBqdW1waW5nIHRvIGl0cyBlbmQgc3RhdGUuIFdoaWxlIHRlY2huaWNhbGx5IG9uZSBjb3VsZCBhcmd1ZSB0aGF0IGl0IHNob3VsZCBqdW1wIHRvIGl0cyBlbmQgc3RhdGUsIHRoYXQncyBub3Qgd2hhdCB1c2VycyBpbnR1aXRpdmVseSBleHBlY3QuXG5cdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRpZiAoYmVmb3JlUmF3VGltZSAmJiB0bC5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRcdHRsLnRvdGFsVGltZSh0bC5fdG90YWxUaW1lLCB0cnVlKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0bC5fZ2MpIHtcblx0XHRcdFx0XHRcdHRsLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVtb3ZlKHZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgfHwgKHZhbHVlICYmIHZhbHVlLnB1c2ggJiYgX2lzQXJyYXkodmFsdWUpKSkge1xuXHRcdFx0XHR2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmUodmFsdWVbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUxhYmVsKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmtpbGwobnVsbCwgdmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLl9yZW1vdmUgPSBmdW5jdGlvbih0d2Vlbiwgc2tpcERpc2FibGUpIHtcblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5fcmVtb3ZlLmNhbGwodGhpcywgdHdlZW4sIHNraXBEaXNhYmxlKTtcblx0XHRcdHZhciBsYXN0ID0gdGhpcy5fbGFzdDtcblx0XHRcdGlmICghbGFzdCkge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA+IGxhc3QuX3N0YXJ0VGltZSArIGxhc3QuX3RvdGFsRHVyYXRpb24gLyBsYXN0Ll90aW1lU2NhbGUpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmFwcGVuZCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXRPckxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodmFsdWUsIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCwgb2Zmc2V0T3JMYWJlbCwgdHJ1ZSwgdmFsdWUpKTtcblx0XHR9O1xuXG5cdFx0cC5pbnNlcnQgPSBwLmluc2VydE11bHRpcGxlID0gZnVuY3Rpb24odmFsdWUsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHZhbHVlLCBwb3NpdGlvbiB8fCAwLCBhbGlnbiwgc3RhZ2dlcik7XG5cdFx0fTtcblxuXHRcdHAuYXBwZW5kTXVsdGlwbGUgPSBmdW5jdGlvbih0d2VlbnMsIG9mZnNldE9yTGFiZWwsIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodHdlZW5zLCB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsIG9mZnNldE9yTGFiZWwsIHRydWUsIHR3ZWVucyksIGFsaWduLCBzdGFnZ2VyKTtcblx0XHR9O1xuXG5cdFx0cC5hZGRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsLCBwb3NpdGlvbikge1xuXHRcdFx0dGhpcy5fbGFiZWxzW2xhYmVsXSA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuYWRkUGF1c2UgPSBmdW5jdGlvbihwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdHZhciB0ID0gVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIF9wYXVzZUNhbGxiYWNrLCBbXCJ7c2VsZn1cIiwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGVdLCB0aGlzKTtcblx0XHRcdHQuZGF0YSA9IFwiaXNQYXVzZVwiOyAvLyB3ZSB1c2UgdGhpcyBmbGFnIGluIFR3ZWVuTGl0ZSdzIHJlbmRlcigpIG1ldGhvZCB0byBpZGVudGlmeSBpdCBhcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHNob3VsZG4ndCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmlydHVhbCBwbGF5aGVhZCBpcyBMRUFWSU5HIHRoZSBleGFjdCBwb3NpdGlvbiB3aGVyZSB0aGUgcGF1c2UgaXMsIG90aGVyd2lzZSB0aW1lbGluZS5hZGRQYXVzZSgxKS5wbGF5KDEpIHdvdWxkIGVuZCB1cCBwYXVzZWQgb24gdGhlIHZlcnkgbmV4dCB0aWNrLlxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHQsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGFiZWxzW2xhYmVsXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsVGltZSA9IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2xhYmVsc1tsYWJlbF0gIT0gbnVsbCkgPyB0aGlzLl9sYWJlbHNbbGFiZWxdIDogLTE7XG5cdFx0fTtcblxuXHRcdHAuX3BhcnNlVGltZU9yTGFiZWwgPSBmdW5jdGlvbih0aW1lT3JMYWJlbCwgb2Zmc2V0T3JMYWJlbCwgYXBwZW5kSWZBYnNlbnQsIGlnbm9yZSkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHQvL2lmIHdlJ3JlIGFib3V0IHRvIGFkZCBhIHR3ZWVuL3RpbWVsaW5lIChvciBhbiBhcnJheSBvZiB0aGVtKSB0aGF0J3MgYWxyZWFkeSBhIGNoaWxkIG9mIHRoaXMgdGltZWxpbmUsIHdlIHNob3VsZCByZW1vdmUgaXQgZmlyc3Qgc28gdGhhdCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBkdXJhdGlvbigpLlxuXHRcdFx0aWYgKGlnbm9yZSBpbnN0YW5jZW9mIEFuaW1hdGlvbiAmJiBpZ25vcmUudGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlKTtcblx0XHRcdH0gZWxzZSBpZiAoaWdub3JlICYmICgoaWdub3JlIGluc3RhbmNlb2YgQXJyYXkpIHx8IChpZ25vcmUucHVzaCAmJiBfaXNBcnJheShpZ25vcmUpKSkpIHtcblx0XHRcdFx0aSA9IGlnbm9yZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChpZ25vcmVbaV0gaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlW2ldLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZShpZ25vcmVbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZihvZmZzZXRPckxhYmVsKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChvZmZzZXRPckxhYmVsLCAoYXBwZW5kSWZBYnNlbnQgJiYgdHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJudW1iZXJcIiAmJiB0aGlzLl9sYWJlbHNbb2Zmc2V0T3JMYWJlbF0gPT0gbnVsbCkgPyB0aW1lT3JMYWJlbCAtIHRoaXMuZHVyYXRpb24oKSA6IDAsIGFwcGVuZElmQWJzZW50KTtcblx0XHRcdH1cblx0XHRcdG9mZnNldE9yTGFiZWwgPSBvZmZzZXRPckxhYmVsIHx8IDA7XG5cdFx0XHRpZiAodHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJzdHJpbmdcIiAmJiAoaXNOYU4odGltZU9yTGFiZWwpIHx8IHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gIT0gbnVsbCkpIHsgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cblx0XHRcdFx0aSA9IHRpbWVPckxhYmVsLmluZGV4T2YoXCI9XCIpO1xuXHRcdFx0XHRpZiAoaSA9PT0gLTEpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYXBwZW5kSWZBYnNlbnQgPyAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9IHRoaXMuZHVyYXRpb24oKSArIG9mZnNldE9yTGFiZWwpIDogb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gKyBvZmZzZXRPckxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9mZnNldE9yTGFiZWwgPSBwYXJzZUludCh0aW1lT3JMYWJlbC5jaGFyQXQoaS0xKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodGltZU9yTGFiZWwuc3Vic3RyKGkrMSkpO1xuXHRcdFx0XHR0aW1lT3JMYWJlbCA9IChpID4gMSkgPyB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHRpbWVPckxhYmVsLnN1YnN0cigwLCBpLTEpLCAwLCBhcHBlbmRJZkFic2VudCkgOiB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWVPckxhYmVsID09IG51bGwpIHtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtYmVyKHRpbWVPckxhYmVsKSArIG9mZnNldE9yTGFiZWw7XG5cdFx0fTtcblxuXHRcdHAuc2VlayA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKCh0eXBlb2YocG9zaXRpb24pID09PSBcIm51bWJlclwiKSA/IHBvc2l0aW9uIDogdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiksIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpKTtcblx0XHR9O1xuXG5cdFx0cC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYXkocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2UocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlBhdXNlZCA9IHRoaXMuX3BhdXNlZCxcblx0XHRcdFx0dHdlZW4sIGlzQ29tcGxldGUsIG5leHQsIGNhbGxiYWNrLCBpbnRlcm5hbEZvcmNlO1xuXHRcdFx0aWYgKHRpbWUgPj0gdG90YWxEdXIpIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkKSBpZiAoIXRoaXMuX2hhc1BhdXNlZENoaWxkKCkpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSAhIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbjsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2R1cmF0aW9uID09PSAwKSBpZiAodGltZSA9PT0gMCB8fCB0aGlzLl9yYXdQcmV2VGltZSA8IDAgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtKSBpZiAodGhpcy5fcmF3UHJldlRpbWUgIT09IHRpbWUgJiYgdGhpcy5fZmlyc3QpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0dGltZSA9IHRvdGFsRHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy5cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKHRoaXMuX2R1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lICE9PSBfdGlueU51bSAmJiAodGhpcy5fcmF3UHJldlRpbWUgPiAwIHx8ICh0aW1lIDwgMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA+PSAwKSkpKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgdGhpcy5fcmV2ZXJzZWQpIHsgLy9lbnN1cmVzIHByb3BlciBHQyBpZiBhIHRpbWVsaW5lIGlzIHJlc3VtZWQgYWZ0ZXIgaXQncyBmaW5pc2hlZCByZXZlcnNpbmcuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gaXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lID49IDAgJiYgdGhpcy5fZmlyc3QpIHsgLy93aGVuIGdvaW5nIGJhY2sgYmV5b25kIHRoZSBzdGFydCwgZm9yY2UgYSByZW5kZXIgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyB0aGF0IHNpdCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgcmVuZGVyIHRoZWlyIHN0YXJ0IHZhbHVlcyBwcm9wZXJseS4gT3RoZXJ3aXNlLCBpZiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBhdCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lLCBhbmQgdGhlbiBtb3ZlcyBiYWNrd2FyZHMsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgYmVnaW5uaW5nIHdvdWxkIHN0aWxsIGJlIGF0IHRoZWlyIGVuZCBzdGF0ZS5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwICYmIGlzQ29tcGxldGUpIHsgLy9pZiB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSB0aW1lbGluZSBhbmQgdGhlIHBsYXloZWFkIGxhbmRzIEVYQUNUTFkgYXQgdGltZSAwLCB0aGF0IHR3ZWVuIHdpbGwgY29ycmVjdGx5IHJlbmRlciBpdHMgZW5kIHZhbHVlcywgYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgdGltZWxpbmUgYWxpdmUgZm9yIG9uZSBtb3JlIHJlbmRlciBzbyB0aGF0IHRoZSBiZWdpbm5pbmcgdmFsdWVzIHJlbmRlciBwcm9wZXJseSBhcyB0aGUgcGFyZW50J3MgcGxheWhlYWQga2VlcHMgbW92aW5nIGJleW9uZCB0aGUgYmVnaW5pbmcuIEltYWdpbmUgb2JqLnggc3RhcnRzIGF0IDAgYW5kIHRoZW4gd2UgZG8gdGwuc2V0KG9iaiwge3g6MTAwfSkudG8ob2JqLCAxLCB7eDoyMDB9KSBhbmQgdGhlbiBsYXRlciB3ZSB0bC5yZXZlcnNlKCkuLi50aGUgZ29hbCBpcyB0byBoYXZlIG9iai54IHJldmVydCB0byAwLiBJZiB0aGUgcGxheWhlYWQgaGFwcGVucyB0byBsYW5kIG9uIGV4YWN0bHkgMCwgd2l0aG91dCB0aGlzIGNodW5rIG9mIGNvZGUsIGl0J2QgY29tcGxldGUgdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVuZGVyaW5nIHF1ZXVlIChub3QgZ29vZCkuXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA9IDA7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgKGNvdWxkIGNhdXNlIHByb2JsZW1zIGVzcGVjaWFsbHkgd2l0aCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lKVxuXHRcdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lIHx8ICF0aGlzLl9maXJzdCkgJiYgIWZvcmNlICYmICFpbnRlcm5hbEZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgdGhlIHRpbWVsaW5lIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgaXQgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdGltZWxpbmUgYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUsIGZvciBleGFtcGxlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldlRpbWUgPT09IDApIGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RpbWUgIT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy52YXJzLm9uU3RhcnQuYXBwbHkodGhpcy52YXJzLm9uU3RhcnRTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25TdGFydFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90aW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gdGhpcy5fdGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmdcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0VGltZSB8fCBwcmV2VGltZVNjYWxlICE9PSB0aGlzLl90aW1lU2NhbGUpIGlmICh0aGlzLl90aW1lID09PSAwIHx8IHRvdGFsRHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpKSB7IC8vaWYgb25lIG9mIHRoZSB0d2VlbnMgdGhhdCB3YXMgcmVuZGVyZWQgYWx0ZXJlZCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIChsaWtlIGlmIGFuIG9uQ29tcGxldGUgcmV2ZXJzZWQgdGhlIHRpbWVsaW5lKSwgaXQgcHJvYmFibHkgaXNuJ3QgY29tcGxldGUuIElmIGl0IGlzLCBkb24ndCB3b3JyeSwgYmVjYXVzZSB3aGF0ZXZlciBjYWxsIGFsdGVyZWQgdGhlIHN0YXJ0VGltZSB3b3VsZCBjb21wbGV0ZSBpZiBpdCB3YXMgbmVjZXNzYXJ5IGF0IHRoZSBuZXcgdGltZS4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHRoZSB0aW1lU2NhbGUgcHJvcGVydHkuIEFsc28gY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25Db21wbGV0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMudmFyc1tjYWxsYmFja10uYXBwbHkodGhpcy52YXJzW2NhbGxiYWNrICsgXCJTY29wZVwiXSB8fCB0aGlzLCB0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlBhcmFtc1wiXSB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5faGFzUGF1c2VkQ2hpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fcGF1c2VkIHx8ICgodHdlZW4gaW5zdGFuY2VvZiBUaW1lbGluZUxpdGUpICYmIHR3ZWVuLl9oYXNQYXVzZWRDaGlsZCgpKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAtOTk5OTk5OTk5OTtcblx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGNudCA9IDA7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0Ly9kbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUpIHtcblx0XHRcdFx0XHRpZiAodHdlZW5zICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRpbWVsaW5lcyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChuZXN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQodHdlZW4uZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcblx0XHRcdFx0XHRcdGNudCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbih0YXJnZXQsIG5lc3RlZCkge1xuXHRcdFx0dmFyIGRpc2FibGVkID0gdGhpcy5fZ2MsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0dHdlZW5zLCBpO1xuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgdHJ1ZSk7IC8vZ2V0VHdlZW5zT2YoKSBmaWx0ZXJzIG91dCBkaXNhYmxlZCB0d2VlbnMsIGFuZCB3ZSBoYXZlIHRvIG1hcmsgdGhlbSBhcyBfZ2MgPSB0cnVlIHdoZW4gdGhlIHRpbWVsaW5lIGNvbXBsZXRlcyBpbiBvcmRlciB0byBhbGxvdyBjbGVhbiBnYXJiYWdlIGNvbGxlY3Rpb24sIHNvIHRlbXBvcmFyaWx5IHJlLWVuYWJsZSB0aGUgdGltZWxpbmUgaGVyZS5cblx0XHRcdH1cblx0XHRcdHR3ZWVucyA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQpO1xuXHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS50aW1lbGluZSA9PT0gdGhpcyB8fCAobmVzdGVkICYmIHRoaXMuX2NvbnRhaW5zKHR3ZWVuc1tpXSkpKSB7XG5cdFx0XHRcdFx0YVtjbnQrK10gPSB0d2VlbnNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLnJlY2VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlY2VudDtcblx0XHR9O1xuXG5cdFx0cC5fY29udGFpbnMgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdFx0dmFyIHRsID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwpIHtcblx0XHRcdFx0aWYgKHRsID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGwgPSB0bC50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdGlnbm9yZUJlZm9yZVRpbWUgPSBpZ25vcmVCZWZvcmVUaW1lIHx8IDA7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bGFiZWxzID0gdGhpcy5fbGFiZWxzLFxuXHRcdFx0XHRwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fc3RhcnRUaW1lICs9IGFtb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFkanVzdExhYmVscykge1xuXHRcdFx0XHRmb3IgKHAgaW4gbGFiZWxzKSB7XG5cdFx0XHRcdFx0aWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0XHRsYWJlbHNbcF0gKz0gYW1vdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdGlmICghdmFycyAmJiAhdGFyZ2V0KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHdlZW5zID0gKCF0YXJnZXQpID8gdGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkgOiB0aGlzLmdldFR3ZWVuc09mKHRhcmdldCksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS5fa2lsbCh2YXJzLCB0YXJnZXQpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmNsZWFyID0gZnVuY3Rpb24obGFiZWxzKSB7XG5cdFx0XHR2YXIgdHdlZW5zID0gdGhpcy5nZXRDaGlsZHJlbihmYWxzZSwgdHJ1ZSwgdHJ1ZSksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0dHdlZW5zW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGFiZWxzICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLmludmFsaWRhdGUoKTtcblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTs7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKGVuYWJsZWQgPT09IHRoaXMuX2djKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChlbmFibGVkLCB0cnVlKTtcblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gdHJ1ZTtcblx0XHRcdHZhciB2YWwgPSBBbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTsgLy9qdXN0IHRyaWdnZXJzIHJlY2FsY3VsYXRpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5kdXJhdGlvbigpICE9PSAwICYmIHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudGltZVNjYWxlKHRoaXMuX2R1cmF0aW9uIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dmFyIG1heCA9IDAsXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3QsXG5cdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSA5OTk5OTk5OTk5OTksXG5cdFx0XHRcdFx0XHRwcmV2LCBlbmQ7XG5cdFx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRwcmV2ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fZGlydHkpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4udG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSB0d2VlbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+IHByZXZTdGFydCAmJiB0aGlzLl9zb3J0Q2hpbGRyZW4gJiYgIXR3ZWVuLl9wYXVzZWQpIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgdHdlZW5zIHNoaWZ0ZWQgb3V0IG9mIG9yZGVyLCBpdCBuZWVkcyB0byBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZVxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCAwICYmICF0d2Vlbi5fcGF1c2VkKSB7IC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG5cdFx0XHRcdFx0XHRcdG1heCAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgKz0gdHdlZW4uX3N0YXJ0VGltZSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLnNoaWZ0Q2hpbGRyZW4oLXR3ZWVuLl9zdGFydFRpbWUsIGZhbHNlLCAtOTk5OTk5OTk5OSk7XG5cdFx0XHRcdFx0XHRcdHByZXZTdGFydCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbmQgPSB0d2Vlbi5fc3RhcnRUaW1lICsgKHR3ZWVuLl90b3RhbER1cmF0aW9uIC8gdHdlZW4uX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRpZiAoZW5kID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IGVuZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR3ZWVuID0gcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gbWF4O1xuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy50b3RhbER1cmF0aW9uKCkgIT09IDApIGlmICh2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRpbWVTY2FsZSh0aGlzLl90b3RhbER1cmF0aW9uIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghdmFsdWUpIHsgLy9pZiB0aGVyZSdzIGEgcGF1c2UgZGlyZWN0bHkgYXQgdGhlIHNwb3QgZnJvbSB3aGVyZSB3ZSdyZSB1bnBhdXNpbmcsIHNraXAgaXQuXG5cdFx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA9PT0gdGltZSAmJiB0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIikge1xuXHRcdFx0XHRcdFx0dHdlZW4uX3Jhd1ByZXZUaW1lID0gMDsgLy9yZW1lbWJlciwgX3Jhd1ByZXZUaW1lIGlzIGhvdyB6ZXJvLWR1cmF0aW9uIHR3ZWVucy9jYWxsYmFja3Mgc2Vuc2UgZGlyZWN0aW9uYWxpdHkgYW5kIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmaXJlLiBJZiBfcmF3UHJldlRpbWUgaXMgdGhlIHNhbWUgYXMgX3N0YXJ0VGltZSBvbiB0aGUgbmV4dCByZW5kZXIsIGl0IHdvbid0IGZpcmUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHRwLnVzZXNGcmFtZXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGwgPT09IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lKTtcblx0XHR9O1xuXG5cdFx0cC5yYXdUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkID8gdGhpcy5fdG90YWxUaW1lIDogKHRoaXMuX3RpbWVsaW5lLnJhd1RpbWUoKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZUxpdGU7XG5cblx0fSwgdHJ1ZSk7XG5cdFxuXG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaW1lbGluZU1heFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTWF4XCIsIFtcIlRpbWVsaW5lTGl0ZVwiLFwiVHdlZW5MaXRlXCIsXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oVGltZWxpbmVMaXRlLCBUd2VlbkxpdGUsIEVhc2UpIHtcblxuXHRcdHZhciBUaW1lbGluZU1heCA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0VGltZWxpbmVMaXRlLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfZWFzZU5vbmUgPSBuZXcgRWFzZShudWxsLCBudWxsLCAxLCAwKSxcblx0XHRcdHAgPSBUaW1lbGluZU1heC5wcm90b3R5cGUgPSBuZXcgVGltZWxpbmVMaXRlKCk7XG5cblx0XHRwLmNvbnN0cnVjdG9yID0gVGltZWxpbmVNYXg7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0VGltZWxpbmVNYXgudmVyc2lvbiA9IFwiMS4xNi4xXCI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVGltZWxpbmVMaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblxuXHRcdHAuYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgcG9zaXRpb24sIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUNhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBvc2l0aW9uKSB7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHBvc2l0aW9uID09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9raWxsKG51bGwsIGNhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgYSA9IHRoaXMuZ2V0VHdlZW5zT2YoY2FsbGJhY2ssIGZhbHNlKSxcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldLl9zdGFydFRpbWUgPT09IHRpbWUpIHtcblx0XHRcdFx0XHRcdFx0YVtpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlUGF1c2UgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlQ2FsbGJhY2soVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMucGF1c2VDYWxsYmFjaywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnR3ZWVuVG8gPSBmdW5jdGlvbihwb3NpdGlvbiwgdmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHR2YXIgY29weSA9IHtlYXNlOl9lYXNlTm9uZSwgdXNlRnJhbWVzOnRoaXMudXNlc0ZyYW1lcygpLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2V9LFxuXHRcdFx0XHRkdXJhdGlvbiwgcCwgdDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0Y29weS50aW1lID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRkdXJhdGlvbiA9IChNYXRoLmFicyhOdW1iZXIoY29weS50aW1lKSAtIHRoaXMuX3RpbWUpIC8gdGhpcy5fdGltZVNjYWxlKSB8fCAwLjAwMTtcblx0XHRcdHQgPSBuZXcgVHdlZW5MaXRlKHRoaXMsIGR1cmF0aW9uLCBjb3B5KTtcblx0XHRcdGNvcHkub25TdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0LnRhcmdldC5wYXVzZWQodHJ1ZSk7XG5cdFx0XHRcdGlmICh0LnZhcnMudGltZSAhPT0gdC50YXJnZXQudGltZSgpICYmIGR1cmF0aW9uID09PSB0LmR1cmF0aW9uKCkpIHsgLy9kb24ndCBtYWtlIHRoZSBkdXJhdGlvbiB6ZXJvIC0gaWYgaXQncyBzdXBwb3NlZCB0byBiZSB6ZXJvLCBkb24ndCB3b3JyeSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBpbml0dGluZyB0aGUgdHdlZW4gYW5kIHdpbGwgY29tcGxldGUgaW1tZWRpYXRlbHksIGVmZmVjdGl2ZWx5IG1ha2luZyB0aGUgZHVyYXRpb24gemVybyBhbnl3YXkuIElmIHdlIG1ha2UgZHVyYXRpb24gemVybywgdGhlIHR3ZWVuIHdvbid0IHJ1biBhdCBhbGwuXG5cdFx0XHRcdFx0dC5kdXJhdGlvbiggTWF0aC5hYnMoIHQudmFycy50aW1lIC0gdC50YXJnZXQudGltZSgpKSAvIHQudGFyZ2V0Ll90aW1lU2NhbGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycy5vblN0YXJ0KSB7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuXHRcdFx0XHRcdHZhcnMub25TdGFydC5hcHBseSh2YXJzLm9uU3RhcnRTY29wZSB8fCB0LCB2YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fTtcblxuXHRcdHAudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbihmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0ZnJvbVBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChmcm9tUG9zaXRpb24pO1xuXHRcdFx0dmFycy5zdGFydEF0ID0ge29uQ29tcGxldGU6dGhpcy5zZWVrLCBvbkNvbXBsZXRlUGFyYW1zOltmcm9tUG9zaXRpb25dLCBvbkNvbXBsZXRlU2NvcGU6dGhpc307XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpO1xuXHRcdFx0dmFyIHQgPSB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgdmFycyk7XG5cdFx0XHRyZXR1cm4gdC5kdXJhdGlvbigoTWF0aC5hYnMoIHQudmFycy50aW1lIC0gZnJvbVBvc2l0aW9uKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDEpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2UsIGN5Y2xlRHVyYXRpb247XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1cikge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gdGhpcy5fcmVwZWF0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9ICEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICh0aW1lID09PSAwIHx8IHByZXZSYXdQcmV2VGltZSA8IDAgfHwgcHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSAmJiB0aGlzLl9maXJzdCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHR0aW1lID0gZHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy4gV2UgY2Fubm90IGRvIGxlc3MgdGhlbiAwLjAwMDEgYmVjYXVzZSB0aGUgc2FtZSBpc3N1ZSBjYW4gb2NjdXIgd2hlbiB0aGUgZHVyYXRpb24gaXMgZXh0cmVtZWx5IGxhcmdlIGxpa2UgOTk5OTk5OTk5OTk5IGluIHdoaWNoIGNhc2UgYWRkaW5nIDAuMDAwMDAwMDEsIGZvciBleGFtcGxlLCBjYXVzZXMgaXQgdG8gYWN0IGxpa2Ugbm90aGluZyB3YXMgYWRkZWQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1ciA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgIT09IF90aW55TnVtICYmIChwcmV2UmF3UHJldlRpbWUgPiAwIHx8ICh0aW1lIDwgMCAmJiBwcmV2UmF3UHJldlRpbWUgPj0gMCkpICYmICF0aGlzLl9sb2NrZWQpKSB7IC8vZWRnZSBjYXNlIGZvciBjaGVja2luZyB0aW1lIDwgMCAmJiBwcmV2UmF3UHJldlRpbWUgPj0gMDogYSB6ZXJvLWR1cmF0aW9uIGZyb21UbygpIHR3ZWVuIGluc2lkZSBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgKHllYWgsIHZlcnkgcmFyZSlcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCAmJiB0aGlzLl9maXJzdCkgeyAvL3doZW4gZ29pbmcgYmFjayBiZXlvbmQgdGhlIHN0YXJ0LCBmb3JjZSBhIHJlbmRlciBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIHRoYXQgc2l0IGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyByZW5kZXIgdGhlaXIgc3RhcnQgdmFsdWVzIHByb3Blcmx5LiBPdGhlcndpc2UsIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBsYW5kcyBleGFjdGx5IGF0IHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUsIGFuZCB0aGVuIG1vdmVzIGJhY2t3YXJkcywgdGhlIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSBiZWdpbm5pbmcgd291bGQgc3RpbGwgYmUgYXQgdGhlaXIgZW5kIHN0YXRlLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IChkdXIgfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwICYmIGlzQ29tcGxldGUpIHsgLy9pZiB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSB0aW1lbGluZSBhbmQgdGhlIHBsYXloZWFkIGxhbmRzIEVYQUNUTFkgYXQgdGltZSAwLCB0aGF0IHR3ZWVuIHdpbGwgY29ycmVjdGx5IHJlbmRlciBpdHMgZW5kIHZhbHVlcywgYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgdGltZWxpbmUgYWxpdmUgZm9yIG9uZSBtb3JlIHJlbmRlciBzbyB0aGF0IHRoZSBiZWdpbm5pbmcgdmFsdWVzIHJlbmRlciBwcm9wZXJseSBhcyB0aGUgcGFyZW50J3MgcGxheWhlYWQga2VlcHMgbW92aW5nIGJleW9uZCB0aGUgYmVnaW5pbmcuIEltYWdpbmUgb2JqLnggc3RhcnRzIGF0IDAgYW5kIHRoZW4gd2UgZG8gdGwuc2V0KG9iaiwge3g6MTAwfSkudG8ob2JqLCAxLCB7eDoyMDB9KSBhbmQgdGhlbiBsYXRlciB3ZSB0bC5yZXZlcnNlKCkuLi50aGUgZ29hbCBpcyB0byBoYXZlIG9iai54IHJldmVydCB0byAwLiBJZiB0aGUgcGxheWhlYWQgaGFwcGVucyB0byBsYW5kIG9uIGV4YWN0bHkgMCwgd2l0aG91dCB0aGlzIGNodW5rIG9mIGNvZGUsIGl0J2QgY29tcGxldGUgdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVuZGVyaW5nIHF1ZXVlIChub3QgZ29vZCkuXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA9IDA7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgKGNvdWxkIGNhdXNlIHByb2JsZW1zIGVzcGVjaWFsbHkgd2l0aCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lKVxuXHRcdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkdXIgPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lIDwgMCkgeyAvL3dpdGhvdXQgdGhpcywgemVyby1kdXJhdGlvbiByZXBlYXRpbmcgdGltZWxpbmVzIChsaWtlIHdpdGggYSBzaW1wbGUgY2FsbGJhY2sgbmVzdGVkIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBhbmQgYSByZXBlYXREZWxheSkgd291bGRuJ3QgcmVuZGVyIHRoZSBmaXJzdCB0aW1lIHRocm91Z2guXG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aW1lO1xuXHRcdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0XHRcdGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gKHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pID4+IDA7IC8vb3JpZ2luYWxseSBfdG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbiBidXQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIGNhdXNlZCBwcm9ibGVtcywgc28gSSBub3JtYWxpemVkIGl0LiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgaXQgZ2V0cyByZXBvcnRlZCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gMCkgaWYgKHRoaXMuX2N5Y2xlID09PSB0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lIC0gKHRoaXMuX2N5Y2xlICogY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXIgLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiBkdXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHRcdFx0dGltZSA9IGR1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0Lypcblx0XHRcdFx0bWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcblx0XHRcdFx0YSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcblx0XHRcdFx0d291bGQgZ2V0IHRyYW5zYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcblx0XHRcdFx0Y291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG5cdFx0XHRcdHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3Rcblx0XHRcdFx0ZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmVNYXggd29yay5cblx0XHRcdFx0Ki9cblx0XHRcdFx0dmFyIGJhY2t3YXJkcyA9ICh0aGlzLl95b3lvICYmIChwcmV2Q3ljbGUgJiAxKSAhPT0gMCksXG5cdFx0XHRcdFx0d3JhcCA9IChiYWNrd2FyZHMgPT09ICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSksXG5cdFx0XHRcdFx0cmVjVG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLFxuXHRcdFx0XHRcdHJlY0N5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdFx0cmVjUmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0XHRyZWNUaW1lID0gdGhpcy5fdGltZTtcblxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSBwcmV2Q3ljbGUgKiBkdXI7XG5cdFx0XHRcdGlmICh0aGlzLl9jeWNsZSA8IHByZXZDeWNsZSkge1xuXHRcdFx0XHRcdGJhY2t3YXJkcyA9ICFiYWNrd2FyZHM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lICs9IGR1cjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcHJldlRpbWU7IC8vdGVtcG9yYXJpbHkgcmV2ZXJ0IF90aW1lIHNvIHRoYXQgcmVuZGVyKCkgcmVuZGVycyB0aGUgY2hpbGRyZW4gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdpdGhvdXQgdGhpcywgdHdlZW5zIHdvbid0IHJld2luZCBjb3JyZWN0bHkuIFdlIGNvdWxkIGFyaGljdGVjdCB0aGluZ3MgaW4gYSBcImNsZWFuZXJcIiB3YXkgYnkgc3BsaXR0aW5nIG91dCB0aGUgcmVuZGVyaW5nIHF1ZXVlIGludG8gYSBzZXBhcmF0ZSBtZXRob2QgYnV0IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBrZXB0IGl0IGFsbCBpbnNpZGUgdGhpcyBtZXRob2QuXG5cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAoZHVyID09PSAwKSA/IHByZXZSYXdQcmV2VGltZSAtIDAuMDAwMSA6IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IHRydWU7IC8vcHJldmVudHMgY2hhbmdlcyB0byB0b3RhbFRpbWUgYW5kIHNraXBzIHJlcGVhdC95b3lvIGJlaGF2aW9yIHdoZW4gd2UgcmVjdXJzaXZlbHkgY2FsbCByZW5kZXIoKVxuXHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gMCA6IGR1cjtcblx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHN1cHByZXNzRXZlbnRzLCAoZHVyID09PSAwKSk7XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICghdGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRpZiAodGhpcy52YXJzLm9uUmVwZWF0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZhcnMub25SZXBlYXQuYXBwbHkodGhpcy52YXJzLm9uUmVwZWF0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uUmVwZWF0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHdyYXApIHtcblx0XHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gZHVyICsgMC4wMDAxIDogLTAuMDAwMTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaWYgdGhlIHJlbmRlcigpIHRyaWdnZXJlZCBjYWxsYmFjayB0aGF0IHBhdXNlZCB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgYWJvcnQgKHZlcnkgcmFyZSwgYnV0IHBvc3NpYmxlKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcmVjVGltZTtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcmVjVG90YWxUaW1lO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHJlY0N5Y2xlO1xuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJlY1Jhd1ByZXZUaW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lIHx8ICF0aGlzLl9maXJzdCkgJiYgIWZvcmNlICYmICFpbnRlcm5hbEZvcmNlKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RvdGFsVGltZSAhPT0gcHJldlRvdGFsVGltZSAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgdGhlIHRpbWVsaW5lIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgaXQgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdGltZWxpbmUgYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUsIGZvciBleGFtcGxlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldlRvdGFsVGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMudmFycy5vblN0YXJ0LmFwcGx5KHRoaXMudmFycy5vblN0YXJ0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZ1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHRoaXMuX3RpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmdcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2xvY2tlZCkgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzW2NhbGxiYWNrXS5hcHBseSh0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlNjb3BlXCJdIHx8IHRoaXMsIHRoaXMudmFyc1tjYWxsYmFjayArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmdldEFjdGl2ZSA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmIChuZXN0ZWQgPT0gbnVsbCkge1xuXHRcdFx0XHRuZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdFx0XHRcdHR3ZWVucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZWxpbmVzID09IG51bGwpIHtcblx0XHRcdFx0dGltZWxpbmVzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRhbGwgPSB0aGlzLmdldENoaWxkcmVuKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRsID0gYWxsLmxlbmd0aCxcblx0XHRcdFx0aSwgdHdlZW47XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHR3ZWVuID0gYWxsW2ldO1xuXHRcdFx0XHRpZiAodHdlZW4uaXNBY3RpdmUoKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblxuXHRcdHAuZ2V0TGFiZWxBZnRlciA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICghdGltZSkgaWYgKHRpbWUgIT09IDApIHsgLy9mYXN0ZXIgdGhhbiBpc05hbigpXG5cdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxcblx0XHRcdFx0bCA9IGxhYmVscy5sZW5ndGgsXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA+IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsQmVmb3JlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0aWYgKHRpbWUgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGkgPSBsYWJlbHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA8IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsc0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwO1xuXHRcdFx0Zm9yIChwIGluIHRoaXMuX2xhYmVscykge1xuXHRcdFx0XHRhW2NudCsrXSA9IHt0aW1lOnRoaXMuX2xhYmVsc1twXSwgbmFtZTpwfTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLGIpIHtcblx0XHRcdFx0cmV0dXJuIGEudGltZSAtIGIudGltZTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICgodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0VGltZWxpbmVMaXRlLnByb3RvdHlwZS50b3RhbER1cmF0aW9uLmNhbGwodGhpcyk7IC8vanVzdCBmb3JjZXMgcmVmcmVzaFxuXHRcdFx0XHRcdC8vSW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlcy5cblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IHRoaXMgOiB0aGlzLmR1cmF0aW9uKCAodmFsdWUgLSAodGhpcy5fcmVwZWF0ICogdGhpcy5fcmVwZWF0RGVsYXkpKSAvICh0aGlzLl9yZXBlYXQgKyAxKSApO1xuXHRcdH07XG5cblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSA9ICh0aGlzLl9kdXJhdGlvbiAtIHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSArPSB0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmVwZWF0RGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC55b3lvID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5feW95bztcblx0XHRcdH1cblx0XHRcdHRoaXMuX3lveW8gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxCZWZvcmUodGhpcy5fdGltZSArIDAuMDAwMDAwMDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZU1heDtcblxuXHR9LCB0cnVlKTtcblx0XG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQmV6aWVyUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0KGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0XHRcdF9yMSA9IFtdLFxuXHRcdFx0X3IyID0gW10sXG5cdFx0XHRfcjMgPSBbXSxcblx0XHRcdF9jb3JQcm9wcyA9IHt9LFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdFNlZ21lbnQgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdHRoaXMuYSA9IGE7XG5cdFx0XHRcdHRoaXMuYiA9IGI7XG5cdFx0XHRcdHRoaXMuYyA9IGM7XG5cdFx0XHRcdHRoaXMuZCA9IGQ7XG5cdFx0XHRcdHRoaXMuZGEgPSBkIC0gYTtcblx0XHRcdFx0dGhpcy5jYSA9IGMgLSBhO1xuXHRcdFx0XHR0aGlzLmJhID0gYiAtIGE7XG5cdFx0XHR9LFxuXHRcdFx0X2NvcnJlbGF0ZSA9IFwiLHgseSx6LGxlZnQsdG9wLHJpZ2h0LGJvdHRvbSxtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20scGFkZGluZ0xlZnQscGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxiYWNrZ3JvdW5kUG9zaXRpb24sYmFja2dyb3VuZFBvc2l0aW9uX3ksXCIsXG5cdFx0XHRjdWJpY1RvUXVhZHJhdGljID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHR2YXIgcTEgPSB7YTphfSxcblx0XHRcdFx0XHRxMiA9IHt9LFxuXHRcdFx0XHRcdHEzID0ge30sXG5cdFx0XHRcdFx0cTQgPSB7YzpkfSxcblx0XHRcdFx0XHRtYWIgPSAoYSArIGIpIC8gMixcblx0XHRcdFx0XHRtYmMgPSAoYiArIGMpIC8gMixcblx0XHRcdFx0XHRtY2QgPSAoYyArIGQpIC8gMixcblx0XHRcdFx0XHRtYWJjID0gKG1hYiArIG1iYykgLyAyLFxuXHRcdFx0XHRcdG1iY2QgPSAobWJjICsgbWNkKSAvIDIsXG5cdFx0XHRcdFx0bTggPSAobWJjZCAtIG1hYmMpIC8gODtcblx0XHRcdFx0cTEuYiA9IG1hYiArIChhIC0gbWFiKSAvIDQ7XG5cdFx0XHRcdHEyLmIgPSBtYWJjICsgbTg7XG5cdFx0XHRcdHExLmMgPSBxMi5hID0gKHExLmIgKyBxMi5iKSAvIDI7XG5cdFx0XHRcdHEyLmMgPSBxMy5hID0gKG1hYmMgKyBtYmNkKSAvIDI7XG5cdFx0XHRcdHEzLmIgPSBtYmNkIC0gbTg7XG5cdFx0XHRcdHE0LmIgPSBtY2QgKyAoZCAtIG1jZCkgLyA0O1xuXHRcdFx0XHRxMy5jID0gcTQuYSA9IChxMy5iICsgcTQuYikgLyAyO1xuXHRcdFx0XHRyZXR1cm4gW3ExLCBxMiwgcTMsIHE0XTtcblx0XHRcdH0sXG5cdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKGEsIGN1cnZpbmVzcywgcXVhZCwgYmFzaWMsIGNvcnJlbGF0ZSkge1xuXHRcdFx0XHR2YXIgbCA9IGEubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRpaSA9IDAsXG5cdFx0XHRcdFx0Y3AxID0gYVswXS5hLFxuXHRcdFx0XHRcdGksIHAxLCBwMiwgcDMsIHNlZywgbTEsIG0yLCBtbSwgY3AyLCBxYiwgcjEsIHIyLCB0bDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRcdHAxID0gc2VnLmE7XG5cdFx0XHRcdFx0cDIgPSBzZWcuZDtcblx0XHRcdFx0XHRwMyA9IGFbaWkrMV0uZDtcblxuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHIxID0gX3IxW2ldO1xuXHRcdFx0XHRcdFx0cjIgPSBfcjJbaV07XG5cdFx0XHRcdFx0XHR0bCA9ICgocjIgKyByMSkgKiBjdXJ2aW5lc3MgKiAwLjI1KSAvIChiYXNpYyA/IDAuNSA6IF9yM1tpXSB8fCAwLjUpO1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIChiYXNpYyA/IGN1cnZpbmVzcyAqIDAuNSA6IChyMSAhPT0gMCA/IHRsIC8gcjEgOiAwKSk7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIyICE9PSAwID8gdGwgLyByMiA6IDApKTtcblx0XHRcdFx0XHRcdG1tID0gcDIgLSAobTEgKyAoKChtMiAtIG0xKSAqICgocjEgKiAzIC8gKHIxICsgcjIpKSArIDAuNSkgLyA0KSB8fCAwKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG0xID0gcDIgLSAocDIgLSBwMSkgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogY3VydmluZXNzICogMC41O1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArIG0yKSAvIDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG0xICs9IG1tO1xuXHRcdFx0XHRcdG0yICs9IG1tO1xuXG5cdFx0XHRcdFx0c2VnLmMgPSBjcDIgPSBtMTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZy5iID0gY3AxID0gc2VnLmEgKyAoc2VnLmMgLSBzZWcuYSkgKiAwLjY7IC8vaW5zdGVhZCBvZiBwbGFjaW5nIGIgb24gYSBleGFjdGx5LCB3ZSBtb3ZlIGl0IGlubGluZSB3aXRoIGMgc28gdGhhdCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgYW4gZWFzZSBsaWtlIEJhY2suZWFzZUluIG9yIEVsYXN0aWMuZWFzZUluIHdoaWNoIGdvZXMgQkVZT05EIHRoZSBiZWdpbm5pbmcsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2VnLmRhID0gcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuY2EgPSBjcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBwMTtcblxuXHRcdFx0XHRcdGlmIChxdWFkKSB7XG5cdFx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMocDEsIGNwMSwgY3AyLCBwMik7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHRcdFx0aWkgKz0gNDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWkrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjcDEgPSBtMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWcgPSBhW2lpXTtcblx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdHNlZy5jID0gY3AxICsgKHNlZy5kIC0gY3AxKSAqIDAuNDsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYyBvbiBkIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYiBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGljaCBnb2VzIEJFWU9ORCB0aGUgZW5kLCBpdCB3aWxsIGRvIHNvIHNtb290aGx5LlxuXHRcdFx0XHRzZWcuZGEgPSBzZWcuZCAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuY2EgPSBzZWcuYyAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBzZWcuYTtcblx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMoc2VnLmEsIGNwMSwgc2VnLmMsIHNlZy5kKTtcblx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQW5jaG9ycyA9IGZ1bmN0aW9uKHZhbHVlcywgcCwgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bCwgaSwgcDEsIHAyLCBwMywgdG1wO1xuXHRcdFx0XHRpZiAocHJlcGVuZCkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IFtwcmVwZW5kXS5jb25jYXQodmFsdWVzKTtcblx0XHRcdFx0XHRpID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbaV1bcF0pICkgPT09IFwic3RyaW5nXCIpIGlmICh0bXAuY2hhckF0KDEpID09PSBcIj1cIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbaV1bcF0gPSBwcmVwZW5kW3BdICsgTnVtYmVyKHRtcC5jaGFyQXQoMCkgKyB0bXAuc3Vic3RyKDIpKTsgLy9hY2NvbW1vZGF0ZSByZWxhdGl2ZSB2YWx1ZXMuIERvIGl0IGlubGluZSBpbnN0ZWFkIG9mIGJyZWFraW5nIGl0IG91dCBpbnRvIGEgZnVuY3Rpb24gZm9yIHNwZWVkIHJlYXNvbnNcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAyO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRhWzBdID0gbmV3IFNlZ21lbnQodmFsdWVzWzBdW3BdLCAwLCAwLCB2YWx1ZXNbKGwgPCAtMSkgPyAwIDogMV1bcF0pO1xuXHRcdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRwMSA9IHZhbHVlc1tpXVtwXTtcblx0XHRcdFx0XHRwMiA9IHZhbHVlc1tpKzFdW3BdO1xuXHRcdFx0XHRcdGFbaV0gPSBuZXcgU2VnbWVudChwMSwgMCwgMCwgcDIpO1xuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHAzID0gdmFsdWVzW2krMl1bcF07XG5cdFx0XHRcdFx0XHRfcjFbaV0gPSAoX3IxW2ldIHx8IDApICsgKHAyIC0gcDEpICogKHAyIC0gcDEpO1xuXHRcdFx0XHRcdFx0X3IyW2ldID0gKF9yMltpXSB8fCAwKSArIChwMyAtIHAyKSAqIChwMyAtIHAyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHZhbHVlc1tpXVtwXSwgMCwgMCwgdmFsdWVzW2krMV1bcF0pO1xuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHRiZXppZXJUaHJvdWdoID0gZnVuY3Rpb24odmFsdWVzLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIGNvcnJlbGF0ZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRmaXJzdCA9IHByZXBlbmQgfHwgdmFsdWVzWzBdLFxuXHRcdFx0XHRcdGksIHAsIGEsIGosIHIsIGwsIHNlYW1sZXNzLCBsYXN0O1xuXHRcdFx0XHRjb3JyZWxhdGUgPSAodHlwZW9mKGNvcnJlbGF0ZSkgPT09IFwic3RyaW5nXCIpID8gXCIsXCIrY29ycmVsYXRlK1wiLFwiIDogX2NvcnJlbGF0ZTtcblx0XHRcdFx0aWYgKGN1cnZpbmVzcyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y3VydmluZXNzID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB0aGUgbGFzdCBhbmQgZmlyc3QgdmFsdWVzIGFyZSBpZGVudGljYWwgKHdlbGwsIHdpdGhpbiAwLjA1KS4gSWYgc28sIG1ha2Ugc2VhbWxlc3MgYnkgYXBwZW5kaW5nIHRoZSBzZWNvbmQgZWxlbWVudCB0byB0aGUgdmVyeSBlbmQgb2YgdGhlIHZhbHVlcyBhcnJheSBhbmQgdGhlIDJuZC10by1sYXN0IGVsZW1lbnQgdG8gdGhlIHZlcnkgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhvc2Ugc2VnbWVudHMgbGF0ZXIpXG5cdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdHNlYW1sZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKGZpcnN0W3BdIC0gbGFzdFtwXSkgPiAwLjA1KSB7IC8vYnVpbGQgaW4gYSB0b2xlcmFuY2Ugb2YgKy8tMC4wNSB0byBhY2NvbW1vZGF0ZSByb3VuZGluZyBlcnJvcnMuIEZvciBleGFtcGxlLCBpZiB5b3Ugc2V0IGFuIG9iamVjdCdzIHBvc2l0aW9uIHRvIDQuOTQ1LCBGbGFzaCB3aWxsIG1ha2UgaXQgNC45XG5cdFx0XHRcdFx0XHRcdHNlYW1sZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoKTsgLy9kdXBsaWNhdGUgdGhlIGFycmF5IHRvIGF2b2lkIGNvbnRhbWluYXRpbmcgdGhlIG9yaWdpbmFsIHdoaWNoIHRoZSB1c2VyIG1heSBiZSByZXVzaW5nIGZvciBvdGhlciB0d2VlbnNcblx0XHRcdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy51bnNoaWZ0KHByZXBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2godmFsdWVzWzFdKTtcblx0XHRcdFx0XHRcdHByZXBlbmQgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfcjEubGVuZ3RoID0gX3IyLmxlbmd0aCA9IF9yMy5sZW5ndGggPSAwO1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0X2NvclByb3BzW3BdID0gKGNvcnJlbGF0ZS5pbmRleE9mKFwiLFwiK3ArXCIsXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0b2JqW3BdID0gX3BhcnNlQW5jaG9ycyh2YWx1ZXMsIHAsIF9jb3JQcm9wc1twXSwgcHJlcGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IF9yMS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdF9yMVtpXSA9IE1hdGguc3FydChfcjFbaV0pO1xuXHRcdFx0XHRcdF9yMltpXSA9IE1hdGguc3FydChfcjJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYmFzaWMpIHtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKF9jb3JQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRhID0gb2JqW3Byb3BzW2ldXTtcblx0XHRcdFx0XHRcdFx0bCA9IGEubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdHIgPSBhW2orMV0uZGEgLyBfcjJbal0gKyBhW2pdLmRhIC8gX3IxW2pdO1xuXHRcdFx0XHRcdFx0XHRcdF9yM1tqXSA9IChfcjNbal0gfHwgMCkgKyByICogcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpID0gX3IzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9yM1tpXSA9IE1hdGguc3FydChfcjNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRqID0gcXVhZHJhdGljID8gNCA6IDE7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRhID0gb2JqW3BdO1xuXHRcdFx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzKGEsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgX2NvclByb3BzW3BdKTsgLy90aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IF9wYXJzZUFuY2hvcnMoKSBhbmQgX3NldFNlZ21lbnRSYXRpb3MoKSByYW4gZmlyc3Qgc28gdGhhdCBfcjEsIF9yMiwgYW5kIF9yMyB2YWx1ZXMgYXJlIHBvcHVsYXRlZCBmb3IgYWxsIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKDAsIGopO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoYS5sZW5ndGggLSBqLCBqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VCZXppZXJEYXRhID0gZnVuY3Rpb24odmFsdWVzLCB0eXBlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlIHx8IFwic29mdFwiO1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0aW5jID0gKHR5cGUgPT09IFwiY3ViaWNcIikgPyAzIDogMixcblx0XHRcdFx0XHRzb2Z0ID0gKHR5cGUgPT09IFwic29mdFwiKSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGEsIGIsIGMsIGQsIGN1ciwgaSwgaiwgbCwgcCwgY250LCB0bXA7XG5cdFx0XHRcdGlmIChzb2Z0ICYmIHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlcyA9PSBudWxsIHx8IHZhbHVlcy5sZW5ndGggPCBpbmMgKyAxKSB7IHRocm93IFwiaW52YWxpZCBCZXppZXIgZGF0YVwiOyB9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRvYmpbcF0gPSBjdXIgPSBbXTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdGEgPSAocHJlcGVuZCA9PSBudWxsKSA/IHZhbHVlc1tqXVtwXSA6ICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbal1bcF0pICkgPT09IFwic3RyaW5nXCIgJiYgdG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSkgOiBOdW1iZXIodG1wKTtcblx0XHRcdFx0XHRcdGlmIChzb2Z0KSBpZiAoaiA+IDEpIGlmIChqIDwgbCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IChhICsgY3VyW2NudC0yXSkgLyAyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGwgPSBjbnQgLSBpbmMgKyAxO1xuXHRcdFx0XHRcdGNudCA9IDA7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGogKz0gaW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gY3VyW2pdO1xuXHRcdFx0XHRcdFx0YiA9IGN1cltqKzFdO1xuXHRcdFx0XHRcdFx0YyA9IGN1cltqKzJdO1xuXHRcdFx0XHRcdFx0ZCA9IChpbmMgPT09IDIpID8gMCA6IGN1cltqKzNdO1xuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IHRtcCA9IChpbmMgPT09IDMpID8gbmV3IFNlZ21lbnQoYSwgYiwgYywgZCkgOiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1ci5sZW5ndGggPSBjbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfYWRkQ3ViaWNMZW5ndGhzID0gZnVuY3Rpb24oYSwgc3RlcHMsIHJlc29sdXRpb24pIHtcblx0XHRcdFx0dmFyIGluYyA9IDEgLyByZXNvbHV0aW9uLFxuXHRcdFx0XHRcdGogPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRkLCBkMSwgcywgZGEsIGNhLCBiYSwgcCwgaSwgaW52LCBiZXosIGluZGV4O1xuXHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRiZXogPSBhW2pdO1xuXHRcdFx0XHRcdHMgPSBiZXouYTtcblx0XHRcdFx0XHRkYSA9IGJlei5kIC0gcztcblx0XHRcdFx0XHRjYSA9IGJlei5jIC0gcztcblx0XHRcdFx0XHRiYSA9IGJlei5iIC0gcztcblx0XHRcdFx0XHRkID0gZDEgPSAwO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwID0gaW5jICogaTtcblx0XHRcdFx0XHRcdGludiA9IDEgLSBwO1xuXHRcdFx0XHRcdFx0ZCA9IGQxIC0gKGQxID0gKHAgKiBwICogZGEgKyAzICogaW52ICogKHAgKiBjYSArIGludiAqIGJhKSkgKiBwKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gaiAqIHJlc29sdXRpb24gKyBpIC0gMTtcblx0XHRcdFx0XHRcdHN0ZXBzW2luZGV4XSA9IChzdGVwc1tpbmRleF0gfHwgMCkgKyBkICogZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VMZW5ndGhEYXRhID0gZnVuY3Rpb24ob2JqLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHJlc29sdXRpb24gPSByZXNvbHV0aW9uID4+IDAgfHwgNjtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsZW5ndGhzID0gW10sXG5cdFx0XHRcdFx0ZCA9IDAsXG5cdFx0XHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0XHRcdHRocmVzaG9sZCA9IHJlc29sdXRpb24gLSAxLFxuXHRcdFx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRcdFx0Y3VyTFMgPSBbXSwgLy9jdXJyZW50IGxlbmd0aCBzZWdtZW50cyBhcnJheVxuXHRcdFx0XHRcdHAsIGksIGwsIGluZGV4O1xuXHRcdFx0XHRmb3IgKHAgaW4gb2JqKSB7XG5cdFx0XHRcdFx0X2FkZEN1YmljTGVuZ3RocyhvYmpbcF0sIGEsIHJlc29sdXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGQgKz0gTWF0aC5zcXJ0KGFbaV0pO1xuXHRcdFx0XHRcdGluZGV4ID0gaSAlIHJlc29sdXRpb247XG5cdFx0XHRcdFx0Y3VyTFNbaW5kZXhdID0gZDtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT09IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0dG90YWwgKz0gZDtcblx0XHRcdFx0XHRcdGluZGV4ID0gKGkgLyByZXNvbHV0aW9uKSA+PiAwO1xuXHRcdFx0XHRcdFx0c2VnbWVudHNbaW5kZXhdID0gY3VyTFM7XG5cdFx0XHRcdFx0XHRsZW5ndGhzW2luZGV4XSA9IHRvdGFsO1xuXHRcdFx0XHRcdFx0ZCA9IDA7XG5cdFx0XHRcdFx0XHRjdXJMUyA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2xlbmd0aDp0b3RhbCwgbGVuZ3RoczpsZW5ndGhzLCBzZWdtZW50czpzZWdtZW50c307XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0QmV6aWVyUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdFx0cHJvcE5hbWU6IFwiYmV6aWVyXCIsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRcdHZlcnNpb246IFwiMS4zLjRcIixcblx0XHRcdFx0XHRBUEk6IDIsXG5cdFx0XHRcdFx0Z2xvYmFsOnRydWUsXG5cblx0XHRcdFx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0aWYgKHZhcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdFx0XHR2YXJzID0ge3ZhbHVlczp2YXJzfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2Z1bmMgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX3JvdW5kID0ge307XG5cdFx0XHRcdFx0XHR0aGlzLl9wcm9wcyA9IFtdO1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZVJlcyA9ICh2YXJzLnRpbWVSZXNvbHV0aW9uID09IG51bGwpID8gNiA6IHBhcnNlSW50KHZhcnMudGltZVJlc29sdXRpb24sIDEwKTtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YXJzLnZhbHVlcyB8fCBbXSxcblx0XHRcdFx0XHRcdFx0Zmlyc3QgPSB7fSxcblx0XHRcdFx0XHRcdFx0c2Vjb25kID0gdmFsdWVzWzBdLFxuXHRcdFx0XHRcdFx0XHRhdXRvUm90YXRlID0gdmFycy5hdXRvUm90YXRlIHx8IHR3ZWVuLnZhcnMub3JpZW50VG9CZXppZXIsXG5cdFx0XHRcdFx0XHRcdHAsIGlzRnVuYywgaSwgaiwgcHJlcGVuZDtcblxuXHRcdFx0XHRcdFx0dGhpcy5fYXV0b1JvdGF0ZSA9IGF1dG9Sb3RhdGUgPyAoYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSA/IGF1dG9Sb3RhdGUgOiBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIiwoKGF1dG9Sb3RhdGUgPT09IHRydWUpID8gMCA6IE51bWJlcihhdXRvUm90YXRlKSB8fCAwKV1dIDogbnVsbDtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBzZWNvbmQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aSA9IHRoaXMuX3Byb3BzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fcHJvcHNbaV07XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0aXNGdW5jID0gdGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKTtcblx0XHRcdFx0XHRcdFx0Zmlyc3RbcF0gPSAoIWlzRnVuYykgPyBwYXJzZUZsb2F0KHRhcmdldFtwXSkgOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCk7XG5cdFx0XHRcdFx0XHRcdGlmICghcHJlcGVuZCkgaWYgKGZpcnN0W3BdICE9PSB2YWx1ZXNbMF1bcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRwcmVwZW5kID0gZmlyc3Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2JlemllcnMgPSAodmFycy50eXBlICE9PSBcImN1YmljXCIgJiYgdmFycy50eXBlICE9PSBcInF1YWRyYXRpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJzb2Z0XCIpID8gYmV6aWVyVGhyb3VnaCh2YWx1ZXMsIGlzTmFOKHZhcnMuY3VydmluZXNzKSA/IDEgOiB2YXJzLmN1cnZpbmVzcywgZmFsc2UsICh2YXJzLnR5cGUgPT09IFwidGhydUJhc2ljXCIpLCB2YXJzLmNvcnJlbGF0ZSwgcHJlcGVuZCkgOiBfcGFyc2VCZXppZXJEYXRhKHZhbHVlcywgdmFycy50eXBlLCBmaXJzdCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdDb3VudCA9IHRoaXMuX2JlemllcnNbcF0ubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGQgPSBfcGFyc2VMZW5ndGhEYXRhKHRoaXMuX2JlemllcnMsIHRoaXMuX3RpbWVSZXMpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGggPSBsZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xlbmd0aHMgPSBsZC5sZW5ndGhzO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50cyA9IGxkLnNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IHRoaXMuX2xpID0gdGhpcy5fczEgPSB0aGlzLl9zaSA9IDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2wyID0gdGhpcy5fbGVuZ3Roc1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gdGhpcy5fY3VyU2VnWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9wcmVjID0gMSAvIHRoaXMuX2N1clNlZy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgoYXV0b1JvdGF0ZSA9IHRoaXMuX2F1dG9Sb3RhdGUpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2luaXRpYWxSb3RhdGlvbnMgPSBbXTtcblx0XHRcdFx0XHRcdFx0aWYgKCEoYXV0b1JvdGF0ZVswXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID0gW2F1dG9Sb3RhdGVdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGkgPSBhdXRvUm90YXRlLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IDM7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bal07XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9mdW5jW3BdID0gKHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpID8gdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSA6IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwID0gYXV0b1JvdGF0ZVtpXVsyXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zW2ldID0gdGhpcy5fZnVuY1twXSA/IHRoaXMuX2Z1bmNbcF0uY2FsbCh0aGlzLl90YXJnZXQpIDogdGhpcy5fdGFyZ2V0W3BdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydFJhdGlvID0gdHdlZW4udmFycy5ydW5CYWNrd2FyZHMgPyAxIDogMDsgLy93ZSBkZXRlcm1pbmUgdGhlIHN0YXJ0aW5nIHJhdGlvIHdoZW4gdGhlIHR3ZWVuIGluaXRzIHdoaWNoIGlzIGFsd2F5cyAwIHVubGVzcyB0aGUgdHdlZW4gaGFzIHJ1bkJhY2t3YXJkczp0cnVlIChpbmRpY2F0aW5nIGl0J3MgYSBmcm9tKCkgdHdlZW4pIGluIHdoaWNoIGNhc2UgaXQncyAxLlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vY2FsbGVkIGVhY2ggdGltZSB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkLCBhbmQgdGhlIHJhdGlvIGdldHMgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAodHlwaWNhbGx5IGl0J3MgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBpdCBjYW4gZXhjZWVkIHRob3NlIHdoZW4gdXNpbmcgYW4gZWFzZSBsaWtlIEVsYXN0aWMuZWFzZU91dCBvciBCYWNrLmVhc2VPdXQsIGV0Yy4pXG5cdFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdDb3VudCxcblx0XHRcdFx0XHRcdFx0ZnVuYyA9IHRoaXMuX2Z1bmMsXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldCxcblx0XHRcdFx0XHRcdFx0bm90U3RhcnQgPSAodiAhPT0gdGhpcy5fc3RhcnRSYXRpbyksXG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4LCBpbnYsIGksIHAsIGIsIHQsIHZhbCwgbCwgbGVuZ3RocywgY3VyU2VnO1xuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLl90aW1lUmVzKSB7XG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4ID0gKHYgPCAwKSA/IDAgOiAodiA+PSAxKSA/IHNlZ21lbnRzIC0gMSA6IChzZWdtZW50cyAqIHYpID4+IDA7XG5cdFx0XHRcdFx0XHRcdHQgPSAodiAtIChjdXJJbmRleCAqICgxIC8gc2VnbWVudHMpKSkgKiBzZWdtZW50cztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxlbmd0aHMgPSB0aGlzLl9sZW5ndGhzO1xuXHRcdFx0XHRcdFx0XHRjdXJTZWcgPSB0aGlzLl9jdXJTZWc7XG5cdFx0XHRcdFx0XHRcdHYgKj0gdGhpcy5fbGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRpID0gdGhpcy5fbGk7XG5cdFx0XHRcdFx0XHRcdC8vZmluZCB0aGUgYXBwcm9wcmlhdGUgc2VnbWVudCAoaWYgdGhlIGN1cnJlbnRseSBjYWNoZWQgb25lIGlzbid0IGNvcnJlY3QpXG5cdFx0XHRcdFx0XHRcdGlmICh2ID4gdGhpcy5fbDIgJiYgaSA8IHNlZ21lbnRzIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGwgPSBzZWdtZW50cyAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9sMiA9IGxlbmd0aHNbKytpXSkgPD0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gbGVuZ3Roc1tpLTFdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1sodGhpcy5fczEgPSB0aGlzLl9zaSA9IDApXTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2IDwgdGhpcy5fbDEgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA+IDAgJiYgKHRoaXMuX2wxID0gbGVuZ3Roc1stLWldKSA+PSB2KSB7IH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCAmJiB2IDwgdGhpcy5fbDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IGxlbmd0aHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbGkgPSBpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IGN1clNlZyA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gY3VyU2VnWyh0aGlzLl9zaSA9IGN1clNlZy5sZW5ndGggLSAxKSAtIDFdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbdGhpcy5fc2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0Ly9ub3cgZmluZCB0aGUgYXBwcm9wcmlhdGUgc3ViLXNlZ21lbnQgKHdlIHNwbGl0IGl0IGludG8gdGhlIG51bWJlciBvZiBwaWVjZXMgdGhhdCB3YXMgZGVmaW5lZCBieSBcInByZWNpc2lvblwiIGFuZCBtZWFzdXJlZCBlYWNoIG9uZSlcblx0XHRcdFx0XHRcdFx0diAtPSB0aGlzLl9sMTtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX3NpO1xuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX3MyICYmIGkgPCBjdXJTZWcubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGwgPSBjdXJTZWcubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA8IGwgJiYgKHRoaXMuX3MyID0gY3VyU2VnWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1tpLTFdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NpID0gaTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2IDwgdGhpcy5fczEgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA+IDAgJiYgKHRoaXMuX3MxID0gY3VyU2VnWy0taV0pID49IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCAmJiB2IDwgdGhpcy5fczEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dCA9IChpICsgKHYgLSB0aGlzLl9zMSkgLyAodGhpcy5fczIgLSB0aGlzLl9zMSkpICogdGhpcy5fcHJlYztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGludiA9IDEgLSB0O1xuXG5cdFx0XHRcdFx0XHRpID0gdGhpcy5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9wcm9wc1tpXTtcblx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbcF1bY3VySW5kZXhdO1xuXHRcdFx0XHRcdFx0XHR2YWwgPSAodCAqIHQgKiBiLmRhICsgMyAqIGludiAqICh0ICogYi5jYSArIGludiAqIGIuYmEpKSAqIHQgKyBiLmE7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl9yb3VuZFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoZnVuY1twXSkge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSh2YWwpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSA9IHZhbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXIgPSB0aGlzLl9hdXRvUm90YXRlLFxuXHRcdFx0XHRcdFx0XHRcdGIyLCB4MSwgeTEsIHgyLCB5MiwgYWRkLCBjb252O1xuXHRcdFx0XHRcdFx0XHRpID0gYXIubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRwID0gYXJbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0YWRkID0gYXJbaV1bM10gfHwgMDtcblx0XHRcdFx0XHRcdFx0XHRjb252ID0gKGFyW2ldWzRdID09PSB0cnVlKSA/IDEgOiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdFx0XHRiID0gdGhpcy5fYmV6aWVyc1thcltpXVswXV07XG5cdFx0XHRcdFx0XHRcdFx0YjIgPSB0aGlzLl9iZXppZXJzW2FyW2ldWzFdXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChiICYmIGIyKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHByb3BlcnRpZXMgZ290IG92ZXJ3cml0dGVuLlxuXHRcdFx0XHRcdFx0XHRcdFx0YiA9IGJbY3VySW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YjIgPSBiMltjdXJJbmRleF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdHgxID0gYi5hICsgKGIuYiAtIGIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDIgPSBiLmIgKyAoYi5jIC0gYi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MSArPSAoeDIgLSB4MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDIgKz0gKChiLmMgKyAoYi5kIC0gYi5jKSAqIHQpIC0geDIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0eTEgPSBiMi5hICsgKGIyLmIgLSBiMi5hKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MiA9IGIyLmIgKyAoYjIuYyAtIGIyLmIpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkxICs9ICh5MiAtIHkxKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MiArPSAoKGIyLmMgKyAoYjIuZCAtIGIyLmMpICogdCkgLSB5MikgKiB0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWwgPSBub3RTdGFydCA/IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiBjb252ICsgYWRkIDogdGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRwID0gQmV6aWVyUGx1Z2luLnByb3RvdHlwZTtcblxuXG5cdFx0QmV6aWVyUGx1Z2luLmJlemllclRocm91Z2ggPSBiZXppZXJUaHJvdWdoO1xuXHRcdEJlemllclBsdWdpbi5jdWJpY1RvUXVhZHJhdGljID0gY3ViaWNUb1F1YWRyYXRpYztcblx0XHRCZXppZXJQbHVnaW4uX2F1dG9DU1MgPSB0cnVlOyAvL2luZGljYXRlcyB0aGF0IHRoaXMgcGx1Z2luIGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBcImNzc1wiIG9iamVjdCB1c2luZyB0aGUgYXV0b0NTUyBmZWF0dXJlIG9mIFR3ZWVuTGl0ZVxuXHRcdEJlemllclBsdWdpbi5xdWFkcmF0aWNUb0N1YmljID0gZnVuY3Rpb24oYSwgYiwgYykge1xuXHRcdFx0cmV0dXJuIG5ldyBTZWdtZW50KGEsICgyICogYiArIGEpIC8gMywgKDIgKiBiICsgYykgLyAzLCBjKTtcblx0XHR9O1xuXG5cdFx0QmV6aWVyUGx1Z2luLl9jc3NSZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIENTU1BsdWdpbiA9IF9nbG9iYWxzLkNTU1BsdWdpbjtcblx0XHRcdGlmICghQ1NTUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMsXG5cdFx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHksXG5cdFx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvLFxuXHRcdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2Vlbjtcblx0XHRcdF9pbnRlcm5hbHMuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmV6aWVyXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcHJvcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0ZSA9IHt2YWx1ZXM6ZX07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luID0gbmV3IEJlemllclBsdWdpbigpO1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gZS52YWx1ZXMsXG5cdFx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdHBsdWdpblZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdHYgPSB7fSxcblx0XHRcdFx0XHRpLCBwLCBkYXRhO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0XHRkYXRhID0gX3BhcnNlVG9Qcm94eSh0LCB2YWx1ZXNbaV0sIGNzc3AsIHB0LCBwbHVnaW4sIChsICE9PSBpKSk7XG5cdFx0XHRcdFx0cGx1Z2luVmFsdWVzW2ldID0gZGF0YS5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIGUpIHtcblx0XHRcdFx0XHR2W3BdID0gZVtwXTsgLy9kdXBsaWNhdGUgdGhlIHZhcnMgb2JqZWN0IGJlY2F1c2Ugd2UgbmVlZCB0byBhbHRlciBzb21lIHRoaW5ncyB3aGljaCB3b3VsZCBjYXVzZSBwcm9ibGVtcyBpZiB0aGUgdXNlciBwbGFucyB0byByZXVzZSB0aGUgc2FtZSB2YXJzIG9iamVjdCBmb3IgYW5vdGhlciB0d2Vlbi5cblx0XHRcdFx0fVxuXHRcdFx0XHR2LnZhbHVlcyA9IHBsdWdpblZhbHVlcztcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIFwiYmV6aWVyXCIsIDAsIDAsIGRhdGEucHQsIDIpO1xuXHRcdFx0XHRwdC5kYXRhID0gZGF0YTtcblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRQbHVnaW5SYXRpbztcblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSA9PT0gMCkge1xuXHRcdFx0XHRcdHYuYXV0b1JvdGF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSAmJiAhKHYuYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdGkgPSAodi5hdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIodi5hdXRvUm90YXRlKTtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSAoZGF0YS5lbmQubGVmdCAhPSBudWxsKSA/IFtbXCJsZWZ0XCIsXCJ0b3BcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogKGRhdGEuZW5kLnggIT0gbnVsbCkgPyBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIixpLGZhbHNlXV0gOiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0aWYgKCFjc3NwLl90cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRcdGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhLmF1dG9Sb3RhdGUgPSBjc3NwLl90YXJnZXQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbi5fb25Jbml0VHdlZW4oZGF0YS5wcm94eSwgdiwgY3NzcC5fdHdlZW4pO1xuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9fSk7XG5cdFx0fTtcblxuXHRcdHAuX3JvdW5kUHJvcHMgPSBmdW5jdGlvbihsb29rdXAsIHZhbHVlKSB7XG5cdFx0XHR2YXIgb3AgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0aSA9IG9wLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAobG9va3VwW29wW2ldXSB8fCBsb29rdXAuYmV6aWVyIHx8IGxvb2t1cC5iZXppZXJUaHJvdWdoKSB7XG5cdFx0XHRcdFx0dGhpcy5fcm91bmRbb3BbaV1dID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9wcm9wcyxcblx0XHRcdFx0cCwgaTtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9iZXppZXJzKSB7XG5cdFx0XHRcdGlmIChwIGluIGxvb2t1cCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9iZXppZXJzW3BdO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9mdW5jW3BdO1xuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldID09PSBwKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyLl9raWxsLmNhbGwodGhpcywgbG9va3VwKTtcblx0XHR9O1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDU1NQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJwbHVnaW5zLkNTU1BsdWdpblwiLCBbXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKFR3ZWVuUGx1Z2luLCBUd2VlbkxpdGUpIHtcblxuXHRcdC8qKiBAY29uc3RydWN0b3IgKiovXG5cdFx0dmFyIENTU1BsdWdpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRUd2VlblBsdWdpbi5jYWxsKHRoaXMsIFwiY3NzXCIpO1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGggPSAwO1xuXHRcdFx0XHR0aGlzLnNldFJhdGlvID0gQ1NTUGx1Z2luLnByb3RvdHlwZS5zZXRSYXRpbzsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblx0XHRcdH0sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2hhc1ByaW9yaXR5LCAvL3R1cm5zIHRydWUgd2hlbmV2ZXIgYSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgaXMgY3JlYXRlZCB0aGF0IGhhcyBhIHByaW9yaXR5IG90aGVyIHRoYW4gMC4gVGhpcyBoZWxwcyB1cyBkaXNjZXJuIHdoZXRoZXIgb3Igbm90IHdlIHNob3VsZCBzcGVuZCB0aGUgdGltZSBvcmdhbml6aW5nIHRoZSBsaW5rZWQgbGlzdCBvciBub3QgYWZ0ZXIgYSBDU1NQbHVnaW4ncyBfb25Jbml0VHdlZW4oKSBtZXRob2QgaXMgY2FsbGVkLlxuXHRcdFx0X3N1ZmZpeE1hcCwgLy93ZSBzZXQgdGhpcyBpbiBfb25Jbml0VHdlZW4oKSBlYWNoIHRpbWUgYXMgYSB3YXkgdG8gaGF2ZSBhIHBlcnNpc3RlbnQgdmFyaWFibGUgd2UgY2FuIHVzZSBpbiBvdGhlciBtZXRob2RzIGxpa2UgX3BhcnNlKCkgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyBpdCBhcm91bmQgYXMgYSBwYXJhbWV0ZXIgYW5kIHdlIGtlZXAgX3BhcnNlKCkgZGVjb3VwbGVkIGZyb20gYSBwYXJ0aWN1bGFyIENTU1BsdWdpbiBpbnN0YW5jZVxuXHRcdFx0X2NzLCAvL2NvbXB1dGVkIHN0eWxlICh3ZSBzdG9yZSB0aGlzIGluIGEgc2hhcmVkIHZhcmlhYmxlIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgbWFrZSBtaW5pZmljYXRpb24gdGlnaHRlclxuXHRcdFx0X292ZXJ3cml0ZVByb3BzLCAvL2FsaWFzIHRvIHRoZSBjdXJyZW50bHkgaW5zdGFudGlhdGluZyBDU1NQbHVnaW4ncyBfb3ZlcndyaXRlUHJvcHMgYXJyYXkuIFdlIHVzZSB0aGlzIGNsb3N1cmUgaW4gb3JkZXIgdG8gYXZvaWQgaGF2aW5nIHRvIHBhc3MgYSByZWZlcmVuY2UgYXJvdW5kIGZyb20gbWV0aG9kIHRvIG1ldGhvZCBhbmQgYWlkIGluIG1pbmlmaWNhdGlvbi5cblx0XHRcdF9zcGVjaWFsUHJvcHMgPSB7fSxcblx0XHRcdHAgPSBDU1NQbHVnaW4ucHJvdG90eXBlID0gbmV3IFR3ZWVuUGx1Z2luKFwiY3NzXCIpO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IENTU1BsdWdpbjtcblx0XHRDU1NQbHVnaW4udmVyc2lvbiA9IFwiMS4xNi4xXCI7XG5cdFx0Q1NTUGx1Z2luLkFQSSA9IDI7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IDA7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZSA9IFwiY29tcGVuc2F0ZWRcIjtcblx0XHRwID0gXCJweFwiOyAvL3dlJ2xsIHJldXNlIHRoZSBcInBcIiB2YXJpYWJsZSB0byBrZWVwIGZpbGUgc2l6ZSBkb3duXG5cdFx0Q1NTUGx1Z2luLnN1ZmZpeE1hcCA9IHt0b3A6cCwgcmlnaHQ6cCwgYm90dG9tOnAsIGxlZnQ6cCwgd2lkdGg6cCwgaGVpZ2h0OnAsIGZvbnRTaXplOnAsIHBhZGRpbmc6cCwgbWFyZ2luOnAsIHBlcnNwZWN0aXZlOnAsIGxpbmVIZWlnaHQ6XCJcIn07XG5cblxuXHRcdHZhciBfbnVtRXhwID0gLyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZCkrL2csXG5cdFx0XHRfcmVsTnVtRXhwID0gLyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZHxcXCs9XFxkfFxcLT1cXGR8XFwrPS5cXGR8XFwtPVxcLlxcZCkrL2csXG5cdFx0XHRfdmFsdWVzRXhwID0gLyg/OlxcKz18XFwtPXxcXC18XFxiKVtcXGRcXC1cXC5dK1thLXpBLVowLTldKig/OiV8XFxiKS9naSwgLy9maW5kcyBhbGwgdGhlIHZhbHVlcyB0aGF0IGJlZ2luIHdpdGggbnVtYmVycyBvciArPSBvciAtPSBhbmQgdGhlbiBhIG51bWJlci4gSW5jbHVkZXMgc3VmZml4ZXMuIFdlIHVzZSB0aGlzIHRvIHNwbGl0IGNvbXBsZXggdmFsdWVzIGFwYXJ0IGxpa2UgXCIxcHggNXB4IDIwcHggcmdiKDI1NSwxMDIsNTEpXCJcblx0XHRcdF9OYU5FeHAgPSAvKD8hWystXT9cXGQqXFwuP1xcZCt8WystXXxlWystXVxcZCspW14wLTldL2csIC8vYWxzbyBhbGxvd3Mgc2NpZW50aWZpYyBub3RhdGlvbiBhbmQgZG9lc24ndCBraWxsIHRoZSBsZWFkaW5nIC0vKyBpbiAtPSBhbmQgKz1cblx0XHRcdF9zdWZmaXhFeHAgPSAvKD86XFxkfFxcLXxcXCt8PXwjfFxcLikqL2csXG5cdFx0XHRfb3BhY2l0eUV4cCA9IC9vcGFjaXR5ICo9ICooW14pXSopL2ksXG5cdFx0XHRfb3BhY2l0eVZhbEV4cCA9IC9vcGFjaXR5OihbXjtdKikvaSxcblx0XHRcdF9hbHBoYUZpbHRlckV4cCA9IC9hbHBoYVxcKG9wYWNpdHkgKj0uKz9cXCkvaSxcblx0XHRcdF9yZ2Joc2xFeHAgPSAvXihyZ2J8aHNsKS8sXG5cdFx0XHRfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG5cdFx0XHRfY2FtZWxFeHAgPSAvLShbYS16XSkvZ2ksXG5cdFx0XHRfdXJsRXhwID0gLyheKD86dXJsXFwoXFxcInx1cmxcXCgpKXwoPzooXFxcIlxcKSkkfFxcKSQpL2dpLCAvL2ZvciBwdWxsaW5nIG91dCB1cmxzIGZyb20gdXJsKC4uLikgb3IgdXJsKFwiLi4uXCIpIHN0cmluZ3MgKHNvbWUgYnJvd3NlcnMgd3JhcCB1cmxzIGluIHF1b3Rlcywgc29tZSBkb24ndCB3aGVuIHJlcG9ydGluZyB0aGluZ3MgbGlrZSBiYWNrZ3JvdW5kSW1hZ2UpXG5cdFx0XHRfY2FtZWxGdW5jID0gZnVuY3Rpb24ocywgZykgeyByZXR1cm4gZy50b1VwcGVyQ2FzZSgpOyB9LFxuXHRcdFx0X2hvcml6RXhwID0gLyg/OkxlZnR8UmlnaHR8V2lkdGgpL2ksXG5cdFx0XHRfaWVHZXRNYXRyaXhFeHAgPSAvKE0xMXxNMTJ8TTIxfE0yMik9W1xcZFxcLVxcLmVdKy9naSxcblx0XHRcdF9pZVNldE1hdHJpeEV4cCA9IC9wcm9naWRcXDpEWEltYWdlVHJhbnNmb3JtXFwuTWljcm9zb2Z0XFwuTWF0cml4XFwoLis/XFwpL2ksXG5cdFx0XHRfY29tbWFzT3V0c2lkZVBhcmVuRXhwID0gLywoPz1bXlxcKV0qKD86XFwofCQpKS9naSwgLy9maW5kcyBhbnkgY29tbWFzIHRoYXQgYXJlIG5vdCB3aXRoaW4gcGFyZW50aGVzaXNcblx0XHRcdF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0XHRcdF9mb3JjZVBUID0ge30sXG5cdFx0XHRfZG9jID0gZG9jdW1lbnQsXG5cdFx0XHRfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXHRcdFx0fSxcblx0XHRcdF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRfdGVtcEltZyA9IF9jcmVhdGVFbGVtZW50KFwiaW1nXCIpLFxuXHRcdFx0X2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzID0ge19zcGVjaWFsUHJvcHM6X3NwZWNpYWxQcm9wc30sIC8vcHJvdmlkZXMgYSBob29rIHRvIGEgZmV3IGludGVybmFsIG1ldGhvZHMgdGhhdCB3ZSBuZWVkIHRvIGFjY2VzcyBmcm9tIGluc2lkZSBvdGhlciBwbHVnaW5zXG5cdFx0XHRfYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXHRcdFx0X2F1dG9Sb3VuZCxcblx0XHRcdF9yZXFTYWZhcmlGaXgsIC8vd2Ugd29uJ3QgYXBwbHkgdGhlIFNhZmFyaSB0cmFuc2Zvcm0gZml4IHVudGlsIHdlIGFjdHVhbGx5IGNvbWUgYWNyb3NzIGEgdHdlZW4gdGhhdCBhZmZlY3RzIGEgdHJhbnNmb3JtIHByb3BlcnR5ICh0byBtYWludGFpbiBiZXN0IHBlcmZvcm1hbmNlKS5cblxuXHRcdFx0X2lzU2FmYXJpLFxuXHRcdFx0X2lzRmlyZWZveCwgLy9GaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyAzRCB0cmFuc2Zvcm1lZCBlbGVtZW50cyB0byByYW5kb21seSBkaXNhcHBlYXIgdW5sZXNzIGEgcmVwYWludCBpcyBmb3JjZWQgYWZ0ZXIgZWFjaCB1cGRhdGUgb24gZWFjaCBlbGVtZW50LlxuXHRcdFx0X2lzU2FmYXJpTFQ2LCAvL1NhZmFyaSAoYW5kIEFuZHJvaWQgNCB3aGljaCB1c2VzIGEgZmxhdm9yIG9mIFNhZmFyaSkgaGFzIGEgYnVnIHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiBwcm9wZXJ0aWVzIGZyb20gcmVuZGVyaW5nIHByb3Blcmx5IGlmIGNoYW5nZWQgb24gdGhlIHNhbWUgZnJhbWUgYXMgYSB0cmFuc2Zvcm0gVU5MRVNTIHdlIHNldCB0aGUgZWxlbWVudCdzIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB0byBoaWRkZW4gKHdlaXJkLCBJIGtub3cpLiBEb2luZyB0aGlzIGZvciBBbmRyb2lkIDMgYW5kIGVhcmxpZXIgc2VlbXMgdG8gYWN0dWFsbHkgY2F1c2Ugb3RoZXIgcHJvYmxlbXMsIHRob3VnaCAoZnVuISlcblx0XHRcdF9pZVZlcnMsXG5cdFx0XHRfc3VwcG9ydHNPcGFjaXR5ID0gKGZ1bmN0aW9uKCkgeyAvL3dlIHNldCBfaXNTYWZhcmksIF9pZVZlcnMsIF9pc0ZpcmVmb3gsIGFuZCBfc3VwcG9ydHNPcGFjaXR5IGFsbCBpbiBvbmUgZnVuY3Rpb24gaGVyZSB0byByZWR1Y2UgZmlsZSBzaXplIHNsaWdodGx5LCBlc3BlY2lhbGx5IGluIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuXHRcdFx0XHR2YXIgaSA9IF9hZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSxcblx0XHRcdFx0XHRhID0gX2NyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdFx0XHRfaXNTYWZhcmkgPSAoX2FnZW50LmluZGV4T2YoXCJTYWZhcmlcIikgIT09IC0xICYmIF9hZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID09PSAtMSAmJiAoaSA9PT0gLTEgfHwgTnVtYmVyKF9hZ2VudC5zdWJzdHIoaSs4LCAxKSkgPiAzKSk7XG5cdFx0XHRcdF9pc1NhZmFyaUxUNiA9IChfaXNTYWZhcmkgJiYgKE51bWJlcihfYWdlbnQuc3Vic3RyKF9hZ2VudC5pbmRleE9mKFwiVmVyc2lvbi9cIikrOCwgMSkpIDwgNikpO1xuXHRcdFx0XHRfaXNGaXJlZm94ID0gKF9hZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRpZiAoKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLykuZXhlYyhfYWdlbnQpIHx8ICgvVHJpZGVudFxcLy4qcnY6KFswLTldezEsfVtcXC4wLTldezAsfSkvKS5leGVjKF9hZ2VudCkpIHtcblx0XHRcdFx0XHRfaWVWZXJzID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweDtvcGFjaXR5Oi41NTtcIjtcblx0XHRcdFx0cmV0dXJuIC9eMC41NS8udGVzdChhLnN0eWxlLm9wYWNpdHkpO1xuXHRcdFx0fSgpKSxcblx0XHRcdF9nZXRJRU9wYWNpdHkgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAoX29wYWNpdHlFeHAudGVzdCggKCh0eXBlb2YodikgPT09IFwic3RyaW5nXCIpID8gdiA6ICh2LmN1cnJlbnRTdHlsZSA/IHYuY3VycmVudFN0eWxlLmZpbHRlciA6IHYuc3R5bGUuZmlsdGVyKSB8fCBcIlwiKSApID8gKCBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKSAvIDEwMCApIDogMSk7XG5cdFx0XHR9LFxuXHRcdFx0X2xvZyA9IGZ1bmN0aW9uKHMpIHsvL2ZvciBsb2dnaW5nIG1lc3NhZ2VzLCBidXQgaW4gYSB3YXkgdGhhdCB3b24ndCB0aHJvdyBlcnJvcnMgaW4gb2xkIHZlcnNpb25zIG9mIElFLlxuXHRcdFx0XHRpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3ByZWZpeENTUyA9IFwiXCIsIC8vdGhlIG5vbi1jYW1lbENhc2UgdmVuZG9yIHByZWZpeCBsaWtlIFwiLW8tXCIsIFwiLW1vei1cIiwgXCItbXMtXCIsIG9yIFwiLXdlYmtpdC1cIlxuXHRcdFx0X3ByZWZpeCA9IFwiXCIsIC8vY2FtZWxDYXNlIHZlbmRvciBwcmVmaXggbGlrZSBcIk9cIiwgXCJtc1wiLCBcIldlYmtpdFwiLCBvciBcIk1velwiLlxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBmZWVkIGluIGEgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUgbGlrZSBcInRyYW5zZm9ybVwiIGFuZCBpdCB3aWxsIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyB2YWxpZCBhcy1pcyBvciBpZiBpdCBuZWVkcyBhIHZlbmRvciBwcmVmaXguIEl0IHJldHVybnMgdGhlIGNvcnJlY3RlZCBjYW1lbENhc2UgcHJvcGVydHkgbmFtZSAoaS5lLiBcIldlYmtpdFRyYW5zZm9ybVwiIG9yIFwiTW96VHJhbnNmb3JtXCIgb3IgXCJ0cmFuc2Zvcm1cIiBvciBudWxsIGlmIG5vIHN1Y2ggcHJvcGVydHkgaXMgZm91bmQsIGxpa2UgaWYgdGhlIGJyb3dzZXIgaXMgSUU4IG9yIGJlZm9yZSwgXCJ0cmFuc2Zvcm1cIiB3b24ndCBiZSBmb3VuZCBhdCBhbGwpXG5cdFx0XHRfY2hlY2tQcm9wUHJlZml4ID0gZnVuY3Rpb24ocCwgZSkge1xuXHRcdFx0XHRlID0gZSB8fCBfdGVtcERpdjtcblx0XHRcdFx0dmFyIHMgPSBlLnN0eWxlLFxuXHRcdFx0XHRcdGEsIGk7XG5cdFx0XHRcdGlmIChzW3BdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpO1xuXHRcdFx0XHRhID0gW1wiT1wiLFwiTW96XCIsXCJtc1wiLFwiTXNcIixcIldlYmtpdFwiXTtcblx0XHRcdFx0aSA9IDU7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSAmJiBzW2FbaV0rcF0gPT09IHVuZGVmaW5lZCkgeyB9XG5cdFx0XHRcdGlmIChpID49IDApIHtcblx0XHRcdFx0XHRfcHJlZml4ID0gKGkgPT09IDMpID8gXCJtc1wiIDogYVtpXTtcblx0XHRcdFx0XHRfcHJlZml4Q1NTID0gXCItXCIgKyBfcHJlZml4LnRvTG93ZXJDYXNlKCkgKyBcIi1cIjtcblx0XHRcdFx0XHRyZXR1cm4gX3ByZWZpeCArIHA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0Q29tcHV0ZWRTdHlsZSA9IF9kb2MuZGVmYXVsdFZpZXcgPyBfZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUgOiBmdW5jdGlvbigpIHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFJldHVybnMgdGhlIGNzcyBzdHlsZSBmb3IgYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQuIEZvciBleGFtcGxlLCB0byBnZXQgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgXCJsZWZ0XCIgY3NzIHZhbHVlIGZvciBhbiBlbGVtZW50IHdpdGggYW4gSUQgb2YgXCJteUVsZW1lbnRcIiwgeW91IGNvdWxkIGRvOlxuXHRcdFx0ICogdmFyIGN1cnJlbnRMZWZ0ID0gQ1NTUGx1Z2luLmdldFN0eWxlKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15RWxlbWVudFwiKSwgXCJsZWZ0XCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudCB3aG9zZSBzdHlsZSBwcm9wZXJ0eSB5b3Ugd2FudCB0byBxdWVyeVxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBvciBcIm1hcmdpblRvcFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QuIFRoaXMganVzdCBwcm92aWRlcyBhIHdheSB0byBzcGVlZCBwcm9jZXNzaW5nIGlmIHlvdSdyZSBnb2luZyB0byBnZXQgc2V2ZXJhbCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGVsZW1lbnQgaW4gcXVpY2sgc3VjY2Vzc2lvbiAtIHlvdSBjYW4gcmV1c2UgdGhlIHJlc3VsdCBvZiB0aGUgZ2V0Q29tcHV0ZWRTdHlsZSgpIGNhbGwuXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjYWxjIElmIHRydWUsIHRoZSB2YWx1ZSB3aWxsIG5vdCBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGVsZW1lbnQncyBcInN0eWxlXCIgcHJvcGVydHkgKGlmIGl0IGV4aXN0cyB0aGVyZSksIGJ1dCBpbnN0ZWFkIHRoZSBnZXRDb21wdXRlZFN0eWxlKCkgcmVzdWx0IHdpbGwgYmUgdXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgdGhlIGJyb3dzZXIgaXRzZWxmIGlzIGludGVycHJldGluZyB0aGUgdmFsdWUuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGRmbHQgRGVmYXVsdCB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCBpbiB0aGUgcGxhY2Ugb2YgbnVsbCwgXCJub25lXCIsIFwiYXV0b1wiIG9yIFwiYXV0byBhdXRvXCIuXG5cdFx0XHQgKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0U3R5bGUgPSBDU1NQbHVnaW4uZ2V0U3R5bGUgPSBmdW5jdGlvbih0LCBwLCBjcywgY2FsYywgZGZsdCkge1xuXHRcdFx0XHR2YXIgcnY7XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgaWYgKHAgPT09IFwib3BhY2l0eVwiKSB7IC8vc2V2ZXJhbCB2ZXJzaW9ucyBvZiBJRSBkb24ndCB1c2UgdGhlIHN0YW5kYXJkIFwib3BhY2l0eVwiIHByb3BlcnR5IC0gdGhleSB1c2UgdGhpbmdzIGxpa2UgZmlsdGVyOmFscGhhKG9wYWNpdHk9NTApLCBzbyB3ZSBwYXJzZSB0aGF0IGhlcmUuXG5cdFx0XHRcdFx0cmV0dXJuIF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjYWxjICYmIHQuc3R5bGVbcF0pIHtcblx0XHRcdFx0XHRydiA9IHQuc3R5bGVbcF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCkpKSB7XG5cdFx0XHRcdFx0cnYgPSBjc1twXSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHApIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0LmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdHJ2ID0gdC5jdXJyZW50U3R5bGVbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChkZmx0ICE9IG51bGwgJiYgKCFydiB8fCBydiA9PT0gXCJub25lXCIgfHwgcnYgPT09IFwiYXV0b1wiIHx8IHJ2ID09PSBcImF1dG8gYXV0b1wiKSkgPyBkZmx0IDogcnY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhc3MgdGhlIHRhcmdldCBlbGVtZW50LCB0aGUgcHJvcGVydHkgbmFtZSwgdGhlIG51bWVyaWMgdmFsdWUsIGFuZCB0aGUgc3VmZml4IChsaWtlIFwiJVwiLCBcImVtXCIsIFwicHhcIiwgZXRjLikgYW5kIGl0IHdpbGwgc3BpdCBiYWNrIHRoZSBlcXVpdmFsZW50IHBpeGVsIG51bWJlci5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIsIFwidG9wXCIsIFwibWFyZ2luTGVmdFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSB2IFZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHNmeCBTdWZmaXggKGxpa2UgXCJweFwiIG9yIFwiJVwiIG9yIFwiZW1cIilcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlY3Vyc2UgSWYgdHJ1ZSwgdGhlIGNhbGwgaXMgYSByZWN1cnNpdmUgb25lLiBJbiBzb21lIGJyb3dzZXJzIChsaWtlIElFNy84KSwgb2NjYXNpb25hbGx5IHRoZSB2YWx1ZSBpc24ndCBhY2N1cmF0ZWx5IHJlcG9ydGVkIGluaXRpYWxseSwgYnV0IGlmIHdlIHJ1biB0aGUgZnVuY3Rpb24gYWdhaW4gaXQgd2lsbCB0YWtlIGVmZmVjdC5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gdmFsdWUgaW4gcGl4ZWxzXG5cdFx0XHQgKi9cblx0XHRcdF9jb252ZXJ0VG9QaXhlbHMgPSBfaW50ZXJuYWxzLmNvbnZlcnRUb1BpeGVscyA9IGZ1bmN0aW9uKHQsIHAsIHYsIHNmeCwgcmVjdXJzZSkge1xuXHRcdFx0XHRpZiAoc2Z4ID09PSBcInB4XCIgfHwgIXNmeCkgeyByZXR1cm4gdjsgfVxuXHRcdFx0XHRpZiAoc2Z4ID09PSBcImF1dG9cIiB8fCAhdikgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHR2YXIgaG9yaXogPSBfaG9yaXpFeHAudGVzdChwKSxcblx0XHRcdFx0XHRub2RlID0gdCxcblx0XHRcdFx0XHRzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuXHRcdFx0XHRcdG5lZyA9ICh2IDwgMCksXG5cdFx0XHRcdFx0cGl4LCBjYWNoZSwgdGltZTtcblx0XHRcdFx0aWYgKG5lZykge1xuXHRcdFx0XHRcdHYgPSAtdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2Z4ID09PSBcIiVcIiAmJiBwLmluZGV4T2YoXCJib3JkZXJcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0cGl4ID0gKHYgLyAxMDApICogKGhvcml6ID8gdC5jbGllbnRXaWR0aCA6IHQuY2xpZW50SGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MCBzb2xpZCByZWQ7cG9zaXRpb246XCIgKyBfZ2V0U3R5bGUodCwgXCJwb3NpdGlvblwiKSArIFwiO2xpbmUtaGVpZ2h0OjA7XCI7XG5cdFx0XHRcdFx0aWYgKHNmeCA9PT0gXCIlXCIgfHwgIW5vZGUuYXBwZW5kQ2hpbGQpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSB0LnBhcmVudE5vZGUgfHwgX2RvYy5ib2R5O1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBub2RlLl9nc0NhY2hlO1xuXHRcdFx0XHRcdFx0dGltZSA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHRcdFx0XHRpZiAoY2FjaGUgJiYgaG9yaXogJiYgY2FjaGUudGltZSA9PT0gdGltZSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogd2UgcmVjb3JkIHRoZSB3aWR0aCBvZiBlbGVtZW50cyBhbG9uZyB3aXRoIHRoZSB0aWNrZXIgZnJhbWUgc28gdGhhdCB3ZSBjYW4gcXVpY2tseSBnZXQgaXQgYWdhaW4gb24gdGhlIHNhbWUgdGljayAoc2VlbXMgcmVsYXRpdmVseSBzYWZlIHRvIGFzc3VtZSBpdCB3b3VsZG4ndCBjaGFuZ2Ugb24gdGhlIHNhbWUgdGljaylcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhY2hlLndpZHRoICogdiAvIDEwMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwiYm9yZGVyTGVmdFdpZHRoXCIgOiBcImJvcmRlclRvcFdpZHRoXCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRcdHBpeCA9IHBhcnNlRmxvYXQoX3RlbXBEaXZbKGhvcml6ID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIildKTtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0XHRpZiAoaG9yaXogJiYgc2Z4ID09PSBcIiVcIiAmJiBDU1NQbHVnaW4uY2FjaGVXaWR0aHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRjYWNoZSA9IG5vZGUuX2dzQ2FjaGUgPSBub2RlLl9nc0NhY2hlIHx8IHt9O1xuXHRcdFx0XHRcdFx0Y2FjaGUudGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0XHRjYWNoZS53aWR0aCA9IHBpeCAvIHYgKiAxMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwaXggPT09IDAgJiYgIXJlY3Vyc2UpIHtcblx0XHRcdFx0XHRcdHBpeCA9IF9jb252ZXJ0VG9QaXhlbHModCwgcCwgdiwgc2Z4LCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5lZyA/IC1waXggOiBwaXg7XG5cdFx0XHR9LFxuXHRcdFx0X2NhbGN1bGF0ZU9mZnNldCA9IF9pbnRlcm5hbHMuY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24odCwgcCwgY3MpIHsgLy9mb3IgZmlndXJpbmcgb3V0IFwidG9wXCIgb3IgXCJsZWZ0XCIgaW4gcHggd2hlbiBpdCdzIFwiYXV0b1wiLiBXZSBuZWVkIHRvIGZhY3RvciBpbiBtYXJnaW4gd2l0aCB0aGUgb2Zmc2V0TGVmdC9vZmZzZXRUb3Bcblx0XHRcdFx0aWYgKF9nZXRTdHlsZSh0LCBcInBvc2l0aW9uXCIsIGNzKSAhPT0gXCJhYnNvbHV0ZVwiKSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdHZhciBkaW0gPSAoKHAgPT09IFwibGVmdFwiKSA/IFwiTGVmdFwiIDogXCJUb3BcIiksXG5cdFx0XHRcdFx0diA9IF9nZXRTdHlsZSh0LCBcIm1hcmdpblwiICsgZGltLCBjcyk7XG5cdFx0XHRcdHJldHVybiB0W1wib2Zmc2V0XCIgKyBkaW1dIC0gKF9jb252ZXJ0VG9QaXhlbHModCwgcCwgcGFyc2VGbG9hdCh2KSwgdi5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIHJldHVybnMgYXQgb2JqZWN0IGNvbnRhaW5pbmcgQUxMIG9mIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGluIGNhbWVsQ2FzZSBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMuXG5cdFx0XHRfZ2V0QWxsU3R5bGVzID0gZnVuY3Rpb24odCwgY3MpIHtcblx0XHRcdFx0dmFyIHMgPSB7fSxcblx0XHRcdFx0XHRpLCB0ciwgcDtcblx0XHRcdFx0aWYgKChjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSkge1xuXHRcdFx0XHRcdGlmICgoaSA9IGNzLmxlbmd0aCkpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdGlmIChwLmluZGV4T2YoXCItdHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcENTUyA9PT0gcCkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW3AucmVwbGFjZShfY2FtZWxFeHAsIF9jYW1lbEZ1bmMpXSA9IGNzLmdldFByb3BlcnR5VmFsdWUocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgeyAvL3NvbWUgYnJvd3NlcnMgYmVoYXZlIGRpZmZlcmVudGx5IC0gY3MubGVuZ3RoIGlzIGFsd2F5cyAwLCBzbyB3ZSBtdXN0IGRvIGEgZm9yLi4uaW4gbG9vcC5cblx0XHRcdFx0XHRcdGZvciAoaSBpbiBjcykge1xuXHRcdFx0XHRcdFx0XHRpZiAoaS5pbmRleE9mKFwiVHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcCA9PT0gaSkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW2ldID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gdC5jdXJyZW50U3R5bGUgfHwgdC5zdHlsZSkpIHtcblx0XHRcdFx0XHRmb3IgKGkgaW4gY3MpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoaSkgPT09IFwic3RyaW5nXCIgJiYgc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHNbaS5yZXBsYWNlKF9jYW1lbEV4cCwgX2NhbWVsRnVuYyldID0gY3NbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkge1xuXHRcdFx0XHRcdHMub3BhY2l0eSA9IF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHIgPSBfZ2V0VHJhbnNmb3JtKHQsIGNzLCBmYWxzZSk7XG5cdFx0XHRcdHMucm90YXRpb24gPSB0ci5yb3RhdGlvbjtcblx0XHRcdFx0cy5za2V3WCA9IHRyLnNrZXdYO1xuXHRcdFx0XHRzLnNjYWxlWCA9IHRyLnNjYWxlWDtcblx0XHRcdFx0cy5zY2FsZVkgPSB0ci5zY2FsZVk7XG5cdFx0XHRcdHMueCA9IHRyLng7XG5cdFx0XHRcdHMueSA9IHRyLnk7XG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdHMueiA9IHRyLno7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblggPSB0ci5yb3RhdGlvblg7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblkgPSB0ci5yb3RhdGlvblk7XG5cdFx0XHRcdFx0cy5zY2FsZVogPSB0ci5zY2FsZVo7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHMuZmlsdGVycykge1xuXHRcdFx0XHRcdGRlbGV0ZSBzLmZpbHRlcnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBhbmFseXplcyB0d28gc3R5bGUgb2JqZWN0cyAoYXMgcmV0dXJuZWQgYnkgX2dldEFsbFN0eWxlcygpKSBhbmQgb25seSBsb29rcyBmb3IgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIHRoYXQgY29udGFpbiB0d2VlbmFibGUgdmFsdWVzIChsaWtlIGEgbnVtYmVyIG9yIGNvbG9yKS4gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIFwiZGlmc1wiIHByb3BlcnR5IHdoaWNoIHJlZmVycyB0byBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRob3NlIGlzb2xhdGVkIHByb3BlcnRpZXMgYW5kIHZhbHVlcyBmb3IgdHdlZW5pbmcsIGFuZCBhIFwiZmlyc3RNUFRcIiBwcm9wZXJ0eSB3aGljaCByZWZlcnMgdG8gdGhlIGZpcnN0IE1pbmlQcm9wVHdlZW4gaW5zdGFuY2UgaW4gYSBsaW5rZWQgbGlzdCB0aGF0IHJlY29yZGVkIGFsbCB0aGUgc3RhcnRpbmcgdmFsdWVzIG9mIHRoZSBkaWZmZXJlbnQgcHJvcGVydGllcyBzbyB0aGF0IHdlIGNhbiByZXZlcnQgdG8gdGhlbSBhdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gLSB3ZSBkb24ndCB3YW50IHRoZSBjYXNjYWRpbmcgdG8gZ2V0IG1lc3NlZCB1cC4gVGhlIGZvcmNlTG9va3VwIHBhcmFtZXRlciBpcyBhbiBvcHRpb25hbCBnZW5lcmljIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgZm9yY2VkIGludG8gdGhlIHJlc3VsdHMgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY2xhc3NOYW1lIHR3ZWVucyB0aGF0IGFyZSBvdmVyd3JpdGluZyBvdGhlcnMgYmVjYXVzZSBpbWFnaW5lIGEgc2NlbmFyaW8gd2hlcmUgYSByb2xsb3Zlci9yb2xsb3V0IGFkZHMvcmVtb3ZlcyBhIGNsYXNzIGFuZCB0aGUgdXNlciBzd2lwZXMgdGhlIG1vdXNlIG92ZXIgdGhlIHRhcmdldCBTVVBFUiBmYXN0LCB0aHVzIG5vdGhpbmcgYWN0dWFsbHkgY2hhbmdlZCB5ZXQgYW5kIHRoZSBzdWJzZXF1ZW50IGNvbXBhcmlzb24gb2YgdGhlIHByb3BlcnRpZXMgd291bGQgaW5kaWNhdGUgdGhleSBtYXRjaCAoZXNwZWNpYWxseSB3aGVuIHB4IHJvdW5kaW5nIGlzIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiksIHRodXMgbm8gdHdlZW5pbmcgaXMgbmVjZXNzYXJ5IGV2ZW4gdGhvdWdoIGl0IFNIT1VMRCB0d2VlbiBhbmQgcmVtb3ZlIHRob3NlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIHR3ZWVuIChvdGhlcndpc2UgdGhlIGlubGluZSBzdHlsZXMgd2lsbCBjb250YW1pbmF0ZSB0aGluZ3MpLiBTZWUgdGhlIGNsYXNzTmFtZSBTcGVjaWFsUHJvcCBjb2RlIGZvciBkZXRhaWxzLlxuXHRcdFx0X2Nzc0RpZiA9IGZ1bmN0aW9uKHQsIHMxLCBzMiwgdmFycywgZm9yY2VMb29rdXApIHtcblx0XHRcdFx0dmFyIGRpZnMgPSB7fSxcblx0XHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdFx0dmFsLCBwLCBtcHQ7XG5cdFx0XHRcdGZvciAocCBpbiBzMikge1xuXHRcdFx0XHRcdGlmIChwICE9PSBcImNzc1RleHRcIikgaWYgKHAgIT09IFwibGVuZ3RoXCIpIGlmIChpc05hTihwKSkgaWYgKHMxW3BdICE9PSAodmFsID0gczJbcF0pIHx8IChmb3JjZUxvb2t1cCAmJiBmb3JjZUxvb2t1cFtwXSkpIGlmIChwLmluZGV4T2YoXCJPcmlnaW5cIikgPT09IC0xKSBpZiAodHlwZW9mKHZhbCkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mKHZhbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdGRpZnNbcF0gPSAodmFsID09PSBcImF1dG9cIiAmJiAocCA9PT0gXCJsZWZ0XCIgfHwgcCA9PT0gXCJ0b3BcIikpID8gX2NhbGN1bGF0ZU9mZnNldCh0LCBwKSA6ICgodmFsID09PSBcIlwiIHx8IHZhbCA9PT0gXCJhdXRvXCIgfHwgdmFsID09PSBcIm5vbmVcIikgJiYgdHlwZW9mKHMxW3BdKSA9PT0gXCJzdHJpbmdcIiAmJiBzMVtwXS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpICE9PSBcIlwiKSA/IDAgOiB2YWw7IC8vaWYgdGhlIGVuZGluZyB2YWx1ZSBpcyBkZWZhdWx0aW5nIChcIlwiIG9yIFwiYXV0b1wiKSwgd2UgY2hlY2sgdGhlIHN0YXJ0aW5nIHZhbHVlIGFuZCBpZiBpdCBjYW4gYmUgcGFyc2VkIGludG8gYSBudW1iZXIgKGEgc3RyaW5nIHdoaWNoIGNvdWxkIGhhdmUgYSBzdWZmaXggdG9vLCBsaWtlIDcwMHB4KSwgdGhlbiB3ZSBzd2FwIGluIDAgZm9yIFwiXCIgb3IgXCJhdXRvXCIgc28gdGhhdCB0aGluZ3MgYWN0dWFsbHkgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAoc3R5bGVbcF0gIT09IHVuZGVmaW5lZCkgeyAvL2ZvciBjbGFzc05hbWUgdHdlZW5zLCB3ZSBtdXN0IHJlbWVtYmVyIHdoaWNoIHByb3BlcnRpZXMgYWxyZWFkeSBleGlzdGVkIGlubGluZSAtIHRoZSBvbmVzIHRoYXQgZGlkbid0IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gdGhlIHR3ZWVuIGlzbid0IGluIHByb2dyZXNzIGJlY2F1c2UgdGhleSB3ZXJlIG9ubHkgaW50cm9kdWNlZCB0byBmYWNpbGl0YXRlIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gY2xhc3Nlcy5cblx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4oc3R5bGUsIHAsIHN0eWxlW3BdLCBtcHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycykge1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7IC8vY29weSBwcm9wZXJ0aWVzIChleGNlcHQgY2xhc3NOYW1lKVxuXHRcdFx0XHRcdFx0aWYgKHAgIT09IFwiY2xhc3NOYW1lXCIpIHtcblx0XHRcdFx0XHRcdFx0ZGlmc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7ZGlmczpkaWZzLCBmaXJzdE1QVDptcHR9O1xuXHRcdFx0fSxcblx0XHRcdF9kaW1lbnNpb25zID0ge3dpZHRoOltcIkxlZnRcIixcIlJpZ2h0XCJdLCBoZWlnaHQ6W1wiVG9wXCIsXCJCb3R0b21cIl19LFxuXHRcdFx0X21hcmdpbnMgPSBbXCJtYXJnaW5MZWZ0XCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luVG9wXCIsXCJtYXJnaW5Cb3R0b21cIl0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgR2V0cyB0aGUgd2lkdGggb3IgaGVpZ2h0IG9mIGFuIGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKFwid2lkdGhcIiBvciBcImhlaWdodFwiKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QgKGlmIG9uZSBleGlzdHMpLiBKdXN0IGEgc3BlZWQgb3B0aW1pemF0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBEaW1lbnNpb24gKGluIHBpeGVscylcblx0XHRcdCAqL1xuXHRcdFx0X2dldERpbWVuc2lvbiA9IGZ1bmN0aW9uKHQsIHAsIGNzKSB7XG5cdFx0XHRcdHZhciB2ID0gcGFyc2VGbG9hdCgocCA9PT0gXCJ3aWR0aFwiKSA/IHQub2Zmc2V0V2lkdGggOiB0Lm9mZnNldEhlaWdodCksXG5cdFx0XHRcdFx0YSA9IF9kaW1lbnNpb25zW3BdLFxuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0Y3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0diAtPSBwYXJzZUZsb2F0KCBfZ2V0U3R5bGUodCwgXCJwYWRkaW5nXCIgKyBhW2ldLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHRcdHYgLT0gcGFyc2VGbG9hdCggX2dldFN0eWxlKHQsIFwiYm9yZGVyXCIgKyBhW2ldICsgXCJXaWR0aFwiLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgUGFyc2VzIHBvc2l0aW9uLXJlbGF0ZWQgY29tcGxleCBzdHJpbmdzIGxpa2UgXCJ0b3AgbGVmdFwiIG9yIFwiNTBweCAxMHB4XCIgb3IgXCI3MCUgMjAlXCIsIGV0Yy4gd2hpY2ggYXJlIHVzZWQgZm9yIHRoaW5ncyBsaWtlIHRyYW5zZm9ybU9yaWdpbiBvciBiYWNrZ3JvdW5kUG9zaXRpb24uIE9wdGlvbmFsbHkgZGVjb3JhdGVzIGEgc3VwcGxpZWQgb2JqZWN0IChyZWNPYmopIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBcIm94XCIgKG9mZnNldFgpLCBcIm95XCIgKG9mZnNldFkpLCBcIm94cFwiIChpZiB0cnVlLCBcIm94XCIgaXMgYSBwZXJjZW50YWdlIG5vdCBhIHBpeGVsIHZhbHVlKSwgYW5kIFwib3h5XCIgKGlmIHRydWUsIFwib3lcIiBpcyBhIHBlcmNlbnRhZ2Ugbm90IGEgcGl4ZWwgdmFsdWUpXG5cdFx0XHRfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uKHYsIHJlY09iaikge1xuXHRcdFx0XHRpZiAodiA9PSBudWxsIHx8IHYgPT09IFwiXCIgfHwgdiA9PT0gXCJhdXRvXCIgfHwgdiA9PT0gXCJhdXRvIGF1dG9cIikgeyAvL25vdGU6IEZpcmVmb3ggdXNlcyBcImF1dG8gYXV0b1wiIGFzIGRlZmF1bHQgd2hlcmVhcyBDaHJvbWUgdXNlcyBcImF1dG9cIi5cblx0XHRcdFx0XHR2ID0gXCIwIDBcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYSA9IHYuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdHggPSAodi5pbmRleE9mKFwibGVmdFwiKSAhPT0gLTEpID8gXCIwJVwiIDogKHYuaW5kZXhPZihcInJpZ2h0XCIpICE9PSAtMSkgPyBcIjEwMCVcIiA6IGFbMF0sXG5cdFx0XHRcdFx0eSA9ICh2LmluZGV4T2YoXCJ0b3BcIikgIT09IC0xKSA/IFwiMCVcIiA6ICh2LmluZGV4T2YoXCJib3R0b21cIikgIT09IC0xKSA/IFwiMTAwJVwiIDogYVsxXTtcblx0XHRcdFx0aWYgKHkgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHkgPSAoeCA9PT0gXCJjZW50ZXJcIikgPyBcIjUwJVwiIDogXCIwXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeSA9PT0gXCJjZW50ZXJcIikge1xuXHRcdFx0XHRcdHkgPSBcIjUwJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4ID09PSBcImNlbnRlclwiIHx8IChpc05hTihwYXJzZUZsb2F0KHgpKSAmJiAoeCArIFwiXCIpLmluZGV4T2YoXCI9XCIpID09PSAtMSkpIHsgLy9yZW1lbWJlciwgdGhlIHVzZXIgY291bGQgZmxpcC1mbG9wIHRoZSB2YWx1ZXMgYW5kIHNheSBcImJvdHRvbSBjZW50ZXJcIiBvciBcImNlbnRlciBib3R0b21cIiwgZXRjLiBcImNlbnRlclwiIGlzIGFtYmlndW91cyBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWQgdG8gZGVzY3JpYmUgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCwgaGVuY2UgdGhlIGlzTmFOKCkuIElmIHRoZXJlJ3MgYW4gXCI9XCIgc2lnbiBpbiB0aGUgdmFsdWUsIGl0J3MgcmVsYXRpdmUuXG5cdFx0XHRcdFx0eCA9IFwiNTAlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0diA9IHggKyBcIiBcIiArIHkgKyAoKGEubGVuZ3RoID4gMikgPyBcIiBcIiArIGFbMl0gOiBcIlwiKTtcblx0XHRcdFx0aWYgKHJlY09iaikge1xuXHRcdFx0XHRcdHJlY09iai5veHAgPSAoeC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veXAgPSAoeS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veHIgPSAoeC5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRyZWNPYmoub3lyID0gKHkuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0cmVjT2JqLm94ID0gcGFyc2VGbG9hdCh4LnJlcGxhY2UoX05hTkV4cCwgXCJcIikpO1xuXHRcdFx0XHRcdHJlY09iai5veSA9IHBhcnNlRmxvYXQoeS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpKTtcblx0XHRcdFx0XHRyZWNPYmoudiA9IHY7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlY09iaiB8fCB2O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUYWtlcyBhbiBlbmRpbmcgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZywgYnV0IGNhbiBiZSBhIG51bWJlcikgYW5kIGEgc3RhcnRpbmcgdmFsdWUgYW5kIHJldHVybnMgdGhlIGNoYW5nZSBiZXR3ZWVuIHRoZSB0d28sIGxvb2tpbmcgZm9yIHJlbGF0aXZlIHZhbHVlIGluZGljYXRvcnMgbGlrZSArPSBhbmQgLT0gYW5kIGl0IGFsc28gaWdub3JlcyBzdWZmaXhlcyAoYnV0IG1ha2Ugc3VyZSB0aGUgZW5kaW5nIHZhbHVlIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIG9yICs9Ly09IGFuZCB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZSBpcyBhIE5VTUJFUiEpXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gZSBFbmQgdmFsdWUgd2hpY2ggaXMgdHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgY291bGQgYmUgYSBudW1iZXJcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBiIEJlZ2lubmluZyB2YWx1ZSB3aGljaCBpcyB0eXBpY2FsbHkgYSBzdHJpbmcgYnV0IGNvdWxkIGJlIGEgbnVtYmVyXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IEFtb3VudCBvZiBjaGFuZ2UgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIChyZWxhdGl2ZSB2YWx1ZXMgdGhhdCBoYXZlIGEgXCIrPVwiIG9yIFwiLT1cIiBhcmUgcmVjb2duaXplZClcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ2hhbmdlID0gZnVuY3Rpb24oZSwgYikge1xuXHRcdFx0XHRyZXR1cm4gKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQoZS5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChlLnN1YnN0cigyKSkgOiBwYXJzZUZsb2F0KGUpIC0gcGFyc2VGbG9hdChiKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVGFrZXMgYSB2YWx1ZSBhbmQgYSBkZWZhdWx0IG51bWJlciwgY2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyByZWxhdGl2ZSwgbnVsbCwgb3IgbnVtZXJpYyBhbmQgc3BpdHMgYmFjayBhIG5vcm1hbGl6ZWQgbnVtYmVyIGFjY29yZGluZ2x5LiBQcmltYXJpbHkgdXNlZCBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgZnVuY3Rpb24uXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSB0byBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gZCBEZWZhdWx0IHZhbHVlICh3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHJlbGF0aXZlIGNhbGN1bGF0aW9ucyBpZiBcIis9XCIgb3IgXCItPVwiIGlzIGZvdW5kIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IFBhcnNlZCB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VWYWwgPSBmdW5jdGlvbih2LCBkKSB7XG5cdFx0XHRcdHJldHVybiAodiA9PSBudWxsKSA/IGQgOiAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHYuc3Vic3RyKDIpKSArIGQgOiBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUcmFuc2xhdGVzIHN0cmluZ3MgbGlrZSBcIjQwZGVnXCIgb3IgXCI0MFwiIG9yIDQwcmFkXCIgb3IgXCIrPTQwZGVnXCIgb3IgXCIyNzBfc2hvcnRcIiBvciBcIi05MF9jd1wiIG9yIFwiKz00NV9jY3dcIiB0byBhIG51bWVyaWMgcmFkaWFuIGFuZ2xlLiBPZiBjb3Vyc2UgYSBzdGFydGluZy9kZWZhdWx0IHZhbHVlIG11c3QgYmUgZmVkIGluIHRvbyBzbyB0aGF0IHJlbGF0aXZlIHZhbHVlcyBjYW4gYmUgY2FsY3VsYXRlZCBwcm9wZXJseS5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSBkIERlZmF1bHQgdmFsdWUgKHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgcmVsYXRpdmUgY2FsY3VsYXRpb25zIGlmIFwiKz1cIiBvciBcIi09XCIgaXMgZm91bmQgaW4gdGhlIGZpcnN0IHBhcmFtZXRlcilcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gcCBwcm9wZXJ0eSBuYW1lIGZvciBkaXJlY3Rpb25hbEVuZCAob3B0aW9uYWwgLSBvbmx5IHVzZWQgd2hlbiB0aGUgcGFyc2VkIHZhbHVlIGlzIGRpcmVjdGlvbmFsIChcIl9zaG9ydFwiLCBcIl9jd1wiLCBvciBcIl9jY3dcIiBzdWZmaXgpLiBXZSBuZWVkIGEgd2F5IHRvIHN0b3JlIHRoZSB1bmNvbXBlbnNhdGVkIHZhbHVlIHNvIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCBpdCB0byBleGFjdGx5IHdoYXQgd2FzIHJlcXVlc3RlZCB3aXRoIG5vIGRpcmVjdGlvbmFsIGNvbXBlbnNhdGlvbikuIFByb3BlcnR5IG5hbWUgd291bGQgYmUgXCJyb3RhdGlvblwiLCBcInJvdGF0aW9uWFwiLCBvciBcInJvdGF0aW9uWVwiXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGRpcmVjdGlvbmFsRW5kIEFuIG9iamVjdCB0aGF0IHdpbGwgc3RvcmUgdGhlIHJhdyBlbmQgdmFsdWVzIGZvciBkaXJlY3Rpb25hbCBhbmdsZXMgKFwiX3Nob3J0XCIsIFwiX2N3XCIsIG9yIFwiX2Njd1wiIHN1ZmZpeCkuIFdlIG5lZWQgYSB3YXkgdG8gc3RvcmUgdGhlIHVuY29tcGVuc2F0ZWQgdmFsdWUgc28gdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IGl0IHRvIGV4YWN0bHkgd2hhdCB3YXMgcmVxdWVzdGVkIHdpdGggbm8gZGlyZWN0aW9uYWwgY29tcGVuc2F0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBwYXJzZWQgYW5nbGUgaW4gcmFkaWFuc1xuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VBbmdsZSA9IGZ1bmN0aW9uKHYsIGQsIHAsIGRpcmVjdGlvbmFsRW5kKSB7XG5cdFx0XHRcdHZhciBtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHRjYXAsIHNwbGl0LCBkaWYsIHJlc3VsdCwgaXNSZWxhdGl2ZTtcblx0XHRcdFx0aWYgKHYgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYXAgPSAzNjA7XG5cdFx0XHRcdFx0c3BsaXQgPSB2LnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHRpc1JlbGF0aXZlID0gKHYuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0ZGlmID0gKGlzUmVsYXRpdmUgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHNwbGl0WzBdLnN1YnN0cigyKSkgOiBwYXJzZUZsb2F0KHNwbGl0WzBdKSkgKiAoKHYuaW5kZXhPZihcInJhZFwiKSA9PT0gLTEpID8gMSA6IF9SQUQyREVHKSAtIChpc1JlbGF0aXZlID8gMCA6IGQpO1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChkaXJlY3Rpb25hbEVuZCkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25hbEVuZFtwXSA9IGQgKyBkaWY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBkICsgZGlmO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXN1bHQgPCBtaW4gJiYgcmVzdWx0ID4gLW1pbikge1xuXHRcdFx0XHRcdHJlc3VsdCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHRcdF9jb2xvckxvb2t1cCA9IHthcXVhOlswLDI1NSwyNTVdLFxuXHRcdFx0XHRsaW1lOlswLDI1NSwwXSxcblx0XHRcdFx0c2lsdmVyOlsxOTIsMTkyLDE5Ml0sXG5cdFx0XHRcdGJsYWNrOlswLDAsMF0sXG5cdFx0XHRcdG1hcm9vbjpbMTI4LDAsMF0sXG5cdFx0XHRcdHRlYWw6WzAsMTI4LDEyOF0sXG5cdFx0XHRcdGJsdWU6WzAsMCwyNTVdLFxuXHRcdFx0XHRuYXZ5OlswLDAsMTI4XSxcblx0XHRcdFx0d2hpdGU6WzI1NSwyNTUsMjU1XSxcblx0XHRcdFx0ZnVjaHNpYTpbMjU1LDAsMjU1XSxcblx0XHRcdFx0b2xpdmU6WzEyOCwxMjgsMF0sXG5cdFx0XHRcdHllbGxvdzpbMjU1LDI1NSwwXSxcblx0XHRcdFx0b3JhbmdlOlsyNTUsMTY1LDBdLFxuXHRcdFx0XHRncmF5OlsxMjgsMTI4LDEyOF0sXG5cdFx0XHRcdHB1cnBsZTpbMTI4LDAsMTI4XSxcblx0XHRcdFx0Z3JlZW46WzAsMTI4LDBdLFxuXHRcdFx0XHRyZWQ6WzI1NSwwLDBdLFxuXHRcdFx0XHRwaW5rOlsyNTUsMTkyLDIwM10sXG5cdFx0XHRcdGN5YW46WzAsMjU1LDI1NV0sXG5cdFx0XHRcdHRyYW5zcGFyZW50OlsyNTUsMjU1LDI1NSwwXX0sXG5cblx0XHRcdF9odWUgPSBmdW5jdGlvbihoLCBtMSwgbTIpIHtcblx0XHRcdFx0aCA9IChoIDwgMCkgPyBoICsgMSA6IChoID4gMSkgPyBoIC0gMSA6IGg7XG5cdFx0XHRcdHJldHVybiAoKCgoaCAqIDYgPCAxKSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiAoaCA8IDAuNSkgPyBtMiA6IChoICogMyA8IDIpID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiAyNTUpICsgMC41KSB8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhcnNlcyBhIGNvbG9yIChsaWtlICM5RjAsICNGRjk5MDAsIG9yIHJnYigyNTUsNTEsMTUzKSkgaW50byBhbiBhcnJheSB3aXRoIDMgZWxlbWVudHMgZm9yIHJlZCwgZ3JlZW4sIGFuZCBibHVlLiBBbHNvIGhhbmRsZXMgcmdiYSgpIHZhbHVlcyAoc3BsaXRzIGludG8gYXJyYXkgb2YgNCBlbGVtZW50cyBvZiBjb3Vyc2UpXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gdiBUaGUgdmFsdWUgdGhlIHNob3VsZCBiZSBwYXJzZWQgd2hpY2ggY291bGQgYmUgYSBzdHJpbmcgbGlrZSAjOUYwIG9yIHJnYigyNTUsMTAyLDUxKSBvciByZ2JhKDI1NSwwLDAsMC41KSBvciBpdCBjb3VsZCBiZSBhIG51bWJlciBsaWtlIDB4RkYwMENDIG9yIGV2ZW4gYSBuYW1lZCBjb2xvciBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuXG5cdFx0XHQgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQW4gYXJyYXkgY29udGFpbmluZyByZWQsIGdyZWVuLCBhbmQgYmx1ZSAoYW5kIG9wdGlvbmFsbHkgYWxwaGEpIGluIHRoYXQgb3JkZXIuXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNvbG9yID0gQ1NTUGx1Z2luLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciBjMSwgYzIsIGMzLCBoLCBzLCBsO1xuXHRcdFx0XHRpZiAoIXYgfHwgdiA9PT0gXCJcIikge1xuXHRcdFx0XHRcdHJldHVybiBfY29sb3JMb29rdXAuYmxhY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHJldHVybiBbdiA+PiAxNiwgKHYgPj4gOCkgJiAyNTUsIHYgJiAyNTVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmNoYXJBdCh2Lmxlbmd0aCAtIDEpID09PSBcIixcIikgeyAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cblx0XHRcdFx0XHR2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9jb2xvckxvb2t1cFt2XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG5cdFx0XHRcdFx0aWYgKHYubGVuZ3RoID09PSA0KSB7IC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjBcblx0XHRcdFx0XHRcdGMxID0gdi5jaGFyQXQoMSksXG5cdFx0XHRcdFx0XHRjMiA9IHYuY2hhckF0KDIpLFxuXHRcdFx0XHRcdFx0YzMgPSB2LmNoYXJBdCgzKTtcblx0XHRcdFx0XHRcdHYgPSBcIiNcIiArIGMxICsgYzEgKyBjMiArIGMyICsgYzMgKyBjMztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0diA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG5cdFx0XHRcdFx0cmV0dXJuIFt2ID4+IDE2LCAodiA+PiA4KSAmIDI1NSwgdiAmIDI1NV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG5cdFx0XHRcdFx0diA9IHYubWF0Y2goX251bUV4cCk7XG5cdFx0XHRcdFx0aCA9IChOdW1iZXIodlswXSkgJSAzNjApIC8gMzYwO1xuXHRcdFx0XHRcdHMgPSBOdW1iZXIodlsxXSkgLyAxMDA7XG5cdFx0XHRcdFx0bCA9IE51bWJlcih2WzJdKSAvIDEwMDtcblx0XHRcdFx0XHRjMiA9IChsIDw9IDAuNSkgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG5cdFx0XHRcdFx0YzEgPSBsICogMiAtIGMyO1xuXHRcdFx0XHRcdGlmICh2Lmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHRcdHZbM10gPSBOdW1iZXIodlszXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZbMF0gPSBfaHVlKGggKyAxIC8gMywgYzEsIGMyKTtcblx0XHRcdFx0XHR2WzFdID0gX2h1ZShoLCBjMSwgYzIpO1xuXHRcdFx0XHRcdHZbMl0gPSBfaHVlKGggLSAxIC8gMywgYzEsIGMyKTtcblx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ID0gdi5tYXRjaChfbnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG5cdFx0XHRcdHZbMF0gPSBOdW1iZXIodlswXSk7XG5cdFx0XHRcdHZbMV0gPSBOdW1iZXIodlsxXSk7XG5cdFx0XHRcdHZbMl0gPSBOdW1iZXIodlsyXSk7XG5cdFx0XHRcdGlmICh2Lmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHR2WzNdID0gTnVtYmVyKHZbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSxcblx0XHRcdF9jb2xvckV4cCA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMuKz9cXFxcYlwiOyAvL3dlJ2xsIGR5bmFtaWNhbGx5IGJ1aWxkIHRoaXMgUmVndWxhciBFeHByZXNzaW9uIHRvIGNvbnNlcnZlIGZpbGUgc2l6ZS4gQWZ0ZXIgYnVpbGRpbmcgaXQsIGl0IHdpbGwgYmUgYWJsZSB0byBmaW5kIHJnYigpLCByZ2JhKCksICMgKGhleGFkZWNpbWFsKSwgYW5kIG5hbWVkIGNvbG9yIHZhbHVlcyBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuXG5cblx0XHRmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG5cdFx0XHRfY29sb3JFeHAgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuXHRcdH1cblx0XHRfY29sb3JFeHAgPSBuZXcgUmVnRXhwKF9jb2xvckV4cCtcIilcIiwgXCJnaVwiKTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlIFJldHVybnMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRha2luZyBhIHN0cmluZyAob3IgbnVtYmVyIGluIHNvbWUgY2FzZXMpIGFuZCByZXR1cm5pbmcgYSBjb25zaXN0ZW50bHkgZm9ybWF0dGVkIG9uZSBpbiB0ZXJtcyBvZiBkZWxpbWl0ZXJzLCBxdWFudGl0eSBvZiB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGUsIHdlIG1heSBnZXQgYm94U2hhZG93IHZhbHVlcyBkZWZpbmVkIGFzIFwiMHB4IHJlZFwiIG9yIFwiMHB4IDBweCAxMHB4IHJnYigyNTUsMCwwKVwiIG9yIFwiMHB4IDBweCAyMHB4IDIwcHggI0YwMFwiIGFuZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHdoYXQgd2UgZ2V0IGJhY2sgaXMgZGVzY3JpYmVkIHdpdGggNCBudW1iZXJzIGFuZCBhIGNvbG9yLiBUaGlzIGFsbG93cyB1cyB0byBmZWVkIGl0IGludG8gdGhlIF9wYXJzZUNvbXBsZXgoKSBtZXRob2QgYW5kIHNwbGl0IHRoZSB2YWx1ZXMgdXAgYXBwcm9wcmlhdGVseS4gVGhlIG5lYXQgdGhpbmcgYWJvdXQgdGhpcyBfZ2V0Rm9ybWF0dGVyKCkgZnVuY3Rpb24gaXMgdGhhdCB0aGUgZGZsdCBkZWZpbmVzIGEgcGF0dGVybiBhcyB3ZWxsIGFzIGEgZGVmYXVsdCwgc28gZm9yIGV4YW1wbGUsIF9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4IDBweCAwcHggIzc3N1wiLCB0cnVlKSBub3Qgb25seSBzZXRzIHRoZSBkZWZhdWx0IGFzIDBweCBmb3IgYWxsIGRpc3RhbmNlcyBhbmQgIzc3NyBmb3IgdGhlIGNvbG9yLCBidXQgYWxzbyBzZXRzIHRoZSBwYXR0ZXJuIHN1Y2ggdGhhdCA0IG51bWJlcnMgYW5kIGEgY29sb3Igd2lsbCBhbHdheXMgZ2V0IHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gZGZsdCBUaGUgZGVmYXVsdCB2YWx1ZSBhbmQgcGF0dGVybiB0byBmb2xsb3cuIFNvIFwiMHB4IDBweCAwcHggMHB4ICM3NzdcIiB3aWxsIGVuc3VyZSB0aGF0IDQgbnVtYmVycyBhbmQgYSBjb2xvciB3aWxsIGFsd2F5cyBnZXQgcmV0dXJuZWQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY2xyIElmIHRydWUsIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBjb2xvci1yZWxhdGVkIGRhdGEuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgdmFsdWVzIHR5cGljYWxseSBjb250YWluIGEgY29sb3Igd2hlcmVhcyBib3JkZXJSYWRpdXMgZG9uJ3QuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY29sbGFwc2libGUgSWYgdHJ1ZSwgdGhlIHZhbHVlIGlzIGEgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHN0eWxlIG9uZSB0aGF0IGFjdHMgbGlrZSBtYXJnaW4gb3IgcGFkZGluZywgd2hlcmUgaWYgb25seSBvbmUgdmFsdWUgaXMgcmVjZWl2ZWQsIGl0J3MgdXNlZCBmb3IgYWxsIDQ7IGlmIDIgYXJlIHJlY2VpdmVkLCB0aGUgZmlyc3QgaXMgZHVwbGljYXRlZCBmb3IgM3JkIChib3R0b20pIGFuZCB0aGUgMm5kIGlzIGR1cGxpY2F0ZWQgZm9yIHRoZSA0dGggc3BvdCAobGVmdCksIGV0Yy5cblx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gZm9ybWF0dGVyIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dmFyIF9nZXRGb3JtYXR0ZXIgPSBmdW5jdGlvbihkZmx0LCBjbHIsIGNvbGxhcHNpYmxlLCBtdWx0aSkge1xuXHRcdFx0XHRpZiAoZGZsdCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHYpIHtyZXR1cm4gdjt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBkQ29sb3IgPSBjbHIgPyAoZGZsdC5tYXRjaChfY29sb3JFeHApIHx8IFtcIlwiXSlbMF0gOiBcIlwiLFxuXHRcdFx0XHRcdGRWYWxzID0gZGZsdC5zcGxpdChkQ29sb3IpLmpvaW4oXCJcIikubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW10sXG5cdFx0XHRcdFx0cGZ4ID0gZGZsdC5zdWJzdHIoMCwgZGZsdC5pbmRleE9mKGRWYWxzWzBdKSksXG5cdFx0XHRcdFx0c2Z4ID0gKGRmbHQuY2hhckF0KGRmbHQubGVuZ3RoIC0gMSkgPT09IFwiKVwiKSA/IFwiKVwiIDogXCJcIixcblx0XHRcdFx0XHRkZWxpbSA9IChkZmx0LmluZGV4T2YoXCIgXCIpICE9PSAtMSkgPyBcIiBcIiA6IFwiLFwiLFxuXHRcdFx0XHRcdG51bVZhbHMgPSBkVmFscy5sZW5ndGgsXG5cdFx0XHRcdFx0ZFNmeCA9IChudW1WYWxzID4gMCkgPyBkVmFsc1swXS5yZXBsYWNlKF9udW1FeHAsIFwiXCIpIDogXCJcIixcblx0XHRcdFx0XHRmb3JtYXR0ZXI7XG5cdFx0XHRcdGlmICghbnVtVmFscykge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih2KSB7cmV0dXJuIHY7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xyKSB7XG5cdFx0XHRcdFx0Zm9ybWF0dGVyID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIGNvbG9yLCB2YWxzLCBpLCBhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG11bHRpICYmIF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdCh2KSkge1xuXHRcdFx0XHRcdFx0XHRhID0gdi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0YVtpXSA9IGZvcm1hdHRlcihhW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbG9yID0gKHYubWF0Y2goX2NvbG9yRXhwKSB8fCBbZENvbG9yXSlbMF07XG5cdFx0XHRcdFx0XHR2YWxzID0gdi5zcGxpdChjb2xvcikuam9pbihcIlwiKS5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXTtcblx0XHRcdFx0XHRcdGkgPSB2YWxzLmxlbmd0aDtcblx0XHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgrK2kgPCBudW1WYWxzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsc1tpXSA9IGNvbGxhcHNpYmxlID8gdmFsc1soKChpIC0gMSkgLyAyKSB8IDApXSA6IGRWYWxzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGZ4ICsgdmFscy5qb2luKGRlbGltKSArIGRlbGltICsgY29sb3IgKyBzZnggKyAodi5pbmRleE9mKFwiaW5zZXRcIikgIT09IC0xID8gXCIgaW5zZXRcIiA6IFwiXCIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcm1hdHRlciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHR2YXIgdmFscywgYSwgaTtcblx0XHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtdWx0aSAmJiBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QodikpIHtcblx0XHRcdFx0XHRcdGEgPSB2LnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBmb3JtYXR0ZXIoYVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFscyA9IHYubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW107XG5cdFx0XHRcdFx0aSA9IHZhbHMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoKytpIDwgbnVtVmFscykge1xuXHRcdFx0XHRcdFx0XHR2YWxzW2ldID0gY29sbGFwc2libGUgPyB2YWxzWygoKGkgLSAxKSAvIDIpIHwgMCldIDogZFZhbHNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwZnggKyB2YWxzLmpvaW4oZGVsaW0pICsgc2Z4O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gZm9ybWF0dGVyO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSByZXR1cm5zIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQncyB1c2VkIGZvciBlZGdlLXJlbGF0ZWQgdmFsdWVzIGxpa2UgbWFyZ2luVG9wLCBtYXJnaW5MZWZ0LCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nUmlnaHQsIGV0Yy4gSnVzdCBwYXNzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgcmVsYXRlZCB0byB0aGUgZWRnZXMuXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgaW4gb3JkZXIgZnJvbSB0b3AgdG8gbGVmdCwgbGlrZSBcIm1hcmdpblRvcCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20sbWFyZ2luTGVmdFwiXG5cdFx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmb3JtYXR0ZXIgZnVuY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0X2dldEVkZ2VQYXJzZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0XHR2YXIgYSA9IChlICsgXCJcIikuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdFx0aTtcblx0XHRcdFx0XHR2YXJzID0ge307XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyc1twcm9wc1tpXV0gPSBhW2ldID0gYVtpXSB8fCBhWygoKGkgLSAxKSAvIDIpID4+IDApXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNzc3AucGFyc2UodCwgdmFycywgcHQsIHBsdWdpbik7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSB1c2VkIHdoZW4gb3RoZXIgcGx1Z2lucyBtdXN0IHR3ZWVuIHZhbHVlcyBmaXJzdCwgbGlrZSBCZXppZXJQbHVnaW4gb3IgVGhyb3dQcm9wc1BsdWdpbiwgZXRjLiBUaGF0IHBsdWdpbidzIHNldFJhdGlvKCkgZ2V0cyBjYWxsZWQgZmlyc3Qgc28gdGhhdCB0aGUgdmFsdWVzIGFyZSB1cGRhdGVkLCBhbmQgdGhlbiB3ZSBsb29wIHRocm91Z2ggdGhlIE1pbmlQcm9wVHdlZW5zICB3aGljaCBoYW5kbGUgY29weWluZyB0aGUgdmFsdWVzIGludG8gdGhlaXIgYXBwcm9wcmlhdGUgc2xvdHMgc28gdGhhdCB0aGV5IGNhbiB0aGVuIGJlIGFwcGxpZWQgY29ycmVjdGx5IGluIHRoZSBtYWluIENTU1BsdWdpbiBzZXRSYXRpbygpIG1ldGhvZC4gUmVtZW1iZXIsIHdlIHR5cGljYWxseSBjcmVhdGUgYSBwcm94eSBvYmplY3QgdGhhdCBoYXMgYSBidW5jaCBvZiB1bmlxdWVseS1uYW1lZCBwcm9wZXJ0aWVzIHRoYXQgd2UgZmVlZCB0byB0aGUgc3ViLXBsdWdpbiBhbmQgaXQgZG9lcyBpdHMgbWFnaWMgbm9ybWFsbHksIGFuZCB0aGVuIHdlIG11c3QgaW50ZXJwcmV0IHRob3NlIHZhbHVlcyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgY3NzIGJlY2F1c2Ugb2Z0ZW4gbnVtYmVycyBtdXN0IGdldCBjb21iaW5lZC9jb25jYXRlbmF0ZWQsIHN1ZmZpeGVzIGFkZGVkLCBldGMuIHRvIHdvcmsgd2l0aCBjc3MsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgNCB2YWx1ZXMgcGx1cyBhIGNvbG9yLlxuXHRcdFx0X3NldFBsdWdpblJhdGlvID0gX2ludGVybmFscy5fc2V0UGx1Z2luUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldFJhdGlvKHYpO1xuXHRcdFx0XHR2YXIgZCA9IHRoaXMuZGF0YSxcblx0XHRcdFx0XHRwcm94eSA9IGQucHJveHksXG5cdFx0XHRcdFx0bXB0ID0gZC5maXJzdE1QVCxcblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHR2YWwsIHB0LCBpLCBzdHI7XG5cdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHR2YWwgPSBwcm94eVttcHQudl07XG5cdFx0XHRcdFx0aWYgKG1wdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4gJiYgdmFsID4gLW1pbikge1xuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bXB0LnRbbXB0LnBdID0gdmFsO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZC5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0ZC5hdXRvUm90YXRlLnJvdGF0aW9uID0gcHJveHkucm90YXRpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9hdCB0aGUgZW5kLCB3ZSBtdXN0IHNldCB0aGUgQ1NTUHJvcFR3ZWVuJ3MgXCJlXCIgKGVuZCkgdmFsdWUgZHluYW1pY2FsbHkgaGVyZSBiZWNhdXNlIHRoYXQncyB3aGF0IGlzIHVzZWQgaW4gdGhlIGZpbmFsIHNldFJhdGlvKCkgbWV0aG9kLlxuXHRcdFx0XHRpZiAodiA9PT0gMSkge1xuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQ7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtcHQudDtcblx0XHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRwdC5lID0gcHQucyArIHB0LnhzMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyBwdC5zICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQuZSA9IHN0cjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgQGNvbnN0cnVjdG9yIFVzZWQgYnkgYSBmZXcgU3BlY2lhbFByb3BzIHRvIGhvbGQgaW1wb3J0YW50IHZhbHVlcyBmb3IgcHJveGllcy4gRm9yIGV4YW1wbGUsIF9wYXJzZVRvUHJveHkoKSBjcmVhdGVzIGEgTWluaVByb3BUd2VlbiBpbnN0YW5jZSBmb3IgZWFjaCBwcm9wZXJ0eSB0aGF0IG11c3QgZ2V0IHR3ZWVuZWQgb24gdGhlIHByb3h5LCBhbmQgd2UgcmVjb3JkIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBuYW1lIGFzIHdlbGwgYXMgdGhlIHVuaXF1ZSBvbmUgd2UgY3JlYXRlIGZvciB0aGUgcHJveHksIHBsdXMgd2hldGhlciBvciBub3QgdGhlIHZhbHVlIG5lZWRzIHRvIGJlIHJvdW5kZWQgcGx1cyB0aGUgb3JpZ2luYWwgdmFsdWUuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSB3ZSdyZSB0d2VlbmluZyAob2Z0ZW4gYSBDU1NQcm9wVHdlZW4pXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgcHJvcGVydHkgbmFtZVxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZ3xvYmplY3QpfSB2IHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge01pbmlQcm9wVHdlZW49fSBuZXh0IG5leHQgTWluaVByb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgaWYgdHJ1ZSwgdGhlIHR3ZWVuZWQgdmFsdWUgc2hvdWxkIGJlIHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuXHRcdFx0ICovXG5cdFx0XHRNaW5pUHJvcFR3ZWVuID0gZnVuY3Rpb24odCwgcCwgdiwgbmV4dCwgcikge1xuXHRcdFx0XHR0aGlzLnQgPSB0O1xuXHRcdFx0XHR0aGlzLnAgPSBwO1xuXHRcdFx0XHR0aGlzLnYgPSB2O1xuXHRcdFx0XHR0aGlzLnIgPSByO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuX25leHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIE1vc3Qgb3RoZXIgcGx1Z2lucyAobGlrZSBCZXppZXJQbHVnaW4gYW5kIFRocm93UHJvcHNQbHVnaW4gYW5kIG90aGVycykgY2FuIG9ubHkgdHdlZW4gbnVtZXJpYyB2YWx1ZXMsIGJ1dCBDU1NQbHVnaW4gbXVzdCBhY2NvbW1vZGF0ZSBzcGVjaWFsIHZhbHVlcyB0aGF0IGhhdmUgYSBidW5jaCBvZiBleHRyYSBkYXRhIChsaWtlIGEgc3VmZml4IG9yIHN0cmluZ3MgYmV0d2VlbiBudW1lcmljIHZhbHVlcywgZXRjLikuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgaGFzIHZhbHVlcyBsaWtlIFwiMTBweCAxMHB4IDIwcHggMzBweCByZ2IoMjU1LDAsMClcIiB3aGljaCB3b3VsZCB1dHRlcmx5IGNvbmZ1c2Ugb3RoZXIgcGx1Z2lucy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIHNwbGl0IHRoYXQgZGF0YSBhcGFydCBhbmQgZ3JhYiBvbmx5IHRoZSBudW1lcmljIGRhdGEgYW5kIGF0dGFjaCBpdCB0byB1bmlxdWVseS1uYW1lZCBwcm9wZXJ0aWVzIG9mIGEgZ2VuZXJpYyBwcm94eSBvYmplY3QgKHt9KSBzbyB0aGF0IHdlIGNhbiBmZWVkIHRoYXQgdG8gdmlydHVhbGx5IGFueSBwbHVnaW4gdG8gaGF2ZSB0aGUgbnVtYmVycyB0d2VlbmVkLiBIb3dldmVyLCB3ZSBtdXN0IGFsc28ga2VlcCB0cmFjayBvZiB3aGljaCBwcm9wZXJ0aWVzIGZyb20gdGhlIHByb3h5IGdvIHdpdGggd2hpY2ggQ1NTUHJvcFR3ZWVuIHZhbHVlcyBhbmQgaW5zdGFuY2VzLiBTbyB3ZSBjcmVhdGUgYSBsaW5rZWQgbGlzdCBvZiBNaW5pUHJvcFR3ZWVucy4gRWFjaCBvbmUgcmVjb3JkcyBhIHRhcmdldCAodGhlIG9yaWdpbmFsIENTU1Byb3BUd2VlbiksIHByb3BlcnR5IChsaWtlIFwic1wiIG9yIFwieG4xXCIgb3IgXCJ4bjJcIikgdGhhdCB3ZSdyZSB0d2VlbmluZyBhbmQgdGhlIHVuaXF1ZSBwcm9wZXJ0eSBuYW1lIHRoYXQgd2FzIHVzZWQgZm9yIHRoZSBwcm94eSAobGlrZSBcImJveFNoYWRvd194bjFcIiBhbmQgXCJib3hTaGFkb3dfeG4yXCIpIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGV5IG5lZWQgdG8gYmUgcm91bmRlZC4gVGhhdCB3YXksIGluIHRoZSBfc2V0UGx1Z2luUmF0aW8oKSBtZXRob2Qgd2UgY2FuIHNpbXBseSBjb3B5IHRoZSB2YWx1ZXMgb3ZlciBmcm9tIHRoZSBwcm94eSB0byB0aGUgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlKHMpLiBUaGVuLCB3aGVuIHRoZSBtYWluIENTU1BsdWdpbiBzZXRSYXRpbygpIG1ldGhvZCBydW5zIGFuZCBhcHBsaWVzIHRoZSBDU1NQcm9wVHdlZW4gdmFsdWVzIGFjY29yZGluZ2x5LCB0aGV5J3JlIHVwZGF0ZWQgbmljZWx5LiBTbyB0aGUgZXh0ZXJuYWwgcGx1Z2luIHR3ZWVucyB0aGUgbnVtYmVycywgX3NldFBsdWdpblJhdGlvKCkgY29waWVzIHRoZW0gb3ZlciwgYW5kIHNldFJhdGlvKCkgYWN0cyBub3JtYWxseSwgYXBwbHlpbmcgY3NzLXNwZWNpZmljIHZhbHVlcyB0byB0aGUgZWxlbWVudC5cblx0XHRcdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHRcdCAqICAtIHByb3h5OiBhIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0YXJ0aW5nIHZhbHVlcyBmb3IgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSB0d2VlbmVkIGJ5IHRoZSBleHRlcm5hbCBwbHVnaW4uICBUaGlzIGlzIHdoYXQgd2UgZmVlZCB0byB0aGUgZXh0ZXJuYWwgX29uSW5pdFR3ZWVuKCkgYXMgdGhlIHRhcmdldFxuXHRcdFx0ICogIC0gZW5kOiBhIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuZGluZyB2YWx1ZXMgZm9yIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdHdlZW5lZCBieSB0aGUgZXh0ZXJuYWwgcGx1Z2luLiBUaGlzIGlzIHdoYXQgd2UgZmVlZCB0byB0aGUgZXh0ZXJuYWwgcGx1Z2luJ3MgX29uSW5pdFR3ZWVuKCkgYXMgdGhlIGRlc3RpbmF0aW9uIHZhbHVlc1xuXHRcdFx0ICogIC0gZmlyc3RNUFQ6IHRoZSBmaXJzdCBNaW5pUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogIC0gcHQ6IHRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHRoYXQgd2FzIGNyZWF0ZWQgd2hlbiBwYXJzaW5nLiBJZiBzaGFsbG93IGlzIHRydWUsIHRoaXMgbGlua2VkIGxpc3Qgd2lsbCBOT1QgYXR0YWNoIHRvIHRoZSBvbmUgcGFzc2VkIGludG8gdGhlIF9wYXJzZVRvUHJveHkoKSBhcyB0aGUgXCJwdFwiICg0dGgpIHBhcmFtZXRlci5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgb2JqZWN0IHRvIGJlIHR3ZWVuZWRcblx0XHRcdCAqIEBwYXJhbSB7IShPYmplY3R8c3RyaW5nKX0gdmFycyB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0d2VlbmluZyB2YWx1ZXMgKHR5cGljYWxseSB0aGUgZW5kL2Rlc3RpbmF0aW9uIHZhbHVlcykgdGhhdCBzaG91bGQgYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFDU1NQbHVnaW59IGNzc3AgVGhlIENTU1BsdWdpbiBpbnN0YW5jZVxuXHRcdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBwdCB0aGUgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIHRoZSBleHRlcm5hbCBUd2VlblBsdWdpbiBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgaGFuZGxpbmcgdHdlZW5pbmcgdGhlIG51bWVyaWMgdmFsdWVzXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaGFsbG93IGlmIHRydWUsIHRoZSByZXN1bHRpbmcgbGlua2VkIGxpc3QgZnJvbSB0aGUgcGFyc2Ugd2lsbCBOT1QgYmUgYXR0YWNoZWQgdG8gdGhlIENTU1Byb3BUd2VlbiB0aGF0IHdhcyBwYXNzZWQgaW4gYXMgdGhlIFwicHRcIiAoNHRoKSBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBAcmV0dXJuIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogcHJveHksIGVuZCwgZmlyc3RNUFQsIGFuZCBwdCAoc2VlIGFib3ZlIGZvciBkZXNjcmlwdGlvbnMpXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHkgPSBmdW5jdGlvbih0LCB2YXJzLCBjc3NwLCBwdCwgcGx1Z2luLCBzaGFsbG93KSB7XG5cdFx0XHRcdHZhciBicHQgPSBwdCxcblx0XHRcdFx0XHRzdGFydCA9IHt9LFxuXHRcdFx0XHRcdGVuZCA9IHt9LFxuXHRcdFx0XHRcdHRyYW5zZm9ybSA9IGNzc3AuX3RyYW5zZm9ybSxcblx0XHRcdFx0XHRvbGRGb3JjZSA9IF9mb3JjZVBULFxuXHRcdFx0XHRcdGksIHAsIHhwLCBtcHQsIGZpcnN0UFQ7XG5cdFx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IG51bGw7XG5cdFx0XHRcdF9mb3JjZVBUID0gdmFycztcblx0XHRcdFx0cHQgPSBmaXJzdFBUID0gY3NzcC5wYXJzZSh0LCB2YXJzLCBwdCwgcGx1Z2luKTtcblx0XHRcdFx0X2ZvcmNlUFQgPSBvbGRGb3JjZTtcblx0XHRcdFx0Ly9icmVhayBvZmYgZnJvbSB0aGUgbGlua2VkIGxpc3Qgc28gdGhlIG5ldyBvbmVzIGFyZSBpc29sYXRlZC5cblx0XHRcdFx0aWYgKHNoYWxsb3cpIHtcblx0XHRcdFx0XHRjc3NwLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdFx0XHRcdFx0aWYgKGJwdCkge1xuXHRcdFx0XHRcdFx0YnB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmIChicHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0YnB0Ll9wcmV2Ll9uZXh0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKHB0ICYmIHB0ICE9PSBicHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSA8PSAxKSB7XG5cdFx0XHRcdFx0XHRwID0gcHQucDtcblx0XHRcdFx0XHRcdGVuZFtwXSA9IHB0LnMgKyBwdC5jO1xuXHRcdFx0XHRcdFx0c3RhcnRbcF0gPSBwdC5zO1xuXHRcdFx0XHRcdFx0aWYgKCFzaGFsbG93KSB7XG5cdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHB0LCBcInNcIiwgcCwgbXB0LCBwdC5yKTtcblx0XHRcdFx0XHRcdFx0cHQuYyA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocHQudHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR4cCA9IFwieG5cIiArIGk7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHB0LnAgKyBcIl9cIiArIHhwO1xuXHRcdFx0XHRcdFx0XHRcdGVuZFtwXSA9IHB0LmRhdGFbeHBdO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0W3BdID0gcHRbeHBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghc2hhbGxvdykge1xuXHRcdFx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4ocHQsIHhwLCBwLCBtcHQsIHB0LnJ4cFt4cF0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7cHJveHk6c3RhcnQsIGVuZDplbmQsIGZpcnN0TVBUOm1wdCwgcHQ6Zmlyc3RQVH07XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAY29uc3RydWN0b3IgRWFjaCBwcm9wZXJ0eSB0aGF0IGlzIHR3ZWVuZWQgaGFzIGF0IGxlYXN0IG9uZSBDU1NQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGVzZSBpbnN0YW5jZXMgc3RvcmUgaW1wb3J0YW50IGluZm9ybWF0aW9uIGxpa2UgdGhlIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0aW5nIHZhbHVlLCBhbW91bnQgb2YgY2hhbmdlLCBldGMuIFRoZXkgY2FuIGFsc28gb3B0aW9uYWxseSBoYXZlIGEgbnVtYmVyIG9mIFwiZXh0cmFcIiBzdHJpbmdzIGFuZCBudW1lcmljIHZhbHVlcyBuYW1lZCB4czEsIHhuMSwgeHMyLCB4bjIsIHhzMywgeG4zLCBldGMuIHdoZXJlIFwic1wiIGluZGljYXRlcyBzdHJpbmcgYW5kIFwiblwiIGluZGljYXRlcyBudW1iZXIuIFRoZXNlIGNhbiBiZSBwaWVjZWQgdG9nZXRoZXIgaW4gYSBjb21wbGV4LXZhbHVlIHR3ZWVuICh0eXBlOjEpIHRoYXQgaGFzIGFsdGVybmF0aW5nIHR5cGVzIG9mIGRhdGEgbGlrZSBhIHN0cmluZywgbnVtYmVyLCBzdHJpbmcsIG51bWJlciwgZXRjLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IGNvdWxkIGJlIFwiNXB4IDVweCA4cHggcmdiKDEwMiwgMTAyLCA1MSlcIi4gSW4gdGhhdCB2YWx1ZSwgdGhlcmUgYXJlIDYgbnVtYmVycyB0aGF0IG1heSBuZWVkIHRvIHR3ZWVuIGFuZCB0aGVuIHBpZWNlZCBiYWNrIHRvZ2V0aGVyIGludG8gYSBzdHJpbmcgYWdhaW4gd2l0aCBzcGFjZXMsIHN1ZmZpeGVzLCBldGMuIHhzMCBpcyBzcGVjaWFsIGluIHRoYXQgaXQgc3RvcmVzIHRoZSBzdWZmaXggZm9yIHN0YW5kYXJkICh0eXBlOjApIHR3ZWVucywgLU9SLSB0aGUgZmlyc3Qgc3RyaW5nIChwcmVmaXgpIGluIGEgY29tcGxleC12YWx1ZSAodHlwZToxKSBDU1NQcm9wVHdlZW4gLU9SLSBpdCBjYW4gYmUgdGhlIG5vbi10d2VlbmluZyB2YWx1ZSBpbiBhIHR5cGU6LTEgQ1NTUHJvcFR3ZWVuLiBXZSBkbyB0aGlzIHRvIGNvbnNlcnZlIG1lbW9yeS5cblx0XHRcdCAqIENTU1Byb3BUd2VlbnMgaGF2ZSB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgYXMgd2VsbCAobm90IGRlZmluZWQgdGhyb3VnaCB0aGUgY29uc3RydWN0b3IpOlxuXHRcdFx0ICogIC0gbDogTGVuZ3RoIGluIHRlcm1zIG9mIHRoZSBudW1iZXIgb2YgZXh0cmEgcHJvcGVydGllcyB0aGF0IHRoZSBDU1NQcm9wVHdlZW4gaGFzIChkZWZhdWx0OiAwKS4gRm9yIGV4YW1wbGUsIGZvciBhIGJveFNoYWRvdyB3ZSBtYXkgbmVlZCB0byB0d2VlbiA1IG51bWJlcnMgaW4gd2hpY2ggY2FzZSBsIHdvdWxkIGJlIDU7IEtlZXAgaW4gbWluZCB0aGF0IHRoZSBzdGFydC9lbmQgdmFsdWVzIGZvciB0aGUgZmlyc3QgbnVtYmVyIHRoYXQncyB0d2VlbmVkIGFyZSBhbHdheXMgc3RvcmVkIGluIHRoZSBzIGFuZCBjIHByb3BlcnRpZXMgdG8gY29uc2VydmUgbWVtb3J5LiBBbGwgYWRkaXRpb25hbCB2YWx1ZXMgdGhlcmVhZnRlciBhcmUgc3RvcmVkIGluIHhuMSwgeG4yLCBldGMuXG5cdFx0XHQgKiAgLSB4Zmlyc3Q6IFRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgc3ViLUNTU1Byb3BUd2VlbnMgdGhhdCBhcmUgdHdlZW5pbmcgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlLiBGb3IgZXhhbXBsZSwgd2UgbWF5IHNwbGl0IHVwIGEgYm94U2hhZG93IHR3ZWVuIHNvIHRoYXQgdGhlcmUncyBhIG1haW4gQ1NTUHJvcFR3ZWVuIG9mIHR5cGU6MSB0aGF0IGhhcyB2YXJpb3VzIHhzKiBhbmQgeG4qIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGgtc2hhZG93LCB2LXNoYWRvdywgYmx1ciwgY29sb3IsIGV0Yy4gVGhlbiB3ZSBzcGF3biBhIENTU1Byb3BUd2VlbiBmb3IgZWFjaCBvZiB0aG9zZSB0aGF0IGhhcyBhIGhpZ2hlciBwcmlvcml0eSBhbmQgcnVucyBCRUZPUkUgdGhlIG1haW4gQ1NTUHJvcFR3ZWVuIHNvIHRoYXQgdGhlIHZhbHVlcyBhcmUgYWxsIHNldCBieSB0aGUgdGltZSBpdCBuZWVkcyB0byByZS1hc3NlbWJsZSB0aGVtLiBUaGUgeGZpcnN0IGdpdmVzIHVzIGFuIGVhc3kgd2F5IHRvIGlkZW50aWZ5IHRoZSBmaXJzdCBvbmUgaW4gdGhhdCBjaGFpbiB3aGljaCB0eXBpY2FsbHkgZW5kcyBhdCB0aGUgbWFpbiBvbmUgKGJlY2F1c2UgdGhleSdyZSBhbGwgcHJlcGVuZGUgdG8gdGhlIGxpbmtlZCBsaXN0KVxuXHRcdFx0ICogIC0gcGx1Z2luOiBUaGUgVHdlZW5QbHVnaW4gaW5zdGFuY2UgdGhhdCB3aWxsIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgYW55IGNvbXBsZXggdmFsdWVzLiBGb3IgZXhhbXBsZSwgc29tZXRpbWVzIHdlIGRvbid0IHdhbnQgdG8gdXNlIG5vcm1hbCBzdWJ0d2VlbnMgKGxpa2UgeGZpcnN0IHJlZmVycyB0bykgdG8gdHdlZW4gdGhlIHZhbHVlcyAtIHdlIG1pZ2h0IHdhbnQgVGhyb3dQcm9wc1BsdWdpbiBvciBCZXppZXJQbHVnaW4gc29tZSBvdGhlciBwbHVnaW4gdG8gZG8gdGhlIGFjdHVhbCB0d2VlbmluZywgc28gd2UgY3JlYXRlIGEgcGx1Z2luIGluc3RhbmNlIGFuZCBzdG9yZSBhIHJlZmVyZW5jZSBoZXJlLiBXZSBuZWVkIHRoaXMgcmVmZXJlbmNlIHNvIHRoYXQgaWYgd2UgZ2V0IGEgcmVxdWVzdCB0byByb3VuZCB2YWx1ZXMgb3IgZGlzYWJsZSBhIHR3ZWVuLCB3ZSBjYW4gcGFzcyBhbG9uZyB0aGF0IHJlcXVlc3QuXG5cdFx0XHQgKiAgLSBkYXRhOiBBcmJpdHJhcnkgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHN0b3JlZCB3aXRoIHRoZSBDU1NQcm9wVHdlZW4uIFR5cGljYWxseSBpZiB3ZSdyZSBnb2luZyB0byBoYXZlIGEgcGx1Z2luIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgYSBjb21wbGV4LXZhbHVlIHR3ZWVuLCB3ZSBjcmVhdGUgYSBnZW5lcmljIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUgRU5EIHZhbHVlcyB0aGF0IHdlJ3JlIHR3ZWVuaW5nIHRvIGFuZCB0aGUgQ1NTUHJvcFR3ZWVuJ3MgeHMxLCB4czIsIGV0Yy4gaGF2ZSB0aGUgc3RhcnRpbmcgdmFsdWVzLiBXZSBzdG9yZSB0aGF0IG9iamVjdCBhcyBkYXRhLiBUaGF0IHdheSwgd2UgY2FuIHNpbXBseSBwYXNzIHRoYXQgb2JqZWN0IHRvIHRoZSBwbHVnaW4gYW5kIHVzZSB0aGUgQ1NTUHJvcFR3ZWVuIGFzIHRoZSB0YXJnZXQuXG5cdFx0XHQgKiAgLSBzZXRSYXRpbzogT25seSB1c2VkIGZvciB0eXBlOjIgdHdlZW5zIHRoYXQgcmVxdWlyZSBjdXN0b20gZnVuY3Rpb25hbGl0eS4gSW4gdGhpcyBjYXNlLCB3ZSBjYWxsIHRoZSBDU1NQcm9wVHdlZW4ncyBzZXRSYXRpbygpIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmF0aW8gZWFjaCB0aW1lIHRoZSB0d2VlbiB1cGRhdGVzLiBUaGlzIGlzbid0IHF1aXRlIGFzIGVmZmljaWVudCBhcyBkb2luZyB0aGluZ3MgZGlyZWN0bHkgaW4gdGhlIENTU1BsdWdpbidzIHNldFJhdGlvKCkgbWV0aG9kLCBidXQgaXQncyB2ZXJ5IGNvbnZlbmllbnQgYW5kIGZsZXhpYmxlLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2lsbCBiZSB0d2VlbmVkLiBPZnRlbiBhIERPTSBlbGVtZW50LCBidXQgbm90IGFsd2F5cy4gSXQgY291bGQgYmUgYW55dGhpbmcuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcCBQcm9wZXJ0eSB0byB0d2VlbiAobmFtZSkuIEZvciBleGFtcGxlLCB0byB0d2VlbiBlbGVtZW50LndpZHRoLCBwIHdvdWxkIGJlIFwid2lkdGhcIi5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBzIFN0YXJ0aW5nIG51bWVyaWMgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgZWxlbWVudC53aWR0aCBzdGFydHMgYXQgNSBhbmQgc2hvdWxkIGVuZCBhdCAxMDAsIGMgd291bGQgYmUgOTUuXG5cdFx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IG5leHQgVGhlIG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdC4gSWYgb25lIGlzIGRlZmluZWQsIHdlIHdpbGwgZGVmaW5lIGl0cyBfcHJldiBhcyB0aGUgbmV3IGluc3RhbmNlLCBhbmQgdGhlIG5ldyBpbnN0YW5jZSdzIF9uZXh0IHdpbGwgYmUgcG9pbnRlZCBhdCBpdC5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gdHlwZSBUaGUgdHlwZSBvZiBDU1NQcm9wVHdlZW4gd2hlcmUgLTEgPSBhIG5vbi10d2VlbmluZyB2YWx1ZSwgMCA9IGEgc3RhbmRhcmQgc2ltcGxlIHR3ZWVuLCAxID0gYSBjb21wbGV4IHZhbHVlIChsaWtlIG9uZSB0aGF0IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluIGEgY29tbWEtIG9yIHNwYWNlLWRlbGltaXRlZCBzdHJpbmcgbGlrZSBib3JkZXI6XCIxcHggc29saWQgcmVkXCIpLCBhbmQgMiA9IG9uZSB0aGF0IHVzZXMgYSBjdXN0b20gc2V0UmF0aW8gZnVuY3Rpb24gdGhhdCBkb2VzIGFsbCBvZiB0aGUgd29yayBvZiBhcHBseWluZyB0aGUgdmFsdWVzIG9uIGVhY2ggdXBkYXRlLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBuIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIG92ZXJ3cml0aW5nIHB1cnBvc2VzIHdoaWNoIGlzIHR5cGljYWxseSB0aGUgc2FtZSBhcyBwIGJ1dCBub3QgYWx3YXlzLiBGb3IgZXhhbXBsZSwgd2UgbWF5IG5lZWQgdG8gY3JlYXRlIGEgc3VidHdlZW4gZm9yIHRoZSAybmQgcGFydCBvZiBhIFwiY2xpcDpyZWN0KC4uLilcIiB0d2VlbiBpbiB3aGljaCBjYXNlIFwicFwiIG1pZ2h0IGJlIHhzMSBidXQgXCJuXCIgaXMgc3RpbGwgXCJjbGlwXCJcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgSWYgdHJ1ZSwgdGhlIHZhbHVlKHMpIHNob3VsZCBiZSByb3VuZGVkXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByIFByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IENTU1Byb3BUd2VlbnMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBiIEJlZ2lubmluZyB2YWx1ZS4gV2Ugc3RvcmUgdGhpcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBFWEFDVExZIHdoYXQgaXQgd2FzIHdoZW4gdGhlIHR3ZWVuIGJlZ2FuIHdpdGhvdXQgYW55IHJpc2sgb2YgaW50ZXJwcmV0YXRpb24gaXNzdWVzLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBlIEVuZGluZyB2YWx1ZS4gV2Ugc3RvcmUgdGhpcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBFWEFDVExZIHdoYXQgdGhlIHVzZXIgZGVmaW5lZCBhdCB0aGUgZW5kIG9mIHRoZSB0d2VlbiB3aXRob3V0IGFueSByaXNrIG9mIGludGVycHJldGF0aW9uIGlzc3Vlcy5cblx0XHRcdCAqL1xuXHRcdFx0Q1NTUHJvcFR3ZWVuID0gX2ludGVybmFscy5DU1NQcm9wVHdlZW4gPSBmdW5jdGlvbih0LCBwLCBzLCBjLCBuZXh0LCB0eXBlLCBuLCByLCBwciwgYiwgZSkge1xuXHRcdFx0XHR0aGlzLnQgPSB0OyAvL3RhcmdldFxuXHRcdFx0XHR0aGlzLnAgPSBwOyAvL3Byb3BlcnR5XG5cdFx0XHRcdHRoaXMucyA9IHM7IC8vc3RhcnRpbmcgdmFsdWVcblx0XHRcdFx0dGhpcy5jID0gYzsgLy9jaGFuZ2UgdmFsdWVcblx0XHRcdFx0dGhpcy5uID0gbiB8fCBwOyAvL25hbWUgdGhhdCB0aGlzIENTU1Byb3BUd2VlbiBzaG91bGQgYmUgYXNzb2NpYXRlZCB0byAodXN1YWxseSB0aGUgc2FtZSBhcyBwLCBidXQgbm90IGFsd2F5cyAtIG4gaXMgd2hhdCBvdmVyd3JpdGluZyBsb29rcyBhdClcblx0XHRcdFx0aWYgKCEodCBpbnN0YW5jZW9mIENTU1Byb3BUd2VlbikpIHtcblx0XHRcdFx0XHRfb3ZlcndyaXRlUHJvcHMucHVzaCh0aGlzLm4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuciA9IHI7IC8vcm91bmQgKGJvb2xlYW4pXG5cdFx0XHRcdHRoaXMudHlwZSA9IHR5cGUgfHwgMDsgLy8wID0gbm9ybWFsIHR3ZWVuLCAtMSA9IG5vbi10d2VlbmluZyAoaW4gd2hpY2ggY2FzZSB4czAgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSB0YXJnZXQncyBwcm9wZXJ0eSwgbGlrZSB0cC50W3RwLnBdID0gdHAueHMwKSwgMSA9IGNvbXBsZXgtdmFsdWUgU3BlY2lhbFByb3AsIDIgPSBjdXN0b20gc2V0UmF0aW8oKSB0aGF0IGRvZXMgYWxsIHRoZSB3b3JrXG5cdFx0XHRcdGlmIChwcikge1xuXHRcdFx0XHRcdHRoaXMucHIgPSBwcjtcblx0XHRcdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYiA9IChiID09PSB1bmRlZmluZWQpID8gcyA6IGI7XG5cdFx0XHRcdHRoaXMuZSA9IChlID09PSB1bmRlZmluZWQpID8gcyArIGMgOiBlO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdHRoaXMuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRha2VzIGEgdGFyZ2V0LCB0aGUgYmVnaW5uaW5nIHZhbHVlIGFuZCBlbmRpbmcgdmFsdWUgKGFzIHN0cmluZ3MpIGFuZCBwYXJzZXMgdGhlbSBpbnRvIGEgQ1NTUHJvcFR3ZWVuIChwb3NzaWJseSB3aXRoIGNoaWxkIENTU1Byb3BUd2VlbnMpIHRoYXQgYWNjb21tb2RhdGVzIG11bHRpcGxlIG51bWJlcnMsIGNvbG9ycywgY29tbWEtZGVsaW1pdGVkIHZhbHVlcywgZXRjLiBGb3IgZXhhbXBsZTpcblx0XHRcdCAqIHNwLnBhcnNlQ29tcGxleChlbGVtZW50LCBcImJveFNoYWRvd1wiLCBcIjVweCAxMHB4IDIwcHggcmdiKDI1NSwxMDIsNTEpXCIsIFwiMHB4IDBweCAwcHggcmVkXCIsIHRydWUsIFwiMHB4IDBweCAwcHggcmdiKDAsMCwwLDApXCIsIHB0KTtcblx0XHRcdCAqIEl0IHdpbGwgd2FsayB0aHJvdWdoIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBmb3JtYXQgd2l0aCB0aGUgc2FtZSBudW1iZXIgYW5kIHR5cGUgb2YgdmFsdWVzKSBhbmQgZmlndXJlIG91dCB3aGljaCBwYXJ0cyBhcmUgbnVtYmVycywgd2hhdCBzdHJpbmdzIHNlcGFyYXRlIHRoZSBudW1lcmljL3R3ZWVuYWJsZSB2YWx1ZXMsIGFuZCB0aGVuIGNyZWF0ZSB0aGUgQ1NTUHJvcFR3ZWVucyBhY2NvcmRpbmdseS4gSWYgYSBwbHVnaW4gaXMgZGVmaW5lZCwgbm8gY2hpbGQgQ1NTUHJvcFR3ZWVucyB3aWxsIGJlIGNyZWF0ZWQuIEluc3RlYWQsIHRoZSBlbmRpbmcgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBcImRhdGFcIiBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgQ1NTUHJvcFR3ZWVuIGxpa2U6IHtzOi01LCB4bjE6LTEwLCB4bjI6LTIwLCB4bjM6MjU1LCB4bjQ6MCwgeG41OjB9IHNvIHRoYXQgaXQgY2FuIGJlIGZlZCB0byBhbnkgb3RoZXIgcGx1Z2luIGFuZCBpdCdsbCBiZSBwbGFpbiBudW1lcmljIHR3ZWVucyBidXQgdGhlIHJlY29tcG9zaXRpb24gb2YgdGhlIGNvbXBsZXggdmFsdWUgd2lsbCBiZSBoYW5kbGVkIGluc2lkZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpLlxuXHRcdFx0ICogSWYgYSBzZXRSYXRpbyBpcyBkZWZpbmVkLCB0aGUgdHlwZSBvZiB0aGUgQ1NTUHJvcFR3ZWVuIHdpbGwgYmUgc2V0IHRvIDIgYW5kIHJlY29tcG9zaXRpb24gb2YgdGhlIHZhbHVlcyB3aWxsIGJlIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGF0IG1ldGhvZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IHdob3NlIHByb3BlcnR5IHdpbGwgYmUgdHdlZW5lZFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IHRoYXQgd2lsbCBiZSB0d2VlbmVkIChpdHMgbmFtZSwgbGlrZSBcImxlZnRcIiBvciBcImJhY2tncm91bmRDb2xvclwiIG9yIFwiYm94U2hhZG93XCIpXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYiBCZWdpbm5pbmcgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBlIEVuZGluZyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBjbHJzIElmIHRydWUsIHRoZSB2YWx1ZSBjb3VsZCBjb250YWluIGEgY29sb3IgdmFsdWUgbGlrZSBcInJnYigyNTUsMCwwKVwiIG9yIFwiI0YwMFwiIG9yIFwicmVkXCIuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLCBzbyBubyBjb2xvcnMgd2lsbCBiZSByZWNvZ25pemVkIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcblx0XHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8T2JqZWN0KX0gZGZsdCBUaGUgZGVmYXVsdCBiZWdpbm5pbmcgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBpZiBubyB2YWxpZCBiZWdpbm5pbmcgdmFsdWUgaXMgZGVmaW5lZCBvciBpZiB0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbnNpZGUgdGhlIGNvbXBsZXggYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGRvbid0IG1hdGNoXG5cdFx0XHQgKiBAcGFyYW0gez9DU1NQcm9wVHdlZW59IHB0IENTU1Byb3BUd2VlbiBpbnN0YW5jZSB0aGF0IGlzIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIGxpbmtlZCBsaXN0ICh3ZSdsbCBwcmVwZW5kIHRvIHRoaXMpLlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwciBQcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gSWYgYSBwbHVnaW4gc2hvdWxkIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgZXh0cmEgcHJvcGVydGllcywgcGFzcyB0aGUgcGx1Z2luIGluc3RhbmNlIGhlcmUuIElmIG9uZSBpcyBkZWZpbmVkLCB0aGVuIE5PIHN1YnR3ZWVucyB3aWxsIGJlIGNyZWF0ZWQgZm9yIGFueSBleHRyYSBwcm9wZXJ0aWVzICh0aGUgcHJvcGVydGllcyB3aWxsIGJlIGNyZWF0ZWQgLSBqdXN0IG5vdCBhZGRpdGlvbmFsIENTU1Byb3BUd2VlbiBpbnN0YW5jZXMgdG8gdHdlZW4gdGhlbSkgYmVjYXVzZSB0aGUgcGx1Z2luIGlzIGV4cGVjdGVkIHRvIGRvIHNvLiBIb3dldmVyLCB0aGUgZW5kIHZhbHVlcyBXSUxMIGJlIHBvcHVsYXRlZCBpbiB0aGUgXCJkYXRhXCIgcHJvcGVydHksIGxpa2Uge3M6MTAwLCB4bjE6NTAsIHhuMjozMDB9XG5cdFx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik9fSBzZXRSYXRpbyBJZiB2YWx1ZXMgc2hvdWxkIGJlIHNldCBpbiBhIGN1c3RvbSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGJlaW5nIHBpZWNlZCB0b2dldGhlciBpbiBhIHR5cGU6MSAoY29tcGxleC12YWx1ZSkgQ1NTUHJvcFR3ZWVuLCBkZWZpbmUgdGhhdCBjdXN0b20gZnVuY3Rpb24gaGVyZS5cblx0XHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gVGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Qgd2hpY2ggaW5jbHVkZXMgdGhlIG5ldyBvbmUocykgYWRkZWQgYnkgdGhlIHBhcnNlQ29tcGxleCgpIGNhbGwuXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNvbXBsZXggPSBDU1NQbHVnaW4ucGFyc2VDb21wbGV4ID0gZnVuY3Rpb24odCwgcCwgYiwgZSwgY2xycywgZGZsdCwgcHQsIHByLCBwbHVnaW4sIHNldFJhdGlvKSB7XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZUNvbXBsZXg6IFwiK3ArXCIsIGI6IFwiK2IrXCIsIGU6IFwiK2UpO1xuXHRcdFx0XHRiID0gYiB8fCBkZmx0IHx8IFwiXCI7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgKHNldFJhdGlvID8gMiA6IDEpLCBudWxsLCBmYWxzZSwgcHIsIGIsIGUpO1xuXHRcdFx0XHRlICs9IFwiXCI7IC8vZW5zdXJlcyBpdCdzIGEgc3RyaW5nXG5cdFx0XHRcdHZhciBiYSA9IGIuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksIC8vYmVnaW5uaW5nIGFycmF5XG5cdFx0XHRcdFx0ZWEgPSBlLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2VuZGluZyBhcnJheVxuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGgsXG5cdFx0XHRcdFx0YXV0b1JvdW5kID0gKF9hdXRvUm91bmQgIT09IGZhbHNlKSxcblx0XHRcdFx0XHRpLCB4aSwgbmksIGJ2LCBldiwgYm51bXMsIGVudW1zLCBibiwgcmdiYSwgdGVtcCwgY3YsIHN0cjtcblx0XHRcdFx0aWYgKGUuaW5kZXhPZihcIixcIikgIT09IC0xIHx8IGIuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0YmEgPSBiYS5qb2luKFwiIFwiKS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGVhID0gZWEuam9pbihcIiBcIikucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcIiwgXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsICE9PSBlYS5sZW5ndGgpIHtcblx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibWlzbWF0Y2hlZCBmb3JtYXR0aW5nIGRldGVjdGVkIG9uIFwiICsgcCArIFwiIChcIiArIGIgKyBcIiB2cyBcIiArIGUgKyBcIilcIik7XG5cdFx0XHRcdFx0YmEgPSAoZGZsdCB8fCBcIlwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gc2V0UmF0aW87XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRidiA9IGJhW2ldO1xuXHRcdFx0XHRcdGV2ID0gZWFbaV07XG5cdFx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJ2KTtcblx0XHRcdFx0XHQvL2lmIHRoZSB2YWx1ZSBiZWdpbnMgd2l0aCBhIG51bWJlciAobW9zdCBjb21tb24pLiBJdCdzIGZpbmUgaWYgaXQgaGFzIGEgc3VmZml4IGxpa2UgcHhcblx0XHRcdFx0XHRpZiAoYm4gfHwgYm4gPT09IDApIHtcblx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoXCJcIiwgYm4sIF9wYXJzZUNoYW5nZShldiwgYm4pLCBldi5yZXBsYWNlKF9yZWxOdW1FeHAsIFwiXCIpLCAoYXV0b1JvdW5kICYmIGV2LmluZGV4T2YoXCJweFwiKSAhPT0gLTEpLCB0cnVlKTtcblxuXHRcdFx0XHRcdC8vaWYgdGhlIHZhbHVlIGlzIGEgY29sb3Jcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNscnMgJiYgKGJ2LmNoYXJBdCgwKSA9PT0gXCIjXCIgfHwgX2NvbG9yTG9va3VwW2J2XSB8fCBfcmdiaHNsRXhwLnRlc3QoYnYpKSkge1xuXHRcdFx0XHRcdFx0c3RyID0gZXYuY2hhckF0KGV2Lmxlbmd0aCAtIDEpID09PSBcIixcIiA/IFwiKSxcIiA6IFwiKVwiOyAvL2lmIHRoZXJlJ3MgYSBjb21tYSBhdCB0aGUgZW5kLCByZXRhaW4gaXQuXG5cdFx0XHRcdFx0XHRidiA9IF9wYXJzZUNvbG9yKGJ2KTtcblx0XHRcdFx0XHRcdGV2ID0gX3BhcnNlQ29sb3IoZXYpO1xuXHRcdFx0XHRcdFx0cmdiYSA9IChidi5sZW5ndGggKyBldi5sZW5ndGggPiA2KTtcblx0XHRcdFx0XHRcdGlmIChyZ2JhICYmICFfc3VwcG9ydHNPcGFjaXR5ICYmIGV2WzNdID09PSAwKSB7IC8vb2xkZXIgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCksIHNvIGlmIHRoZSBkZXN0aW5hdGlvbiBhbHBoYSBpcyAwLCBqdXN0IHVzZSBcInRyYW5zcGFyZW50XCIgZm9yIHRoZSBlbmQgY29sb3Jcblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gcHQubCA/IFwiIHRyYW5zcGFyZW50XCIgOiBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdFx0XHRcdHB0LmUgPSBwdC5lLnNwbGl0KGVhW2ldKS5qb2luKFwidHJhbnNwYXJlbnRcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIHsgLy9vbGQgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCkuXG5cdFx0XHRcdFx0XHRcdFx0cmdiYSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoKHJnYmEgPyBcInJnYmEoXCIgOiBcInJnYihcIiksIGJ2WzBdLCBldlswXSAtIGJ2WzBdLCBcIixcIiwgdHJ1ZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kWHRyYShcIlwiLCBidlsxXSwgZXZbMV0gLSBidlsxXSwgXCIsXCIsIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIGV2WzJdIC0gYnZbMl0sIChyZ2JhID8gXCIsXCIgOiBzdHIpLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKHJnYmEpIHtcblx0XHRcdFx0XHRcdFx0XHRidiA9IChidi5sZW5ndGggPCA0KSA/IDEgOiBidlszXTtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKFwiXCIsIGJ2LCAoKGV2Lmxlbmd0aCA8IDQpID8gMSA6IGV2WzNdKSAtIGJ2LCBzdHIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJudW1zID0gYnYubWF0Y2goX251bUV4cCk7IC8vZ2V0cyBlYWNoIGdyb3VwIG9mIG51bWJlcnMgaW4gdGhlIGJlZ2lubmluZyB2YWx1ZSBzdHJpbmcgYW5kIGRyb3BzIHRoZW0gaW50byBhbiBhcnJheVxuXG5cdFx0XHRcdFx0XHQvL2lmIG5vIG51bWJlciBpcyBmb3VuZCwgdHJlYXQgaXQgYXMgYSBub24tdHdlZW5pbmcgdmFsdWUgYW5kIGp1c3QgYXBwZW5kIHRoZSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgeHMuXG5cdFx0XHRcdFx0XHRpZiAoIWJudW1zKSB7XG5cdFx0XHRcdFx0XHRcdHB0W1wieHNcIiArIHB0LmxdICs9IHB0LmwgPyBcIiBcIiArIGJ2IDogYnY7XG5cblx0XHRcdFx0XHRcdC8vbG9vcCB0aHJvdWdoIGFsbCB0aGUgbnVtYmVycyB0aGF0IGFyZSBmb3VuZCBhbmQgY29uc3RydWN0IHRoZSBleHRyYSB2YWx1ZXMgb24gdGhlIHB0LlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW51bXMgPSBldi5tYXRjaChfcmVsTnVtRXhwKTsgLy9nZXQgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBlbmQgdmFsdWUgc3RyaW5nIGFuZCBkcm9wIHRoZW0gaW50byBhbiBhcnJheS4gV2UgYWxsb3cgcmVsYXRpdmUgdmFsdWVzIHRvbywgbGlrZSArPTUwIG9yIC09LjVcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnVtcyB8fCBlbnVtcy5sZW5ndGggIT09IGJudW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJtaXNtYXRjaGVkIGZvcm1hdHRpbmcgZGV0ZWN0ZWQgb24gXCIgKyBwICsgXCIgKFwiICsgYiArIFwiIHZzIFwiICsgZSArIFwiKVwiKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmkgPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHhpID0gMDsgeGkgPCBibnVtcy5sZW5ndGg7IHhpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjdiA9IGJudW1zW3hpXTtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wID0gYnYuaW5kZXhPZihjdiwgbmkpO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoYnYuc3Vic3RyKG5pLCB0ZW1wIC0gbmkpLCBOdW1iZXIoY3YpLCBfcGFyc2VDaGFuZ2UoZW51bXNbeGldLCBjdiksIFwiXCIsIChhdXRvUm91bmQgJiYgYnYuc3Vic3RyKHRlbXAgKyBjdi5sZW5ndGgsIDIpID09PSBcInB4XCIpLCAoeGkgPT09IDApKTtcblx0XHRcdFx0XHRcdFx0XHRuaSA9IHRlbXAgKyBjdi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gYnYuc3Vic3RyKG5pKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgcmVsYXRpdmUgdmFsdWVzIChcIis9XCIgb3IgXCItPVwiIHByZWZpeCksIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBlbmRpbmcgdmFsdWUgdG8gZWxpbWluYXRlIHRoZSBwcmVmaXhlcyBhbmQgY29tYmluZSB0aGUgdmFsdWVzIHByb3Blcmx5LlxuXHRcdFx0XHRpZiAoZS5pbmRleE9mKFwiPVwiKSAhPT0gLTEpIGlmIChwdC5kYXRhKSB7XG5cdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQuZGF0YS5zO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhzXCIgKyBpXSArIHB0LmRhdGFbXCJ4blwiICsgaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LmUgPSBzdHIgKyBwdFtcInhzXCIgKyBpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXB0LmwpIHtcblx0XHRcdFx0XHRwdC50eXBlID0gLTE7XG5cdFx0XHRcdFx0cHQueHMwID0gcHQuZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQueGZpcnN0IHx8IHB0O1xuXHRcdFx0fSxcblx0XHRcdGkgPSA5O1xuXG5cblx0XHRwID0gQ1NTUHJvcFR3ZWVuLnByb3RvdHlwZTtcblx0XHRwLmwgPSBwLnByID0gMDsgLy9sZW5ndGggKG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIGxpa2UgeG4xLCB4bjIsIHhuMywgZXRjLlxuXHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRwW1wieG5cIiArIGldID0gMDtcblx0XHRcdHBbXCJ4c1wiICsgaV0gPSBcIlwiO1xuXHRcdH1cblx0XHRwLnhzMCA9IFwiXCI7XG5cdFx0cC5fbmV4dCA9IHAuX3ByZXYgPSBwLnhmaXJzdCA9IHAuZGF0YSA9IHAucGx1Z2luID0gcC5zZXRSYXRpbyA9IHAucnhwID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogQXBwZW5kcyBhbmQgZXh0cmEgdHdlZW5pbmcgdmFsdWUgdG8gYSBDU1NQcm9wVHdlZW4gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyBhbnkgcHJlZml4IGFuZCBzdWZmaXggc3RyaW5ncy4gVGhlIGZpcnN0IGV4dHJhIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBvZiB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gaW5zdGFuY2UsIGJ1dCB0aGVyZWFmdGVyIGFueSBleHRyYXMgYXJlIHN0b3JlZCBpbiB0aGUgeG4xLCB4bjIsIHhuMywgZXRjLiBUaGUgcHJlZml4ZXMgYW5kIHN1ZmZpeGVzIGFyZSBzdG9yZWQgaW4gdGhlIHhzMCwgeHMxLCB4czIsIGV0Yy4gcHJvcGVydGllcy4gRm9yIGV4YW1wbGUsIGlmIEkgd2FsayB0aHJvdWdoIGEgY2xpcCB2YWx1ZSBsaWtlIFwicmVjdCgxMHB4LCA1cHgsIDBweCwgMjBweClcIiwgdGhlIHZhbHVlcyB3b3VsZCBiZSBzdG9yZWQgbGlrZSB0aGlzOlxuXHRcdCAqIHhzMDpcInJlY3QoXCIsIHM6MTAsIHhzMTpcInB4LCBcIiwgeG4xOjUsIHhzMjpcInB4LCBcIiwgeG4yOjAsIHhzMzpcInB4LCBcIiwgeG4zOjIwLCB4bjQ6XCJweClcIlxuXHRcdCAqIEFuZCB0aGV5J2QgYWxsIGdldCBqb2luZWQgdG9nZXRoZXIgd2hlbiB0aGUgQ1NTUGx1Z2luIHJlbmRlcnMgKGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCkuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBwZnggUHJlZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBzIFN0YXJ0aW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHN0YXJ0IGlzIDUgYW5kIHRoZSBlbmQgaXMgMTAwLCB0aGUgY2hhbmdlIHdvdWxkIGJlIDk1LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2Z4IFN1ZmZpeCAoaWYgYW55KVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgUm91bmQgKGlmIHRydWUpLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhZCBJZiB0cnVlLCB0aGlzIGV4dHJhIHZhbHVlIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgdGhlIHByZXZpb3VzIG9uZSBieSBhIHNwYWNlLiBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBleHRyYSBhbmQgcGFkIGlzIHRydWUsIGl0IHdpbGwgYXV0b21hdGljYWxseSBkcm9wIHRoZSBzcGFjZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IHJldHVybnMgaXRzZWxmIHNvIHRoYXQgbXVsdGlwbGUgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci5cblx0XHQgKi9cblx0XHRwLmFwcGVuZFh0cmEgPSBmdW5jdGlvbihwZngsIHMsIGMsIHNmeCwgciwgcGFkKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLFxuXHRcdFx0XHRsID0gcHQubDtcblx0XHRcdHB0W1wieHNcIiArIGxdICs9IChwYWQgJiYgbCkgPyBcIiBcIiArIHBmeCA6IHBmeCB8fCBcIlwiO1xuXHRcdFx0aWYgKCFjKSBpZiAobCAhPT0gMCAmJiAhcHQucGx1Z2luKSB7IC8vdHlwaWNhbGx5IHdlJ2xsIGNvbWJpbmUgbm9uLWNoYW5naW5nIHZhbHVlcyByaWdodCBpbnRvIHRoZSB4cyB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSwgYnV0IHdlIGRvbid0IGNvbWJpbmUgdGhlbSB3aGVuIHRoZXJlJ3MgYSBwbHVnaW4gdGhhdCB3aWxsIGJlIHR3ZWVuaW5nIHRoZSB2YWx1ZXMgYmVjYXVzZSBpdCBtYXkgZGVwZW5kIG9uIHRoZSB2YWx1ZXMgYmVpbmcgc3BsaXQgYXBhcnQsIGxpa2UgZm9yIGEgYmV6aWVyLCBpZiBhIHZhbHVlIGRvZXNuJ3QgY2hhbmdlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgaXRlcmF0aW9uIGJ1dCB0aGVuIGl0IGRvZXMgb24gdGhlIDNyZCwgd2UnbGwgcnVuIGludG8gdHJvdWJsZSBiZWNhdXNlIHRoZXJlJ3Mgbm8geG4gc2xvdCBmb3IgdGhhdCB2YWx1ZSFcblx0XHRcdFx0cHRbXCJ4c1wiICsgbF0gKz0gcyArIChzZnggfHwgXCJcIik7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHRcdHB0LmwrKztcblx0XHRcdHB0LnR5cGUgPSBwdC5zZXRSYXRpbyA/IDIgOiAxO1xuXHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gPSBzZnggfHwgXCJcIjtcblx0XHRcdGlmIChsID4gMCkge1xuXHRcdFx0XHRwdC5kYXRhW1wieG5cIiArIGxdID0gcyArIGM7XG5cdFx0XHRcdHB0LnJ4cFtcInhuXCIgKyBsXSA9IHI7IC8vcm91bmQgZXh0cmEgcHJvcGVydHkgKHdlIG5lZWQgdG8gdGFwIGludG8gdGhpcyBpbiB0aGUgX3BhcnNlVG9Qcm94eSgpIG1ldGhvZClcblx0XHRcdFx0cHRbXCJ4blwiICsgbF0gPSBzO1xuXHRcdFx0XHRpZiAoIXB0LnBsdWdpbikge1xuXHRcdFx0XHRcdHB0LnhmaXJzdCA9IG5ldyBDU1NQcm9wVHdlZW4ocHQsIFwieG5cIiArIGwsIHMsIGMsIHB0LnhmaXJzdCB8fCBwdCwgMCwgcHQubiwgciwgcHQucHIpO1xuXHRcdFx0XHRcdHB0LnhmaXJzdC54czAgPSAwOyAvL2p1c3QgdG8gZW5zdXJlIHRoYXQgdGhlIHByb3BlcnR5IHN0YXlzIG51bWVyaWMgd2hpY2ggaGVscHMgbW9kZXJuIGJyb3dzZXJzIHNwZWVkIHVwIHByb2Nlc3NpbmcuIFJlbWVtYmVyLCBpbiB0aGUgc2V0UmF0aW8oKSBtZXRob2QsIHdlIGRvIHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czAgc28gaWYgcHQueHMwIGlzIFwiXCIgKHRoZSBkZWZhdWx0KSwgaXQnbGwgY2FzdCB0aGUgZW5kIHZhbHVlIGFzIGEgc3RyaW5nLiBXaGVuIGEgcHJvcGVydHkgaXMgYSBudW1iZXIgc29tZXRpbWVzIGFuZCBhIHN0cmluZyBzb21ldGltZXMsIGl0IHByZXZlbnRzIHRoZSBjb21waWxlciBmcm9tIGxvY2tpbmcgaW4gdGhlIGRhdGEgdHlwZSwgc2xvd2luZyB0aGluZ3MgZG93biBzbGlnaHRseS5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0XHRwdC5kYXRhID0ge3M6cyArIGN9O1xuXHRcdFx0cHQucnhwID0ge307XG5cdFx0XHRwdC5zID0gcztcblx0XHRcdHB0LmMgPSBjO1xuXHRcdFx0cHQuciA9IHI7XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEBjb25zdHJ1Y3RvciBBIFNwZWNpYWxQcm9wIGlzIGJhc2ljYWxseSBhIGNzcyBwcm9wZXJ0eSB0aGF0IG5lZWRzIHRvIGJlIHRyZWF0ZWQgaW4gYSBub24tc3RhbmRhcmQgd2F5LCBsaWtlIGlmIGl0IG1heSBjb250YWluIGEgY29tcGxleCB2YWx1ZSBsaWtlIGJveFNoYWRvdzpcIjVweCAxMHB4IDE1cHggcmdiKDI1NSwgMTAyLCA1MSlcIiBvciBpZiBpdCBpcyBhc3NvY2lhdGVkIHdpdGggYW5vdGhlciBwbHVnaW4gbGlrZSBUaHJvd1Byb3BzUGx1Z2luIG9yIEJlemllclBsdWdpbi4gRXZlcnkgU3BlY2lhbFByb3AgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciBwcm9wZXJ0eSBuYW1lIGxpa2UgXCJib3hTaGFkb3dcIiBvciBcInRocm93UHJvcHNcIiBvciBcImJlemllclwiIGFuZCBpdCB3aWxsIGludGVyY2VwdCB0aG9zZSB2YWx1ZXMgaW4gdGhlIHZhcnMgb2JqZWN0IHRoYXQncyBwYXNzZWQgdG8gdGhlIENTU1BsdWdpbiBhbmQgaGFuZGxlIHRoZW0gYWNjb3JkaW5nbHkuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJib3hTaGFkb3dcIiBvciBcInRocm93UHJvcHNcIilcblx0XHQgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZmlndXJhdGlvbiBvcHRpb25zOlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gZGVmYXVsdFZhbHVlOiB0aGUgZGVmYXVsdCB2YWx1ZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VyOiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IG5hbWUgaXMgZm91bmQgaW4gdGhlIHZhcnMuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIENTU1Byb3BUd2VlbiBpbnN0YW5jZSBhbmQgaXQgc2hvdWxkIGVuc3VyZSB0aGF0IGl0IGlzIHByb3Blcmx5IGluc2VydGVkIGludG8gdGhlIGxpbmtlZCBsaXN0LiBJdCB3aWxsIHJlY2VpdmUgNCBwYXJhbXRlcnM6IDEpIFRoZSB0YXJnZXQsIDIpIFRoZSB2YWx1ZSBkZWZpbmVkIGluIHRoZSB2YXJzLCAzKSBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlICh3aG9zZSBfZmlyc3RQVCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGxpbmtlZCBsaXN0KSwgYW5kIDQpIEEgY29tcHV0ZWQgc3R5bGUgb2JqZWN0IGlmIG9uZSB3YXMgY2FsY3VsYXRlZCAodGhpcyBpcyBhIHNwZWVkIG9wdGltaXphdGlvbiB0aGF0IGFsbG93cyByZXRyaWV2YWwgb2Ygc3RhcnRpbmcgdmFsdWVzIHF1aWNrZXIpXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBmb3JtYXR0ZXI6IGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGFueSB2YWx1ZSByZWNlaXZlZCBmb3IgdGhpcyBzcGVjaWFsIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgYm94U2hhZG93IGNvdWxkIHRha2UgXCI1cHggNXB4IHJlZFwiIGFuZCBmb3JtYXQgaXQgdG8gXCI1cHggNXB4IDBweCAwcHggcmVkXCIgc28gdGhhdCBib3RoIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgaGF2ZSBhIGNvbW1vbiBvcmRlciBhbmQgcXVhbnRpdHkgb2YgdmFsdWVzLilcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHByZWZpeDogaWYgdHJ1ZSwgd2UnbGwgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoaXMgcHJvcGVydHkgcmVxdWlyZXMgYSB2ZW5kb3IgcHJlZml4IChsaWtlIFdlYmtpdCBvciBNb3ogb3IgbXMgb3IgTylcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGNvbG9yOiBzZXQgdGhpcyB0byB0cnVlIGlmIHRoZSB2YWx1ZSBmb3IgdGhpcyBTcGVjaWFsUHJvcCBtYXkgY29udGFpbiBjb2xvci1yZWxhdGVkIHZhbHVlcyBsaWtlIHJnYigpLCByZ2JhKCksIGV0Yy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHByaW9yaXR5OiBwcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBTcGVjaWFsUHJvcHMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gbXVsdGk6IGlmIHRydWUsIHRoZSBmb3JtYXR0ZXIgc2hvdWxkIGFjY29tbW9kYXRlIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzLCBsaWtlIGJveFNoYWRvdyBjb3VsZCBoYXZlIG11bHRpcGxlIGJveFNoYWRvd3MgbGlzdGVkIG91dC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGNvbGxhcHNpYmxlOiBpZiB0cnVlLCB0aGUgZm9ybWF0dGVyIHNob3VsZCB0cmVhdCB0aGUgdmFsdWUgbGlrZSBpdCdzIGEgdG9wL3JpZ2h0L2JvdHRvbS9sZWZ0IHZhbHVlIHRoYXQgY291bGQgYmUgY29sbGFwc2VkLCBsaWtlIFwiNXB4XCIgd291bGQgYXBwbHkgdG8gYWxsLCBcIjVweCwgMTBweFwiIHdvdWxkIHVzZSA1cHggZm9yIHRvcC9ib3R0b20gYW5kIDEwcHggZm9yIHJpZ2h0L2xlZnQsIGV0Yy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGtleXdvcmQ6IGEgc3BlY2lhbCBrZXl3b3JkIHRoYXQgY2FuIFtvcHRpb25hbGx5XSBiZSBmb3VuZCBpbnNpZGUgdGhlIHZhbHVlIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KS4gVGhpcyBhbGxvd3MgdXMgdG8gdmFsaWRhdGUgYmVnaW5uaW5nL2VuZGluZyB2YWx1ZXMgdG8gbWFrZSBzdXJlIHRoZXkgbWF0Y2ggKGlmIHRoZSBrZXl3b3JkIGlzIGZvdW5kIGluIG9uZSwgaXQnbGwgYmUgYWRkZWQgdG8gdGhlIG90aGVyIGZvciBjb25zaXN0ZW5jeSBieSBkZWZhdWx0KS5cblx0XHQgKi9cblx0XHR2YXIgU3BlY2lhbFByb3AgPSBmdW5jdGlvbihwLCBvcHRpb25zKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0XHR0aGlzLnAgPSBvcHRpb25zLnByZWZpeCA/IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcCA6IHA7XG5cdFx0XHRcdF9zcGVjaWFsUHJvcHNbcF0gPSBfc3BlY2lhbFByb3BzW3RoaXMucF0gPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IF9nZXRGb3JtYXR0ZXIob3B0aW9ucy5kZWZhdWx0VmFsdWUsIG9wdGlvbnMuY29sb3IsIG9wdGlvbnMuY29sbGFwc2libGUsIG9wdGlvbnMubXVsdGkpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5wYXJzZXIpIHtcblx0XHRcdFx0XHR0aGlzLnBhcnNlID0gb3B0aW9ucy5wYXJzZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jbHJzID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdFx0dGhpcy5tdWx0aSA9IG9wdGlvbnMubXVsdGk7XG5cdFx0XHRcdHRoaXMua2V5d29yZCA9IG9wdGlvbnMua2V5d29yZDtcblx0XHRcdFx0dGhpcy5kZmx0ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdHRoaXMucHIgPSBvcHRpb25zLnByaW9yaXR5IHx8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3Nob3J0Y3V0IGZvciBjcmVhdGluZyBhIG5ldyBTcGVjaWFsUHJvcCB0aGF0IGNhbiBhY2NlcHQgbXVsdGlwbGUgcHJvcGVydGllcyBhcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IChoZWxwcyBtaW5pZmljYXRpb24pLiBkZmx0IGNhbiBiZSBhbiBhcnJheSBmb3IgbXVsdGlwbGUgdmFsdWVzICh3ZSBkb24ndCBkbyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IGJlY2F1c2UgdGhlIGRlZmF1bHQgdmFsdWUgbWF5IGNvbnRhaW4gY29tbWFzLCBsaWtlIHJlY3QoMHB4LDBweCwwcHgsMHB4KSkuIFdlIGF0dGFjaCB0aGlzIG1ldGhvZCB0byB0aGUgU3BlY2lhbFByb3AgY2xhc3Mvb2JqZWN0IGluc3RlYWQgb2YgdXNpbmcgYSBwcml2YXRlIF9jcmVhdGVTcGVjaWFsUHJvcCgpIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiB0YXAgaW50byBpdCBleHRlcm5hbGx5IGlmIG5lY2Vzc2FyeSwgbGlrZSBmcm9tIGFub3RoZXIgcGx1Z2luLlxuXHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wID0gX2ludGVybmFscy5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AgPSBmdW5jdGlvbihwLCBvcHRpb25zLCBkZWZhdWx0cykge1xuXHRcdFx0XHRpZiAodHlwZW9mKG9wdGlvbnMpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHtwYXJzZXI6ZGVmYXVsdHN9OyAvL3RvIG1ha2UgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBCZXppZXJQbHVnaW4gYW5kIFRocm93UHJvcHNQbHVnaW5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYSA9IHAuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGQgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZSxcblx0XHRcdFx0XHRpLCB0ZW1wO1xuXHRcdFx0XHRkZWZhdWx0cyA9IGRlZmF1bHRzIHx8IFtkXTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvcHRpb25zLnByZWZpeCA9IChpID09PSAwICYmIG9wdGlvbnMucHJlZml4KTtcblx0XHRcdFx0XHRvcHRpb25zLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRzW2ldIHx8IGQ7XG5cdFx0XHRcdFx0dGVtcCA9IG5ldyBTcGVjaWFsUHJvcChhW2ldLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly9jcmVhdGVzIGEgcGxhY2Vob2xkZXIgc3BlY2lhbCBwcm9wIGZvciBhIHBsdWdpbiBzbyB0aGF0IHRoZSBwcm9wZXJ0eSBnZXRzIGNhdWdodCB0aGUgZmlyc3QgdGltZSBhIHR3ZWVuIG9mIGl0IGlzIGF0dGVtcHRlZCwgYW5kIGF0IHRoYXQgdGltZSBpdCBtYWtlcyB0aGUgcGx1Z2luIHJlZ2lzdGVyIGl0c2VsZiwgdGh1cyB0YWtpbmcgb3ZlciBmb3IgYWxsIGZ1dHVyZSB0d2VlbnMgb2YgdGhhdCBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgdXMgdG8gbm90IG1hbmRhdGUgdGhhdCB0aGluZ3MgbG9hZCBpbiBhIHBhcnRpY3VsYXIgb3JkZXIgYW5kIGl0IGFsc28gYWxsb3dzIHVzIHRvIGxvZygpIGFuIGVycm9yIHRoYXQgaW5mb3JtcyB0aGUgdXNlciB3aGVuIHRoZXkgYXR0ZW1wdCB0byB0d2VlbiBhbiBleHRlcm5hbCBwbHVnaW4tcmVsYXRlZCBwcm9wZXJ0eSB3aXRob3V0IGxvYWRpbmcgaXRzIC5qcyBmaWxlLlxuXHRcdFx0X3JlZ2lzdGVyUGx1Z2luUHJvcCA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKCFfc3BlY2lhbFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0dmFyIHBsdWdpbk5hbWUgPSBwLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcC5zdWJzdHIoMSkgKyBcIlBsdWdpblwiO1xuXHRcdFx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChwLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0XHRcdHZhciBwbHVnaW5DbGFzcyA9IF9nbG9iYWxzLmNvbS5ncmVlbnNvY2sucGx1Z2luc1twbHVnaW5OYW1lXTtcblx0XHRcdFx0XHRcdGlmICghcGx1Z2luQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0X2xvZyhcIkVycm9yOiBcIiArIHBsdWdpbk5hbWUgKyBcIiBqcyBmaWxlIG5vdCBsb2FkZWQuXCIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwbHVnaW5DbGFzcy5fY3NzUmVnaXN0ZXIoKTtcblx0XHRcdFx0XHRcdHJldHVybiBfc3BlY2lhbFByb3BzW3BdLnBhcnNlKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpO1xuXHRcdFx0XHRcdH19KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXG5cdFx0cCA9IFNwZWNpYWxQcm9wLnByb3RvdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIEFsaWFzIGZvciBfcGFyc2VDb21wbGV4KCkgdGhhdCBhdXRvbWF0aWNhbGx5IHBsdWdzIGluIGNlcnRhaW4gdmFsdWVzIGZvciB0aGlzIFNwZWNpYWxQcm9wLCBsaWtlIGl0cyBwcm9wZXJ0eSBuYW1lLCB3aGV0aGVyIG9yIG5vdCBjb2xvcnMgc2hvdWxkIGJlIHNlbnNlZCwgdGhlIGRlZmF1bHQgdmFsdWUsIGFuZCBwcmlvcml0eS4gSXQgYWxzbyBsb29rcyBmb3IgYW55IGtleXdvcmQgdGhhdCB0aGUgU3BlY2lhbFByb3AgZGVmaW5lcyAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykgYW5kIGVuc3VyZXMgdGhhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHZhbHVlcyBmb3IgU3BlY2lhbFByb3BzIHdoZXJlIG11bHRpIGlzIHRydWUgKGxpa2UgYm94U2hhZG93IGFuZCB0ZXh0U2hhZG93IGNhbiBoYXZlIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QpXG5cdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxvYmplY3QpfSBiIGJlZ2lubmluZyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8b2JqZWN0KX0gZSBlbmRpbmcgKGRlc3RpbmF0aW9uKSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gcHQgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhbm90aGVyIHBsdWdpbiB3aWxsIGJlIHR3ZWVuaW5nIHRoZSBjb21wbGV4IHZhbHVlLCB0aGF0IFR3ZWVuUGx1Z2luIGluc3RhbmNlIGdvZXMgaGVyZS5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gc2V0UmF0aW8gSWYgYSBjdXN0b20gc2V0UmF0aW8oKSBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gaGFuZGxlIHRoaXMgY29tcGxleCB2YWx1ZSwgdGhhdCBnb2VzIGhlcmUuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVuPX0gRmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdCAqL1xuXHRcdHAucGFyc2VDb21wbGV4ID0gZnVuY3Rpb24odCwgYiwgZSwgcHQsIHBsdWdpbiwgc2V0UmF0aW8pIHtcblx0XHRcdHZhciBrd2QgPSB0aGlzLmtleXdvcmQsXG5cdFx0XHRcdGksIGJhLCBlYSwgbCwgYmksIGVpO1xuXHRcdFx0Ly9pZiB0aGlzIFNwZWNpYWxQcm9wJ3MgdmFsdWUgY2FuIGNvbnRhaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgKGxpa2UgYm94U2hhZG93IG9yIHRleHRTaGFkb3cpLCB3ZSBtdXN0IHBhcnNlIHRoZW0gaW4gYSBzcGVjaWFsIHdheSwgYW5kIGxvb2sgZm9yIGEga2V5d29yZCAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykgYW5kIGVuc3VyZSB0aGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBCT1RIIGhhdmUgaXQgaWYgdGhlIGVuZCBkZWZpbmVzIGl0IGFzIHN1Y2guIFdlIGFsc28gbXVzdCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgYW4gZXF1YWwgbnVtYmVyIG9mIHZhbHVlcyBzcGVjaWZpZWQgKHdlIGNhbid0IHR3ZWVuIDEgYm94U2hhZG93IHRvIDMgZm9yIGV4YW1wbGUpXG5cdFx0XHRpZiAodGhpcy5tdWx0aSkgaWYgKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdChlKSB8fCBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QoYikpIHtcblx0XHRcdFx0YmEgPSBiLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0ZWEgPSBlLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdH0gZWxzZSBpZiAoa3dkKSB7XG5cdFx0XHRcdGJhID0gW2JdO1xuXHRcdFx0XHRlYSA9IFtlXTtcblx0XHRcdH1cblx0XHRcdGlmIChlYSkge1xuXHRcdFx0XHRsID0gKGVhLmxlbmd0aCA+IGJhLmxlbmd0aCkgPyBlYS5sZW5ndGggOiBiYS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRiID0gYmFbaV0gPSBiYVtpXSB8fCB0aGlzLmRmbHQ7XG5cdFx0XHRcdFx0ZSA9IGVhW2ldID0gZWFbaV0gfHwgdGhpcy5kZmx0O1xuXHRcdFx0XHRcdGlmIChrd2QpIHtcblx0XHRcdFx0XHRcdGJpID0gYi5pbmRleE9mKGt3ZCk7XG5cdFx0XHRcdFx0XHRlaSA9IGUuaW5kZXhPZihrd2QpO1xuXHRcdFx0XHRcdFx0aWYgKGJpICE9PSBlaSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZWkgPT09IC0xKSB7IC8vaWYgdGhlIGtleXdvcmQgaXNuJ3QgaW4gdGhlIGVuZCB2YWx1ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIGJlZ2lubmluZyBvbmUuXG5cdFx0XHRcdFx0XHRcdFx0YmFbaV0gPSBiYVtpXS5zcGxpdChrd2QpLmpvaW4oXCJcIik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYmkgPT09IC0xKSB7IC8vaWYgdGhlIGtleXdvcmQgaXNuJ3QgaW4gdGhlIGJlZ2lubmluZywgYWRkIGl0LlxuXHRcdFx0XHRcdFx0XHRcdGJhW2ldICs9IFwiIFwiICsga3dkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGIgPSBiYS5qb2luKFwiLCBcIik7XG5cdFx0XHRcdGUgPSBlYS5qb2luKFwiLCBcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX3BhcnNlQ29tcGxleCh0LCB0aGlzLnAsIGIsIGUsIHRoaXMuY2xycywgdGhpcy5kZmx0LCBwdCwgdGhpcy5wciwgcGx1Z2luLCBzZXRSYXRpbyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFjY2VwdHMgYSB0YXJnZXQgYW5kIGVuZCB2YWx1ZSBhbmQgc3BpdHMgYmFjayBhIENTU1Byb3BUd2VlbiB0aGF0IGhhcyBiZWVuIGluc2VydGVkIGludG8gdGhlIENTU1BsdWdpbidzIGxpbmtlZCBsaXN0IGFuZCBjb25mb3JtcyB3aXRoIGFsbCB0aGUgY29udmVudGlvbnMgd2UgdXNlIGludGVybmFsbHksIGxpa2UgdHlwZTotMSwgMCwgMSwgb3IgMiwgc2V0dGluZyB1cCBhbnkgZXh0cmEgcHJvcGVydHkgdHdlZW5zLCBwcmlvcml0eSwgZXRjLiBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZSBhIGJveFNoYWRvdyBTcGVjaWFsUHJvcCBhbmQgY2FsbDpcblx0XHQgKiB0aGlzLl9maXJzdFBUID0gc3AucGFyc2UoZWxlbWVudCwgXCI1cHggMTBweCAyMHB4IHJnYigyNTUwLDEwMiw1MSlcIiwgXCJib3hTaGFkb3dcIiwgdGhpcyk7XG5cdFx0ICogSXQgc2hvdWxkIGZpZ3VyZSBvdXQgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIHRoZSBlbGVtZW50J3MgYm94U2hhZG93LCBjb21wYXJlIGl0IHRvIHRoZSBwcm92aWRlZCBlbmQgdmFsdWUgYW5kIGNyZWF0ZSBhbGwgdGhlIG5lY2Vzc2FyeSBDU1NQcm9wVHdlZW5zIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlcyB0byB0d2VlbiB0aGUgYm94U2hhZG93LiBUaGUgQ1NTUHJvcFR3ZWVuIHRoYXQgZ2V0cyBzcGl0IGJhY2sgc2hvdWxkIGFscmVhZHkgYmUgaW5zZXJ0ZWQgaW50byB0aGUgbGlua2VkIGxpc3QgKHRoZSA0dGggcGFyYW1ldGVyIGlzIHRoZSBjdXJyZW50IGhlYWQsIHNvIHByZXBlbmQgdG8gdGhhdCkuXG5cdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgYmVpbmcgdHdlZW5lZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlIEVuZCB2YWx1ZSBhcyBwcm92aWRlZCBpbiB0aGUgdmFycyBvYmplY3QgKHR5cGljYWxseSBhIHN0cmluZywgYnV0IG5vdCBhbHdheXMgLSBsaWtlIGEgdGhyb3dQcm9wcyB3b3VsZCBiZSBhbiBvYmplY3QpLlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lXG5cdFx0ICogQHBhcmFtIHshQ1NTUGx1Z2lufSBjc3NwIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2UgdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHdlZW4uXG5cdFx0ICogQHBhcmFtIHs/Q1NTUHJvcFR3ZWVufSBwdCBUaGUgQ1NTUHJvcFR3ZWVuIHRoYXQgaXMgdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgbGlua2VkIGxpc3QgKHdlJ2xsIHByZXBlbmQgdG8gaXQpXG5cdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhIHBsdWdpbiB3aWxsIGJlIHVzZWQgdG8gdHdlZW4gdGhlIHBhcnNlZCB2YWx1ZSwgdGhpcyBpcyB0aGUgcGx1Z2luIGluc3RhbmNlLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gdmFycyBPcmlnaW5hbCB2YXJzIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIGZvciBwYXJzaW5nLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gVGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Qgd2hpY2ggaW5jbHVkZXMgdGhlIG5ldyBvbmUocykgYWRkZWQgYnkgdGhlIHBhcnNlKCkgY2FsbC5cblx0XHQgKi9cblx0XHRwLnBhcnNlID0gZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCB0aGlzLnAsIF9jcywgZmFsc2UsIHRoaXMuZGZsdCkpLCB0aGlzLmZvcm1hdChlKSwgcHQsIHBsdWdpbik7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgaW50ZXJjZXB0ZWQgZnJvbSBhbnkgXCJjc3NcIiBvYmplY3RzIGRlZmluZWQgaW4gdHdlZW5zLiBUaGlzIGFsbG93cyB5b3UgdG8gaGFuZGxlIHRoZW0gaG93ZXZlciB5b3Ugd2FudCB3aXRob3V0IENTU1BsdWdpbiBkb2luZyBpdCBmb3IgeW91LiBUaGUgMm5kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgMyBwYXJhbWV0ZXJzOlxuXHRcdCAqICAxKSBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHNob3VsZCBiZSB0d2VlbmVkICh0eXBpY2FsbHkgYSBET00gZWxlbWVudClcblx0XHQgKiAgMikgVGhlIGVuZC9kZXN0aW5hdGlvbiB2YWx1ZSAoY291bGQgYmUgYSBzdHJpbmcsIG51bWJlciwgb2JqZWN0LCBvciB3aGF0ZXZlciB5b3Ugd2FudClcblx0XHQgKiAgMykgVGhlIHR3ZWVuIGluc3RhbmNlICh5b3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGlzLCBidXQgaXQgY2FuIGJlIHVzZWZ1bCBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBsaWtlIHRoZSBkdXJhdGlvbilcblx0XHQgKlxuXHRcdCAqIFRoZW4sIHlvdXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGVhY2ggdGltZSB0aGUgdHdlZW4gZ2V0cyByZW5kZXJlZCwgcGFzc2luZyBhIG51bWVyaWMgXCJyYXRpb1wiIHBhcmFtZXRlciB0byB5b3VyIGZ1bmN0aW9uIHRoYXQgaW5kaWNhdGVzIHRoZSBjaGFuZ2UgZmFjdG9yICh1c3VhbGx5IGJldHdlZW4gMCBhbmQgMSkuIEZvciBleGFtcGxlOlxuXHRcdCAqXG5cdFx0ICogQ1NTUGx1Z2luLnJlZ2lzdGVyU3BlY2lhbFByb3AoXCJteUN1c3RvbVByb3BcIiwgZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHQgKiAgICAgIHZhciBzdGFydCA9IHRhcmdldC5zdHlsZS53aWR0aDtcblx0XHQgKiAgICAgIHJldHVybiBmdW5jdGlvbihyYXRpbykge1xuXHRcdCAqICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSAoc3RhcnQgKyB2YWx1ZSAqIHJhdGlvKSArIFwicHhcIjtcblx0XHQgKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZXQgd2lkdGggdG8gXCIgKyB0YXJnZXQuc3R5bGUud2lkdGgpO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiB9LCAwKTtcblx0XHQgKlxuXHRcdCAqIFRoZW4sIHdoZW4gSSBkbyB0aGlzIHR3ZWVuLCBpdCB3aWxsIHRyaWdnZXIgbXkgc3BlY2lhbCBwcm9wZXJ0eTpcblx0XHQgKlxuXHRcdCAqIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntteUN1c3RvbVByb3A6MTAwfX0pO1xuXHRcdCAqXG5cdFx0ICogSW4gdGhlIGV4YW1wbGUsIG9mIGNvdXJzZSwgd2UncmUganVzdCBjaGFuZ2luZyB0aGUgd2lkdGgsIGJ1dCB5b3UgY2FuIGRvIGFueXRoaW5nIHlvdSB3YW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgKG9yIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzKSB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZCBhbmQgaGFuZGxlZCBieSB5b3VyIGZ1bmN0aW9uLiBGb3IgZXhhbXBsZSwgaWYgSSBkZWZpbmUgXCJteUN1c3RvbVByb3BcIiwgdGhlbiBpdCB3b3VsZCBoYW5kbGUgdGhhdCBwb3J0aW9uIG9mIHRoZSBmb2xsb3dpbmcgdHdlZW46IFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntteUN1c3RvbVByb3A6MTAwfX0pXG5cdFx0ICogQHBhcmFtIHshZnVuY3Rpb24oT2JqZWN0LCBPYmplY3QsIE9iamVjdCwgc3RyaW5nKTpmdW5jdGlvbihudW1iZXIpfSBvbkluaXRUd2VlbiBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdHdlZW4gb2YgdGhpcyBzcGVjaWFsIHByb3BlcnR5IGlzIHBlcmZvcm1lZC4gVGhlIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSA0IHBhcmFtZXRlcnM6IDEpIFRhcmdldCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdHdlZW5lZCwgMikgVmFsdWUgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSB0d2VlbiwgMykgVGhlIHR3ZWVuIGluc3RhbmNlIGl0c2VsZiAocmFyZWx5IHVzZWQpLCBhbmQgNCkgVGhlIHByb3BlcnR5IG5hbWUgdGhhdCdzIGJlaW5nIHR3ZWVuZWQuIFlvdXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUgb2YgdGhlIHR3ZWVuLiBUaGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhIHNpbmdsZSBwYXJhbWV0ZXIgdGhhdCBpcyBhIFwiY2hhbmdlIGZhY3RvclwiIHZhbHVlICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2YgY2hhbmdlIGFzIGEgcmF0aW8uIFlvdSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhlIHZhbHVlcyBhcHByb3ByaWF0ZWx5IGluIHlvdXIgZnVuY3Rpb24uXG5cdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwcmlvcml0eSBQcmlvcml0eSB0aGF0IGhlbHBzIHRoZSBlbmdpbmUgZGV0ZXJtaW5lIHRoZSBvcmRlciBpbiB3aGljaCB0byBzZXQgdGhlIHByb3BlcnRpZXMgKGRlZmF1bHQ6IDApLiBIaWdoZXIgcHJpb3JpdHkgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuXG5cdFx0ICovXG5cdFx0Q1NTUGx1Z2luLnJlZ2lzdGVyU3BlY2lhbFByb3AgPSBmdW5jdGlvbihuYW1lLCBvbkluaXRUd2VlbiwgcHJpb3JpdHkpIHtcblx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChuYW1lLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0dmFyIHJ2ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgMiwgcCwgZmFsc2UsIHByaW9yaXR5KTtcblx0XHRcdFx0cnYucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRydi5zZXRSYXRpbyA9IG9uSW5pdFR3ZWVuKHQsIGUsIGNzc3AuX3R3ZWVuLCBwKTtcblx0XHRcdFx0cmV0dXJuIHJ2O1xuXHRcdFx0fSwgcHJpb3JpdHk6cHJpb3JpdHl9KTtcblx0XHR9O1xuXG5cblxuXG5cblxuXHRcdC8vdHJhbnNmb3JtLXJlbGF0ZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXHRcdENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyID0gX2lzU2FmYXJpOyAvL1NhZmFyaSBoYXMgc29tZSByZW5kZXJpbmcgYnVncyB3aGVuIGFwcGx5aW5nIENTUyB0cmFuc2Zvcm1zIHRvIFNWRyBlbGVtZW50cywgc28gZGVmYXVsdCB0byB1c2luZyB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUgaW5zdGVhZC5cblx0XHR2YXIgX3RyYW5zZm9ybVByb3BzID0gKFwic2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHosc2tld1gsc2tld1kscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxwZXJzcGVjdGl2ZSx4UGVyY2VudCx5UGVyY2VudFwiKS5zcGxpdChcIixcIiksXG5cdFx0XHRfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoXCJ0cmFuc2Zvcm1cIiksIC8vdGhlIEphdmFzY3JpcHQgKGNhbWVsQ2FzZSkgdHJhbnNmb3JtIHByb3BlcnR5LCBsaWtlIG1zVHJhbnNmb3JtLCBXZWJraXRUcmFuc2Zvcm0sIE1velRyYW5zZm9ybSwgb3IgT1RyYW5zZm9ybS5cblx0XHRcdF90cmFuc2Zvcm1Qcm9wQ1NTID0gX3ByZWZpeENTUyArIFwidHJhbnNmb3JtXCIsXG5cdFx0XHRfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoXCJ0cmFuc2Zvcm1PcmlnaW5cIiksXG5cdFx0XHRfc3VwcG9ydHMzRCA9IChfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIikgIT09IG51bGwpLFxuXHRcdFx0VHJhbnNmb3JtID0gX2ludGVybmFscy5UcmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wZXJzcGVjdGl2ZSA9IHBhcnNlRmxvYXQoQ1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSkgfHwgMDtcblx0XHRcdFx0dGhpcy5mb3JjZTNEID0gKENTU1BsdWdpbi5kZWZhdWx0Rm9yY2UzRCA9PT0gZmFsc2UgfHwgIV9zdXBwb3J0czNEKSA/IGZhbHNlIDogQ1NTUGx1Z2luLmRlZmF1bHRGb3JjZTNEIHx8IFwiYXV0b1wiO1xuXHRcdFx0fSxcblx0XHRcdF9TVkdFbGVtZW50ID0gd2luZG93LlNWR0VsZW1lbnQsXG5cdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0cixcblx0XHRcdC8vU29tZSBicm93c2VycyAobGlrZSBGaXJlZm94IGFuZCBJRSkgZG9uJ3QgaG9ub3IgdHJhbnNmb3JtLW9yaWdpbiBwcm9wZXJseSBpbiBTVkcgZWxlbWVudHMsIHNvIHdlIG5lZWQgdG8gbWFudWFsbHkgYWRqdXN0IHRoZSBtYXRyaXggYWNjb3JkaW5nbHkuIFdlIGZlYXR1cmUgZGV0ZWN0IGhlcmUgcmF0aGVyIHRoYW4gYWx3YXlzIGRvaW5nIHRoZSBjb252ZXJzaW9uIGZvciBjZXJ0YWluIGJyb3dzZXJzIGJlY2F1c2UgdGhleSBtYXkgZml4IHRoZSBwcm9ibGVtIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cblxuXHRcdFx0X2NyZWF0ZVNWRyA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRhaW5lciwgYXR0cmlidXRlcykge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdHlwZSksXG5cdFx0XHRcdFx0cmVnID0gLyhbYS16XSkoW0EtWl0pL2csXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIHAucmVwbGFjZShyZWcsIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSwgYXR0cmlidXRlc1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdH0sXG5cdFx0XHRfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0X2ZvcmNlU1ZHVHJhbnNmb3JtQXR0ciA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly9JRSBhbmQgQW5kcm9pZCBzdG9jayBkb24ndCBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIG9uIFNWRyBlbGVtZW50cywgc28gd2UgbXVzdCB3cml0ZSB0aGVtIHRvIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZS4gV2UgcG9wdWxhdGUgdGhpcyB2YXJpYWJsZSBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgbWV0aG9kLCBhbmQgb25seSBpZi93aGVuIHdlIGNvbWUgYWNyb3NzIGFuIFNWRyBlbGVtZW50XG5cdFx0XHRcdHZhciBmb3JjZSA9IF9pZVZlcnMgfHwgKC9BbmRyb2lkL2kudGVzdChfYWdlbnQpICYmICF3aW5kb3cuY2hyb21lKSxcblx0XHRcdFx0XHRzdmcsIHJlY3QsIHdpZHRoO1xuXHRcdFx0XHRpZiAoX2RvYy5jcmVhdGVFbGVtZW50TlMgJiYgIWZvcmNlKSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW55d2F5XG5cdFx0XHRcdFx0c3ZnID0gX2NyZWF0ZVNWRyhcInN2Z1wiLCBfZG9jRWxlbWVudCk7XG5cdFx0XHRcdFx0cmVjdCA9IF9jcmVhdGVTVkcoXCJyZWN0XCIsIHN2Zywge3dpZHRoOjEwMCwgaGVpZ2h0OjUwLCB4OjEwMH0pO1xuXHRcdFx0XHRcdHdpZHRoID0gcmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRcdFx0XHRyZWN0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiNTAlIDUwJVwiO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJzY2FsZVgoMC41KVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKHdpZHRoID09PSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICYmICEoX2lzRmlyZWZveCAmJiBfc3VwcG9ydHMzRCkpOyAvL25vdGU6IEZpcmVmb3ggZmFpbHMgdGhlIHRlc3QgZXZlbiB0aG91Z2ggaXQgZG9lcyBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIGluIDNELiBTaW5jZSB3ZSBjYW4ndCBwdXNoIDNEIHN0dWZmIGludG8gdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIHdlIGZvcmNlIEZpcmVmb3ggdG8gcGFzcyB0aGUgdGVzdCBoZXJlIChhcyBsb25nIGFzIGl0IGRvZXMgdHJ1bHkgc3VwcG9ydCAzRCkuXG5cdFx0XHRcdFx0X2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm9yY2U7XG5cdFx0XHR9KSgpLFxuXHRcdFx0X3BhcnNlU1ZHT3JpZ2luID0gZnVuY3Rpb24oZSwgbG9jYWwsIGRlY29yYXRlZSwgYWJzb2x1dGUpIHtcblx0XHRcdFx0dmFyIGJib3gsIHY7XG5cdFx0XHRcdGlmICghYWJzb2x1dGUgfHwgISh2ID0gYWJzb2x1dGUuc3BsaXQoXCIgXCIpKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRiYm94ID0gZS5nZXRCQm94KCk7XG5cdFx0XHRcdFx0bG9jYWwgPSBfcGFyc2VQb3NpdGlvbihsb2NhbCkuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdHYgPSBbKGxvY2FsWzBdLmluZGV4T2YoXCIlXCIpICE9PSAtMSA/IHBhcnNlRmxvYXQobG9jYWxbMF0pIC8gMTAwICogYmJveC53aWR0aCA6IHBhcnNlRmxvYXQobG9jYWxbMF0pKSArIGJib3gueCxcblx0XHRcdFx0XHRcdCAobG9jYWxbMV0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFsxXSkgLyAxMDAgKiBiYm94LmhlaWdodCA6IHBhcnNlRmxvYXQobG9jYWxbMV0pKSArIGJib3gueV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVjb3JhdGVlLnhPcmlnaW4gPSBwYXJzZUZsb2F0KHZbMF0pO1xuXHRcdFx0XHRkZWNvcmF0ZWUueU9yaWdpbiA9IHBhcnNlRmxvYXQodlsxXSk7XG5cdFx0XHRcdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHYuam9pbihcIiBcIikpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYXJzZXMgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgZm9yIGFuIGVsZW1lbnQsIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCB4LCB5LCB6LCBzY2FsZVgsIHNjYWxlWSwgc2NhbGVaLCByb3RhdGlvbiwgcm90YXRpb25YLCByb3RhdGlvblksIHNrZXdYLCBhbmQgc2tld1kgcHJvcGVydGllcy4gTm90ZTogYnkgZGVmYXVsdCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLCBhbGwgc2tld2luZyBpcyBjb21iaW5lZCBpbnRvIHNrZXdYIGFuZCByb3RhdGlvbiBidXQgc2tld1kgc3RpbGwgaGFzIGEgcGxhY2UgaW4gdGhlIHRyYW5zZm9ybSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVjb3JkIGhvdyBtdWNoIG9mIHRoZSBza2V3IGlzIGF0dHJpYnV0ZWQgdG8gc2tld1ggdnMgc2tld1kuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgYW5kIHNrZXdYIG9mIC0xMC5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBjb21wdXRlZCBzdHlsZSBvYmplY3QgKG9wdGlvbmFsKVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcmVjIGlmIHRydWUsIHRoZSB0cmFuc2Zvcm0gdmFsdWVzIHdpbGwgYmUgcmVjb3JkZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50J3MgX2dzVHJhbnNmb3JtIG9iamVjdCwgbGlrZSB0YXJnZXQuX2dzVHJhbnNmb3JtID0ge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcGFyc2UgaWYgdHJ1ZSwgd2UnbGwgaWdub3JlIGFueSBfZ3NUcmFuc2Zvcm0gdmFsdWVzIHRoYXQgYWxyZWFkeSBleGlzdCBvbiB0aGUgZWxlbWVudCwgYW5kIGZvcmNlIGEgcmVwYXJzaW5nIG9mIHRoZSBjc3MgKGNhbGN1bGF0ZWQgc3R5bGUpXG5cdFx0XHQgKiBAcmV0dXJuIHtvYmplY3R9IG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMvdmFsdWVzIGxpa2Uge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0VHJhbnNmb3JtID0gX2ludGVybmFscy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih0LCBjcywgcmVjLCBwYXJzZSkge1xuXHRcdFx0XHRpZiAodC5fZ3NUcmFuc2Zvcm0gJiYgcmVjICYmICFwYXJzZSkge1xuXHRcdFx0XHRcdHJldHVybiB0Ll9nc1RyYW5zZm9ybTsgLy9pZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBhIF9nc1RyYW5zZm9ybSwgdXNlIHRoYXQuIE5vdGU6IHNvbWUgYnJvd3NlcnMgZG9uJ3QgYWNjdXJhdGVseSByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgc3R5bGUgZm9yIHRoZSB0cmFuc2Zvcm0gKHBhcnRpY3VsYXJseSBmb3IgU1ZHKSwgc28gaXQncyBhbG1vc3QgYWx3YXlzIHNhZmVzdCB0byBqdXN0IHVzZSB0aGUgdmFsdWVzIHdlJ3ZlIGFscmVhZHkgYXBwbGllZCByYXRoZXIgdGhhbiByZS1wYXJzaW5nIHRoaW5ncy5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdG0gPSByZWMgPyB0Ll9nc1RyYW5zZm9ybSB8fCBuZXcgVHJhbnNmb3JtKCkgOiBuZXcgVHJhbnNmb3JtKCksXG5cdFx0XHRcdFx0aW52WCA9ICh0bS5zY2FsZVggPCAwKSwgLy9pbiBvcmRlciB0byBpbnRlcnByZXQgdGhpbmdzIHByb3Blcmx5LCB3ZSBuZWVkIHRvIGtub3cgaWYgdGhlIHVzZXIgYXBwbGllZCBhIG5lZ2F0aXZlIHNjYWxlWCBwcmV2aW91c2x5IHNvIHRoYXQgd2UgY2FuIGFkanVzdCB0aGUgcm90YXRpb24gYW5kIHNrZXdYIGFjY29yZGluZ2x5LiBPdGhlcndpc2UsIGlmIHdlIGFsd2F5cyBpbnRlcnByZXQgYSBmbGlwcGVkIG1hdHJpeCBhcyBhZmZlY3Rpbmcgc2NhbGVZIGFuZCB0aGUgdXNlciBvbmx5IHdhbnRzIHRvIHR3ZWVuIHRoZSBzY2FsZVggb24gbXVsdGlwbGUgc2VxdWVudGlhbCB0d2VlbnMsIGl0IHdvdWxkIGtlZXAgdGhlIG5lZ2F0aXZlIHNjYWxlWSB3aXRob3V0IHRoYXQgYmVpbmcgdGhlIHVzZXIncyBpbnRlbnQuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMixcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0ek9yaWdpbiA9IF9zdXBwb3J0czNEID8gcGFyc2VGbG9hdChfZ2V0U3R5bGUodCwgX3RyYW5zZm9ybU9yaWdpblByb3AsIGNzLCBmYWxzZSwgXCIwIDAgMFwiKS5zcGxpdChcIiBcIilbMl0pIHx8IHRtLnpPcmlnaW4gIHx8IDAgOiAwLFxuXHRcdFx0XHRcdGRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBhcnNlRmxvYXQoQ1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSkgfHwgMCxcblx0XHRcdFx0XHRpc0RlZmF1bHQsIHMsIG0sIGksIG4sIGRlYywgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WDtcblx0XHRcdFx0aWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0cyA9IF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtUHJvcENTUywgY3MsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQuY3VycmVudFN0eWxlKSB7XG5cdFx0XHRcdFx0Ly9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUsIHdlIG5lZWQgdG8gaW50ZXJwcmV0IHRoZSBmaWx0ZXIgcG9ydGlvbiB0aGF0IGlzIGluIHRoZSBmb3JtYXQ6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTYuMTIzMjMzOTk1NzM2NzY2ZS0xNywgTTEyPS0xLCBNMjE9MSwgTTIyPTYuMTIzMjMzOTk1NzM2NzY2ZS0xNywgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpIE5vdGljZSB0aGF0IHdlIG5lZWQgdG8gc3dhcCBiIGFuZCBjIGNvbXBhcmVkIHRvIGEgbm9ybWFsIG1hdHJpeC5cblx0XHRcdFx0XHRzID0gdC5jdXJyZW50U3R5bGUuZmlsdGVyLm1hdGNoKF9pZUdldE1hdHJpeEV4cCk7XG5cdFx0XHRcdFx0cyA9IChzICYmIHMubGVuZ3RoID09PSA0KSA/IFtzWzBdLnN1YnN0cig0KSwgTnVtYmVyKHNbMl0uc3Vic3RyKDQpKSwgTnVtYmVyKHNbMV0uc3Vic3RyKDQpKSwgc1szXS5zdWJzdHIoNCksICh0bS54IHx8IDApLCAodG0ueSB8fCAwKV0uam9pbihcIixcIikgOiBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlzRGVmYXVsdCA9ICghcyB8fCBzID09PSBcIm5vbmVcIiB8fCBzID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiKTtcblx0XHRcdFx0dG0uc3ZnID0gISEoX1NWR0VsZW1lbnQgJiYgdHlwZW9mKHQuZ2V0QkJveCkgPT09IFwiZnVuY3Rpb25cIiAmJiB0LmdldENUTSAmJiAoIXQucGFyZW50Tm9kZSB8fCAodC5wYXJlbnROb2RlLmdldEJCb3ggJiYgdC5wYXJlbnROb2RlLmdldENUTSkpKTsgLy9kb24ndCBqdXN0IHJlbHkgb24gXCJpbnN0YW5jZW9mIF9TVkdFbGVtZW50XCIgYmVjYXVzZSBpZiB0aGUgU1ZHIGlzIGVtYmVkZGVkIHZpYSBhbiBvYmplY3QgdGFnLCBpdCB3b24ndCB3b3JrIChTVkdFbGVtZW50IGlzIG1hcHBlZCB0byBhIGRpZmZlcmVudCBvYmplY3QpXG5cdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmICh0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLmluZGV4T2YoXCJtYXRyaXhcIikgIT09IC0xKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUgNDApIGRvbid0IGNvcnJlY3RseSByZXBvcnQgdHJhbnNmb3JtcyB0aGF0IGFyZSBhcHBsaWVkIGlubGluZSBvbiBhbiBTVkcgZWxlbWVudCAodGhleSBkb24ndCBnZXQgaW5jbHVkZWQgaW4gdGhlIGNvbXB1dGVkIHN0eWxlKSwgc28gd2UgZG91YmxlLWNoZWNrIGhlcmUgYW5kIGFjY2VwdCBtYXRyaXggdmFsdWVzXG5cdFx0XHRcdFx0XHRzID0gdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF07XG5cdFx0XHRcdFx0XHRpc0RlZmF1bHQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCwgX2NzLCBmYWxzZSwgXCI1MCUgNTAlXCIpICsgXCJcIiwgdG0sIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpKTtcblx0XHRcdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0ciA9IENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyIHx8IF9mb3JjZVNWR1RyYW5zZm9ybUF0dHI7XG5cdFx0XHRcdFx0bSA9IHQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgbSAmJiBtLmluZGV4T2YoXCJtYXRyaXhcIikgIT09IC0xKSB7IC8vanVzdCBpbiBjYXNlIHRoZXJlJ3MgYSBcInRyYW5zZm9ybVwiIHZhbHVlIHNwZWNpZmllZCBhcyBhbiBhdHRyaWJ1dGUgaW5zdGVhZCBvZiBDU1Mgc3R5bGUuIE9ubHkgYWNjZXB0IGEgbWF0cml4LCB0aG91Z2guXG5cdFx0XHRcdFx0XHRzID0gbTtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNEZWZhdWx0KSB7XG5cdFx0XHRcdFx0Ly9zcGxpdCB0aGUgbWF0cml4IHZhbHVlcyBvdXQgaW50byBhbiBhcnJheSAobSBmb3IgbWF0cml4KVxuXHRcdFx0XHRcdG0gPSAocyB8fCBcIlwiKS5tYXRjaCgvKD86XFwtfFxcYilbXFxkXFwtXFwuZV0rXFxiL2dpKSB8fCBbXTtcblx0XHRcdFx0XHRpID0gbS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRuID0gTnVtYmVyKG1baV0pO1xuXHRcdFx0XHRcdFx0bVtpXSA9IChkZWMgPSBuIC0gKG4gfD0gMCkpID8gKChkZWMgKiBybmQgKyAoZGVjIDwgMCA/IC0wLjUgOiAwLjUpKSB8IDApIC8gcm5kICsgbiA6IG47IC8vY29udmVydCBzdHJpbmdzIHRvIE51bWJlcnMgYW5kIHJvdW5kIHRvIDUgZGVjaW1hbCBwbGFjZXMgdG8gYXZvaWQgaXNzdWVzIHdpdGggdGlueSBudW1iZXJzLiBSb3VnaGx5IDIweCBmYXN0ZXIgdGhhbiBOdW1iZXIudG9GaXhlZCgpLiBXZSBhbHNvIG11c3QgbWFrZSBzdXJlIHRvIHJvdW5kIGJlZm9yZSBkaXZpZGluZyBzbyB0aGF0IHZhbHVlcyBsaWtlIDAuOTk5OTk5OTk5OSBiZWNvbWUgMSB0byBhdm9pZCBnbGl0Y2hlcyBpbiBicm93c2VyIHJlbmRlcmluZyBhbmQgaW50ZXJwcmV0YXRpb24gb2YgZmxpcHBlZC9yb3RhdGVkIDNEIG1hdHJpY2VzLiBBbmQgZG9uJ3QganVzdCBtdWx0aXBseSB0aGUgbnVtYmVyIGJ5IHJuZCwgZmxvb3IgaXQsIGFuZCB0aGVuIGRpdmlkZSBieSBybmQgYmVjYXVzZSB0aGUgYml0d2lzZSBvcGVyYXRpb25zIG1heCBvdXQgYXQgYSAzMi1iaXQgc2lnbmVkIGludGVnZXIsIHRodXMgaXQgY291bGQgZ2V0IGNsaXBwZWQgYXQgYSByZWxhdGl2ZWx5IGxvdyB2YWx1ZSAobGlrZSAyMiwwMDAuMDAwMDAgZm9yIGV4YW1wbGUpLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobS5sZW5ndGggPT09IDE2KSB7XG5cdFx0XHRcdFx0XHQvL3dlJ2xsIG9ubHkgbG9vayBhdCB0aGVzZSBwb3NpdGlvbi1yZWxhdGVkIDYgdmFyaWFibGVzIGZpcnN0IGJlY2F1c2UgaWYgeC95L3ogYWxsIG1hdGNoLCBpdCdzIHJlbGF0aXZlbHkgc2FmZSB0byBhc3N1bWUgd2UgZG9uJ3QgbmVlZCB0byByZS1wYXJzZSBldmVyeXRoaW5nIHdoaWNoIHJpc2tzIGxvc2luZyBpbXBvcnRhbnQgcm90YXRpb25hbCBpbmZvcm1hdGlvbiAobGlrZSByb3RhdGlvblg6MTgwIHBsdXMgcm90YXRpb25ZOjE4MCB3b3VsZCBsb29rIHRoZSBzYW1lIGFzIHJvdGF0aW9uOjE4MCAtIHRoZXJlJ3Mgbm8gd2F5IHRvIGtub3cgZm9yIHN1cmUgd2hpY2ggZGlyZWN0aW9uIHdhcyB0YWtlbiBiYXNlZCBzb2xlbHkgb24gdGhlIG1hdHJpeDNkKCkgdmFsdWVzKVxuXHRcdFx0XHRcdFx0dmFyIGExMSA9IG1bMF0sIGEyMSA9IG1bMV0sIGEzMSA9IG1bMl0sIGE0MSA9IG1bM10sXG5cdFx0XHRcdFx0XHRcdGExMiA9IG1bNF0sIGEyMiA9IG1bNV0sIGEzMiA9IG1bNl0sIGE0MiA9IG1bN10sXG5cdFx0XHRcdFx0XHRcdGExMyA9IG1bOF0sIGEyMyA9IG1bOV0sIGEzMyA9IG1bMTBdLFxuXHRcdFx0XHRcdFx0XHRhMTQgPSBtWzEyXSwgYTI0ID0gbVsxM10sIGEzNCA9IG1bMTRdLFxuXHRcdFx0XHRcdFx0XHRhNDMgPSBtWzExXSxcblx0XHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGEzMiwgYTMzKSxcblx0XHRcdFx0XHRcdFx0dDEsIHQyLCB0MywgdDQsIGNvcywgc2luO1xuXG5cdFx0XHRcdFx0XHQvL3dlIG1hbnVhbGx5IGNvbXBlbnNhdGUgZm9yIG5vbi16ZXJvIHogY29tcG9uZW50IG9mIHRyYW5zZm9ybU9yaWdpbiB0byB3b3JrIGFyb3VuZCBidWdzIGluIFNhZmFyaVxuXHRcdFx0XHRcdFx0aWYgKHRtLnpPcmlnaW4pIHtcblx0XHRcdFx0XHRcdFx0YTM0ID0gLXRtLnpPcmlnaW47XG5cdFx0XHRcdFx0XHRcdGExNCA9IGExMyphMzQtbVsxMl07XG5cdFx0XHRcdFx0XHRcdGEyNCA9IGEyMyphMzQtbVsxM107XG5cdFx0XHRcdFx0XHRcdGEzNCA9IGEzMyphMzQrdG0uek9yaWdpbi1tWzE0XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHQvL3JvdGF0aW9uWFxuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGEyMipjb3MrYTIzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDMgPSBhMzIqY29zK2EzMypzaW47XG5cdFx0XHRcdFx0XHRcdGExMyA9IGExMiotc2luK2ExMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMyA9IGEzMiotc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0XHRcdGE0MyA9IGE0Miotc2luK2E0Mypjb3M7XG5cdFx0XHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMjIgPSB0Mjtcblx0XHRcdFx0XHRcdFx0YTMyID0gdDM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3JvdGF0aW9uWVxuXHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGExMywgYTMzKTtcblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBhMTEqY29zLWExMypzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIxKmNvcy1hMjMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MyA9IGEzMSpjb3MtYTMzKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIzID0gYTIxKnNpbithMjMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzMgPSBhMzEqc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0XHRcdGE0MyA9IGE0MSpzaW4rYTQzKmNvcztcblx0XHRcdFx0XHRcdFx0YTExID0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0XHRhMzEgPSB0Mztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRpb25aXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTIxLCBhMTEpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdGExMSA9IGExMSpjb3MrYTEyKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zK2EyMipzaW47XG5cdFx0XHRcdFx0XHRcdGEyMiA9IGEyMSotc2luK2EyMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMiA9IGEzMSotc2luK2EzMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodG0ucm90YXRpb25YICYmIE1hdGguYWJzKHRtLnJvdGF0aW9uWCkgKyBNYXRoLmFicyh0bS5yb3RhdGlvbikgPiAzNTkuOSkgeyAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gdG0ucm90YXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblkgKz0gMTgwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0bS5zY2FsZVggPSAoKE1hdGguc3FydChhMTEgKiBhMTEgKyBhMjEgKiBhMjEpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVZID0gKChNYXRoLnNxcnQoYTIyICogYTIyICsgYTIzICogYTIzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdHRtLnNjYWxlWiA9ICgoTWF0aC5zcXJ0KGEzMiAqIGEzMiArIGEzMyAqIGEzMykgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5za2V3WCA9IDA7XG5cdFx0XHRcdFx0XHR0bS5wZXJzcGVjdGl2ZSA9IGE0MyA/IDEgLyAoKGE0MyA8IDApID8gLWE0MyA6IGE0MykgOiAwO1xuXHRcdFx0XHRcdFx0dG0ueCA9IGExNDtcblx0XHRcdFx0XHRcdHRtLnkgPSBhMjQ7XG5cdFx0XHRcdFx0XHR0bS56ID0gYTM0O1xuXHRcdFx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0bS54IC09IHRtLnhPcmlnaW4gLSAodG0ueE9yaWdpbiAqIGExMSAtIHRtLnlPcmlnaW4gKiBhMTIpO1xuXHRcdFx0XHRcdFx0XHR0bS55IC09IHRtLnlPcmlnaW4gLSAodG0ueU9yaWdpbiAqIGEyMSAtIHRtLnhPcmlnaW4gKiBhMjIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICgoIV9zdXBwb3J0czNEIHx8IHBhcnNlIHx8ICFtLmxlbmd0aCB8fCB0bS54ICE9PSBtWzRdIHx8IHRtLnkgIT09IG1bNV0gfHwgKCF0bS5yb3RhdGlvblggJiYgIXRtLnJvdGF0aW9uWSkpICYmICEodG0ueCAhPT0gdW5kZWZpbmVkICYmIF9nZXRTdHlsZSh0LCBcImRpc3BsYXlcIiwgY3MpID09PSBcIm5vbmVcIikpIHsgLy9zb21ldGltZXMgYSA2LWVsZW1lbnQgbWF0cml4IGlzIHJldHVybmVkIGV2ZW4gd2hlbiB3ZSBwZXJmb3JtZWQgM0QgdHJhbnNmb3JtcywgbGlrZSBpZiByb3RhdGlvblggYW5kIHJvdGF0aW9uWSBhcmUgMTgwLiBJbiBjYXNlcyBsaWtlIHRoaXMsIHdlIHN0aWxsIG5lZWQgdG8gaG9ub3IgdGhlIDNEIHRyYW5zZm9ybXMuIElmIHdlIGp1c3QgcmVseSBvbiB0aGUgMkQgaW5mbywgaXQgY291bGQgYWZmZWN0IGhvdyB0aGUgZGF0YSBpcyBpbnRlcnByZXRlZCwgbGlrZSBzY2FsZVkgbWlnaHQgZ2V0IHNldCB0byAtMSBvciByb3RhdGlvbiBjb3VsZCBnZXQgb2Zmc2V0IGJ5IDE4MCBkZWdyZWVzLiBGb3IgZXhhbXBsZSwgZG8gYSBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjE4MCwgcm90YXRpb25ZOjE4MH19KSBhbmQgdGhlbiBsYXRlciwgVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e3JvdGF0aW9uWDowfX0pIGFuZCB3aXRob3V0IHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW4gcGxhY2UsIGl0J2QganVtcCB0byBhIHN0YXRlIG9mIGJlaW5nIHVucm90YXRlZCB3aGVuIHRoZSAybmQgdHdlZW4gc3RhcnRzLiBUaGVuIGFnYWluLCB3ZSBuZWVkIHRvIGhvbm9yIHRoZSBmYWN0IHRoYXQgdGhlIHVzZXIgQ09VTEQgYWx0ZXIgdGhlIHRyYW5zZm9ybXMgb3V0c2lkZSBvZiBDU1NQbHVnaW4sIGxpa2UgYnkgbWFudWFsbHkgYXBwbHlpbmcgbmV3IGNzcywgc28gd2UgdHJ5IHRvIHNlbnNlIHRoYXQgYnkgbG9va2luZyBhdCB4IGFuZCB5IGJlY2F1c2UgaWYgdGhvc2UgY2hhbmdlZCwgd2Uga25vdyB0aGUgY2hhbmdlcyB3ZXJlIG1hZGUgb3V0c2lkZSBDU1NQbHVnaW4gYW5kIHdlIGZvcmNlIGEgcmVpbnRlcnByZXRhdGlvbiBvZiB0aGUgbWF0cml4IHZhbHVlcy4gQWxzbywgaW4gV2Via2l0IGJyb3dzZXJzLCBpZiB0aGUgZWxlbWVudCdzIFwiZGlzcGxheVwiIGlzIFwibm9uZVwiLCBpdHMgY2FsY3VsYXRlZCBzdHlsZSB2YWx1ZSB3aWxsIGFsd2F5cyByZXR1cm4gZW1wdHksIHNvIGlmIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgdGhlIHZhbHVlcyBpbiB0aGUgX2dzVHJhbnNmb3JtIG9iamVjdCwgd2UnbGwganVzdCByZWx5IG9uIHRob3NlLlxuXHRcdFx0XHRcdFx0dmFyIGsgPSAobS5sZW5ndGggPj0gNiksXG5cdFx0XHRcdFx0XHRcdGEgPSBrID8gbVswXSA6IDEsXG5cdFx0XHRcdFx0XHRcdGIgPSBtWzFdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGMgPSBtWzJdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGQgPSBrID8gbVszXSA6IDE7XG5cdFx0XHRcdFx0XHR0bS54ID0gbVs0XSB8fCAwO1xuXHRcdFx0XHRcdFx0dG0ueSA9IG1bNV0gfHwgMDtcblx0XHRcdFx0XHRcdHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0XHRcdFx0XHRcdHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcblx0XHRcdFx0XHRcdHJvdGF0aW9uID0gKGEgfHwgYikgPyBNYXRoLmF0YW4yKGIsIGEpICogX1JBRDJERUcgOiB0bS5yb3RhdGlvbiB8fCAwOyAvL25vdGU6IGlmIHNjYWxlWCBpcyAwLCB3ZSBjYW5ub3QgYWNjdXJhdGVseSBtZWFzdXJlIHJvdGF0aW9uLiBTYW1lIGZvciBza2V3WCB3aXRoIGEgc2NhbGVZIG9mIDAuIFRoZXJlZm9yZSwgd2UgZGVmYXVsdCB0byB0aGUgcHJldmlvdXNseSByZWNvcmRlZCB2YWx1ZSAob3IgemVybyBpZiB0aGF0IGRvZXNuJ3QgZXhpc3QpLlxuXHRcdFx0XHRcdFx0c2tld1ggPSAoYyB8fCBkKSA/IE1hdGguYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogdG0uc2tld1ggfHwgMDtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcblx0XHRcdFx0XHRcdFx0aWYgKGludlgpIHtcblx0XHRcdFx0XHRcdFx0XHRzY2FsZVggKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0c2tld1ggKz0gKHJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0XHRyb3RhdGlvbiArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNjYWxlWSAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRza2V3WCArPSAoc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVggPSBzY2FsZVg7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSBzY2FsZVk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0dG0uc2tld1ggPSBza2V3WDtcblx0XHRcdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvblkgPSB0bS56ID0gMDtcblx0XHRcdFx0XHRcdFx0dG0ucGVyc3BlY3RpdmUgPSBkZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmU7XG5cdFx0XHRcdFx0XHRcdHRtLnNjYWxlWiA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnggLT0gdG0ueE9yaWdpbiAtICh0bS54T3JpZ2luICogYSAtIHRtLnlPcmlnaW4gKiBiKTtcblx0XHRcdFx0XHRcdFx0dG0ueSAtPSB0bS55T3JpZ2luIC0gKHRtLnlPcmlnaW4gKiBkIC0gdG0ueE9yaWdpbiAqIGMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bS56T3JpZ2luID0gek9yaWdpbjtcblx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byAwIGluIHRoZXNlIGNhc2VzLiBUaGUgY29uZGl0aW9uYWwgbG9naWMgaGVyZSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIE1hdGguYWJzKCkuIEFsc28sIGJyb3dzZXJzIHRlbmQgdG8gcmVuZGVyIGEgU0xJR0hUTFkgcm90YXRlZCBvYmplY3QgaW4gYSBmdXp6eSB3YXksIHNvIHdlIG5lZWQgdG8gc25hcCB0byBleGFjdGx5IDAgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdFx0XHRmb3IgKGkgaW4gdG0pIHtcblx0XHRcdFx0XHRcdGlmICh0bVtpXSA8IG1pbikgaWYgKHRtW2ldID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR0bVtpXSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZWQgcm90YXRpb24gb2YgXCIgKyB0LmdldEF0dHJpYnV0ZShcImlkXCIpK1wiOiBcIisodG0ucm90YXRpb25YKStcIiwgXCIrKHRtLnJvdGF0aW9uWSkrXCIsIFwiKyh0bS5yb3RhdGlvbikrXCIsIHNjYWxlOiBcIit0bS5zY2FsZVgrXCIsIFwiK3RtLnNjYWxlWStcIiwgXCIrdG0uc2NhbGVaK1wiLCBwb3NpdGlvbjogXCIrdG0ueCtcIiwgXCIrdG0ueStcIiwgXCIrdG0ueitcIiwgcGVyc3BlY3RpdmU6IFwiK3RtLnBlcnNwZWN0aXZlKTtcblx0XHRcdFx0aWYgKHJlYykge1xuXHRcdFx0XHRcdHQuX2dzVHJhbnNmb3JtID0gdG07IC8vcmVjb3JkIHRvIHRoZSBvYmplY3QncyBfZ3NUcmFuc2Zvcm0gd2hpY2ggd2UgdXNlIHNvIHRoYXQgdHdlZW5zIGNhbiBjb250cm9sIGluZGl2aWR1YWwgcHJvcGVydGllcyBpbmRlcGVuZGVudGx5ICh3ZSBuZWVkIGFsbCB0aGUgcHJvcGVydGllcyB0byBhY2N1cmF0ZWx5IHJlY29tcG9zZSB0aGUgbWF0cml4IGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZClcblx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7IC8vaWYgd2UncmUgc3VwcG9zZWQgdG8gYXBwbHkgdHJhbnNmb3JtcyB0byB0aGUgU1ZHIGVsZW1lbnQncyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgbWFrZSBzdXJlIHRoZXJlIGFyZW4ndCBhbnkgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvciB0aGV5J2xsIG92ZXJyaWRlIHRoZSBhdHRyaWJ1dGUgb25lcy4gQWxzbyBjbGVhciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpZiB3ZSdyZSB1c2luZyBDU1MsIGp1c3QgdG8gYmUgY2xlYW4uXG5cdFx0XHRcdFx0XHRpZiAoX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0pIHtcblx0XHRcdFx0XHRcdFx0X3JlbW92ZVByb3AodC5zdHlsZSwgX3RyYW5zZm9ybVByb3ApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICghX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgdC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcblx0XHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0bTtcblx0XHRcdH0sXG5cblx0XHRcdC8vZm9yIHNldHRpbmcgMkQgdHJhbnNmb3JtcyBpbiBJRTYsIElFNywgYW5kIElFOCAobXVzdCB1c2UgYSBcImZpbHRlclwiIHRvIGVtdWxhdGUgdGhlIGJlaGF2aW9yIG9mIG1vZGVybiBkYXkgYnJvd3NlciB0cmFuc2Zvcm1zKVxuXHRcdFx0X3NldElFVHJhbnNmb3JtUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy5kYXRhLCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3Rcblx0XHRcdFx0XHRhbmcgPSAtdC5yb3RhdGlvbiAqIF9ERUcyUkFELFxuXHRcdFx0XHRcdHNrZXcgPSBhbmcgKyB0LnNrZXdYICogX0RFRzJSQUQsXG5cdFx0XHRcdFx0cm5kID0gMTAwMDAwLFxuXHRcdFx0XHRcdGEgPSAoKE1hdGguY29zKGFuZykgKiB0LnNjYWxlWCAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRiID0gKChNYXRoLnNpbihhbmcpICogdC5zY2FsZVggKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0YyA9ICgoTWF0aC5zaW4oc2tldykgKiAtdC5zY2FsZVkgKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0ZCA9ICgoTWF0aC5jb3Moc2tldykgKiB0LnNjYWxlWSAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRzdHlsZSA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHRjcyA9IHRoaXMudC5jdXJyZW50U3R5bGUsXG5cdFx0XHRcdFx0ZmlsdGVycywgdmFsO1xuXHRcdFx0XHRpZiAoIWNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbCA9IGI7IC8vanVzdCBmb3Igc3dhcHBpbmcgdGhlIHZhcmlhYmxlcyBhbiBpbnZlcnRpbmcgdGhlbSAocmV1c2VkIFwidmFsXCIgdG8gYXZvaWQgY3JlYXRpbmcgYW5vdGhlciB2YXJpYWJsZSBpbiBtZW1vcnkpLiBJRSdzIGZpbHRlciBtYXRyaXggdXNlcyBhIG5vbi1zdGFuZGFyZCBtYXRyaXggY29uZmlndXJhdGlvbiAoYW5nbGUgZ29lcyB0aGUgb3Bwb3NpdGUgd2F5LCBhbmQgYiBhbmQgYyBhcmUgcmV2ZXJzZWQgYW5kIGludmVydGVkKVxuXHRcdFx0XHRiID0gLWM7XG5cdFx0XHRcdGMgPSAtdmFsO1xuXHRcdFx0XHRmaWx0ZXJzID0gY3MuZmlsdGVyO1xuXHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBcIlwiOyAvL3JlbW92ZSBmaWx0ZXJzIHNvIHRoYXQgd2UgY2FuIGFjY3VyYXRlbHkgbWVhc3VyZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHRcblx0XHRcdFx0dmFyIHcgPSB0aGlzLnQub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0aCA9IHRoaXMudC5vZmZzZXRIZWlnaHQsXG5cdFx0XHRcdFx0Y2xpcCA9IChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSxcblx0XHRcdFx0XHRtID0gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT1cIiArIGEgKyBcIiwgTTEyPVwiICsgYiArIFwiLCBNMjE9XCIgKyBjICsgXCIsIE0yMj1cIiArIGQsXG5cdFx0XHRcdFx0b3ggPSB0LnggKyAodyAqIHQueFBlcmNlbnQgLyAxMDApLFxuXHRcdFx0XHRcdG95ID0gdC55ICsgKGggKiB0LnlQZXJjZW50IC8gMTAwKSxcblx0XHRcdFx0XHRkeCwgZHk7XG5cblx0XHRcdFx0Ly9pZiB0cmFuc2Zvcm1PcmlnaW4gaXMgYmVpbmcgdXNlZCwgYWRqdXN0IHRoZSBvZmZzZXQgeCBhbmQgeVxuXHRcdFx0XHRpZiAodC5veCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0ZHggPSAoKHQub3hwKSA/IHcgKiB0Lm94ICogMC4wMSA6IHQub3gpIC0gdyAvIDI7XG5cdFx0XHRcdFx0ZHkgPSAoKHQub3lwKSA/IGggKiB0Lm95ICogMC4wMSA6IHQub3kpIC0gaCAvIDI7XG5cdFx0XHRcdFx0b3ggKz0gZHggLSAoZHggKiBhICsgZHkgKiBiKTtcblx0XHRcdFx0XHRveSArPSBkeSAtIChkeCAqIGMgKyBkeSAqIGQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFjbGlwKSB7XG5cdFx0XHRcdFx0bSArPSBcIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZHggPSAodyAvIDIpO1xuXHRcdFx0XHRcdGR5ID0gKGggLyAyKTtcblx0XHRcdFx0XHQvL3RyYW5zbGF0ZSB0byBlbnN1cmUgdGhhdCB0cmFuc2Zvcm1hdGlvbnMgb2NjdXIgYXJvdW5kIHRoZSBjb3JyZWN0IG9yaWdpbiAoZGVmYXVsdCBpcyBjZW50ZXIpLlxuXHRcdFx0XHRcdG0gKz0gXCIsIER4PVwiICsgKGR4IC0gKGR4ICogYSArIGR5ICogYikgKyBveCkgKyBcIiwgRHk9XCIgKyAoZHkgLSAoZHggKiBjICsgZHkgKiBkKSArIG95KSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdHN0eWxlLmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfaWVTZXRNYXRyaXhFeHAsIG0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlLmZpbHRlciA9IG0gKyBcIiBcIiArIGZpbHRlcnM7IC8vd2UgbXVzdCBhbHdheXMgcHV0IHRoZSB0cmFuc2Zvcm0vbWF0cml4IEZJUlNUIChiZWZvcmUgYWxwaGEob3BhY2l0eT14eCkpIHRvIGF2b2lkIGFuIElFIGJ1ZyB0aGF0IHNsaWNlcyBwYXJ0IG9mIHRoZSBvYmplY3Qgd2hlbiByb3RhdGlvbiBpcyBhcHBsaWVkIHdpdGggYWxwaGEuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2F0IHRoZSBlbmQgb3IgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiwgaWYgdGhlIG1hdHJpeCBpcyBub3JtYWwgKDEsIDAsIDAsIDEpIGFuZCBvcGFjaXR5IGlzIDEwMCAob3IgZG9lc24ndCBleGlzdCksIHJlbW92ZSB0aGUgZmlsdGVyIHRvIGltcHJvdmUgYnJvd3NlciBwZXJmb3JtYW5jZS5cblx0XHRcdFx0aWYgKHYgPT09IDAgfHwgdiA9PT0gMSkgaWYgKGEgPT09IDEpIGlmIChiID09PSAwKSBpZiAoYyA9PT0gMCkgaWYgKGQgPT09IDEpIGlmICghY2xpcCB8fCBtLmluZGV4T2YoXCJEeD0wLCBEeT0wXCIpICE9PSAtMSkgaWYgKCFfb3BhY2l0eUV4cC50ZXN0KGZpbHRlcnMpIHx8IHBhcnNlRmxvYXQoUmVnRXhwLiQxKSA9PT0gMTAwKSBpZiAoZmlsdGVycy5pbmRleE9mKFwiZ3JhZGllbnQoXCIgJiYgZmlsdGVycy5pbmRleE9mKFwiQWxwaGFcIikpID09PSAtMSkge1xuXHRcdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vd2UgbXVzdCBzZXQgdGhlIG1hcmdpbnMgQUZURVIgYXBwbHlpbmcgdGhlIGZpbHRlciBpbiBvcmRlciB0byBhdm9pZCBzb21lIGJ1Z3MgaW4gSUU4IHRoYXQgY291bGQgKGluIHJhcmUgc2NlbmFyaW9zKSBjYXVzZSB0aGVtIHRvIGJlIGlnbm9yZWQgaW50ZXJtaXR0ZW50bHkgKHZpYnJhdGlvbikuXG5cdFx0XHRcdGlmICghY2xpcCkge1xuXHRcdFx0XHRcdHZhciBtdWx0ID0gKF9pZVZlcnMgPCA4KSA/IDEgOiAtMSwgLy9pbiBJbnRlcm5ldCBFeHBsb3JlciA3IGFuZCBiZWZvcmUsIHRoZSBib3ggbW9kZWwgaXMgYnJva2VuLCBjYXVzaW5nIHRoZSBicm93c2VyIHRvIHRyZWF0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFjdHVhbCByb3RhdGVkIGZpbHRlcmVkIGltYWdlIGFzIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGJveCBpdHNlbGYsIGJ1dCBNaWNyb3NvZnQgY29ycmVjdGVkIHRoYXQgaW4gSUU4LiBXZSBtdXN0IHVzZSBhIG5lZ2F0aXZlIG9mZnNldCBpbiBJRTggb24gdGhlIHJpZ2h0L2JvdHRvbVxuXHRcdFx0XHRcdFx0bWFyZywgcHJvcCwgZGlmO1xuXHRcdFx0XHRcdGR4ID0gdC5pZU9mZnNldFggfHwgMDtcblx0XHRcdFx0XHRkeSA9IHQuaWVPZmZzZXRZIHx8IDA7XG5cdFx0XHRcdFx0dC5pZU9mZnNldFggPSBNYXRoLnJvdW5kKCh3IC0gKChhIDwgMCA/IC1hIDogYSkgKiB3ICsgKGIgPCAwID8gLWIgOiBiKSAqIGgpKSAvIDIgKyBveCk7XG5cdFx0XHRcdFx0dC5pZU9mZnNldFkgPSBNYXRoLnJvdW5kKChoIC0gKChkIDwgMCA/IC1kIDogZCkgKiBoICsgKGMgPCAwID8gLWMgOiBjKSAqIHcpKSAvIDIgKyBveSk7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdFx0cHJvcCA9IF9tYXJnaW5zW2ldO1xuXHRcdFx0XHRcdFx0bWFyZyA9IGNzW3Byb3BdO1xuXHRcdFx0XHRcdFx0Ly93ZSBuZWVkIHRvIGdldCB0aGUgY3VycmVudCBtYXJnaW4gaW4gY2FzZSBpdCBpcyBiZWluZyB0d2VlbmVkIHNlcGFyYXRlbHkgKHdlIHdhbnQgdG8gcmVzcGVjdCB0aGF0IHR3ZWVuJ3MgY2hhbmdlcylcblx0XHRcdFx0XHRcdHZhbCA9IChtYXJnLmluZGV4T2YoXCJweFwiKSAhPT0gLTEpID8gcGFyc2VGbG9hdChtYXJnKSA6IF9jb252ZXJ0VG9QaXhlbHModGhpcy50LCBwcm9wLCBwYXJzZUZsb2F0KG1hcmcpLCBtYXJnLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIikpIHx8IDA7XG5cdFx0XHRcdFx0XHRpZiAodmFsICE9PSB0W3Byb3BdKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IChpIDwgMikgPyAtdC5pZU9mZnNldFggOiAtdC5pZU9mZnNldFk7IC8vaWYgYW5vdGhlciB0d2VlbiBpcyBjb250cm9sbGluZyBhIG1hcmdpbiwgd2UgY2Fubm90IG9ubHkgYXBwbHkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIGllT2Zmc2V0cywgc28gd2UgZXNzZW50aWFsbHkgemVyby1vdXQgdGhlIGR4IGFuZCBkeSBoZXJlIGluIHRoYXQgY2FzZS4gV2UgcmVjb3JkIHRoZSBtYXJnaW4ocykgbGF0ZXIgc28gdGhhdCB3ZSBjYW4ga2VlcCBjb21wYXJpbmcgdGhlbSwgbWFraW5nIHRoaXMgY29kZSB2ZXJ5IGZsZXhpYmxlLlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKGkgPCAyKSA/IGR4IC0gdC5pZU9mZnNldFggOiBkeSAtIHQuaWVPZmZzZXRZO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3R5bGVbcHJvcF0gPSAodFtwcm9wXSA9IE1hdGgucm91bmQoIHZhbCAtIGRpZiAqICgoaSA9PT0gMCB8fCBpID09PSAyKSA/IDEgOiBtdWx0KSApKSArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qIHRyYW5zbGF0ZXMgYSBzdXBlciBzbWFsbCBkZWNpbWFsIHRvIGEgc3RyaW5nIFdJVEhPVVQgc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0X3NhZmVEZWNpbWFsID0gZnVuY3Rpb24obikge1xuXHRcdFx0XHR2YXIgcyA9IChuIDwgMCA/IC1uIDogbikgKyBcIlwiLFxuXHRcdFx0XHRcdGEgPSBzLnNwbGl0KFwiZS1cIik7XG5cdFx0XHRcdHJldHVybiAobiA8IDAgPyBcIi0wLlwiIDogXCIwLlwiKSArIG5ldyBBcnJheShwYXJzZUludChhWzFdLCAxMCkgfHwgMCkuam9pbihcIjBcIikgKyBhWzBdLnNwbGl0KFwiLlwiKS5qb2luKFwiXCIpO1xuXHRcdFx0fSxcblx0XHRcdCovXG5cblx0XHRcdF9zZXRUcmFuc2Zvcm1SYXRpbyA9IF9pbnRlcm5hbHMuc2V0M0RUcmFuc2Zvcm1SYXRpbyA9IF9pbnRlcm5hbHMuc2V0VHJhbnNmb3JtUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy5kYXRhLCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3Rcblx0XHRcdFx0XHRzdHlsZSA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHRhbmdsZSA9IHQucm90YXRpb24sXG5cdFx0XHRcdFx0cm90YXRpb25YID0gdC5yb3RhdGlvblgsXG5cdFx0XHRcdFx0cm90YXRpb25ZID0gdC5yb3RhdGlvblksXG5cdFx0XHRcdFx0c3ggPSB0LnNjYWxlWCxcblx0XHRcdFx0XHRzeSA9IHQuc2NhbGVZLFxuXHRcdFx0XHRcdHN6ID0gdC5zY2FsZVosXG5cdFx0XHRcdFx0eCA9IHQueCxcblx0XHRcdFx0XHR5ID0gdC55LFxuXHRcdFx0XHRcdHogPSB0LnosXG5cdFx0XHRcdFx0aXNTVkcgPSB0LnN2Zyxcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZSA9IHQucGVyc3BlY3RpdmUsXG5cdFx0XHRcdFx0Zm9yY2UzRCA9IHQuZm9yY2UzRCxcblx0XHRcdFx0XHRhMTEsIGExMiwgYTEzLCBhMjEsIGEyMiwgYTIzLCBhMzEsIGEzMiwgYTMzLCBhNDEsIGE0MiwgYTQzLFxuXHRcdFx0XHRcdHpPcmlnaW4sIG1pbiwgY29zLCBzaW4sIHQxLCB0MiwgdHJhbnNmb3JtLCBjb21tYSwgemVybywgc2tldywgcm5kO1xuXG5cdFx0XHRcdC8vY2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCByZW5kZXIgYXMgMkQgKGFuZCBTVkdzIG11c3QgdXNlIDJEIHdoZW4gX3VzZVNWR1RyYW5zZm9ybUF0dHIgaXMgdHJ1ZSlcblx0XHRcdFx0aWYgKCgoKCh2ID09PSAxIHx8IHYgPT09IDApICYmIGZvcmNlM0QgPT09IFwiYXV0b1wiICYmICh0aGlzLnR3ZWVuLl90b3RhbFRpbWUgPT09IHRoaXMudHdlZW4uX3RvdGFsRHVyYXRpb24gfHwgIXRoaXMudHdlZW4uX3RvdGFsVGltZSkpIHx8ICFmb3JjZTNEKSAmJiAheiAmJiAhcGVyc3BlY3RpdmUgJiYgIXJvdGF0aW9uWSAmJiAhcm90YXRpb25YKSB8fCAoX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgaXNTVkcpIHx8ICFfc3VwcG9ydHMzRCkgeyAvL29uIHRoZSBmaW5hbCByZW5kZXIgKHdoaWNoIGNvdWxkIGJlIDAgZm9yIGEgZnJvbSB0d2VlbiksIGlmIHRoZXJlIGFyZSBubyAzRCBhc3BlY3RzLCByZW5kZXIgaW4gMkQgdG8gZnJlZSB1cCBtZW1vcnkgYW5kIGltcHJvdmUgcGVyZm9ybWFuY2UgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy4gQ2hlY2sgdGhlIHR3ZWVuJ3MgdG90YWxUaW1lL3RvdGFsRHVyYXRpb24gdG9vIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGhhcHBlbiBiZXR3ZWVuIHJlcGVhdHMgaWYgaXQncyBhIHJlcGVhdGluZyB0d2Vlbi5cblxuXHRcdFx0XHRcdC8vMkRcblx0XHRcdFx0XHRpZiAoYW5nbGUgfHwgdC5za2V3WCB8fCBpc1NWRykge1xuXHRcdFx0XHRcdFx0YW5nbGUgKj0gX0RFRzJSQUQ7XG5cdFx0XHRcdFx0XHRza2V3ID0gdC5za2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0cm5kID0gMTAwMDAwO1xuXHRcdFx0XHRcdFx0YTExID0gTWF0aC5jb3MoYW5nbGUpICogc3g7XG5cdFx0XHRcdFx0XHRhMjEgPSBNYXRoLnNpbihhbmdsZSkgKiBzeDtcblx0XHRcdFx0XHRcdGExMiA9IE1hdGguc2luKGFuZ2xlIC0gc2tldykgKiAtc3k7XG5cdFx0XHRcdFx0XHRhMjIgPSBNYXRoLmNvcyhhbmdsZSAtIHNrZXcpICogc3k7XG5cdFx0XHRcdFx0XHRpZiAoc2tldyAmJiB0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tldyk7XG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC5zcXJ0KDEgKyB0MSAqIHQxKTtcblx0XHRcdFx0XHRcdFx0YTEyICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMjIgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdGlmICh0LnNrZXdZKSB7XG5cdFx0XHRcdFx0XHRcdFx0YTExICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRcdGEyMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGlzU1ZHKSB7XG5cdFx0XHRcdFx0XHRcdHggKz0gdC54T3JpZ2luIC0gKHQueE9yaWdpbiAqIGExMSArIHQueU9yaWdpbiAqIGExMik7XG5cdFx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEyMSArIHQueU9yaWdpbiAqIGEyMik7XG5cdFx0XHRcdFx0XHRcdG1pbiA9IDAuMDAwMDAxO1xuXHRcdFx0XHRcdFx0XHRpZiAoeCA8IG1pbikgaWYgKHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHkgPCBtaW4pIGlmICh5ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm0gPSAoKChhMTEgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChhMjEgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChhMTIgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChhMjIgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRpZiAoaXNTVkcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIm1hdHJpeChcIiArIHRyYW5zZm9ybSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byA1IGRlY2ltYWwgcGxhY2VzLlxuXHRcdFx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgoXCIgOiBcIm1hdHJpeChcIikgKyB0cmFuc2Zvcm07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeChcIiA6IFwibWF0cml4KFwiKSArIHN4ICsgXCIsMCwwLFwiICsgc3kgKyBcIixcIiArIHggKyBcIixcIiArIHkgKyBcIilcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc0ZpcmVmb3gpIHsgLy9GaXJlZm94IGhhcyBhIGJ1ZyAoYXQgbGVhc3QgaW4gdjI1KSB0aGF0IGNhdXNlcyBpdCB0byByZW5kZXIgdGhlIHRyYW5zcGFyZW50IHBhcnQgb2YgMzItYml0IFBORyBpbWFnZXMgYXMgYmxhY2sgd2hlbiBkaXNwbGF5ZWQgaW5zaWRlIGFuIGlmcmFtZSBhbmQgdGhlIDNEIHNjYWxlIGlzIHZlcnkgc21hbGwgYW5kIGRvZXNuJ3QgY2hhbmdlIHN1ZmZpY2llbnRseSBlbm91Z2ggYmV0d2VlbiByZW5kZXJzIChsaWtlIGlmIHlvdSB1c2UgYSBQb3dlcjQuZWFzZUluT3V0IHRvIHNjYWxlIGZyb20gMCB0byAxIHdoZXJlIHRoZSBiZWdpbm5pbmcgdmFsdWVzIG9ubHkgY2hhbmdlIGEgdGlueSBhbW91bnQgdG8gYmVnaW4gdGhlIHR3ZWVuIGJlZm9yZSBhY2NlbGVyYXRpbmcpLiBJbiB0aGlzIGNhc2UsIHdlIGZvcmNlIHRoZSBzY2FsZSB0byBiZSAwLjAwMDAyIGluc3RlYWQgd2hpY2ggaXMgdmlzdWFsbHkgdGhlIHNhbWUgYnV0IHdvcmtzIGFyb3VuZCB0aGUgRmlyZWZveCBpc3N1ZS5cblx0XHRcdFx0XHRtaW4gPSAwLjAwMDE7XG5cdFx0XHRcdFx0aWYgKHN4IDwgbWluICYmIHN4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0c3ggPSBzeiA9IDAuMDAwMDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzeSA8IG1pbiAmJiBzeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHN5ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGVyc3BlY3RpdmUgJiYgIXQueiAmJiAhdC5yb3RhdGlvblggJiYgIXQucm90YXRpb25ZKSB7IC8vRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgZWxlbWVudHMgdG8gaGF2ZSBhbiBvZGQgc3VwZXItdGhpbiwgYnJva2VuL2RvdHRlZCBibGFjayBib3JkZXIgb24gZWxlbWVudHMgdGhhdCBoYXZlIGEgcGVyc3BlY3RpdmUgc2V0IGJ1dCBhcmVuJ3QgdXRpbGl6aW5nIDNEIHNwYWNlIChubyByb3RhdGlvblgsIHJvdGF0aW9uWSwgb3IgeikuXG5cdFx0XHRcdFx0XHRwZXJzcGVjdGl2ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhbmdsZSB8fCB0LnNrZXdYKSB7XG5cdFx0XHRcdFx0YW5nbGUgKj0gX0RFRzJSQUQ7XG5cdFx0XHRcdFx0Y29zID0gYTExID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IGEyMSA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRpZiAodC5za2V3WCkge1xuXHRcdFx0XHRcdFx0YW5nbGUgLT0gdC5za2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdFx0aWYgKHQuc2tld1R5cGUgPT09IFwic2ltcGxlXCIpIHsgLy9ieSBkZWZhdWx0LCB3ZSBjb21wZW5zYXRlIHNrZXdpbmcgb24gdGhlIG90aGVyIGF4aXMgdG8gbWFrZSBpdCBsb29rIG1vcmUgbmF0dXJhbCwgYnV0IHlvdSBjYW4gc2V0IHRoZSBza2V3VHlwZSB0byBcInNpbXBsZVwiIHRvIHVzZSB0aGUgdW5jb21wZW5zYXRlZCBza2V3aW5nIHRoYXQgQ1NTIGRvZXNcblx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnRhbih0LnNrZXdYICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGNvcyAqPSB0MTtcblx0XHRcdFx0XHRcdFx0c2luICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAodC5za2V3WSkge1xuXHRcdFx0XHRcdFx0XHRcdGExMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0XHRhMjEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YTEyID0gLXNpbjtcblx0XHRcdFx0XHRhMjIgPSBjb3M7XG5cblx0XHRcdFx0fSBlbHNlIGlmICghcm90YXRpb25ZICYmICFyb3RhdGlvblggJiYgc3ogPT09IDEgJiYgIXBlcnNwZWN0aXZlICYmICFpc1NWRykgeyAvL2lmIHdlJ3JlIG9ubHkgdHJhbnNsYXRpbmcgYW5kL29yIDJEIHNjYWxpbmcsIHRoaXMgaXMgZmFzdGVyLi4uXG5cdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgdHJhbnNsYXRlM2QoXCIgOiBcInRyYW5zbGF0ZTNkKFwiKSArIHggKyBcInB4LFwiICsgeSArIFwicHgsXCIgKyB6ICtcInB4KVwiICsgKChzeCAhPT0gMSB8fCBzeSAhPT0gMSkgPyBcIiBzY2FsZShcIiArIHN4ICsgXCIsXCIgKyBzeSArIFwiKVwiIDogXCJcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGExMSA9IGEyMiA9IDE7XG5cdFx0XHRcdFx0YTEyID0gYTIxID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBLRVkgIElOREVYICAgQUZGRUNUU1xuXHRcdFx0XHQvLyBhMTEgIDAgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEyMSAgMSAgICAgICByb3RhdGlvbiwgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTMxICAyICAgICAgIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGE0MSAgMyAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMTIgIDQgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMjIgIDUgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMzIgIDYgICAgICAgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTQyICA3ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGExMyAgOCAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEyMyAgOSAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEzMyAgMTAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGE0MyAgMTEgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgcGVyc3BlY3RpdmUsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMTQgIDEyICAgICAgeCwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEyNCAgMTMgICAgICB5LCB6T3JpZ2luLCBzdmdPcmlnaW5cblx0XHRcdFx0Ly8gYTM0ICAxNCAgICAgIHosIHpPcmlnaW5cblx0XHRcdFx0Ly8gYTQ0ICAxNVxuXHRcdFx0XHQvLyByb3RhdGlvbjogTWF0aC5hdGFuMihhMjEsIGExMSlcblx0XHRcdFx0Ly8gcm90YXRpb25ZOiBNYXRoLmF0YW4yKGExMywgYTMzKSAob3IgTWF0aC5hdGFuMihhMTMsIGExMSkpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWDogTWF0aC5hdGFuMihhMzIsIGEzMylcblx0XHRcdFx0YTMzID0gMTtcblx0XHRcdFx0YTEzID0gYTIzID0gYTMxID0gYTMyID0gYTQxID0gYTQyID0gMDtcblx0XHRcdFx0YTQzID0gKHBlcnNwZWN0aXZlKSA/IC0xIC8gcGVyc3BlY3RpdmUgOiAwO1xuXHRcdFx0XHR6T3JpZ2luID0gdC56T3JpZ2luO1xuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMTsgLy90aHJlc2hvbGQgYmVsb3cgd2hpY2ggYnJvd3NlcnMgdXNlIHNjaWVudGlmaWMgbm90YXRpb24gd2hpY2ggd29uJ3Qgd29yay5cblx0XHRcdFx0Y29tbWEgPSBcIixcIjtcblx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWSAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGEzMSA9IC1zaW47XG5cdFx0XHRcdFx0YTQxID0gYTQzKi1zaW47XG5cdFx0XHRcdFx0YTEzID0gYTExKnNpbjtcblx0XHRcdFx0XHRhMjMgPSBhMjEqc2luO1xuXHRcdFx0XHRcdGEzMyA9IGNvcztcblx0XHRcdFx0XHRhNDMgKj0gY29zO1xuXHRcdFx0XHRcdGExMSAqPSBjb3M7XG5cdFx0XHRcdFx0YTIxICo9IGNvcztcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdGEzMiA9IGEzMypzaW47XG5cdFx0XHRcdFx0YTQyID0gYTQzKnNpbjtcblx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0YTMzID0gYTMzKmNvcztcblx0XHRcdFx0XHRhNDMgPSBhNDMqY29zO1xuXHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeiAhPT0gMSkge1xuXHRcdFx0XHRcdGExMyo9c3o7XG5cdFx0XHRcdFx0YTIzKj1zejtcblx0XHRcdFx0XHRhMzMqPXN6O1xuXHRcdFx0XHRcdGE0Myo9c3o7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN5ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTEyKj1zeTtcblx0XHRcdFx0XHRhMjIqPXN5O1xuXHRcdFx0XHRcdGEzMio9c3k7XG5cdFx0XHRcdFx0YTQyKj1zeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ggIT09IDEpIHtcblx0XHRcdFx0XHRhMTEqPXN4O1xuXHRcdFx0XHRcdGEyMSo9c3g7XG5cdFx0XHRcdFx0YTMxKj1zeDtcblx0XHRcdFx0XHRhNDEqPXN4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHpPcmlnaW4gfHwgaXNTVkcpIHtcblx0XHRcdFx0XHRpZiAoek9yaWdpbikge1xuXHRcdFx0XHRcdFx0eCArPSBhMTMqLXpPcmlnaW47XG5cdFx0XHRcdFx0XHR5ICs9IGEyMyotek9yaWdpbjtcblx0XHRcdFx0XHRcdHogKz0gYTMzKi16T3JpZ2luK3pPcmlnaW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpc1NWRykgeyAvL2R1ZSB0byBidWdzIGluIHNvbWUgYnJvd3NlcnMsIHdlIG5lZWQgdG8gbWFuYWdlIHRoZSB0cmFuc2Zvcm0tb3JpZ2luIG9mIFNWRyBtYW51YWxseVxuXHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKTtcblx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEyMSArIHQueU9yaWdpbiAqIGEyMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh4IDwgbWluICYmIHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR4ID0gemVybztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHkgPCBtaW4gJiYgeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHkgPSB6ZXJvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeiA8IG1pbiAmJiB6ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eiA9IDA7IC8vZG9uJ3QgdXNlIHN0cmluZyBiZWNhdXNlIHdlIGNhbGN1bGF0ZSBwZXJzcGVjdGl2ZSBsYXRlciBhbmQgbmVlZCB0aGUgbnVtYmVyLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vb3B0aW1pemVkIHdheSBvZiBjb25jYXRlbmF0aW5nIGFsbCB0aGUgdmFsdWVzIGludG8gYSBzdHJpbmcuIElmIHdlIGRvIGl0IGFsbCBpbiBvbmUgc2hvdCwgaXQncyBzbG93ZXIgYmVjYXVzZSBvZiB0aGUgd2F5IGJyb3dzZXJzIGhhdmUgdG8gY3JlYXRlIHRlbXAgc3RyaW5ncyBhbmQgdGhlIHdheSBpdCBhZmZlY3RzIG1lbW9yeS4gSWYgd2UgZG8gaXQgcGllY2UtYnktcGllY2Ugd2l0aCArPSwgaXQncyBhIGJpdCBzbG93ZXIgdG9vLiBXZSBmb3VuZCB0aGF0IGRvaW5nIGl0IGluIHRoZXNlIHNpemVkIGNodW5rcyB3b3JrcyBiZXN0IG92ZXJhbGw6XG5cdFx0XHRcdHRyYW5zZm9ybSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeDNkKFwiIDogXCJtYXRyaXgzZChcIik7XG5cdFx0XHRcdHRyYW5zZm9ybSArPSAoKGExMSA8IG1pbiAmJiBhMTEgPiAtbWluKSA/IHplcm8gOiBhMTEpICsgY29tbWEgKyAoKGEyMSA8IG1pbiAmJiBhMjEgPiAtbWluKSA/IHplcm8gOiBhMjEpICsgY29tbWEgKyAoKGEzMSA8IG1pbiAmJiBhMzEgPiAtbWluKSA/IHplcm8gOiBhMzEpO1xuXHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGE0MSA8IG1pbiAmJiBhNDEgPiAtbWluKSA/IHplcm8gOiBhNDEpICsgY29tbWEgKyAoKGExMiA8IG1pbiAmJiBhMTIgPiAtbWluKSA/IHplcm8gOiBhMTIpICsgY29tbWEgKyAoKGEyMiA8IG1pbiAmJiBhMjIgPiAtbWluKSA/IHplcm8gOiBhMjIpO1xuXHRcdFx0XHRpZiAocm90YXRpb25YIHx8IHJvdGF0aW9uWSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAob2Z0ZW4gdGhlcmUncyBubyByb3RhdGlvblggb3Igcm90YXRpb25ZLCBzbyB3ZSBjYW4gc2tpcCB0aGVzZSBjYWxjdWxhdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMzIgPCBtaW4gJiYgYTMyID4gLW1pbikgPyB6ZXJvIDogYTMyKSArIGNvbW1hICsgKChhNDIgPCBtaW4gJiYgYTQyID4gLW1pbikgPyB6ZXJvIDogYTQyKSArIGNvbW1hICsgKChhMTMgPCBtaW4gJiYgYTEzID4gLW1pbikgPyB6ZXJvIDogYTEzKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEyMyA8IG1pbiAmJiBhMjMgPiAtbWluKSA/IHplcm8gOiBhMjMpICsgY29tbWEgKyAoKGEzMyA8IG1pbiAmJiBhMzMgPiAtbWluKSA/IHplcm8gOiBhMzMpICsgY29tbWEgKyAoKGE0MyA8IG1pbiAmJiBhNDMgPiAtbWluKSA/IHplcm8gOiBhNDMpICsgY29tbWE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IFwiLDAsMCwwLDAsMSwwLFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zZm9ybSArPSB4ICsgY29tbWEgKyB5ICsgY29tbWEgKyB6ICsgY29tbWEgKyAocGVyc3BlY3RpdmUgPyAoMSArICgteiAvIHBlcnNwZWN0aXZlKSkgOiAxKSArIFwiKVwiO1xuXG5cdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblx0XHRcdH07XG5cblx0XHRwID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblx0XHRwLnggPSBwLnkgPSBwLnogPSBwLnNrZXdYID0gcC5za2V3WSA9IHAucm90YXRpb24gPSBwLnJvdGF0aW9uWCA9IHAucm90YXRpb25ZID0gcC56T3JpZ2luID0gcC54UGVyY2VudCA9IHAueVBlcmNlbnQgPSAwO1xuXHRcdHAuc2NhbGVYID0gcC5zY2FsZVkgPSBwLnNjYWxlWiA9IDE7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudFwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdGlmIChjc3NwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID09PSB2YXJzKSB7IHJldHVybiBwdDsgfSAvL29ubHkgbmVlZCB0byBwYXJzZSB0aGUgdHJhbnNmb3JtIG9uY2UsIGFuZCBvbmx5IGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGl0LlxuXHRcdFx0Y3NzcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9IHZhcnM7XG5cdFx0XHR2YXIgbTEgPSBjc3NwLl90cmFuc2Zvcm0gPSBfZ2V0VHJhbnNmb3JtKHQsIF9jcywgdHJ1ZSwgdmFycy5wYXJzZVRyYW5zZm9ybSksXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdGkgPSBfdHJhbnNmb3JtUHJvcHMubGVuZ3RoLFxuXHRcdFx0XHR2ID0gdmFycyxcblx0XHRcdFx0ZW5kUm90YXRpb25zID0ge30sXG5cdFx0XHRcdG0yLCBza2V3WSwgY29weSwgb3JpZywgaGFzM0QsIGhhc0NoYW5nZSwgZHI7XG5cdFx0XHRpZiAodHlwZW9mKHYudHJhbnNmb3JtKSA9PT0gXCJzdHJpbmdcIiAmJiBfdHJhbnNmb3JtUHJvcCkgeyAvL2ZvciB2YWx1ZXMgbGlrZSB0cmFuc2Zvcm06XCJyb3RhdGUoNjBkZWcpIHNjYWxlKDAuNSwgMC44KVwiXG5cdFx0XHRcdGNvcHkgPSBfdGVtcERpdi5zdHlsZTsgLy9kb24ndCB1c2UgdGhlIG9yaWdpbmFsIHRhcmdldCBiZWNhdXNlIGl0IG1pZ2h0IGJlIFNWRyBpbiB3aGljaCBjYXNlIHNvbWUgYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IGNvbXB1dGVkIHN0eWxlIGNvcnJlY3RseS5cblx0XHRcdFx0Y29weVtfdHJhbnNmb3JtUHJvcF0gPSB2LnRyYW5zZm9ybTtcblx0XHRcdFx0Y29weS5kaXNwbGF5ID0gXCJibG9ja1wiOyAvL2lmIGRpc3BsYXkgaXMgXCJub25lXCIsIHRoZSBicm93c2VyIG9mdGVuIHJlZnVzZXMgdG8gcmVwb3J0IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBjb3JyZWN0bHkuXG5cdFx0XHRcdGNvcHkucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRcdF9kb2MuYm9keS5hcHBlbmRDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdG0yID0gX2dldFRyYW5zZm9ybShfdGVtcERpdiwgbnVsbCwgZmFsc2UpO1xuXHRcdFx0XHRfZG9jLmJvZHkucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwib2JqZWN0XCIpIHsgLy9mb3IgdmFsdWVzIGxpa2Ugc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCB4LCB5LCBza2V3WCwgYW5kIHNrZXdZIG9yIHRyYW5zZm9ybTp7Li4ufSAob2JqZWN0KVxuXHRcdFx0XHRtMiA9IHtzY2FsZVg6X3BhcnNlVmFsKCh2LnNjYWxlWCAhPSBudWxsKSA/IHYuc2NhbGVYIDogdi5zY2FsZSwgbTEuc2NhbGVYKSxcblx0XHRcdFx0XHRzY2FsZVk6X3BhcnNlVmFsKCh2LnNjYWxlWSAhPSBudWxsKSA/IHYuc2NhbGVZIDogdi5zY2FsZSwgbTEuc2NhbGVZKSxcblx0XHRcdFx0XHRzY2FsZVo6X3BhcnNlVmFsKHYuc2NhbGVaLCBtMS5zY2FsZVopLFxuXHRcdFx0XHRcdHg6X3BhcnNlVmFsKHYueCwgbTEueCksXG5cdFx0XHRcdFx0eTpfcGFyc2VWYWwodi55LCBtMS55KSxcblx0XHRcdFx0XHR6Ol9wYXJzZVZhbCh2LnosIG0xLnopLFxuXHRcdFx0XHRcdHhQZXJjZW50Ol9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCksXG5cdFx0XHRcdFx0eVBlcmNlbnQ6X3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KSxcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZTpfcGFyc2VWYWwodi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSwgbTEucGVyc3BlY3RpdmUpfTtcblx0XHRcdFx0ZHIgPSB2LmRpcmVjdGlvbmFsUm90YXRpb247XG5cdFx0XHRcdGlmIChkciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihkcikgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRcdGZvciAoY29weSBpbiBkcikge1xuXHRcdFx0XHRcdFx0XHR2W2NvcHldID0gZHJbY29weV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHYucm90YXRpb24gPSBkcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2LngpID09PSBcInN0cmluZ1wiICYmIHYueC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRtMi54ID0gMDtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LngsIG0xLnhQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mKHYueSkgPT09IFwic3RyaW5nXCIgJiYgdi55LmluZGV4T2YoXCIlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdG0yLnkgPSAwO1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueSwgbTEueVBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bTIucm90YXRpb24gPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvblwiIGluIHYpID8gdi5yb3RhdGlvbiA6IChcInNob3J0Um90YXRpb25cIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvbiArIFwiX3Nob3J0XCIgOiAoXCJyb3RhdGlvblpcIiBpbiB2KSA/IHYucm90YXRpb25aIDogbTEucm90YXRpb24sIG0xLnJvdGF0aW9uLCBcInJvdGF0aW9uXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWCA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWFwiIGluIHYpID8gdi5yb3RhdGlvblggOiAoXCJzaG9ydFJvdGF0aW9uWFwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWCArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblggfHwgMCwgbTEucm90YXRpb25YLCBcInJvdGF0aW9uWFwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWSA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWVwiIGluIHYpID8gdi5yb3RhdGlvblkgOiAoXCJzaG9ydFJvdGF0aW9uWVwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWSArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblkgfHwgMCwgbTEucm90YXRpb25ZLCBcInJvdGF0aW9uWVwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG0yLnNrZXdYID0gKHYuc2tld1ggPT0gbnVsbCkgPyBtMS5za2V3WCA6IF9wYXJzZUFuZ2xlKHYuc2tld1gsIG0xLnNrZXdYKTtcblxuXHRcdFx0XHQvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMsIGlnbm9yaW5nIHNrZXdZIGJ1dCB3ZSBtdXN0IHN0aWxsIHJlY29yZCBpdCBzbyB0aGF0IHdlIGNhbiBkaXNjZXJuIGhvdyBtdWNoIG9mIHRoZSBvdmVyYWxsIHNrZXcgaXMgYXR0cmlidXRlZCB0byBza2V3WCB2cy4gc2tld1kuIE90aGVyd2lzZSwgaWYgdGhlIHNrZXdZIHdvdWxkIGFsd2F5cyBhY3QgcmVsYXRpdmUgKHR3ZWVuIHNrZXdZIHRvIDEwZGVnLCBmb3IgZXhhbXBsZSwgbXVsdGlwbGUgdGltZXMgYW5kIGlmIHdlIGFsd2F5cyBjb21iaW5lIHRoaW5ncyBpbnRvIHNrZXdYLCB3ZSBjYW4ndCByZW1lbWJlciB0aGF0IHNrZXdZIHdhcyAxMCBmcm9tIGxhc3QgdGltZSkuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAtMTAgZGVncmVlcy5cblx0XHRcdFx0bTIuc2tld1kgPSAodi5za2V3WSA9PSBudWxsKSA/IG0xLnNrZXdZIDogX3BhcnNlQW5nbGUodi5za2V3WSwgbTEuc2tld1kpO1xuXHRcdFx0XHRpZiAoKHNrZXdZID0gbTIuc2tld1kgLSBtMS5za2V3WSkpIHtcblx0XHRcdFx0XHRtMi5za2V3WCArPSBza2V3WTtcblx0XHRcdFx0XHRtMi5yb3RhdGlvbiArPSBza2V3WTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKF9zdXBwb3J0czNEICYmIHYuZm9yY2UzRCAhPSBudWxsKSB7XG5cdFx0XHRcdG0xLmZvcmNlM0QgPSB2LmZvcmNlM0Q7XG5cdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdG0xLnNrZXdUeXBlID0gdi5za2V3VHlwZSB8fCBtMS5za2V3VHlwZSB8fCBDU1NQbHVnaW4uZGVmYXVsdFNrZXdUeXBlO1xuXG5cdFx0XHRoYXMzRCA9IChtMS5mb3JjZTNEIHx8IG0xLnogfHwgbTEucm90YXRpb25YIHx8IG0xLnJvdGF0aW9uWSB8fCBtMi56IHx8IG0yLnJvdGF0aW9uWCB8fCBtMi5yb3RhdGlvblkgfHwgbTIucGVyc3BlY3RpdmUpO1xuXHRcdFx0aWYgKCFoYXMzRCAmJiB2LnNjYWxlICE9IG51bGwpIHtcblx0XHRcdFx0bTIuc2NhbGVaID0gMTsgLy9ubyBuZWVkIHRvIHR3ZWVuIHNjYWxlWi5cblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHAgPSBfdHJhbnNmb3JtUHJvcHNbaV07XG5cdFx0XHRcdG9yaWcgPSBtMltwXSAtIG0xW3BdO1xuXHRcdFx0XHRpZiAob3JpZyA+IG1pbiB8fCBvcmlnIDwgLW1pbiB8fCB2W3BdICE9IG51bGwgfHwgX2ZvcmNlUFRbcF0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBwLCBtMVtwXSwgb3JpZywgcHQpO1xuXHRcdFx0XHRcdGlmIChwIGluIGVuZFJvdGF0aW9ucykge1xuXHRcdFx0XHRcdFx0cHQuZSA9IGVuZFJvdGF0aW9uc1twXTsgLy9kaXJlY3Rpb25hbCByb3RhdGlvbnMgdHlwaWNhbGx5IGhhdmUgY29tcGVuc2F0ZWQgdmFsdWVzIGR1cmluZyB0aGUgdHdlZW4sIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGV5IGVuZCBhdCBleGFjdGx5IHdoYXQgdGhlIHVzZXIgcmVxdWVzdGVkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LnhzMCA9IDA7IC8vZW5zdXJlcyB0aGUgdmFsdWUgc3RheXMgbnVtZXJpYyBpbiBzZXRSYXRpbygpXG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocHQubik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0b3JpZyA9IHYudHJhbnNmb3JtT3JpZ2luO1xuXHRcdFx0aWYgKG0xLnN2ZyAmJiAob3JpZyB8fCB2LnN2Z09yaWdpbikpIHtcblx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9wYXJzZVBvc2l0aW9uKG9yaWcpLCBtMiwgdi5zdmdPcmlnaW4pO1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIFwieE9yaWdpblwiLCBtMS54T3JpZ2luLCBtMi54T3JpZ2luIC0gbTEueE9yaWdpbiwgcHQsIC0xLCBcInRyYW5zZm9ybU9yaWdpblwiKTtcblx0XHRcdFx0cHQuYiA9IG0xLnhPcmlnaW47XG5cdFx0XHRcdHB0LmUgPSBwdC54czAgPSBtMi54T3JpZ2luO1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIFwieU9yaWdpblwiLCBtMS55T3JpZ2luLCBtMi55T3JpZ2luIC0gbTEueU9yaWdpbiwgcHQsIC0xLCBcInRyYW5zZm9ybU9yaWdpblwiKTtcblx0XHRcdFx0cHQuYiA9IG0xLnlPcmlnaW47XG5cdFx0XHRcdHB0LmUgPSBwdC54czAgPSBtMi55T3JpZ2luO1xuXHRcdFx0XHRvcmlnID0gX3VzZVNWR1RyYW5zZm9ybUF0dHIgPyBudWxsIDogXCIwcHggMHB4XCI7IC8vY2VydGFpbiBicm93c2VycyAobGlrZSBmaXJlZm94KSBjb21wbGV0ZWx5IGJvdGNoIHRyYW5zZm9ybS1vcmlnaW4sIHNvIHdlIG11c3QgcmVtb3ZlIGl0IHRvIHByZXZlbnQgaXQgZnJvbSBjb250YW1pbmF0aW5nIHRyYW5zZm9ybXMuIFdlIG1hbmFnZSBpdCBvdXJzZWx2ZXMgd2l0aCB4T3JpZ2luIGFuZCB5T3JpZ2luXG5cdFx0XHR9XG5cdFx0XHRpZiAob3JpZyB8fCAoX3N1cHBvcnRzM0QgJiYgaGFzM0QgJiYgbTEuek9yaWdpbikpIHsgLy9pZiBhbnl0aGluZyAzRCBpcyBoYXBwZW5pbmcgYW5kIHRoZXJlJ3MgYSB0cmFuc2Zvcm1PcmlnaW4gd2l0aCBhIHogY29tcG9uZW50IHRoYXQncyBub24temVybywgd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgdHJhbnNmb3JtT3JpZ2luJ3Mgei1jb21wb25lbnQgaXMgc2V0IHRvIDAgc28gdGhhdCB3ZSBjYW4gbWFudWFsbHkgZG8gdGhvc2UgY2FsY3VsYXRpb25zIHRvIGdldCBhcm91bmQgU2FmYXJpIGJ1Z3MuIEV2ZW4gaWYgdGhlIHVzZXIgZGlkbid0IHNwZWNpZmljYWxseSBkZWZpbmUgYSBcInRyYW5zZm9ybU9yaWdpblwiIGluIHRoaXMgcGFydGljdWxhciB0d2VlbiAobWF5YmUgdGhleSBkaWQgaXQgdmlhIGNzcyBkaXJlY3RseSkuXG5cdFx0XHRcdGlmIChfdHJhbnNmb3JtUHJvcCkge1xuXHRcdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdFx0cCA9IF90cmFuc2Zvcm1PcmlnaW5Qcm9wO1xuXHRcdFx0XHRcdG9yaWcgPSAob3JpZyB8fCBfZ2V0U3R5bGUodCwgcCwgX2NzLCBmYWxzZSwgXCI1MCUgNTAlXCIpKSArIFwiXCI7IC8vY2FzdCBhcyBzdHJpbmcgdG8gYXZvaWQgZXJyb3JzXG5cdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCAwLCAwLCBwdCwgLTEsIFwidHJhbnNmb3JtT3JpZ2luXCIpO1xuXHRcdFx0XHRcdHB0LmIgPSBzdHlsZVtwXTtcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0XHRjb3B5ID0gbTEuek9yaWdpbjtcblx0XHRcdFx0XHRcdG9yaWcgPSBvcmlnLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRcdG0xLnpPcmlnaW4gPSAoKG9yaWcubGVuZ3RoID4gMiAmJiAhKGNvcHkgIT09IDAgJiYgb3JpZ1syXSA9PT0gXCIwcHhcIikpID8gcGFyc2VGbG9hdChvcmlnWzJdKSA6IGNvcHkpIHx8IDA7IC8vU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIHRoZSB6IHBhcnQgb2YgdHJhbnNmb3JtT3JpZ2luIGNvcnJlY3RseSwgc28gd2UnbGwgbWFudWFsbHkgaGFuZGxlIGl0IGluIHRoZSBfc2V0M0RUcmFuc2Zvcm1SYXRpbygpIG1ldGhvZC5cblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBvcmlnWzBdICsgXCIgXCIgKyAob3JpZ1sxXSB8fCBcIjUwJVwiKSArIFwiIDBweFwiOyAvL3dlIG11c3QgZGVmaW5lIGEgeiB2YWx1ZSBvZiAwcHggc3BlY2lmaWNhbGx5IG90aGVyd2lzZSBpT1MgNSBTYWZhcmkgd2lsbCBzdGljayB3aXRoIHRoZSBvbGQgb25lIChpZiBvbmUgd2FzIGRlZmluZWQpIVxuXHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBcInpPcmlnaW5cIiwgMCwgMCwgcHQsIC0xLCBwdC5uKTsgLy93ZSBtdXN0IGNyZWF0ZSBhIENTU1Byb3BUd2VlbiBmb3IgdGhlIF9nc1RyYW5zZm9ybS56T3JpZ2luIHNvIHRoYXQgaXQgZ2V0cyByZXNldCBwcm9wZXJseSBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSB0d2VlbiBydW5zIGJhY2t3YXJkIChhcyBvcHBvc2VkIHRvIGp1c3Qgc2V0dGluZyBtMS56T3JpZ2luIGhlcmUpXG5cdFx0XHRcdFx0XHRwdC5iID0gY29weTtcblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBtMS56T3JpZ2luO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gb3JpZztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSAoNi04KSwgd2UgbmVlZCB0byBtYW51YWxseSBjYWxjdWxhdGUgdGhpbmdzIGluc2lkZSB0aGUgc2V0UmF0aW8oKSBmdW5jdGlvbi4gV2UgcmVjb3JkIG9yaWdpbiB4IGFuZCB5IChveCBhbmQgb3kpIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWVzIGFyZSBwZXJjZW50YWdlcyAob3hwIGFuZCBveXApLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9wYXJzZVBvc2l0aW9uKG9yaWcgKyBcIlwiLCBtMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNDaGFuZ2UpIHtcblx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtVHlwZSA9ICghKG0xLnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgKGhhczNEIHx8IHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpKSA/IDMgOiAyOyAvL3F1aWNrZXIgdGhhbiBjYWxsaW5nIGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9LCBwcmVmaXg6dHJ1ZX0pO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm94U2hhZG93XCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAwcHggIzk5OVwiLCBwcmVmaXg6dHJ1ZSwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZSwga2V5d29yZDpcImluc2V0XCJ9KTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlclJhZGl1c1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR2YXIgcHJvcHMgPSBbXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIl0sXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0ZWExLCBpLCBlczIsIGJzMiwgYnMsIGVzLCBibiwgZW4sIHcsIGgsIGVzZngsIGJzZngsIHJlbCwgaG4sIHZuLCBlbTtcblx0XHRcdHcgPSBwYXJzZUZsb2F0KHQub2Zmc2V0V2lkdGgpO1xuXHRcdFx0aCA9IHBhcnNlRmxvYXQodC5vZmZzZXRIZWlnaHQpO1xuXHRcdFx0ZWExID0gZS5zcGxpdChcIiBcIik7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgLy9pZiB3ZSdyZSBkZWFsaW5nIHdpdGggcGVyY2VudGFnZXMsIHdlIG11c3QgY29udmVydCB0aGluZ3Mgc2VwYXJhdGVseSBmb3IgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGF4aXMhXG5cdFx0XHRcdGlmICh0aGlzLnAuaW5kZXhPZihcImJvcmRlclwiKSkgeyAvL29sZGVyIGJyb3dzZXJzIHVzZWQgYSBwcmVmaXhcblx0XHRcdFx0XHRwcm9wc1tpXSA9IF9jaGVja1Byb3BQcmVmaXgocHJvcHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJzID0gYnMyID0gX2dldFN0eWxlKHQsIHByb3BzW2ldLCBfY3MsIGZhbHNlLCBcIjBweFwiKTtcblx0XHRcdFx0aWYgKGJzLmluZGV4T2YoXCIgXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdGJzMiA9IGJzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRicyA9IGJzMlswXTtcblx0XHRcdFx0XHRiczIgPSBiczJbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXMgPSBlczIgPSBlYTFbaV07XG5cdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdGJzZnggPSBicy5zdWJzdHIoKGJuICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0cmVsID0gKGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUludChlcy5jaGFyQXQoMCkrXCIxXCIsIDEwKTtcblx0XHRcdFx0XHRlcyA9IGVzLnN1YnN0cigyKTtcblx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCAtIChlbiA8IDAgPyAxIDogMCkpIHx8IFwiXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRlc2Z4ID0gX3N1ZmZpeE1hcFtwXSB8fCBic2Z4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlc2Z4ICE9PSBic2Z4KSB7XG5cdFx0XHRcdFx0aG4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyTGVmdFwiLCBibiwgYnNmeCk7IC8vaG9yaXpvbnRhbCBudW1iZXIgKHdlIHVzZSBhIGJvZ3VzIFwiYm9yZGVyTGVmdFwiIHByb3BlcnR5IGp1c3QgYmVjYXVzZSB0aGUgX2NvbnZlcnRUb1BpeGVscygpIG1ldGhvZCBzZWFyY2hlcyBmb3IgdGhlIGtleXdvcmRzIFwiTGVmdFwiLCBcIlJpZ2h0XCIsIFwiVG9wXCIsIGFuZCBcIkJvdHRvbVwiIHRvIGRldGVybWluZSBvZiBpdCdzIGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0eSwgYW5kIHdlIG5lZWQgXCJib3JkZXJcIiBpbiB0aGUgbmFtZSBzbyB0aGF0IGl0IGtub3dzIGl0IHNob3VsZCBtZWFzdXJlIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50IGl0c2VsZiwgbm90IGl0cyBwYXJlbnQuXG5cdFx0XHRcdFx0dm4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyVG9wXCIsIGJuLCBic2Z4KTsgLy92ZXJ0aWNhbCBudW1iZXJcblx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gdyAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdGJzMiA9ICh2biAvIGggKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ID09PSBcImVtXCIpIHtcblx0XHRcdFx0XHRcdGVtID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlckxlZnRcIiwgMSwgXCJlbVwiKTtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdFx0YnMyID0gKHZuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRicyA9IGhuICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0YnMyID0gdm4gKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdGVzID0gKHBhcnNlRmxvYXQoYnMpICsgZW4pICsgZXNmeDtcblx0XHRcdFx0XHRcdGVzMiA9IChwYXJzZUZsb2F0KGJzMikgKyBlbikgKyBlc2Z4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHByb3BzW2ldLCBicyArIFwiIFwiICsgYnMyLCBlcyArIFwiIFwiICsgZXMyLCBmYWxzZSwgXCIwcHhcIiwgcHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH0sIHByZWZpeDp0cnVlLCBmb3JtYXR0ZXI6X2dldEZvcm1hdHRlcihcIjBweCAwcHggMHB4IDBweFwiLCBmYWxzZSwgdHJ1ZSl9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZ3JvdW5kUG9zaXRpb25cIiwge2RlZmF1bHRWYWx1ZTpcIjAgMFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIGJwID0gXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXG5cdFx0XHRcdGNzID0gKF9jcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKSksXG5cdFx0XHRcdGJzID0gdGhpcy5mb3JtYXQoICgoY3MpID8gX2llVmVycyA/IGNzLmdldFByb3BlcnR5VmFsdWUoYnAgKyBcIi14XCIpICsgXCIgXCIgKyBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwICsgXCIteVwiKSA6IGNzLmdldFByb3BlcnR5VmFsdWUoYnApIDogdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWCArIFwiIFwiICsgdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWSkgfHwgXCIwIDBcIiksIC8vSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCByZXBvcnQgYmFja2dyb3VuZC1wb3NpdGlvbiBjb3JyZWN0bHkgLSB3ZSBtdXN0IHF1ZXJ5IGJhY2tncm91bmQtcG9zaXRpb24teCBhbmQgYmFja2dyb3VuZC1wb3NpdGlvbi15IGFuZCBjb21iaW5lIHRoZW0gKGV2ZW4gaW4gSUUxMCkuIEJlZm9yZSBJRTksIHdlIG11c3QgZG8gdGhlIHNhbWUgd2l0aCB0aGUgY3VycmVudFN0eWxlIG9iamVjdCBhbmQgdXNlIGNhbWVsQ2FzZVxuXHRcdFx0XHRlcyA9IHRoaXMuZm9ybWF0KGUpLFxuXHRcdFx0XHRiYSwgZWEsIGksIHBjdCwgb3ZlcmxhcCwgc3JjO1xuXHRcdFx0aWYgKChicy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpICE9PSAoZXMuaW5kZXhPZihcIiVcIikgIT09IC0xKSkge1xuXHRcdFx0XHRzcmMgPSBfZ2V0U3R5bGUodCwgXCJiYWNrZ3JvdW5kSW1hZ2VcIikucmVwbGFjZShfdXJsRXhwLCBcIlwiKTtcblx0XHRcdFx0aWYgKHNyYyAmJiBzcmMgIT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YmEgPSBicy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0ZWEgPSBlcy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0X3RlbXBJbWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7IC8vc2V0IHRoZSB0ZW1wIElNRydzIHNyYyB0byB0aGUgYmFja2dyb3VuZC1pbWFnZSBzbyB0aGF0IHdlIGNhbiBtZWFzdXJlIGl0cyB3aWR0aC9oZWlnaHRcblx0XHRcdFx0XHRpID0gMjtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGJzID0gYmFbaV07XG5cdFx0XHRcdFx0XHRwY3QgPSAoYnMuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRcdGlmIChwY3QgIT09IChlYVtpXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJsYXAgPSAoaSA9PT0gMCkgPyB0Lm9mZnNldFdpZHRoIC0gX3RlbXBJbWcud2lkdGggOiB0Lm9mZnNldEhlaWdodCAtIF90ZW1wSW1nLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0YmFbaV0gPSBwY3QgPyAocGFyc2VGbG9hdChicykgLyAxMDAgKiBvdmVybGFwKSArIFwicHhcIiA6IChwYXJzZUZsb2F0KGJzKSAvIG92ZXJsYXAgKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJzID0gYmEuam9pbihcIiBcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCBicywgZXMsIHB0LCBwbHVnaW4pO1xuXHRcdH0sIGZvcm1hdHRlcjpfcGFyc2VQb3NpdGlvbn0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tncm91bmRTaXplXCIsIHtkZWZhdWx0VmFsdWU6XCIwIDBcIiwgZm9ybWF0dGVyOl9wYXJzZVBvc2l0aW9ufSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGVyc3BlY3RpdmVcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBlcnNwZWN0aXZlT3JpZ2luXCIsIHtkZWZhdWx0VmFsdWU6XCI1MCUgNTAlXCIsIHByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidHJhbnNmb3JtU3R5bGVcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2ZhY2VWaXNpYmlsaXR5XCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInVzZXJTZWxlY3RcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwibWFyZ2luXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIil9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwYWRkaW5nXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLHBhZGRpbmdMZWZ0XCIpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xpcFwiLCB7ZGVmYXVsdFZhbHVlOlwicmVjdCgwcHgsMHB4LDBweCwwcHgpXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKXtcblx0XHRcdHZhciBiLCBjcywgZGVsaW07XG5cdFx0XHRpZiAoX2llVmVycyA8IDkpIHsgLy9JRTggYW5kIGVhcmxpZXIgZG9uJ3QgcmVwb3J0IGEgXCJjbGlwXCIgdmFsdWUgaW4gdGhlIGN1cnJlbnRTdHlsZSAtIGluc3RlYWQsIHRoZSB2YWx1ZXMgYXJlIHNwbGl0IGFwYXJ0IGludG8gY2xpcFRvcCwgY2xpcFJpZ2h0LCBjbGlwQm90dG9tLCBhbmQgY2xpcExlZnQuIEFsc28sIGluIElFNyBhbmQgZWFybGllciwgdGhlIHZhbHVlcyBpbnNpZGUgcmVjdCgpIGFyZSBzcGFjZS1kZWxpbWl0ZWQsIG5vdCBjb21tYS1kZWxpbWl0ZWQuXG5cdFx0XHRcdGNzID0gdC5jdXJyZW50U3R5bGU7XG5cdFx0XHRcdGRlbGltID0gX2llVmVycyA8IDggPyBcIiBcIiA6IFwiLFwiO1xuXHRcdFx0XHRiID0gXCJyZWN0KFwiICsgY3MuY2xpcFRvcCArIGRlbGltICsgY3MuY2xpcFJpZ2h0ICsgZGVsaW0gKyBjcy5jbGlwQm90dG9tICsgZGVsaW0gKyBjcy5jbGlwTGVmdCArIFwiKVwiO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSkuc3BsaXQoXCIsXCIpLmpvaW4oZGVsaW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YiA9IHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCB0aGlzLnAsIF9jcywgZmFsc2UsIHRoaXMuZGZsdCkpO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgYiwgZSwgcHQsIHBsdWdpbik7XG5cdFx0fX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRleHRTaGFkb3dcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4ICM5OTlcIiwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImF1dG9Sb3VuZCxzdHJpY3RVbml0c1wiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0KSB7cmV0dXJuIHB0O319KTsgLy9qdXN0IHNvIHRoYXQgd2UgY2FuIGlnbm9yZSB0aGVzZSBwcm9wZXJ0aWVzIChub3QgdHdlZW4gdGhlbSlcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCBzb2xpZCAjMDAwXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BXaWR0aFwiLCBfY3MsIGZhbHNlLCBcIjBweFwiKSArIFwiIFwiICsgX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wU3R5bGVcIiwgX2NzLCBmYWxzZSwgXCJzb2xpZFwiKSArIFwiIFwiICsgX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wQ29sb3JcIiwgX2NzLCBmYWxzZSwgXCIjMDAwXCIpKSwgdGhpcy5mb3JtYXQoZSksIHB0LCBwbHVnaW4pO1xuXHRcdFx0fSwgY29sb3I6dHJ1ZSwgZm9ybWF0dGVyOmZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0cmV0dXJuIGFbMF0gKyBcIiBcIiArIChhWzFdIHx8IFwic29saWRcIikgKyBcIiBcIiArICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW1wiIzAwMFwiXSlbMF07XG5cdFx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyV2lkdGhcIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcImJvcmRlclRvcFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsYm9yZGVyTGVmdFdpZHRoXCIpfSk7IC8vRmlyZWZveCBkb2Vzbid0IHBpY2sgdXAgb24gYm9yZGVyV2lkdGggc2V0IGluIHN0eWxlIHNoZWV0cyAob25seSBpbmxpbmUpLlxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImZsb2F0LGNzc0Zsb2F0LHN0eWxlRmxvYXRcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgcyA9IHQuc3R5bGUsXG5cdFx0XHRcdHByb3AgPSAoXCJjc3NGbG9hdFwiIGluIHMpID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCI7XG5cdFx0XHRyZXR1cm4gbmV3IENTU1Byb3BUd2VlbihzLCBwcm9wLCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBzW3Byb3BdLCBlKTtcblx0XHR9fSk7XG5cblx0XHQvL29wYWNpdHktcmVsYXRlZFxuXHRcdHZhciBfc2V0SUVPcGFjaXR5UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy50LCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHByb3BlcnR5XG5cdFx0XHRcdFx0ZmlsdGVycyA9IHQuZmlsdGVyIHx8IF9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpIHx8IFwiXCIsXG5cdFx0XHRcdFx0dmFsID0gKHRoaXMucyArIHRoaXMuYyAqIHYpIHwgMCxcblx0XHRcdFx0XHRza2lwO1xuXHRcdFx0XHRpZiAodmFsID09PSAxMDApIHsgLy9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhhdCBuZWVkIHRvIHVzZSBhIGZpbHRlciB0byBhcHBseSBvcGFjaXR5LCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBmaWx0ZXIgaWYgb3BhY2l0eSBoaXRzIDEgaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IG1ha2Ugc3VyZSB0aGVyZSBpc24ndCBhIHRyYW5zZm9ybSAobWF0cml4KSBvciBncmFkaWVudCBpbiB0aGUgZmlsdGVycy5cblx0XHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiYXRyaXgoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJyYWRpZW50KFwiKSA9PT0gLTEgJiYgZmlsdGVycy5pbmRleE9mKFwib2FkZXIoXCIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gKCFfZ2V0U3R5bGUodGhpcy5kYXRhLCBcImZpbHRlclwiKSk7IC8vaWYgYSBjbGFzcyBpcyBhcHBsaWVkIHRoYXQgaGFzIGFuIGFscGhhIGZpbHRlciwgaXQgd2lsbCB0YWtlIGVmZmVjdCAod2UgZG9uJ3Qgd2FudCB0aGF0KSwgc28gcmUtYXBwbHkgb3VyIGFscGhhIGZpbHRlciBpbiB0aGF0IGNhc2UuIFdlIG11c3QgZmlyc3QgcmVtb3ZlIGl0IGFuZCB0aGVuIGNoZWNrLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfYWxwaGFGaWx0ZXJFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnhuMSkge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzID0gZmlsdGVycyB8fCAoXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCIpOyAvL3dvcmtzIGFyb3VuZCBidWcgaW4gSUU3LzggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseSBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEgb24gdGhlIHNhbWUgZnJhbWUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJwYWNpdHlcIikgPT09IC0xKSB7IC8vb25seSB1c2VkIGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBzdGFuZGFyZCBvcGFjaXR5IHN0eWxlIHByb3BlcnR5IChJRSA3IGFuZCA4KS4gV2Ugb21pdCB0aGUgXCJPXCIgdG8gYXZvaWQgY2FzZS1zZW5zaXRpdml0eSBpc3N1ZXNcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IDAgfHwgIXRoaXMueG4xKSB7IC8vYnVncyBpbiBJRTcvOCB3b24ndCByZW5kZXIgdGhlIGZpbHRlciBwcm9wZXJseSBpZiBvcGFjaXR5IGlzIEFEREVEIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBcInZpc2liaWxpdHlcIiBjaGFuZ2VzICh0aGlzLnhuMSBpcyAxIGlmIHRoaXMgdHdlZW4gaXMgYW4gXCJhdXRvQWxwaGFcIiB0d2Vlbilcblx0XHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzICsgXCIgYWxwaGEob3BhY2l0eT1cIiArIHZhbCArIFwiKVwiOyAvL3dlIHJvdW5kIHRoZSB2YWx1ZSBiZWNhdXNlIG90aGVyd2lzZSwgYnVncyBpbiBJRTcvOCBjYW4gcHJldmVudCBcInZpc2liaWxpdHlcIiBjaGFuZ2VzIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseS5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX29wYWNpdHlFeHAsIFwib3BhY2l0eT1cIiArIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm9wYWNpdHksYWxwaGEsYXV0b0FscGhhXCIsIHtkZWZhdWx0VmFsdWU6XCIxXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYiA9IHBhcnNlRmxvYXQoX2dldFN0eWxlKHQsIFwib3BhY2l0eVwiLCBfY3MsIGZhbHNlLCBcIjFcIikpLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdGlzQXV0b0FscGhhID0gKHAgPT09IFwiYXV0b0FscGhhXCIpO1xuXHRcdFx0aWYgKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0ZSA9ICgoZS5jaGFyQXQoMCkgPT09IFwiLVwiKSA/IC0xIDogMSkgKiBwYXJzZUZsb2F0KGUuc3Vic3RyKDIpKSArIGI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEgJiYgYiA9PT0gMSAmJiBfZ2V0U3R5bGUodCwgXCJ2aXNpYmlsaXR5XCIsIF9jcykgPT09IFwiaGlkZGVuXCIgJiYgZSAhPT0gMCkgeyAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuXHRcdFx0XHRiID0gMDtcblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHNPcGFjaXR5KSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIsIGUgLSBiLCBwdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIFwib3BhY2l0eVwiLCBiICogMTAwLCAoZSAtIGIpICogMTAwLCBwdCk7XG5cdFx0XHRcdHB0LnhuMSA9IGlzQXV0b0FscGhhID8gMSA6IDA7IC8vd2UgbmVlZCB0byByZWNvcmQgd2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhdXRvQWxwaGEgc28gdGhhdCBpbiB0aGUgc2V0UmF0aW8oKSwgd2Uga25vdyB0byBkdXBsaWNhdGUgdGhlIHNldHRpbmcgb2YgdGhlIGFscGhhIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFNyBhbmQgSUU4IHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInZpc2liaWxpdHlcIiBmcm9tIHRha2luZyBlZmZlY3QgaWYgdGhlIGZpbHRlciBpcyBjaGFuZ2VkIHRvIGEgZGlmZmVyZW50IGFscGhhKG9wYWNpdHkpIGF0IHRoZSBzYW1lIHRpbWUuIFNldHRpbmcgaXQgdG8gdGhlIFNBTUUgdmFsdWUgZmlyc3QsIHRoZW4gdGhlIG5ldyB2YWx1ZSB3b3JrcyBhcm91bmQgdGhlIElFNy84IGJ1Zy5cblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0cHQudHlwZSA9IDI7XG5cdFx0XHRcdHB0LmIgPSBcImFscGhhKG9wYWNpdHk9XCIgKyBwdC5zICsgXCIpXCI7XG5cdFx0XHRcdHB0LmUgPSBcImFscGhhKG9wYWNpdHk9XCIgKyAocHQucyArIHB0LmMpICsgXCIpXCI7XG5cdFx0XHRcdHB0LmRhdGEgPSB0O1xuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gX3NldElFT3BhY2l0eVJhdGlvO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXV0b0FscGhhKSB7IC8vd2UgaGF2ZSB0byBjcmVhdGUgdGhlIFwidmlzaWJpbGl0eVwiIFByb3BUd2VlbiBhZnRlciB0aGUgb3BhY2l0eSBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0IHNvIHRoYXQgdGhleSBydW4gaW4gdGhlIG9yZGVyIHRoYXQgd29ya3MgcHJvcGVybHkgaW4gSUU4IGFuZCBlYXJsaWVyXG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJ2aXNpYmlsaXR5XCIsIDAsIDAsIHB0LCAtMSwgbnVsbCwgZmFsc2UsIDAsICgoYiAhPT0gMCkgPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIpLCAoKGUgPT09IDApID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiKSk7XG5cdFx0XHRcdHB0LnhzMCA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXG5cdFx0dmFyIF9yZW1vdmVQcm9wID0gZnVuY3Rpb24ocywgcCkge1xuXHRcdFx0XHRpZiAocCkge1xuXHRcdFx0XHRcdGlmIChzLnJlbW92ZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRpZiAocC5zdWJzdHIoMCwyKSA9PT0gXCJtc1wiIHx8IHAuc3Vic3RyKDAsNikgPT09IFwid2Via2l0XCIpIHsgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdFx0XHRwID0gXCItXCIgKyBwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cy5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuXHRcdFx0XHRcdFx0cy5yZW1vdmVBdHRyaWJ1dGUocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3NldENsYXNzTmFtZVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IHRoaXM7XG5cdFx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgKHYgPT09IDApID8gdGhpcy5iIDogdGhpcy5lKTtcblx0XHRcdFx0XHR2YXIgbXB0ID0gdGhpcy5kYXRhLCAvL2ZpcnN0IE1pbmlQcm9wVHdlZW5cblx0XHRcdFx0XHRcdHMgPSB0aGlzLnQuc3R5bGU7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0aWYgKCFtcHQudikge1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBtcHQucCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzW21wdC5wXSA9IG1wdC52O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodiA9PT0gMSAmJiB0aGlzLnQuX2dzQ2xhc3NQVCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy50Ll9nc0NsYXNzUFQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgIT09IHRoaXMuZSkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsYXNzTmFtZVwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdHZhciBiID0gdC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiLCAvL2Rvbid0IHVzZSB0LmNsYXNzTmFtZSBiZWNhdXNlIGl0IGRvZXNuJ3Qgd29yayBjb25zaXN0ZW50bHkgb24gU1ZHIGVsZW1lbnRzOyBnZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSBhbmQgc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWVcIikgaXMgbW9yZSByZWxpYWJsZS5cblx0XHRcdFx0Y3NzVGV4dCA9IHQuc3R5bGUuY3NzVGV4dCxcblx0XHRcdFx0ZGlmRGF0YSwgYnMsIGNucHQsIGNucHRMb29rdXAsIG1wdDtcblx0XHRcdHB0ID0gY3NzcC5fY2xhc3NOYW1lUFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsYXNzTmFtZVJhdGlvO1xuXHRcdFx0cHQucHIgPSAtMTE7XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cHQuYiA9IGI7XG5cdFx0XHRicyA9IF9nZXRBbGxTdHlsZXModCwgX2NzKTtcblx0XHRcdC8vaWYgdGhlcmUncyBhIGNsYXNzTmFtZSB0d2VlbiBhbHJlYWR5IG9wZXJhdGluZyBvbiB0aGUgdGFyZ2V0LCBmb3JjZSBpdCB0byBpdHMgZW5kIHNvIHRoYXQgdGhlIG5lY2Vzc2FyeSBpbmxpbmUgc3R5bGVzIGFyZSByZW1vdmVkIGFuZCB0aGUgY2xhc3MgbmFtZSBpcyBhcHBsaWVkIGJlZm9yZSB3ZSBkZXRlcm1pbmUgdGhlIGVuZCBzdGF0ZSAod2UgZG9uJ3Qgd2FudCBpbmxpbmUgc3R5bGVzIGludGVyZmVyaW5nIHRoYXQgd2VyZSB0aGVyZSBqdXN0IGZvciBjbGFzcy1zcGVjaWZpYyB2YWx1ZXMpXG5cdFx0XHRjbnB0ID0gdC5fZ3NDbGFzc1BUO1xuXHRcdFx0aWYgKGNucHQpIHtcblx0XHRcdFx0Y25wdExvb2t1cCA9IHt9O1xuXHRcdFx0XHRtcHQgPSBjbnB0LmRhdGE7IC8vZmlyc3QgTWluaVByb3BUd2VlbiB3aGljaCBzdG9yZXMgdGhlIGlubGluZSBzdHlsZXMgLSB3ZSBuZWVkIHRvIGZvcmNlIHRoZXNlIHNvIHRoYXQgdGhlIGlubGluZSBzdHlsZXMgZG9uJ3QgY29udGFtaW5hdGUgdGhpbmdzLiBPdGhlcndpc2UsIHRoZXJlJ3MgYSBzbWFsbCBjaGFuY2UgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IGFuZCB0aGUgaW5saW5lIHZhbHVlcyBtYXRjaCB0aGUgZGVzdGluYXRpb24gdmFsdWVzIGFuZCB0aGV5IG5ldmVyIGdldCBjbGVhbmVkLlxuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0Y25wdExvb2t1cFttcHQucF0gPSAxO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbnB0LnNldFJhdGlvKDEpO1xuXHRcdFx0fVxuXHRcdFx0dC5fZ3NDbGFzc1BUID0gcHQ7XG5cdFx0XHRwdC5lID0gKGUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlIDogYi5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxccypcXFxcYlwiICsgZS5zdWJzdHIoMikgKyBcIlxcXFxiXCIpLCBcIlwiKSArICgoZS5jaGFyQXQoMCkgPT09IFwiK1wiKSA/IFwiIFwiICsgZS5zdWJzdHIoMikgOiBcIlwiKTtcblx0XHRcdHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcHQuZSk7XG5cdFx0XHRkaWZEYXRhID0gX2Nzc0RpZih0LCBicywgX2dldEFsbFN0eWxlcyh0KSwgdmFycywgY25wdExvb2t1cCk7XG5cdFx0XHR0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGIpO1xuXHRcdFx0cHQuZGF0YSA9IGRpZkRhdGEuZmlyc3RNUFQ7XG5cdFx0XHR0LnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0OyAvL3dlIHJlY29yZGVkIGNzc1RleHQgYmVmb3JlIHdlIHN3YXBwZWQgY2xhc3NlcyBhbmQgcmFuIF9nZXRBbGxTdHlsZXMoKSBiZWNhdXNlIGluIGNhc2VzIHdoZW4gYSBjbGFzc05hbWUgdHdlZW4gaXMgb3ZlcndyaXR0ZW4sIHdlIHJlbW92ZSBhbGwgdGhlIHJlbGF0ZWQgdHdlZW5pbmcgcHJvcGVydGllcyBmcm9tIHRoYXQgY2xhc3MgY2hhbmdlIChvdGhlcndpc2UgY2xhc3Mtc3BlY2lmaWMgc3R1ZmYgY2FuJ3Qgb3ZlcnJpZGUgcHJvcGVydGllcyB3ZSd2ZSBkaXJlY3RseSBzZXQgb24gdGhlIHRhcmdldCdzIHN0eWxlIG9iamVjdCBkdWUgdG8gc3BlY2lmaWNpdHkpLlxuXHRcdFx0cHQgPSBwdC54Zmlyc3QgPSBjc3NwLnBhcnNlKHQsIGRpZkRhdGEuZGlmcywgcHQsIHBsdWdpbik7IC8vd2UgcmVjb3JkIHRoZSBDU1NQcm9wVHdlZW4gYXMgdGhlIHhmaXJzdCBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgb3ZlcndyaXRpbmcgcHJvcGVydGx5IChpZiBcImNsYXNzTmFtZVwiIGdldHMgb3ZlcndyaXR0ZW4sIHdlIG11c3Qga2lsbCBhbGwgdGhlIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGFzc05hbWUgcGFydCBvZiB0aGUgdHdlZW4sIHNvIHdlIGNhbiBsb29wIHRocm91Z2ggZnJvbSB4Zmlyc3QgdG8gdGhlIHB0IGl0c2VsZilcblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblxuXHRcdHZhciBfc2V0Q2xlYXJQcm9wc1JhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkgaWYgKHRoaXMuZGF0YS5fdG90YWxUaW1lID09PSB0aGlzLmRhdGEuX3RvdGFsRHVyYXRpb24gJiYgdGhpcy5kYXRhLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikgeyAvL3RoaXMuZGF0YSByZWZlcnMgdG8gdGhlIHR3ZWVuLiBPbmx5IGNsZWFyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBtYWtlIHRoZSByYXRpbyBnbyBmcm9tIDEgdG8gMCwgc28gd2UgY2FuJ3QganVzdCBjaGVjayB0aGF0IGFuZCBpZiB0aGUgdHdlZW4gaXMgdGhlIHplcm8tZHVyYXRpb24gb25lIHRoYXQncyBjcmVhdGVkIGludGVybmFsbHkgdG8gcmVuZGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgaW4gYSBmcm9tKCkgdHdlZW4sIGlnbm9yZSB0aGF0IGJlY2F1c2Ugb3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4pLlxuXHRcdFx0XHR2YXIgcyA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHR0cmFuc2Zvcm1QYXJzZSA9IF9zcGVjaWFsUHJvcHMudHJhbnNmb3JtLnBhcnNlLFxuXHRcdFx0XHRcdGEsIHAsIGksIGNsZWFyVHJhbnNmb3JtLCB0cmFuc2Zvcm07XG5cdFx0XHRcdGlmICh0aGlzLmUgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0XHRzLmNzc1RleHQgPSBcIlwiO1xuXHRcdFx0XHRcdGNsZWFyVHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhID0gdGhpcy5lLnNwbGl0KFwiIFwiKS5qb2luKFwiXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwID0gYVtpXTtcblx0XHRcdFx0XHRcdGlmIChfc3BlY2lhbFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChfc3BlY2lhbFByb3BzW3BdLnBhcnNlID09PSB0cmFuc2Zvcm1QYXJzZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsZWFyVHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwID0gKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpID8gX3RyYW5zZm9ybU9yaWdpblByb3AgOiBfc3BlY2lhbFByb3BzW3BdLnA7IC8vZW5zdXJlcyB0aGF0IHNwZWNpYWwgcHJvcGVydGllcyB1c2UgdGhlIHByb3BlciBicm93c2VyLXNwZWNpZmljIHByb3BlcnR5IG5hbWUsIGxpa2UgXCJzY2FsZVhcIiBtaWdodCBiZSBcIi13ZWJraXQtdHJhbnNmb3JtXCIgb3IgXCJib3hTaGFkb3dcIiBtaWdodCBiZSBcIi1tb3otYm94LXNoYWRvd1wiXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xlYXJUcmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gdGhpcy50Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0XHRpZiAodHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMudC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsZWFyUHJvcHNcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCkge1xuXHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsZWFyUHJvcHNSYXRpbztcblx0XHRcdHB0LmUgPSBlO1xuXHRcdFx0cHQucHIgPSAtMTA7XG5cdFx0XHRwdC5kYXRhID0gY3NzcC5fdHdlZW47XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXHRcdHAgPSBcImJlemllcix0aHJvd1Byb3BzLHBoeXNpY3NQcm9wcyxwaHlzaWNzMkRcIi5zcGxpdChcIixcIik7XG5cdFx0aSA9IHAubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdF9yZWdpc3RlclBsdWdpblByb3AocFtpXSk7XG5cdFx0fVxuXG5cblxuXG5cblxuXG5cblx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZTtcblx0XHRwLl9maXJzdFBUID0gcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9IHAuX3RyYW5zZm9ybSA9IG51bGw7XG5cblx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGtpY2tzIGV2ZXJ5dGhpbmcgb2ZmLCByZWNvcmRpbmcgc3RhcnQvZW5kIHZhbHVlcywgZXRjLlxuXHRcdHAuX29uSW5pdFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0aWYgKCF0YXJnZXQubm9kZVR5cGUpIHsgLy9jc3MgaXMgb25seSBmb3IgZG9tIGVsZW1lbnRzXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHR0aGlzLl92YXJzID0gdmFycztcblx0XHRcdF9hdXRvUm91bmQgPSB2YXJzLmF1dG9Sb3VuZDtcblx0XHRcdF9oYXNQcmlvcml0eSA9IGZhbHNlO1xuXHRcdFx0X3N1ZmZpeE1hcCA9IHZhcnMuc3VmZml4TWFwIHx8IENTU1BsdWdpbi5zdWZmaXhNYXA7XG5cdFx0XHRfY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsIFwiXCIpO1xuXHRcdFx0X292ZXJ3cml0ZVByb3BzID0gdGhpcy5fb3ZlcndyaXRlUHJvcHM7XG5cdFx0XHR2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHYsIHB0LCBwdDIsIGZpcnN0LCBsYXN0LCBuZXh0LCB6SW5kZXgsIHRwdCwgdGhyZWVEO1xuXHRcdFx0aWYgKF9yZXFTYWZhcmlGaXgpIGlmIChzdHlsZS56SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0diA9IF9nZXRTdHlsZSh0YXJnZXQsIFwiekluZGV4XCIsIF9jcyk7XG5cdFx0XHRcdGlmICh2ID09PSBcImF1dG9cIiB8fCB2ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0Ly9jb3JyZWN0cyBhIGJ1ZyBpbiBbbm9uLUFuZHJvaWRdIFNhZmFyaSB0aGF0IHByZXZlbnRzIGl0IGZyb20gcmVwYWludGluZyBlbGVtZW50cyBpbiB0aGVpciBuZXcgcG9zaXRpb25zIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHpJbmRleCBzZXQuIFdlIGFsc28gY2FuJ3QganVzdCBhcHBseSB0aGlzIGluc2lkZSBfcGFyc2VUcmFuc2Zvcm0oKSBiZWNhdXNlIGFueXRoaW5nIHRoYXQncyBtb3ZlZCBpbiBhbnkgd2F5IChsaWtlIHVzaW5nIFwibGVmdFwiIG9yIFwidG9wXCIgaW5zdGVhZCBvZiB0cmFuc2Zvcm1zIGxpa2UgXCJ4XCIgYW5kIFwieVwiKSBjYW4gYmUgYWZmZWN0ZWQsIHNvIGl0IGlzIGJlc3QgdG8gZW5zdXJlIHRoYXQgYW55dGhpbmcgdGhhdCdzIHR3ZWVuaW5nIGhhcyBhIHotaW5kZXguIFNldHRpbmcgXCJXZWJraXRQZXJzcGVjdGl2ZVwiIHRvIGEgbm9uLXplcm8gdmFsdWUgd29ya2VkIHRvbyBleGNlcHQgdGhhdCBvbiBpT1MgU2FmYXJpIHRoaW5ncyB3b3VsZCBmbGlja2VyIHJhbmRvbWx5LiBQbHVzIHpJbmRleCBpcyBsZXNzIG1lbW9yeS1pbnRlbnNpdmUuXG5cdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJ6SW5kZXhcIiwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZih2YXJzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmaXJzdCA9IHN0eWxlLmNzc1RleHQ7XG5cdFx0XHRcdHYgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCwgX2NzKTtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGZpcnN0ICsgXCI7XCIgKyB2YXJzO1xuXHRcdFx0XHR2ID0gX2Nzc0RpZih0YXJnZXQsIHYsIF9nZXRBbGxTdHlsZXModGFyZ2V0KSkuZGlmcztcblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5ICYmIF9vcGFjaXR5VmFsRXhwLnRlc3QodmFycykpIHtcblx0XHRcdFx0XHR2Lm9wYWNpdHkgPSBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXJzID0gdjtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFycy5jbGFzc05hbWUpIHsgLy9jbGFzc05hbWUgdHdlZW5zIHdpbGwgY29tYmluZSBhbnkgZGlmZmVyZW5jZXMgdGhleSBmaW5kIGluIHRoZSBjc3Mgd2l0aCB0aGUgdmFycyB0aGF0IGFyZSBwYXNzZWQgaW4sIHNvIHtjbGFzc05hbWU6XCJteUNsYXNzXCIsIHNjYWxlOjAuNSwgbGVmdDoyMH0gd291bGQgd29yay5cblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0gX3NwZWNpYWxQcm9wcy5jbGFzc05hbWUucGFyc2UodGFyZ2V0LCB2YXJzLmNsYXNzTmFtZSwgXCJjbGFzc05hbWVcIiwgdGhpcywgbnVsbCwgbnVsbCwgdmFycyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB0aGlzLnBhcnNlKHRhcmdldCwgdmFycywgbnVsbCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90cmFuc2Zvcm1UeXBlKSB7XG5cdFx0XHRcdHRocmVlRCA9ICh0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKTtcblx0XHRcdFx0aWYgKCFfdHJhbnNmb3JtUHJvcCkge1xuXHRcdFx0XHRcdHN0eWxlLnpvb20gPSAxOyAvL2hlbHBzIGNvcnJlY3QgYW4gSUUgaXNzdWUuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX2lzU2FmYXJpKSB7XG5cdFx0XHRcdFx0X3JlcVNhZmFyaUZpeCA9IHRydWU7XG5cdFx0XHRcdFx0Ly9pZiB6SW5kZXggaXNuJ3Qgc2V0LCBpT1MgU2FmYXJpIGRvZXNuJ3QgcmVwYWludCB0aGluZ3MgY29ycmVjdGx5IHNvbWV0aW1lcyAoc2VlbWluZ2x5IGF0IHJhbmRvbSkuXG5cdFx0XHRcdFx0aWYgKHN0eWxlLnpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0ekluZGV4ID0gX2dldFN0eWxlKHRhcmdldCwgXCJ6SW5kZXhcIiwgX2NzKTtcblx0XHRcdFx0XHRcdGlmICh6SW5kZXggPT09IFwiYXV0b1wiIHx8IHpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcInpJbmRleFwiLCAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9TZXR0aW5nIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSBjb3JyZWN0cyAzIGJ1Z3M6XG5cdFx0XHRcdFx0Ly8gMSkgW25vbi1BbmRyb2lkXSBTYWZhcmkgc2tpcHMgcmVuZGVyaW5nIGNoYW5nZXMgdG8gXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgdGhhdCBhcmUgbWFkZSBvbiB0aGUgc2FtZSBmcmFtZS9yZW5kZXIgYXMgYSB0cmFuc2Zvcm0gdXBkYXRlLlxuXHRcdFx0XHRcdC8vIDIpIGlPUyBTYWZhcmkgc29tZXRpbWVzIG5lZ2xlY3RzIHRvIHJlcGFpbnQgZWxlbWVudHMgaW4gdGhlaXIgbmV3IHBvc2l0aW9ucy4gU2V0dGluZyBcIldlYmtpdFBlcnNwZWN0aXZlXCIgdG8gYSBub24temVybyB2YWx1ZSB3b3JrZWQgdG9vIGV4Y2VwdCB0aGF0IG9uIGlPUyBTYWZhcmkgdGhpbmdzIHdvdWxkIGZsaWNrZXIgcmFuZG9tbHkuXG5cdFx0XHRcdFx0Ly8gMykgU2FmYXJpIHNvbWV0aW1lcyBkaXNwbGF5ZWQgb2RkIGFydGlmYWN0cyB3aGVuIHR3ZWVuaW5nIHRoZSB0cmFuc2Zvcm0gKG9yIFdlYmtpdFRyYW5zZm9ybSkgcHJvcGVydHksIGxpa2UgZ2hvc3RzIG9mIHRoZSBlZGdlcyBvZiB0aGUgZWxlbWVudCByZW1haW5lZC4gRGVmaW5pdGVseSBhIGJyb3dzZXIgYnVnLlxuXHRcdFx0XHRcdC8vTm90ZTogd2UgYWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGF1dG8tc2V0dGluZyBieSBkZWZpbmluZyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgaW4gdGhlIHZhcnMgb2YgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdGlmIChfaXNTYWZhcmlMVDYpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsIHRoaXMuX3ZhcnMuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IHx8ICh0aHJlZUQgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQyID0gcHQ7XG5cdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLl9uZXh0KSB7XG5cdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odGFyZ2V0LCBcInRyYW5zZm9ybVwiLCAwLCAwLCBudWxsLCAyKTtcblx0XHRcdFx0dGhpcy5fbGlua0NTU1AodHB0LCBudWxsLCBwdDIpO1xuXHRcdFx0XHR0cHQuc2V0UmF0aW8gPSBfdHJhbnNmb3JtUHJvcCA/IF9zZXRUcmFuc2Zvcm1SYXRpbyA6IF9zZXRJRVRyYW5zZm9ybVJhdGlvO1xuXHRcdFx0XHR0cHQuZGF0YSA9IHRoaXMuX3RyYW5zZm9ybSB8fCBfZ2V0VHJhbnNmb3JtKHRhcmdldCwgX2NzLCB0cnVlKTtcblx0XHRcdFx0dHB0LnR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdHRwdC5wciA9IC0xOyAvL2Vuc3VyZXMgdGhhdCB0aGUgdHJhbnNmb3JtcyBnZXQgYXBwbGllZCBhZnRlciB0aGUgY29tcG9uZW50cyBhcmUgdXBkYXRlZC5cblx0XHRcdFx0X292ZXJ3cml0ZVByb3BzLnBvcCgpOyAvL3dlIGRvbid0IHdhbnQgdG8gZm9yY2UgdGhlIG92ZXJ3cml0ZSBvZiBhbGwgXCJ0cmFuc2Zvcm1cIiB0d2VlbnMgb2YgdGhlIHRhcmdldCAtIHdlIG9ubHkgY2FyZSBhYm91dCBpbmRpdmlkdWFsIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGVYLCByb3RhdGlvbiwgZXRjLiBUaGUgQ1NTUHJvcFR3ZWVuIGNvbnN0cnVjdG9yIGF1dG9tYXRpY2FsbHkgYWRkcyB0aGUgcHJvcGVydHkgdG8gX292ZXJ3cml0ZVByb3BzIHdoaWNoIGlzIHdoeSB3ZSBuZWVkIHRvIHBvcCgpIGhlcmUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChfaGFzUHJpb3JpdHkpIHtcblx0XHRcdFx0Ly9yZW9yZGVycyB0aGUgbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHIgKHByaW9yaXR5KVxuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cHQyID0gZmlyc3Q7XG5cdFx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuXHRcdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcnN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSBwdDIpKSB7XG5cdFx0XHRcdFx0XHRwdDIuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXG5cdFx0cC5wYXJzZSA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0XHRwLCBzcCwgYm4sIGVuLCBicywgZXMsIGJzZngsIGVzZngsIGlzU3RyLCByZWw7XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRlcyA9IHZhcnNbcF07IC8vZW5kaW5nIHZhbHVlIHN0cmluZ1xuXHRcdFx0XHRzcCA9IF9zcGVjaWFsUHJvcHNbcF07IC8vU3BlY2lhbFByb3AgbG9va3VwLlxuXHRcdFx0XHRpZiAoc3ApIHtcblx0XHRcdFx0XHRwdCA9IHNwLnBhcnNlKHRhcmdldCwgZXMsIHAsIHRoaXMsIHB0LCBwbHVnaW4sIHZhcnMpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnMgPSBfZ2V0U3R5bGUodGFyZ2V0LCBwLCBfY3MpICsgXCJcIjtcblx0XHRcdFx0XHRpc1N0ciA9ICh0eXBlb2YoZXMpID09PSBcInN0cmluZ1wiKTtcblx0XHRcdFx0XHRpZiAocCA9PT0gXCJjb2xvclwiIHx8IHAgPT09IFwiZmlsbFwiIHx8IHAgPT09IFwic3Ryb2tlXCIgfHwgcC5pbmRleE9mKFwiQ29sb3JcIikgIT09IC0xIHx8IChpc1N0ciAmJiBfcmdiaHNsRXhwLnRlc3QoZXMpKSkgeyAvL09wZXJhIHVzZXMgYmFja2dyb3VuZDogdG8gZGVmaW5lIGNvbG9yIHNvbWV0aW1lcyBpbiBhZGRpdGlvbiB0byBiYWNrZ3JvdW5kQ29sb3I6XG5cdFx0XHRcdFx0XHRpZiAoIWlzU3RyKSB7XG5cdFx0XHRcdFx0XHRcdGVzID0gX3BhcnNlQ29sb3IoZXMpO1xuXHRcdFx0XHRcdFx0XHRlcyA9ICgoZXMubGVuZ3RoID4gMykgPyBcInJnYmEoXCIgOiBcInJnYihcIikgKyBlcy5qb2luKFwiLFwiKSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwLCBicywgZXMsIHRydWUsIFwidHJhbnNwYXJlbnRcIiwgcHQsIDAsIHBsdWdpbik7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzU3RyICYmIChlcy5pbmRleE9mKFwiIFwiKSAhPT0gLTEgfHwgZXMuaW5kZXhPZihcIixcIikgIT09IC0xKSkge1xuXHRcdFx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwLCBicywgZXMsIHRydWUsIG51bGwsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdFx0XHRic2Z4ID0gKGJuIHx8IGJuID09PSAwKSA/IGJzLnN1YnN0cigoYm4gKyBcIlwiKS5sZW5ndGgpIDogXCJcIjsgLy9yZW1lbWJlciwgYnMgY291bGQgYmUgbm9uLW51bWVyaWMgbGlrZSBcIm5vcm1hbFwiIGZvciBmb250V2VpZ2h0LCBzbyB3ZSBzaG91bGQgZGVmYXVsdCB0byBhIGJsYW5rIHN1ZmZpeCBpbiB0aGF0IGNhc2UuXG5cblx0XHRcdFx0XHRcdGlmIChicyA9PT0gXCJcIiB8fCBicyA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSBfZ2V0RGltZW5zaW9uKHRhcmdldCwgcCwgX2NzKTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwibGVmdFwiIHx8IHAgPT09IFwidG9wXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IF9jYWxjdWxhdGVPZmZzZXQodGFyZ2V0LCBwLCBfY3MpO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSAocCAhPT0gXCJvcGFjaXR5XCIpID8gMCA6IDE7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVsID0gKGlzU3RyICYmIGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlSW50KGVzLmNoYXJBdCgwKSArIFwiMVwiLCAxMCk7XG5cdFx0XHRcdFx0XHRcdGVzID0gZXMuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IGVzLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gaXNTdHIgPyBlcy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpIDogXCJcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IChwIGluIF9zdWZmaXhNYXApID8gX3N1ZmZpeE1hcFtwXSA6IGJzZng7IC8vcG9wdWxhdGUgdGhlIGVuZCBzdWZmaXgsIHByaW9yaXRpemluZyB0aGUgbWFwLCB0aGVuIGlmIG5vbmUgaXMgZm91bmQsIHVzZSB0aGUgYmVnaW5uaW5nIHN1ZmZpeC5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXMgPSAoZW4gfHwgZW4gPT09IDApID8gKHJlbCA/IGVuICsgYm4gOiBlbikgKyBlc2Z4IDogdmFyc1twXTsgLy9lbnN1cmVzIHRoYXQgYW55ICs9IG9yIC09IHByZWZpeGVzIGFyZSB0YWtlbiBjYXJlIG9mLiBSZWNvcmQgdGhlIGVuZCB2YWx1ZSBiZWZvcmUgbm9ybWFsaXppbmcgdGhlIHN1ZmZpeCBiZWNhdXNlIHdlIGFsd2F5cyB3YW50IHRvIGVuZCB0aGUgdHdlZW4gb24gZXhhY3RseSB3aGF0IHRoZXkgaW50ZW5kZWQgZXZlbiBpZiBpdCBkb2Vzbid0IG1hdGNoIHRoZSBiZWdpbm5pbmcgdmFsdWUncyBzdWZmaXguXG5cblx0XHRcdFx0XHRcdC8vaWYgdGhlIGJlZ2lubmluZy9lbmRpbmcgc3VmZml4ZXMgZG9uJ3QgbWF0Y2gsIG5vcm1hbGl6ZSB0aGVtLi4uXG5cdFx0XHRcdFx0XHRpZiAoYnNmeCAhPT0gZXNmeCkgaWYgKGVzZnggIT09IFwiXCIpIGlmIChlbiB8fCBlbiA9PT0gMCkgaWYgKGJuKSB7IC8vbm90ZTogaWYgdGhlIGJlZ2lubmluZyB2YWx1ZSAoYm4pIGlzIDAsIHdlIGRvbid0IG5lZWQgdG8gY29udmVydCB1bml0cyFcblx0XHRcdFx0XHRcdFx0Ym4gPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgYm4sIGJzZngpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiAvPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgMTAwLCBcIiVcIikgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhcnMuc3RyaWN0VW5pdHMgIT09IHRydWUpIHsgLy9zb21lIGJyb3dzZXJzIHJlcG9ydCBvbmx5IFwicHhcIiB2YWx1ZXMgaW5zdGVhZCBvZiBhbGxvd2luZyBcIiVcIiB3aXRoIGdldENvbXB1dGVkU3R5bGUoKSwgc28gd2UgYXNzdW1lIHRoYXQgaWYgd2UncmUgdHdlZW5pbmcgdG8gYSAlLCB3ZSBzaG91bGQgc3RhcnQgdGhlcmUgdG9vIHVubGVzcyBzdHJpY3RVbml0czp0cnVlIGlzIGRlZmluZWQuIFRoaXMgYXBwcm9hY2ggaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgcmVzcG9uc2l2ZSBkZXNpZ25zIHRoYXQgdXNlIGZyb20oKSB0d2VlbnMuXG5cdFx0XHRcdFx0XHRcdFx0XHRicyA9IGJuICsgXCIlXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCA9PT0gXCJlbVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gLz0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIDEsIFwiZW1cIik7XG5cblx0XHRcdFx0XHRcdFx0Ly9vdGhlcndpc2UgY29udmVydCB0byBwaXhlbHMuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCAhPT0gXCJweFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW4gPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgZW4sIGVzZngpO1xuXHRcdFx0XHRcdFx0XHRcdGVzZnggPSBcInB4XCI7IC8vd2UgZG9uJ3QgdXNlIGJzZnggYWZ0ZXIgdGhpcywgc28gd2UgZG9uJ3QgbmVlZCB0byBzZXQgaXQgdG8gcHggdG9vLlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChyZWwpIGlmIChlbiB8fCBlbiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGVzID0gKGVuICsgYm4pICsgZXNmeDsgLy90aGUgY2hhbmdlcyB3ZSBtYWRlIGFmZmVjdCByZWxhdGl2ZSBjYWxjdWxhdGlvbnMsIHNvIGFkanVzdCB0aGUgZW5kIHZhbHVlIGhlcmUuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0XHRlbiArPSBibjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKChibiB8fCBibiA9PT0gMCkgJiYgKGVuIHx8IGVuID09PSAwKSkgeyAvL2Zhc3RlciB0aGFuIGlzTmFOKCkuIEFsc28sIHByZXZpb3VzbHkgd2UgcmVxdWlyZWQgZW4gIT09IGJuIGJ1dCB0aGF0IGRvZXNuJ3QgcmVhbGx5IGdhaW4gbXVjaCBwZXJmb3JtYW5jZSBhbmQgaXQgcHJldmVudHMgX3BhcnNlVG9Qcm94eSgpIGZyb20gd29ya2luZyBwcm9wZXJseSBpZiBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgbWF0Y2ggYnV0IG5lZWQgdG8gZ2V0IHR3ZWVuZWQgYnkgYW4gZXh0ZXJuYWwgcGx1Z2luIGFueXdheS4gRm9yIGV4YW1wbGUsIGEgYmV6aWVyIHR3ZWVuIHdoZXJlIHRoZSB0YXJnZXQgc3RhcnRzIGF0IGxlZnQ6MCBhbmQgaGFzIHRoZXNlIHBvaW50czogW3tsZWZ0OjUwfSx7bGVmdDowfV0gd291bGRuJ3Qgd29yayBwcm9wZXJseSBiZWNhdXNlIHdoZW4gcGFyc2luZyB0aGUgbGFzdCBwb2ludCwgaXQnZCBtYXRjaCB0aGUgZmlyc3QgKGN1cnJlbnQpIG9uZSBhbmQgYSBub24tdHdlZW5pbmcgQ1NTUHJvcFR3ZWVuIHdvdWxkIGJlIHJlY29yZGVkIHdoZW4gd2UgYWN0dWFsbHkgbmVlZCBhIG5vcm1hbCB0d2VlbiAodHlwZTowKSBzbyB0aGF0IHRoaW5ncyBnZXQgdXBkYXRlZCBkdXJpbmcgdGhlIHR3ZWVuIHByb3Blcmx5LlxuXHRcdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIGJuLCBlbiAtIGJuLCBwdCwgMCwgcCwgKF9hdXRvUm91bmQgIT09IGZhbHNlICYmIChlc2Z4ID09PSBcInB4XCIgfHwgcCA9PT0gXCJ6SW5kZXhcIikpLCAwLCBicywgZXMpO1xuXHRcdFx0XHRcdFx0XHRwdC54czAgPSBlc2Z4O1xuXHRcdFx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwidHdlZW4gXCIrcCtcIiBmcm9tIFwiK3B0LmIrXCIgKFwiK2JuK2VzZngrXCIpIHRvIFwiK3B0LmUrXCIgd2l0aCBzdWZmaXg6IFwiK3B0LnhzMCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0eWxlW3BdID09PSB1bmRlZmluZWQgfHwgIWVzICYmIChlcyArIFwiXCIgPT09IFwiTmFOXCIgfHwgZXMgPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRcdFx0X2xvZyhcImludmFsaWQgXCIgKyBwICsgXCIgdHdlZW4gdmFsdWU6IFwiICsgdmFyc1twXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIGVuIHx8IGJuIHx8IDAsIDAsIHB0LCAtMSwgcCwgZmFsc2UsIDAsIGJzLCBlcyk7XG5cdFx0XHRcdFx0XHRcdHB0LnhzMCA9IChlcyA9PT0gXCJub25lXCIgJiYgKHAgPT09IFwiZGlzcGxheVwiIHx8IHAuaW5kZXhPZihcIlN0eWxlXCIpICE9PSAtMSkpID8gYnMgOiBlczsgLy9pbnRlcm1lZGlhdGUgdmFsdWUgc2hvdWxkIHR5cGljYWxseSBiZSBzZXQgaW1tZWRpYXRlbHkgKGVuZCB2YWx1ZSkgZXhjZXB0IGZvciBcImRpc3BsYXlcIiBvciB0aGluZ3MgbGlrZSBib3JkZXJUb3BTdHlsZSwgYm9yZGVyQm90dG9tU3R5bGUsIGV0Yy4gd2hpY2ggc2hvdWxkIHVzZSB0aGUgYmVnaW5uaW5nIHZhbHVlIGR1cmluZyB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJub24tdHdlZW5pbmcgdmFsdWUgXCIrcCtcIjogXCIrcHQueHMwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBsdWdpbikgaWYgKHB0ICYmICFwdC5wbHVnaW4pIHtcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cblx0XHQvL2dldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHR3ZWVuIHVwZGF0ZXMsIHBhc3NpbmcgdGhlIG5ldyByYXRpbyAodHlwaWNhbGx5IGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgbm90IGFsd2F5cyAoZm9yIGV4YW1wbGUsIGlmIGFuIEVsYXN0aWMuZWFzZU91dCBpcyB1c2VkLCB0aGUgdmFsdWUgY2FuIGp1bXAgYWJvdmUgMSBtaWQtdHdlZW4pLiBJdCB3aWxsIGFsd2F5cyBzdGFydCBhbmQgMCBhbmQgZW5kIGF0IDEuXG5cdFx0cC5zZXRSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHR2YWwsIHN0ciwgaTtcblx0XHRcdC8vYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCB0aGUgdmFsdWVzIHRvIGV4YWN0bHkgd2hhdCB3ZSByZWNlaXZlZCBpbiBvcmRlciB0byBtYWtlIHN1cmUgbm9uLXR3ZWVuaW5nIHZhbHVlcyAobGlrZSBcInBvc2l0aW9uXCIgb3IgXCJmbG9hdFwiIG9yIHdoYXRldmVyKSBhcmUgc2V0IGFuZCBzbyB0aGF0IGlmIHRoZSBiZWdpbm5pbmcvZW5kaW5nIHN1ZmZpeGVzICh1bml0cykgZGlkbid0IG1hdGNoIGFuZCB3ZSBub3JtYWxpemVkIHRvIHB4LCB0aGUgdmFsdWUgdGhhdCB0aGUgdXNlciBwYXNzZWQgaW4gaXMgdXNlZCBoZXJlLiBXZSBjaGVjayB0byBzZWUgaWYgdGhlIHR3ZWVuIGlzIGF0IGl0cyBiZWdpbm5pbmcgaW4gY2FzZSBpdCdzIGEgZnJvbSgpIHR3ZWVuIGluIHdoaWNoIGNhc2UgdGhlIHJhdGlvIHdpbGwgYWN0dWFsbHkgZ28gZnJvbSAxIHRvIDAgb3ZlciB0aGUgY291cnNlIG9mIHRoZSB0d2VlbiAoYmFja3dhcmRzKS5cblx0XHRcdGlmICh2ID09PSAxICYmICh0aGlzLl90d2Vlbi5fdGltZSA9PT0gdGhpcy5fdHdlZW4uX2R1cmF0aW9uIHx8IHRoaXMuX3R3ZWVuLl90aW1lID09PSAwKSkge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSAhPT0gMikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodiB8fCAhKHRoaXMuX3R3ZWVuLl90aW1lID09PSB0aGlzLl90d2Vlbi5fZHVyYXRpb24gfHwgdGhpcy5fdHdlZW4uX3RpbWUgPT09IDApIHx8IHRoaXMuX3R3ZWVuLl9yYXdQcmV2VGltZSA9PT0gLTAuMDAwMDAxKSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHZhbCA9IHB0LmMgKiB2ICsgcHQucztcblx0XHRcdFx0XHRpZiAocHQucikge1xuXHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluKSBpZiAodmFsID4gLW1pbikge1xuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFwdC50eXBlKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsICsgcHQueHMwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkgeyAvL2NvbXBsZXggdmFsdWUgKG9uZSB0aGF0IHR5cGljYWxseSBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbnNpZGUgYSBzdHJpbmcsIGxpa2UgXCJyZWN0KDVweCwxMHB4LDIwcHgsMjVweClcIlxuXHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRpZiAoaSA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSAzKSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czM7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDQpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMyArIHB0LnhuMyArIHB0LnhzNDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gNSkge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzICsgcHQueG4zICsgcHQueHM0ICsgcHQueG40ICsgcHQueHM1O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgdmFsICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHN0cjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gLTEpIHsgLy9ub24tdHdlZW5pbmcgdmFsdWVcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czA7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnNldFJhdGlvKSB7IC8vY3VzdG9tIHNldFJhdGlvKCkgZm9yIHRoaW5ncyBsaWtlIFNwZWNpYWxQcm9wcywgZXh0ZXJuYWwgcGx1Z2lucywgZXRjLlxuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly9pZiB0aGUgdHdlZW4gaXMgcmV2ZXJzZWQgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyB3aGljaCBtYXkgaGF2ZSBkaWZmZXJlbnQgdW5pdHMgKGxpa2UgJSBpbnN0ZWFkIG9mIHB4IG9yIGVtIG9yIHdoYXRldmVyKS5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBGb3JjZXMgcmVuZGVyaW5nIG9mIHRoZSB0YXJnZXQncyB0cmFuc2Zvcm1zIChyb3RhdGlvbiwgc2NhbGUsIGV0Yy4pIHdoZW5ldmVyIHRoZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpIGlzIGNhbGxlZC5cblx0XHQgKiBCYXNpY2FsbHksIHRoaXMgdGVsbHMgdGhlIENTU1BsdWdpbiB0byBjcmVhdGUgYSBDU1NQcm9wVHdlZW4gKHR5cGUgMikgYWZ0ZXIgaW5zdGFudGlhdGlvbiB0aGF0IHJ1bnMgbGFzdCBpbiB0aGUgbGlua2VkXG5cdFx0ICogbGlzdCBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlICgzRCBvciAyRCkgcmVuZGVyaW5nIGZ1bmN0aW9uLiBXZSBzZXBhcmF0ZSB0aGlzIGludG8gaXRzIG93biBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gY2FsbFxuXHRcdCAqIGl0IGZyb20gb3RoZXIgcGx1Z2lucyBsaWtlIEJlemllclBsdWdpbiBpZiwgZm9yIGV4YW1wbGUsIGl0IG5lZWRzIHRvIGFwcGx5IGFuIGF1dG9Sb3RhdGlvbiBhbmQgdGhpcyBDU1NQbHVnaW5cblx0XHQgKiBkb2Vzbid0IGhhdmUgYW55IHRyYW5zZm9ybS1yZWxhdGVkIHByb3BlcnRpZXMgb2YgaXRzIG93bi4gWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIGFzIG1hbnkgdGltZXMgYXMgeW91XG5cdFx0ICogd2FudCBhbmQgaXQgd29uJ3QgY3JlYXRlIGR1cGxpY2F0ZSBDU1NQcm9wVHdlZW5zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSB0aHJlZUQgaWYgdHJ1ZSwgaXQgc2hvdWxkIGFwcGx5IDNEIHR3ZWVucyAob3RoZXJ3aXNlLCBqdXN0IDJEIG9uZXMgYXJlIGZpbmUgYW5kIHR5cGljYWxseSBmYXN0ZXIpXG5cdFx0ICovXG5cdFx0cC5fZW5hYmxlVHJhbnNmb3JtcyA9IGZ1bmN0aW9uKHRocmVlRCkge1xuXHRcdFx0dGhpcy5fdHJhbnNmb3JtID0gdGhpcy5fdHJhbnNmb3JtIHx8IF9nZXRUcmFuc2Zvcm0odGhpcy5fdGFyZ2V0LCBfY3MsIHRydWUpOyAvL2Vuc3VyZXMgdGhhdCB0aGUgZWxlbWVudCBoYXMgYSBfZ3NUcmFuc2Zvcm0gcHJvcGVydHkgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzLlxuXHRcdFx0dGhpcy5fdHJhbnNmb3JtVHlwZSA9ICghKHRoaXMuX3RyYW5zZm9ybS5zdmcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpICYmICh0aHJlZUQgfHwgdGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMykpID8gMyA6IDI7XG5cdFx0fTtcblxuXHRcdHZhciBsYXp5U2V0ID0gZnVuY3Rpb24odikge1xuXHRcdFx0dGhpcy50W3RoaXMucF0gPSB0aGlzLmU7XG5cdFx0XHR0aGlzLmRhdGEuX2xpbmtDU1NQKHRoaXMsIHRoaXMuX25leHQsIG51bGwsIHRydWUpOyAvL3dlIHB1cnBvc2VmdWxseSBrZWVwIHRoaXMuX25leHQgZXZlbiB0aG91Z2ggaXQnZCBtYWtlIHNlbnNlIHRvIG51bGwgaXQsIGJ1dCB0aGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBhcyB0aGlzIGhhcHBlbnMgZHVyaW5nIHRoZSB3aGlsZSAocHQpIHt9IGxvb3AgaW4gc2V0UmF0aW8oKSBhdCB0aGUgYm90dG9tIG9mIHdoaWNoIGl0IHNldHMgcHQgPSBwdC5fbmV4dCwgc28gaWYgd2UgbnVsbCBpdCwgdGhlIGxpbmtlZCBsaXN0IHdpbGwgYmUgYnJva2VuIGluIHRoYXQgbG9vcC5cblx0XHR9O1xuXHRcdC8qKiBAcHJpdmF0ZSBHaXZlcyB1cyBhIHdheSB0byBzZXQgYSB2YWx1ZSBvbiB0aGUgZmlyc3QgcmVuZGVyIChhbmQgb25seSB0aGUgZmlyc3QgcmVuZGVyKS4gKiovXG5cdFx0cC5fYWRkTGF6eVNldCA9IGZ1bmN0aW9uKHQsIHAsIHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHRoaXMuX2ZpcnN0UFQsIDIpO1xuXHRcdFx0cHQuZSA9IHY7XG5cdFx0XHRwdC5zZXRSYXRpbyA9IGxhenlTZXQ7XG5cdFx0XHRwdC5kYXRhID0gdGhpcztcblx0XHR9O1xuXG5cdFx0LyoqIEBwcml2YXRlICoqL1xuXHRcdHAuX2xpbmtDU1NQID0gZnVuY3Rpb24ocHQsIG5leHQsIHByZXYsIHJlbW92ZSkge1xuXHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRyZW1vdmUgPSB0cnVlOyAvL2p1c3QgdG8gcHJldmVudCByZXNldHRpbmcgdGhpcy5fZmlyc3RQVCA1IGxpbmVzIGRvd24gaW4gY2FzZSBwdC5fbmV4dCBpcyBudWxsLiAob3B0aW1pemVkIGZvciBzcGVlZClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJldikge1xuXHRcdFx0XHRcdHByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0fSBlbHNlIGlmICghcmVtb3ZlICYmIHRoaXMuX2ZpcnN0UFQgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRwdC5fcHJldiA9IHByZXY7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXHRcdC8vd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBpZiBhbHBoYSBvciBhdXRvQWxwaGEgaXMga2lsbGVkLCBvcGFjaXR5IGlzIHRvby4gQW5kIGF1dG9BbHBoYSBhZmZlY3RzIHRoZSBcInZpc2liaWxpdHlcIiBwcm9wZXJ0eS5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgY29weSA9IGxvb2t1cCxcblx0XHRcdFx0cHQsIHAsIHhmaXJzdDtcblx0XHRcdGlmIChsb29rdXAuYXV0b0FscGhhIHx8IGxvb2t1cC5hbHBoYSkge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdGZvciAocCBpbiBsb29rdXApIHsgLy9jb3B5IHRoZSBsb29rdXAgc28gdGhhdCB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIG9yaWdpbmFsIHdoaWNoIG1heSBiZSBwYXNzZWQgZWxzZXdoZXJlLlxuXHRcdFx0XHRcdGNvcHlbcF0gPSBsb29rdXBbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29weS5vcGFjaXR5ID0gMTtcblx0XHRcdFx0aWYgKGNvcHkuYXV0b0FscGhhKSB7XG5cdFx0XHRcdFx0Y29weS52aXNpYmlsaXR5ID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxvb2t1cC5jbGFzc05hbWUgJiYgKHB0ID0gdGhpcy5fY2xhc3NOYW1lUFQpKSB7IC8vZm9yIGNsYXNzTmFtZSB0d2VlbnMsIHdlIG5lZWQgdG8ga2lsbCBhbnkgYXNzb2NpYXRlZCBDU1NQcm9wVHdlZW5zIHRvbzsgYSBsaW5rZWQgbGlzdCBzdGFydHMgYXQgdGhlIGNsYXNzTmFtZSdzIFwieGZpcnN0XCIuXG5cdFx0XHRcdHhmaXJzdCA9IHB0LnhmaXJzdDtcblx0XHRcdFx0aWYgKHhmaXJzdCAmJiB4Zmlyc3QuX3ByZXYpIHtcblx0XHRcdFx0XHR0aGlzLl9saW5rQ1NTUCh4Zmlyc3QuX3ByZXYsIHB0Ll9uZXh0LCB4Zmlyc3QuX3ByZXYuX3ByZXYpOyAvL2JyZWFrIG9mZiB0aGUgcHJldlxuXHRcdFx0XHR9IGVsc2UgaWYgKHhmaXJzdCA9PT0gdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHR0aGlzLl9saW5rQ1NTUChwdC5fbmV4dCwgcHQuX25leHQuX25leHQsIHhmaXJzdC5fcHJldik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2xhc3NOYW1lUFQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFR3ZWVuUGx1Z2luLnByb3RvdHlwZS5fa2lsbC5jYWxsKHRoaXMsIGNvcHkpO1xuXHRcdH07XG5cblxuXG5cdFx0Ly91c2VkIGJ5IGNhc2NhZGVUbygpIGZvciBnYXRoZXJpbmcgYWxsIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIG9mIGVhY2ggY2hpbGQgZWxlbWVudCBpbnRvIGFuIGFycmF5IGZvciBjb21wYXJpc29uLlxuXHRcdHZhciBfZ2V0Q2hpbGRTdHlsZXMgPSBmdW5jdGlvbihlLCBwcm9wcywgdGFyZ2V0cykge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4sIGksIGNoaWxkLCB0eXBlO1xuXHRcdFx0XHRpZiAoZS5zbGljZSkge1xuXHRcdFx0XHRcdGkgPSBlLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9nZXRDaGlsZFN0eWxlcyhlW2ldLCBwcm9wcywgdGFyZ2V0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbiA9IGUuY2hpbGROb2Rlcztcblx0XHRcdFx0aSA9IGNoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0XHR0eXBlID0gY2hpbGQudHlwZTtcblx0XHRcdFx0XHRpZiAoY2hpbGQuc3R5bGUpIHtcblx0XHRcdFx0XHRcdHByb3BzLnB1c2goX2dldEFsbFN0eWxlcyhjaGlsZCkpO1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCh0eXBlID09PSAxIHx8IHR5cGUgPT09IDkgfHwgdHlwZSA9PT0gMTEpICYmIGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRfZ2V0Q2hpbGRTdHlsZXMoY2hpbGQsIHByb3BzLCB0YXJnZXRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBUeXBpY2FsbHkgb25seSB1c2VmdWwgZm9yIGNsYXNzTmFtZSB0d2VlbnMgdGhhdCBtYXkgYWZmZWN0IGNoaWxkIGVsZW1lbnRzLCB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgVHdlZW5MaXRlXG5cdFx0ICogYW5kIHRoZW4gY29tcGFyZXMgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgYWxsIHRoZSB0YXJnZXQncyBjaGlsZCBlbGVtZW50cyBhdCB0aGUgdHdlZW4ncyBzdGFydCBhbmQgZW5kLCBhbmRcblx0XHQgKiBpZiBhbnkgYXJlIGRpZmZlcmVudCwgaXQgYWxzbyBjcmVhdGVzIHR3ZWVucyBmb3IgdGhvc2UgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBBTEwgb2YgdGhlIHJlc3VsdGluZ1xuXHRcdCAqIHR3ZWVucyAoc28gdGhhdCB5b3UgY2FuIGVhc2lseSBhZGQoKSB0aGVtIHRvIGEgVGltZWxpbmVMaXRlLCBmb3IgZXhhbXBsZSkuIFRoZSByZWFzb24gdGhpcyBmdW5jdGlvbmFsaXR5IGlzXG5cdFx0ICogd3JhcHBlZCBpbnRvIGEgc2VwYXJhdGUgc3RhdGljIG1ldGhvZCBvZiBDU1NQbHVnaW4gaW5zdGVhZCBvZiBiZWluZyBpbnRlZ3JhdGVkIGludG8gYWxsIHJlZ3VsYXIgY2xhc3NOYW1lIHR3ZWVuc1xuXHRcdCAqIGlzIGJlY2F1c2UgaXQgY3JlYXRlcyBlbnRpcmVseSBuZXcgdHdlZW5zIHRoYXQgbWF5IGhhdmUgY29tcGxldGVseSBkaWZmZXJlbnQgdGFyZ2V0cyB0aGFuIHRoZSBvcmlnaW5hbCB0d2Vlbixcblx0XHQgKiBzbyBpZiB0aGV5IHdlcmUgYWxsIGx1bXBlZCBpbnRvIHRoZSBvcmlnaW5hbCB0d2VlbiBpbnN0YW5jZSwgaXQgd291bGQgYmUgaW5jb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIEFQSVxuXHRcdCAqIGFuZCBpdCB3b3VsZCBjcmVhdGUgb3RoZXIgcHJvYmxlbXMuIEZvciBleGFtcGxlOlxuXHRcdCAqICAtIElmIEkgY3JlYXRlIGEgdHdlZW4gb2YgZWxlbWVudEEsIHRoYXQgdHdlZW4gaW5zdGFuY2UgbWF5IHN1ZGRlbmx5IGNoYW5nZSBpdHMgdGFyZ2V0IHRvIGluY2x1ZGUgNTAgb3RoZXIgZWxlbWVudHMgKHVuaW50dWl0aXZlIGlmIEkgc3BlY2lmaWNhbGx5IGRlZmluZWQgdGhlIHRhcmdldCBJIHdhbnRlZClcblx0XHQgKiAgLSBXZSBjYW4ndCBqdXN0IGNyZWF0ZSBuZXcgaW5kZXBlbmRlbnQgdHdlZW5zIGJlY2F1c2Ugb3RoZXJ3aXNlLCB3aGF0IGhhcHBlbnMgaWYgdGhlIG9yaWdpbmFsL3BhcmVudCB0d2VlbiBpcyByZXZlcnNlZCBvciBwYXVzZSBvciBkcm9wcGVkIGludG8gYSBUaW1lbGluZUxpdGUgZm9yIHRpZ2h0IGNvbnRyb2w/IFlvdSdkIGV4cGVjdCB0aGF0IHR3ZWVuJ3MgYmVoYXZpb3IgdG8gYWZmZWN0IGFsbCB0aGUgb3RoZXJzLlxuXHRcdCAqICAtIEFuYWx5emluZyBldmVyeSBzdHlsZSBwcm9wZXJ0eSBvZiBldmVyeSBjaGlsZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSB0d2VlbiBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHdoZW4gdGhlcmUgYXJlIG1hbnkgY2hpbGRyZW4sIHNvIHRoaXMgYmVoYXZpb3Igc2hvdWxkbid0IGJlIGltcG9zZWQgb24gYWxsIGNsYXNzTmFtZSB0d2VlbnMgYnkgZGVmYXVsdCwgZXNwZWNpYWxseSBzaW5jZSBpdCdzIHByb2JhYmx5IHJhcmUgdGhhdCB0aGlzIGV4dHJhIGZ1bmN0aW9uYWxpdHkgaXMgbmVlZGVkLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBvYmplY3QgdG8gYmUgdHdlZW5lZFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBEdXJhdGlvbiBpbiBzZWNvbmRzIChvciBmcmFtZXMgZm9yIGZyYW1lcy1iYXNlZCB0d2VlbnMpXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBlbmQgdmFsdWVzLCBsaWtlIHtjbGFzc05hbWU6XCJuZXdDbGFzc1wiLCBlYXNlOkxpbmVhci5lYXNlTm9uZX1cblx0XHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgVHdlZW5MaXRlIGluc3RhbmNlc1xuXHRcdCAqL1xuXHRcdENTU1BsdWdpbi5jYXNjYWRlVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSBUd2VlbkxpdGUudG8odGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksXG5cdFx0XHRcdHJlc3VsdHMgPSBbdHdlZW5dLFxuXHRcdFx0XHRiID0gW10sXG5cdFx0XHRcdGUgPSBbXSxcblx0XHRcdFx0dGFyZ2V0cyA9IFtdLFxuXHRcdFx0XHRfcmVzZXJ2ZWRQcm9wcyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLnJlc2VydmVkUHJvcHMsXG5cdFx0XHRcdGksIGRpZnMsIHAsIGZyb207XG5cdFx0XHR0YXJnZXQgPSB0d2Vlbi5fdGFyZ2V0cyB8fCB0d2Vlbi50YXJnZXQ7XG5cdFx0XHRfZ2V0Q2hpbGRTdHlsZXModGFyZ2V0LCBiLCB0YXJnZXRzKTtcblx0XHRcdHR3ZWVuLnJlbmRlcihkdXJhdGlvbiwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRfZ2V0Q2hpbGRTdHlsZXModGFyZ2V0LCBlKTtcblx0XHRcdHR3ZWVuLnJlbmRlcigwLCB0cnVlLCB0cnVlKTtcblx0XHRcdHR3ZWVuLl9lbmFibGVkKHRydWUpO1xuXHRcdFx0aSA9IHRhcmdldHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGRpZnMgPSBfY3NzRGlmKHRhcmdldHNbaV0sIGJbaV0sIGVbaV0pO1xuXHRcdFx0XHRpZiAoZGlmcy5maXJzdE1QVCkge1xuXHRcdFx0XHRcdGRpZnMgPSBkaWZzLmRpZnM7XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRcdGlmIChfcmVzZXJ2ZWRQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRkaWZzW3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnJvbSA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiBkaWZzKSB7XG5cdFx0XHRcdFx0XHRmcm9tW3BdID0gYltpXVtwXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKFR3ZWVuTGl0ZS5mcm9tVG8odGFyZ2V0c1tpXSwgZHVyYXRpb24sIGZyb20sIGRpZnMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlKFtDU1NQbHVnaW5dKTtcblx0XHRyZXR1cm4gQ1NTUGx1Z2luO1xuXG5cdH0sIHRydWUpO1xuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFJvdW5kUHJvcHNQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgUm91bmRQcm9wc1BsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0XHRwcm9wTmFtZTogXCJyb3VuZFByb3BzXCIsXG5cdFx0XHRcdHByaW9yaXR5OiAtMSxcblx0XHRcdFx0QVBJOiAyLFxuXG5cdFx0XHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KSxcblx0XHRcdHAgPSBSb3VuZFByb3BzUGx1Z2luLnByb3RvdHlwZTtcblxuXHRcdHAuX29uSW5pdEFsbFByb3BzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl90d2Vlbixcblx0XHRcdFx0cnAgPSAodHdlZW4udmFycy5yb3VuZFByb3BzIGluc3RhbmNlb2YgQXJyYXkpID8gdHdlZW4udmFycy5yb3VuZFByb3BzIDogdHdlZW4udmFycy5yb3VuZFByb3BzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0aSA9IHJwLmxlbmd0aCxcblx0XHRcdFx0bG9va3VwID0ge30sXG5cdFx0XHRcdHJwdCA9IHR3ZWVuLl9wcm9wTG9va3VwLnJvdW5kUHJvcHMsXG5cdFx0XHRcdHByb3AsIHB0LCBuZXh0O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxvb2t1cFtycFtpXV0gPSAxO1xuXHRcdFx0fVxuXHRcdFx0aSA9IHJwLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRwcm9wID0gcnBbaV07XG5cdFx0XHRcdHB0ID0gdHdlZW4uX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDsgLy9yZWNvcmQgaGVyZSwgYmVjYXVzZSBpdCBtYXkgZ2V0IHJlbW92ZWRcblx0XHRcdFx0XHRpZiAocHQucGcpIHtcblx0XHRcdFx0XHRcdHB0LnQuX3JvdW5kUHJvcHMobG9va3VwLCB0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0Lm4gPT09IHByb3ApIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZChwdC50LCBwcm9wLCBwdC5zLCBwdC5jKTtcblx0XHRcdFx0XHRcdC8vcmVtb3ZlIGZyb20gbGlua2VkIGxpc3Rcblx0XHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdG5leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5fZmlyc3RQVCA9IG5leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdC5fbmV4dCA9IHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdHR3ZWVuLl9wcm9wTG9va3VwW3Byb3BdID0gcnB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fYWRkID0gZnVuY3Rpb24odGFyZ2V0LCBwLCBzLCBjKSB7XG5cdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIHAsIHMsIHMgKyBjLCBwLCB0cnVlKTtcblx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0fTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQXR0clBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdHByb3BOYW1lOiBcImF0dHJcIixcblx0XHRBUEk6IDIsXG5cdFx0dmVyc2lvbjogXCIwLjMuM1wiLFxuXG5cdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0dmFyIHAsIHN0YXJ0LCBlbmQ7XG5cdFx0XHRpZiAodHlwZW9mKHRhcmdldC5zZXRBdHRyaWJ1dGUpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5fcHJveHkgPSB7fTtcblx0XHRcdHRoaXMuX3N0YXJ0ID0ge307IC8vIHdlIHJlY29yZCBzdGFydCBhbmQgZW5kIHZhbHVlcyBleGFjdGx5IGFzIHRoZXkgYXJlIGluIGNhc2UgdGhleSdyZSBzdHJpbmdzIChub3QgbnVtYmVycykgLSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRvIHRoZW0gY2xlYW5seS5cblx0XHRcdHRoaXMuX2VuZCA9IHt9O1xuXHRcdFx0Zm9yIChwIGluIHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0W3BdID0gdGhpcy5fcHJveHlbcF0gPSBzdGFydCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUocCk7XG5cdFx0XHRcdGVuZCA9IHRoaXMuX2FkZFR3ZWVuKHRoaXMuX3Byb3h5LCBwLCBwYXJzZUZsb2F0KHN0YXJ0KSwgdmFsdWVbcF0sIHApO1xuXHRcdFx0XHR0aGlzLl9lbmRbcF0gPSBlbmQgPyBlbmQucyArIGVuZC5jIDogdmFsdWVbcF07XG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRzZXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0XHR0aGlzLl9zdXBlci5zZXRSYXRpby5jYWxsKHRoaXMsIHJhdGlvKTtcblx0XHRcdHZhciBwcm9wcyA9IHRoaXMuX292ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoLFxuXHRcdFx0XHRsb29rdXAgPSAocmF0aW8gPT09IDEpID8gdGhpcy5fZW5kIDogcmF0aW8gPyB0aGlzLl9wcm94eSA6IHRoaXMuX3N0YXJ0LFxuXHRcdFx0XHRwO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0LnNldEF0dHJpYnV0ZShwLCBsb29rdXBbcF0gKyBcIlwiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fSk7XG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0cHJvcE5hbWU6IFwiZGlyZWN0aW9uYWxSb3RhdGlvblwiLFxuXHRcdHZlcnNpb246IFwiMC4yLjFcIixcblx0XHRBUEk6IDIsXG5cblx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YWx1ZSA9IHtyb3RhdGlvbjp2YWx1ZX07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZpbmFscyA9IHt9O1xuXHRcdFx0dmFyIGNhcCA9ICh2YWx1ZS51c2VSYWRpYW5zID09PSB0cnVlKSA/IE1hdGguUEkgKiAyIDogMzYwLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0cCwgdiwgc3RhcnQsIGVuZCwgZGlmLCBzcGxpdDtcblx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAocCAhPT0gXCJ1c2VSYWRpYW5zXCIpIHtcblx0XHRcdFx0XHRzcGxpdCA9ICh2YWx1ZVtwXSArIFwiXCIpLnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHR2ID0gc3BsaXRbMF07XG5cdFx0XHRcdFx0c3RhcnQgPSBwYXJzZUZsb2F0KCAodHlwZW9mKHRhcmdldFtwXSkgIT09IFwiZnVuY3Rpb25cIikgPyB0YXJnZXRbcF0gOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCkgKTtcblx0XHRcdFx0XHRlbmQgPSB0aGlzLmZpbmFsc1twXSA9ICh0eXBlb2YodikgPT09IFwic3RyaW5nXCIgJiYgdi5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHN0YXJ0ICsgcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKHYuc3Vic3RyKDIpKSA6IE51bWJlcih2KSB8fCAwO1xuXHRcdFx0XHRcdGRpZiA9IGVuZCAtIHN0YXJ0O1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHYgPSBzcGxpdC5qb2luKFwiX1wiKTtcblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJzaG9ydFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gZGlmICUgY2FwO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlmICE9PSBkaWYgJSAoY2FwIC8gMikpIHtcblx0XHRcdFx0XHRcdFx0XHRkaWYgPSAoZGlmIDwgMCkgPyBkaWYgKyBjYXAgOiBkaWYgLSBjYXA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJfY3dcIikgIT09IC0xICYmIGRpZiA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgKyBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiY2N3XCIpICE9PSAtMSAmJiBkaWYgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmIC0gY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkaWYgPiBtaW4gfHwgZGlmIDwgLW1pbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBwLCBzdGFydCwgc3RhcnQgKyBkaWYsIHApO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdHNldDogZnVuY3Rpb24ocmF0aW8pIHtcblx0XHRcdHZhciBwdDtcblx0XHRcdGlmIChyYXRpbyAhPT0gMSkge1xuXHRcdFx0XHR0aGlzLl9zdXBlci5zZXRSYXRpby5jYWxsKHRoaXMsIHJhdGlvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0odGhpcy5maW5hbHNbcHQucF0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdGhpcy5maW5hbHNbcHQucF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fSkuX2F1dG9DU1MgPSB0cnVlO1xuXG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEVhc2VQYWNrXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiZWFzaW5nLkJhY2tcIiwgW1wiZWFzaW5nLkVhc2VcIl0sIGZ1bmN0aW9uKEVhc2UpIHtcblx0XHRcblx0XHR2YXIgdyA9IChfZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzIHx8IF9nc1Njb3BlKSxcblx0XHRcdGdzID0gdy5jb20uZ3JlZW5zb2NrLFxuXHRcdFx0XzJQSSA9IE1hdGguUEkgKiAyLFxuXHRcdFx0X0hBTEZfUEkgPSBNYXRoLlBJIC8gMixcblx0XHRcdF9jbGFzcyA9IGdzLl9jbGFzcyxcblx0XHRcdF9jcmVhdGUgPSBmdW5jdGlvbihuLCBmKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24oKXt9LCB0cnVlKSxcblx0XHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciB8fCBmdW5jdGlvbigpe30sIC8vcHV0IGFuIGVtcHR5IGZ1bmN0aW9uIGluIHBsYWNlIGp1c3QgYXMgYSBzYWZldHkgbWVhc3VyZSBpbiBjYXNlIHNvbWVvbmUgbG9hZHMgYW4gT0xEIHZlcnNpb24gb2YgVHdlZW5MaXRlLmpzIHdoZXJlIEVhc2UucmVnaXN0ZXIgZG9lc24ndCBleGlzdC5cblx0XHRcdF93cmFwID0gZnVuY3Rpb24obmFtZSwgRWFzZU91dCwgRWFzZUluLCBFYXNlSW5PdXQsIGFsaWFzZXMpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIrbmFtZSwge1xuXHRcdFx0XHRcdGVhc2VPdXQ6bmV3IEVhc2VPdXQoKSxcblx0XHRcdFx0XHRlYXNlSW46bmV3IEVhc2VJbigpLFxuXHRcdFx0XHRcdGVhc2VJbk91dDpuZXcgRWFzZUluT3V0KClcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHRcdF9lYXNlUmVnKEMsIG5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cdFx0XHRFYXNlUG9pbnQgPSBmdW5jdGlvbih0aW1lLCB2YWx1ZSwgbmV4dCkge1xuXHRcdFx0XHR0aGlzLnQgPSB0aW1lO1xuXHRcdFx0XHR0aGlzLnYgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHR0aGlzLm5leHQgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQucHJldiA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5jID0gbmV4dC52IC0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5nYXAgPSBuZXh0LnQgLSB0aW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL0JhY2tcblx0XHRcdF9jcmVhdGVCYWNrID0gZnVuY3Rpb24obiwgZikge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKG92ZXJzaG9vdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fcDEgPSAob3ZlcnNob290IHx8IG92ZXJzaG9vdCA9PT0gMCkgPyBvdmVyc2hvb3QgOiAxLjcwMTU4O1xuXHRcdFx0XHRcdFx0dGhpcy5fcDIgPSB0aGlzLl9wMSAqIDEuNTI1O1xuXHRcdFx0XHRcdH0sIHRydWUpLFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEMob3ZlcnNob290KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXG5cdFx0XHRCYWNrID0gX3dyYXAoXCJCYWNrXCIsXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCA9IHAgLSAxKSAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwICsgdGhpcy5fcDEpICsgMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHAgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCAtIHRoaXMuX3AxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBwICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgLSB0aGlzLl9wMikgOiAwLjUgKiAoKHAgLT0gMikgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCArIHRoaXMuX3AyKSArIDIpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KSxcblxuXG5cdFx0XHQvL1Nsb3dNb1xuXHRcdFx0U2xvd01vID0gX2NsYXNzKFwiZWFzaW5nLlNsb3dNb1wiLCBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRcdHBvd2VyID0gKHBvd2VyIHx8IHBvd2VyID09PSAwKSA/IHBvd2VyIDogMC43O1xuXHRcdFx0XHRpZiAobGluZWFyUmF0aW8gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMC43O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmVhclJhdGlvID4gMSkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9wID0gKGxpbmVhclJhdGlvICE9PSAxKSA/IHBvd2VyIDogMDtcblx0XHRcdFx0dGhpcy5fcDEgPSAoMSAtIGxpbmVhclJhdGlvKSAvIDI7XG5cdFx0XHRcdHRoaXMuX3AyID0gbGluZWFyUmF0aW87XG5cdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDEgKyB0aGlzLl9wMjtcblx0XHRcdFx0dGhpcy5fY2FsY0VuZCA9ICh5b3lvTW9kZSA9PT0gdHJ1ZSk7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdHAgPSBTbG93TW8ucHJvdG90eXBlID0gbmV3IEVhc2UoKSxcblx0XHRcdFN0ZXBwZWRFYXNlLCBSb3VnaEVhc2UsIF9jcmVhdGVFbGFzdGljO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNsb3dNbztcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHIgPSBwICsgKDAuNSAtIHApICogdGhpcy5fcDtcblx0XHRcdGlmIChwIDwgdGhpcy5fcDEpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHApIDogciAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwICogcCAqIHAgKiByKTtcblx0XHRcdH0gZWxzZSBpZiAocCA+IHRoaXMuX3AzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSAtIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwIDogciArICgocCAtIHIpICogKHAgPSAocCAtIHRoaXMuX3AzKSAvIHRoaXMuX3AxKSAqIHAgKiBwICogcCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgOiByO1xuXHRcdH07XG5cdFx0U2xvd01vLmVhc2UgPSBuZXcgU2xvd01vKDAuNywgMC43KTtcblxuXHRcdHAuY29uZmlnID0gU2xvd01vLmNvbmZpZyA9IGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2xvd01vKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpO1xuXHRcdH07XG5cblxuXHRcdC8vU3RlcHBlZEVhc2Vcblx0XHRTdGVwcGVkRWFzZSA9IF9jbGFzcyhcImVhc2luZy5TdGVwcGVkRWFzZVwiLCBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0XHRzdGVwcyA9IHN0ZXBzIHx8IDE7XG5cdFx0XHRcdHRoaXMuX3AxID0gMSAvIHN0ZXBzO1xuXHRcdFx0XHR0aGlzLl9wMiA9IHN0ZXBzICsgMTtcblx0XHRcdH0sIHRydWUpO1xuXHRcdHAgPSBTdGVwcGVkRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBTdGVwcGVkRWFzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHAgPCAwKSB7XG5cdFx0XHRcdHAgPSAwO1xuXHRcdFx0fSBlbHNlIGlmIChwID49IDEpIHtcblx0XHRcdFx0cCA9IDAuOTk5OTk5OTk5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICgodGhpcy5fcDIgKiBwKSA+PiAwKSAqIHRoaXMuX3AxO1xuXHRcdH07XG5cdFx0cC5jb25maWcgPSBTdGVwcGVkRWFzZS5jb25maWcgPSBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0cmV0dXJuIG5ldyBTdGVwcGVkRWFzZShzdGVwcyk7XG5cdFx0fTtcblxuXG5cdFx0Ly9Sb3VnaEVhc2Vcblx0XHRSb3VnaEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuUm91Z2hFYXNlXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIHRhcGVyID0gdmFycy50YXBlciB8fCBcIm5vbmVcIixcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwb2ludHMgPSAodmFycy5wb2ludHMgfHwgMjApIHwgMCxcblx0XHRcdFx0aSA9IHBvaW50cyxcblx0XHRcdFx0cmFuZG9taXplID0gKHZhcnMucmFuZG9taXplICE9PSBmYWxzZSksXG5cdFx0XHRcdGNsYW1wID0gKHZhcnMuY2xhbXAgPT09IHRydWUpLFxuXHRcdFx0XHR0ZW1wbGF0ZSA9ICh2YXJzLnRlbXBsYXRlIGluc3RhbmNlb2YgRWFzZSkgPyB2YXJzLnRlbXBsYXRlIDogbnVsbCxcblx0XHRcdFx0c3RyZW5ndGggPSAodHlwZW9mKHZhcnMuc3RyZW5ndGgpID09PSBcIm51bWJlclwiKSA/IHZhcnMuc3RyZW5ndGggKiAwLjQgOiAwLjQsXG5cdFx0XHRcdHgsIHksIGJ1bXAsIGludlgsIG9iaiwgcG50O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHggPSByYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpIDogKDEgLyBwb2ludHMpICogaTtcblx0XHRcdFx0eSA9IHRlbXBsYXRlID8gdGVtcGxhdGUuZ2V0UmF0aW8oeCkgOiB4O1xuXHRcdFx0XHRpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcIm91dFwiKSB7XG5cdFx0XHRcdFx0aW52WCA9IDEgLSB4O1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcImluXCIpIHtcblx0XHRcdFx0XHRidW1wID0geCAqIHggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh4IDwgMC41KSB7ICAvL1wiYm90aFwiIChzdGFydClcblx0XHRcdFx0XHRpbnZYID0geCAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvL1wiYm90aFwiIChlbmQpXG5cdFx0XHRcdFx0aW52WCA9ICgxIC0geCkgKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyYW5kb21pemUpIHtcblx0XHRcdFx0XHR5ICs9IChNYXRoLnJhbmRvbSgpICogYnVtcCkgLSAoYnVtcCAqIDAuNSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSAlIDIpIHtcblx0XHRcdFx0XHR5ICs9IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSAtPSBidW1wICogMC41O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbGFtcCkge1xuXHRcdFx0XHRcdGlmICh5ID4gMSkge1xuXHRcdFx0XHRcdFx0eSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh5IDwgMCkge1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbY250KytdID0ge3g6eCwgeTp5fTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhLnggLSBiLng7XG5cdFx0XHR9KTtcblxuXHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludCgxLCAxLCBudWxsKTtcblx0XHRcdGkgPSBwb2ludHM7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0b2JqID0gYVtpXTtcblx0XHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludChvYmoueCwgb2JqLnksIHBudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ByZXYgPSBuZXcgRWFzZVBvaW50KDAsIDAsIChwbnQudCAhPT0gMCkgPyBwbnQgOiBwbnQubmV4dCk7XG5cdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFJvdWdoRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBSb3VnaEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciBwbnQgPSB0aGlzLl9wcmV2O1xuXHRcdFx0aWYgKHAgPiBwbnQudCkge1xuXHRcdFx0XHR3aGlsZSAocG50Lm5leHQgJiYgcCA+PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcHJldiA9IHBudDtcblx0XHRcdHJldHVybiAocG50LnYgKyAoKHAgLSBwbnQudCkgLyBwbnQuZ2FwKSAqIHBudC5jKTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBSb3VnaEVhc2UodmFycyk7XG5cdFx0fTtcblx0XHRSb3VnaEVhc2UuZWFzZSA9IG5ldyBSb3VnaEVhc2UoKTtcblxuXG5cdFx0Ly9Cb3VuY2Vcblx0XHRfd3JhcChcIkJvdW5jZVwiLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKChwID0gMSAtIHApIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiBwICogcCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1KTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0dmFyIGludmVydCA9IChwIDwgMC41KTtcblx0XHRcdFx0aWYgKGludmVydCkge1xuXHRcdFx0XHRcdHAgPSAxIC0gKHAgKiAyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gKHAgKiAyKSAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpbnZlcnQgPyAoMSAtIHApICogMC41IDogcCAqIDAuNSArIDAuNTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9DSVJDXG5cdFx0X3dyYXAoXCJDaXJjXCIsXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtIChwID0gcCAtIDEpICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIChwICogcCkpIC0gMSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwKj0yKSA8IDEpID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHAgKiBwKSAtIDEpIDogMC41ICogKE1hdGguc3FydCgxIC0gKHAgLT0gMikgKiBwKSArIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0VsYXN0aWNcblx0XHRfY3JlYXRlRWxhc3RpYyA9IGZ1bmN0aW9uKG4sIGYsIGRlZikge1xuXHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRcdHRoaXMuX3AxID0gKGFtcGxpdHVkZSA+PSAxKSA/IGFtcGxpdHVkZSA6IDE7IC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG5cdFx0XHRcdFx0dGhpcy5fcDIgPSAocGVyaW9kIHx8IGRlZikgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpO1xuXHRcdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gdGhpcy5fcDEpIHx8IDApO1xuXHRcdFx0XHRcdHRoaXMuX3AyID0gXzJQSSAvIHRoaXMuX3AyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQyhhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIEM7XG5cdFx0fTtcblx0XHRfd3JhcChcIkVsYXN0aWNcIixcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSArIDE7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLSh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSk7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAtMC41ICogKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMikpIDogdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKihwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKiAwLjUgKyAxO1xuXHRcdFx0fSwgMC40NSlcblx0XHQpO1xuXG5cblx0XHQvL0V4cG9cblx0XHRfd3JhcChcIkV4cG9cIixcblx0XHRcdF9jcmVhdGUoXCJFeHBvT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9JblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIC0gMC4wMDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIDogMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAocCAtIDEpKSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vU2luZVxuXHRcdF93cmFwKFwiU2luZVwiLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaW4ocCAqIF9IQUxGX1BJKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtTWF0aC5jb3MocCAqIF9IQUxGX1BJKSArIDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogcCkgLSAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdF9jbGFzcyhcImVhc2luZy5FYXNlTG9va3VwXCIsIHtcblx0XHRcdFx0ZmluZDpmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEVhc2UubWFwW3NdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKTtcblxuXHRcdC8vcmVnaXN0ZXIgdGhlIG5vbi1zdGFuZGFyZCBlYXNlc1xuXHRcdF9lYXNlUmVnKHcuU2xvd01vLCBcIlNsb3dNb1wiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFJvdWdoRWFzZSwgXCJSb3VnaEVhc2VcIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhTdGVwcGVkRWFzZSwgXCJTdGVwcGVkRWFzZVwiLCBcImVhc2UsXCIpO1xuXG5cdFx0cmV0dXJuIEJhY2s7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5cbn0pO1xuXG5pZiAoX2dzU2NvcGUuX2dzRGVmaW5lKSB7IF9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCk7IH0gLy9uZWNlc3NhcnkgaW4gY2FzZSBUd2VlbkxpdGUgd2FzIGFscmVhZHkgbG9hZGVkIHNlcGFyYXRlbHkuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJhc2UgY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgU2ltcGxlVGltZWxpbmUsIEVhc2UsIFRpY2tlciwgZXRjLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4oZnVuY3Rpb24od2luZG93LCBtb2R1bGVOYW1lKSB7XG5cblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX2dsb2JhbHMgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIHx8IHdpbmRvdztcblx0XHRpZiAoX2dsb2JhbHMuVHdlZW5MaXRlKSB7XG5cdFx0XHRyZXR1cm47IC8vaW4gY2FzZSB0aGUgY29yZSBzZXQgb2YgY2xhc3NlcyBpcyBhbHJlYWR5IGxvYWRlZCwgZG9uJ3QgaW5zdGFudGlhdGUgdHdpY2UuXG5cdFx0fVxuXHRcdHZhciBfbmFtZXNwYWNlID0gZnVuY3Rpb24obnMpIHtcblx0XHRcdFx0dmFyIGEgPSBucy5zcGxpdChcIi5cIiksXG5cdFx0XHRcdFx0cCA9IF9nbG9iYWxzLCBpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBbYVtpXV0gPSBwID0gcFthW2ldXSB8fCB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcDtcblx0XHRcdH0sXG5cdFx0XHRncyA9IF9uYW1lc3BhY2UoXCJjb20uZ3JlZW5zb2NrXCIpLFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldCwgMCkgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRfZW1wdHlGdW5jID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdF9pc0FycmF5ID0gKGZ1bmN0aW9uKCkgeyAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gaWZyYW1lIGVudmlyb25tZW50cyB3aGVyZSB0aGUgQXJyYXkgZ2xvYmFsIGlzbid0IHNoYXJlZCwgdGh1cyBpZiB0aGUgb2JqZWN0IG9yaWdpbmF0ZXMgaW4gYSBkaWZmZXJlbnQgd2luZG93L2lmcmFtZSwgXCIob2JqIGluc3RhbmNlb2YgQXJyYXkpXCIgd2lsbCBldmFsdWF0ZSBmYWxzZS4gV2UgYWRkZWQgc29tZSBzcGVlZCBvcHRpbWl6YXRpb25zIHRvIGF2b2lkIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgpIHVubGVzcyBpdCdzIGFic29sdXRlbHkgbmVjZXNzYXJ5IGJlY2F1c2UgaXQncyBWRVJZIHNsb3cgKGxpa2UgMjB4IHNsb3dlcilcblx0XHRcdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcblx0XHRcdFx0XHRhcnJheSA9IHRvU3RyaW5nLmNhbGwoW10pO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIChvYmogaW5zdGFuY2VvZiBBcnJheSB8fCAodHlwZW9mKG9iaikgPT09IFwib2JqZWN0XCIgJiYgISFvYmoucHVzaCAmJiB0b1N0cmluZy5jYWxsKG9iaikgPT09IGFycmF5KSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCkpLFxuXHRcdFx0YSwgaSwgcCwgX3RpY2tlciwgX3RpY2tlckFjdGl2ZSxcblx0XHRcdF9kZWZMb29rdXAgPSB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHRcdCAqIERlZmluZXMgYSBHcmVlblNvY2sgY2xhc3MsIG9wdGlvbmFsbHkgd2l0aCBhbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgdGhhdCBtdXN0IGJlIGluc3RhbnRpYXRlZCBmaXJzdCBhbmQgcGFzc2VkIGludG8gdGhlIGRlZmluaXRpb24uXG5cdFx0XHQgKiBUaGlzIGFsbG93cyB1c2VycyB0byBsb2FkIEdyZWVuU29jayBKUyBmaWxlcyBpbiBhbnkgb3JkZXIgZXZlbiBpZiB0aGV5IGhhdmUgaW50ZXJkZXBlbmRlbmNpZXMgKGxpa2UgQ1NTUGx1Z2luIGV4dGVuZHMgVHdlZW5QbHVnaW4gd2hpY2ggaXNcblx0XHRcdCAqIGluc2lkZSBUd2VlbkxpdGUuanMsIGJ1dCBpZiBDU1NQbHVnaW4gaXMgbG9hZGVkIGZpcnN0LCBpdCBzaG91bGQgd2FpdCB0byBydW4gaXRzIGNvZGUgdW50aWwgVHdlZW5MaXRlLmpzIGxvYWRzIGFuZCBpbnN0YW50aWF0ZXMgVHdlZW5QbHVnaW5cblx0XHRcdCAqIGFuZCB0aGVuIHBhc3MgVHdlZW5QbHVnaW4gdG8gQ1NTUGx1Z2luJ3MgZGVmaW5pdGlvbikuIFRoaXMgaXMgYWxsIGRvbmUgYXV0b21hdGljYWxseSBhbmQgaW50ZXJuYWxseS5cblx0XHRcdCAqXG5cdFx0XHQgKiBFdmVyeSBkZWZpbml0aW9uIHdpbGwgYmUgYWRkZWQgdG8gYSBcImNvbS5ncmVlbnNvY2tcIiBnbG9iYWwgb2JqZWN0ICh0eXBpY2FsbHkgd2luZG93LCBidXQgaWYgYSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyBvYmplY3QgaXMgZm91bmQsXG5cdFx0XHQgKiBpdCB3aWxsIGdvIHRoZXJlIGFzIG9mIHYxLjcpLiBGb3IgZXhhbXBsZSwgVHdlZW5MaXRlIHdpbGwgYmUgZm91bmQgYXQgd2luZG93LmNvbS5ncmVlbnNvY2suVHdlZW5MaXRlIGFuZCBzaW5jZSBpdCdzIGEgZ2xvYmFsIGNsYXNzIHRoYXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBhbnl3aGVyZSxcblx0XHRcdCAqIGl0IGlzIEFMU08gcmVmZXJlbmNlZCBhdCB3aW5kb3cuVHdlZW5MaXRlLiBIb3dldmVyIHNvbWUgY2xhc3NlcyBhcmVuJ3QgY29uc2lkZXJlZCBnbG9iYWwsIGxpa2UgdGhlIGJhc2UgY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbiBjbGFzcywgc29cblx0XHRcdCAqIHRob3NlIHdpbGwgb25seSBiZSBhdCB0aGUgcGFja2FnZSBsaWtlIHdpbmRvdy5jb20uZ3JlZW5zb2NrLmNvcmUuQW5pbWF0aW9uLiBBZ2FpbiwgaWYgeW91IGRlZmluZSBhIEdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IG9uIHRoZSB3aW5kb3csIGV2ZXJ5dGhpbmdcblx0XHRcdCAqIGdldHMgdHVja2VkIG5lYXRseSBpbnNpZGUgdGhlcmUgaW5zdGVhZCBvZiBvbiB0aGUgd2luZG93IGRpcmVjdGx5LiBUaGlzIGFsbG93cyB5b3UgdG8gZG8gYWR2YW5jZWQgdGhpbmdzIGxpa2UgbG9hZCBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBHcmVlblNvY2tcblx0XHRcdCAqIGZpbGVzIGFuZCBwdXQgdGhlbSBpbnRvIGRpc3RpbmN0IG9iamVjdHMgKGltYWdpbmUgYSBiYW5uZXIgYWQgdXNlcyBhIG5ld2VyIHZlcnNpb24gYnV0IHRoZSBtYWluIHNpdGUgdXNlcyBhbiBvbGRlciBvbmUpLiBJbiB0aGF0IGNhc2UsIHlvdSBjb3VsZFxuXHRcdFx0ICogc2FuZGJveCB0aGUgYmFubmVyIG9uZSBsaWtlOlxuXHRcdFx0ICpcblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgdmFyIGdzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB7fTsgLy90aGUgbmV3ZXIgdmVyc2lvbiB3ZSdyZSBhYm91dCB0byBsb2FkIGNvdWxkIG5vdyBiZSByZWZlcmVuY2VkIGluIGEgXCJnc1wiIG9iamVjdCwgbGlrZSBncy5Ud2VlbkxpdGUudG8oLi4uKS4gVXNlIHdoYXRldmVyIGFsaWFzIHlvdSB3YW50IGFzIGxvbmcgYXMgaXQncyB1bmlxdWUsIFwiZ3NcIiBvciBcImJhbm5lclwiIG9yIHdoYXRldmVyLlxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS43L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93Ll9nc1F1ZXVlID0gd2luZG93Ll9nc0RlZmluZSA9IG51bGw7IC8vcmVzZXQgaXQgYmFjayB0byBudWxsIChhbG9uZyB3aXRoIHRoZSBzcGVjaWFsIF9nc1F1ZXVlIHZhcmlhYmxlKSBzbyB0aGF0IHRoZSBuZXh0IGxvYWQgb2YgVHdlZW5NYXggYWZmZWN0cyB0aGUgd2luZG93IGFuZCB3ZSBjYW4gcmVmZXJlbmNlIHRoaW5ncyBkaXJlY3RseSBsaWtlIFR3ZWVuTGl0ZS50byguLi4pXG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQgc3JjPVwianMvZ3JlZW5zb2NrL3YxLjYvVHdlZW5NYXguanNcIj48L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgZ3MuVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjdcblx0XHRcdCAqICAgICBUd2VlbkxpdGUudG8oLi4uKTsgLy93b3VsZCB1c2UgdjEuNlxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBucyBUaGUgbmFtZXNwYWNlIG9mIHRoZSBjbGFzcyBkZWZpbml0aW9uLCBsZWF2aW5nIG9mZiBcImNvbS5ncmVlbnNvY2suXCIgYXMgdGhhdCdzIGFzc3VtZWQuIEZvciBleGFtcGxlLCBcIlR3ZWVuTGl0ZVwiIG9yIFwicGx1Z2lucy5DU1NQbHVnaW5cIiBvciBcImVhc2luZy5CYWNrXCIuXG5cdFx0XHQgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gZGVwZW5kZW5jaWVzIEFuIGFycmF5IG9mIGRlcGVuZGVuY2llcyAoZGVzY3JpYmVkIGFzIHRoZWlyIG5hbWVzcGFjZXMgbWludXMgXCJjb20uZ3JlZW5zb2NrLlwiIHByZWZpeCkuIEZvciBleGFtcGxlIFtcIlR3ZWVuTGl0ZVwiLFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLFwiY29yZS5BbmltYXRpb25cIl1cblx0XHRcdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6T2JqZWN0fSBmdW5jIFRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgYW5kIHBhc3NlZCB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBhY3R1YWwgY2xhc3MgZm9yIHRoaXMgZGVmaW5pdGlvbi5cblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGdsb2JhbCBJZiB0cnVlLCB0aGUgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2xvYmFsIHNjb3BlICh0eXBpY2FsbHkgd2luZG93IHVubGVzcyB5b3UgZGVmaW5lIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0KVxuXHRcdFx0ICovXG5cdFx0XHREZWZpbml0aW9uID0gZnVuY3Rpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdHRoaXMuc2MgPSAoX2RlZkxvb2t1cFtuc10pID8gX2RlZkxvb2t1cFtuc10uc2MgOiBbXTsgLy9zdWJjbGFzc2VzXG5cdFx0XHRcdF9kZWZMb29rdXBbbnNdID0gdGhpcztcblx0XHRcdFx0dGhpcy5nc0NsYXNzID0gbnVsbDtcblx0XHRcdFx0dGhpcy5mdW5jID0gZnVuYztcblx0XHRcdFx0dmFyIF9jbGFzc2VzID0gW107XG5cdFx0XHRcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbihpbml0KSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBkZXBlbmRlbmNpZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0bWlzc2luZyA9IGksXG5cdFx0XHRcdFx0XHRjdXIsIGEsIG4sIGNsO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKChjdXIgPSBfZGVmTG9va3VwW2RlcGVuZGVuY2llc1tpXV0gfHwgbmV3IERlZmluaXRpb24oZGVwZW5kZW5jaWVzW2ldLCBbXSkpLmdzQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0X2NsYXNzZXNbaV0gPSBjdXIuZ3NDbGFzcztcblx0XHRcdFx0XHRcdFx0bWlzc2luZy0tO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpbml0KSB7XG5cdFx0XHRcdFx0XHRcdGN1ci5zYy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWlzc2luZyA9PT0gMCAmJiBmdW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gKFwiY29tLmdyZWVuc29jay5cIiArIG5zKS5zcGxpdChcIi5cIik7XG5cdFx0XHRcdFx0XHRuID0gYS5wb3AoKTtcblx0XHRcdFx0XHRcdGNsID0gX25hbWVzcGFjZShhLmpvaW4oXCIuXCIpKVtuXSA9IHRoaXMuZ3NDbGFzcyA9IGZ1bmMuYXBwbHkoZnVuYywgX2NsYXNzZXMpO1xuXG5cdFx0XHRcdFx0XHQvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoZ2xvYmFsKSB7XG5cdFx0XHRcdFx0XHRcdF9nbG9iYWxzW25dID0gY2w7IC8vcHJvdmlkZXMgYSB3YXkgdG8gYXZvaWQgZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBtYWluIGNsYXNzZXMgbGlrZSBUd2VlbkxpdGUsIFBvd2VyMSwgU3Ryb25nLCBldGMuIGFyZSBhZGRlZCB0byB3aW5kb3cgdW5sZXNzIGEgR3JlZW5Tb2NrR2xvYmFscyBpcyBkZWZpbmVkLiBTbyBpZiB5b3Ugd2FudCB0byBoYXZlIHRoaW5ncyBhZGRlZCB0byBhIGN1c3RvbSBvYmplY3QgaW5zdGVhZCwganVzdCBkbyBzb21ldGhpbmcgbGlrZSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHt9IGJlZm9yZSBsb2FkaW5nIGFueSBHcmVlblNvY2sgZmlsZXMuIFlvdSBjYW4gZXZlbiBzZXQgdXAgYW4gYWxpYXMgbGlrZSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvd3MuZ3MgPSB7fSBzbyB0aGF0IHlvdSBjYW4gYWNjZXNzIGV2ZXJ5dGhpbmcgbGlrZSBncy5Ud2VlbkxpdGUuIEFsc28gcmVtZW1iZXIgdGhhdCBBTEwgY2xhc3NlcyBhcmUgYWRkZWQgdG8gdGhlIHdpbmRvdy5jb20uZ3JlZW5zb2NrIG9iamVjdCAoaW4gdGhlaXIgcmVzcGVjdGl2ZSBwYWNrYWdlcywgbGlrZSBjb20uZ3JlZW5zb2NrLmVhc2luZy5Qb3dlcjEsIGNvbS5ncmVlbnNvY2suVHdlZW5MaXRlLCBldGMuKVxuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mKGRlZmluZSkgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKXsgLy9BTURcblx0XHRcdFx0XHRcdFx0XHRkZWZpbmUoKHdpbmRvdy5HcmVlblNvY2tBTURQYXRoID8gd2luZG93LkdyZWVuU29ja0FNRFBhdGggKyBcIi9cIiA6IFwiXCIpICsgbnMuc3BsaXQoXCIuXCIpLnBvcCgpLCBbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBjbDsgfSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobnMgPT09IG1vZHVsZU5hbWUgJiYgdHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpeyAvL25vZGVcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5zYy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNjW2ldLmNoZWNrKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmNoZWNrKHRydWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly91c2VkIHRvIGNyZWF0ZSBEZWZpbml0aW9uIGluc3RhbmNlcyAod2hpY2ggYmFzaWNhbGx5IHJlZ2lzdGVycyBhIGNsYXNzIHRoYXQgaGFzIGRlcGVuZGVuY2llcykuXG5cdFx0XHRfZ3NEZWZpbmUgPSB3aW5kb3cuX2dzRGVmaW5lID0gZnVuY3Rpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgRGVmaW5pdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9hIHF1aWNrIHdheSB0byBjcmVhdGUgYSBjbGFzcyB0aGF0IGRvZXNuJ3QgaGF2ZSBhbnkgZGVwZW5kZW5jaWVzLiBSZXR1cm5zIHRoZSBjbGFzcywgYnV0IGZpcnN0IHJlZ2lzdGVycyBpdCBpbiB0aGUgR3JlZW5Tb2NrIG5hbWVzcGFjZSBzbyB0aGF0IG90aGVyIGNsYXNzZXMgY2FuIGdyYWIgaXQgKG90aGVyIGNsYXNzZXMgbWlnaHQgYmUgZGVwZW5kZW50IG9uIHRoZSBjbGFzcykuXG5cdFx0XHRfY2xhc3MgPSBncy5fY2xhc3MgPSBmdW5jdGlvbihucywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdGZ1bmMgPSBmdW5jIHx8IGZ1bmN0aW9uKCkge307XG5cdFx0XHRcdF9nc0RlZmluZShucywgW10sIGZ1bmN0aW9uKCl7IHJldHVybiBmdW5jOyB9LCBnbG9iYWwpO1xuXHRcdFx0XHRyZXR1cm4gZnVuYztcblx0XHRcdH07XG5cblx0XHRfZ3NEZWZpbmUuZ2xvYmFscyA9IF9nbG9iYWxzO1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEVhc2VcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBfYmFzZVBhcmFtcyA9IFswLCAwLCAxLCAxXSxcblx0XHRcdF9ibGFua0FycmF5ID0gW10sXG5cdFx0XHRFYXNlID0gX2NsYXNzKFwiZWFzaW5nLkVhc2VcIiwgZnVuY3Rpb24oZnVuYywgZXh0cmFQYXJhbXMsIHR5cGUsIHBvd2VyKSB7XG5cdFx0XHRcdHRoaXMuX2Z1bmMgPSBmdW5jO1xuXHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9wb3dlciA9IHBvd2VyIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3BhcmFtcyA9IGV4dHJhUGFyYW1zID8gX2Jhc2VQYXJhbXMuY29uY2F0KGV4dHJhUGFyYW1zKSA6IF9iYXNlUGFyYW1zO1xuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRfZWFzZU1hcCA9IEVhc2UubWFwID0ge30sXG5cdFx0XHRfZWFzZVJlZyA9IEVhc2UucmVnaXN0ZXIgPSBmdW5jdGlvbihlYXNlLCBuYW1lcywgdHlwZXMsIGNyZWF0ZSkge1xuXHRcdFx0XHR2YXIgbmEgPSBuYW1lcy5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0aSA9IG5hLmxlbmd0aCxcblx0XHRcdFx0XHR0YSA9ICh0eXBlcyB8fCBcImVhc2VJbixlYXNlT3V0LGVhc2VJbk91dFwiKS5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0ZSwgbmFtZSwgaiwgdHlwZTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0bmFtZSA9IG5hW2ldO1xuXHRcdFx0XHRcdGUgPSBjcmVhdGUgPyBfY2xhc3MoXCJlYXNpbmcuXCIrbmFtZSwgbnVsbCwgdHJ1ZSkgOiBncy5lYXNpbmdbbmFtZV0gfHwge307XG5cdFx0XHRcdFx0aiA9IHRhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSB0YVtqXTtcblx0XHRcdFx0XHRcdF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHR5cGVdID0gX2Vhc2VNYXBbdHlwZSArIG5hbWVdID0gZVt0eXBlXSA9IGVhc2UuZ2V0UmF0aW8gPyBlYXNlIDogZWFzZVt0eXBlXSB8fCBuZXcgZWFzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdHAgPSBFYXNlLnByb3RvdHlwZTtcblx0XHRwLl9jYWxjRW5kID0gZmFsc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmICh0aGlzLl9mdW5jKSB7XG5cdFx0XHRcdHRoaXMuX3BhcmFtc1swXSA9IHA7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9mdW5jLmFwcGx5KG51bGwsIHRoaXMuX3BhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdCA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHB3ID0gdGhpcy5fcG93ZXIsXG5cdFx0XHRcdHIgPSAodCA9PT0gMSkgPyAxIC0gcCA6ICh0ID09PSAyKSA/IHAgOiAocCA8IDAuNSkgPyBwICogMiA6ICgxIC0gcCkgKiAyO1xuXHRcdFx0aWYgKHB3ID09PSAxKSB7XG5cdFx0XHRcdHIgKj0gcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDIpIHtcblx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDMpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSA0KSB7XG5cdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodCA9PT0gMSkgPyAxIC0gciA6ICh0ID09PSAyKSA/IHIgOiAocCA8IDAuNSkgPyByIC8gMiA6IDEgLSAociAvIDIpO1xuXHRcdH07XG5cblx0XHQvL2NyZWF0ZSBhbGwgdGhlIHN0YW5kYXJkIGVhc2VzIGxpa2UgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgYW5kIFBvd2VyNCAoZWFjaCB3aXRoIGVhc2VJbiwgZWFzZU91dCwgYW5kIGVhc2VJbk91dClcblx0XHRhID0gW1wiTGluZWFyXCIsXCJRdWFkXCIsXCJDdWJpY1wiLFwiUXVhcnRcIixcIlF1aW50LFN0cm9uZ1wiXTtcblx0XHRpID0gYS5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRwID0gYVtpXStcIixQb3dlclwiK2k7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMSxpKSwgcCwgXCJlYXNlT3V0XCIsIHRydWUpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDIsaSksIHAsIFwiZWFzZUluXCIgKyAoKGkgPT09IDApID8gXCIsZWFzZU5vbmVcIiA6IFwiXCIpKTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwzLGkpLCBwLCBcImVhc2VJbk91dFwiKTtcblx0XHR9XG5cdFx0X2Vhc2VNYXAubGluZWFyID0gZ3MuZWFzaW5nLkxpbmVhci5lYXNlSW47XG5cdFx0X2Vhc2VNYXAuc3dpbmcgPSBncy5lYXNpbmcuUXVhZC5lYXNlSW5PdXQ7IC8vZm9yIGpRdWVyeSBmb2xrc1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFdmVudERpc3BhdGNoZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBFdmVudERpc3BhdGNoZXIgPSBfY2xhc3MoXCJldmVudHMuRXZlbnREaXNwYXRjaGVyXCIsIGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdFx0dGhpcy5fbGlzdGVuZXJzID0ge307XG5cdFx0XHR0aGlzLl9ldmVudFRhcmdldCA9IHRhcmdldCB8fCB0aGlzO1xuXHRcdH0pO1xuXHRcdHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xuXG5cdFx0cC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIHNjb3BlLCB1c2VQYXJhbSwgcHJpb3JpdHkpIHtcblx0XHRcdHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxpc3RlbmVyLCBpO1xuXHRcdFx0aWYgKGxpc3QgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBsaXN0ID0gW107XG5cdFx0XHR9XG5cdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0bGlzdGVuZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRpZiAobGlzdGVuZXIuYyA9PT0gY2FsbGJhY2sgJiYgbGlzdGVuZXIucyA9PT0gc2NvcGUpIHtcblx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpbmRleCA9PT0gMCAmJiBsaXN0ZW5lci5wciA8IHByaW9yaXR5KSB7XG5cdFx0XHRcdFx0aW5kZXggPSBpICsgMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGlzdC5zcGxpY2UoaW5kZXgsIDAsIHtjOmNhbGxiYWNrLCBzOnNjb3BlLCB1cDp1c2VQYXJhbSwgcHI6cHJpb3JpdHl9KTtcblx0XHRcdGlmICh0aGlzID09PSBfdGlja2VyICYmICFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sIGk7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsaXN0W2ldLmMgPT09IGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGksIHQsIGxpc3RlbmVyO1xuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHR0ID0gdGhpcy5fZXZlbnRUYXJnZXQ7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAobGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lci51cCkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jLmNhbGwobGlzdGVuZXIucyB8fCB0LCB7dHlwZTp0eXBlLCB0YXJnZXQ6dH0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGlja2VyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbiBcdFx0dmFyIF9yZXFBbmltRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSxcblx0XHRcdF9nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO30sXG5cdFx0XHRfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCk7XG5cblx0XHQvL25vdyB0cnkgdG8gZGV0ZXJtaW5lIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIGNhbmNlbEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9ucyBhbmQgaWYgbm9uZSBhcmUgZm91bmQsIHdlJ2xsIHVzZSBhIHNldFRpbWVvdXQoKS9jbGVhclRpbWVvdXQoKSBwb2x5ZmlsbC5cblx0XHRhID0gW1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEgJiYgIV9yZXFBbmltRnJhbWUpIHtcblx0XHRcdF9yZXFBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvd1thW2ldICsgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXSB8fCB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdH1cblxuXHRcdF9jbGFzcyhcIlRpY2tlclwiLCBmdW5jdGlvbihmcHMsIHVzZVJBRikge1xuXHRcdFx0dmFyIF9zZWxmID0gdGhpcyxcblx0XHRcdFx0X3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG5cdFx0XHRcdF91c2VSQUYgPSAodXNlUkFGICE9PSBmYWxzZSAmJiBfcmVxQW5pbUZyYW1lKSxcblx0XHRcdFx0X2xhZ1RocmVzaG9sZCA9IDUwMCxcblx0XHRcdFx0X2FkanVzdGVkTGFnID0gMzMsXG5cdFx0XHRcdF90aWNrV29yZCA9IFwidGlja1wiLCAvL2hlbHBzIHJlZHVjZSBnYyBidXJkZW5cblx0XHRcdFx0X2ZwcywgX3JlcSwgX2lkLCBfZ2FwLCBfbmV4dFRpbWUsXG5cdFx0XHRcdF90aWNrID0gZnVuY3Rpb24obWFudWFsKSB7XG5cdFx0XHRcdFx0dmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG5cdFx0XHRcdFx0XHRvdmVybGFwLCBkaXNwYXRjaDtcblx0XHRcdFx0XHRpZiAoZWxhcHNlZCA+IF9sYWdUaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdF9zdGFydFRpbWUgKz0gZWxhcHNlZCAtIF9hZGp1c3RlZExhZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcblx0XHRcdFx0XHRfc2VsZi50aW1lID0gKF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZSkgLyAxMDAwO1xuXHRcdFx0XHRcdG92ZXJsYXAgPSBfc2VsZi50aW1lIC0gX25leHRUaW1lO1xuXHRcdFx0XHRcdGlmICghX2ZwcyB8fCBvdmVybGFwID4gMCB8fCBtYW51YWwgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdF9zZWxmLmZyYW1lKys7XG5cdFx0XHRcdFx0XHRfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyAwLjAwNCA6IF9nYXAgLSBvdmVybGFwKTtcblx0XHRcdFx0XHRcdGRpc3BhdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1hbnVhbCAhPT0gdHJ1ZSkgeyAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxuXHRcdFx0XHRcdFx0X2lkID0gX3JlcShfdGljayk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkaXNwYXRjaCkge1xuXHRcdFx0XHRcdFx0X3NlbGYuZGlzcGF0Y2hFdmVudChfdGlja1dvcmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0RXZlbnREaXNwYXRjaGVyLmNhbGwoX3NlbGYpO1xuXHRcdFx0X3NlbGYudGltZSA9IF9zZWxmLmZyYW1lID0gMDtcblx0XHRcdF9zZWxmLnRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0X3RpY2sodHJ1ZSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5sYWdTbW9vdGhpbmcgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgKDEgLyBfdGlueU51bSk7IC8vemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZywgX2xhZ1RocmVzaG9sZCwgMCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5zbGVlcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX2lkID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfdXNlUkFGIHx8ICFfY2FuY2VsQW5pbUZyYW1lKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KF9pZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2NhbmNlbEFuaW1GcmFtZShfaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXEgPSBfZW1wdHlGdW5jO1xuXHRcdFx0XHRfaWQgPSBudWxsO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLndha2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF9pZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoX3NlbGYuZnJhbWUgPiAxMCkgeyAvL2Rvbid0IHRyaWdnZXIgbGFnU21vb3RoaW5nIGlmIHdlJ3JlIGp1c3Qgd2FraW5nIHVwLCBhbmQgbWFrZSBzdXJlIHRoYXQgYXQgbGVhc3QgMTAgZnJhbWVzIGhhdmUgZWxhcHNlZCBiZWNhdXNlIG9mIHRoZSBpT1MgYnVnIHRoYXQgd2Ugd29yayBhcm91bmQgYmVsb3cgd2l0aCB0aGUgMS41LXNlY29uZCBzZXRUaW1vdXQoKS5cblx0XHRcdFx0XHRfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCkgLSBfbGFnVGhyZXNob2xkICsgNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gKF9mcHMgPT09IDApID8gX2VtcHR5RnVuYyA6ICghX3VzZVJBRiB8fCAhX3JlcUFuaW1GcmFtZSkgPyBmdW5jdGlvbihmKSB7IHJldHVybiBzZXRUaW1lb3V0KGYsICgoX25leHRUaW1lIC0gX3NlbGYudGltZSkgKiAxMDAwICsgMSkgfCAwKTsgfSA6IF9yZXFBbmltRnJhbWU7XG5cdFx0XHRcdGlmIChfc2VsZiA9PT0gX3RpY2tlcikge1xuXHRcdFx0XHRcdF90aWNrZXJBY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90aWNrKDIpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuZnBzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9mcHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2ZwcyA9IHZhbHVlO1xuXHRcdFx0XHRfZ2FwID0gMSAvIChfZnBzIHx8IDYwKTtcblx0XHRcdFx0X25leHRUaW1lID0gdGhpcy50aW1lICsgX2dhcDtcblx0XHRcdFx0X3NlbGYud2FrZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYudXNlUkFGID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF91c2VSQUY7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0X3VzZVJBRiA9IHZhbHVlO1xuXHRcdFx0XHRfc2VsZi5mcHMoX2Zwcyk7XG5cdFx0XHR9O1xuXHRcdFx0X3NlbGYuZnBzKGZwcyk7XG5cblx0XHRcdC8vYSBidWcgaW4gaU9TIDYgU2FmYXJpIG9jY2FzaW9uYWxseSBwcmV2ZW50cyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gd29ya2luZyBpbml0aWFsbHksIHNvIHdlIHVzZSBhIDEuNS1zZWNvbmQgdGltZW91dCB0aGF0IGF1dG9tYXRpY2FsbHkgZmFsbHMgYmFjayB0byBzZXRUaW1lb3V0KCkgaWYgaXQgc2Vuc2VzIHRoaXMgY29uZGl0aW9uLlxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF91c2VSQUYgJiYgX3NlbGYuZnJhbWUgPCA1KSB7XG5cdFx0XHRcdFx0X3NlbGYudXNlUkFGKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTUwMCk7XG5cdFx0fSk7XG5cblx0XHRwID0gZ3MuVGlja2VyLnByb3RvdHlwZSA9IG5ldyBncy5ldmVudHMuRXZlbnREaXNwYXRjaGVyKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IGdzLlRpY2tlcjtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQW5pbWF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgQW5pbWF0aW9uID0gX2NsYXNzKFwiY29yZS5BbmltYXRpb25cIiwgZnVuY3Rpb24oZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0dGhpcy52YXJzID0gdmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDA7XG5cdFx0XHRcdHRoaXMuX2RlbGF5ID0gTnVtYmVyKHZhcnMuZGVsYXkpIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3RpbWVTY2FsZSA9IDE7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSAodmFycy5yZXZlcnNlZCA9PT0gdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFfcm9vdFRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TIDYgU2FmYXJpKSBzaHV0IGRvd24gSmF2YVNjcmlwdCBleGVjdXRpb24gd2hlbiB0aGUgdGFiIGlzIGRpc2FibGVkIGFuZCB0aGV5IFtvY2Nhc2lvbmFsbHldIG5lZ2xlY3QgdG8gc3RhcnQgdXAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFnYWluIHdoZW4gcmV0dXJuaW5nIC0gdGhpcyBjb2RlIGVuc3VyZXMgdGhhdCB0aGUgZW5naW5lIHN0YXJ0cyB1cCBhZ2FpbiBwcm9wZXJseS5cblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0bCA9IHRoaXMudmFycy51c2VGcmFtZXMgPyBfcm9vdEZyYW1lc1RpbWVsaW5lIDogX3Jvb3RUaW1lbGluZTtcblx0XHRcdFx0dGwuYWRkKHRoaXMsIHRsLl90aW1lKTtcblxuXHRcdFx0XHRpZiAodGhpcy52YXJzLnBhdXNlZCkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdF90aWNrZXIgPSBBbmltYXRpb24udGlja2VyID0gbmV3IGdzLlRpY2tlcigpO1xuXHRcdHAgPSBBbmltYXRpb24ucHJvdG90eXBlO1xuXHRcdHAuX2RpcnR5ID0gcC5fZ2MgPSBwLl9pbml0dGVkID0gcC5fcGF1c2VkID0gZmFsc2U7XG5cdFx0cC5fdG90YWxUaW1lID0gcC5fdGltZSA9IDA7XG5cdFx0cC5fcmF3UHJldlRpbWUgPSAtMTtcblx0XHRwLl9uZXh0ID0gcC5fbGFzdCA9IHAuX29uVXBkYXRlID0gcC5fdGltZWxpbmUgPSBwLnRpbWVsaW5lID0gbnVsbDtcblx0XHRwLl9wYXVzZWQgPSBmYWxzZTtcblxuXG5cdFx0Ly9zb21lIGJyb3dzZXJzIChsaWtlIGlPUykgb2NjYXNpb25hbGx5IGRyb3AgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBldmVudCB3aGVuIHRoZSB1c2VyIHN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHRhYiBhbmQgdGhlbiBjb21lcyBiYWNrIGFnYWluLCBzbyB3ZSB1c2UgYSAyLXNlY29uZCBzZXRUaW1lb3V0KCkgdG8gc2Vuc2UgaWYvd2hlbiB0aGF0IGNvbmRpdGlvbiBvY2N1cnMgYW5kIHRoZW4gd2FrZSgpIHRoZSB0aWNrZXIuXG5cdFx0dmFyIF9jaGVja1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF90aWNrZXJBY3RpdmUgJiYgX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlID4gMjAwMCkge1xuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldFRpbWVvdXQoX2NoZWNrVGltZW91dCwgMjAwMCk7XG5cdFx0XHR9O1xuXHRcdF9jaGVja1RpbWVvdXQoKTtcblxuXG5cdFx0cC5wbGF5ID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlID0gZnVuY3Rpb24oYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGF0VGltZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN1bWUgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5zZWVrID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZShOdW1iZXIodGltZSksIHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVzdGFydCA9IGZ1bmN0aW9uKGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlaygoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHQvL3N0dWIgLSB3ZSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBzdWJjbGFzc2VzLlxuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRoaXMuX2djID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdFx0aWYgKHRoaXMuX2djIHx8ICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsIC8vdGhlIDIgcm9vdCB0aW1lbGluZXMgd29uJ3QgaGF2ZSBhIF90aW1lbGluZTsgdGhleSdyZSBhbHdheXMgYWN0aXZlLlxuXHRcdFx0XHRzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHJhd1RpbWU7XG5cdFx0XHRyZXR1cm4gKCF0bCB8fCAoIXRoaXMuX2djICYmICF0aGlzLl9wYXVzZWQgJiYgdGwuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHRsLnJhd1RpbWUoKSkgPj0gc3RhcnRUaW1lICYmIHJhd1RpbWUgPCBzdGFydFRpbWUgKyB0aGlzLnRvdGFsRHVyYXRpb24oKSAvIHRoaXMuX3RpbWVTY2FsZSkpO1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9nYyA9ICFlbmFibGVkO1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0aWYgKGlnbm9yZVRpbWVsaW5lICE9PSB0cnVlKSB7XG5cdFx0XHRcdGlmIChlbmFibGVkICYmICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuYWRkKHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTtcblx0XHRcdFx0fSBlbHNlIGlmICghZW5hYmxlZCAmJiB0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuX3JlbW92ZSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAua2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0dGhpcy5fa2lsbCh2YXJzLCB0YXJnZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3VuY2FjaGUgPSBmdW5jdGlvbihpbmNsdWRlU2VsZikge1xuXHRcdFx0dmFyIHR3ZWVuID0gaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3N3YXBTZWxmSW5QYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHRcdHZhciBpID0gcGFyYW1zLmxlbmd0aCxcblx0XHRcdFx0Y29weSA9IHBhcmFtcy5jb25jYXQoKTtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGFyYW1zW2ldID09PSBcIntzZWxmfVwiKSB7XG5cdFx0XHRcdFx0Y29weVtpXSA9IHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH07XG5cbi8vLS0tLUFuaW1hdGlvbiBnZXR0ZXJzL3NldHRlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRpZiAoKHR5cGUgfHwgXCJcIikuc3Vic3RyKDAsMikgPT09IFwib25cIikge1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFycztcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdlt0eXBlXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB2W3R5cGVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZbdHlwZV0gPSBjYWxsYmFjaztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlBhcmFtc1wiXSA9IChfaXNBcnJheShwYXJhbXMpICYmIHBhcmFtcy5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSA/IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXMocGFyYW1zKSA6IHBhcmFtcztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlNjb3BlXCJdID0gc2NvcGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGUgPT09IFwib25VcGRhdGVcIikge1xuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2s7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmRlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZGVsYXk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dGhpcy5zdGFydFRpbWUoIHRoaXMuX3N0YXJ0VGltZSArIHZhbHVlIC0gdGhpcy5fZGVsYXkgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gdmFsdWU7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpOyAvL3RydWUgaW4gY2FzZSBpdCdzIGEgVHdlZW5NYXggb3IgVGltZWxpbmVNYXggdGhhdCBoYXMgYSByZXBlYXQgLSB3ZSdsbCBuZWVkIHRvIHJlZnJlc2ggdGhlIHRvdGFsRHVyYXRpb24uXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIGlmICh0aGlzLl90aW1lID4gMCkgaWYgKHRoaXMuX3RpbWUgPCB0aGlzLl9kdXJhdGlvbikgaWYgKHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudG90YWxUaW1lKHRoaXMuX3RvdGFsVGltZSAqICh2YWx1ZSAvIHRoaXMuX2R1cmF0aW9uKSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uKHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pID8gdGhpcy5fZHVyYXRpb24gOiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmICF1bmNhcHBlZCkge1xuXHRcdFx0XHRcdHRpbWUgKz0gdGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHRvdGFsRHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uLFxuXHRcdFx0XHRcdFx0dGwgPSB0aGlzLl90aW1lbGluZTtcblx0XHRcdFx0XHRpZiAodGltZSA+IHRvdGFsRHVyYXRpb24gJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0XHR0aW1lID0gdG90YWxEdXJhdGlvbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gKHRoaXMuX3BhdXNlZCA/IHRoaXMuX3BhdXNlVGltZSA6IHRsLl90aW1lKSAtICgoIXRoaXMuX3JldmVyc2VkID8gdGltZSA6IHRvdGFsRHVyYXRpb24gLSB0aW1lKSAvIHRoaXMuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0aWYgKCF0bC5fZGlydHkpIHsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG5cdFx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0VGltZSBvZiB0aGF0IGNoaWxkIHdvdWxkIGdldCBwdXNoZWQgb3V0LCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgbWF5IGhhdmUgY29tcGxldGVkLlxuXHRcdFx0XHRcdGlmICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZS5fdGltZSAhPT0gKHRsLl9zdGFydFRpbWUgKyB0bC5fdG90YWxUaW1lKSAvIHRsLl90aW1lU2NhbGUpIHtcblx0XHRcdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHRpbWUgfHwgdGhpcy5fZHVyYXRpb24gPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIHNvbWVvbmUgY2FsbHMgc2VlaygpIG9yIHRpbWUoKSBvciBwcm9ncmVzcygpLCB0aGV5IGV4cGVjdCBhbiBpbW1lZGlhdGUgcmVuZGVyLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnByb2dyZXNzID0gcC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnN0YXJ0VGltZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAodGhpcy50aW1lbGluZSkgaWYgKHRoaXMudGltZWxpbmUuX3NvcnRDaGlsZHJlbikge1xuXHRcdFx0XHRcdHRoaXMudGltZWxpbmUuYWRkKHRoaXMsIHZhbHVlIC0gdGhpcy5fZGVsYXkpOyAvL2Vuc3VyZXMgdGhhdCBhbnkgbmVjZXNzYXJ5IHJlLXNlcXVlbmNpbmcgb2YgQW5pbWF0aW9ucyBpbiB0aGUgdGltZWxpbmUgb2NjdXJzIHRvIG1ha2Ugc3VyZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGlzIGNvcnJlY3QuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmVuZFRpbWUgPSBmdW5jdGlvbihpbmNsdWRlUmVwZWF0cykge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZSArICgoaW5jbHVkZVJlcGVhdHMgIT0gZmFsc2UpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdH07XG5cblx0XHRwLnRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgX3RpbnlOdW07IC8vY2FuJ3QgYWxsb3cgemVybyBiZWNhdXNlIGl0J2xsIHRocm93IHRoZSBtYXRoIG9mZlxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lICYmIHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdHZhciBwYXVzZVRpbWUgPSB0aGlzLl9wYXVzZVRpbWUsXG5cdFx0XHRcdFx0dCA9IChwYXVzZVRpbWUgfHwgcGF1c2VUaW1lID09PSAwKSA/IHBhdXNlVGltZSA6IHRoaXMuX3RpbWVsaW5lLnRvdGFsVGltZSgpO1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGhpcy5fc3RhcnRUaW1lKSAqIHRoaXMuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RpbWVTY2FsZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJldmVyc2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUoKCh0aGlzLl90aW1lbGluZSAmJiAhdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgLSB0aGlzLl90b3RhbFRpbWUgOiB0aGlzLl90b3RhbFRpbWUpLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhdXNlZDtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lLFxuXHRcdFx0XHRyYXcsIGVsYXBzZWQ7XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcGF1c2VkKSBpZiAodGwpIHtcblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlICYmICF2YWx1ZSkge1xuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhdyA9IHRsLnJhd1RpbWUoKTtcblx0XHRcdFx0ZWxhcHNlZCA9IHJhdyAtIHRoaXMuX3BhdXNlVGltZTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiB0bC5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3BhdXNlVGltZSA9IHZhbHVlID8gcmF3IDogbnVsbDtcblx0XHRcdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiBlbGFwc2VkICE9PSAwICYmIHRoaXMuX2luaXR0ZWQgJiYgdGhpcy5kdXJhdGlvbigpKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIoKHRsLnNtb290aENoaWxkVGltaW5nID8gdGhpcy5fdG90YWxUaW1lIDogKHJhdyAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl90aW1lU2NhbGUpLCB0cnVlLCB0cnVlKTsgLy9pbiBjYXNlIHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzIGNoYW5nZWQgdmlhIHNvbWUgb3RoZXIgdHdlZW4gb3IgbWFudWFsIHVwZGF0ZSBieSB0aGUgdXNlciwgd2Ugc2hvdWxkIGZvcmNlIGEgcmVuZGVyLlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZ2MgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogU2ltcGxlVGltZWxpbmVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBTaW1wbGVUaW1lbGluZSA9IF9jbGFzcyhcImNvcmUuU2ltcGxlVGltZWxpbmVcIiwgZnVuY3Rpb24odmFycykge1xuXHRcdFx0QW5pbWF0aW9uLmNhbGwodGhpcywgMCwgdmFycyk7XG5cdFx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9IHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0cCA9IFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZSA9IG5ldyBBbmltYXRpb24oKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gU2ltcGxlVGltZWxpbmU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0cC5fZmlyc3QgPSBwLl9sYXN0ID0gcC5fcmVjZW50ID0gbnVsbDtcblx0XHRwLl9zb3J0Q2hpbGRyZW4gPSBmYWxzZTtcblxuXHRcdHAuYWRkID0gcC5pbnNlcnQgPSBmdW5jdGlvbihjaGlsZCwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgcHJldlR3ZWVuLCBzdDtcblx0XHRcdGNoaWxkLl9zdGFydFRpbWUgPSBOdW1iZXIocG9zaXRpb24gfHwgMCkgKyBjaGlsZC5fZGVsYXk7XG5cdFx0XHRpZiAoY2hpbGQuX3BhdXNlZCkgaWYgKHRoaXMgIT09IGNoaWxkLl90aW1lbGluZSkgeyAvL3dlIG9ubHkgYWRqdXN0IHRoZSBfcGF1c2VUaW1lIGlmIGl0IHdhc24ndCBpbiB0aGlzIHRpbWVsaW5lIGFscmVhZHkuIFJlbWVtYmVyLCBzb21ldGltZXMgYSB0d2VlbiB3aWxsIGJlIGluc2VydGVkIGFnYWluIGludG8gdGhlIHNhbWUgdGltZWxpbmUgd2hlbiBpdHMgc3RhcnRUaW1lIGlzIGNoYW5nZWQgc28gdGhhdCB0aGUgdHdlZW5zIGluIHRoZSBUaW1lbGluZUxpdGUvTWF4IGFyZSByZS1vcmRlcmVkIHByb3Blcmx5IGluIHRoZSBsaW5rZWQgbGlzdCAoc28gZXZlcnl0aGluZyByZW5kZXJzIGluIHRoZSBwcm9wZXIgb3JkZXIpLlxuXHRcdFx0XHRjaGlsZC5fcGF1c2VUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArICgodGhpcy5yYXdUaW1lKCkgLSBjaGlsZC5fc3RhcnRUaW1lKSAvIGNoaWxkLl90aW1lU2NhbGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoaWxkLnRpbWVsaW5lKSB7XG5cdFx0XHRcdGNoaWxkLnRpbWVsaW5lLl9yZW1vdmUoY2hpbGQsIHRydWUpOyAvL3JlbW92ZXMgZnJvbSBleGlzdGluZyB0aW1lbGluZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSBhZGRlZCB0byB0aGlzIG9uZS5cblx0XHRcdH1cblx0XHRcdGNoaWxkLnRpbWVsaW5lID0gY2hpbGQuX3RpbWVsaW5lID0gdGhpcztcblx0XHRcdGlmIChjaGlsZC5fZ2MpIHtcblx0XHRcdFx0Y2hpbGQuX2VuYWJsZWQodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRwcmV2VHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0aWYgKHRoaXMuX3NvcnRDaGlsZHJlbikge1xuXHRcdFx0XHRzdCA9IGNoaWxkLl9zdGFydFRpbWU7XG5cdFx0XHRcdHdoaWxlIChwcmV2VHdlZW4gJiYgcHJldlR3ZWVuLl9zdGFydFRpbWUgPiBzdCkge1xuXHRcdFx0XHRcdHByZXZUd2VlbiA9IHByZXZUd2Vlbi5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUd2Vlbikge1xuXHRcdFx0XHRjaGlsZC5fbmV4dCA9IHByZXZUd2Vlbi5fbmV4dDtcblx0XHRcdFx0cHJldlR3ZWVuLl9uZXh0ID0gY2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5fbmV4dCA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR0aGlzLl9maXJzdCA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoaWxkLl9uZXh0KSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9sYXN0ID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZC5fcHJldiA9IHByZXZUd2Vlbjtcblx0XHRcdHRoaXMuX3JlY2VudCA9IGNoaWxkO1xuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRpZiAodHdlZW4udGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0aWYgKCFza2lwRGlzYWJsZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0d2Vlbi5fcHJldikge1xuXHRcdFx0XHRcdHR3ZWVuLl9wcmV2Ll9uZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3QgPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3QgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4uX25leHQpIHtcblx0XHRcdFx0XHR0d2Vlbi5fbmV4dC5fcHJldiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xhc3QgPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fbGFzdCA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuLl9uZXh0ID0gdHdlZW4uX3ByZXYgPSB0d2Vlbi50aW1lbGluZSA9IG51bGw7XG5cdFx0XHRcdGlmICh0d2VlbiA9PT0gdGhpcy5fcmVjZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVjZW50ID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdG5leHQ7XG5cdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0aW1lID49IHR3ZWVuLl9zdGFydFRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQpKSB7XG5cdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAucmF3VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHR9O1xuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHdlZW5MaXRlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgVHdlZW5MaXRlID0gX2NsYXNzKFwiVHdlZW5MaXRlXCIsIGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0QW5pbWF0aW9uLmNhbGwodGhpcywgZHVyYXRpb24sIHZhcnMpO1xuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUucmVuZGVyOyAvL3NwZWVkIG9wdGltaXphdGlvbiAoYXZvaWQgcHJvdG90eXBlIGxvb2t1cCBvbiB0aGlzIFwiaG90XCIgbWV0aG9kKVxuXG5cdFx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRocm93IFwiQ2Fubm90IHR3ZWVuIGEgbnVsbCB0YXJnZXQuXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRhcmdldCA9IHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyB0YXJnZXQgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cblx0XHRcdFx0dmFyIGlzU2VsZWN0b3IgPSAodGFyZ2V0LmpxdWVyeSB8fCAodGFyZ2V0Lmxlbmd0aCAmJiB0YXJnZXQgIT09IHdpbmRvdyAmJiB0YXJnZXRbMF0gJiYgKHRhcmdldFswXSA9PT0gd2luZG93IHx8ICh0YXJnZXRbMF0ubm9kZVR5cGUgJiYgdGFyZ2V0WzBdLnN0eWxlICYmICF0YXJnZXQubm9kZVR5cGUpKSkpLFxuXHRcdFx0XHRcdG92ZXJ3cml0ZSA9IHRoaXMudmFycy5vdmVyd3JpdGUsXG5cdFx0XHRcdFx0aSwgdGFyZywgdGFyZ2V0cztcblxuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGUgPSAob3ZlcndyaXRlID09IG51bGwpID8gX292ZXJ3cml0ZUxvb2t1cFtUd2VlbkxpdGUuZGVmYXVsdE92ZXJ3cml0ZV0gOiAodHlwZW9mKG92ZXJ3cml0ZSkgPT09IFwibnVtYmVyXCIpID8gb3ZlcndyaXRlID4+IDAgOiBfb3ZlcndyaXRlTG9va3VwW292ZXJ3cml0ZV07XG5cblx0XHRcdFx0aWYgKChpc1NlbGVjdG9yIHx8IHRhcmdldCBpbnN0YW5jZW9mIEFycmF5IHx8ICh0YXJnZXQucHVzaCAmJiBfaXNBcnJheSh0YXJnZXQpKSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IF9zbGljZSh0YXJnZXQpOyAgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSBbXTtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpXTtcblx0XHRcdFx0XHRcdGlmICghdGFyZykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHRhcmcpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmcgPSB0YXJnZXRzW2ktLV0gPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZyk7IC8vaW4gY2FzZSBpdCdzIGFuIGFycmF5IG9mIHN0cmluZ3Ncblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGkrMSwgMSk7IC8vdG8gYXZvaWQgYW4gZW5kbGVzcyBsb29wIChjYW4ndCBpbWFnaW5lIHdoeSB0aGUgc2VsZWN0b3Igd291bGQgcmV0dXJuIGEgc3RyaW5nLCBidXQganVzdCBpbiBjYXNlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0YXJnLmxlbmd0aCAmJiB0YXJnICE9PSB3aW5kb3cgJiYgdGFyZ1swXSAmJiAodGFyZ1swXSA9PT0gd2luZG93IHx8ICh0YXJnWzBdLm5vZGVUeXBlICYmIHRhcmdbMF0uc3R5bGUgJiYgIXRhcmcubm9kZVR5cGUpKSkgeyAvL2luIGNhc2UgdGhlIHVzZXIgaXMgcGFzc2luZyBpbiBhbiBhcnJheSBvZiBzZWxlY3RvciBvYmplY3RzIChsaWtlIGpRdWVyeSBvYmplY3RzKSwgd2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSBsZXZlbCBhbmQgcHVsbCB0aGluZ3Mgb3V0IGlmIG5lY2Vzc2FyeS4gQWxzbyBub3RlIHRoYXQgPHNlbGVjdD4gZWxlbWVudHMgcGFzcyBhbGwgdGhlIGNyaXRlcmlhIHJlZ2FyZGluZyBsZW5ndGggYW5kIHRoZSBmaXJzdCBjaGlsZCBoYXZpbmcgc3R5bGUsIHNvIHdlIG11c3QgYWxzbyBjaGVjayB0byBlbnN1cmUgdGhlIHRhcmdldCBpc24ndCBhbiBIVE1MIG5vZGUgaXRzZWxmLlxuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KF9zbGljZSh0YXJnKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZywgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzW2ldLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdFx0X2FwcGx5T3ZlcndyaXRlKHRhcmcsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0ge307XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGFyZ2V0LCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnZXQsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgfHwgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX2RlbGF5ID09PSAwICYmIHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHRcdHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAodiAmJiB2Lmxlbmd0aCAmJiB2ICE9PSB3aW5kb3cgJiYgdlswXSAmJiAodlswXSA9PT0gd2luZG93IHx8ICh2WzBdLm5vZGVUeXBlICYmIHZbMF0uc3R5bGUgJiYgIXYubm9kZVR5cGUpKSk7IC8vd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBpZiB0aGUgdGFyZ2V0IGlzIHdpbmRvdyBmcm9tIHdpdGhpbiBhbiBpZnJhbWUsIG90aGVyd2lzZSBpdCB3aWxsIHRyaWdnZXIgYSBzZWN1cml0eSBlcnJvciBpbiBzb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cblx0XHRcdH0sXG5cdFx0XHRfYXV0b0NTUyA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0XHR2YXIgY3NzID0ge30sXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdICYmICghKHAgaW4gdGFyZ2V0KSB8fCBwID09PSBcInRyYW5zZm9ybVwiIHx8IHAgPT09IFwieFwiIHx8IHAgPT09IFwieVwiIHx8IHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiIHx8IHAgPT09IFwiY2xhc3NOYW1lXCIgfHwgcCA9PT0gXCJib3JkZXJcIikgJiYgKCFfcGx1Z2luc1twXSB8fCAoX3BsdWdpbnNbcF0gJiYgX3BsdWdpbnNbcF0uX2F1dG9DU1MpKSkgeyAvL25vdGU6IDxpbWc+IGVsZW1lbnRzIGNvbnRhaW4gcmVhZC1vbmx5IFwieFwiIGFuZCBcInlcIiBwcm9wZXJ0aWVzLiBXZSBzaG91bGQgYWxzbyBwcmlvcml0aXplIGVkaXRpbmcgY3NzIHdpZHRoL2hlaWdodCByYXRoZXIgdGhhbiB0aGUgZWxlbWVudCdzIHByb3BlcnRpZXMuXG5cdFx0XHRcdFx0XHRjc3NbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHZhcnNbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMuY3NzID0gY3NzO1xuXHRcdFx0fTtcblxuXHRcdHAgPSBUd2VlbkxpdGUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2VlbkxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cbi8vLS0tLVR3ZWVuTGl0ZSBkZWZhdWx0cywgb3ZlcndyaXRlIG1hbmFnZW1lbnQsIGFuZCByb290IHVwZGF0ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5yYXRpbyA9IDA7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX3RhcmdldHMgPSBwLl9vdmVyd3JpdHRlblByb3BzID0gcC5fc3RhcnRBdCA9IG51bGw7XG5cdFx0cC5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHAuX2xhenkgPSBmYWxzZTtcblxuXHRcdFR3ZWVuTGl0ZS52ZXJzaW9uID0gXCIxLjE2LjFcIjtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdEVhc2UgPSBwLl9lYXNlID0gbmV3IEVhc2UobnVsbCwgbnVsbCwgMSwgMSk7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGUgPSBcImF1dG9cIjtcblx0XHRUd2VlbkxpdGUudGlja2VyID0gX3RpY2tlcjtcblx0XHRUd2VlbkxpdGUuYXV0b1NsZWVwID0gMTIwO1xuXHRcdFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmcgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRfdGlja2VyLmxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeSB8fCBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5O1xuXHRcdFx0aWYgKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gc2VsZWN0b3IoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHR5cGVvZihkb2N1bWVudCkgPT09IFwidW5kZWZpbmVkXCIpID8gZSA6IChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSA6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKChlLmNoYXJBdCgwKSA9PT0gXCIjXCIpID8gZS5zdWJzdHIoMSkgOiBlKSk7XG5cdFx0fTtcblxuXHRcdHZhciBfbGF6eVR3ZWVucyA9IFtdLFxuXHRcdFx0X2xhenlMb29rdXAgPSB7fSxcblx0XHRcdF9pbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyA9IHtpc0FycmF5Ol9pc0FycmF5LCBpc1NlbGVjdG9yOl9pc1NlbGVjdG9yLCBsYXp5VHdlZW5zOl9sYXp5VHdlZW5zfSwgLy9naXZlcyB1cyBhIHdheSB0byBleHBvc2UgY2VydGFpbiBwcml2YXRlIHZhbHVlcyB0byBvdGhlciBHcmVlblNvY2sgY2xhc3NlcyB3aXRob3V0IGNvbnRhbWluYXRpbmcgdGhhIG1haW4gVHdlZW5MaXRlIG9iamVjdC5cblx0XHRcdF9wbHVnaW5zID0gVHdlZW5MaXRlLl9wbHVnaW5zID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXAgPSBfaW50ZXJuYWxzLnR3ZWVuTG9va3VwID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXBOdW0gPSAwLFxuXHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBfaW50ZXJuYWxzLnJlc2VydmVkUHJvcHMgPSB7ZWFzZToxLCBkZWxheToxLCBvdmVyd3JpdGU6MSwgb25Db21wbGV0ZToxLCBvbkNvbXBsZXRlUGFyYW1zOjEsIG9uQ29tcGxldGVTY29wZToxLCB1c2VGcmFtZXM6MSwgcnVuQmFja3dhcmRzOjEsIHN0YXJ0QXQ6MSwgb25VcGRhdGU6MSwgb25VcGRhdGVQYXJhbXM6MSwgb25VcGRhdGVTY29wZToxLCBvblN0YXJ0OjEsIG9uU3RhcnRQYXJhbXM6MSwgb25TdGFydFNjb3BlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOjEsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6MSwgb25SZXBlYXQ6MSwgb25SZXBlYXRQYXJhbXM6MSwgb25SZXBlYXRTY29wZToxLCBlYXNlUGFyYW1zOjEsIHlveW86MSwgaW1tZWRpYXRlUmVuZGVyOjEsIHJlcGVhdDoxLCByZXBlYXREZWxheToxLCBkYXRhOjEsIHBhdXNlZDoxLCByZXZlcnNlZDoxLCBhdXRvQ1NTOjEsIGxhenk6MSwgb25PdmVyd3JpdGU6MX0sXG5cdFx0XHRfb3ZlcndyaXRlTG9va3VwID0ge25vbmU6MCwgYWxsOjEsIGF1dG86MiwgY29uY3VycmVudDozLCBhbGxPblN0YXJ0OjQsIHByZWV4aXN0aW5nOjUsIFwidHJ1ZVwiOjEsIFwiZmFsc2VcIjowfSxcblx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpLFxuXHRcdFx0X3Jvb3RUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfbmV4dEdDRnJhbWUgPSAzMCxcblx0XHRcdF9sYXp5UmVuZGVyID0gX2ludGVybmFscy5sYXp5UmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRcdHR3ZWVuO1xuXHRcdFx0XHRfbGF6eUxvb2t1cCA9IHt9O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0d2VlbiA9IF9sYXp5VHdlZW5zW2ldO1xuXHRcdFx0XHRcdGlmICh0d2VlbiAmJiB0d2Vlbi5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcih0d2Vlbi5fbGF6eVswXSwgdHdlZW4uX2xhenlbMV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0dHdlZW4uX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X2xhenlUd2VlbnMubGVuZ3RoID0gMDtcblx0XHRcdH07XG5cblx0XHRfcm9vdFRpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLnRpbWU7XG5cdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lID0gX3RpY2tlci5mcmFtZTtcblx0XHRfcm9vdFRpbWVsaW5lLl9hY3RpdmUgPSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9hY3RpdmUgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoX2xhenlSZW5kZXIsIDEpOyAvL29uIHNvbWUgbW9iaWxlIGRldmljZXMsIHRoZXJlIGlzbid0IGEgXCJ0aWNrXCIgYmVmb3JlIGNvZGUgcnVucyB3aGljaCBtZWFucyBhbnkgbGF6eSByZW5kZXJzIHdvdWxkbid0IHJ1biBiZWZvcmUgdGhlIG5leHQgb2ZmaWNpYWwgXCJ0aWNrXCIuXG5cblx0XHRBbmltYXRpb24uX3VwZGF0ZVJvb3QgPSBUd2VlbkxpdGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhLCBwO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaWYgY29kZSBpcyBydW4gb3V0c2lkZSBvZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AsIHRoZXJlIG1heSBiZSB0d2VlbnMgcXVldWVkIEFGVEVSIHRoZSBlbmdpbmUgcmVmcmVzaGVkLCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBhbnkgcGVuZGluZyByZW5kZXJzIG9jY3VyIGJlZm9yZSB3ZSByZWZyZXNoIGFnYWluLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jvb3RUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIudGltZSAtIF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSkgKiBfcm9vdFRpbWVsaW5lLl90aW1lU2NhbGUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUucmVuZGVyKChfdGlja2VyLmZyYW1lIC0gX3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290RnJhbWVzVGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7IC8vZHVtcCBnYXJiYWdlIGV2ZXJ5IDEyMCBmcmFtZXMgb3Igd2hhdGV2ZXIgdGhlIHVzZXIgc2V0cyBUd2VlbkxpdGUuYXV0b1NsZWVwIHRvXG5cdFx0XHRcdFx0X25leHRHQ0ZyYW1lID0gX3RpY2tlci5mcmFtZSArIChwYXJzZUludChUd2VlbkxpdGUuYXV0b1NsZWVwLCAxMCkgfHwgMTIwKTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gX3R3ZWVuTG9va3VwKSB7XG5cdFx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW3BdLnR3ZWVucztcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGEubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBfdHdlZW5Mb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaWYgdGhlcmUgYXJlIG5vIG1vcmUgdHdlZW5zIGluIHRoZSByb290IHRpbWVsaW5lcywgb3IgaWYgdGhleSdyZSBhbGwgcGF1c2VkLCBtYWtlIHRoZSBfdGltZXIgc2xlZXAgdG8gcmVkdWNlIGxvYWQgb24gdGhlIENQVSBzbGlnaHRseVxuXHRcdFx0XHRcdHAgPSBfcm9vdFRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0XHRpZiAoIXAgfHwgcC5fcGF1c2VkKSBpZiAoVHdlZW5MaXRlLmF1dG9TbGVlcCAmJiAhX3Jvb3RGcmFtZXNUaW1lbGluZS5fZmlyc3QgJiYgX3RpY2tlci5fbGlzdGVuZXJzLnRpY2subGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAocCAmJiBwLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHAuX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXApIHtcblx0XHRcdFx0XHRcdFx0X3RpY2tlci5zbGVlcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdF90aWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgQW5pbWF0aW9uLl91cGRhdGVSb290KTtcblxuXHRcdHZhciBfcmVnaXN0ZXIgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBzY3J1Yikge1xuXHRcdFx0XHR2YXIgaWQgPSB0YXJnZXQuX2dzVHdlZW5JRCwgYSwgaTtcblx0XHRcdFx0aWYgKCFfdHdlZW5Mb29rdXBbaWQgfHwgKHRhcmdldC5fZ3NUd2VlbklEID0gaWQgPSBcInRcIiArIChfdHdlZW5Mb29rdXBOdW0rKykpXSkge1xuXHRcdFx0XHRcdF90d2Vlbkxvb2t1cFtpZF0gPSB7dGFyZ2V0OnRhcmdldCwgdHdlZW5zOltdfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4pIHtcblx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHRcdFx0YVsoaSA9IGEubGVuZ3RoKV0gPSB0d2Vlbjtcblx0XHRcdFx0XHRpZiAoc2NydWIpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25PdmVyd3JpdGUgPSBmdW5jdGlvbihvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKSB7XG5cdFx0XHRcdHZhciBmdW5jID0gb3ZlcndyaXR0ZW5Ud2Vlbi52YXJzLm9uT3ZlcndyaXRlLCByMSwgcjI7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjEgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmMgPSBUd2VlbkxpdGUub25PdmVyd3JpdGU7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjIgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAocjEgIT09IGZhbHNlICYmIHIyICE9PSBmYWxzZSk7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5T3ZlcndyaXRlID0gZnVuY3Rpb24odGFyZ2V0LCB0d2VlbiwgcHJvcHMsIG1vZGUsIHNpYmxpbmdzKSB7XG5cdFx0XHRcdHZhciBpLCBjaGFuZ2VkLCBjdXJUd2VlbiwgbDtcblx0XHRcdFx0aWYgKG1vZGUgPT09IDEgfHwgbW9kZSA+PSA0KSB7XG5cdFx0XHRcdFx0bCA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGN1clR3ZWVuID0gc2libGluZ3NbaV0pICE9PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWN1clR3ZWVuLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChfb25PdmVyd3JpdGUoY3VyVHdlZW4sIHR3ZWVuKSAmJiBjdXJUd2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobW9kZSA9PT0gNSkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9OT1RFOiBBZGQgMC4wMDAwMDAwMDAxIHRvIG92ZXJjb21lIGZsb2F0aW5nIHBvaW50IGVycm9ycyB0aGF0IGNhbiBjYXVzZSB0aGUgc3RhcnRUaW1lIHRvIGJlIFZFUlkgc2xpZ2h0bHkgb2ZmICh3aGVuIGEgdHdlZW4ncyB0aW1lKCkgaXMgc2V0IGZvciBleGFtcGxlKVxuXHRcdFx0XHR2YXIgc3RhcnRUaW1lID0gdHdlZW4uX3N0YXJ0VGltZSArIF90aW55TnVtLFxuXHRcdFx0XHRcdG92ZXJsYXBzID0gW10sXG5cdFx0XHRcdFx0b0NvdW50ID0gMCxcblx0XHRcdFx0XHR6ZXJvRHVyID0gKHR3ZWVuLl9kdXJhdGlvbiA9PT0gMCksXG5cdFx0XHRcdFx0Z2xvYmFsU3RhcnQ7XG5cdFx0XHRcdGkgPSBzaWJsaW5ncy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICgoY3VyVHdlZW4gPSBzaWJsaW5nc1tpXSkgPT09IHR3ZWVuIHx8IGN1clR3ZWVuLl9nYyB8fCBjdXJUd2Vlbi5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHQvL2lnbm9yZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VyVHdlZW4uX3RpbWVsaW5lICE9PSB0d2Vlbi5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdGdsb2JhbFN0YXJ0ID0gZ2xvYmFsU3RhcnQgfHwgX2NoZWNrT3ZlcmxhcCh0d2VlbiwgMCwgemVyb0R1cik7XG5cdFx0XHRcdFx0XHRpZiAoX2NoZWNrT3ZlcmxhcChjdXJUd2VlbiwgZ2xvYmFsU3RhcnQsIHplcm9EdXIpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJsYXBzW29Db3VudCsrXSA9IGN1clR3ZWVuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VyVHdlZW4uX3N0YXJ0VGltZSA8PSBzdGFydFRpbWUpIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lICsgY3VyVHdlZW4udG90YWxEdXJhdGlvbigpIC8gY3VyVHdlZW4uX3RpbWVTY2FsZSA+IHN0YXJ0VGltZSkgaWYgKCEoKHplcm9EdXIgfHwgIWN1clR3ZWVuLl9pbml0dGVkKSAmJiBzdGFydFRpbWUgLSBjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IDAuMDAwMDAwMDAwMikpIHtcblx0XHRcdFx0XHRcdG92ZXJsYXBzW29Db3VudCsrXSA9IGN1clR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgPSBvQ291bnQ7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGN1clR3ZWVuID0gb3ZlcmxhcHNbaV07XG5cdFx0XHRcdFx0aWYgKG1vZGUgPT09IDIpIGlmIChjdXJUd2Vlbi5fa2lsbChwcm9wcywgdGFyZ2V0LCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobW9kZSAhPT0gMiB8fCAoIWN1clR3ZWVuLl9maXJzdFBUICYmIGN1clR3ZWVuLl9pbml0dGVkKSkge1xuXHRcdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgJiYgIV9vbk92ZXJ3cml0ZShjdXJUd2VlbiwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1clR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSkpIHsgLy9pZiBhbGwgcHJvcGVydHkgdHdlZW5zIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiwga2lsbCB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdH0sXG5cblx0XHRcdF9jaGVja092ZXJsYXAgPSBmdW5jdGlvbih0d2VlbiwgcmVmZXJlbmNlLCB6ZXJvRHVyKSB7XG5cdFx0XHRcdHZhciB0bCA9IHR3ZWVuLl90aW1lbGluZSxcblx0XHRcdFx0XHR0cyA9IHRsLl90aW1lU2NhbGUsXG5cdFx0XHRcdFx0dCA9IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0ICs9IHRsLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0dHMgKj0gdGwuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRpZiAodGwuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIC0xMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHQgLz0gdHM7XG5cdFx0XHRcdHJldHVybiAodCA+IHJlZmVyZW5jZSkgPyB0IC0gcmVmZXJlbmNlIDogKCh6ZXJvRHVyICYmIHQgPT09IHJlZmVyZW5jZSkgfHwgKCF0d2Vlbi5faW5pdHRlZCAmJiB0IC0gcmVmZXJlbmNlIDwgMiAqIF90aW55TnVtKSkgPyBfdGlueU51bSA6ICgodCArPSB0d2Vlbi50b3RhbER1cmF0aW9uKCkgLyB0d2Vlbi5fdGltZVNjYWxlIC8gdHMpID4gcmVmZXJlbmNlICsgX3RpbnlOdW0pID8gMCA6IHQgLSByZWZlcmVuY2UgLSBfdGlueU51bTtcblx0XHRcdH07XG5cblxuLy8tLS0tIFR3ZWVuTGl0ZSBpbnN0YW5jZSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0b3AgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzLFxuXHRcdFx0XHRkdXIgPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0aW1tZWRpYXRlID0gISF2LmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0ZWFzZSA9IHYuZWFzZSxcblx0XHRcdFx0aSwgaW5pdFBsdWdpbnMsIHB0LCBwLCBzdGFydFZhcnM7XG5cdFx0XHRpZiAodi5zdGFydEF0KSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvL2lmIHdlJ3ZlIHJ1biBhIHN0YXJ0QXQgcHJldmlvdXNseSAod2hlbiB0aGUgdHdlZW4gaW5zdGFudGlhdGVkKSwgd2Ugc2hvdWxkIHJldmVydCBpdCBzbyB0aGF0IHRoZSB2YWx1ZXMgcmUtaW5zdGFudGlhdGUgY29ycmVjdGx5IHBhcnRpY3VsYXJseSBmb3IgcmVsYXRpdmUgdHdlZW5zLiBXaXRob3V0IHRoaXMsIGEgVHdlZW5MaXRlLmZyb21UbyhvYmosIDEsIHt4OlwiKz0xMDBcIn0sIHt4OlwiLT0xMDBcIn0pLCBmb3IgZXhhbXBsZSwgd291bGQgYWN0dWFsbHkganVtcCB0byArPTIwMCBiZWNhdXNlIHRoZSBzdGFydEF0IHdvdWxkIHJ1biB0d2ljZSwgZG91YmxpbmcgdGhlIHJlbGF0aXZlIGNoYW5nZS5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFZhcnMgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIHYuc3RhcnRBdCkgeyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgMSwgZnJvbSwgdG8pLmZyb21UbyhlLCAxLCB0bywgZnJvbSk7XG5cdFx0XHRcdFx0c3RhcnRWYXJzW3BdID0gdi5zdGFydEF0W3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycy5vdmVyd3JpdGUgPSBmYWxzZTtcblx0XHRcdFx0c3RhcnRWYXJzLmltbWVkaWF0ZVJlbmRlciA9IHRydWU7XG5cdFx0XHRcdHN0YXJ0VmFycy5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0c3RhcnRWYXJzLnN0YXJ0QXQgPSBzdGFydFZhcnMuZGVsYXkgPSBudWxsOyAvL25vIG5lc3Rpbmcgb2Ygc3RhcnRBdCBvYmplY3RzIGFsbG93ZWQgKG90aGVyd2lzZSBpdCBjb3VsZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wKS5cblx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgc3RhcnRWYXJzKTtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lTGl0ZS9NYXggaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2UgKHdoaWNoIGlzIHRoZSBkZWZhdWx0IGluIHRoZSBjb252ZW5pZW5jZSBtZXRob2RzIGxpa2UgZnJvbSgpKS5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGR1ciAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lTGl0ZSBvciBUaW1lbGluZU1heCwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodi5ydW5CYWNrd2FyZHMgJiYgZHVyICE9PSAwKSB7XG5cdFx0XHRcdC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgIT09IDApIHsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblx0XHRcdFx0XHRcdGltbWVkaWF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiB2KSB7IC8vY29weSBwcm9wcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgc2tpcCBhbnkgcmVzZXJ2ZWQgcHJvcHMsIG90aGVyd2lzZSBvbkNvbXBsZXRlIG9yIG9uVXBkYXRlIG9yIG9uU3RhcnQgY291bGQgZmlyZS4gV2Ugc2hvdWxkLCBob3dldmVyLCBwZXJtaXQgYXV0b0NTUyB0byBnbyB0aHJvdWdoLlxuXHRcdFx0XHRcdFx0aWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSB8fCBwID09PSBcImF1dG9DU1NcIikge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHZbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0Lm92ZXJ3cml0ZSA9IDA7XG5cdFx0XHRcdFx0cHQuZGF0YSA9IFwiaXNGcm9tU3RhcnRcIjsgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG5cdFx0XHRcdFx0cHQubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdFx0cHQuaW1tZWRpYXRlUmVuZGVyID0gaW1tZWRpYXRlOyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgcHQpO1xuXHRcdFx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0Ll9pbml0KCk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoZmFsc2UpOyAvL25vIG5lZWQgdG8gaGF2ZSB0aGUgdHdlZW4gcmVuZGVyIG9uIHRoZSBuZXh0IGN5Y2xlLiBEaXNhYmxlIGl0IGJlY2F1c2Ugd2UnbGwgYWx3YXlzIG1hbnVhbGx5IGNvbnRyb2wgdGhlIHJlbmRlcnMgb2YgdGhlIF9zdGFydEF0IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlID0gZWFzZSA9ICghZWFzZSkgPyBUd2VlbkxpdGUuZGVmYXVsdEVhc2UgOiAoZWFzZSBpbnN0YW5jZW9mIEVhc2UpID8gZWFzZSA6ICh0eXBlb2YoZWFzZSkgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgRWFzZShlYXNlLCB2LmVhc2VQYXJhbXMpIDogX2Vhc2VNYXBbZWFzZV0gfHwgVHdlZW5MaXRlLmRlZmF1bHRFYXNlO1xuXHRcdFx0aWYgKHYuZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5ICYmIGVhc2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlLmNvbmZpZy5hcHBseShlYXNlLCB2LmVhc2VQYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWFzZVR5cGUgPSB0aGlzLl9lYXNlLl90eXBlO1xuXHRcdFx0dGhpcy5fZWFzZVBvd2VyID0gdGhpcy5fZWFzZS5fcG93ZXI7XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gbnVsbDtcblxuXHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0aSA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMuX2luaXRQcm9wcyggdGhpcy5fdGFyZ2V0c1tpXSwgKHRoaXMuX3Byb3BMb29rdXBbaV0gPSB7fSksIHRoaXMuX3NpYmxpbmdzW2ldLCAob3AgPyBvcFtpXSA6IG51bGwpKSApIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluaXRQbHVnaW5zID0gdGhpcy5faW5pdFByb3BzKHRoaXMudGFyZ2V0LCB0aGlzLl9wcm9wTG9va3VwLCB0aGlzLl9zaWJsaW5ncywgb3ApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW5pdFBsdWdpbnMpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uSW5pdEFsbFByb3BzXCIsIHRoaXMpOyAvL3Jlb3JkZXJzIHRoZSBhcnJheSBpbiBvcmRlciBvZiBwcmlvcml0eS4gVXNlcyBhIHN0YXRpYyBUd2VlblBsdWdpbiBtZXRob2QgaW4gb3JkZXIgdG8gbWluaW1pemUgZmlsZSBzaXplIGluIFR3ZWVuTGl0ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9wKSBpZiAoIXRoaXMuX2ZpcnN0UFQpIGlmICh0eXBlb2YodGhpcy50YXJnZXQpICE9PSBcImZ1bmN0aW9uXCIpIHsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4sIGtpbGwgdGhlIHR3ZWVuLiBJZiB0aGUgdGFyZ2V0IGlzIGEgZnVuY3Rpb24sIGl0J3MgcHJvYmFibHkgYSBkZWxheWVkQ2FsbCBzbyBsZXQgaXQgbGl2ZS5cblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHYucnVuQmFja3dhcmRzKSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0cHQucyArPSBwdC5jO1xuXHRcdFx0XHRcdHB0LmMgPSAtcHQuYztcblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHYub25VcGRhdGU7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0cC5faW5pdFByb3BzID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcykge1xuXHRcdFx0dmFyIHAsIGksIGluaXRQbHVnaW5zLCBwbHVnaW4sIHB0LCB2O1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9sYXp5TG9va3VwW3RhcmdldC5fZ3NUd2VlbklEXSkge1xuXHRcdFx0XHRfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMudmFycy5jc3MpIGlmICh0YXJnZXQuc3R5bGUpIGlmICh0YXJnZXQgIT09IHdpbmRvdyAmJiB0YXJnZXQubm9kZVR5cGUpIGlmIChfcGx1Z2lucy5jc3MpIGlmICh0aGlzLnZhcnMuYXV0b0NTUyAhPT0gZmFsc2UpIHsgLy9pdCdzIHNvIGNvbW1vbiB0byB1c2UgVHdlZW5MaXRlL01heCB0byBhbmltYXRlIHRoZSBjc3Mgb2YgRE9NIGVsZW1lbnRzLCB3ZSBhc3N1bWUgdGhhdCBpZiB0aGUgdGFyZ2V0IGlzIGEgRE9NIGVsZW1lbnQsIHRoYXQncyB3aGF0IGlzIGludGVuZGVkIChhIGNvbnZlbmllbmNlIHNvIHRoYXQgdXNlcnMgZG9uJ3QgaGF2ZSB0byB3cmFwIHRoaW5ncyBpbiBjc3M6e30sIGFsdGhvdWdoIHdlIHN0aWxsIHJlY29tbWVuZCBpdCBmb3IgYSBzbGlnaHQgcGVyZm9ybWFuY2UgYm9vc3QgYW5kIGJldHRlciBzcGVjaWZpY2l0eSkuIE5vdGU6IHdlIGNhbm5vdCBjaGVjayBcIm5vZGVUeXBlXCIgb24gdGhlIHdpbmRvdyBpbnNpZGUgYW4gaWZyYW1lLlxuXHRcdFx0XHRfYXV0b0NTUyh0aGlzLnZhcnMsIHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy52YXJzKSB7XG5cdFx0XHRcdHYgPSB0aGlzLnZhcnNbcF07XG5cdFx0XHRcdGlmIChfcmVzZXJ2ZWRQcm9wc1twXSkge1xuXHRcdFx0XHRcdGlmICh2KSBpZiAoKHYgaW5zdGFuY2VvZiBBcnJheSkgfHwgKHYucHVzaCAmJiBfaXNBcnJheSh2KSkpIGlmICh2LmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMudmFyc1twXSA9IHYgPSB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHYsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKF9wbHVnaW5zW3BdICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcF0oKSkuX29uSW5pdFR3ZWVuKHRhcmdldCwgdGhpcy52YXJzW3BdLCB0aGlzKSkge1xuXG5cdFx0XHRcdFx0Ly90IC0gdGFyZ2V0IFx0XHRbb2JqZWN0XVxuXHRcdFx0XHRcdC8vcCAtIHByb3BlcnR5IFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcyAtIHN0YXJ0XHRcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2MgLSBjaGFuZ2VcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2YgLSBpc0Z1bmN0aW9uXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL24gLSBuYW1lXHRcdFx0W3N0cmluZ11cblx0XHRcdFx0XHQvL3BnIC0gaXNQbHVnaW4gXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL3ByIC0gcHJpb3JpdHlcdFx0W251bWJlcl1cblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDpwbHVnaW4sIHA6XCJzZXRSYXRpb1wiLCBzOjAsIGM6MSwgZjp0cnVlLCBuOnAsIHBnOnRydWUsIHByOnBsdWdpbi5fcHJpb3JpdHl9O1xuXHRcdFx0XHRcdGkgPSBwbHVnaW4uX292ZXJ3cml0ZVByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHByb3BMb29rdXBbcGx1Z2luLl9vdmVyd3JpdGVQcm9wc1tpXV0gPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGx1Z2luLl9wcmlvcml0eSB8fCBwbHVnaW4uX29uSW5pdEFsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX29uRGlzYWJsZSB8fCBwbHVnaW4uX29uRW5hYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHJvcExvb2t1cFtwXSA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6dGFyZ2V0LCBwOnAsIGY6KHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpLCBuOnAsIHBnOmZhbHNlLCBwcjowfTtcblx0XHRcdFx0XHRwdC5zID0gKCFwdC5mKSA/IHBhcnNlRmxvYXQodGFyZ2V0W3BdKSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKTtcblx0XHRcdFx0XHRwdC5jID0gKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKHYuc3Vic3RyKDIpKSA6IChOdW1iZXIodikgLSBwdC5zKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdCkgaWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3ZlcndyaXR0ZW5Qcm9wcykgaWYgKHRoaXMuX2tpbGwob3ZlcndyaXR0ZW5Qcm9wcywgdGFyZ2V0KSkgeyAvL2Fub3RoZXIgdHdlZW4gbWF5IGhhdmUgdHJpZWQgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgb2YgdGhpcyB0d2VlbiBiZWZvcmUgaW5pdCgpIHdhcyBjYWxsZWQgKGxpa2UgaWYgdHdvIHR3ZWVucyBzdGFydCBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgb25lIGNyZWF0ZWQgc2Vjb25kIHdpbGwgcnVuIGZpcnN0KVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX292ZXJ3cml0ZSA+IDEpIGlmICh0aGlzLl9maXJzdFBUKSBpZiAoc2libGluZ3MubGVuZ3RoID4gMSkgaWYgKF9hcHBseU92ZXJ3cml0ZSh0YXJnZXQsIHRoaXMsIHByb3BMb29rdXAsIHRoaXMuX292ZXJ3cml0ZSwgc2libGluZ3MpKSB7XG5cdFx0XHRcdHRoaXMuX2tpbGwocHJvcExvb2t1cCwgdGFyZ2V0KTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9wcyh0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9maXJzdFBUKSBpZiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpIHsgLy96ZXJvIGR1cmF0aW9uIHR3ZWVucyBkb24ndCBsYXp5IHJlbmRlciBieSBkZWZhdWx0OyBldmVyeXRoaW5nIGVsc2UgZG9lcy5cblx0XHRcdFx0X2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbml0UGx1Z2lucztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRpc0NvbXBsZXRlLCBjYWxsYmFjaywgcHQsIHJhd1ByZXZUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkICkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAoZm9yY2UgfHwgdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKTsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhcnRUaW1lID09PSB0aGlzLl90aW1lbGluZS5fZHVyYXRpb24pIHsgLy9pZiBhIHplcm8tZHVyYXRpb24gdHdlZW4gaXMgYXQgdGhlIFZFUlkgZW5kIG9mIGEgdGltZWxpbmUgYW5kIHRoYXQgdGltZWxpbmUgcmVuZGVycyBhdCBpdHMgZW5kLCBpdCB3aWxsIHR5cGljYWxseSBhZGQgYSB0aW55IGJpdCBvZiBjdXNoaW9uIHRvIHRoZSByZW5kZXIgdGltZSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGdldHRpbmcgaW4gdGhlIHdheSBvZiB0d2VlbnMgcmVuZGVyaW5nIHRoZWlyIFZFUlkgZW5kLiBJZiB3ZSB0aGVuIHJldmVyc2UoKSB0aGF0IHRpbWVsaW5lLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiB3aWxsIHRyaWdnZXIgaXRzIG9uUmV2ZXJzZUNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5IHRoZSBwbGF5aGVhZCBkaWRuJ3QgcGFzcyBvdmVyIGl0IGFnYWluLiBJdCdzIGEgdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2Ugd2UgbXVzdCBhY2NvbW1vZGF0ZS5cblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCB8fCBwcmV2UmF3UHJldlRpbWUgPCAwIHx8IChwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSAhPT0gXCJpc1BhdXNlXCIpKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lKSB7IC8vbm90ZTogd2hlbiB0aGlzLmRhdGEgaXMgXCJpc1BhdXNlXCIsIGl0J3MgYSBjYWxsYmFjayBhZGRlZCBieSBhZGRQYXVzZSgpIG9uIGEgdGltZWxpbmUgdGhhdCB3ZSBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCB3aGVuIExFQVZJTkcgaXRzIGV4YWN0IHN0YXJ0IHRpbWUuIEluIG90aGVyIHdvcmRzLCB0bC5hZGRQYXVzZSgxKS5wbGF5KDEpIHNob3VsZG4ndCBwYXVzZS5cblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8IChkdXJhdGlvbiA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPiAwKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+PSAwICYmICEocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgPT09IFwiaXNQYXVzZVwiKSkge1xuXHRcdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSkge1xuXHRcdFx0XHRcdHZhciByID0gdGltZSAvIGR1cmF0aW9uLCB0eXBlID0gdGhpcy5fZWFzZVR5cGUsIHBvdyA9IHRoaXMuX2Vhc2VQb3dlcjtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSB8fCAodHlwZSA9PT0gMyAmJiByID49IDAuNSkpIHtcblx0XHRcdFx0XHRcdHIgPSAxIC0gcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvdyA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ciAqPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAyKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gNCkge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRpbWUgLyBkdXJhdGlvbiA8IDAuNSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHIgLyAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIChyIC8gMik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fZ2MpIHsgLy9pbW1lZGlhdGVSZW5kZXIgdHdlZW5zIHR5cGljYWxseSB3b24ndCBpbml0aWFsaXplIHVudGlsIHRoZSBwbGF5aGVhZCBhZHZhbmNlcyAoX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDApIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IG92ZXJ3cml0aW5nIG9jY3VycyBwcm9wZXJseS4gQWxzbywgaWYgYWxsIG9mIHRoZSB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiAod2hpY2ggd291bGQgY2F1c2UgX2djIHRvIGJlIHRydWUsIGFzIHNldCBpbiBfaW5pdCgpKSwgd2Ugc2hvdWxkbid0IGNvbnRpbnVlIG90aGVyd2lzZSBhbiBvblN0YXJ0IGNhbGxiYWNrIGNvdWxkIGJlIGNhbGxlZCBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWZvcmNlICYmIHRoaXMuX2ZpcnN0UFQgJiYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSBwcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0XHRfbGF6eVR3ZWVucy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMuX2xhenkgPSBbdGltZSwgc3VwcHJlc3NFdmVudHNdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL19lYXNlIGlzIGluaXRpYWxseSBzZXQgdG8gZGVmYXVsdEVhc2UsIHNvIG5vdyB0aGF0IGluaXQoKSBoYXMgcnVuLCBfZWFzZSBpcyBzZXQgcHJvcGVybHkgYW5kIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHJhdGlvLiBPdmVyYWxsIHRoaXMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY29uZGl0aW9uYWwgbG9naWMgZWFybGllciBpbiB0aGUgbWV0aG9kIHRvIGF2b2lkIGhhdmluZyB0byBzZXQgcmF0aW8gdHdpY2UgYmVjYXVzZSB3ZSBvbmx5IGluaXQoKSBvbmNlIGJ1dCByZW5kZXJUaW1lKCkgZ2V0cyBjYWxsZWQgVkVSWSBmcmVxdWVudGx5LlxuXHRcdFx0XHRpZiAodGhpcy5fdGltZSAmJiAhaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNDb21wbGV0ZSAmJiB0aGlzLl9lYXNlLl9jYWxjRW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oKHRoaXMuX3RpbWUgPT09IDApID8gMCA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fbGF6eSAhPT0gZmFsc2UpIHsgLy9pbiBjYXNlIGEgbGF6eSByZW5kZXIgaXMgcGVuZGluZywgd2Ugc2hvdWxkIGZsdXNoIGl0IGJlY2F1c2UgdGhlIG5ldyByZW5kZXIgaXMgb2NjdXJyaW5nIG5vdyAoaW1hZ2luZSBhIGxhenkgdHdlZW4gaW5zdGFudGlhdGluZyBhbmQgdGhlbiBpbW1lZGlhdGVseSB0aGUgdXNlciBjYWxscyB0d2Vlbi5zZWVrKHR3ZWVuLmR1cmF0aW9uKCkpLCBza2lwcGluZyB0byB0aGUgZW5kIC0gdGhlIGVuZCByZW5kZXIgd291bGQgYmUgZm9yY2VkLCBhbmQgdGhlbiBpZiB3ZSBkaWRuJ3QgZmx1c2ggdGhlIGxhenkgcmVuZGVyLCBpdCdkIGZpcmUgQUZURVIgdGhlIHNlZWsoKSwgcmVuZGVyaW5nIGl0IGF0IHRoZSB3cm9uZyB0aW1lLlxuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBhIHR3ZWVuIChhcyBvcHBvc2VkIHRvIHRoZSB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCB0aGUgdGltZWxpbmUgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdHdlZW4gYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUuXG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRpbWUgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwiX2R1bW15R1NcIjsgLy9pZiBubyBjYWxsYmFjayBpcyBkZWZpbmVkLCB1c2UgYSBkdW1teSB2YWx1ZSBqdXN0IHNvIHRoYXQgdGhlIGNvbmRpdGlvbiBhdCB0aGUgZW5kIGV2YWx1YXRlcyBhcyB0cnVlIGJlY2F1c2UgX3N0YXJ0QXQgc2hvdWxkIHJlbmRlciBBRlRFUiB0aGUgbm9ybWFsIHJlbmRlciBsb29wIHdoZW4gdGhlIHRpbWUgaXMgbmVnYXRpdmUuIFdlIGNvdWxkIGhhbmRsZSB0aGlzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LCBvZiBjb3Vyc2UsIGJ1dCB0aGUgcmVuZGVyIGxvb3AgaXMgdGhlIE1PU1QgaW1wb3J0YW50IHRoaW5nIHRvIG9wdGltaXplLCBzbyB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgdXMgdG8gYXZvaWQgYWRkaW5nIGV4dHJhIGNvbmRpdGlvbmFsIGxvZ2ljIGluIGEgaGlnaC1mcmVxdWVuY3kgYXJlYS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCB8fCBkdXJhdGlvbiA9PT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdHRoaXMudmFycy5vblN0YXJ0LmFwcGx5KHRoaXMudmFycy5vblN0YXJ0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKHRoaXMuX3RpbWUgIT09IHByZXZUaW1lIHx8IGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MgfHwgZm9yY2UpIHsgLy9jaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGltZSAhPT0gLTAuMDAwMSkgeyAvLy0wLjAwMDEgaXMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgd2UgdXNlIHdoZW4gbG9vcGluZyBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSByZXBlYXRlZCBUaW1lbGluZU1heCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRuJ3QgcmVuZGVyIHRoZSBfc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzW2NhbGxiYWNrXS5hcHBseSh0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlNjb3BlXCJdIHx8IHRoaXMsIHRoaXMudmFyc1tjYWxsYmFjayArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHJhd1ByZXZUaW1lICE9PSBfdGlueU51bSkgeyAvL3RoZSBvbkNvbXBsZXRlIG9yIG9uUmV2ZXJzZUNvbXBsZXRlIGNvdWxkIHRyaWdnZXIgbW92ZW1lbnQgb2YgdGhlIHBsYXloZWFkIGFuZCBmb3IgemVyby1kdXJhdGlvbiB0d2VlbnMgKHdoaWNoIG11c3QgZGlzY2VybiBkaXJlY3Rpb24pIHRoYXQgbGFuZCBkaXJlY3RseSBiYWNrIG9uIHRoZWlyIHN0YXJ0IHRpbWUsIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBhZ2FpbiBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaW5rIG9mIHNldmVyYWwgYWRkUGF1c2UoKSdzIGluIGEgdGltZWxpbmUgdGhhdCBmb3JjZXMgdGhlIHBsYXloZWFkIHRvIGEgY2VydGFpbiBzcG90LCBidXQgd2hhdCBpZiBpdCdzIGFscmVhZHkgcGF1c2VkIGFuZCBhbm90aGVyIHR3ZWVuIGlzIHR3ZWVuaW5nIHRoZSBcInRpbWVcIiBvZiB0aGUgdGltZWxpbmU/IEVhY2ggdGltZSBpdCBtb3ZlcyBbZm9yd2FyZF0gcGFzdCB0aGF0IHNwb3QsIGl0IHdvdWxkIG1vdmUgYmFjaywgYW5kIHNpbmNlIHN1cHByZXNzRXZlbnRzIGlzIHRydWUsIGl0J2QgcmVzZXQgX3Jhd1ByZXZUaW1lIHRvIF90aW55TnVtIHNvIHRoYXQgd2hlbiBpdCBiZWdpbnMgYWdhaW4sIHRoZSBjYWxsYmFjayB3b3VsZCBmaXJlIChzbyB1bHRpbWF0ZWx5IGl0IGNvdWxkIGJvdW5jZSBiYWNrIGFuZCBmb3J0aCBkdXJpbmcgdGhhdCB0d2VlbikuIEFnYWluLCB0aGlzIGlzIGEgdmVyeSB1bmNvbW1vbiBzY2VuYXJpbywgYnV0IHBvc3NpYmxlIG5vbmV0aGVsZXNzLlxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0LCBvdmVyd3JpdGluZ1R3ZWVuKSB7XG5cdFx0XHRpZiAodmFycyA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHR2YXJzID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICh2YXJzID09IG51bGwpIGlmICh0YXJnZXQgPT0gbnVsbCB8fCB0YXJnZXQgPT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyAodGFyZ2V0IHx8IHRoaXMuX3RhcmdldHMgfHwgdGhpcy50YXJnZXQpIDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIGksIG92ZXJ3cml0dGVuUHJvcHMsIHAsIHB0LCBwcm9wTG9va3VwLCBjaGFuZ2VkLCBraWxsUHJvcHMsIHJlY29yZCwga2lsbGVkO1xuXHRcdFx0aWYgKChfaXNBcnJheSh0YXJnZXQpIHx8IF9pc1NlbGVjdG9yKHRhcmdldCkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fa2lsbCh2YXJzLCB0YXJnZXRbaV0pKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl90YXJnZXRzKSB7XG5cdFx0XHRcdFx0aSA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gdGhpcy5fdGFyZ2V0c1tpXSkge1xuXHRcdFx0XHRcdFx0XHRwcm9wTG9va3VwID0gdGhpcy5fcHJvcExvb2t1cFtpXSB8fCB7fTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwgW107XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzW2ldID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLnRhcmdldCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwcm9wTG9va3VwID0gdGhpcy5fcHJvcExvb2t1cDtcblx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHZhcnMgPyB0aGlzLl9vdmVyd3JpdHRlblByb3BzIHx8IHt9IDogXCJhbGxcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcm9wTG9va3VwKSB7XG5cdFx0XHRcdFx0a2lsbFByb3BzID0gdmFycyB8fCBwcm9wTG9va3VwO1xuXHRcdFx0XHRcdHJlY29yZCA9ICh2YXJzICE9PSBvdmVyd3JpdHRlblByb3BzICYmIG92ZXJ3cml0dGVuUHJvcHMgIT09IFwiYWxsXCIgJiYgdmFycyAhPT0gcHJvcExvb2t1cCAmJiAodHlwZW9mKHZhcnMpICE9PSBcIm9iamVjdFwiIHx8ICF2YXJzLl90ZW1wS2lsbCkpOyAvL190ZW1wS2lsbCBpcyBhIHN1cGVyLXNlY3JldCB3YXkgdG8gZGVsZXRlIGEgcGFydGljdWxhciB0d2VlbmluZyBwcm9wZXJ0eSBidXQgTk9UIGhhdmUgaXQgcmVtZW1iZXJlZCBhcyBhbiBvZmZpY2lhbCBvdmVyd3JpdHRlbiBwcm9wZXJ0eSAobGlrZSBpbiBCZXppZXJQbHVnaW4pXG5cdFx0XHRcdFx0aWYgKG92ZXJ3cml0aW5nVHdlZW4gJiYgKFR3ZWVuTGl0ZS5vbk92ZXJ3cml0ZSB8fCB0aGlzLnZhcnMub25PdmVyd3JpdGUpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4ga2lsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wTG9va3VwW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFraWxsZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGtpbGxlZCA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRraWxsZWQucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCFfb25PdmVyd3JpdGUodGhpcywgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWQpKSB7IC8vaWYgdGhlIG9uT3ZlcndyaXRlIHJldHVybmVkIGZhbHNlLCB0aGF0IG1lYW5zIHRoZSB1c2VyIHdhbnRzIHRvIG92ZXJyaWRlIHRoZSBvdmVyd3JpdGluZyAoY2FuY2VsIGl0KS5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdGlmICgocHQgPSBwcm9wTG9va3VwW3BdKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocHQucGcgJiYgcHQudC5fa2lsbChraWxsUHJvcHMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7IC8vc29tZSBwbHVnaW5zIG5lZWQgdG8gYmUgbm90aWZpZWQgc28gdGhleSBjYW4gcGVyZm9ybSBjbGVhbnVwIHRhc2tzIGZpcnN0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFwdC5wZyB8fCBwdC50Ll9vdmVyd3JpdGVQcm9wcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwdCA9PT0gdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHB0Ll9uZXh0ID0gcHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBwcm9wTG9va3VwW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHJlY29yZCkge1xuXHRcdFx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzW3BdID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9maXJzdFBUICYmIHRoaXMuX2luaXR0ZWQpIHsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBhcmUga2lsbGVkLCBraWxsIHRoZSB0d2Vlbi4gV2l0aG91dCB0aGlzIGxpbmUsIGlmIHRoZXJlJ3MgYSB0d2VlbiB3aXRoIG11bHRpcGxlIHRhcmdldHMgYW5kIHRoZW4geW91IGtpbGxUd2VlbnNPZigpIGVhY2ggdGFyZ2V0IGluZGl2aWR1YWxseSwgdGhlIHR3ZWVuIHdvdWxkIHRlY2huaWNhbGx5IHN0aWxsIHJlbWFpbiBhY3RpdmUgYW5kIGZpcmUgaXRzIG9uQ29tcGxldGUgZXZlbiB0aG91Z2ggdGhlcmUgYXJlbid0IGFueSBtb3JlIHByb3BlcnRpZXMgdHdlZW5pbmcuXG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCkge1xuXHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZmlyc3RQVCA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSBudWxsO1xuXHRcdFx0dGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSAodGhpcy5fdGFyZ2V0cykgPyB7fSA6IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdFx0dGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmIChlbmFibGVkICYmIHRoaXMuX2djKSB7XG5cdFx0XHRcdHZhciB0YXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRpZiAodGFyZ2V0cykge1xuXHRcdFx0XHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzW2ldID0gX3JlZ2lzdGVyKHRhcmdldHNbaV0sIHRoaXMsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IF9yZWdpc3Rlcih0aGlzLnRhcmdldCwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdEFuaW1hdGlvbi5wcm90b3R5cGUuX2VuYWJsZWQuY2FsbCh0aGlzLCBlbmFibGVkLCBpZ25vcmVUaW1lbGluZSk7XG5cdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCkgaWYgKHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0cmV0dXJuIFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudCgoZW5hYmxlZCA/IFwiX29uRW5hYmxlXCIgOiBcIl9vbkRpc2FibGVcIiksIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuLy8tLS0tVHdlZW5MaXRlIHN0YXRpYyBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRUd2VlbkxpdGUudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHRvVmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgdXNlRnJhbWVzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZShjYWxsYmFjaywgMCwge2RlbGF5OmRlbGF5LCBvbkNvbXBsZXRlOmNhbGxiYWNrLCBvbkNvbXBsZXRlUGFyYW1zOnBhcmFtcywgb25Db21wbGV0ZVNjb3BlOnNjb3BlLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBvblJldmVyc2VDb21wbGV0ZVNjb3BlOnNjb3BlLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2UsIGxhenk6ZmFsc2UsIHVzZUZyYW1lczp1c2VGcmFtZXMsIG92ZXJ3cml0ZTowfSk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uKHRhcmdldCwgb25seUFjdGl2ZSkge1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/IHRhcmdldCA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblx0XHRcdHZhciBpLCBhLCBqLCB0O1xuXHRcdFx0aWYgKChfaXNBcnJheSh0YXJnZXQpIHx8IF9pc1NlbGVjdG9yKHRhcmdldCkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXQubGVuZ3RoO1xuXHRcdFx0XHRhID0gW107XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGEgPSBhLmNvbmNhdChUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0W2ldLCBvbmx5QWN0aXZlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHQvL25vdyBnZXQgcmlkIG9mIGFueSBkdXBsaWNhdGVzICh0d2VlbnMgb2YgYXJyYXlzIG9mIG9iamVjdHMgY291bGQgY2F1c2UgZHVwbGljYXRlcylcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dCA9IGFbaV07XG5cdFx0XHRcdFx0aiA9IGk7XG5cdFx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodCA9PT0gYVtqXSkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGEgPSBfcmVnaXN0ZXIodGFyZ2V0KS5jb25jYXQoKTtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MgfHwgKG9ubHlBY3RpdmUgJiYgIWFbaV0uaXNBY3RpdmUoKSkpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2YgPSBUd2VlbkxpdGUua2lsbERlbGF5ZWRDYWxsc1RvID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlLCB2YXJzKSB7XG5cdFx0XHRpZiAodHlwZW9mKG9ubHlBY3RpdmUpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBvbmx5QWN0aXZlOyAvL2ZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoYmVmb3JlIFwib25seUFjdGl2ZVwiIHBhcmFtZXRlciB3YXMgaW5zZXJ0ZWQpXG5cdFx0XHRcdG9ubHlBY3RpdmUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBhID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCwgb25seUFjdGl2ZSksXG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRhW2ldLl9raWxsKHZhcnMsIHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUd2VlblBsdWdpbiAgIChjb3VsZCBlYXNpbHkgYmUgc3BsaXQgb3V0IGFzIGEgc2VwYXJhdGUgZmlsZS9jbGFzcywgYnV0IGluY2x1ZGVkIGZvciBlYXNlIG9mIHVzZSAoc28gdGhhdCBwZW9wbGUgZG9uJ3QgbmVlZCB0byBpbmNsdWRlIGFub3RoZXIgc2NyaXB0IGNhbGwgYmVmb3JlIGxvYWRpbmcgcGx1Z2lucyB3aGljaCBpcyBlYXN5IHRvIGZvcmdldClcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBUd2VlblBsdWdpbiA9IF9jbGFzcyhcInBsdWdpbnMuVHdlZW5QbHVnaW5cIiwgZnVuY3Rpb24ocHJvcHMsIHByaW9yaXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSAocHJvcHMgfHwgXCJcIikuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BOYW1lID0gdGhpcy5fb3ZlcndyaXRlUHJvcHNbMF07XG5cdFx0XHRcdFx0dGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gVHdlZW5QbHVnaW4ucHJvdG90eXBlO1xuXHRcdFx0XHR9LCB0cnVlKTtcblxuXHRcdHAgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0VHdlZW5QbHVnaW4udmVyc2lvbiA9IFwiMS4xMC4xXCI7XG5cdFx0VHdlZW5QbHVnaW4uQVBJID0gMjtcblx0XHRwLl9maXJzdFBUID0gbnVsbDtcblxuXHRcdHAuX2FkZFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBvdmVyd3JpdGVQcm9wLCByb3VuZCkge1xuXHRcdFx0dmFyIGMsIHB0O1xuXHRcdFx0aWYgKGVuZCAhPSBudWxsICYmIChjID0gKHR5cGVvZihlbmQpID09PSBcIm51bWJlclwiIHx8IGVuZC5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IE51bWJlcihlbmQpIC0gc3RhcnQgOiBwYXJzZUludChlbmQuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIE51bWJlcihlbmQuc3Vic3RyKDIpKSkpIHtcblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6dGFyZ2V0LCBwOnByb3AsIHM6c3RhcnQsIGM6YywgZjoodHlwZW9mKHRhcmdldFtwcm9wXSkgPT09IFwiZnVuY3Rpb25cIiksIG46b3ZlcndyaXRlUHJvcCB8fCBwcm9wLCByOnJvdW5kfTtcblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0dmFsO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdHZhbCA9IHB0LmMgKiB2ICsgcHQucztcblx0XHRcdFx0aWYgKHB0LnIpIHtcblx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluKSBpZiAodmFsID4gLW1pbikgeyAvL3ByZXZlbnRzIGlzc3VlcyB3aXRoIGNvbnZlcnRpbmcgdmVyeSBzbWFsbCBudW1iZXJzIHRvIHN0cmluZ3MgaW4gdGhlIGJyb3dzZXJcblx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSh2YWwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRpO1xuXHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobG9va3VwW2FbaV1dICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChsb29rdXBbcHQubl0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fcm91bmRQcm9wcyA9IGZ1bmN0aW9uKGxvb2t1cCwgdmFsdWUpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gfHwgKHB0Lm4gIT0gbnVsbCAmJiBsb29rdXBbIHB0Lm4uc3BsaXQodGhpcy5fcHJvcE5hbWUgKyBcIl9cIikuam9pbihcIlwiKSBdKSkgeyAvL3NvbWUgcHJvcGVydGllcyB0aGF0IGFyZSB2ZXJ5IHBsdWdpbi1zcGVjaWZpYyBhZGQgYSBwcmVmaXggbmFtZWQgYWZ0ZXIgdGhlIF9wcm9wTmFtZSBwbHVzIGFuIHVuZGVyc2NvcmUsIHNvIHdlIG5lZWQgdG8gaWdub3JlIHRoYXQgZXh0cmEgc3R1ZmYgaGVyZS5cblx0XHRcdFx0XHRwdC5yID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50ID0gZnVuY3Rpb24odHlwZSwgdHdlZW4pIHtcblx0XHRcdHZhciBwdCA9IHR3ZWVuLl9maXJzdFBULFxuXHRcdFx0XHRjaGFuZ2VkLCBwdDIsIGZpcnN0LCBsYXN0LCBuZXh0O1xuXHRcdFx0aWYgKHR5cGUgPT09IFwiX29uSW5pdEFsbFByb3BzXCIpIHtcblx0XHRcdFx0Ly9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gcmVuZGVyIGVhcmxpZXIvbGF0ZXIgdGhhbiBvdGhlcnMsIGxpa2UgTW90aW9uQmx1clBsdWdpbiBhcHBsaWVzIGl0cyBlZmZlY3RzIGFmdGVyIGFsbCB4L3kvYWxwaGEgdHdlZW5zIGhhdmUgcmVuZGVyZWQgb24gZWFjaCBmcmFtZS5cblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gdHdlZW4uX2ZpcnN0UFQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQucGcpIGlmICh0eXBlb2YocHQudFt0eXBlXSkgPT09IFwiZnVuY3Rpb25cIikgaWYgKHB0LnRbdHlwZV0oKSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUgPSBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0XHR2YXIgaSA9IHBsdWdpbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwbHVnaW5zW2ldLkFQSSA9PT0gVHdlZW5QbHVnaW4uQVBJKSB7XG5cdFx0XHRcdFx0X3BsdWdpbnNbKG5ldyBwbHVnaW5zW2ldKCkpLl9wcm9wTmFtZV0gPSBwbHVnaW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0Ly9wcm92aWRlcyBhIG1vcmUgY29uY2lzZSB3YXkgdG8gZGVmaW5lIHBsdWdpbnMgdGhhdCBoYXZlIG5vIGRlcGVuZGVuY2llcyBiZXNpZGVzIFR3ZWVuUGx1Z2luIGFuZCBUd2VlbkxpdGUsIHdyYXBwaW5nIGNvbW1vbiBib2lsZXJwbGF0ZSBzdHVmZiBpbnRvIG9uZSBmdW5jdGlvbiAoYWRkZWQgaW4gMS45LjApLiBZb3UgZG9uJ3QgTkVFRCB0byB1c2UgdGhpcyB0byBkZWZpbmUgYSBwbHVnaW4gLSB0aGUgb2xkIHdheSBzdGlsbCB3b3JrcyBhbmQgY2FuIGJlIHVzZWZ1bCBpbiBjZXJ0YWluIChyYXJlKSBzaXR1YXRpb25zLlxuXHRcdF9nc0RlZmluZS5wbHVnaW4gPSBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdGlmICghY29uZmlnIHx8ICFjb25maWcucHJvcE5hbWUgfHwgIWNvbmZpZy5pbml0IHx8ICFjb25maWcuQVBJKSB7IHRocm93IFwiaWxsZWdhbCBwbHVnaW4gZGVmaW5pdGlvbi5cIjsgfVxuXHRcdFx0dmFyIHByb3BOYW1lID0gY29uZmlnLnByb3BOYW1lLFxuXHRcdFx0XHRwcmlvcml0eSA9IGNvbmZpZy5wcmlvcml0eSB8fCAwLFxuXHRcdFx0XHRvdmVyd3JpdGVQcm9wcyA9IGNvbmZpZy5vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0bWFwID0ge2luaXQ6XCJfb25Jbml0VHdlZW5cIiwgc2V0Olwic2V0UmF0aW9cIiwga2lsbDpcIl9raWxsXCIsIHJvdW5kOlwiX3JvdW5kUHJvcHNcIiwgaW5pdEFsbDpcIl9vbkluaXRBbGxQcm9wc1wifSxcblx0XHRcdFx0UGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5cIiArIHByb3BOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcE5hbWUuc3Vic3RyKDEpICsgXCJQbHVnaW5cIixcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFR3ZWVuUGx1Z2luLmNhbGwodGhpcywgcHJvcE5hbWUsIHByaW9yaXR5KTtcblx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXRlUHJvcHMgfHwgW107XG5cdFx0XHRcdFx0fSwgKGNvbmZpZy5nbG9iYWwgPT09IHRydWUpKSxcblx0XHRcdFx0cCA9IFBsdWdpbi5wcm90b3R5cGUgPSBuZXcgVHdlZW5QbHVnaW4ocHJvcE5hbWUpLFxuXHRcdFx0XHRwcm9wO1xuXHRcdFx0cC5jb25zdHJ1Y3RvciA9IFBsdWdpbjtcblx0XHRcdFBsdWdpbi5BUEkgPSBjb25maWcuQVBJO1xuXHRcdFx0Zm9yIChwcm9wIGluIG1hcCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKGNvbmZpZ1twcm9wXSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHBbbWFwW3Byb3BdXSA9IGNvbmZpZ1twcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0UGx1Z2luLnZlcnNpb24gPSBjb25maWcudmVyc2lvbjtcblx0XHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlKFtQbHVnaW5dKTtcblx0XHRcdHJldHVybiBQbHVnaW47XG5cdFx0fTtcblxuXG5cdFx0Ly9ub3cgcnVuIHRocm91Z2ggYWxsIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBhbmQgaWYgYW55IGFyZSBtaXNzaW5nLCBsb2cgdGhhdCB0byB0aGUgY29uc29sZSBhcyBhIHdhcm5pbmcuIFRoaXMgaXMgd2h5IGl0J3MgYmVzdCB0byBoYXZlIFR3ZWVuTGl0ZSBsb2FkIGxhc3QgLSBpdCBjYW4gY2hlY2sgYWxsIHRoZSBkZXBlbmRlbmNpZXMgZm9yIHlvdS5cblx0XHRhID0gd2luZG93Ll9nc1F1ZXVlO1xuXHRcdGlmIChhKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRhW2ldKCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gX2RlZkxvb2t1cCkge1xuXHRcdFx0XHRpZiAoIV9kZWZMb29rdXBbcF0uZnVuYykge1xuXHRcdFx0XHRcdHdpbmRvdy5jb25zb2xlLmxvZyhcIkdTQVAgZW5jb3VudGVyZWQgbWlzc2luZyBkZXBlbmRlbmN5OiBjb20uZ3JlZW5zb2NrLlwiICsgcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7IC8vZW5zdXJlcyB0aGF0IHRoZSBmaXJzdCBvZmZpY2lhbCBhbmltYXRpb24gZm9yY2VzIGEgdGlja2VyLnRpY2soKSB0byB1cGRhdGUgdGhlIHRpbWUgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWRcblxufSkoKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93LCBcIlR3ZWVuTWF4XCIpOyIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjQgLSAyMDE0LTA5LTI4XG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ21veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgZXh0ZW5kKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gbGFzdC5kZWx0YVggLSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBsYXN0LmRlbHRhWSAtIGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5ID4gMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpIC0gZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5hbGxvdyA9IHRydWU7IC8vIHVzZWQgYnkgSW5wdXQuVG91Y2hNb3VzZSB0byBkaXNhYmxlIG1vdXNlIGV2ZW50c1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duLCBhbmQgbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkIChzZWUgdGhlIFRvdWNoTW91c2UgaW5wdXQpXG4gICAgICAgIGlmICghdGhpcy5wcmVzc2VkIHx8ICF0aGlzLmFsbG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbn1cblxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICBdO1xufVxuXG4vKipcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCBzbyAgYmxvY2sgYWxsIHVwY29taW5nIG1vdXNlIGV2ZW50c1xuICAgICAgICAvLyBtb3N0IG1vYmlsZSBicm93c2VyIGFsc28gZW1pdCBtb3VzZWV2ZW50cywgcmlnaHQgYWZ0ZXIgdG91Y2hzdGFydFxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgIXRoaXMubW91c2UuYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBhbGxvd01vdXNlIHdoZW4gd2UncmUgZG9uZVxuICAgICAgICBpZiAoaW5wdXRFdmVudCAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgLy8gbm90IG5lZWRlZCB3aXRoIG5hdGl2ZSBzdXBwb3J0IGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHlcbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcblxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgIC8vIHBhbi14IGFuZCBwYW4teSBjYW4gYmUgY29tYmluZWRcbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fUEFOX1ggKyAnICcgKyBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRzKTtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBleHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KHdpdGhTdGF0ZSkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgKHdpdGhTdGF0ZSA/IHN0YXRlU3RyKHN0YXRlKSA6ICcnKSwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdCgpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBleHRlbmQoe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0LCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDUwMCwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA1IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjY1LFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eVg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0LnZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQuZGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn1cblxuaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0YXBzOiAxLFxuICAgICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgIHRocmVzaG9sZDogMiwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCApIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYW4gbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNCc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfSwgWydyb3RhdGUnXV0sXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIseyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwgeyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH0sIFsnc3dpcGUnXV0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIEhhbW1lci5kZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2gob3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xufVxuXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXI7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ3JlbW92ZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpLCAxKTtcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKV0gPSBhZGQgPyB2YWx1ZSA6ICcnO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5leHRlbmQoSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PSBUWVBFX0ZVTkNUSU9OICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbn0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xufVxuXG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG4iLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5wYWdlPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAvKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG4vKipcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIHBhdGh0b1JlZ2V4cCA9IHJlcXVpcmUoJ3BhdGgtdG8tcmVnZXhwJyk7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBleHBvcnRzLlxuICAgKi9cblxuICBtb2R1bGUuZXhwb3J0cyA9IHBhZ2U7XG5cbiAgLyoqXG4gICAqIFRvIHdvcmsgcHJvcGVybHkgd2l0aCB0aGUgVVJMXG4gICAqIGhpc3RvcnkubG9jYXRpb24gZ2VuZXJhdGVkIHBvbHlmaWxsIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZvdGUvSFRNTDUtSGlzdG9yeS1BUElcbiAgICovXG5cbiAgdmFyIGxvY2F0aW9uID0gd2luZG93Lmhpc3RvcnkubG9jYXRpb24gfHwgd2luZG93LmxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGluaXRpYWwgZGlzcGF0Y2guXG4gICAqL1xuXG4gIHZhciBkaXNwYXRjaCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEJhc2UgcGF0aC5cbiAgICovXG5cbiAgdmFyIGJhc2UgPSAnJztcblxuICAvKipcbiAgICogUnVubmluZyBmbGFnLlxuICAgKi9cblxuICB2YXIgcnVubmluZztcblxuICAvKipcbiAgKiBIYXNoQmFuZyBvcHRpb25cbiAgKi9cblxuICB2YXIgaGFzaGJhbmcgPSBmYWxzZTtcblxuICAvKipcbiAgICogUHJldmlvdXMgY29udGV4dCwgZm9yIGNhcHR1cmluZ1xuICAgKiBwYWdlIGV4aXQgZXZlbnRzLlxuICAgKi9cblxuICB2YXIgcHJldkNvbnRleHQ7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGBwYXRoYCB3aXRoIGNhbGxiYWNrIGBmbigpYCxcbiAgICogb3Igcm91dGUgYHBhdGhgLCBvciByZWRpcmVjdGlvbixcbiAgICogb3IgYHBhZ2Uuc3RhcnQoKWAuXG4gICAqXG4gICAqICAgcGFnZShmbik7XG4gICAqICAgcGFnZSgnKicsIGZuKTtcbiAgICogICBwYWdlKCcvdXNlci86aWQnLCBsb2FkLCB1c2VyKTtcbiAgICogICBwYWdlKCcvdXNlci8nICsgdXNlci5pZCwgeyBzb21lOiAndGhpbmcnIH0pO1xuICAgKiAgIHBhZ2UoJy91c2VyLycgKyB1c2VyLmlkKTtcbiAgICogICBwYWdlKCcvZnJvbScsICcvdG8nKVxuICAgKiAgIHBhZ2UoKTtcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHBhdGhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4uLi5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gcGFnZShwYXRoLCBmbikge1xuICAgIC8vIDxjYWxsYmFjaz5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYWdlKCcqJywgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gcm91dGUgPHBhdGg+IHRvIDxjYWxsYmFjayAuLi4+XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmbikge1xuICAgICAgdmFyIHJvdXRlID0gbmV3IFJvdXRlKHBhdGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcGFnZS5jYWxsYmFja3MucHVzaChyb3V0ZS5taWRkbGV3YXJlKGFyZ3VtZW50c1tpXSkpO1xuICAgICAgfVxuICAgIC8vIHNob3cgPHBhdGg+IHdpdGggW3N0YXRlXVxuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHBhdGgpIHtcbiAgICAgICdzdHJpbmcnID09PSB0eXBlb2YgZm5cbiAgICAgICAgPyBwYWdlLnJlZGlyZWN0KHBhdGgsIGZuKVxuICAgICAgICA6IHBhZ2Uuc2hvdyhwYXRoLCBmbik7XG4gICAgLy8gc3RhcnQgW29wdGlvbnNdXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2Uuc3RhcnQocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICovXG5cbiAgcGFnZS5jYWxsYmFja3MgPSBbXTtcbiAgcGFnZS5leGl0cyA9IFtdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGJhc2VwYXRoIHRvIGBwYXRoYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5iYXNlID0gZnVuY3Rpb24ocGF0aCl7XG4gICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYXNlO1xuICAgIGJhc2UgPSBwYXRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAgICpcbiAgICogT3B0aW9uczpcbiAgICpcbiAgICogICAgLSBgY2xpY2tgIGJpbmQgdG8gY2xpY2sgZXZlbnRzIFt0cnVlXVxuICAgKiAgICAtIGBwb3BzdGF0ZWAgYmluZCB0byBwb3BzdGF0ZSBbdHJ1ZV1cbiAgICogICAgLSBgZGlzcGF0Y2hgIHBlcmZvcm0gaW5pdGlhbCBkaXNwYXRjaCBbdHJ1ZV1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChydW5uaW5nKSByZXR1cm47XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgaWYgKGZhbHNlID09PSBvcHRpb25zLmRpc3BhdGNoKSBkaXNwYXRjaCA9IGZhbHNlO1xuICAgIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5wb3BzdGF0ZSkgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25wb3BzdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5jbGljaykgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25jbGljaywgZmFsc2UpO1xuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmhhc2hiYW5nKSBoYXNoYmFuZyA9IHRydWU7XG4gICAgaWYgKCFkaXNwYXRjaCkgcmV0dXJuO1xuICAgIHZhciB1cmwgPSAoaGFzaGJhbmcgJiYgfmxvY2F0aW9uLmhhc2guaW5kZXhPZignIyEnKSlcbiAgICAgID8gbG9jYXRpb24uaGFzaC5zdWJzdHIoMikgKyBsb2NhdGlvbi5zZWFyY2hcbiAgICAgIDogbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoO1xuICAgIHBhZ2UucmVwbGFjZSh1cmwsIG51bGwsIHRydWUsIGRpc3BhdGNoKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIGNsaWNrIGFuZCBwb3BzdGF0ZSBldmVudCBoYW5kbGVycy5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoIXJ1bm5pbmcpIHJldHVybjtcbiAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25jbGljaywgZmFsc2UpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9ucG9wc3RhdGUsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyBgcGF0aGAgd2l0aCBvcHRpb25hbCBgc3RhdGVgIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzcGF0Y2hcbiAgICogQHJldHVybiB7Q29udGV4dH1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5zaG93ID0gZnVuY3Rpb24ocGF0aCwgc3RhdGUsIGRpc3BhdGNoKXtcbiAgICB2YXIgY3R4ID0gbmV3IENvbnRleHQocGF0aCwgc3RhdGUpO1xuICAgIGlmIChmYWxzZSAhPT0gZGlzcGF0Y2gpIHBhZ2UuZGlzcGF0Y2goY3R4KTtcbiAgICBpZiAoZmFsc2UgIT09IGN0eC5oYW5kbGVkKSBjdHgucHVzaFN0YXRlKCk7XG4gICAgcmV0dXJuIGN0eDtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgcm91dGUgdG8gcmVkaXJlY3QgZnJvbSBvbmUgcGF0aCB0byBvdGhlclxuICAgKiBvciBqdXN0IHJlZGlyZWN0IHRvIGFub3RoZXIgcm91dGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyb20gLSBpZiBwYXJhbSAndG8nIGlzIHVuZGVmaW5lZCByZWRpcmVjdHMgdG8gJ2Zyb20nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdG9dXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBwYWdlLnJlZGlyZWN0ID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAvLyBEZWZpbmUgcm91dGUgZnJvbSBhIHBhdGggdG8gYW5vdGhlclxuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGZyb20gJiYgJ3N0cmluZycgPT09IHR5cGVvZiB0bykge1xuICAgICAgcGFnZShmcm9tLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHBhZ2UucmVwbGFjZSh0byk7XG4gICAgICAgIH0sMCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXYWl0IGZvciB0aGUgcHVzaCBzdGF0ZSBhbmQgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXJcbiAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGZyb20gJiYgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0bykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBwYWdlLnJlcGxhY2UoZnJvbSk7XG4gICAgICB9LDApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZSBgcGF0aGAgd2l0aCBvcHRpb25hbCBgc3RhdGVgIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEByZXR1cm4ge0NvbnRleHR9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2UucmVwbGFjZSA9IGZ1bmN0aW9uKHBhdGgsIHN0YXRlLCBpbml0LCBkaXNwYXRjaCl7XG4gICAgdmFyIGN0eCA9IG5ldyBDb250ZXh0KHBhdGgsIHN0YXRlKTtcbiAgICBjdHguaW5pdCA9IGluaXQ7XG4gICAgY3R4LnNhdmUoKTsgLy8gc2F2ZSBiZWZvcmUgZGlzcGF0Y2hpbmcsIHdoaWNoIG1heSByZWRpcmVjdFxuICAgIGlmIChmYWxzZSAhPT0gZGlzcGF0Y2gpIHBhZ2UuZGlzcGF0Y2goY3R4KTtcbiAgICByZXR1cm4gY3R4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCB0aGUgZ2l2ZW4gYGN0eGAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIHBhZ2UuZGlzcGF0Y2ggPSBmdW5jdGlvbihjdHgpe1xuICAgIHZhciBwcmV2ID0gcHJldkNvbnRleHQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHByZXZDb250ZXh0ID0gY3R4O1xuXG4gICAgZnVuY3Rpb24gbmV4dEV4aXQoKSB7XG4gICAgICB2YXIgZm4gPSBwYWdlLmV4aXRzW2orK107XG4gICAgICBpZiAoIWZuKSByZXR1cm4gbmV4dEVudGVyKCk7XG4gICAgICBmbihwcmV2LCBuZXh0RXhpdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dEVudGVyKCkge1xuICAgICAgdmFyIGZuID0gcGFnZS5jYWxsYmFja3NbaSsrXTtcbiAgICAgIGlmICghZm4pIHJldHVybiB1bmhhbmRsZWQoY3R4KTtcbiAgICAgIGZuKGN0eCwgbmV4dEVudGVyKTtcbiAgICB9XG5cbiAgICBpZiAocHJldikge1xuICAgICAgbmV4dEV4aXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEVudGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbmhhbmRsZWQgYGN0eGAuIFdoZW4gaXQncyBub3QgdGhlIGluaXRpYWxcbiAgICogcG9wc3RhdGUgdGhlbiByZWRpcmVjdC4gSWYgeW91IHdpc2ggdG8gaGFuZGxlXG4gICAqIDQwNHMgb24geW91ciBvd24gdXNlIGBwYWdlKCcqJywgY2FsbGJhY2spYC5cbiAgICpcbiAgICogQHBhcmFtIHtDb250ZXh0fSBjdHhcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHVuaGFuZGxlZChjdHgpIHtcbiAgICBpZiAoY3R4LmhhbmRsZWQpIHJldHVybjtcbiAgICB2YXIgY3VycmVudDtcblxuICAgIGlmIChoYXNoYmFuZykge1xuICAgICAgY3VycmVudCA9IGJhc2UgKyBsb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMhJywnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gY3R4LmNhbm9uaWNhbFBhdGgpIHJldHVybjtcbiAgICBwYWdlLnN0b3AoKTtcbiAgICBjdHguaGFuZGxlZCA9IGZhbHNlO1xuICAgIGxvY2F0aW9uLmhyZWYgPSBjdHguY2Fub25pY2FsUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBleGl0IHJvdXRlIG9uIGBwYXRoYCB3aXRoXG4gICAqIGNhbGxiYWNrIGBmbigpYCwgd2hpY2ggd2lsbCBiZSBjYWxsZWRcbiAgICogb24gdGhlIHByZXZpb3VzIGNvbnRleHQgd2hlbiBhIG5ld1xuICAgKiBwYWdlIGlzIHZpc2l0ZWQuXG4gICAqL1xuICBwYWdlLmV4aXQgPSBmdW5jdGlvbihwYXRoLCBmbikge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcGFnZS5leGl0KCcqJywgcGF0aCk7XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZShwYXRoKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgcGFnZS5leGl0cy5wdXNoKHJvdXRlLm1pZGRsZXdhcmUoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIFJlbW92ZSBVUkwgZW5jb2RpbmcgZnJvbSB0aGUgZ2l2ZW4gYHN0cmAuXG4gICogQWNjb21tb2RhdGVzIHdoaXRlc3BhY2UgaW4gYm90aCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgKiBhbmQgcmVndWxhciBwZXJjZW50LWVuY29kZWQgZm9ybS5cbiAgKlxuICAqIEBwYXJhbSB7c3RyfSBVUkwgY29tcG9uZW50IHRvIGRlY29kZVxuICAqL1xuICBmdW5jdGlvbiBkZWNvZGVVUkxFbmNvZGVkVVJJQ29tcG9uZW50KHN0cikge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IFwicmVxdWVzdFwiIGBDb250ZXh0YFxuICAgKiB3aXRoIHRoZSBnaXZlbiBgcGF0aGAgYW5kIG9wdGlvbmFsIGluaXRpYWwgYHN0YXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIENvbnRleHQocGF0aCwgc3RhdGUpIHtcbiAgICBwYXRoID0gZGVjb2RlVVJMRW5jb2RlZFVSSUNvbXBvbmVudChwYXRoKTtcbiAgICBpZiAoJy8nID09PSBwYXRoWzBdICYmIDAgIT09IHBhdGguaW5kZXhPZihiYXNlKSkgcGF0aCA9IGJhc2UgKyBwYXRoO1xuICAgIHZhciBpID0gcGF0aC5pbmRleE9mKCc/Jyk7XG5cbiAgICB0aGlzLmNhbm9uaWNhbFBhdGggPSBwYXRoO1xuICAgIHRoaXMucGF0aCA9IHBhdGgucmVwbGFjZShiYXNlLCAnJykgfHwgJy8nO1xuXG4gICAgdGhpcy50aXRsZSA9IGRvY3VtZW50LnRpdGxlO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgICB0aGlzLnN0YXRlLnBhdGggPSBwYXRoO1xuICAgIHRoaXMucXVlcnlzdHJpbmcgPSB+aVxuICAgICAgPyBwYXRoLnNsaWNlKGkgKyAxKVxuICAgICAgOiAnJztcbiAgICB0aGlzLnBhdGhuYW1lID0gfmlcbiAgICAgID8gcGF0aC5zbGljZSgwLCBpKVxuICAgICAgOiBwYXRoO1xuICAgIHRoaXMucGFyYW1zID0gW107XG5cbiAgICAvLyBmcmFnbWVudFxuICAgIHRoaXMuaGFzaCA9ICcnO1xuICAgIGlmICghfnRoaXMucGF0aC5pbmRleE9mKCcjJykpIHJldHVybjtcbiAgICB2YXIgcGFydHMgPSB0aGlzLnBhdGguc3BsaXQoJyMnKTtcbiAgICB0aGlzLnBhdGggPSBwYXJ0c1swXTtcbiAgICB0aGlzLmhhc2ggPSBwYXJ0c1sxXSB8fCAnJztcbiAgICB0aGlzLnF1ZXJ5c3RyaW5nID0gdGhpcy5xdWVyeXN0cmluZy5zcGxpdCgnIycpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBgQ29udGV4dGAuXG4gICAqL1xuXG4gIHBhZ2UuQ29udGV4dCA9IENvbnRleHQ7XG5cbiAgLyoqXG4gICAqIFB1c2ggc3RhdGUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBDb250ZXh0LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbigpe1xuICAgIGhpc3RvcnkucHVzaFN0YXRlKHRoaXMuc3RhdGVcbiAgICAgICwgdGhpcy50aXRsZVxuICAgICAgLCBoYXNoYmFuZyAmJiB0aGlzLnBhdGggIT09ICcvJ1xuICAgICAgICA/ICcjIScgKyB0aGlzLnBhdGhcbiAgICAgICAgOiB0aGlzLmNhbm9uaWNhbFBhdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHRoZSBjb250ZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDb250ZXh0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKXtcbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh0aGlzLnN0YXRlXG4gICAgICAsIHRoaXMudGl0bGVcbiAgICAgICwgaGFzaGJhbmcgJiYgdGhpcy5wYXRoICE9PSAnLydcbiAgICAgICAgPyAnIyEnICsgdGhpcy5wYXRoXG4gICAgICAgIDogdGhpcy5jYW5vbmljYWxQYXRoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBgUm91dGVgIHdpdGggdGhlIGdpdmVuIEhUVFAgYHBhdGhgLFxuICAgKiBhbmQgYW4gYXJyYXkgb2YgYGNhbGxiYWNrc2AgYW5kIGBvcHRpb25zYC5cbiAgICpcbiAgICogT3B0aW9uczpcbiAgICpcbiAgICogICAtIGBzZW5zaXRpdmVgICAgIGVuYWJsZSBjYXNlLXNlbnNpdGl2ZSByb3V0ZXNcbiAgICogICAtIGBzdHJpY3RgICAgICAgIGVuYWJsZSBzdHJpY3QgbWF0Y2hpbmcgZm9yIHRyYWlsaW5nIHNsYXNoZXNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBSb3V0ZShwYXRoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5wYXRoID0gKHBhdGggPT09ICcqJykgPyAnKC4qKScgOiBwYXRoO1xuICAgIHRoaXMubWV0aG9kID0gJ0dFVCc7XG4gICAgdGhpcy5yZWdleHAgPSBwYXRodG9SZWdleHAodGhpcy5wYXRoLFxuICAgICAgdGhpcy5rZXlzID0gW10sXG4gICAgICBvcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIG9wdGlvbnMuc3RyaWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgYFJvdXRlYC5cbiAgICovXG5cbiAgcGFnZS5Sb3V0ZSA9IFJvdXRlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gcm91dGUgbWlkZGxld2FyZSB3aXRoXG4gICAqIHRoZSBnaXZlbiBjYWxsYmFjayBgZm4oKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBSb3V0ZS5wcm90b3R5cGUubWlkZGxld2FyZSA9IGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGN0eCwgbmV4dCl7XG4gICAgICBpZiAoc2VsZi5tYXRjaChjdHgucGF0aCwgY3R4LnBhcmFtcykpIHJldHVybiBmbihjdHgsIG5leHQpO1xuICAgICAgbmV4dCgpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgcm91dGUgbWF0Y2hlcyBgcGF0aGAsIGlmIHNvXG4gICAqIHBvcHVsYXRlIGBwYXJhbXNgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIFJvdXRlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdGgsIHBhcmFtcyl7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgIHFzSW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKSxcbiAgICAgICAgcGF0aG5hbWUgPSB+cXNJbmRleFxuICAgICAgICAgID8gcGF0aC5zbGljZSgwLCBxc0luZGV4KVxuICAgICAgICAgIDogcGF0aCxcbiAgICAgICAgbSA9IHRoaXMucmVnZXhwLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHBhdGhuYW1lKSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG5cbiAgICAgIHZhciB2YWwgPSAnc3RyaW5nJyA9PT0gdHlwZW9mIG1baV1cbiAgICAgICAgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSlcbiAgICAgICAgOiBtW2ldO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB1bmRlZmluZWQgIT09IHBhcmFtc1trZXkubmFtZV1cbiAgICAgICAgICA/IHBhcmFtc1trZXkubmFtZV1cbiAgICAgICAgICA6IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBcInBvcHVsYXRlXCIgZXZlbnRzLlxuICAgKi9cblxuICBmdW5jdGlvbiBvbnBvcHN0YXRlKGUpIHtcbiAgICBpZiAoZS5zdGF0ZSkge1xuICAgICAgdmFyIHBhdGggPSBlLnN0YXRlLnBhdGg7XG4gICAgICBwYWdlLnJlcGxhY2UocGF0aCwgZS5zdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBcImNsaWNrXCIgZXZlbnRzLlxuICAgKi9cblxuICBmdW5jdGlvbiBvbmNsaWNrKGUpIHtcbiAgICBpZiAoMSAhPSB3aGljaChlKSkgcmV0dXJuO1xuICAgIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHJldHVybjtcbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAvLyBlbnN1cmUgbGlua1xuICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgIHdoaWxlIChlbCAmJiAnQScgIT0gZWwubm9kZU5hbWUpIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICBpZiAoIWVsIHx8ICdBJyAhPSBlbC5ub2RlTmFtZSkgcmV0dXJuO1xuXG4gICAgLy8gSWdub3JlIGlmIHRhZyBoYXMgYSBcImRvd25sb2FkXCIgYXR0cmlidXRlXG4gICAgaWYgKGVsLmdldEF0dHJpYnV0ZShcImRvd25sb2FkXCIpKSByZXR1cm47XG5cbiAgICAvLyBlbnN1cmUgbm9uLWhhc2ggZm9yIHRoZSBzYW1lIHBhdGhcbiAgICB2YXIgbGluayA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGlmIChlbC5wYXRobmFtZSA9PT0gbG9jYXRpb24ucGF0aG5hbWUgJiYgKGVsLmhhc2ggfHwgJyMnID09PSBsaW5rKSkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgZm9yIG1haWx0bzogaW4gdGhlIGhyZWZcbiAgICBpZiAobGluayAmJiBsaW5rLmluZGV4T2YoXCJtYWlsdG86XCIpID4gLTEpIHJldHVybjtcblxuICAgIC8vIGNoZWNrIHRhcmdldFxuICAgIGlmIChlbC50YXJnZXQpIHJldHVybjtcblxuICAgIC8vIHgtb3JpZ2luXG4gICAgaWYgKCFzYW1lT3JpZ2luKGVsLmhyZWYpKSByZXR1cm47XG5cbiAgICAvLyByZWJ1aWxkIHBhdGhcbiAgICB2YXIgcGF0aCA9IGVsLnBhdGhuYW1lICsgZWwuc2VhcmNoICsgKGVsLmhhc2ggfHwgJycpO1xuXG4gICAgLy8gc2FtZSBwYWdlXG4gICAgdmFyIG9yaWcgPSBwYXRoO1xuXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZShiYXNlLCAnJyk7XG5cbiAgICBpZiAoYmFzZSAmJiBvcmlnID09PSBwYXRoKSByZXR1cm47XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcGFnZS5zaG93KG9yaWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGJ1dHRvbi5cbiAgICovXG5cbiAgZnVuY3Rpb24gd2hpY2goZSkge1xuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICByZXR1cm4gbnVsbCA9PT0gZS53aGljaFxuICAgICAgPyBlLmJ1dHRvblxuICAgICAgOiBlLndoaWNoO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGBocmVmYCBpcyB0aGUgc2FtZSBvcmlnaW4uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNhbWVPcmlnaW4oaHJlZikge1xuICAgIHZhciBvcmlnaW4gPSBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgICBpZiAobG9jYXRpb24ucG9ydCkgb3JpZ2luICs9ICc6JyArIGxvY2F0aW9uLnBvcnQ7XG4gICAgcmV0dXJuIChocmVmICYmICgwID09PSBocmVmLmluZGV4T2Yob3JpZ2luKSkpO1xuICB9XG5cbiAgcGFnZS5zYW1lT3JpZ2luID0gc2FtZU9yaWdpbjtcblxufSx7XCJwYXRoLXRvLXJlZ2V4cFwiOjJ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogRXhwb3NlIGBwYXRodG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGh0b1JlZ2V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBhbHJlYWR5IGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBpbmNvcnJlY3RseSBhcHBlYXJcbiAgLy8gaW4gZnV0dXJlIG1hdGNoZXMuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdFxuICAvLyBzaG91bGRuJ3QgYmUgdHJhbnNmb3JtZWQuXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCJdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZF1cbiAgJyhbXFxcXC8uXSk/KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKShbKyo/XSk/JyxcbiAgLy8gTWF0Y2ggcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBhbHdheXMgYmUgZXNjYXBlZC5cbiAgJyhbLisqPz1eIToke30oKVtcXFxcXXxcXFxcL10pJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG52YXIgYXR0YWNoS2V5cyA9IGZ1bmN0aW9uIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcblxuICByZXR1cm4gcmU7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBzaG91bGQgYmUgcGFzc2VkIGluLCB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIHBsYWNlaG9sZGVyIGtleVxuICogbmFtZXMuIEZvciBleGFtcGxlIGAvdXNlci86aWRgIHdpbGwgdGhlbiBjb250YWluIGBbXCJpZFwiXWAuXG4gKlxuICogQHBhcmFtICB7KFN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRodG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKGtleXMgJiYgIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0ga2V5cztcbiAgICBrZXlzID0gbnVsbDtcbiAgfVxuXG4gIGtleXMgPSBrZXlzIHx8IFtdO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciBmbGFncyA9IG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSc7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBNYXRjaCBhbGwgY2FwdHVyaW5nIGdyb3VwcyBvZiBhIHJlZ2V4cC5cbiAgICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZykgfHwgW107XG5cbiAgICAvLyBNYXAgYWxsIHRoZSBtYXRjaGVzIHRvIHRoZWlyIG51bWVyaWMga2V5cyBhbmQgcHVzaCBpbnRvIHRoZSBrZXlzLlxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBncm91cHMubWFwKGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICAgICAgaW5kZXgsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6ICBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiAgICBmYWxzZVxuICAgICAgfTtcbiAgICB9KSk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHNvdXJjZSBiYWNrIHRvIHRoZSB1c2VyLlxuICAgIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAvLyBNYXAgYXJyYXkgcGFydHMgaW50byByZWdleHBzIGFuZCByZXR1cm4gdGhlaXIgc291cmNlLiBXZSBhbHNvIHBhc3NcbiAgICAvLyB0aGUgc2FtZSBrZXlzIGFuZCBvcHRpb25zIGluc3RhbmNlIGludG8gZXZlcnkgZ2VuZXJhdGlvbiB0byBnZXRcbiAgICAvLyBjb25zaXN0ZW50IG1hdGNoaW5nIGdyb3VwcyBiZWZvcmUgd2Ugam9pbiB0aGUgc291cmNlcyB0b2dldGhlci5cbiAgICBwYXRoID0gcGF0aC5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcGF0aHRvUmVnZXhwKHZhbHVlLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7XG4gICAgfSk7XG5cbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyByZWdleHAgaW5zdGFuY2UgYnkgam9pbmluZyBhbGwgdGhlIHBhcnRzIHRvZ2V0aGVyLlxuICAgIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJyg/OicgKyBwYXRoLmpvaW4oJ3wnKSArICcpJywgZmxhZ3MpLCBrZXlzKTtcbiAgfVxuXG4gIC8vIEFsdGVyIHRoZSBwYXRoIHN0cmluZyBpbnRvIGEgdXNhYmxlIHJlZ2V4cC5cbiAgcGF0aCA9IHBhdGgucmVwbGFjZShQQVRIX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoLCBlc2NhcGVkLCBwcmVmaXgsIGtleSwgY2FwdHVyZSwgZ3JvdXAsIHN1ZmZpeCwgZXNjYXBlKSB7XG4gICAgLy8gQXZvaWRpbmcgcmUtZXNjYXBpbmcgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG5cbiAgICAvLyBFc2NhcGUgcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlO1xuICAgIH1cblxuICAgIHZhciByZXBlYXQgICA9IHN1ZmZpeCA9PT0gJysnIHx8IHN1ZmZpeCA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IHN1ZmZpeCA9PT0gJz8nIHx8IHN1ZmZpeCA9PT0gJyonO1xuXG4gICAga2V5cy5wdXNoKHtcbiAgICAgIG5hbWU6ICAgICAga2V5IHx8IGluZGV4KyssXG4gICAgICBkZWxpbWl0ZXI6IHByZWZpeCB8fCAnLycsXG4gICAgICBvcHRpb25hbDogIG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiAgICByZXBlYXRcbiAgICB9KTtcblxuICAgIC8vIEVzY2FwZSB0aGUgcHJlZml4IGNoYXJhY3Rlci5cbiAgICBwcmVmaXggPSBwcmVmaXggPyAnXFxcXCcgKyBwcmVmaXggOiAnJztcblxuICAgIC8vIE1hdGNoIHVzaW5nIHRoZSBjdXN0b20gY2FwdHVyaW5nIGdyb3VwLCBvciBmYWxsYmFjayB0byBjYXB0dXJpbmdcbiAgICAvLyBldmVyeXRoaW5nIHVwIHRvIHRoZSBuZXh0IHNsYXNoIChvciBuZXh0IHBlcmlvZCBpZiB0aGUgcGFyYW0gd2FzXG4gICAgLy8gcHJlZml4ZWQgd2l0aCBhIHBlcmlvZCkuXG4gICAgY2FwdHVyZSA9IGVzY2FwZUdyb3VwKGNhcHR1cmUgfHwgZ3JvdXAgfHwgJ1teJyArIChwcmVmaXggfHwgJ1xcXFwvJykgKyAnXSs/Jyk7XG5cbiAgICAvLyBBbGxvdyBwYXJhbWV0ZXJzIHRvIGJlIHJlcGVhdGVkIG1vcmUgdGhhbiBvbmNlLlxuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgIGNhcHR1cmUgPSBjYXB0dXJlICsgJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBhIHBhcmFtZXRlciB0byBiZSBvcHRpb25hbC5cbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBwYXJhbWV0ZXIgc3VwcG9ydC5cbiAgICByZXR1cm4gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgfSk7XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcGF0aCBlbmRzIGluIGEgc2xhc2ggYXMgaXQgYWx0ZXJzIHNvbWUgbWF0Y2ggYmVoYXZpb3VyLlxuICB2YXIgZW5kc1dpdGhTbGFzaCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhbiBvcHRpb25hbCB0cmFpbGluZyBzbGFzaCBpbiB0aGUgbWF0Y2guIElmXG4gIC8vIHRoZSBwYXRoIHRvIG1hdGNoIGFscmVhZHkgZW5kZWQgd2l0aCBhIHNsYXNoLCB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmb3JcbiAgLy8gY29uc2lzdGVuY3kuIFRoZSBzbGFzaCBpcyBvbmx5IHZhbGlkIGF0IHRoZSB2ZXJ5IGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdFxuICAvLyBhbnl3aGVyZSBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudCBmb3Igbm9uLWVuZGluZyBtb2RlLCBvdGhlcndpc2VcbiAgLy8gXCIvdGVzdC9cIiB3aWxsIG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcGF0aCA9IChlbmRzV2l0aFNsYXNoID8gcGF0aC5zbGljZSgwLCAtMikgOiBwYXRoKSArICcoPzpcXFxcLyg/PSQpKT8nO1xuICB9XG5cbiAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHByb21wdCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoXG4gIC8vIGFzIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIGZvciB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICBpZiAoIWVuZCkge1xuICAgIHBhdGggKz0gc3RyaWN0ICYmIGVuZHNXaXRoU2xhc2ggPyAnJyA6ICcoPz1cXFxcL3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHBhdGggKyAoZW5kID8gJyQnIDogJycpLCBmbGFncyksIGtleXMpO1xufTtcblxufSx7fV19LHt9LFsxXSkoMSlcbn0pOyIsIi8qXG5cblx0cmFjdGl2ZS1ldmVudHMtdGFwXG5cdD09PT09PT09PT09PT09PT09PVxuXG5cdFZlcnNpb24gMC4xLjIuXG5cblx0T24gbW9iaWxlIGRldmljZXMsIHVzaW5nIGBvbi1jbGlja2AgaXNuJ3QgZ29vZCBlbm91Z2guIFRhcHBpbmcgdGhlXG5cdHRvdWNoc2NyZWVuIHdpbGwgZmlyZSBhIHNpbXVsYXRlZCBjbGljayBldmVudCwgYnV0IG9ubHkgYWZ0ZXIgYSAzMDBcblx0bWlsbGlzZWNvbmQgZGVsYXksIHdoaWNoIG1ha2VzIHlvdXIgYXBwIGZlZWwgc2x1Z2dpc2guIEl0IGFsc29cblx0Y2F1c2VzIHRoZSB0YXBwZWQgYXJlYSB0byBoaWdobGlnaHQsIHdoaWNoIGluIG1vc3QgY2FzZXMgbG9va3MgYVxuXHRiaXQgbWVzc3kuXG5cblx0SW5zdGVhZCwgdXNlIGBvbi10YXBgLiBXaGVuIHlvdSB0YXAgYW4gYXJlYSwgdGhlIHNpbXVsYXRlZCBjbGlja1xuXHRldmVudCB3aWxsIGJlIHByZXZlbnRlZCwgYW5kIHRoZSB1c2VyJ3MgYWN0aW9uIGlzIHJlc3BvbmRlZCB0b1xuXHRpbnN0YW50bHkuIFRoZSBgb24tdGFwYCBldmVudCBhbHNvIGRpZmZlcnMgZnJvbSBgb24tY2xpY2tgIGluIHRoYXRcblx0dGhlIGNsaWNrIGV2ZW50IHdpbGwgKGZyYW5rbHkgcmF0aGVyIGJpemFycmVseSkgZmlyZSBldmVuIGlmIHlvdVxuXHRob2xkIHRoZSBtb3VzZSBkb3duIG92ZXIgYSBzaW5nbGUgZWxlbWVudCBmb3Igc2V2ZXJhbCBzZWNvbmRzIGFuZFxuXHR3YWdnbGUgaXQgYWJvdXQuXG5cblx0UG9pbnRlciBldmVudHMgYXJlIGFsc28gc3VwcG9ydGVkLCBhcyBpcyBwcmVzc2luZyB0aGUgc3BhY2ViYXIgd2hlblxuXHR0aGUgcmVsZXZhbnQgZWxlbWVudCBpcyBmb2N1c2VkICh3aGljaCB0cmlnZ2VycyBhIGNsaWNrIGV2ZW50LCBhbmRcblx0aXMgZ29vZCBmb3IgYWNjZXNzaWJpbGl0eSkuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRUcm91Ymxlc2hvb3Rpbmc6IElmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBzeXN0ZW0gaW4geW91ciBhcHAgKEFNRCBvclxuXHRzb21ldGhpbmcgbW9yZSBub2RleSkgdGhlbiB5b3UgbWF5IG5lZWQgdG8gY2hhbmdlIHRoZSBwYXRocyBiZWxvdyxcblx0d2hlcmUgaXQgc2F5cyBgcmVxdWlyZSggJ3JhY3RpdmUnIClgIG9yIGBkZWZpbmUoWyAncmFjdGl2ZScgXS4uLilgLlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VXNhZ2U6IEluY2x1ZGUgdGhpcyBmaWxlIG9uIHlvdXIgcGFnZSBiZWxvdyBSYWN0aXZlLCBlLmc6XG5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS5qcyc+PC9zY3JpcHQ+XG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUtZXZlbnRzLXRhcC5qcyc+PC9zY3JpcHQ+XG5cblx0T3IsIGlmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBsb2FkZXIsIHJlcXVpcmUgdGhpcyBtb2R1bGU6XG5cblx0ICAgIC8vIHJlcXVpcmluZyB0aGUgcGx1Z2luIHdpbGwgJ2FjdGl2YXRlJyBpdCAtIG5vIG5lZWQgdG8gdXNlXG5cdCAgICAvLyB0aGUgcmV0dXJuIHZhbHVlXG5cdCAgICByZXF1aXJlKCAncmFjdGl2ZS1ldmVudHMtdGFwJyApO1xuXG5cdEFkZCBhIHRhcCBldmVudCBpbiB0aGUgbm9ybWFsIGZhc2hpb246XG5cblx0ICAgIDxkaXYgb24tdGFwPSdmb28nPnRhcCBtZSE8L2Rpdj5cblxuXHRUaGVuIGFkZCBhIGhhbmRsZXI6XG5cblx0ICAgIHJhY3RpdmUub24oICdmb28nLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHQgICAgICBhbGVydCggJ3RhcHBlZCcgKTtcblx0ICAgIH0pO1xuXG4qL1xuXG4oZnVuY3Rpb24gKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIENvbW1vbiBKUyAoaS5lLiBicm93c2VyaWZ5KSBlbnZpcm9ubWVudFxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdGZhY3RvcnkoIHJlcXVpcmUoIFwiLi8uLi9yYWN0aXZlL3JhY3RpdmUuanNcIiApICk7XG5cdH1cblxuXHQvLyBBTUQ/XG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKFsgJ3JhY3RpdmUnIF0sIGZhY3RvcnkgKTtcblx0fVxuXG5cdC8vIGJyb3dzZXIgZ2xvYmFsXG5cdGVsc2UgaWYgKCBnbG9iYWwuUmFjdGl2ZSApIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwuUmFjdGl2ZSApO1xuXHR9XG5cblx0ZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgUmFjdGl2ZSEgSXQgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIHRoZSByYWN0aXZlLWV2ZW50cy10YXAgcGx1Z2luJyApO1xuXHR9XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKCBSYWN0aXZlICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdGFwID0gZnVuY3Rpb24gKCBub2RlLCBmaXJlICkge1xuXHRcdHZhciBtb3VzZWRvd24sIHRvdWNoc3RhcnQsIGZvY3VzSGFuZGxlciwgZGlzdGFuY2VUaHJlc2hvbGQsIHRpbWVUaHJlc2hvbGQsIHByZXZlbnRNb3VzZWRvd25FdmVudHMsIHByZXZlbnRNb3VzZWRvd25UaW1lb3V0O1xuXG5cdFx0ZGlzdGFuY2VUaHJlc2hvbGQgPSA1OyAvLyBtYXhpbXVtIHBpeGVscyBwb2ludGVyIGNhbiBtb3ZlIGJlZm9yZSBjYW5jZWxcblx0XHR0aW1lVGhyZXNob2xkID0gNDAwOyAgIC8vIG1heGltdW0gbWlsbGlzZWNvbmRzIGJldHdlZW4gZG93biBhbmQgdXAgYmVmb3JlIGNhbmNlbFxuXG5cdFx0bW91c2Vkb3duID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciBjdXJyZW50VGFyZ2V0LCB4LCB5LCBwb2ludGVySWQsIHVwLCBtb3ZlLCBjYW5jZWw7XG5cblx0XHRcdGlmICggcHJldmVudE1vdXNlZG93bkV2ZW50cyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoICE9PSB1bmRlZmluZWQgJiYgZXZlbnQud2hpY2ggIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0eCA9IGV2ZW50LmNsaWVudFg7XG5cdFx0XHR5ID0gZXZlbnQuY2xpZW50WTtcblx0XHRcdGN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdFx0Ly8gVGhpcyB3aWxsIGJlIG51bGwgZm9yIG1vdXNlIGV2ZW50cy5cblx0XHRcdHBvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuXHRcdFx0dXAgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50LnBvaW50ZXJJZCAhPSBwb2ludGVySWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmlyZSh7XG5cdFx0XHRcdFx0bm9kZTogY3VycmVudFRhcmdldCxcblx0XHRcdFx0XHRvcmlnaW5hbDogZXZlbnRcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRtb3ZlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBldmVudC5wb2ludGVySWQgIT0gcG9pbnRlcklkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggKCBNYXRoLmFicyggZXZlbnQuY2xpZW50WCAtIHggKSA+PSBkaXN0YW5jZVRocmVzaG9sZCApIHx8ICggTWF0aC5hYnMoIGV2ZW50LmNsaWVudFkgLSB5ICkgPj0gZGlzdGFuY2VUaHJlc2hvbGQgKSApIHtcblx0XHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Y2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJVcCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyTW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJDYW5jZWwnLCBjYW5jZWwsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCApIHtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyVXAnLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlck1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyQ2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHR9XG5cblx0XHRcdHNldFRpbWVvdXQoIGNhbmNlbCwgdGltZVRocmVzaG9sZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVyZG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHR9IGVsc2UgaWYgKCB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJEb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0fVxuXG5cblx0XHR0b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciBjdXJyZW50VGFyZ2V0LCB4LCB5LCB0b3VjaCwgZmluZ2VyLCBtb3ZlLCB1cCwgY2FuY2VsO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcblxuXHRcdFx0eCA9IHRvdWNoLmNsaWVudFg7XG5cdFx0XHR5ID0gdG91Y2guY2xpZW50WTtcblx0XHRcdGN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXG5cdFx0XHRmaW5nZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHR1cCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0b3VjaDtcblxuXHRcdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXHRcdFx0XHRpZiAoIHRvdWNoLmlkZW50aWZpZXIgIT09IGZpbmdlciApIHtcblx0XHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7ICAvLyBwcmV2ZW50IGNvbXBhdGliaWxpdHkgbW91c2UgZXZlbnRcblxuXHRcdFx0XHQvLyBmb3IgdGhlIGJlbmVmaXQgb2YgbW9iaWxlIEZpcmVmb3ggYW5kIG9sZCBBbmRyb2lkIGJyb3dzZXJzLCB3ZSBuZWVkIHRoaXMgYWJzdXJkIGhhY2suXG5cdFx0XHRcdHByZXZlbnRNb3VzZWRvd25FdmVudHMgPSB0cnVlO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHByZXZlbnRNb3VzZWRvd25UaW1lb3V0ICk7XG5cblx0XHRcdFx0cHJldmVudE1vdXNlZG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cHJldmVudE1vdXNlZG93bkV2ZW50cyA9IGZhbHNlO1xuXHRcdFx0XHR9LCA0MDAgKTtcblxuXHRcdFx0XHRmaXJlKHtcblx0XHRcdFx0XHRub2RlOiBjdXJyZW50VGFyZ2V0LFxuXHRcdFx0XHRcdG9yaWdpbmFsOiBldmVudFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdH07XG5cblx0XHRcdG1vdmUgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdG91Y2g7XG5cblx0XHRcdFx0aWYgKCBldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMSB8fCBldmVudC50b3VjaGVzWzBdLmlkZW50aWZpZXIgIT09IGZpbmdlciApIHtcblx0XHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcblx0XHRcdFx0aWYgKCAoIE1hdGguYWJzKCB0b3VjaC5jbGllbnRYIC0geCApID49IGRpc3RhbmNlVGhyZXNob2xkICkgfHwgKCBNYXRoLmFicyggdG91Y2guY2xpZW50WSAtIHkgKSA+PSBkaXN0YW5jZVRocmVzaG9sZCApICkge1xuXHRcdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaGNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdH07XG5cblx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdXAsIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoY2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCBjYW5jZWwsIHRpbWVUaHJlc2hvbGQgKTtcblx0XHR9O1xuXG5cdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlICk7XG5cblxuXHRcdC8vIG5hdGl2ZSBidXR0b25zLCBhbmQgPGlucHV0IHR5cGU9J2J1dHRvbic+IGVsZW1lbnRzLCBzaG91bGQgZmlyZSBhIHRhcCBldmVudFxuXHRcdC8vIHdoZW4gdGhlIHNwYWNlIGtleSBpcyBwcmVzc2VkXG5cdFx0aWYgKCBub2RlLnRhZ05hbWUgPT09ICdCVVRUT04nIHx8IG5vZGUudHlwZSA9PT0gJ2J1dHRvbicgKSB7XG5cdFx0XHRmb2N1c0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBibHVySGFuZGxlciwga2V5ZG93bkhhbmRsZXI7XG5cblx0XHRcdFx0a2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQud2hpY2ggPT09IDMyICkgeyAvLyBzcGFjZSBrZXlcblx0XHRcdFx0XHRcdGZpcmUoe1xuXHRcdFx0XHRcdFx0XHRub2RlOiBub2RlLFxuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbDogZXZlbnRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRibHVySGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywga2V5ZG93bkhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnYmx1cicsIGJsdXJIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBrZXlkb3duSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsIGJsdXJIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fTtcblxuXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBmb2N1c0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0fVxuXG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcmRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlckRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2ZvY3VzJywgZm9jdXNIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cblx0UmFjdGl2ZS5ldmVudHMudGFwID0gdGFwO1xuXG59KSk7XG4iLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3JhY3RpdmUnLCAnaGFtbWVyanMnXSwgZmFjdG9yeSk7XG4gIH1cblxuICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkocmVxdWlyZShcIi4vLi4vcmFjdGl2ZS9yYWN0aXZlLmpzXCIpLCByZXF1aXJlKFwiLi8uLi9oYW1tZXJqcy9oYW1tZXIuanNcIikpO1xuICB9XG5cbiAgZWxzZSB7XG4gICAgZmFjdG9yeShyb290LlJhY3RpdmUsIHJvb3QuSGFtbWVyKTtcbiAgfVxuXG59KHRoaXMsIGZ1bmN0aW9uIChSYWN0aXZlLCBIYW1tZXIpIHtcblxuICAvLyBDaGVjayB0aGUgcmVjb2duaXplcnMgZG9jdW1lbnRhdGlvbi5cbiAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXRhcFxuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICB0YXA6IHtcbiAgICAgIHJlY29nbml6ZXJDbGFzczogSGFtbWVyLlRhcCxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdGltZTogNTAwXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgICd0YXAnIFxuICAgICAgXVxuICAgIH0sXG4gICAgZG91YmxldGFwOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5UYXAsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHRhcHM6IDIsXG4gICAgICAgIGV2ZW50OiAnZG91YmxldGFwJ1xuICAgICAgfSxcbiAgICAgIHJlY29nbml6ZVdpdGg6IFsndGFwJ10sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAgJ2RvdWJsZXRhcCcgXG4gICAgICBdXG4gICAgfSxcbiAgICBzd2lwZToge1xuICAgICAgcmVjb2duaXplckNsYXNzOiBIYW1tZXIuU3dpcGUsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAnc3dpcGUnLFxuICAgICAgICAnc3dpcGVsZWZ0JyxcbiAgICAgICAgJ3N3aXBlcmlnaHQnLFxuICAgICAgICAnc3dpcGV1cCcsXG4gICAgICAgICdzd2lwZWRvd24nIFxuICAgICAgXVxuICAgIH0sXG4gICAgcGFuOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5QYW4sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgICB9LFxuICAgICAgcmVjb2duaXplV2l0aDogWydzd2lwZSddLFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgICdwYW4nLFxuICAgICAgICAncGFuc3RhcnQnLFxuICAgICAgICAncGFubW92ZScsXG4gICAgICAgICdwYW5lbmQnLFxuICAgICAgICAncGFuY2FuY2VsJyxcbiAgICAgICAgJ3BhbmxlZnQnLFxuICAgICAgICAncGFucmlnaHQnLFxuICAgICAgICAncGFudXAnLFxuICAgICAgICAncGFuZG93bicgXG4gICAgICBdXG4gICAgfSxcbiAgICBwcmVzczoge1xuICAgICAgcmVjb2duaXplckNsYXNzOiBIYW1tZXIuUHJlc3MsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAncHJlc3MnIFxuICAgICAgXVxuICAgIH0sXG4gICAgcm90YXRlOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5Sb3RhdGUsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAncm90YXRlJyxcbiAgICAgICAgJ3JvdGF0ZXN0YXJ0JyxcbiAgICAgICAgJ3JvdGF0ZW1vdmUnLFxuICAgICAgICAncm90YXRlZW5kJyxcbiAgICAgICAgJ3JvdGF0ZWNhbmNlbCcgXG4gICAgICBdXG4gICAgfSxcbiAgICBwaW5jaDoge1xuICAgICAgcmVjb2duaXplckNsYXNzOiBIYW1tZXIuUGluY2gsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIHJlY29nbml6ZVdpdGg6IFsncm90YXRlJ10sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAgJ3BpbmNoJyxcbiAgICAgICAgJ3BpbmNoc3RhcnQnLFxuICAgICAgICAncGluY2htb3ZlJyxcbiAgICAgICAgJ3BpbmNoZW5kJyxcbiAgICAgICAgJ3BpbmNoY2FuY2VsJyxcbiAgICAgICAgJ3BpbmNoaW4nLFxuICAgICAgICAncGluY2hvdXQnIFxuICAgICAgXVxuICAgIH1cbiAgfTtcblxuICB2YXIgYWxpYXNlcztcblxuICAvLyBiaW5kIGFsbCBldmVudHMgdXNpbmcgYnVpbGRFdmVudFxuICBmb3IgKHZhciByZWNvZ25pemVyTmFtZSBpbiBkZWZhdWx0cykge1xuICAgIGlmICghZGVmYXVsdHMuaGFzT3duUHJvcGVydHkocmVjb2duaXplck5hbWUpKSBjb250aW51ZTtcbiAgICBcbiAgICB2YXIgZXZlbnRzID0gZGVmYXVsdHNbcmVjb2duaXplck5hbWVdLmV2ZW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYnVpbGRFdmVudChldmVudHNbaV0sIHJlY29nbml6ZXJOYW1lLCBkZWZhdWx0c1tyZWNvZ25pemVyTmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBidWlsZEV2ZW50IDogYnVpbGRFdmVudChldmVudCwgcmVjb2duaXplck5hbWUsIGNvbmZpZylcbiAgICogKHByaXZhdGUpIHJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciBidWlsZEV2ZW50LlxuICAgKlxuICAgKiAgICAgYnVpbGRFdmVudCgncGFuc3RhcnQnLCAncGFuJywgeyAuLi4gfSk7XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJ1aWxkRXZlbnQoZXZlbnROYW1lLCByZWNvZ25pemVyTmFtZSwgY29uZmlnKSB7XG4gICAgUmFjdGl2ZS5ldmVudHNbZXZlbnROYW1lXSA9IGJ1aWxkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgcmVjb2duaXplck5hbWUsIGNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogYnVpbGRFdmVudEhhbmRsZXIoKSA6IGJ1aWxkRXZlbnRIYW5kbGVyKGV2ZW50LCByZWNvZ25pemVyTmFtZSwgY29uZmlnKVxuICAgKiAocHJpdmF0ZSkgQ3JlYXRlcyB0aGUgZXZlbnQgaGFuZGxlciBmb3IgYSBnaXZlbiBgZXZlbnROYW1lYCB0aGF0IHdpbGwgYmVcbiAgICogcmVnaXN0ZXJlZCB0byBgUmFjdGl2ZS5ldmVudHNgLlxuICAgKi9cblxuICBmdW5jdGlvbiBidWlsZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIHJlY29nbml6ZXJOYW1lLCBjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGZpcmUpIHtcbiAgICAgIHZhciBoYW1tZXJNYW5hZ2VyID0gZ2V0SGFtbWVyTWFuYWdlcihub2RlKTtcblxuICAgICAgdmFyIHJlY29nbml6ZXJFeGlzdHMgPSAoaGFtbWVyTWFuYWdlci5nZXQocmVjb2duaXplck5hbWUpICE9PSBudWxsKTtcblxuICAgICAgaWYgKCFyZWNvZ25pemVyRXhpc3RzKSB7XG4gICAgICAgIC8vIGluaXQgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSBuZXcgY29uZmlnLnJlY29nbml6ZXJDbGFzcyhjb25maWcub3B0aW9ucyk7XG5cbiAgICAgICAgLy8gSGFtbWVyLlJlY29nbml6ZXIuc2V0IG1lcmdlcyBpdCBvbiB0b3Agb2YgdGhlIGRlZmF1bHRzIHN1cHBsaWVkIGFib3ZlXG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VPcHRpb25zKG5vZGUsIHJlY29nbml6ZXJOYW1lKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpXG4gICAgICAgICAgcmVjb2duaXplci5zZXQob3B0aW9ucyk7XG5cbiAgICAgICAgaGFtbWVyTWFuYWdlci5hZGQocmVjb2duaXplcik7XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVSZWNvZ25pemVXaXRoKGhhbW1lck1hbmFnZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWdpc3RlciB0aGUgaGFuZGxlclxuICAgICAgaGFtbWVyTWFuYWdlci5vbihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZpcmUoe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb3JpZ2luYWw6IGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gaGFuZGxlIGV4aXRzXG4gICAgICBmdW5jdGlvbiB0ZWFyZG93bigpIHtcbiAgICAgICAgZ2V0SGFtbWVyTWFuYWdlcihub2RlKS5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSBub2RlLl9oYW1tZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHRlYXJkb3duOiB0ZWFyZG93biB9O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlUmVjb2duaXplV2l0aCA6IHVwZGF0ZVJlY29nbml6ZVdpdGgoaGFtbWVyTWFuYWdlcilcbiAgICogKHByaXZhdGUpIFNldHMgcmVjb2duaXplV2l0aCBpZiBkZWZhdWx0cyBoYXZlIGl0XG4gICAqXG4gICAqIFNpbmNlIHdlIGFkZCByZWNvZ25pemVycyBkeW5hbWljYWxseSBhbmQgd2l0aG91dCBhbnkgc3RyaWN0IG9yZGVyLFxuICAgKiAgd2UgbmVlZCB0byBndWFyZCBhZ2FpbnN0IHRyeWluZyB0byBzZXQgYSByZXF1aXJlV2l0aCBmb3IgYSByZWNvZ25pemVyXG4gICAqICB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldC5cbiAgICogXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVSZWNvZ25pemVXaXRoKGhhbW1lck1hbmFnZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbW1lck1hbmFnZXIucmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZWNvZ25pemVyID0gaGFtbWVyTWFuYWdlci5yZWNvZ25pemVyc1tpXTtcbiAgICAgIHZhciByZWNvZ25pemVyTmFtZSA9IHJlY29nbml6ZXIub3B0aW9ucy5ldmVudDtcblxuICAgICAgaWYgKCFkZWZhdWx0c1tyZWNvZ25pemVyTmFtZV0uaGFzT3duUHJvcGVydHkoJ3JlY29nbml6ZVdpdGgnKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIHZhciByZWNvZ25pemVXaXRocyA9IGRlZmF1bHRzW3JlY29nbml6ZXJOYW1lXS5yZWNvZ25pemVXaXRoO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByZWNvZ25pemVXaXRocy5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgcmVjZ29uaXplciB3ZSdyZSB0cnlpbmcgdG8gZGVwZW5kIG9uIGlzIHJlYWxseSB0aGVyZVxuICAgICAgICBpZiAoIWhhbW1lck1hbmFnZXIuZ2V0KHJlY29nbml6ZVdpdGhzW2tdKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gSXQncyBzYWZlIHRvIHJlY29nbml6ZVdpdGggbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJlY29nbml6ZXJcbiAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKHJlY29nbml6ZVdpdGhzW2tdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcGFyc2VPcHRpb25zIDogcGFyc2VPcHRpb25zKG5vZGUsIGtleSlcbiAgICogKHByaXZhdGUpIFJldHVybnMgb3B0aW9ucyBmb3IgYSBnaXZlbiBET00gbm9kZS5cbiAgICpcbiAgICogICAgIG5vZGUgPSA8ZGl2IGRhdGEtc3dpcGUtZGlyZWN0aW9uPSdsZWZ0JyBkYXRhLXN3aXBlLXRocmVzaG9sZD0nMic+XG4gICAqXG4gICAqICAgICBwYXJzZU9wdGlvbnMobm9kZSwgJ3N3aXBlJylcbiAgICogICAgID0+IHsgZGlyZWN0aW9uOiAnbGVmdCcsIHRocmVzaG9sZDogMiB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhub2RlLCBrZXkpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKFwiXig/OmRhdGEtKT9cIitrZXkrXCItKC4qKSRcIik7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldLFxuICAgICAgICAgIG0gPSBhdHRyLm5hbWUubWF0Y2gocmUpO1xuXG4gICAgICBpZiAoIW0pIGNvbnRpbnVlO1xuICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgb3V0cHV0W21bMV1dID0gcGFyc2VIYW1tZXJWYWx1ZShhdHRyLnZhbHVlLCBtWzFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlSGFtbWVyVmFsdWUgOiBwYXJzZUhhbW1lclZhbHVlKHN0ciwga2V5KVxuICAgKiAocHJpdmF0ZSkgVmFsdWUtaXplcyBhIGdpdmVuIHN0cmluZyBgc3RyYCwgY29udmVydGluZyBpdCB0byBhIG51bWJlciBhc1xuICAgKiBuZWVkZWQuIElmIGBrZXlgIGlzIGdpdmVuLCBpdCBjYW4gYWxzbyByZXNvbHZlIGFsaWFzZXMgZm9yIHRoYXQgZ2l2ZW5cbiAgICoga2V5LlxuICAgKlxuICAgKiBVc2VkIGJ5IGBnZXREYXRhKClgLiBcbiAgICpcbiAgICogICAgIHBhcnNlSGFtbWVyVmFsdWUoXCIxMDBcIikgICA9PiAxMDBcbiAgICogICAgIHBhcnNlSGFtbWVyVmFsdWUoXCJyaWdodFwiKSA9PiBcInJpZ2h0XCJcbiAgICogICAgIHBhcnNlSGFtbWVyVmFsdWUoXCJyaWdodFwiLCBcImRpcmVjdGlvblwiKSA9PiBIYW1tZXIuRElSRUNUSU9OX1JJR0hUXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGFtbWVyVmFsdWUoc3RyLCBrZXkpIHtcbiAgICBpZiAoc3RyLm1hdGNoICYmIHN0ci5tYXRjaCgvXi0/XFxkKyg/OlxcLlxcZCspPyQvKSkgcmV0dXJuICtzdHI7XG4gICAgcmV0dXJuIChhbGlhc2VzW2tleV0gJiYgYWxpYXNlc1trZXldW3N0cl0pIHx8XG4gICAgICBhbGlhc2VzLmFsbFtzdHJdIHx8IHN0cjtcbiAgfVxuXG4gIC8qXG4gICAqIEFsaWFzZXMgZm9yIGB2YWwoKWAuXG4gICAqL1xuXG4gIGFsaWFzZXMgPSB7XG4gICAgYWxsOiB7XG4gICAgICAndHJ1ZSc6IHRydWUsXG4gICAgICAnZmFsc2UnOiBmYWxzZSxcbiAgICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWQsXG4gICAgICAnbnVsbCc6IG51bGxcbiAgICB9LFxuICAgIGRpcmVjdGlvbjoge1xuICAgICAgJ25vbmUnOiBIYW1tZXIuRElSRUNUSU9OX05PTkUsXG4gICAgICAnYWxsJzogSGFtbWVyLkRJUkVDVElPTl9BTEwsXG4gICAgICAndXAnOiBIYW1tZXIuRElSRUNUSU9OX1VQLFxuICAgICAgJ2Rvd24nOiBIYW1tZXIuRElSRUNUSU9OX0RPV04sXG4gICAgICAnbGVmdCc6IEhhbW1lci5ESVJFQ1RJT05fTEVGVCxcbiAgICAgICdyaWdodCc6IEhhbW1lci5ESVJFQ1RJT05fUklHSFQsXG4gICAgICAnaG9yaXpvbnRhbCc6IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICAgICd2ZXJ0aWNhbCc6IEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUxcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGdldEhhbW1lck1hbmFnZXIgOiBnZXRIYW1tZXJNYW5hZ2VyKG5vZGUpXG4gICAqIChwcml2YXRlKSBSZXR1cm5zIHRoZSBgSGFtbWVyTWFuYWdlcmAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBub2RlLlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRIYW1tZXJNYW5hZ2VyKG5vZGUpIHtcbiAgICBpZiAobm9kZS5faGFtbWVyKSByZXR1cm4gbm9kZS5faGFtbWVyO1xuXG4gICAgbm9kZS5faGFtbWVyID0gbmV3IEhhbW1lci5NYW5hZ2VyKG5vZGUsIHtyZWNvZ25pemVyczogW119KTtcbiAgICByZXR1cm4gbm9kZS5faGFtbWVyO1xuICB9XG5cblxuICByZXR1cm4ge2RlZmF1bHRzOiBkZWZhdWx0c307XG5cbn0pKTtcbiIsIi8qXG5cblx0cmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlXG5cdD09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFZlcnNpb24gMC4xLjIuXG5cblx0VGhpcyBwbHVnaW4gZG9lcyBleGFjdGx5IHdoYXQgaXQgc2F5cyBvbiB0aGUgdGluIC0gaXQgZmFkZXMgZWxlbWVudHNcblx0aW4gYW5kIG91dCwgdXNpbmcgQ1NTIHRyYW5zaXRpb25zLiBZb3UgY2FuIGNvbnRyb2wgdGhlIGZvbGxvd2luZ1xuXHRwcm9wZXJ0aWVzOiBgZHVyYXRpb25gLCBgZGVsYXlgIGFuZCBgZWFzaW5nYCAod2hpY2ggbXVzdCBiZSBhIHZhbGlkXG5cdENTUyB0cmFuc2l0aW9uIHRpbWluZyBmdW5jdGlvbiwgYW5kIGRlZmF1bHRzIHRvIGBsaW5lYXJgKS5cblxuXHRUaGUgYGR1cmF0aW9uYCBwcm9wZXJ0eSBpcyBpbiBtaWxsaXNlY29uZHMsIGFuZCBkZWZhdWx0cyB0byAzMDAgKHlvdVxuXHRjYW4gYWxzbyB1c2UgYGZhc3RgIG9yIGBzbG93YCBpbnN0ZWFkIG9mIGEgbWlsbGlzZWNvbmQgdmFsdWUsIHdoaWNoXG5cdGVxdWF0ZSB0byAyMDAgYW5kIDYwMCByZXNwZWN0aXZlbHkpLiBBcyBhIHNob3J0aGFuZCwgeW91IGNhbiB1c2Vcblx0YGludHJvPSdmYWRlOjUwMCdgIGluc3RlYWQgb2YgYGludHJvPSdmYWRlOntcImR1cmF0aW9uXCI6NTAwfSdgIC0gdGhpc1xuXHRhcHBsaWVzIHRvIG1hbnkgb3RoZXIgdHJhbnNpdGlvbiBwbHVnaW5zIGFzIHdlbGwuXG5cblx0SWYgYW4gZWxlbWVudCBoYXMgYW4gb3BhY2l0eSBvdGhlciB0aGFuIDEgKHdoZXRoZXIgZGlyZWN0bHksIGJlY2F1c2Vcblx0b2YgYW4gaW5saW5lIHN0eWxlLCBvciBpbmRpcmVjdGx5IGJlY2F1c2Ugb2YgYSBDU1MgcnVsZSksIGl0IHdpbGwgYmVcblx0cmVzcGVjdGVkLiBZb3UgY2FuIG92ZXJyaWRlIHRoZSB0YXJnZXQgb3BhY2l0eSBvZiBhbiBpbnRybyBmYWRlIGJ5XG5cdHNwZWNpZnlpbmcgYSBgdG9gIHByb3BlcnR5IGJldHdlZW4gMCBhbmQgMS5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFRyb3VibGVzaG9vdGluZzogSWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIHN5c3RlbSBpbiB5b3VyIGFwcCAoQU1EIG9yXG5cdHNvbWV0aGluZyBtb3JlIG5vZGV5KSB0aGVuIHlvdSBtYXkgbmVlZCB0byBjaGFuZ2UgdGhlIHBhdGhzIGJlbG93LFxuXHR3aGVyZSBpdCBzYXlzIGByZXF1aXJlKCAnUmFjdGl2ZScgKWAgb3IgYGRlZmluZShbICdSYWN0aXZlJyBdLi4uKWAuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRVc2FnZTogSW5jbHVkZSB0aGlzIGZpbGUgb24geW91ciBwYWdlIGJlbG93IFJhY3RpdmUsIGUuZzpcblxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLmpzJz48L3NjcmlwdD5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlLmpzJz48L3NjcmlwdD5cblxuXHRPciwgaWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIGxvYWRlciwgcmVxdWlyZSB0aGlzIG1vZHVsZTpcblxuXHQgICAgLy8gcmVxdWlyaW5nIHRoZSBwbHVnaW4gd2lsbCAnYWN0aXZhdGUnIGl0IC0gbm8gbmVlZCB0byB1c2Vcblx0ICAgIC8vIHRoZSByZXR1cm4gdmFsdWVcblx0ICAgIHJlcXVpcmUoICdyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUnICk7XG5cblx0QWRkIGEgZmFkZSB0cmFuc2l0aW9uIGxpa2Ugc286XG5cblx0ICAgIDxkaXYgaW50cm89J2ZhZGUnPnRoaXMgd2lsbCBmYWRlIGluPC9kaXY+XG5cbiovXG5cbihmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gQ29tbW9uIEpTIChpLmUuIGJyb3dzZXJpZnkpIGVudmlyb25tZW50XG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0ZmFjdG9yeSggcmVxdWlyZSggXCIuLy4uL3JhY3RpdmUvcmFjdGl2ZS5qc1wiICkgKTtcblx0fVxuXG5cdC8vIEFNRD9cblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoWyAncmFjdGl2ZScgXSwgZmFjdG9yeSApO1xuXHR9XG5cblx0Ly8gYnJvd3NlciBnbG9iYWxcblx0ZWxzZSBpZiAoIGdsb2JhbC5SYWN0aXZlICkge1xuXHRcdGZhY3RvcnkoIGdsb2JhbC5SYWN0aXZlICk7XG5cdH1cblxuXHRlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBSYWN0aXZlISBJdCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhlIHJhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZSBwbHVnaW4nICk7XG5cdH1cblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJhY3RpdmUgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBmYWRlLCBkZWZhdWx0cztcblxuXHRkZWZhdWx0cyA9IHtcblx0XHRkZWxheTogMCxcblx0XHRkdXJhdGlvbjogMzAwLFxuXHRcdGVhc2luZzogJ2xpbmVhcidcblx0fTtcblxuXHRmYWRlID0gZnVuY3Rpb24gKCB0LCBwYXJhbXMgKSB7XG5cdFx0dmFyIHRhcmdldE9wYWNpdHk7XG5cblx0XHRwYXJhbXMgPSB0LnByb2Nlc3NQYXJhbXMoIHBhcmFtcywgZGVmYXVsdHMgKTtcblxuXHRcdGlmICggdC5pc0ludHJvICkge1xuXHRcdFx0dGFyZ2V0T3BhY2l0eSA9IHQuZ2V0U3R5bGUoICdvcGFjaXR5JyApO1xuXHRcdFx0dC5zZXRTdHlsZSggJ29wYWNpdHknLCAwICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldE9wYWNpdHkgPSAwO1xuXHRcdH1cblxuXHRcdHQuYW5pbWF0ZVN0eWxlKCAnb3BhY2l0eScsIHRhcmdldE9wYWNpdHksIHBhcmFtcyApLnRoZW4oIHQuY29tcGxldGUgKTtcblx0fTtcblxuXHRSYWN0aXZlLnRyYW5zaXRpb25zLmZhZGUgPSBmYWRlO1xuXG59KSk7XG4iLCIvKlxuXG5cdHJhY3RpdmUtdHJhbnNpdGlvbnMtZmx5XG5cdD09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VmVyc2lvbiAwLjEuMy5cblxuXHRUaGlzIHRyYW5zaXRpb24gdXNlcyBDU1MgdHJhbnNmb3JtcyB0byAnZmx5JyBlbGVtZW50cyB0byB0aGVpclxuXHRuYXR1cmFsIGxvY2F0aW9uIG9uIHRoZSBwYWdlLCBmYWRpbmcgaW4gZnJvbSB0cmFuc3BhcmVudCBhcyB0aGV5IGdvLlxuXHRCeSBkZWZhdWx0LCB0aGV5IHdpbGwgZmx5IGluIGZyb20gbGVmdC5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFRyb3VibGVzaG9vdGluZzogSWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIHN5c3RlbSBpbiB5b3VyIGFwcCAoQU1EIG9yXG5cdHNvbWV0aGluZyBtb3JlIG5vZGV5KSB0aGVuIHlvdSBtYXkgbmVlZCB0byBjaGFuZ2UgdGhlIHBhdGhzIGJlbG93LFxuXHR3aGVyZSBpdCBzYXlzIGByZXF1aXJlKCAncmFjdGl2ZScgKWAgb3IgYGRlZmluZShbICdyYWN0aXZlJyBdLi4uKWAuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRVc2FnZTogSW5jbHVkZSB0aGlzIGZpbGUgb24geW91ciBwYWdlIGJlbG93IFJhY3RpdmUsIGUuZzpcblxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLmpzJz48L3NjcmlwdD5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS10cmFuc2l0aW9ucy1mbHkuanMnPjwvc2NyaXB0PlxuXG5cdE9yLCBpZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgbG9hZGVyLCByZXF1aXJlIHRoaXMgbW9kdWxlOlxuXG5cdCAgICAvLyByZXF1aXJpbmcgdGhlIHBsdWdpbiB3aWxsICdhY3RpdmF0ZScgaXQgLSBubyBuZWVkIHRvIHVzZVxuXHQgICAgLy8gdGhlIHJldHVybiB2YWx1ZVxuXHQgICAgcmVxdWlyZSggJ3JhY3RpdmUtdHJhbnNpdGlvbnMtZmx5JyApO1xuXG5cdFlvdSBjYW4gYWRqdXN0IHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogYHhgLCBgeWAsIGBkdXJhdGlvbmAsXG5cdGBkZWxheWAgYW5kIGBlYXNpbmdgLlxuXG4qL1xuXG4oZnVuY3Rpb24gKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIENvbW1vbiBKUyAoaS5lLiBicm93c2VyaWZ5KSBlbnZpcm9ubWVudFxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdGZhY3RvcnkoIHJlcXVpcmUoIFwiLi8uLi9yYWN0aXZlL3JhY3RpdmUuanNcIiApICk7XG5cdH1cblxuXHQvLyBBTUQ/XG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKFsgJ3JhY3RpdmUnIF0sIGZhY3RvcnkgKTtcblx0fVxuXG5cdC8vIGJyb3dzZXIgZ2xvYmFsXG5cdGVsc2UgaWYgKCBnbG9iYWwuUmFjdGl2ZSApIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwuUmFjdGl2ZSApO1xuXHR9XG5cblx0ZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgUmFjdGl2ZSEgSXQgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIHRoZSByYWN0aXZlLXRyYW5zaXRpb25zLWZseSBwbHVnaW4nICk7XG5cdH1cblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJhY3RpdmUgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBmbHksIGFkZFB4LCBkZWZhdWx0cztcblxuXHRkZWZhdWx0cyA9IHtcblx0XHRkdXJhdGlvbjogODAwLFxuXHRcdGVhc2luZzogJ2N1YmljLWJlemllcigwLjc3MCwgMC4wMDAsIDAuMTc1LCAxLjAwMCknLFxuXHRcdHg6IC01MDAsXG5cdFx0eTogMFxuXHR9O1xuXG5cdGFkZFB4ID0gZnVuY3Rpb24gKCBudW0gKSB7XG5cdFx0aWYgKCBudW0gPT09IDAgfHwgdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRyZXR1cm4gbnVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBudW0gKyAncHgnO1xuXHR9O1xuXG5cdGZseSA9IGZ1bmN0aW9uICggdCwgcGFyYW1zICkge1xuXHRcdHZhciB4LCB5LCBvZmZzY3JlZW4sIHRhcmdldDtcblxuXHRcdHBhcmFtcyA9IHQucHJvY2Vzc1BhcmFtcyggcGFyYW1zLCBkZWZhdWx0cyApO1xuXG5cdFx0eCA9IGFkZFB4KCBwYXJhbXMueCApO1xuXHRcdHkgPSBhZGRQeCggcGFyYW1zLnkgKTtcblxuXHRcdG9mZnNjcmVlbiA9IHtcblx0XHRcdHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKSdcblx0XHR9O1xuXG5cdFx0aWYgKCB0LmlzSW50cm8gKSB7XG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSBjdXJyZW50IHN0eWxlXG5cdFx0XHR0YXJnZXQgPSB0LmdldFN0eWxlKFsgJ3RyYW5zZm9ybScgXSk7XG5cblx0XHRcdC8vIHNldCBvZmZzY3JlZW4gc3R5bGVcblx0XHRcdHQuc2V0U3R5bGUoIG9mZnNjcmVlbiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQgPSBvZmZzY3JlZW47XG5cdFx0fVxuXG5cdFx0dC5hbmltYXRlU3R5bGUoIHRhcmdldCwgcGFyYW1zICkudGhlbiggdC5jb21wbGV0ZSApO1xuXHR9O1xuXG5cdFJhY3RpdmUudHJhbnNpdGlvbnMuZmx5ID0gZmx5O1xuXG59KSk7XG4iLCIvKlxuXG5cdHJhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGVcblx0PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFZlcnNpb24gMC4xLjIuXG5cblx0VGhpcyB0cmFuc2l0aW9uIHNsaWRlcyBhbiBlbGVtZW50IGluIGFuZCBvdXQgb2Ygdmlldyxcblx0dXNpbmcgQ1NTIHRyYW5zaXRpb25zIHdoZXJlIHBvc3NpYmxlLlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VHJvdWJsZXNob290aW5nOiBJZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgc3lzdGVtIGluIHlvdXIgYXBwIChBTUQgb3Jcblx0c29tZXRoaW5nIG1vcmUgbm9kZXkpIHRoZW4geW91IG1heSBuZWVkIHRvIGNoYW5nZSB0aGUgcGF0aHMgYmVsb3csXG5cdHdoZXJlIGl0IHNheXMgYHJlcXVpcmUoICdyYWN0aXZlJyApYCBvciBgZGVmaW5lKFsgJ3JhY3RpdmUnIF0uLi4pYC5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFVzYWdlOiBJbmNsdWRlIHRoaXMgZmlsZSBvbiB5b3VyIHBhZ2UgYmVsb3cgUmFjdGl2ZSwgZS5nOlxuXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUuanMnPjwvc2NyaXB0PlxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLXRyYW5zaXRpb25zLXNsaWRlLmpzJz48L3NjcmlwdD5cblxuXHRPciwgaWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIGxvYWRlciwgcmVxdWlyZSB0aGlzIG1vZHVsZTpcblxuXHQgICAgLy8gcmVxdWlyaW5nIHRoZSBwbHVnaW4gd2lsbCAnYWN0aXZhdGUnIGl0IC0gbm8gbmVlZCB0byB1c2Vcblx0ICAgIC8vIHRoZSByZXR1cm4gdmFsdWVcblx0ICAgIHJlcXVpcmUoICdyYWN0aXZlLXRyYW5zaXRpb25zLXNsaWRlJyApO1xuXG5cdFlvdSBjYW4gc3BlY2lmeSB0aGUgYGRlbGF5YCwgYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllc1xuXHR1c2luZyB0aGUgY29udmVudGlvbmFsIHN5bnRheDpcblxuXHQgICAgPGRpdiBpbnRybz0nc2xpZGU6e1wiZGVsYXlcIjo1MDAsXCJlYXNpbmdcIjpcImVhc2Utb3V0XCJ9Jz5jb250ZW50PC9kaXY+XG5cblx0Qm90aCBgZGVsYXlgIGFuZCBgZHVyYXRpb25gIGFyZSBpbiBtaWxsaXNlY29uZHMuIFRoZSBgZWFzaW5nYCB2YWx1ZVxuXHRtdXN0IGJlIGEgdmFsaWQgQ1NTIGVhc2luZyBmdW5jdGlvbiAoc2VlIGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLykuXG5cbiovXG5cbihmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gQ29tbW9uIEpTIChpLmUuIGJyb3dzZXJpZnkpIGVudmlyb25tZW50XG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0ZmFjdG9yeSggcmVxdWlyZSggXCIuLy4uL3JhY3RpdmUvcmFjdGl2ZS5qc1wiICkgKTtcblx0fVxuXG5cdC8vIEFNRD9cblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoWyAncmFjdGl2ZScgXSwgZmFjdG9yeSApO1xuXHR9XG5cblx0Ly8gYnJvd3NlciBnbG9iYWxcblx0ZWxzZSBpZiAoIGdsb2JhbC5SYWN0aXZlICkge1xuXHRcdGZhY3RvcnkoIGdsb2JhbC5SYWN0aXZlICk7XG5cdH1cblxuXHRlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBSYWN0aXZlISBJdCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhlIHJhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGUgcGx1Z2luJyApO1xuXHR9XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKCBSYWN0aXZlICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgc2xpZGUsIHByb3BzLCBjb2xsYXBzZWQsIGRlZmF1bHRzO1xuXG5cdGRlZmF1bHRzID0ge1xuXHRcdGR1cmF0aW9uOiAzMDAsXG5cdFx0ZWFzaW5nOiAnZWFzZUluT3V0J1xuXHR9O1xuXG5cdHByb3BzID0gW1xuXHRcdCdoZWlnaHQnLFxuXHRcdCdib3JkZXJUb3BXaWR0aCcsXG5cdFx0J2JvcmRlckJvdHRvbVdpZHRoJyxcblx0XHQncGFkZGluZ1RvcCcsXG5cdFx0J3BhZGRpbmdCb3R0b20nLFxuXHRcdCdtYXJnaW5Ub3AnLFxuXHRcdCdtYXJnaW5Cb3R0b20nXG5cdF07XG5cblx0Y29sbGFwc2VkID0ge1xuXHRcdGhlaWdodDogMCxcblx0XHRib3JkZXJUb3BXaWR0aDogMCxcblx0XHRib3JkZXJCb3R0b21XaWR0aDogMCxcblx0XHRwYWRkaW5nVG9wOiAwLFxuXHRcdHBhZGRpbmdCb3R0b206IDAsXG5cdFx0bWFyZ2luVG9wOiAwLFxuXHRcdG1hcmdpbkJvdHRvbTogMFxuXHR9O1xuXG5cdHNsaWRlID0gZnVuY3Rpb24gKCB0LCBwYXJhbXMgKSB7XG5cdFx0dmFyIHRhcmdldFN0eWxlO1xuXG5cdFx0cGFyYW1zID0gdC5wcm9jZXNzUGFyYW1zKCBwYXJhbXMsIGRlZmF1bHRzICk7XG5cblx0XHRpZiAoIHQuaXNJbnRybyApIHtcblx0XHRcdHRhcmdldFN0eWxlID0gdC5nZXRTdHlsZSggcHJvcHMgKTtcblx0XHRcdHQuc2V0U3R5bGUoIGNvbGxhcHNlZCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBtYWtlIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSdyZSBub3QgdHJhbnNpdGlvbmluZyB0byAnYXV0bydcblx0XHRcdHQuc2V0U3R5bGUoIHQuZ2V0U3R5bGUoIHByb3BzICkgKTtcblx0XHRcdHRhcmdldFN0eWxlID0gY29sbGFwc2VkO1xuXHRcdH1cblxuXHRcdHQuc2V0U3R5bGUoICdvdmVyZmxvd1knLCAnaGlkZGVuJyApO1xuXG5cdFx0dC5hbmltYXRlU3R5bGUoIHRhcmdldFN0eWxlLCBwYXJhbXMgKS50aGVuKCB0LmNvbXBsZXRlICk7XG5cdH07XG5cblx0UmFjdGl2ZS50cmFuc2l0aW9ucy5zbGlkZSA9IHNsaWRlO1xuXG59KSk7XG4iLCIvKlxuXHRyYWN0aXZlLmpzIHYwLjYuMVxuXHQyMDE0LTEwLTI1IC0gY29tbWl0IDNhNTc2ZWIzIFxuXG5cdGh0dHA6Ly9yYWN0aXZlanMub3JnXG5cdGh0dHA6Ly90d2l0dGVyLmNvbS9SYWN0aXZlSlNcblxuXHRSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuXG4oIGZ1bmN0aW9uKCBnbG9iYWwgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBub0NvbmZsaWN0ID0gZ2xvYmFsLlJhY3RpdmU7XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL29wdGlvbnMuanMgKi9cblx0dmFyIG9wdGlvbnMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRcdC8vIHJlbmRlciBwbGFjZW1lbnQ6XG5cdFx0XHRlbDogdm9pZCAwLFxuXHRcdFx0YXBwZW5kOiBmYWxzZSxcblx0XHRcdC8vIHRlbXBsYXRlOlxuXHRcdFx0dGVtcGxhdGU6IHtcblx0XHRcdFx0djogMSxcblx0XHRcdFx0dDogW11cblx0XHRcdH0sXG5cdFx0XHR5aWVsZDogbnVsbCxcblx0XHRcdC8vIHBhcnNlOlxuXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlOiBmYWxzZSxcblx0XHRcdHNhbml0aXplOiBmYWxzZSxcblx0XHRcdHN0cmlwQ29tbWVudHM6IHRydWUsXG5cdFx0XHQvLyBkYXRhICYgYmluZGluZzpcblx0XHRcdGRhdGE6IHt9LFxuXHRcdFx0Y29tcHV0ZWQ6IHt9LFxuXHRcdFx0bWFnaWM6IGZhbHNlLFxuXHRcdFx0bW9kaWZ5QXJyYXlzOiB0cnVlLFxuXHRcdFx0YWRhcHQ6IFtdLFxuXHRcdFx0aXNvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0dHdvd2F5OiB0cnVlLFxuXHRcdFx0bGF6eTogZmFsc2UsXG5cdFx0XHQvLyB0cmFuc2l0aW9uczpcblx0XHRcdG5vSW50cm86IGZhbHNlLFxuXHRcdFx0dHJhbnNpdGlvbnNFbmFibGVkOiB0cnVlLFxuXHRcdFx0Y29tcGxldGU6IHZvaWQgMCxcblx0XHRcdC8vIGNzczpcblx0XHRcdG5vQ3NzVHJhbnNmb3JtOiBmYWxzZSxcblx0XHRcdC8vIGRlYnVnOlxuXHRcdFx0ZGVidWc6IGZhbHNlXG5cdFx0fTtcblx0XHRyZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG5cdH0oKTtcblxuXHQvKiBjb25maWcvZGVmYXVsdHMvZWFzaW5nLmpzICovXG5cdHZhciBlYXNpbmcgPSB7XG5cdFx0bGluZWFyOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0cmV0dXJuIHBvcztcblx0XHR9LFxuXHRcdGVhc2VJbjogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyggcG9zLCAzICk7XG5cdFx0fSxcblx0XHRlYXNlT3V0OiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0cmV0dXJuIE1hdGgucG93KCBwb3MgLSAxLCAzICkgKyAxO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0OiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0aWYgKCAoIHBvcyAvPSAwLjUgKSA8IDEgKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdyggcG9zLCAzICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKCBNYXRoLnBvdyggcG9zIC0gMiwgMyApICsgMiApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBjaXJjdWxhci5qcyAqL1xuXHR2YXIgY2lyY3VsYXIgPSBbXTtcblxuXHQvKiB1dGlscy9oYXNPd25Qcm9wZXJ0eS5qcyAqL1xuXHR2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKiB1dGlscy9pc0FycmF5LmpzICovXG5cdHZhciBpc0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcdC8vIHRoYW5rcywgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaW5zdGFuY2VvZi1jb25zaWRlcmVkLWhhcm1mdWwtb3ItaG93LXRvLXdyaXRlLWEtcm9idXN0LWlzYXJyYXkvXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdHJldHVybiB0b1N0cmluZy5jYWxsKCB0aGluZyApID09PSAnW29iamVjdCBBcnJheV0nO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB1dGlscy9pc09iamVjdC5qcyAqL1xuXHR2YXIgaXNPYmplY3QgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdHJldHVybiB0aGluZyAmJiB0b1N0cmluZy5jYWxsKCB0aGluZyApID09PSAnW29iamVjdCBPYmplY3RdJztcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvaXNOdW1lcmljLmpzICovXG5cdHZhciBpc051bWVyaWMgPSBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdCggdGhpbmcgKSApICYmIGlzRmluaXRlKCB0aGluZyApO1xuXHR9O1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9pbnRlcnBvbGF0b3JzLmpzICovXG5cdHZhciBpbnRlcnBvbGF0b3JzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBoYXNPd25Qcm9wZXJ0eSwgaXNBcnJheSwgaXNPYmplY3QsIGlzTnVtZXJpYyApIHtcblxuXHRcdHZhciBpbnRlcnBvbGF0b3JzLCBpbnRlcnBvbGF0ZSwgY3NzTGVuZ3RoUGF0dGVybjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGludGVycG9sYXRlID0gY2lyY3VsYXIuaW50ZXJwb2xhdGU7XG5cdFx0fSApO1xuXHRcdGNzc0xlbmd0aFBhdHRlcm4gPSAvXihbKy1dP1swLTldK1xcLj8oPzpbMC05XSspPykocHh8ZW18ZXh8JXxpbnxjbXxtbXxwdHxwYykkLztcblx0XHRpbnRlcnBvbGF0b3JzID0ge1xuXHRcdFx0bnVtYmVyOiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBkZWx0YTtcblx0XHRcdFx0aWYgKCAhaXNOdW1lcmljKCBmcm9tICkgfHwgIWlzTnVtZXJpYyggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcm9tID0gK2Zyb207XG5cdFx0XHRcdHRvID0gK3RvO1xuXHRcdFx0XHRkZWx0YSA9IHRvIC0gZnJvbTtcblx0XHRcdFx0aWYgKCAhZGVsdGEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb207XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZyb20gKyB0ICogZGVsdGE7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0YXJyYXk6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIGludGVybWVkaWF0ZSwgaW50ZXJwb2xhdG9ycywgbGVuLCBpO1xuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBmcm9tICkgfHwgIWlzQXJyYXkoIHRvICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW50ZXJtZWRpYXRlID0gW107XG5cdFx0XHRcdGludGVycG9sYXRvcnMgPSBbXTtcblx0XHRcdFx0aSA9IGxlbiA9IE1hdGgubWluKCBmcm9tLmxlbmd0aCwgdG8ubGVuZ3RoICk7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGludGVycG9sYXRvcnNbIGkgXSA9IGludGVycG9sYXRlKCBmcm9tWyBpIF0sIHRvWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzdXJwbHVzIHZhbHVlcyAtIGRvbid0IGludGVycG9sYXRlLCBidXQgZG9uJ3QgZXhjbHVkZSB0aGVtIGVpdGhlclxuXHRcdFx0XHRmb3IgKCBpID0gbGVuOyBpIDwgZnJvbS5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IGZyb21bIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBpID0gbGVuOyBpIDwgdG8ubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSB0b1sgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHR2YXIgaSA9IGxlbjtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gaW50ZXJwb2xhdG9yc1sgaSBdKCB0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0b2JqZWN0OiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBwcm9wZXJ0aWVzLCBsZW4sIGludGVycG9sYXRvcnMsIGludGVybWVkaWF0ZSwgcHJvcDtcblx0XHRcdFx0aWYgKCAhaXNPYmplY3QoIGZyb20gKSB8fCAhaXNPYmplY3QoIHRvICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvcGVydGllcyA9IFtdO1xuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSB7fTtcblx0XHRcdFx0aW50ZXJwb2xhdG9ycyA9IHt9O1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIGZyb20gKSB7XG5cdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCBmcm9tLCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHRvLCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzWyBwcm9wIF0gPSBpbnRlcnBvbGF0ZSggZnJvbVsgcHJvcCBdLCB0b1sgcHJvcCBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IGZyb21bIHByb3AgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggcHJvcCBpbiB0byApIHtcblx0XHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHRvLCBwcm9wICkgJiYgIWhhc093blByb3BlcnR5LmNhbGwoIGZyb20sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gdG9bIHByb3AgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHR2YXIgaSA9IGxlbixcblx0XHRcdFx0XHRcdHByb3A7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1sgaSBdO1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSBpbnRlcnBvbGF0b3JzWyBwcm9wIF0oIHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBpbnRlcnBvbGF0b3JzO1xuXHR9KCBjaXJjdWxhciwgaGFzT3duLCBpc0FycmF5LCBpc09iamVjdCwgaXNOdW1lcmljICk7XG5cblx0LyogY29uZmlnL3N2Zy5qcyAqL1xuXHR2YXIgc3ZnID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3ZnO1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHN2ZyA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdmcgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCAnaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZScsICcxLjEnICk7XG5cdFx0fVxuXHRcdHJldHVybiBzdmc7XG5cdH0oKTtcblxuXHQvKiB1dGlscy93YXJuLmpzICovXG5cdHZhciB3YXJuID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvKiBnbG9iYWwgY29uc29sZSAqL1xuXHRcdHZhciB3YXJuLCB3YXJuZWQgPSB7fTtcblx0XHRpZiAoIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25zb2xlLndhcm4uYXBwbHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR3YXJuID0gZnVuY3Rpb24oIG1lc3NhZ2UsIGFsbG93RHVwbGljYXRlcyApIHtcblx0XHRcdFx0aWYgKCAhYWxsb3dEdXBsaWNhdGVzICkge1xuXHRcdFx0XHRcdGlmICggd2FybmVkWyBtZXNzYWdlIF0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdhcm5lZFsgbWVzc2FnZSBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLndhcm4oICclY1JhY3RpdmUuanM6ICVjJyArIG1lc3NhZ2UsICdjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7JywgJ2NvbG9yOiByZ2IoODUsIDg1LCA4NSk7JyApO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2FybiA9IGZ1bmN0aW9uKCkge307XG5cdFx0fVxuXHRcdHJldHVybiB3YXJuO1xuXHR9KCk7XG5cblx0LyogY29uZmlnL2Vycm9ycy5qcyAqL1xuXHR2YXIgZXJyb3JzID0ge1xuXHRcdG1pc3NpbmdQYXJzZXI6ICdNaXNzaW5nIFJhY3RpdmUucGFyc2UgLSBjYW5ub3QgcGFyc2UgdGVtcGxhdGUuIEVpdGhlciBwcmVwYXJzZSBvciB1c2UgdGhlIHZlcnNpb24gdGhhdCBpbmNsdWRlcyB0aGUgcGFyc2VyJyxcblx0XHRtZXJnZUNvbXBhcmlzb25GYWlsOiAnTWVyZ2Ugb3BlcmF0aW9uOiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nJyxcblx0XHRub0NvbXBvbmVudEV2ZW50QXJndW1lbnRzOiAnQ29tcG9uZW50cyBjdXJyZW50bHkgb25seSBzdXBwb3J0IHNpbXBsZSBldmVudHMgLSB5b3UgY2Fubm90IGluY2x1ZGUgYXJndW1lbnRzLiBTb3JyeSEnLFxuXHRcdG5vVGVtcGxhdGVGb3JQYXJ0aWFsOiAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXCJ7bmFtZX1cIicsXG5cdFx0bm9OZXN0ZWRQYXJ0aWFsczogJ1BhcnRpYWxzICh7ez57bmFtZX19fSkgY2Fubm90IGNvbnRhaW4gbmVzdGVkIGlubGluZSBwYXJ0aWFscycsXG5cdFx0ZXZhbHVhdGlvbkVycm9yOiAnRXJyb3IgZXZhbHVhdGluZyBcInt1bmlxdWVTdHJpbmd9XCI6IHtlcnJ9Jyxcblx0XHRiYWRBcmd1bWVudHM6ICdCYWQgYXJndW1lbnRzIFwie2FyZ3VtZW50c31cIi4gSVxcJ20gbm90IGFsbG93ZWQgdG8gYXJndWUgdW5sZXNzIHlvdVxcJ3ZlIHBhaWQuJyxcblx0XHRmYWlsZWRDb21wdXRhdGlvbjogJ0ZhaWxlZCB0byBjb21wdXRlIFwie2tleX1cIjoge2Vycn0nLFxuXHRcdG1pc3NpbmdQbHVnaW46ICdNaXNzaW5nIFwie25hbWV9XCIge3BsdWdpbn0gcGx1Z2luLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSB7cGx1Z2lufSB2aWEgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvcGx1Z2lucyN7cGx1Z2lufXMnLFxuXHRcdGJhZFJhZGlvSW5wdXRCaW5kaW5nOiAnQSByYWRpbyBpbnB1dCBjYW4gaGF2ZSB0d28td2F5IGJpbmRpbmcgb24gaXRzIG5hbWUgYXR0cmlidXRlLCBvciBpdHMgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aCcsXG5cdFx0bm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuOiAnQSBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkIGZvciBcIntuYW1lfVwiIHtyZWdpc3RyeX0sIGJ1dCBubyB7cmVnaXN0cnl9IHdhcyByZXR1cm5lZCcsXG5cdFx0ZGVmYXVsdEVsU3BlY2lmaWVkOiAnVGhlIDx7bmFtZX0vPiBjb21wb25lbnQgaGFzIGEgZGVmYXVsdCBgZWxgIHByb3BlcnR5OyBpdCBoYXMgYmVlbiBkaXNyZWdhcmRlZCcsXG5cdFx0bm9FbGVtZW50UHJveHlFdmVudFdpbGRjYXJkczogJ09ubHkgY29tcG9uZW50IHByb3h5LWV2ZW50cyBtYXkgY29udGFpbiBcIipcIiB3aWxkY2FyZHMsIDx7ZWxlbWVudH0gb24te2V2ZW50fS8+IGlzIG5vdCB2YWxpZC4nLFxuXHRcdG1ldGhvZERlcHJlY2F0ZWQ6ICdUaGUgbWV0aG9kIFwie2RlcHJlY2F0ZWR9XCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBcIntyZXBsYWNlbWVudH1cIiBhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLidcblx0fTtcblxuXHQvKiB1dGlscy9sb2cuanMgKi9cblx0dmFyIGxvZyA9IGZ1bmN0aW9uKCBjb25zb2xld2FybiwgZXJyb3JzICkge1xuXG5cdFx0dmFyIGxvZyA9IHtcblx0XHRcdHdhcm46IGZ1bmN0aW9uKCBvcHRpb25zLCBwYXNzdGhydSApIHtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kZWJ1ZyAmJiAhcGFzc3RocnUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMud2FybkFsd2F5cyggb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdHdhcm5BbHdheXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmxvZ2dlciggZ2V0TWVzc2FnZSggb3B0aW9ucyApLCBvcHRpb25zLmFsbG93RHVwbGljYXRlcyApO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5lcnJvck9ubHkoIG9wdGlvbnMgKTtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLndhcm4oIG9wdGlvbnMsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGVycm9yT25seTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLmNyaXRpY2FsKCBvcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjcml0aWNhbDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciBlcnIgPSBvcHRpb25zLmVyciB8fCBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSApO1xuXHRcdFx0XHR0aGlzLnRocm93ZXIoIGVyciApO1xuXHRcdFx0fSxcblx0XHRcdGxvZ2dlcjogY29uc29sZXdhcm4sXG5cdFx0XHR0aHJvd2VyOiBmdW5jdGlvbiggZXJyICkge1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IGVycm9yc1sgb3B0aW9ucy5tZXNzYWdlIF0gfHwgb3B0aW9ucy5tZXNzYWdlIHx8ICcnO1xuXHRcdFx0cmV0dXJuIGludGVycG9sYXRlKCBtZXNzYWdlLCBvcHRpb25zLmFyZ3MgKTtcblx0XHR9XG5cdFx0Ly8gc2ltcGxlIGludGVycG9sYXRpb24uIHByb2JhYmx5IHF1aWNrZXIgKGFuZCBiZXR0ZXIpIG91dCB0aGVyZSxcblx0XHQvLyBidXQgbG9nIGlzIG5vdCBpbiBnb2xkZW4gcGF0aCBvZiBleGVjdXRpb24sIG9ubHkgZXhjZXB0aW9uc1xuXHRcdGZ1bmN0aW9uIGludGVycG9sYXRlKCBtZXNzYWdlLCBhcmdzICkge1xuXHRcdFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSggL3soW157fV0qKX0vZywgZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdHJldHVybiBhcmdzWyBiIF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2c7XG5cdH0oIHdhcm4sIGVycm9ycyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9ob29rcy9Ib29rLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHZhciBkZXByZWNhdGlvbnMgPSB7XG5cdFx0XHRjb25zdHJ1Y3Q6IHtcblx0XHRcdFx0ZGVwcmVjYXRlZDogJ2JlZm9yZUluaXQnLFxuXHRcdFx0XHRyZXBsYWNlbWVudDogJ29uY29uc3RydWN0J1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjoge1xuXHRcdFx0XHRkZXByZWNhdGVkOiAnaW5pdCcsXG5cdFx0XHRcdG1lc3NhZ2U6ICdUaGUgXCJpbml0XCIgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiAnICsgJ1lvdSBjYW4gZWl0aGVyIHVzZSB0aGUgXCJvbmluaXRcIiBtZXRob2Qgd2hpY2ggd2lsbCBmaXJlICcgKyAnb25seSBvbmNlIHByaW9yIHRvLCBhbmQgcmVnYXJkbGVzcyBvZiwgYW55IGV2ZW50dWFsIHJhY3RpdmUgJyArICdpbnN0YW5jZSBiZWluZyByZW5kZXJlZCwgb3IgaWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSAnICsgJ3JlbmRlcmVkIERPTSwgdXNlIFwib25yZW5kZXJcIiBpbnN0ZWFkLiAnICsgJ1NlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJ1xuXHRcdFx0fSxcblx0XHRcdGNvbXBsZXRlOiB7XG5cdFx0XHRcdGRlcHJlY2F0ZWQ6ICdjb21wbGV0ZScsXG5cdFx0XHRcdHJlcGxhY2VtZW50OiAnb25jb21wbGV0ZSdcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gSG9vayggZXZlbnQgKSB7XG5cdFx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHR0aGlzLm1ldGhvZCA9ICdvbicgKyBldmVudDtcblx0XHRcdHRoaXMuZGVwcmVjYXRlID0gZGVwcmVjYXRpb25zWyBldmVudCBdO1xuXHRcdH1cblx0XHRIb29rLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24oIHJhY3RpdmUsIGFyZyApIHtcblx0XHRcdGZ1bmN0aW9uIGNhbGwoIG1ldGhvZCApIHtcblx0XHRcdFx0aWYgKCByYWN0aXZlWyBtZXRob2QgXSApIHtcblx0XHRcdFx0XHRhcmcgPyByYWN0aXZlWyBtZXRob2QgXSggYXJnICkgOiByYWN0aXZlWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYWxsKCB0aGlzLm1ldGhvZCApO1xuXHRcdFx0aWYgKCAhcmFjdGl2ZVsgdGhpcy5tZXRob2QgXSAmJiB0aGlzLmRlcHJlY2F0ZSAmJiBjYWxsKCB0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkICkgKSB7XG5cdFx0XHRcdGxvZy53YXJuQWx3YXlzKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogdGhpcy5kZXByZWNhdGUubWVzc2FnZSB8fCAnbWV0aG9kRGVwcmVjYXRlZCcsXG5cdFx0XHRcdFx0YXJnczogdGhpcy5kZXByZWNhdGVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0YXJnID8gcmFjdGl2ZS5maXJlKCB0aGlzLmV2ZW50LCBhcmcgKSA6IHJhY3RpdmUuZmlyZSggdGhpcy5ldmVudCApO1xuXHRcdH07XG5cdFx0cmV0dXJuIEhvb2s7XG5cdH0oIGxvZyApO1xuXG5cdC8qIHV0aWxzL3JlbW92ZUZyb21BcnJheS5qcyAqL1xuXHR2YXIgcmVtb3ZlRnJvbUFycmF5ID0gZnVuY3Rpb24oIGFycmF5LCBtZW1iZXIgKSB7XG5cdFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZiggbWVtYmVyICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRhcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHV0aWxzL1Byb21pc2UuanMgKi9cblx0dmFyIFByb21pc2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgX1Byb21pc2UsIFBFTkRJTkcgPSB7fSxcblx0XHRcdEZVTEZJTExFRCA9IHt9LFxuXHRcdFx0UkVKRUNURUQgPSB7fTtcblx0XHRpZiAoIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gdXNlIG5hdGl2ZSBQcm9taXNlXG5cdFx0XHRfUHJvbWlzZSA9IFByb21pc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9Qcm9taXNlID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHR2YXIgZnVsZmlsbGVkSGFuZGxlcnMgPSBbXSxcblx0XHRcdFx0XHRyZWplY3RlZEhhbmRsZXJzID0gW10sXG5cdFx0XHRcdFx0c3RhdGUgPSBQRU5ESU5HLFxuXHRcdFx0XHRcdHJlc3VsdCwgZGlzcGF0Y2hIYW5kbGVycywgbWFrZVJlc29sdmVyLCBmdWxmaWwsIHJlamVjdCwgcHJvbWlzZTtcblx0XHRcdFx0bWFrZVJlc29sdmVyID0gZnVuY3Rpb24oIG5ld1N0YXRlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHN0YXRlID0gbmV3U3RhdGU7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaEhhbmRsZXJzID0gbWFrZURpc3BhdGNoZXIoIHN0YXRlID09PSBGVUxGSUxMRUQgPyBmdWxmaWxsZWRIYW5kbGVycyA6IHJlamVjdGVkSGFuZGxlcnMsIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0Ly8gZGlzcGF0Y2ggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHRcdHdhaXQoIGRpc3BhdGNoSGFuZGxlcnMgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmdWxmaWwgPSBtYWtlUmVzb2x2ZXIoIEZVTEZJTExFRCApO1xuXHRcdFx0XHRyZWplY3QgPSBtYWtlUmVzb2x2ZXIoIFJFSkVDVEVEICk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCBlcnIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRcdC8vIGB0aGVuKClgIHJldHVybnMgYSBQcm9taXNlIC0gMi4yLjdcblx0XHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJvbWlzZTIgPSBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCBoYW5kbGVyLCBoYW5kbGVycywgZm9yd2FyZCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAyLjIuMS4xXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goIGZ1bmN0aW9uKCBwMXJlc3VsdCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eCA9IGhhbmRsZXIoIHAxcmVzdWx0ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggcHJvbWlzZTIsIHgsIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVqZWN0KCBlcnIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3J3YXJkIHRoZSByZXN1bHQgb2YgcHJvbWlzZTEgdG8gcHJvbWlzZTIsIGlmIHJlc29sdXRpb24gaGFuZGxlcnNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGFyZSBub3QgZ2l2ZW5cblx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goIGZvcndhcmQgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdC8vIDIuMlxuXHRcdFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uRnVsZmlsbGVkLCBmdWxmaWxsZWRIYW5kbGVycywgZnVsZmlsICk7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciggb25SZWplY3RlZCwgcmVqZWN0ZWRIYW5kbGVycywgcmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggc3RhdGUgIT09IFBFTkRJTkcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByb21pc2UgaGFzIHJlc29sdmVkIGFscmVhZHksIGRpc3BhdGNoIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuXHRcdFx0XHRcdFx0XHRcdHdhaXQoIGRpc3BhdGNoSGFuZGxlcnMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb21pc2UyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0cHJvbWlzZVsgJ2NhdGNoJyBdID0gZnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudGhlbiggbnVsbCwgb25SZWplY3RlZCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiggcHJvbWlzZXMgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdFx0XHRwZW5kaW5nLCBpLCBwcm9jZXNzUHJvbWlzZTtcblx0XHRcdFx0XHRpZiAoICFwcm9taXNlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmdWxmaWwoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcm9jZXNzUHJvbWlzZSA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdFx0cHJvbWlzZXNbIGkgXS50aGVuKCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGlmICggIS0tcGVuZGluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRmdWxmaWwoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCByZWplY3QgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHBlbmRpbmcgPSBpID0gcHJvbWlzZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UoIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsICkge1xuXHRcdFx0XHRcdGZ1bGZpbCggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHRcdF9Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKCByZWFzb24gKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHRyZWplY3QoIHJlYXNvbiApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRfX2V4cG9ydCA9IF9Qcm9taXNlO1xuXHRcdC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcblx0XHRmdW5jdGlvbiB3YWl0KCBjYWxsYmFjayApIHtcblx0XHRcdHNldFRpbWVvdXQoIGNhbGxiYWNrLCAwICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIoIGhhbmRsZXJzLCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBoYW5kbGVyO1xuXHRcdFx0XHR3aGlsZSAoIGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpICkge1xuXHRcdFx0XHRcdGhhbmRsZXIoIHJlc3VsdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmUoIHByb21pc2UsIHgsIGZ1bGZpbCwgcmVqZWN0ICkge1xuXHRcdFx0Ly8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVxuXHRcdFx0dmFyIHRoZW47XG5cdFx0XHQvLyAyLjMuMVxuXHRcdFx0aWYgKCB4ID09PSBwcm9taXNlICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnQSBwcm9taXNlXFwncyBmdWxmaWxsbWVudCBoYW5kbGVyIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIDIuMy4yXG5cdFx0XHRpZiAoIHggaW5zdGFuY2VvZiBfUHJvbWlzZSApIHtcblx0XHRcdFx0eC50aGVuKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0fSBlbHNlIGlmICggeCAmJiAoIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyApICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdHJlamVjdCggZSApO1xuXHRcdFx0XHRcdC8vIDIuMy4zLjJcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gMi4zLjMuM1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHZhciBjYWxsZWQsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlO1xuXHRcdFx0XHRcdHJlc29sdmVQcm9taXNlID0gZnVuY3Rpb24oIHkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UsIHksIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZWplY3RQcm9taXNlID0gZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlamVjdCggciApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoZW4uY2FsbCggeCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UgKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0cmVqZWN0KCBlICk7XG5cdFx0XHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4yXG5cdFx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnVsZmlsKCB4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGZpbCggeCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB1dGlscy9ub3JtYWxpc2VSZWYuanMgKi9cblx0dmFyIG5vcm1hbGlzZVJlZiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHJlZ2V4ID0gL1xcW1xccyooXFwqfFswLTldfFsxLTldWzAtOV0rKVxccypcXF0vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXNlUmVmKCByZWYgKSB7XG5cdFx0XHRyZXR1cm4gKCByZWYgfHwgJycgKS5yZXBsYWNlKCByZWdleCwgJy4kMScgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0Lyogc2hhcmVkL2dldElubmVyQ29udGV4dC5qcyAqL1xuXHR2YXIgZ2V0SW5uZXJDb250ZXh0ID0gZnVuY3Rpb24oIGZyYWdtZW50ICkge1xuXHRcdGRvIHtcblx0XHRcdGlmICggZnJhZ21lbnQuY29udGV4dCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dDtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRyZXR1cm4gJyc7XG5cdH07XG5cblx0LyogdXRpbHMvaXNFcXVhbC5qcyAqL1xuXHR2YXIgaXNFcXVhbCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gbnVsbCAmJiBiID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGEgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBiID09PSAnb2JqZWN0JyApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIGEgPT09IGI7XG5cdH07XG5cblx0Lyogc2hhcmVkL2NyZWF0ZUNvbXBvbmVudEJpbmRpbmcuanMgKi9cblx0dmFyIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgcnVubG9vcDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBydW5sb29wID0gY2lyY3VsYXIucnVubG9vcDtcblx0XHR9ICk7XG5cdFx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5cGF0aCwgb3RoZXJJbnN0YW5jZSwgb3RoZXJLZXlwYXRoICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdHRoaXMub3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2U7XG5cdFx0XHR0aGlzLm90aGVyS2V5cGF0aCA9IG90aGVyS2V5cGF0aDtcblx0XHRcdHRoaXMubG9jayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnVubG9jayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdH07XG5cdFx0QmluZGluZy5wcm90b3R5cGUgPSB7XG5cdFx0XHRpc0xvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnVwZGF0aW5nIHx8IHRoaXMuY291bnRlcnBhcnQgJiYgdGhpcy5jb3VudGVycGFydC51cGRhdGluZztcblx0XHRcdH0sXG5cdFx0XHRzaHVmZmxlOiBmdW5jdGlvbiggbmV3SW5kaWNlcywgdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKCB2YWx1ZSwgbmV3SW5kaWNlcyApO1xuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKCB2YWx1ZSApO1xuXHRcdFx0fSxcblx0XHRcdHByb3BhZ2F0ZUNoYW5nZTogZnVuY3Rpb24oIHZhbHVlLCBuZXdJbmRpY2VzICkge1xuXHRcdFx0XHR2YXIgb3RoZXI7XG5cdFx0XHRcdC8vIE9ubHkgKnlvdSogY2FuIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLmlzTG9ja2VkKCkgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMubG9jaygpO1xuXHRcdFx0XHRcdC8vIFRPRE8gbWF5YmUgdGhlIGNhc2UgdGhhdCBgdmFsdWUgPT09IHRoaXMudmFsdWVgIC0gc2hvdWxkIHRoYXQgcmVzdWx0XG5cdFx0XHRcdFx0Ly8gaW4gYW4gdXBkYXRlIHJhdGhlciB0aGFuIGEgc2V0P1xuXHRcdFx0XHRcdC8vIGlmIHRoZSBvdGhlciB2aWV3bW9kZWwgaXMgYWxyZWFkeSBsb2NrZWQgdXAsIG5lZWQgdG8gZG8gYSBkZWZlcnJlZCB1cGRhdGVcblx0XHRcdFx0XHRpZiAoICFydW5sb29wLmFkZFZpZXdtb2RlbCggb3RoZXIgPSB0aGlzLm90aGVySW5zdGFuY2Uudmlld21vZGVsICkgJiYgdGhpcy5jb3VudGVycGFydC52YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBydW5sb29wLmFkZFZpZXdtb2RlbCggb3RoZXIgKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBuZXdJbmRpY2VzICkge1xuXHRcdFx0XHRcdFx0b3RoZXIuc21hcnRVcGRhdGUoIHRoaXMub3RoZXJLZXlwYXRoLCB2YWx1ZSwgbmV3SW5kaWNlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoIGlzU2V0dGFibGUoIG90aGVyLCB0aGlzLm90aGVyS2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHRvdGhlci5zZXQoIHRoaXMub3RoZXJLZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0Ly8gVE9ETyB3aWxsIHRoZSBjb3VudGVycGFydCB1cGRhdGUgYWZ0ZXIgdGhpcyBsaW5lLCBkdXJpbmdcblx0XHRcdFx0XHQvLyB0aGUgcnVubG9vcCBlbmQgY3ljbGU/IG1heSBiZSBhIHByb2JsZW0uLi5cblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggdGhpcy51bmxvY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlZmluZVZhbHVlOiBmdW5jdGlvbigga2V5cGF0aHMgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgb3RoZXI7XG5cdFx0XHRcdGlmICggdGhpcy5pc0xvY2tlZCgpICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmxvY2soKTtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIG90aGVyID0gdGhpcy5vdGhlckluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRrZXlwYXRocy5tYXAoIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAub3RoZXJLZXlwYXRoICsga2V5cGF0aC5zdWJzdHIoIHRoaXMkMC5rZXlwYXRoLmxlbmd0aCApO1xuXHRcdFx0XHR9ICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG90aGVyLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggdGhpcy51bmxvY2sgKTtcblx0XHRcdH0sXG5cdFx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy51bmJpbmQoKTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0dGhpcy5jb3VudGVycGFydC5vdGhlcktleXBhdGggPSBuZXdLZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1NldHRhYmxlKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgY29tcHV0ZWQgPSB2aWV3bW9kZWwuY29tcHV0YXRpb25zWyBrZXlwYXRoIF07XG5cdFx0XHRyZXR1cm4gIWNvbXB1dGVkIHx8IGNvbXB1dGVkLnNldHRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIGNvbXBvbmVudCwgcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aCApIHtcblx0XHRcdHZhciBoYXNoLCBjaGlsZEluc3RhbmNlLCBiaW5kaW5ncywgcGFyZW50VG9DaGlsZEJpbmRpbmcsIGNoaWxkVG9QYXJlbnRCaW5kaW5nO1xuXHRcdFx0aGFzaCA9IHBhcmVudEtleXBhdGggKyAnPScgKyBjaGlsZEtleXBhdGg7XG5cdFx0XHRiaW5kaW5ncyA9IGNvbXBvbmVudC5iaW5kaW5ncztcblx0XHRcdGlmICggYmluZGluZ3NbIGhhc2ggXSApIHtcblx0XHRcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgZXZlciBoYXBwZW4/XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNoaWxkSW5zdGFuY2UgPSBjb21wb25lbnQuaW5zdGFuY2U7XG5cdFx0XHRwYXJlbnRUb0NoaWxkQmluZGluZyA9IG5ldyBCaW5kaW5nKCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCwgY2hpbGRJbnN0YW5jZSwgY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRiaW5kaW5ncy5wdXNoKCBwYXJlbnRUb0NoaWxkQmluZGluZyApO1xuXHRcdFx0aWYgKCBjaGlsZEluc3RhbmNlLnR3b3dheSApIHtcblx0XHRcdFx0Y2hpbGRUb1BhcmVudEJpbmRpbmcgPSBuZXcgQmluZGluZyggY2hpbGRJbnN0YW5jZSwgY2hpbGRLZXlwYXRoLCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBjaGlsZFRvUGFyZW50QmluZGluZyApO1xuXHRcdFx0XHRwYXJlbnRUb0NoaWxkQmluZGluZy5jb3VudGVycGFydCA9IGNoaWxkVG9QYXJlbnRCaW5kaW5nO1xuXHRcdFx0XHRjaGlsZFRvUGFyZW50QmluZGluZy5jb3VudGVycGFydCA9IHBhcmVudFRvQ2hpbGRCaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0YmluZGluZ3NbIGhhc2ggXSA9IHBhcmVudFRvQ2hpbGRCaW5kaW5nO1xuXHRcdH07XG5cdH0oIGNpcmN1bGFyLCBpc0VxdWFsICk7XG5cblx0Lyogc2hhcmVkL3Jlc29sdmVSZWYuanMgKi9cblx0dmFyIHJlc29sdmVSZWYgPSBmdW5jdGlvbiggbm9ybWFsaXNlUmVmLCBnZXRJbm5lckNvbnRleHQsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGFuY2VzdG9yRXJyb3JNZXNzYWdlLCBnZXRPcHRpb25zO1xuXHRcdGFuY2VzdG9yRXJyb3JNZXNzYWdlID0gJ0NvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSAtIHRvbyBtYW55IFwiLi4vXCIgcHJlZml4ZXMnO1xuXHRcdGdldE9wdGlvbnMgPSB7XG5cdFx0XHRldmFsdWF0ZVdyYXBwZWQ6IHRydWVcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBmcmFnbWVudCwgaXNQYXJlbnRMb29rdXAgKSB7XG5cdFx0XHR2YXIgY29udGV4dCwga2V5LCBpbmRleCwga2V5cGF0aCwgcGFyZW50VmFsdWUsIGhhc0NvbnRleHRDaGFpbiwgcGFyZW50S2V5cywgY2hpbGRLZXlzLCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGg7XG5cdFx0XHRyZWYgPSBub3JtYWxpc2VSZWYoIHJlZiApO1xuXHRcdFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zICd+LycsIGl0J3MgYSB0b3AtbGV2ZWwgcmVmZXJlbmNlXG5cdFx0XHRpZiAoIHJlZi5zdWJzdHIoIDAsIDIgKSA9PT0gJ34vJyApIHtcblx0XHRcdFx0cmV0dXJuIHJlZi5zdWJzdHJpbmcoIDIgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyB3aXRoICcuJywgaXQncyBlaXRoZXIgYSByZXN0cmljdGVkIHJlZmVyZW5jZSBvclxuXHRcdFx0Ly8gYW4gYW5jZXN0b3IgcmVmZXJlbmNlLi4uXG5cdFx0XHRpZiAoIHJlZi5jaGFyQXQoIDAgKSA9PT0gJy4nICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzb2x2ZUFuY2VzdG9yUmVmZXJlbmNlKCBnZXRJbm5lckNvbnRleHQoIGZyYWdtZW50ICksIHJlZiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmluZCB0aGUga2V5cGF0aFxuXHRcdFx0a2V5ID0gcmVmLnNwbGl0KCAnLicgKVsgMCBdO1xuXHRcdFx0Ly8gZ2V0KCkgaW4gdmlld21vZGVsIGNyZWF0aW9uIG1lYW5zIG5vIGZyYWdtZW50ICh5ZXQpXG5cdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50IHx8IHt9O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRjb250ZXh0ID0gZnJhZ21lbnQuY29udGV4dDtcblx0XHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldCggY29udGV4dCwgZ2V0T3B0aW9ucyApO1xuXHRcdFx0XHRpZiAoIHBhcmVudFZhbHVlICYmICggdHlwZW9mIHBhcmVudFZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdmdW5jdGlvbicgKSAmJiBrZXkgaW4gcGFyZW50VmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRleHQgKyAnLicgKyByZWY7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdFx0Ly8gUm9vdC9jb21wdXRlZCBwcm9wZXJ0eT9cblx0XHRcdGlmICgga2V5IGluIHJhY3RpdmUuZGF0YSB8fCBrZXkgaW4gcmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0YXRpb25zICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbmxpbmUgY29tcG9uZW50LCBhbmQgaXQncyBub3QgaXNvbGF0ZWQsIHdlXG5cdFx0XHQvLyBjYW4gdHJ5IGdvaW5nIHVwIHRoZSBzY29wZSBjaGFpblxuXHRcdFx0aWYgKCByYWN0aXZlLl9wYXJlbnQgJiYgIXJhY3RpdmUuaXNvbGF0ZWQgKSB7XG5cdFx0XHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG5cdFx0XHRcdGZyYWdtZW50ID0gcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGluZGV4IHJlZnNcblx0XHRcdFx0aWYgKCBmcmFnbWVudC5pbmRleFJlZnMgJiYgKCBpbmRleCA9IGZyYWdtZW50LmluZGV4UmVmc1sgcmVmIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIENyZWF0ZSBhbiBpbmRleCByZWYgYmluZGluZywgc28gdGhhdCBpdCBjYW4gYmUgcmVib3VuZCBsZXR0ZXIgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0XHRcdC8vIEl0IGRvZXNuJ3QgaGF2ZSBhbiBhbGlhcyBzaW5jZSBpdCdzIGFuIGltcGxpY2l0IGJpbmRpbmcsIGhlbmNlIGAuLi5bIHJlZiBdID0gcmVmYFxuXHRcdFx0XHRcdHJhY3RpdmUuY29tcG9uZW50LmluZGV4UmVmQmluZGluZ3NbIHJlZiBdID0gcmVmO1xuXHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldCggcmVmLCBpbmRleCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZS5fcGFyZW50LCByZWYsIGZyYWdtZW50LCB0cnVlICk7XG5cdFx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhbiBpbnRlci1jb21wb25lbnQgYmluZGluZ1xuXHRcdFx0XHRcdC8vIElmIHBhcmVudCBrZXlwYXRoIGlzICdvbmUuZm9vJyBhbmQgY2hpbGQgaXMgJ3R3by5mb28nLCB3ZSBiaW5kXG5cdFx0XHRcdFx0Ly8gJ29uZScgdG8gJ3R3bycgYXMgaXQncyBtb3JlIGVmZmljaWVudCBhbmQgYXZvaWRzIGVkZ2UgY2FzZXNcblx0XHRcdFx0XHRwYXJlbnRLZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdFx0Y2hpbGRLZXlzID0gcmVmLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHR3aGlsZSAoIHBhcmVudEtleXMubGVuZ3RoID4gMSAmJiBjaGlsZEtleXMubGVuZ3RoID4gMSAmJiBwYXJlbnRLZXlzWyBwYXJlbnRLZXlzLmxlbmd0aCAtIDEgXSA9PT0gY2hpbGRLZXlzWyBjaGlsZEtleXMubGVuZ3RoIC0gMSBdICkge1xuXHRcdFx0XHRcdFx0cGFyZW50S2V5cy5wb3AoKTtcblx0XHRcdFx0XHRcdGNoaWxkS2V5cy5wb3AoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IHBhcmVudEtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdFx0Y2hpbGRLZXlwYXRoID0gY2hpbGRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldCggY2hpbGRLZXlwYXRoLCByYWN0aXZlLl9wYXJlbnQudmlld21vZGVsLmdldCggcGFyZW50S2V5cGF0aCApLCB0cnVlICk7XG5cdFx0XHRcdFx0Y3JlYXRlQ29tcG9uZW50QmluZGluZyggcmFjdGl2ZS5jb21wb25lbnQsIHJhY3RpdmUuX3BhcmVudCwgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhlcmUncyBubyBjb250ZXh0IGNoYWluLCBhbmQgdGhlIGluc3RhbmNlIGlzIGVpdGhlciBhKSBpc29sYXRlZCBvclxuXHRcdFx0Ly8gYikgYW4gb3JwaGFuLCB0aGVuIHdlIGtub3cgdGhhdCB0aGUga2V5cGF0aCBpcyBpZGVudGljYWwgdG8gdGhlIHJlZmVyZW5jZVxuXHRcdFx0aWYgKCAhaXNQYXJlbnRMb29rdXAgJiYgIWhhc0NvbnRleHRDaGFpbiApIHtcblx0XHRcdFx0Ly8gdGhlIGRhdGEgb2JqZWN0IG5lZWRzIHRvIGhhdmUgYSBwcm9wZXJ0eSBieSB0aGlzIG5hbWUsXG5cdFx0XHRcdC8vIHRvIHByZXZlbnQgZnV0dXJlIGZhaWxlZCBsb29rdXBzXG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldCggcmVmLCB1bmRlZmluZWQgKTtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCByZWYgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlQW5jZXN0b3JSZWZlcmVuY2UoIGJhc2VDb250ZXh0LCByZWYgKSB7XG5cdFx0XHR2YXIgY29udGV4dEtleXM7XG5cdFx0XHQvLyB7ey59fSBtZWFucyAnY3VycmVudCBjb250ZXh0J1xuXHRcdFx0aWYgKCByZWYgPT09ICcuJyApXG5cdFx0XHRcdHJldHVybiBiYXNlQ29udGV4dDtcblx0XHRcdGNvbnRleHRLZXlzID0gYmFzZUNvbnRleHQgPyBiYXNlQ29udGV4dC5zcGxpdCggJy4nICkgOiBbXTtcblx0XHRcdC8vIGFuY2VzdG9yIHJlZmVyZW5jZXMgKHN0YXJ0aW5nIFwiLi4vXCIpIGdvIHVwIHRoZSB0cmVlXG5cdFx0XHRpZiAoIHJlZi5zdWJzdHIoIDAsIDMgKSA9PT0gJy4uLycgKSB7XG5cdFx0XHRcdHdoaWxlICggcmVmLnN1YnN0ciggMCwgMyApID09PSAnLi4vJyApIHtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0S2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGFuY2VzdG9yRXJyb3JNZXNzYWdlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRleHRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdHJlZiA9IHJlZi5zdWJzdHJpbmcoIDMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZXh0S2V5cy5wdXNoKCByZWYgKTtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm90IGFuIGFuY2VzdG9yIHJlZmVyZW5jZSAtIG11c3QgYmUgYSByZXN0cmljdGVkIHJlZmVyZW5jZSAocHJlcGVuZGVkIHdpdGggXCIuXCIgb3IgXCIuL1wiKVxuXHRcdFx0aWYgKCAhYmFzZUNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZWYucmVwbGFjZSggL15cXC5cXC8/LywgJycgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBiYXNlQ29udGV4dCArIHJlZi5yZXBsYWNlKCAvXlxcLlxcLy8sICcuJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIG5vcm1hbGlzZVJlZiwgZ2V0SW5uZXJDb250ZXh0LCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogZ2xvYmFsL1RyYW5zaXRpb25NYW5hZ2VyLmpzICovXG5cdHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiggY2FsbGJhY2ssIHBhcmVudCApIHtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHRcdFx0dGhpcy5pbnRyb3MgPSBbXTtcblx0XHRcdHRoaXMub3V0cm9zID0gW107XG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXHRcdFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuXHRcdFx0dGhpcy5vdXRyb3NDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5hZGRDaGlsZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKCBjaGlsZCApIHtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gKz0gMTtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuICs9IDE7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50T3V0cm9zOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuIC09IDE7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50VG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gLT0gMTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG5cdFx0XHRcdGxpc3QucHVzaCggdHJhbnNpdGlvbiApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBsaXN0LCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGRldGFjaE5vZGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kZXRhY2hRdWV1ZS5mb3JFYWNoKCBkZXRhY2ggKTtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBkZXRhY2hOb2RlcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkZXRhY2goIGVsZW1lbnQgKSB7XG5cdFx0XHRlbGVtZW50LmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRldGFjaE5vZGVzKCB0bSApIHtcblx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2soIHRtICkge1xuXHRcdFx0aWYgKCAhdG0ucmVhZHkgfHwgdG0ub3V0cm9zLmxlbmd0aCB8fCB0bS5vdXRyb0NoaWxkcmVuIClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Ly8gSWYgYWxsIG91dHJvcyBhcmUgY29tcGxldGUsIGFuZCB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSB0aGlzLFxuXHRcdFx0Ly8gd2Ugbm90aWZ5IHRoZSBwYXJlbnQgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2Vcblx0XHRcdC8vIHN0YXJ0IGRldGFjaGluZyBub2Rlc1xuXHRcdFx0aWYgKCAhdG0ub3V0cm9zQ29tcGxldGUgKSB7XG5cdFx0XHRcdGlmICggdG0ucGFyZW50ICkge1xuXHRcdFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRPdXRyb3MoIHRtICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bS5vdXRyb3NDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuXHRcdFx0Ly8gbWFuYWdlciBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcblx0XHRcdGlmICggIXRtLmludHJvcy5sZW5ndGggJiYgIXRtLnRvdGFsQ2hpbGRyZW4gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRtLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHRtLmNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0bS5wYXJlbnQgKSB7XG5cdFx0XHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudFRvdGFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFRyYW5zaXRpb25NYW5hZ2VyO1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBnbG9iYWwvcnVubG9vcC5qcyAqL1xuXHR2YXIgcnVubG9vcCA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgSG9vaywgcmVtb3ZlRnJvbUFycmF5LCBQcm9taXNlLCByZXNvbHZlUmVmLCBUcmFuc2l0aW9uTWFuYWdlciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgYmF0Y2gsIHJ1bmxvb3AsIHVucmVzb2x2ZWQgPSBbXSxcblx0XHRcdGNoYW5nZUhvb2sgPSBuZXcgSG9vayggJ2NoYW5nZScgKTtcblx0XHRydW5sb29wID0ge1xuXHRcdFx0c3RhcnQ6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgcmV0dXJuUHJvbWlzZSApIHtcblx0XHRcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2U7XG5cdFx0XHRcdGlmICggcmV0dXJuUHJvbWlzZSApIHtcblx0XHRcdFx0XHRwcm9taXNlID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCBmICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bGZpbFByb21pc2UgPSBmO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRiYXRjaCA9IHtcblx0XHRcdFx0XHRwcmV2aW91c0JhdGNoOiBiYXRjaCxcblx0XHRcdFx0XHR0cmFuc2l0aW9uTWFuYWdlcjogbmV3IFRyYW5zaXRpb25NYW5hZ2VyKCBmdWxmaWxQcm9taXNlLCBiYXRjaCAmJiBiYXRjaC50cmFuc2l0aW9uTWFuYWdlciApLFxuXHRcdFx0XHRcdHZpZXdzOiBbXSxcblx0XHRcdFx0XHR0YXNrczogW10sXG5cdFx0XHRcdFx0dmlld21vZGVsczogW10sXG5cdFx0XHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0YmF0Y2gudmlld21vZGVscy5wdXNoKCBpbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH0sXG5cdFx0XHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmbHVzaENoYW5nZXMoKTtcblx0XHRcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuaW5pdCgpO1xuXHRcdFx0XHRpZiAoICFiYXRjaC5wcmV2aW91c0JhdGNoICYmICEhYmF0Y2guaW5zdGFuY2UgKVxuXHRcdFx0XHRcdGJhdGNoLmluc3RhbmNlLnZpZXdtb2RlbC5jaGFuZ2VzID0gW107XG5cdFx0XHRcdGJhdGNoID0gYmF0Y2gucHJldmlvdXNCYXRjaDtcblx0XHRcdH0sXG5cdFx0XHRhZGRWaWV3bW9kZWw6IGZ1bmN0aW9uKCB2aWV3bW9kZWwgKSB7XG5cdFx0XHRcdGlmICggYmF0Y2ggKSB7XG5cdFx0XHRcdFx0aWYgKCBiYXRjaC52aWV3bW9kZWxzLmluZGV4T2YoIHZpZXdtb2RlbCApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGJhdGNoLnZpZXdtb2RlbHMucHVzaCggdmlld21vZGVsICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2aWV3bW9kZWwuYXBwbHlDaGFuZ2VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVnaXN0ZXJUcmFuc2l0aW9uOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGQoIHRyYW5zaXRpb24gKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRWaWV3OiBmdW5jdGlvbiggdmlldyApIHtcblx0XHRcdFx0YmF0Y2gudmlld3MucHVzaCggdmlldyApO1xuXHRcdFx0fSxcblx0XHRcdGFkZFVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0dW5yZXNvbHZlZC5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZVVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB1bnJlc29sdmVkLCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdC8vIHN5bmNocm9uaXNlIG5vZGUgZGV0YWNobWVudHMgd2l0aCB0cmFuc2l0aW9uIGVuZHNcblx0XHRcdGRldGFjaFdoZW5SZWFkeTogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHNjaGVkdWxlVGFzazogZnVuY3Rpb24oIHRhc2ssIHBvc3RSZW5kZXIgKSB7XG5cdFx0XHRcdHZhciBfYmF0Y2g7XG5cdFx0XHRcdGlmICggIWJhdGNoICkge1xuXHRcdFx0XHRcdHRhc2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfYmF0Y2ggPSBiYXRjaDtcblx0XHRcdFx0XHR3aGlsZSAoIHBvc3RSZW5kZXIgJiYgX2JhdGNoLnByZXZpb3VzQmF0Y2ggKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzIGNhbid0IGhhcHBlbiB1bnRpbCB0aGUgRE9NIGhhcyBiZWVuIGZ1bGx5IHVwZGF0ZWRcblx0XHRcdFx0XHRcdC8vIG90aGVyd2lzZSBpbiBzb21lIHNpdHVhdGlvbnMgKHdpdGggY29tcG9uZW50cyBpbnNpZGUgZWxlbWVudHMpXG5cdFx0XHRcdFx0XHQvLyB0cmFuc2l0aW9ucyBhbmQgZGVjb3JhdG9ycyB3aWxsIGluaXRpYWxpc2UgcHJlbWF0dXJlbHlcblx0XHRcdFx0XHRcdF9iYXRjaCA9IF9iYXRjaC5wcmV2aW91c0JhdGNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfYmF0Y2gudGFza3MucHVzaCggdGFzayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjaXJjdWxhci5ydW5sb29wID0gcnVubG9vcDtcblx0XHRfX2V4cG9ydCA9IHJ1bmxvb3A7XG5cblx0XHRmdW5jdGlvbiBmbHVzaENoYW5nZXMoKSB7XG5cdFx0XHR2YXIgaSwgdGhpbmcsIGNoYW5nZUhhc2g7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdHRoaW5nID0gYmF0Y2gudmlld21vZGVsc1sgaSBdO1xuXHRcdFx0XHRjaGFuZ2VIYXNoID0gdGhpbmcuYXBwbHlDaGFuZ2VzKCk7XG5cdFx0XHRcdGlmICggY2hhbmdlSGFzaCApIHtcblx0XHRcdFx0XHRjaGFuZ2VIb29rLmZpcmUoIHRoaW5nLnJhY3RpdmUsIGNoYW5nZUhhc2ggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudmlld21vZGVscy5sZW5ndGggPSAwO1xuXHRcdFx0YXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCk7XG5cdFx0XHQvLyBOb3cgdGhhdCBjaGFuZ2VzIGhhdmUgYmVlbiBmdWxseSBwcm9wYWdhdGVkLCB3ZSBjYW4gdXBkYXRlIHRoZSBET01cblx0XHRcdC8vIGFuZCBjb21wbGV0ZSBvdGhlciB0YXNrc1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC52aWV3cy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0YmF0Y2gudmlld3NbIGkgXS51cGRhdGUoKTtcblx0XHRcdH1cblx0XHRcdGJhdGNoLnZpZXdzLmxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnRhc2tzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRiYXRjaC50YXNrc1sgaSBdKCk7XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC50YXNrcy5sZW5ndGggPSAwO1xuXHRcdFx0Ly8gSWYgdXBkYXRpbmcgdGhlIHZpZXcgY2F1c2VkIHNvbWUgbW9kZWwgYmxvd2JhY2sgLSBlLmcuIGEgdHJpcGxlXG5cdFx0XHQvLyBjb250YWluaW5nIDxvcHRpb24+IGVsZW1lbnRzIGNhdXNlZCB0aGUgYmluZGluZyBvbiB0aGUgPHNlbGVjdD5cblx0XHRcdC8vIHRvIHVwZGF0ZSAtIHRoZW4gd2Ugc3RhcnQgb3ZlclxuXHRcdFx0aWYgKCBiYXRjaC52aWV3bW9kZWxzLmxlbmd0aCApXG5cdFx0XHRcdHJldHVybiBmbHVzaENoYW5nZXMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKSB7XG5cdFx0XHR2YXIgaSwgaXRlbSwga2V5cGF0aCwgcmVzb2x2ZWQ7XG5cdFx0XHRpID0gdW5yZXNvbHZlZC5sZW5ndGg7XG5cdFx0XHQvLyBzZWUgaWYgd2UgY2FuIHJlc29sdmUgYW55IHVucmVzb2x2ZWQgcmVmZXJlbmNlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGl0ZW0gPSB1bnJlc29sdmVkWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5rZXlwYXRoICkge1xuXHRcdFx0XHRcdC8vIGl0IHJlc29sdmVkIHNvbWUgb3RoZXIgd2F5LiBUT0RPIGhvdz8gdHdvLXdheSBiaW5kaW5nPyBTZWVtc1xuXHRcdFx0XHRcdC8vIHdlaXJkIHRoYXQgd2UnZCBzdGlsbCBlbmQgdXAgaGVyZVxuXHRcdFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggaXRlbS5yb290LCBpdGVtLnJlZiwgaXRlbS5wYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRcdCggcmVzb2x2ZWQgfHwgKCByZXNvbHZlZCA9IFtdICkgKS5wdXNoKCB7XG5cdFx0XHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR1bnJlc29sdmVkLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlc29sdmVkICkge1xuXHRcdFx0XHRyZXNvbHZlZC5mb3JFYWNoKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSggcmVzb2x2ZWQgKSB7XG5cdFx0XHRyZXNvbHZlZC5pdGVtLnJlc29sdmUoIHJlc29sdmVkLmtleXBhdGggKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjaXJjdWxhciwgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgcmVtb3ZlRnJvbUFycmF5LCBQcm9taXNlLCByZXNvbHZlUmVmLCBUcmFuc2l0aW9uTWFuYWdlciApO1xuXG5cdC8qIHV0aWxzL2NyZWF0ZUJyYW5jaC5qcyAqL1xuXHR2YXIgY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbnVtZXJpYyA9IC9eXFxzKlswLTldK1xccyokLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBudW1lcmljLnRlc3QoIGtleSApID8gW10gOiB7fTtcblx0XHR9O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvbWFnaWNBZGFwdG9yLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciA9IGZ1bmN0aW9uKCBydW5sb29wLCBjcmVhdGVCcmFuY2gsIGlzQXJyYXkgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHRcdG1hZ2ljQWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFdyYXBwZXIsIHBhcmVudFZhbHVlO1xuXHRcdFx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgdmFsdWUgaXMgYSB3cmFwcGVyLCBvdGhlciB0aGFuIGEgbWFnaWMgd3JhcHBlcixcblx0XHRcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG5cdFx0XHRcdFx0aWYgKCAoIHBhcmVudFdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSAmJiAhcGFyZW50V3JhcHBlci5tYWdpYyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRcdC8vIGlmIHBhcmVudFZhbHVlIGlzIGFuIGFycmF5IHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoaXMgbWVtYmVyLFxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG5cdFx0XHRcdFx0aWYgKCBpc0FycmF5KCBwYXJlbnRWYWx1ZSApICYmIC9eWzAtOV0rJC8udGVzdCgga2V5ICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljV3JhcHBlciggcmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGtleXMsIG9iaktleXBhdGgsIHRlbXBsYXRlLCBzaWJsaW5ncztcblx0XHRcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHR0aGlzLnByb3AgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRvYmpLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoID8gcmFjdGl2ZS5nZXQoIG9iaktleXBhdGggKSA6IHJhY3RpdmUuZGF0YTtcblx0XHRcdFx0dGVtcGxhdGUgPSB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMub2JqLCB0aGlzLnByb3AgKTtcblx0XHRcdFx0Ly8gSGFzIHRoaXMgcHJvcGVydHkgYWxyZWFkeSBiZWVuIHdyYXBwZWQ/XG5cdFx0XHRcdGlmICggdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0ICYmICggc2libGluZ3MgPSB0ZW1wbGF0ZS5zZXQuX3JhY3RpdmVXcmFwcGVycyApICkge1xuXHRcdFx0XHRcdC8vIFllcy4gUmVnaXN0ZXIgdGhpcyB3cmFwcGVyIHRvIHRoaXMgcHJvcGVydHksIGlmIGl0IGhhc24ndCBiZWVuIGFscmVhZHlcblx0XHRcdFx0XHRpZiAoIHNpYmxpbmdzLmluZGV4T2YoIHRoaXMgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRzaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBObywgaXQgaGFzbid0IGJlZW4gd3JhcHBlZFxuXHRcdFx0XHRjcmVhdGVBY2Nlc3NvcnMoIHRoaXMsIHZhbHVlLCB0ZW1wbGF0ZSApO1xuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHQvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucmFjdGl2ZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXRoaXMub2JqWyB0aGlzLnByb3AgXSApIHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gY3JlYXRlQnJhbmNoKCBrZXkgKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG5cdFx0XHRcdFx0Ly8gcmVzdWx0IG9mIGEgc2V0KCkvdXBkYXRlKCkgY2FsbCBtYWRlIGJ5IHRoaXMgd3JhcHBlciwgd2UgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdFx0Ly8gc28gdGhhdCBpdCBkb2Vzbid0IGdldCB0b3JuIGRvd25cblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcy5vYmosIHRoaXMucHJvcCApO1xuXHRcdFx0XHRcdHNldCA9IHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldDtcblx0XHRcdFx0XHRpZiAoICFzZXQgKSB7XG5cdFx0XHRcdFx0XHQvLyBtb3N0IGxpa2VseSwgdGhpcyB3YXMgYW4gYXJyYXkgbWVtYmVyIHRoYXQgd2FzIHNwbGljZWQgb3V0XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cdFx0XHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuXHRcdFx0XHRcdGlmICggIXdyYXBwZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbIHRoaXMucHJvcCBdO1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG5cdFx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bWFnaWNBZGFwdG9yID0gZmFsc2U7XG5cdFx0fVxuXHRcdF9fZXhwb3J0ID0gbWFnaWNBZGFwdG9yO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQWNjZXNzb3JzKCBvcmlnaW5hbFdyYXBwZXIsIHZhbHVlLCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBvYmplY3QsIHByb3BlcnR5LCBvbGRHZXQsIG9sZFNldCwgZ2V0LCBzZXQ7XG5cdFx0XHRvYmplY3QgPSBvcmlnaW5hbFdyYXBwZXIub2JqO1xuXHRcdFx0cHJvcGVydHkgPSBvcmlnaW5hbFdyYXBwZXIucHJvcDtcblx0XHRcdC8vIElzIHRoaXMgdGVtcGxhdGUgY29uZmlndXJhYmxlP1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29uZmlndXJhYmxlICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBhcnJheSBsZW5ndGhcblx0XHRcdFx0aWYgKCBwcm9wZXJ0eSA9PT0gJ2xlbmd0aCcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCB1c2UgbWFnaWMgbW9kZSB3aXRoIHByb3BlcnR5IFwiJyArIHByb3BlcnR5ICsgJ1wiIC0gb2JqZWN0IGlzIG5vdCBjb25maWd1cmFibGUnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lIHRvIHdyYXAgdGhpcyBwcm9wZXJ0eVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0b2xkR2V0ID0gdGVtcGxhdGUuZ2V0O1xuXHRcdFx0XHRvbGRTZXQgPSB0ZW1wbGF0ZS5zZXQ7XG5cdFx0XHR9XG5cdFx0XHRnZXQgPSBvbGRHZXQgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH07XG5cdFx0XHRzZXQgPSBmdW5jdGlvbiggdiApIHtcblx0XHRcdFx0aWYgKCBvbGRTZXQgKSB7XG5cdFx0XHRcdFx0b2xkU2V0KCB2ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBvbGRHZXQgPyBvbGRHZXQoKSA6IHY7XG5cdFx0XHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzLmZvckVhY2goIHVwZGF0ZVdyYXBwZXIgKTtcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoIHdyYXBwZXIgKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoLCByYWN0aXZlO1xuXHRcdFx0XHR3cmFwcGVyLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGlmICggd3JhcHBlci51cGRhdGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmFjdGl2ZSA9IHdyYXBwZXIucmFjdGl2ZTtcblx0XHRcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblx0XHRcdFx0d3JhcHBlci51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHJhY3RpdmUgKTtcblx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFyaygga2V5cGF0aCApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBDcmVhdGUgYW4gYXJyYXkgb2Ygd3JhcHBlcnMsIGluIGNhc2Ugb3RoZXIga2V5cGF0aHMvcmFjdGl2ZXMgZGVwZW5kIG9uIHRoaXMgcHJvcGVydHkuXG5cdFx0XHQvLyBIYW5kaWx5LCB3ZSBjYW4gc3RvcmUgdGhlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBzZXQgZnVuY3Rpb24uIFlheSBKYXZhU2NyaXB0LlxuXHRcdFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMgPSBbIG9yaWdpbmFsV3JhcHBlciBdO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmplY3QsIHByb3BlcnR5LCB7XG5cdFx0XHRcdGdldDogZ2V0LFxuXHRcdFx0XHRzZXQ6IHNldCxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggcnVubG9vcCwgY3JlYXRlQnJhbmNoLCBpc0FycmF5ICk7XG5cblx0LyogY29uZmlnL21hZ2ljLmpzICovXG5cdHZhciBtYWdpYyA9IGZ1bmN0aW9uKCBtYWdpY0FkYXB0b3IgKSB7XG5cblx0XHRyZXR1cm4gISFtYWdpY0FkYXB0b3I7XG5cdH0oIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yICk7XG5cblx0LyogY29uZmlnL25hbWVzcGFjZXMuanMgKi9cblx0dmFyIG5hbWVzcGFjZXMgPSB7XG5cdFx0aHRtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuXHRcdG1hdGhtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuXHRcdHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHR4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG5cdFx0eG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcblx0fTtcblxuXHQvKiB1dGlscy9jcmVhdGVFbGVtZW50LmpzICovXG5cdHZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHN2ZywgbmFtZXNwYWNlcyApIHtcblxuXHRcdHZhciBjcmVhdGVFbGVtZW50O1xuXHRcdC8vIFRlc3QgZm9yIFNWRyBzdXBwb3J0XG5cdFx0aWYgKCAhc3ZnICkge1xuXHRcdFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCB0eXBlLCBucyApIHtcblx0XHRcdFx0aWYgKCBucyAmJiBucyAhPT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRcdHRocm93ICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG90aGVyIHRoYW4gaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIG9mIHRoaXMgZXJyb3IgaXMgdGhhdCB5b3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIFNWRyBpbiBhbiBvbGRlciBicm93c2VyLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3Qvc3ZnLWFuZC1vbGRlci1icm93c2VycyBmb3IgbW9yZSBpbmZvcm1hdGlvbic7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHR5cGUgKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZSwgbnMgKSB7XG5cdFx0XHRcdGlmICggIW5zIHx8IG5zID09PSBuYW1lc3BhY2VzLmh0bWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCBucywgdHlwZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQ7XG5cdH0oIHN2ZywgbmFtZXNwYWNlcyApO1xuXG5cdC8qIGNvbmZpZy9pc0NsaWVudC5qcyAqL1xuXHR2YXIgaXNDbGllbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCc7XG5cdFx0cmV0dXJuIGlzQ2xpZW50O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvZGVmaW5lUHJvcGVydHkuanMgKi9cblx0dmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24oIGlzQ2xpZW50ICkge1xuXG5cdFx0dmFyIGRlZmluZVByb3BlcnR5O1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHRcdGlmICggaXNDbGllbnQgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCBvciB3ZSdyZSBpbiBJRTggd2hlcmUgeW91IGNhblxuXHRcdFx0Ly8gb25seSB1c2UgaXQgd2l0aCBET00gb2JqZWN0cyAod2hhdCB0aGUgZnVjayB3ZXJlIHlvdSBzbW9raW5nLCBNU0ZUPylcblx0XHRcdGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24oIG9iaiwgcHJvcCwgZGVzYyApIHtcblx0XHRcdFx0b2JqWyBwcm9wIF0gPSBkZXNjLnZhbHVlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlZmluZVByb3BlcnR5O1xuXHR9KCBpc0NsaWVudCApO1xuXG5cdC8qIHV0aWxzL2RlZmluZVByb3BlcnRpZXMuanMgKi9cblx0dmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIGlzQ2xpZW50ICkge1xuXG5cdFx0dmFyIGRlZmluZVByb3BlcnRpZXM7XG5cdFx0dHJ5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB7fSwge1xuXHRcdFx0XHRcdHRlc3Q6IHtcblx0XHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHQvLyBUT0RPIGhvdyBkbyB3ZSBhY2NvdW50IGZvciB0aGlzPyBub01hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpc0NsaWVudCApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIGNyZWF0ZUVsZW1lbnQoICdkaXYnICksIHtcblx0XHRcdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIG9iaiwgcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBwcm9wO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdFx0XHRcdGlmICggcHJvcHMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBvYmosIHByb3AsIHByb3BzWyBwcm9wIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzO1xuXHR9KCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgaXNDbGllbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvYWRkLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9hZGQgPSBmdW5jdGlvbiggaXNOdW1lcmljICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFkZCggcm9vdCwga2V5cGF0aCwgZCApIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnIHx8ICFpc051bWVyaWMoIGQgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQmFkIGFyZ3VtZW50cycgKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gK3Jvb3QuZ2V0KCBrZXlwYXRoICkgfHwgMDtcblx0XHRcdGlmICggIWlzTnVtZXJpYyggdmFsdWUgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IGFkZCB0byBhIG5vbi1udW1lcmljIHZhbHVlJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJvb3Quc2V0KCBrZXlwYXRoLCB2YWx1ZSArIGQgKTtcblx0XHR9O1xuXHR9KCBpc051bWVyaWMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9hZGQuanMgKi9cblx0dmFyIFJhY3RpdmUkYWRkID0gZnVuY3Rpb24oIGFkZCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGFkZCgga2V5cGF0aCwgZCApIHtcblx0XHRcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IDEgOiArZCApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2FkZCApO1xuXG5cdC8qIHV0aWxzL25vcm1hbGlzZUtleXBhdGguanMgKi9cblx0dmFyIG5vcm1hbGlzZUtleXBhdGggPSBmdW5jdGlvbiggbm9ybWFsaXNlUmVmICkge1xuXG5cdFx0dmFyIGxlYWRpbmdEb3QgPSAvXlxcLisvO1xuXHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIG5vcm1hbGlzZVJlZigga2V5cGF0aCApLnJlcGxhY2UoIGxlYWRpbmdEb3QsICcnICk7XG5cdFx0fTtcblx0fSggbm9ybWFsaXNlUmVmICk7XG5cblx0LyogY29uZmlnL3ZlbmRvcnMuanMgKi9cblx0dmFyIHZlbmRvcnMgPSBbXG5cdFx0J28nLFxuXHRcdCdtcycsXG5cdFx0J21veicsXG5cdFx0J3dlYmtpdCdcblx0XTtcblxuXHQvKiB1dGlscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMgKi9cblx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQvLyBJZiB3aW5kb3cgZG9lc24ndCBleGlzdCwgd2UgZG9uJ3QgbmVlZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcblx0XHRcdCggZnVuY3Rpb24oIHZlbmRvcnMsIGxhc3RUaW1lLCB3aW5kb3cgKSB7XG5cdFx0XHRcdHZhciB4LCBzZXRUaW1lb3V0O1xuXHRcdFx0XHRpZiAoIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCApIHtcblx0XHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93WyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHRcdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuXHRcdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VyclRpbWUsIHRpbWVUb0NhbGwsIGlkO1xuXHRcdFx0XHRcdFx0Y3VyclRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdFx0dGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XG5cdFx0XHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XG5cdFx0XHRcdFx0XHR9LCB0aW1lVG9DYWxsICk7XG5cdFx0XHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcblx0XHRcdFx0XHRcdHJldHVybiBpZDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9KCB2ZW5kb3JzLCAwLCB3aW5kb3cgKSApO1xuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHV0aWxzL2dldFRpbWUuanMgKi9cblx0dmFyIGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBnZXRUaW1lO1xuXHRcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Z2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gRGF0ZS5ub3coKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBnZXRUaW1lO1xuXHR9KCk7XG5cblx0Lyogc2hhcmVkL2FuaW1hdGlvbnMuanMgKi9cblx0dmFyIGFuaW1hdGlvbnMgPSBmdW5jdGlvbiggckFGLCBnZXRUaW1lLCBydW5sb29wICkge1xuXG5cdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB7XG5cdFx0XHR0aWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGksIGFuaW1hdGlvbiwgbm93O1xuXHRcdFx0XHRub3cgPSBnZXRUaW1lKCk7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVsgaSBdO1xuXHRcdFx0XHRcdGlmICggIWFuaW1hdGlvbi50aWNrKCBub3cgKSApIHtcblx0XHRcdFx0XHRcdC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCBhbmQgZGVjcmVtZW50IGkgc28gd2UgZG9uJ3QgbWlzcyBvbmVcblx0XHRcdFx0XHRcdHF1ZXVlLnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdGlmICggcXVldWUubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJBRiggYW5pbWF0aW9ucy50aWNrICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XG5cdFx0XHRcdHF1ZXVlLnB1c2goIGFuaW1hdGlvbiApO1xuXHRcdFx0XHRpZiAoICFhbmltYXRpb25zLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRyQUYoIGFuaW1hdGlvbnMudGljayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVE9ETyBvcHRpbWlzZSB0aGlzXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oIGtleXBhdGgsIHJvb3QgKSB7XG5cdFx0XHRcdHZhciBpID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0XHRcdGFuaW1hdGlvbjtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gcXVldWVbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbi5yb290ID09PSByb290ICYmIGFuaW1hdGlvbi5rZXlwYXRoID09PSBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBhbmltYXRpb25zO1xuXHR9KCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGdldFRpbWUsIHJ1bmxvb3AgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvdHJhbnNmb3JtLmpzICovXG5cdHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgc2VsZWN0b3JzUGF0dGVybiA9IC8oPzpefFxcfSk/XFxzKihbXlxce1xcfV0rKVxccypcXHsvZyxcblx0XHRcdGNvbW1lbnRzUGF0dGVybiA9IC9cXC9cXCouKj9cXCpcXC8vZyxcblx0XHRcdHNlbGVjdG9yVW5pdFBhdHRlcm4gPSAvKCg/Oig/OlxcW1teXFxdK11cXF0pfCg/OlteXFxzXFwrXFw+XFx+Ol0pKSspKCg/OjpbXlxcc1xcK1xcPlxcfl0rKT9cXHMqW1xcc1xcK1xcPlxcfl0/KVxccyovZyxcblx0XHRcdG1lZGlhUXVlcnlQYXR0ZXJuID0gL15AbWVkaWEvLFxuXHRcdFx0ZGF0YVJ2Y0d1aWRQYXR0ZXJuID0gL1xcW2RhdGEtcnZjZ3VpZD1cIlthLXowLTktXStcIl0vZztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyggY3NzLCBndWlkICkge1xuXHRcdFx0dmFyIHRyYW5zZm9ybWVkLCBhZGRHdWlkO1xuXHRcdFx0YWRkR3VpZCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0dmFyIHNlbGVjdG9yVW5pdHMsIG1hdGNoLCB1bml0LCBkYXRhQXR0ciwgYmFzZSwgcHJlcGVuZGVkLCBhcHBlbmRlZCwgaSwgdHJhbnNmb3JtZWQgPSBbXTtcblx0XHRcdFx0c2VsZWN0b3JVbml0cyA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIG1hdGNoID0gc2VsZWN0b3JVbml0UGF0dGVybi5leGVjKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHNlbGVjdG9yVW5pdHMucHVzaCgge1xuXHRcdFx0XHRcdFx0c3RyOiBtYXRjaFsgMCBdLFxuXHRcdFx0XHRcdFx0YmFzZTogbWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdG1vZGlmaWVyczogbWF0Y2hbIDIgXVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBGb3IgZWFjaCBzaW1wbGUgc2VsZWN0b3Igd2l0aGluIHRoZSBzZWxlY3Rvciwgd2UgbmVlZCB0byBjcmVhdGUgYSB2ZXJzaW9uXG5cdFx0XHRcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgZ3VpZCwgYW5kIGIpIGlzIGluc2lkZSB0aGUgZ3VpZFxuXHRcdFx0XHRkYXRhQXR0ciA9ICdbZGF0YS1ydmNndWlkPVwiJyArIGd1aWQgKyAnXCJdJztcblx0XHRcdFx0YmFzZSA9IHNlbGVjdG9yVW5pdHMubWFwKCBleHRyYWN0U3RyaW5nICk7XG5cdFx0XHRcdGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YXBwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cdFx0XHRcdFx0Ly8gUHNldWRvLXNlbGVjdG9ycyBzaG91bGQgZ28gYWZ0ZXIgdGhlIGF0dHJpYnV0ZSBzZWxlY3RvclxuXHRcdFx0XHRcdHVuaXQgPSBzZWxlY3RvclVuaXRzWyBpIF07XG5cdFx0XHRcdFx0YXBwZW5kZWRbIGkgXSA9IHVuaXQuYmFzZSArIGRhdGFBdHRyICsgdW5pdC5tb2RpZmllcnMgfHwgJyc7XG5cdFx0XHRcdFx0cHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXHRcdFx0XHRcdHByZXBlbmRlZFsgaSBdID0gZGF0YUF0dHIgKyAnICcgKyBwcmVwZW5kZWRbIGkgXTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZC5wdXNoKCBhcHBlbmRlZC5qb2luKCAnICcgKSwgcHJlcGVuZGVkLmpvaW4oICcgJyApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRyYW5zZm9ybWVkLmpvaW4oICcsICcgKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoIGRhdGFSdmNHdWlkUGF0dGVybi50ZXN0KCBjc3MgKSApIHtcblx0XHRcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZSggZGF0YVJ2Y0d1aWRQYXR0ZXJuLCAnW2RhdGEtcnZjZ3VpZD1cIicgKyBndWlkICsgJ1wiXScgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoIGNvbW1lbnRzUGF0dGVybiwgJycgKS5yZXBsYWNlKCBzZWxlY3RvcnNQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3RvcnMsIHRyYW5zZm9ybWVkO1xuXHRcdFx0XHRcdC8vIGRvbid0IHRyYW5zZm9ybSBtZWRpYSBxdWVyaWVzIVxuXHRcdFx0XHRcdGlmICggbWVkaWFRdWVyeVBhdHRlcm4udGVzdCggJDEgKSApXG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdFx0c2VsZWN0b3JzID0gJDEuc3BsaXQoICcsJyApLm1hcCggdHJpbSApO1xuXHRcdFx0XHRcdHRyYW5zZm9ybWVkID0gc2VsZWN0b3JzLm1hcCggYWRkR3VpZCApLmpvaW4oICcsICcgKSArICcgJztcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSggJDEsIHRyYW5zZm9ybWVkICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJpbSggc3RyICkge1xuXHRcdFx0aWYgKCBzdHIudHJpbSApIHtcblx0XHRcdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9eXFxzKy8sICcnICkucmVwbGFjZSggL1xccyskLywgJycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRyYWN0U3RyaW5nKCB1bml0ICkge1xuXHRcdFx0cmV0dXJuIHVuaXQuc3RyO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvY3NzLmpzICovXG5cdHZhciBjc3MgPSBmdW5jdGlvbiggdHJhbnNmb3JtQ3NzICkge1xuXG5cdFx0dmFyIGNzc0NvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICdjc3MnLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBndWlkID0gcHJvdG8uY29uc3RydWN0b3IuX2d1aWQsXG5cdFx0XHRcdGNzcztcblx0XHRcdGlmICggY3NzID0gZ2V0Q3NzKCBvcHRpb25zLmNzcywgb3B0aW9ucywgZ3VpZCApIHx8IGdldENzcyggUGFyZW50LmNzcywgUGFyZW50LCBndWlkICkgKSB7XG5cdFx0XHRcdHByb3RvLmNvbnN0cnVjdG9yLmNzcyA9IGNzcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDc3MoIGNzcywgdGFyZ2V0LCBndWlkICkge1xuXHRcdFx0aWYgKCAhY3NzICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm5vQ3NzVHJhbnNmb3JtID8gY3NzIDogdHJhbnNmb3JtQ3NzKCBjc3MsIGd1aWQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNzc0NvbmZpZztcblx0fSggdHJhbnNmb3JtICk7XG5cblx0LyogdXRpbHMvd3JhcE1ldGhvZC5qcyAqL1xuXHR2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIG1ldGhvZCwgc3VwZXJNZXRob2QsIGZvcmNlICkge1xuXHRcdFx0aWYgKCBmb3JjZSB8fCBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaGFzU3VwZXIgPSAnX3N1cGVyJyBpbiB0aGlzLFxuXHRcdFx0XHRcdFx0X3N1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblx0XHRcdFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGlmICggaGFzU3VwZXIgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG5lZWRzU3VwZXIoIG1ldGhvZCwgc3VwZXJNZXRob2QgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHN1cGVyTWV0aG9kID09PSAnZnVuY3Rpb24nICYmIC9fc3VwZXIvLnRlc3QoIG1ldGhvZCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9kYXRhLmpzICovXG5cdHZhciBkYXRhID0gZnVuY3Rpb24oIHdyYXAgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGRhdGFDb25maWcgPSB7XG5cdFx0XHRuYW1lOiAnZGF0YScsXG5cdFx0XHRleHRlbmQ6IGV4dGVuZCxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZXNldDogcmVzZXRcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZGF0YUNvbmZpZztcblxuXHRcdGZ1bmN0aW9uIGNvbWJpbmUoIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9ucy5kYXRhIHx8IHt9LFxuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGdldEFkZGVkS2V5cyggUGFyZW50LnByb3RvdHlwZS5kYXRhICk7XG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnZGF0YSBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgXCInICsgdmFsdWUgKyAnXCIgaXMgbm90IHZhbGlkJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRpc3BhdGNoKCBwYXJlbnRWYWx1ZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRwcm90by5kYXRhID0gY29tYmluZSggUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXQoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSxcblx0XHRcdFx0cmVzdWx0ID0gY29tYmluZSggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHRpZiAoIHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jYWxsKCByYWN0aXZlLCB2YWx1ZSApIHx8IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhY3RpdmUuZGF0YSA9IHJlc3VsdCB8fCB7fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNldCggcmFjdGl2ZSApIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmluaXQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHJhY3RpdmUgKTtcblx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRyYWN0aXZlLmRhdGEgPSByZXN1bHQ7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEFkZGVkS2V5cyggcGFyZW50ICkge1xuXHRcdFx0Ly8gb25seSBmb3IgZnVuY3Rpb25zIHRoYXQgaGFkIGtleXMgYWRkZWRcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyB8fCAhT2JqZWN0LmtleXMoIHBhcmVudCApLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHRcdH1cblx0XHRcdC8vIGNvcHkgdGhlIGFkZGVkIGtleXMgdG8gdGVtcCAnb2JqZWN0Jywgb3RoZXJ3aXNlXG5cdFx0XHQvLyBwYXJlbnQgd291bGQgYmUgaW50ZXJwcmV0ZWQgYXMgJ2Z1bmN0aW9uJyBieSBkaXNwYXRjaFxuXHRcdFx0dmFyIHRlbXAgPSB7fTtcblx0XHRcdGNvcHkoIHBhcmVudCwgdGVtcCApO1xuXHRcdFx0Ly8gcm9sbCBpbiBhZGRlZCBrZXlzXG5cdFx0XHRyZXR1cm4gZGlzcGF0Y2goIHBhcmVudCwgdGVtcCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3BhdGNoKCBwYXJlbnQsIGNoaWxkICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBleHRlbmRGbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGZyb21GbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29weSggZnJvbSwgdG8sIGZpbGxPbmx5ICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBmcm9tICkge1xuXHRcdFx0XHRpZiAoIGZpbGxPbmx5ICYmIGtleSBpbiB0byApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1sga2V5IF0gPSBmcm9tWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tUHJvcGVydGllcyggY2hpbGQsIHBhcmVudCApIHtcblx0XHRcdGNoaWxkID0gY2hpbGQgfHwge307XG5cdFx0XHRpZiAoICFwYXJlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNvcHkoIHBhcmVudCwgY2hpbGQsIHRydWUgKTtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tRm4oIGNoaWxkLCBwYXJlbnRGbiApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0dmFyIGtleXM7XG5cdFx0XHRcdGlmICggY2hpbGQgKSB7XG5cdFx0XHRcdFx0Ly8gVHJhY2sgdGhlIGtleXMgdGhhdCBvdXIgb24gdGhlIGNoaWxkLFxuXHRcdFx0XHRcdC8vIGJ1dCBub3Qgb24gdGhlIGRhdGEuIFdlJ2xsIG5lZWQgdG8gYXBwbHkgdGhlc2Vcblx0XHRcdFx0XHQvLyBhZnRlciB0aGUgcGFyZW50IGZ1bmN0aW9uIHJldHVybnMuXG5cdFx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2hpbGQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFkYXRhIHx8ICEoIGtleSBpbiBkYXRhICkgKSB7XG5cdFx0XHRcdFx0XHRcdGtleXMucHVzaCgga2V5ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNhbGwgdGhlIHBhcmVudCBmbiwgdXNlIGRhdGEgaWYgbm8gcmV0dXJuIHZhbHVlXG5cdFx0XHRcdGRhdGEgPSBwYXJlbnRGbi5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0Ly8gQ29weSBjaGlsZCBrZXlzIGJhY2sgb250byBkYXRhLiBUaGUgY2hpbGQga2V5c1xuXHRcdFx0XHQvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgd2hhdGV2ZXIgdGhlXG5cdFx0XHRcdC8vIHBhcmVudCBkaWQgd2l0aCB0aGUgZGF0YS5cblx0XHRcdFx0aWYgKCBrZXlzICYmIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gY2hpbGRbIGtleSBdO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kRm4oIGNoaWxkRm4sIHBhcmVudCApIHtcblx0XHRcdHZhciBwYXJlbnRGbjtcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gY29weSBwcm9wcyB0byBkYXRhXG5cdFx0XHRcdHBhcmVudEZuID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdFx0ZnJvbVByb3BlcnRpZXMoIGRhdGEsIHBhcmVudCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyZW50Rm4gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHQvLyBnaXZlIHBhcmVudCBmdW5jdGlvbiBpdCdzIG93biB0aGlzLl9zdXBlciBjb250ZXh0LFxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB0aGlzLl9zdXBlciBpcyBmcm9tIGNoaWxkIGFuZFxuXHRcdFx0XHRcdC8vIGNhdXNlcyBpbmZpbml0ZSBsb29wXG5cdFx0XHRcdFx0cGFyZW50ID0gd3JhcCggcGFyZW50LCBmdW5jdGlvbigpIHt9LCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3cmFwKCBjaGlsZEZuLCBwYXJlbnRGbiApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdyYXBNZXRob2QgKTtcblxuXHQvKiBjb25maWcvdHlwZXMuanMgKi9cblx0dmFyIHR5cGVzID0ge1xuXHRcdFRFWFQ6IDEsXG5cdFx0SU5URVJQT0xBVE9SOiAyLFxuXHRcdFRSSVBMRTogMyxcblx0XHRTRUNUSU9OOiA0LFxuXHRcdElOVkVSVEVEOiA1LFxuXHRcdENMT1NJTkc6IDYsXG5cdFx0RUxFTUVOVDogNyxcblx0XHRQQVJUSUFMOiA4LFxuXHRcdENPTU1FTlQ6IDksXG5cdFx0REVMSU1DSEFOR0U6IDEwLFxuXHRcdE1VU1RBQ0hFOiAxMSxcblx0XHRUQUc6IDEyLFxuXHRcdEFUVFJJQlVURTogMTMsXG5cdFx0Q0xPU0lOR19UQUc6IDE0LFxuXHRcdENPTVBPTkVOVDogMTUsXG5cdFx0TlVNQkVSX0xJVEVSQUw6IDIwLFxuXHRcdFNUUklOR19MSVRFUkFMOiAyMSxcblx0XHRBUlJBWV9MSVRFUkFMOiAyMixcblx0XHRPQkpFQ1RfTElURVJBTDogMjMsXG5cdFx0Qk9PTEVBTl9MSVRFUkFMOiAyNCxcblx0XHRHTE9CQUw6IDI2LFxuXHRcdEtFWV9WQUxVRV9QQUlSOiAyNyxcblx0XHRSRUZFUkVOQ0U6IDMwLFxuXHRcdFJFRklORU1FTlQ6IDMxLFxuXHRcdE1FTUJFUjogMzIsXG5cdFx0UFJFRklYX09QRVJBVE9SOiAzMyxcblx0XHRCUkFDS0VURUQ6IDM0LFxuXHRcdENPTkRJVElPTkFMOiAzNSxcblx0XHRJTkZJWF9PUEVSQVRPUjogMzYsXG5cdFx0SU5WT0NBVElPTjogNDAsXG5cdFx0U0VDVElPTl9JRjogNTAsXG5cdFx0U0VDVElPTl9VTkxFU1M6IDUxLFxuXHRcdFNFQ1RJT05fRUFDSDogNTIsXG5cdFx0U0VDVElPTl9XSVRIOiA1Myxcblx0XHRTRUNUSU9OX0lGX1dJVEg6IDU0XG5cdH07XG5cblx0LyogdXRpbHMvY3JlYXRlLmpzICovXG5cdHZhciBjcmVhdGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjcmVhdGU7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHRcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdC8vIHNpZ2hcblx0XHRcdGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgRiA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggcHJvdG8sIHByb3BzICkge1xuXHRcdFx0XHRcdHZhciBvYmo7XG5cdFx0XHRcdFx0aWYgKCBwcm90byA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdFx0XHRvYmogPSBuZXcgRigpO1xuXHRcdFx0XHRcdGlmICggcHJvcHMgKSB7XG5cdFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggb2JqLCBwcm9wcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlO1xuXHR9KCk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9lcnJvcnMuanMgKi9cblx0dmFyIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzID0ge1xuXHRcdGV4cGVjdGVkRXhwcmVzc2lvbjogJ0V4cGVjdGVkIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uJyxcblx0XHRleHBlY3RlZFBhcmVuOiAnRXhwZWN0ZWQgY2xvc2luZyBwYXJlbidcblx0fTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL251bWJlckxpdGVyYWwuanMgKi9cblx0dmFyIG51bWJlckxpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgbnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pKD86KD86KD86MHxbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKCByZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuTlVNQkVSX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvYm9vbGVhbkxpdGVyYWwuanMgKi9cblx0dmFyIGJvb2xlYW5MaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCA0ICkgPT09ICd0cnVlJyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyArPSA0O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkJPT0xFQU5fTElURVJBTCxcblx0XHRcdFx0XHR2OiAndHJ1ZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgNSApID09PSAnZmFsc2UnICkge1xuXHRcdFx0XHRwYXJzZXIucG9zICs9IDU7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQk9PTEVBTl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6ICdmYWxzZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL21ha2VRdW90ZWRTdHJpbmdNYXRjaGVyLmpzICovXG5cdHZhciBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cdFx0Ly8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuXHRcdC8vIEVPTC9FT0YgaXMgd3JpdHRlbiBhcyAoPyEuKSAobWVhbmluZyB0aGVyZSdzIG5vIG5vbi1uZXdsaW5lIGNoYXIgbmV4dCkuXG5cdFx0c3RyaW5nTWlkZGxlUGF0dGVybiA9IC9eKD89LilbXlwiJ1xcXFxdKz8oPzooPyEuKXwoPz1bXCInXFxcXF0pKS87XG5cdFx0Ly8gTWF0Y2ggb25lIGVzY2FwZSBzZXF1ZW5jZSwgaW5jbHVkaW5nIHRoZSBiYWNrc2xhc2guXG5cdFx0ZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblx0XHQvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuXHRcdGxpbmVDb250aW51YXRpb25QYXR0ZXJuID0gL15cXFxcKD86XFxyXFxufFtcXHUwMDBBXFx1MDAwRFxcdTIwMjhcXHUyMDI5XSkvO1xuXHRcdC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgZ2V0RG91YmxlUXVvdGVkU3RyaW5nIGFuZCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBva1F1b3RlICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBzdGFydCwgbGl0ZXJhbCwgZG9uZSwgbmV4dDtcblx0XHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRsaXRlcmFsID0gJ1wiJztcblx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHR3aGlsZSAoICFkb25lICkge1xuXHRcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzdHJpbmdNaWRkbGVQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggZXNjYXBlU2VxdWVuY2VQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKCBva1F1b3RlICk7XG5cdFx0XHRcdFx0aWYgKCBuZXh0ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBuZXh0ID09PSAnXCInICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXFxcXCInO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gJ1xcXFxcXCcnICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXCcnO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbGluZUNvbnRpbnVhdGlvblBhdHRlcm4gKTtcblx0XHRcdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29udmVydCBcXChuZXdsaW5lLWxpa2UpIGludG8gYSBcXHUgZXNjYXBlLCB3aGljaCBpcyBhbGxvd2VkIGluIEpTT05cblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFxcXHUnICsgKCAnMDAwJyArIG5leHQuY2hhckNvZGVBdCggMSApLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC00ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGl0ZXJhbCArPSAnXCInO1xuXHRcdFx0XHQvLyB1c2UgSlNPTi5wYXJzZSB0byBpbnRlcnByZXQgZXNjYXBlc1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSggbGl0ZXJhbCApO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL3NpbmdsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgc2luZ2xlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXCInICk7XG5cdH0oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL2RvdWJsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgZG91YmxlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXFwnJyApO1xuXHR9KCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9fc3RyaW5nTGl0ZXJhbC5qcyAqL1xuXHR2YXIgc3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLCBnZXREb3VibGVRdW90ZWRTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgc3RyaW5nO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdcIicgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXCInICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuU1RSSU5HX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogc3RyaW5nXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1xcJycgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0U2luZ2xlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXFwnJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlNUUklOR19MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHN0cmluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMsIHNpbmdsZVF1b3RlZFN0cmluZywgZG91YmxlUXVvdGVkU3RyaW5nICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9wYXR0ZXJucy5qcyAqL1xuXHR2YXIgcGF0dGVybnMgPSB7XG5cdFx0bmFtZTogL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovXG5cdH07XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9rZXkuanMgKi9cblx0dmFyIGtleSA9IGZ1bmN0aW9uKCBnZXRTdHJpbmdMaXRlcmFsLCBnZXROdW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApIHtcblxuXHRcdHZhciBpZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcblx0XHQvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXByb3BlcnRpZXNcblx0XHQvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRva2VuO1xuXHRcdFx0aWYgKCB0b2tlbiA9IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gaWRlbnRpZmllci50ZXN0KCB0b2tlbi52ICkgPyB0b2tlbi52IDogJ1wiJyArIHRva2VuLnYucmVwbGFjZSggL1wiL2csICdcXFxcXCInICkgKyAnXCInO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0b2tlbiA9IGdldE51bWJlckxpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW4udjtcblx0XHRcdH1cblx0XHRcdGlmICggdG9rZW4gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBzdHJpbmdMaXRlcmFsLCBudW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9rZXlWYWx1ZVBhaXIuanMgKi9cblx0dmFyIGtleVZhbHVlUGFpciA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGtleSA9IGdldEtleSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIGtleSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSAnOidcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBleHByZXNzaW9uIG11c3QgYmUgYSwgd2VsbC4uLiBleHByZXNzaW9uXG5cdFx0XHR2YWx1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLktFWV9WQUxVRV9QQUlSLFxuXHRcdFx0XHRrOiBrZXksXG5cdFx0XHRcdHY6IHZhbHVlXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBrZXkgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwva2V5VmFsdWVQYWlycy5qcyAqL1xuXHR2YXIga2V5VmFsdWVQYWlycyA9IGZ1bmN0aW9uKCBnZXRLZXlWYWx1ZVBhaXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBwYWlycywgcGFpciwga2V5VmFsdWVQYWlycztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhaXIgPSBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApO1xuXHRcdFx0aWYgKCBwYWlyID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXJzID0gWyBwYWlyIF07XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAha2V5VmFsdWVQYWlycyApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhaXJzLmNvbmNhdCgga2V5VmFsdWVQYWlycyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhaXJzO1xuXHRcdH07XG5cdH0oIGtleVZhbHVlUGFpciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9fb2JqZWN0TGl0ZXJhbC5qcyAqL1xuXHR2YXIgb2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5VmFsdWVQYWlycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBrZXlWYWx1ZVBhaXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAneycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuT0JKRUNUX0xJVEVSQUwsXG5cdFx0XHRcdG06IGtleVZhbHVlUGFpcnNcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGtleVZhbHVlUGFpcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2V4cHJlc3Npb25MaXN0LmpzICovXG5cdHZhciBleHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uKCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoIGV4cHIgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZXhwcmVzc2lvbnMgPSBbIGV4cHIgXTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBleHByZXNzaW9uIGFuZCAnLCdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0bmV4dCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCBuZXh0ID09PSBudWxsICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQuZm9yRWFjaCggYXBwZW5kICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFwcGVuZCggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0ZXhwcmVzc2lvbnMucHVzaCggZXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuXHRcdH07XG5cdH0oIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9hcnJheUxpdGVyYWwuanMgKi9cblx0dmFyIGFycmF5TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0RXhwcmVzc2lvbkxpc3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSAnWydcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRleHByZXNzaW9uTGlzdCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5BUlJBWV9MSVRFUkFMLFxuXHRcdFx0XHRtOiBleHByZXNzaW9uTGlzdFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgZXhwcmVzc2lvbkxpc3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL19saXRlcmFsLmpzICovXG5cdHZhciBsaXRlcmFsID0gZnVuY3Rpb24oIGdldE51bWJlckxpdGVyYWwsIGdldEJvb2xlYW5MaXRlcmFsLCBnZXRTdHJpbmdMaXRlcmFsLCBnZXRPYmplY3RMaXRlcmFsLCBnZXRBcnJheUxpdGVyYWwgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBsaXRlcmFsID0gZ2V0TnVtYmVyTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0Qm9vbGVhbkxpdGVyYWwoIHBhcnNlciApIHx8IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApIHx8IGdldE9iamVjdExpdGVyYWwoIHBhcnNlciApIHx8IGdldEFycmF5TGl0ZXJhbCggcGFyc2VyICk7XG5cdFx0XHRyZXR1cm4gbGl0ZXJhbDtcblx0XHR9O1xuXHR9KCBudW1iZXJMaXRlcmFsLCBib29sZWFuTGl0ZXJhbCwgc3RyaW5nTGl0ZXJhbCwgb2JqZWN0TGl0ZXJhbCwgYXJyYXlMaXRlcmFsICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvcmVmZXJlbmNlLmpzICovXG5cdHZhciByZWZlcmVuY2UgPSBmdW5jdGlvbiggdHlwZXMsIHBhdHRlcm5zICkge1xuXG5cdFx0dmFyIGRvdFJlZmluZW1lbnRQYXR0ZXJuLCBhcnJheU1lbWJlclBhdHRlcm4sIGdldEFycmF5UmVmaW5lbWVudCwgZ2xvYmFscywga2V5d29yZHM7XG5cdFx0ZG90UmVmaW5lbWVudFBhdHRlcm4gPSAvXlxcLlthLXpBLVpfJDAtOV0rLztcblx0XHRnZXRBcnJheVJlZmluZW1lbnQgPSBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIG51bSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGFycmF5TWVtYmVyUGF0dGVybiApO1xuXHRcdFx0aWYgKCBudW0gKSB7XG5cdFx0XHRcdHJldHVybiAnLicgKyBudW07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eXFxbKDB8WzEtOV1bMC05XSopXFxdLztcblx0XHQvLyBpZiBhIHJlZmVyZW5jZSBpcyBhIGJyb3dzZXIgZ2xvYmFsLCB3ZSBkb24ndCBkZWZlcmVuY2UgaXQgbGF0ZXIsIHNvIGl0IG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50XG5cdFx0Z2xvYmFscyA9IC9eKD86QXJyYXl8Y29uc29sZXxEYXRlfFJlZ0V4cHxkZWNvZGVVUklDb21wb25lbnR8ZGVjb2RlVVJJfGVuY29kZVVSSUNvbXBvbmVudHxlbmNvZGVVUkl8aXNGaW5pdGV8aXNOYU58cGFyc2VGbG9hdHxwYXJzZUludHxKU09OfE1hdGh8TmFOfHVuZGVmaW5lZHxudWxsKSQvO1xuXHRcdC8vIGtleXdvcmRzIGFyZSBub3QgdmFsaWQgcmVmZXJlbmNlcywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGB0aGlzYFxuXHRcdGtleXdvcmRzID0gL14oPzpicmVha3xjYXNlfGNhdGNofGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8cmV0dXJufHN3aXRjaHx0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGgpJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnRQb3MsIGFuY2VzdG9yLCBuYW1lLCBkb3QsIGNvbWJvLCByZWZpbmVtZW50LCBsYXN0RG90SW5kZXg7XG5cdFx0XHRzdGFydFBvcyA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGEgcm9vdC1sZXZlbCByZWZlcmVuY2Vcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnfi8nICkgKSB7XG5cdFx0XHRcdGFuY2VzdG9yID0gJ34vJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHdlIG1pZ2h0IGhhdmUgYW5jZXN0b3IgcmVmcy4uLlxuXHRcdFx0XHRhbmNlc3RvciA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoIHBhcnNlci5tYXRjaFN0cmluZyggJy4uLycgKSApIHtcblx0XHRcdFx0XHRhbmNlc3RvciArPSAnLi4vJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhYW5jZXN0b3IgKSB7XG5cdFx0XHRcdC8vIHdlIG1pZ2h0IGhhdmUgYW4gaW1wbGljaXQgaXRlcmF0b3Igb3IgYSByZXN0cmljdGVkIHJlZmVyZW5jZVxuXHRcdFx0XHRkb3QgPSBwYXJzZXIubWF0Y2hTdHJpbmcoICcuLycgKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuJyApIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIC9eQCg/OmtleXBhdGh8aW5kZXh8a2V5KS8gKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgfHwgJyc7XG5cdFx0XHQvLyBidWcgb3V0IGlmIGl0J3MgYSBrZXl3b3JkXG5cdFx0XHRpZiAoIGtleXdvcmRzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBicm93c2VyIGdsb2JhbCwgc3RvcCBoZXJlXG5cdFx0XHRpZiAoICFhbmNlc3RvciAmJiAhZG90ICYmIGdsb2JhbHMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkdMT0JBTCxcblx0XHRcdFx0XHR2OiBuYW1lXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRjb21ibyA9ICggYW5jZXN0b3IgfHwgZG90ICkgKyBuYW1lO1xuXHRcdFx0aWYgKCAhY29tYm8gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKCByZWZpbmVtZW50ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZG90UmVmaW5lbWVudFBhdHRlcm4gKSB8fCBnZXRBcnJheVJlZmluZW1lbnQoIHBhcnNlciApICkge1xuXHRcdFx0XHRjb21ibyArPSByZWZpbmVtZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIGludm9jYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBmdW5jdGlvbikgd2UgbmVlZFxuXHRcdFx0XHQvLyB0byBzdHJpcCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgcmVmZXJlbmNlIGNvbWJvLCBlbHNlIHRoZSBjb250ZXh0XG5cdFx0XHRcdC8vIHdpbGwgYmUgd3Jvbmdcblx0XHRcdFx0bGFzdERvdEluZGV4ID0gY29tYm8ubGFzdEluZGV4T2YoICcuJyApO1xuXHRcdFx0XHRpZiAoIGxhc3REb3RJbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0Y29tYm8gPSBjb21iby5zdWJzdHIoIDAsIGxhc3REb3RJbmRleCApO1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcyArIGNvbWJvLmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zIC09IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLlJFRkVSRU5DRSxcblx0XHRcdFx0bjogY29tYm8ucmVwbGFjZSggL150aGlzXFwuLywgJy4vJyApLnJlcGxhY2UoIC9edGhpcyQvLCAnLicgKVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGF0dGVybnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9icmFja2V0ZWRFeHByZXNzaW9uLmpzICovXG5cdHZhciBicmFja2V0ZWRFeHByZXNzaW9uID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0ZXhwciA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhZXhwciApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcpJyApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZFBhcmVuICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5CUkFDS0VURUQsXG5cdFx0XHRcdHg6IGV4cHJcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvX3ByaW1hcnkuanMgKi9cblx0dmFyIHByaW1hcnkgPSBmdW5jdGlvbiggZ2V0TGl0ZXJhbCwgZ2V0UmVmZXJlbmNlLCBnZXRCcmFja2V0ZWRFeHByZXNzaW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRyZXR1cm4gZ2V0TGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0UmVmZXJlbmNlKCBwYXJzZXIgKSB8fCBnZXRCcmFja2V0ZWRFeHByZXNzaW9uKCBwYXJzZXIgKTtcblx0XHR9O1xuXHR9KCBsaXRlcmFsLCByZWZlcmVuY2UsIGJyYWNrZXRlZEV4cHJlc3Npb24gKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL3JlZmluZW1lbnQuanMgKi9cblx0dmFyIHJlZmluZW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIGVycm9ycywgcGF0dGVybnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UmVmaW5lbWVudCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBuYW1lLCBleHByO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gXCIuXCIgbmFtZVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuJyApICkge1xuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGlmICggbmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBhdHRlcm5zLm5hbWUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuUkVGSU5FTUVOVCxcblx0XHRcdFx0XHRcdG46IG5hbWVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGEgcHJvcGVydHkgbmFtZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIFwiW1wiIGV4cHJlc3Npb24gXCJdXCJcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdGlmICggIWV4cHIgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIFxcJ11cXCcnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5SRUZJTkVNRU5ULFxuXHRcdFx0XHRcdHg6IGV4cHJcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycywgcGF0dGVybnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvbWVtYmVyT3JJbnZvY2F0aW9uLmpzICovXG5cdHZhciBtZW1iZXJPckludm9jYXRpb24gPSBmdW5jdGlvbiggdHlwZXMsIGdldFByaW1hcnksIGdldEV4cHJlc3Npb25MaXN0LCBnZXRSZWZpbmVtZW50LCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBjdXJyZW50LCBleHByZXNzaW9uLCByZWZpbmVtZW50LCBleHByZXNzaW9uTGlzdDtcblx0XHRcdGV4cHJlc3Npb24gPSBnZXRQcmltYXJ5KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKCBleHByZXNzaW9uICkge1xuXHRcdFx0XHRjdXJyZW50ID0gcGFyc2VyLnBvcztcblx0XHRcdFx0aWYgKCByZWZpbmVtZW50ID0gZ2V0UmVmaW5lbWVudCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLk1FTUJFUixcblx0XHRcdFx0XHRcdHg6IGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0XHRyOiByZWZpbmVtZW50XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbkxpc3QgPSBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICk7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJyknICkgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZFBhcmVuICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5JTlZPQ0FUSU9OLFxuXHRcdFx0XHRcdFx0eDogZXhwcmVzc2lvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKCBleHByZXNzaW9uTGlzdCApIHtcblx0XHRcdFx0XHRcdGV4cHJlc3Npb24ubyA9IGV4cHJlc3Npb25MaXN0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG5cdFx0fTtcblx0fSggdHlwZXMsIHByaW1hcnksIGV4cHJlc3Npb25MaXN0LCByZWZpbmVtZW50LCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy90eXBlb2YuanMgKi9cblx0dmFyIF90eXBlb2YgPSBmdW5jdGlvbiggdHlwZXMsIGVycm9ycywgZ2V0TWVtYmVyT3JJbnZvY2F0aW9uICkge1xuXG5cdFx0dmFyIGdldFR5cGVvZiwgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlcjtcblx0XHRtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24oIHN5bWJvbCwgZmFsbHRocm91Z2ggKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdFx0dmFyIGV4cHJlc3Npb247XG5cdFx0XHRcdGlmICggZXhwcmVzc2lvbiA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHN5bWJvbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0czogc3ltYm9sLFxuXHRcdFx0XHRcdG86IGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0dDogdHlwZXMuUFJFRklYX09QRVJBVE9SXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gY3JlYXRlIGFsbCBwcmVmaXggc2VxdWVuY2UgbWF0Y2hlcnMsIHJldHVybiBnZXRUeXBlb2Zcblx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgcHJlZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblx0XHRcdHByZWZpeE9wZXJhdG9ycyA9ICchIH4gKyAtIHR5cGVvZicuc3BsaXQoICcgJyApO1xuXHRcdFx0ZmFsbHRocm91Z2ggPSBnZXRNZW1iZXJPckludm9jYXRpb247XG5cdFx0XHRmb3IgKCBpID0gMCwgbGVuID0gcHJlZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRtYXRjaGVyID0gbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciggcHJlZml4T3BlcmF0b3JzWyBpIF0sIGZhbGx0aHJvdWdoICk7XG5cdFx0XHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcblx0XHRcdH1cblx0XHRcdC8vIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uLCBzbyBwcm92aWRlcyB0aGVcblx0XHRcdC8vIGZhbGx0aHJvdWdoIGZvciB0aGUgbXVsdGlwbGljYXRpb24gc2VxdWVuY2UgbWF0Y2hlciB3ZSdyZSBhYm91dCB0byBjcmVhdGVcblx0XHRcdC8vICh3ZSdyZSBza2lwcGluZyB2b2lkIGFuZCBkZWxldGUpXG5cdFx0XHRnZXRUeXBlb2YgPSBmYWxsdGhyb3VnaDtcblx0XHR9KCkgKTtcblx0XHRyZXR1cm4gZ2V0VHlwZW9mO1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMsIG1lbWJlck9ySW52b2NhdGlvbiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9sb2dpY2FsT3IuanMgKi9cblx0dmFyIGxvZ2ljYWxPciA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0VHlwZW9mICkge1xuXG5cdFx0dmFyIGdldExvZ2ljYWxPciwgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyO1xuXHRcdG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uKCBzeW1ib2wsIGZhbGx0aHJvdWdoICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBzdGFydCwgbGVmdCwgcmlnaHQ7XG5cdFx0XHRcdGxlZnQgPSBmYWxsdGhyb3VnaCggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIWxlZnQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTG9vcCB0byBoYW5kbGUgbGVmdC1yZWN1cnNpb24gaW4gYSBjYXNlIGxpa2UgYGEgKiBiICogY2AgYW5kIHByb2R1Y2Vcblx0XHRcdFx0Ly8gbGVmdCBhc3NvY2lhdGlvbiwgaS5lLiBgKGEgKiBiKSAqIGNgLiAgVGhlIG1hdGNoZXIgY2FuJ3QgY2FsbCBpdHNlbGZcblx0XHRcdFx0Ly8gdG8gcGFyc2UgYGxlZnRgIGJlY2F1c2UgdGhhdCB3b3VsZCBiZSBpbmZpbml0ZSByZWdyZXNzLlxuXHRcdFx0XHR3aGlsZSAoIHRydWUgKSB7XG5cdFx0XHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHN5bWJvbCApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGluIG9wZXJhdG9yIG11c3Qgbm90IGJlIGZvbGxvd2VkIGJ5IFthLXpBLVpfJDAtOV1cblx0XHRcdFx0XHRpZiAoIHN5bWJvbCA9PT0gJ2luJyAmJiAvW2EtekEtWl8kMC05XS8udGVzdCggcGFyc2VyLnJlbWFpbmluZygpLmNoYXJBdCggMCApICkgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdC8vIHJpZ2h0IG9wZXJhbmQgbXVzdCBhbHNvIGNvbnNpc3Qgb2Ygb25seSBoaWdoZXItcHJlY2VkZW5jZSBvcGVyYXRvcnNcblx0XHRcdFx0XHRyaWdodCA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKTtcblx0XHRcdFx0XHRpZiAoICFyaWdodCApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZWZ0ID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuSU5GSVhfT1BFUkFUT1IsXG5cdFx0XHRcdFx0XHRzOiBzeW1ib2wsXG5cdFx0XHRcdFx0XHRvOiBbXG5cdFx0XHRcdFx0XHRcdGxlZnQsXG5cdFx0XHRcdFx0XHRcdHJpZ2h0XG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIGNyZWF0ZSBhbGwgaW5maXggc2VxdWVuY2UgbWF0Y2hlcnMsIGFuZCByZXR1cm4gZ2V0TG9naWNhbE9yXG5cdFx0KCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpLCBsZW4sIG1hdGNoZXIsIGluZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblx0XHRcdC8vIEFsbCB0aGUgaW5maXggb3BlcmF0b3JzIG9uIG9yZGVyIG9mIHByZWNlZGVuY2UgKHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZSlcblx0XHRcdC8vIEVhY2ggc2VxdWVuY2UgbWF0Y2hlciB3aWxsIGluaXRpYWxseSBmYWxsIHRocm91Z2ggdG8gaXRzIGhpZ2hlciBwcmVjZWRlbmNlXG5cdFx0XHQvLyBuZWlnaGJvdXIsIGFuZCBvbmx5IGF0dGVtcHQgdG8gbWF0Y2ggaWYgb25lIG9mIHRoZSBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnNcblx0XHRcdC8vIChvciwgdWx0aW1hdGVseSwgYSBsaXRlcmFsLCByZWZlcmVuY2UsIG9yIGJyYWNrZXRlZCBleHByZXNzaW9uKSBhbHJlYWR5IG1hdGNoZWRcblx0XHRcdGluZml4T3BlcmF0b3JzID0gJyogLyAlICsgLSA8PCA+PiA+Pj4gPCA8PSA+ID49IGluIGluc3RhbmNlb2YgPT0gIT0gPT09ICE9PSAmIF4gfCAmJiB8fCcuc3BsaXQoICcgJyApO1xuXHRcdFx0Ly8gQSB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvblxuXHRcdFx0ZmFsbHRocm91Z2ggPSBnZXRUeXBlb2Y7XG5cdFx0XHRmb3IgKCBpID0gMCwgbGVuID0gaW5maXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG1hdGNoZXIgPSBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIoIGluZml4T3BlcmF0b3JzWyBpIF0sIGZhbGx0aHJvdWdoICk7XG5cdFx0XHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcblx0XHRcdH1cblx0XHRcdC8vIExvZ2ljYWwgT1IgaXMgdGhlIGZhbGx0aHJvdWdoIGZvciB0aGUgY29uZGl0aW9uYWwgbWF0Y2hlclxuXHRcdFx0Z2V0TG9naWNhbE9yID0gZmFsbHRocm91Z2g7XG5cdFx0fSgpICk7XG5cdFx0cmV0dXJuIGdldExvZ2ljYWxPcjtcblx0fSggdHlwZXMsIF90eXBlb2YgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvY29uZGl0aW9uYWwuanMgKi9cblx0dmFyIGNvbmRpdGlvbmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRMb2dpY2FsT3IsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2U7XG5cdFx0XHRleHByZXNzaW9uID0gZ2V0TG9naWNhbE9yKCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmVHJ1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZUcnVlICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIFwiOlwiJyApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWZGYWxzZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZGYWxzZSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5DT05ESVRJT05BTCxcblx0XHRcdFx0bzogW1xuXHRcdFx0XHRcdGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0aWZUcnVlLFxuXHRcdFx0XHRcdGlmRmFsc2Vcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgbG9naWNhbE9yLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci91dGlscy9mbGF0dGVuRXhwcmVzc2lvbi5qcyAqL1xuXHR2YXIgZmxhdHRlbkV4cHJlc3Npb24gPSBmdW5jdGlvbiggdHlwZXMsIGlzT2JqZWN0ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgcmVmcyA9IFtdLFxuXHRcdFx0XHRmbGF0dGVuZWQ7XG5cdFx0XHRleHRyYWN0UmVmcyggZXhwcmVzc2lvbiwgcmVmcyApO1xuXHRcdFx0ZmxhdHRlbmVkID0ge1xuXHRcdFx0XHRyOiByZWZzLFxuXHRcdFx0XHRzOiBzdHJpbmdpZnkoIHRoaXMsIGV4cHJlc3Npb24sIHJlZnMgKVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiBmbGF0dGVuZWQ7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHF1b3RlU3RyaW5nTGl0ZXJhbCggc3RyICkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCBTdHJpbmcoIHN0ciApICk7XG5cdFx0fVxuXHRcdC8vIFRPRE8gbWF5YmUgcmVmYWN0b3IgdGhpcz9cblx0XHRmdW5jdGlvbiBleHRyYWN0UmVmcyggbm9kZSwgcmVmcyApIHtcblx0XHRcdHZhciBpLCBsaXN0O1xuXHRcdFx0aWYgKCBub2RlLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0aWYgKCByZWZzLmluZGV4T2YoIG5vZGUubiApID09PSAtMSApIHtcblx0XHRcdFx0XHRyZWZzLnVuc2hpZnQoIG5vZGUubiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaXN0ID0gbm9kZS5vIHx8IG5vZGUubTtcblx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0aWYgKCBpc09iamVjdCggbGlzdCApICkge1xuXHRcdFx0XHRcdGV4dHJhY3RSZWZzKCBsaXN0LCByZWZzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0ZXh0cmFjdFJlZnMoIGxpc3RbIGkgXSwgcmVmcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnggKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLngsIHJlZnMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS5yICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS5yLCByZWZzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUudiApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUudiwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLCByZWZzICkge1xuXHRcdFx0dmFyIHN0cmluZ2lmeUFsbCA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIGl0ZW0sIHJlZnMgKTtcblx0XHRcdH07XG5cdFx0XHRzd2l0Y2ggKCBub2RlLnQgKSB7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQk9PTEVBTl9MSVRFUkFMOlxuXHRcdFx0XHRjYXNlIHR5cGVzLkdMT0JBTDpcblx0XHRcdFx0Y2FzZSB0eXBlcy5OVU1CRVJfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS52O1xuXHRcdFx0XHRjYXNlIHR5cGVzLlNUUklOR19MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiBxdW90ZVN0cmluZ0xpdGVyYWwoIG5vZGUudiApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkFSUkFZX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuICdbJyArICggbm9kZS5tID8gbm9kZS5tLm1hcCggc3RyaW5naWZ5QWxsICkuam9pbiggJywnICkgOiAnJyApICsgJ10nO1xuXHRcdFx0XHRjYXNlIHR5cGVzLk9CSkVDVF9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiAneycgKyAoIG5vZGUubSA/IG5vZGUubS5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICd9Jztcblx0XHRcdFx0Y2FzZSB0eXBlcy5LRVlfVkFMVUVfUEFJUjpcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5rICsgJzonICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUudiwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlBSRUZJWF9PUEVSQVRPUjpcblx0XHRcdFx0XHRyZXR1cm4gKCBub2RlLnMgPT09ICd0eXBlb2YnID8gJ3R5cGVvZiAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vLCByZWZzICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuSU5GSVhfT1BFUkFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDAgXSwgcmVmcyApICsgKCBub2RlLnMuc3Vic3RyKCAwLCAyICkgPT09ICdpbicgPyAnICcgKyBub2RlLnMgKyAnICcgOiBub2RlLnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDEgXSwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLklOVk9DQVRJT046XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICcoJyArICggbm9kZS5vID8gbm9kZS5vLm1hcCggc3RyaW5naWZ5QWxsICkuam9pbiggJywnICkgOiAnJyApICsgJyknO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkJSQUNLRVRFRDpcblx0XHRcdFx0XHRyZXR1cm4gJygnICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgJyknO1xuXHRcdFx0XHRjYXNlIHR5cGVzLk1FTUJFUjpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUuciwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlJFRklORU1FTlQ6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUubiA/ICcuJyArIG5vZGUubiA6ICdbJyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICddJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5DT05ESVRJT05BTDpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMCBdLCByZWZzICkgKyAnPycgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAxIF0sIHJlZnMgKSArICc6JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDIgXSwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlJFRkVSRU5DRTpcblx0XHRcdFx0XHRyZXR1cm4gJ18nICsgcmVmcy5pbmRleE9mKCBub2RlLm4gKTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBsZWdhbCBKYXZhU2NyaXB0JyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBpc09iamVjdCApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9fUGFyc2VyLmpzICovXG5cdHZhciBQYXJzZXIgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGNyZWF0ZSwgaGFzT3duUHJvcGVydHksIGdldENvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiApIHtcblxuXHRcdHZhciBQYXJzZXIsIFBhcnNlRXJyb3IsIGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLztcblx0XHRQYXJzZUVycm9yID0gZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSAnUGFyc2VFcnJvcic7XG5cdFx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0dGhpcy5zdGFjayA9IGUuc3RhY2s7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblx0XHRQYXJzZXIgPSBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGl0ZW1zLCBpdGVtLCBsaW5lU3RhcnQgPSAwO1xuXHRcdFx0dGhpcy5zdHIgPSBzdHI7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0dGhpcy5wb3MgPSAwO1xuXHRcdFx0dGhpcy5saW5lcyA9IHRoaXMuc3RyLnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0dGhpcy5saW5lRW5kcyA9IHRoaXMubGluZXMubWFwKCBmdW5jdGlvbiggbGluZSApIHtcblx0XHRcdFx0dmFyIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7XG5cdFx0XHRcdC8vICsxIGZvciB0aGUgbmV3bGluZVxuXHRcdFx0XHRsaW5lU3RhcnQgPSBsaW5lRW5kO1xuXHRcdFx0XHRyZXR1cm4gbGluZUVuZDtcblx0XHRcdH0sIDAgKTtcblx0XHRcdC8vIEN1c3RvbSBpbml0IGxvZ2ljXG5cdFx0XHRpZiAoIHRoaXMuaW5pdCApXG5cdFx0XHRcdHRoaXMuaW5pdCggc3RyLCBvcHRpb25zICk7XG5cdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0d2hpbGUgKCB0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoIGl0ZW0gPSB0aGlzLnJlYWQoKSApICkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcblx0XHRcdHRoaXMucmVzdWx0ID0gdGhpcy5wb3N0UHJvY2VzcyA/IHRoaXMucG9zdFByb2Nlc3MoIGl0ZW1zLCBvcHRpb25zICkgOiBpdGVtcztcblx0XHR9O1xuXHRcdFBhcnNlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiggY29udmVydGVycyApIHtcblx0XHRcdFx0dmFyIHBvcywgaSwgbGVuLCBpdGVtO1xuXHRcdFx0XHRpZiAoICFjb252ZXJ0ZXJzIClcblx0XHRcdFx0XHRjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXHRcdFx0XHRwb3MgPSB0aGlzLnBvcztcblx0XHRcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgPSBwb3M7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgZm9yIGVhY2ggYXR0ZW1wdFxuXHRcdFx0XHRcdGlmICggaXRlbSA9IGNvbnZlcnRlcnNbIGkgXSggdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdHJlYWRFeHByZXNzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciAoZXhjZXB0IHlpZWxkLFxuXHRcdFx0XHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2Vcblx0XHRcdFx0Ly8gc3RhcnQgdGhlcmUuIElmIGl0IGRvZXNuJ3QgbWF0Y2gsIGl0ICdmYWxscyB0aHJvdWdoJyB0byBwcm9ncmVzc2l2ZWx5XG5cdFx0XHRcdC8vIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9ycywgdW50aWwgaXQgZXZlbnR1YWxseSBtYXRjaGVzIChvciBmYWlscyB0b1xuXHRcdFx0XHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG5cdFx0XHRcdC8vIHRyZWUgaGFzIGV2ZXJ5dGhpbmcgaW4gaXRzIHByb3BlciBwbGFjZSwgaS5lLiAyICsgMyAqIDQgPT09IDE0LCBub3QgMjAuXG5cdFx0XHRcdHJldHVybiBnZXRDb25kaXRpb25hbCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGZsYXR0ZW5FeHByZXNzaW9uOiBmbGF0dGVuRXhwcmVzc2lvbixcblx0XHRcdGdldExpbmVQb3M6IGZ1bmN0aW9uKCBjaGFyICkge1xuXHRcdFx0XHR2YXIgbGluZU51bSA9IDAsXG5cdFx0XHRcdFx0bGluZVN0YXJ0ID0gMCxcblx0XHRcdFx0XHRjb2x1bW5OdW07XG5cdFx0XHRcdHdoaWxlICggY2hhciA+PSB0aGlzLmxpbmVFbmRzWyBsaW5lTnVtIF0gKSB7XG5cdFx0XHRcdFx0bGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kc1sgbGluZU51bSBdO1xuXHRcdFx0XHRcdGxpbmVOdW0gKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2x1bW5OdW0gPSBjaGFyIC0gbGluZVN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGxpbmVOdW0gKyAxLFxuXHRcdFx0XHRcdGNvbHVtbk51bSArIDEsXG5cdFx0XHRcdFx0Y2hhclxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiggbWVzc2FnZSApIHtcblx0XHRcdFx0dmFyIHBvcywgbGluZU51bSwgY29sdW1uTnVtLCBsaW5lLCBhbm5vdGF0aW9uLCBlcnJvcjtcblx0XHRcdFx0cG9zID0gdGhpcy5nZXRMaW5lUG9zKCB0aGlzLnBvcyApO1xuXHRcdFx0XHRsaW5lTnVtID0gcG9zWyAwIF07XG5cdFx0XHRcdGNvbHVtbk51bSA9IHBvc1sgMSBdO1xuXHRcdFx0XHRsaW5lID0gdGhpcy5saW5lc1sgcG9zWyAwIF0gLSAxIF07XG5cdFx0XHRcdGFubm90YXRpb24gPSBsaW5lICsgJ1xcbicgKyBuZXcgQXJyYXkoIHBvc1sgMSBdICkuam9pbiggJyAnICkgKyAnXi0tLS0nO1xuXHRcdFx0XHRlcnJvciA9IG5ldyBQYXJzZUVycm9yKCBtZXNzYWdlICsgJyBhdCBsaW5lICcgKyBsaW5lTnVtICsgJyBjaGFyYWN0ZXIgJyArIGNvbHVtbk51bSArICc6XFxuJyArIGFubm90YXRpb24gKTtcblx0XHRcdFx0ZXJyb3IubGluZSA9IHBvc1sgMCBdO1xuXHRcdFx0XHRlcnJvci5jaGFyYWN0ZXIgPSBwb3NbIDEgXTtcblx0XHRcdFx0ZXJyb3Iuc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9LFxuXHRcdFx0bWF0Y2hTdHJpbmc6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zdHIuc3Vic3RyKCB0aGlzLnBvcywgc3RyaW5nLmxlbmd0aCApID09PSBzdHJpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bWF0Y2hQYXR0ZXJuOiBmdW5jdGlvbiggcGF0dGVybiApIHtcblx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRpZiAoIG1hdGNoID0gcGF0dGVybi5leGVjKCB0aGlzLnJlbWFpbmluZygpICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbIDAgXS5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoWyAxIF0gfHwgbWF0Y2hbIDAgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsbG93V2hpdGVzcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMubWF0Y2hQYXR0ZXJuKCBsZWFkaW5nV2hpdGVzcGFjZSApO1xuXHRcdFx0fSxcblx0XHRcdHJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0ci5zdWJzdHJpbmcoIHRoaXMucG9zICk7XG5cdFx0XHR9LFxuXHRcdFx0bmV4dENoYXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KCB0aGlzLnBvcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uKCBwcm90byApIHtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRDaGlsZCwga2V5O1xuXHRcdFx0Q2hpbGQgPSBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHRQYXJzZXIuY2FsbCggdGhpcywgc3RyLCBvcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0Q2hpbGQucHJvdG90eXBlID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRmb3IgKCBrZXkgaW4gcHJvdG8gKSB7XG5cdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggcHJvdG8sIGtleSApICkge1xuXHRcdFx0XHRcdENoaWxkLnByb3RvdHlwZVsga2V5IF0gPSBwcm90b1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdENoaWxkLmV4dGVuZCA9IFBhcnNlci5leHRlbmQ7XG5cdFx0XHRyZXR1cm4gQ2hpbGQ7XG5cdFx0fTtcblx0XHRjaXJjdWxhci5QYXJzZXIgPSBQYXJzZXI7XG5cdFx0cmV0dXJuIFBhcnNlcjtcblx0fSggY2lyY3VsYXIsIGNyZWF0ZSwgaGFzT3duLCBjb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24gKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2RlbGltaXRlckNoYW5nZS5qcyAqL1xuXHR2YXIgZGVsaW1pdGVyQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiA9IC9eW15cXHM9XSsvLFxuXHRcdFx0d2hpdGVzcGFjZVBhdHRlcm4gPSAvXlxccysvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBvcGVuaW5nLCBjbG9zaW5nO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPScgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBuZXcgb3BlbmluZyBkZWxpbWl0ZXJcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFvcGVuaW5nICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSAoaW4gZmFjdCwgaXQncyBuZWNlc3NhcnkuLi4pXG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hQYXR0ZXJuKCB3aGl0ZXNwYWNlUGF0dGVybiApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGNsb3NpbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFjbG9zaW5nICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyAnPSdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRvcGVuaW5nLFxuXHRcdFx0XHRjbG9zaW5nXG5cdFx0XHRdO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2RlbGltaXRlclR5cGVzLmpzICovXG5cdHZhciBkZWxpbWl0ZXJUeXBlcyA9IFsge1xuXHRcdGRlbGltaXRlcnM6ICdkZWxpbWl0ZXJzJyxcblx0XHRpc1RyaXBsZTogZmFsc2UsXG5cdFx0aXNTdGF0aWM6IGZhbHNlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAndHJpcGxlRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IHRydWUsXG5cdFx0aXNTdGF0aWM6IGZhbHNlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAnc3RhdGljRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IGZhbHNlLFxuXHRcdGlzU3RhdGljOiB0cnVlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAnc3RhdGljVHJpcGxlRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IHRydWUsXG5cdFx0aXNTdGF0aWM6IHRydWVcblx0fSBdO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvdHlwZS5qcyAqL1xuXHR2YXIgdHlwZSA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBtdXN0YWNoZVR5cGVzID0ge1xuXHRcdFx0JyMnOiB0eXBlcy5TRUNUSU9OLFxuXHRcdFx0J14nOiB0eXBlcy5JTlZFUlRFRCxcblx0XHRcdCcvJzogdHlwZXMuQ0xPU0lORyxcblx0XHRcdCc+JzogdHlwZXMuUEFSVElBTCxcblx0XHRcdCchJzogdHlwZXMuQ09NTUVOVCxcblx0XHRcdCcmJzogdHlwZXMuVFJJUExFXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciB0eXBlID0gbXVzdGFjaGVUeXBlc1sgcGFyc2VyLnN0ci5jaGFyQXQoIHBhcnNlci5wb3MgKSBdO1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IDE7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvaGFuZGxlYmFyc0Jsb2NrQ29kZXMuanMgKi9cblx0dmFyIGhhbmRsZWJhcnNCbG9ja0NvZGVzID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdCdlYWNoJzogdHlwZXMuU0VDVElPTl9FQUNILFxuXHRcdFx0J2lmJzogdHlwZXMuU0VDVElPTl9JRixcblx0XHRcdCdpZi13aXRoJzogdHlwZXMuU0VDVElPTl9JRl9XSVRILFxuXHRcdFx0J3dpdGgnOiB0eXBlcy5TRUNUSU9OX1dJVEgsXG5cdFx0XHQndW5sZXNzJzogdHlwZXMuU0VDVElPTl9VTkxFU1Ncblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIGVtcHR5L2xlZ2FjeS5qcyAqL1xuXHR2YXIgbGVnYWN5ID0gbnVsbDtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2NvbnRlbnQuanMgKi9cblx0dmFyIGNvbnRlbnQgPSBmdW5jdGlvbiggdHlwZXMsIG11c3RhY2hlVHlwZSwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGluZGV4UmVmUGF0dGVybiA9IC9eXFxzKjpcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuXHRcdFx0YXJyYXlNZW1iZXJQYXR0ZXJuID0gL15bMC05XVsxLTldKiQvLFxuXHRcdFx0aGFuZGxlYmFyc0Jsb2NrUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKCcgKyBPYmplY3Qua2V5cyggaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKS5qb2luKCAnfCcgKSArICcpXFxcXGInICksXG5cdFx0XHRsZWdhbFJlZmVyZW5jZTtcblx0XHRsZWdhbFJlZmVyZW5jZSA9IC9eW2EtekEtWiRfMC05XSsoPzooXFwuW2EtekEtWiRfMC05XSspfChcXFtbYS16QS1aJF8wLTldK1xcXSkpKiQvO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgcG9zLCBtdXN0YWNoZSwgdHlwZSwgYmxvY2ssIGV4cHJlc3Npb24sIGksIHJlbWFpbmluZywgaW5kZXgsIGRlbGltaXRlcnM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRtdXN0YWNoZSA9IHt9O1xuXHRcdFx0ZGVsaW1pdGVycyA9IHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF07XG5cdFx0XHRpZiAoIGRlbGltaXRlclR5cGUuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGV0ZXJtaW5lIG11c3RhY2hlIHR5cGVcblx0XHRcdGlmICggZGVsaW1pdGVyVHlwZS5pc1RyaXBsZSApIHtcblx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBmb3IgZXhwcmVzc2lvbnMgYmVmb3JlIHdlIHRlc3QgZm9yIG11c3RhY2hlIHR5cGUsIGJlY2F1c2Vcblx0XHRcdFx0Ly8gYW4gZXhwcmVzc2lvbiB0aGF0IGJlZ2lucyAnIScgbG9va3MgYSBsb3QgbGlrZSBhIGNvbW1lbnRcblx0XHRcdFx0aWYgKCBwYXJzZXIucmVtYWluaW5nKClbIDAgXSA9PT0gJyEnICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdFx0XHQvLyBXYXMgaXQgYWN0dWFsbHkgYW4gZXhwcmVzc2lvbiwgb3IgYSBjb21tZW50IGJsb2NrIGluIGRpc2d1aXNlP1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdGV4cHJlc3Npb24gPSBudWxsO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge31cblx0XHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRpZiAoIH5pbmRleCApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyIChcXCcnICsgZGVsaW1pdGVyc1sgMSBdICsgJ1xcJyknICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0OiB0eXBlcy5DT01NRU5UXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdHR5cGUgPSBtdXN0YWNoZVR5cGUoIHBhcnNlciApO1xuXHRcdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlIHx8IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHQvLyBkZWZhdWx0XG5cdFx0XHRcdFx0Ly8gU2VlIGlmIHRoZXJlJ3MgYW4gZXhwbGljaXQgc2VjdGlvbiB0eXBlIGUuZy4ge3sjd2l0aH19Li4ue3svd2l0aH19XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHRcdFx0aWYgKCBibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUubiA9IGJsb2NrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHR5cGVzLkNPTU1FTlQgfHwgdHlwZSA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApLnNwbGl0KCAnICcgKVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0Ly8gZ2V0IGV4cHJlc3Npb25cblx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGEgcGFydGlhbCwgaXQgbWF5IGhhdmUgYSBjb250ZXh0IChlLmcuIGB7ez5pdGVtIGZvb319YCkuIFRoZXNlXG5cdFx0XHRcdC8vIGNhc2VzIGludm9sdmUgYSBiaXQgb2YgYSBoYWNrIC0gd2Ugd2FudCB0byB0dXJuIGl0IGludG8gdGhlIGVxdWl2YWxlbnQgb2Zcblx0XHRcdFx0Ly8gYHt7I3dpdGggZm9vfX17ez5pdGVtfX17ey93aXRofX1gLCBidXQgdG8gZ2V0IHRoZXJlIHdlIHRlbXBvcmFyaWx5IGFwcGVuZFxuXHRcdFx0XHQvLyBhICdjb250ZXh0UGFydGlhbEV4cHJlc3Npb24nIHRvIHRoZSBtdXN0YWNoZSwgYW5kIHByb2Nlc3MgdGhlIGNvbnRleHQgaW5zdGVhZCBvZlxuXHRcdFx0XHQvLyB0aGUgcmVmZXJlbmNlXG5cdFx0XHRcdHZhciB0ZW1wO1xuXHRcdFx0XHRpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLlBBUlRJQUwgJiYgZXhwcmVzc2lvbiAmJiAoIHRlbXAgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKSApICkge1xuXHRcdFx0XHRcdG11c3RhY2hlID0ge1xuXHRcdFx0XHRcdFx0Y29udGV4dFBhcnRpYWxFeHByZXNzaW9uOiBleHByZXNzaW9uXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRleHByZXNzaW9uID0gdGVtcDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBXaXRoIGNlcnRhaW4gdmFsaWQgcmVmZXJlbmNlcyB0aGF0IGFyZW4ndCB2YWxpZCBleHByZXNzaW9ucyxcblx0XHRcdFx0Ly8gZS5nLiB7ezEuZm9vfX0sIHdlIGhhdmUgYSBwcm9ibGVtOiBpdCBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBhblxuXHRcdFx0XHQvLyBleHByZXNzaW9uLCBidXQgdGhlIGV4cHJlc3Npb24gZGlkbid0IGNvbnN1bWUgdGhlIGVudGlyZVxuXHRcdFx0XHQvLyByZWZlcmVuY2UuIFNvIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgbXVzdGFjaGUgZGVsaW1pdGVyc1xuXHRcdFx0XHQvLyBhcHBlYXIgbmV4dCwgdW5sZXNzIHRoZXJlJ3MgYW4gaW5kZXggcmVmZXJlbmNlIChpLmUuIGEgY29sb24pXG5cdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCBkZWxpbWl0ZXJzWyAxIF0ubGVuZ3RoICkgIT09IGRlbGltaXRlcnNbIDEgXSAmJiByZW1haW5pbmcuY2hhckF0KCAwICkgIT09ICc6JyApIHtcblx0XHRcdFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKS50cmltKCk7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpdCdzIGEgbGVnYWwgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRpZiAoICFsZWdhbFJlZmVyZW5jZS50ZXN0KCBtdXN0YWNoZS5yICkgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGEgbGVnYWwgTXVzdGFjaGUgcmVmZXJlbmNlJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVmaW5lRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uLCBtdXN0YWNoZSApO1xuXHRcdFx0Ly8gaWYgdGhlcmUgd2FzIGNvbnRleHQsIHByb2Nlc3MgdGhlIGV4cHJlc3Npb24gbm93IGFuZCBzYXZlIGl0IGZvciBsYXRlclxuXHRcdFx0aWYgKCBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbiA9IFsgcmVmaW5lRXhwcmVzc2lvbiggcGFyc2VyLCBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24sIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5QQVJUSUFMXG5cdFx0XHRcdH0gKSBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gb3B0aW9uYWwgaW5kZXggcmVmZXJlbmNlXG5cdFx0XHRpZiAoIGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBpbmRleFJlZlBhdHRlcm4gKSApIHtcblx0XHRcdFx0bXVzdGFjaGUuaSA9IGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZmluZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiwgbXVzdGFjaGUgKSB7XG5cdFx0XHR2YXIgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblx0XHRcdGlmICggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0d2hpbGUgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLkJSQUNLRVRFRCAmJiBleHByZXNzaW9uLnggKSB7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbnRlZ2VycyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhcnJheSBtZW1iZXJzIHJlZmVyZW5jZXMsXG5cdFx0XHRcdC8vIHJhdGhlciB0aGFuIGFzIGV4cHJlc3Npb25zIGluIHRoZWlyIG93biByaWdodFxuXHRcdFx0XHRpZiAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLk5VTUJFUl9MSVRFUkFMICYmIGFycmF5TWVtYmVyUGF0dGVybi50ZXN0KCBleHByZXNzaW9uLnYgKSApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLnY7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcmVmZXJlbmNlRXhwcmVzc2lvbiA9IGdldFJlZmVyZW5jZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiApICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUucnggPSByZWZlcmVuY2VFeHByZXNzaW9uO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS54ID0gcGFyc2VyLmZsYXR0ZW5FeHByZXNzaW9uKCBleHByZXNzaW9uICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0aGlzISBpdCdzIGJld2lsZGVyaW5nXG5cdFx0ZnVuY3Rpb24gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIG1lbWJlcnMgPSBbXSxcblx0XHRcdFx0cmVmaW5lbWVudDtcblx0XHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5NRU1CRVIgJiYgZXhwcmVzc2lvbi5yLnQgPT09IHR5cGVzLlJFRklORU1FTlQgKSB7XG5cdFx0XHRcdHJlZmluZW1lbnQgPSBleHByZXNzaW9uLnI7XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudC54ICkge1xuXHRcdFx0XHRcdGlmICggcmVmaW5lbWVudC54LnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcmVmaW5lbWVudC54ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcGFyc2VyLmZsYXR0ZW5FeHByZXNzaW9uKCByZWZpbmVtZW50LnggKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHJlZmluZW1lbnQubiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV4cHJlc3Npb24udCAhPT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHI6IGV4cHJlc3Npb24ubixcblx0XHRcdFx0bTogbWVtYmVyc1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgdHlwZSwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMsIGxlZ2FjeSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUuanMgKi9cblx0dmFyIG11c3RhY2hlID0gZnVuY3Rpb24oIHR5cGVzLCBkZWxpbWl0ZXJDaGFuZ2UsIGRlbGltaXRlclR5cGVzLCBtdXN0YWNoZUNvbnRlbnQsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBkZWxpbWl0ZXJDaGFuZ2VUb2tlbiA9IHtcblx0XHRcdHQ6IHR5cGVzLkRFTElNQ0hBTkdFLFxuXHRcdFx0ZXhjbHVkZTogdHJ1ZVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBnZXRNdXN0YWNoZTtcblxuXHRcdGZ1bmN0aW9uIGdldE11c3RhY2hlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdHlwZXM7XG5cdFx0XHQvLyBJZiB3ZSdyZSBpbnNpZGUgYSA8c2NyaXB0PiBvciA8c3R5bGU+IHRhZywgYW5kIHdlJ3JlIG5vdFxuXHRcdFx0Ly8gaW50ZXJwb2xhdGluZywgYnVnIG91dFxuXHRcdFx0aWYgKCBwYXJzZXIuaW50ZXJwb2xhdGVbIHBhcnNlci5pbnNpZGUgXSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dHlwZXMgPSBkZWxpbWl0ZXJUeXBlcy5zbGljZSgpLnNvcnQoIGZ1bmN0aW9uIGNvbXBhcmUoIGEsIGIgKSB7XG5cdFx0XHRcdC8vIFNvcnQgaW4gb3JkZXIgb2YgZGVzY2VuZGluZyBvcGVuaW5nIGRlbGltaXRlciBsZW5ndGggKGxvbmdlciBmaXJzdCksXG5cdFx0XHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG5cdFx0XHRcdHJldHVybiBwYXJzZXJbIGIuZGVsaW1pdGVycyBdWyAwIF0ubGVuZ3RoIC0gcGFyc2VyWyBhLmRlbGltaXRlcnMgXVsgMCBdLmxlbmd0aDtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiByKCB0eXBlICkge1xuXHRcdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBnZXRNdXN0YWNoZU9mVHlwZSggcGFyc2VyLCB0eXBlICkgfHwgciggdHlwZXMuc2hpZnQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KCB0eXBlcy5zaGlmdCgpICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TXVzdGFjaGVPZlR5cGUoIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgbXVzdGFjaGUsIGRlbGltaXRlcnMsIGNoaWxkcmVuLCBleHBlY3RlZENsb3NlLCBlbHNlQ2hpbGRyZW4sIGN1cnJlbnRDaGlsZHJlbiwgY2hpbGQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRkZWxpbWl0ZXJzID0gcGFyc2VyWyBkZWxpbWl0ZXJUeXBlLmRlbGltaXRlcnMgXTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGVsaW1pdGVyIGNoYW5nZT9cblx0XHRcdGlmICggbXVzdGFjaGUgPSBkZWxpbWl0ZXJDaGFuZ2UoIHBhcnNlciApICkge1xuXHRcdFx0XHQvLyBmaW5kIGNsb3NpbmcgZGVsaW1pdGVyIG9yIGFib3J0Li4uXG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gLi4udGhlbiBtYWtlIHRoZSBzd2l0Y2hcblx0XHRcdFx0cGFyc2VyWyBkZWxpbWl0ZXJUeXBlLmRlbGltaXRlcnMgXSA9IG11c3RhY2hlO1xuXHRcdFx0XHRyZXR1cm4gZGVsaW1pdGVyQ2hhbmdlVG9rZW47XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRtdXN0YWNoZSA9IG11c3RhY2hlQ29udGVudCggcGFyc2VyLCBkZWxpbWl0ZXJUeXBlICk7XG5cdFx0XHRpZiAoIG11c3RhY2hlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBkZWxpbWl0ZXJcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyIFxcJycgKyBkZWxpbWl0ZXJzWyAxIF0gKyAnXFwnIGFmdGVyIHJlZmVyZW5jZScgKTtcblx0XHRcdH1cblx0XHRcdGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuQ09NTUVOVCApIHtcblx0XHRcdFx0bXVzdGFjaGUuZXhjbHVkZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggLT0gMTtcblx0XHRcdFx0aWYgKCBwYXJzZXIuc2VjdGlvbkRlcHRoIDwgMCApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnQXR0ZW1wdGVkIHRvIGNsb3NlIGEgc2VjdGlvbiB0aGF0IHdhc25cXCd0IG9wZW4nICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHBhcnRpYWxzIHdpdGggY29udGV4dFxuXHRcdFx0aWYgKCBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdG11c3RhY2hlLmYgPSBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb247XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gJ3dpdGgnO1xuXHRcdFx0XHRkZWxldGUgbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uO1xuXHRcdFx0fSBlbHNlIGlmICggaXNTZWN0aW9uKCBtdXN0YWNoZSApICkge1xuXHRcdFx0XHRwYXJzZXIuc2VjdGlvbkRlcHRoICs9IDE7XG5cdFx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0XHRcdGN1cnJlbnRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXHRcdFx0XHRleHBlY3RlZENsb3NlID0gbXVzdGFjaGUubjtcblx0XHRcdFx0d2hpbGUgKCBjaGlsZCA9IHBhcnNlci5yZWFkKCkgKSB7XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0aWYgKCBleHBlY3RlZENsb3NlICYmIGNoaWxkLnIgIT09IGV4cGVjdGVkQ2xvc2UgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIHt7LycgKyBleHBlY3RlZENsb3NlICsgJ319JyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHt7ZWxzZX19IHRhZ3MgcmVxdWlyZSBzcGVjaWFsIHRyZWF0bWVudFxuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuSU5URVJQT0xBVE9SICYmIGNoaWxkLnIgPT09ICdlbHNlJyApIHtcblx0XHRcdFx0XHRcdC8vIG5vIHt7ZWxzZX19IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cblx0XHRcdFx0XHRcdGlmICggbXVzdGFjaGUubiA9PT0gJ3VubGVzcycgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ3t7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319JyApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudENoaWxkcmVuID0gZWxzZUNoaWxkcmVuID0gW107XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5mID0gY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbHNlQ2hpbGRyZW4gJiYgZWxzZUNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5sID0gZWxzZUNoaWxkcmVuO1xuXHRcdFx0XHRcdGlmICggbXVzdGFjaGUubiA9PT0gJ3dpdGgnICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUubiA9ICdpZi13aXRoJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRtdXN0YWNoZS5wID0gcGFyc2VyLmdldExpbmVQb3MoIHN0YXJ0ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZXBsYWNlIGJsb2NrIG5hbWUgd2l0aCBjb2RlXG5cdFx0XHRpZiAoIG11c3RhY2hlLm4gKSB7XG5cdFx0XHRcdG11c3RhY2hlLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1sgbXVzdGFjaGUubiBdO1xuXHRcdFx0fSBlbHNlIGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuSU5WRVJURUQgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gdHlwZXMuU0VDVElPTl9VTkxFU1M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTZWN0aW9uKCBtdXN0YWNoZSApIHtcblx0XHRcdHJldHVybiBtdXN0YWNoZS50ID09PSB0eXBlcy5TRUNUSU9OIHx8IG11c3RhY2hlLnQgPT09IHR5cGVzLklOVkVSVEVEO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBkZWxpbWl0ZXJDaGFuZ2UsIGRlbGltaXRlclR5cGVzLCBjb250ZW50LCBoYW5kbGViYXJzQmxvY2tDb2RlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvY29tbWVudC5qcyAqL1xuXHR2YXIgY29tbWVudCA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBPUEVOX0NPTU1FTlQgPSAnPCEtLScsXG5cdFx0XHRDTE9TRV9DT01NRU5UID0gJy0tPic7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGNvbnRlbnQsIHJlbWFpbmluZywgZW5kSW5kZXgsIGNvbW1lbnQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIE9QRU5fQ09NTUVOVCApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGVuZEluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIENMT1NFX0NPTU1FTlQgKTtcblx0XHRcdGlmICggZW5kSW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIEhUTUwgLSBleHBlY3RlZCBjbG9zaW5nIGNvbW1lbnQgc2VxdWVuY2UgKFxcJy0tPlxcJyknICk7XG5cdFx0XHR9XG5cdFx0XHRjb250ZW50ID0gcmVtYWluaW5nLnN1YnN0ciggMCwgZW5kSW5kZXggKTtcblx0XHRcdHBhcnNlci5wb3MgKz0gZW5kSW5kZXggKyAzO1xuXHRcdFx0Y29tbWVudCA9IHtcblx0XHRcdFx0dDogdHlwZXMuQ09NTUVOVCxcblx0XHRcdFx0YzogY29udGVudFxuXHRcdFx0fTtcblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRjb21tZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyggc3RhcnQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb21tZW50O1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogY29uZmlnL3ZvaWRFbGVtZW50TmFtZXMuanMgKi9cblx0dmFyIHZvaWRFbGVtZW50TmFtZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB2b2lkRWxlbWVudE5hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZG9jdHlwZXxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvaTtcblx0XHRyZXR1cm4gdm9pZEVsZW1lbnROYW1lcztcblx0fSgpO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvdXRpbHMvZ2V0TG93ZXN0SW5kZXguanMgKi9cblx0dmFyIGdldExvd2VzdEluZGV4ID0gZnVuY3Rpb24oIGhheXN0YWNrLCBuZWVkbGVzICkge1xuXHRcdHZhciBpLCBpbmRleCwgbG93ZXN0O1xuXHRcdGkgPSBuZWVkbGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGluZGV4ID0gaGF5c3RhY2suaW5kZXhPZiggbmVlZGxlc1sgaSBdICk7XG5cdFx0XHQvLyBzaG9ydCBjaXJjdWl0XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFsb3dlc3QgfHwgaW5kZXggPCBsb3dlc3QgKSB7XG5cdFx0XHRcdGxvd2VzdCA9IGluZGV4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbG93ZXN0IHx8IC0xO1xuXHR9O1xuXG5cdC8qIHNoYXJlZC9kZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzLmpzICovXG5cdHZhciBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGh0bWxFbnRpdGllcywgY29udHJvbENoYXJhY3RlcnMsIGVudGl0eVBhdHRlcm47XG5cdFx0aHRtbEVudGl0aWVzID0ge1xuXHRcdFx0cXVvdDogMzQsXG5cdFx0XHRhbXA6IDM4LFxuXHRcdFx0YXBvczogMzksXG5cdFx0XHRsdDogNjAsXG5cdFx0XHRndDogNjIsXG5cdFx0XHRuYnNwOiAxNjAsXG5cdFx0XHRpZXhjbDogMTYxLFxuXHRcdFx0Y2VudDogMTYyLFxuXHRcdFx0cG91bmQ6IDE2Myxcblx0XHRcdGN1cnJlbjogMTY0LFxuXHRcdFx0eWVuOiAxNjUsXG5cdFx0XHRicnZiYXI6IDE2Nixcblx0XHRcdHNlY3Q6IDE2Nyxcblx0XHRcdHVtbDogMTY4LFxuXHRcdFx0Y29weTogMTY5LFxuXHRcdFx0b3JkZjogMTcwLFxuXHRcdFx0bGFxdW86IDE3MSxcblx0XHRcdG5vdDogMTcyLFxuXHRcdFx0c2h5OiAxNzMsXG5cdFx0XHRyZWc6IDE3NCxcblx0XHRcdG1hY3I6IDE3NSxcblx0XHRcdGRlZzogMTc2LFxuXHRcdFx0cGx1c21uOiAxNzcsXG5cdFx0XHRzdXAyOiAxNzgsXG5cdFx0XHRzdXAzOiAxNzksXG5cdFx0XHRhY3V0ZTogMTgwLFxuXHRcdFx0bWljcm86IDE4MSxcblx0XHRcdHBhcmE6IDE4Mixcblx0XHRcdG1pZGRvdDogMTgzLFxuXHRcdFx0Y2VkaWw6IDE4NCxcblx0XHRcdHN1cDE6IDE4NSxcblx0XHRcdG9yZG06IDE4Nixcblx0XHRcdHJhcXVvOiAxODcsXG5cdFx0XHRmcmFjMTQ6IDE4OCxcblx0XHRcdGZyYWMxMjogMTg5LFxuXHRcdFx0ZnJhYzM0OiAxOTAsXG5cdFx0XHRpcXVlc3Q6IDE5MSxcblx0XHRcdEFncmF2ZTogMTkyLFxuXHRcdFx0QWFjdXRlOiAxOTMsXG5cdFx0XHRBY2lyYzogMTk0LFxuXHRcdFx0QXRpbGRlOiAxOTUsXG5cdFx0XHRBdW1sOiAxOTYsXG5cdFx0XHRBcmluZzogMTk3LFxuXHRcdFx0QUVsaWc6IDE5OCxcblx0XHRcdENjZWRpbDogMTk5LFxuXHRcdFx0RWdyYXZlOiAyMDAsXG5cdFx0XHRFYWN1dGU6IDIwMSxcblx0XHRcdEVjaXJjOiAyMDIsXG5cdFx0XHRFdW1sOiAyMDMsXG5cdFx0XHRJZ3JhdmU6IDIwNCxcblx0XHRcdElhY3V0ZTogMjA1LFxuXHRcdFx0SWNpcmM6IDIwNixcblx0XHRcdEl1bWw6IDIwNyxcblx0XHRcdEVUSDogMjA4LFxuXHRcdFx0TnRpbGRlOiAyMDksXG5cdFx0XHRPZ3JhdmU6IDIxMCxcblx0XHRcdE9hY3V0ZTogMjExLFxuXHRcdFx0T2NpcmM6IDIxMixcblx0XHRcdE90aWxkZTogMjEzLFxuXHRcdFx0T3VtbDogMjE0LFxuXHRcdFx0dGltZXM6IDIxNSxcblx0XHRcdE9zbGFzaDogMjE2LFxuXHRcdFx0VWdyYXZlOiAyMTcsXG5cdFx0XHRVYWN1dGU6IDIxOCxcblx0XHRcdFVjaXJjOiAyMTksXG5cdFx0XHRVdW1sOiAyMjAsXG5cdFx0XHRZYWN1dGU6IDIyMSxcblx0XHRcdFRIT1JOOiAyMjIsXG5cdFx0XHRzemxpZzogMjIzLFxuXHRcdFx0YWdyYXZlOiAyMjQsXG5cdFx0XHRhYWN1dGU6IDIyNSxcblx0XHRcdGFjaXJjOiAyMjYsXG5cdFx0XHRhdGlsZGU6IDIyNyxcblx0XHRcdGF1bWw6IDIyOCxcblx0XHRcdGFyaW5nOiAyMjksXG5cdFx0XHRhZWxpZzogMjMwLFxuXHRcdFx0Y2NlZGlsOiAyMzEsXG5cdFx0XHRlZ3JhdmU6IDIzMixcblx0XHRcdGVhY3V0ZTogMjMzLFxuXHRcdFx0ZWNpcmM6IDIzNCxcblx0XHRcdGV1bWw6IDIzNSxcblx0XHRcdGlncmF2ZTogMjM2LFxuXHRcdFx0aWFjdXRlOiAyMzcsXG5cdFx0XHRpY2lyYzogMjM4LFxuXHRcdFx0aXVtbDogMjM5LFxuXHRcdFx0ZXRoOiAyNDAsXG5cdFx0XHRudGlsZGU6IDI0MSxcblx0XHRcdG9ncmF2ZTogMjQyLFxuXHRcdFx0b2FjdXRlOiAyNDMsXG5cdFx0XHRvY2lyYzogMjQ0LFxuXHRcdFx0b3RpbGRlOiAyNDUsXG5cdFx0XHRvdW1sOiAyNDYsXG5cdFx0XHRkaXZpZGU6IDI0Nyxcblx0XHRcdG9zbGFzaDogMjQ4LFxuXHRcdFx0dWdyYXZlOiAyNDksXG5cdFx0XHR1YWN1dGU6IDI1MCxcblx0XHRcdHVjaXJjOiAyNTEsXG5cdFx0XHR1dW1sOiAyNTIsXG5cdFx0XHR5YWN1dGU6IDI1Myxcblx0XHRcdHRob3JuOiAyNTQsXG5cdFx0XHR5dW1sOiAyNTUsXG5cdFx0XHRPRWxpZzogMzM4LFxuXHRcdFx0b2VsaWc6IDMzOSxcblx0XHRcdFNjYXJvbjogMzUyLFxuXHRcdFx0c2Nhcm9uOiAzNTMsXG5cdFx0XHRZdW1sOiAzNzYsXG5cdFx0XHRmbm9mOiA0MDIsXG5cdFx0XHRjaXJjOiA3MTAsXG5cdFx0XHR0aWxkZTogNzMyLFxuXHRcdFx0QWxwaGE6IDkxMyxcblx0XHRcdEJldGE6IDkxNCxcblx0XHRcdEdhbW1hOiA5MTUsXG5cdFx0XHREZWx0YTogOTE2LFxuXHRcdFx0RXBzaWxvbjogOTE3LFxuXHRcdFx0WmV0YTogOTE4LFxuXHRcdFx0RXRhOiA5MTksXG5cdFx0XHRUaGV0YTogOTIwLFxuXHRcdFx0SW90YTogOTIxLFxuXHRcdFx0S2FwcGE6IDkyMixcblx0XHRcdExhbWJkYTogOTIzLFxuXHRcdFx0TXU6IDkyNCxcblx0XHRcdE51OiA5MjUsXG5cdFx0XHRYaTogOTI2LFxuXHRcdFx0T21pY3JvbjogOTI3LFxuXHRcdFx0UGk6IDkyOCxcblx0XHRcdFJobzogOTI5LFxuXHRcdFx0U2lnbWE6IDkzMSxcblx0XHRcdFRhdTogOTMyLFxuXHRcdFx0VXBzaWxvbjogOTMzLFxuXHRcdFx0UGhpOiA5MzQsXG5cdFx0XHRDaGk6IDkzNSxcblx0XHRcdFBzaTogOTM2LFxuXHRcdFx0T21lZ2E6IDkzNyxcblx0XHRcdGFscGhhOiA5NDUsXG5cdFx0XHRiZXRhOiA5NDYsXG5cdFx0XHRnYW1tYTogOTQ3LFxuXHRcdFx0ZGVsdGE6IDk0OCxcblx0XHRcdGVwc2lsb246IDk0OSxcblx0XHRcdHpldGE6IDk1MCxcblx0XHRcdGV0YTogOTUxLFxuXHRcdFx0dGhldGE6IDk1Mixcblx0XHRcdGlvdGE6IDk1Myxcblx0XHRcdGthcHBhOiA5NTQsXG5cdFx0XHRsYW1iZGE6IDk1NSxcblx0XHRcdG11OiA5NTYsXG5cdFx0XHRudTogOTU3LFxuXHRcdFx0eGk6IDk1OCxcblx0XHRcdG9taWNyb246IDk1OSxcblx0XHRcdHBpOiA5NjAsXG5cdFx0XHRyaG86IDk2MSxcblx0XHRcdHNpZ21hZjogOTYyLFxuXHRcdFx0c2lnbWE6IDk2Myxcblx0XHRcdHRhdTogOTY0LFxuXHRcdFx0dXBzaWxvbjogOTY1LFxuXHRcdFx0cGhpOiA5NjYsXG5cdFx0XHRjaGk6IDk2Nyxcblx0XHRcdHBzaTogOTY4LFxuXHRcdFx0b21lZ2E6IDk2OSxcblx0XHRcdHRoZXRhc3ltOiA5NzcsXG5cdFx0XHR1cHNpaDogOTc4LFxuXHRcdFx0cGl2OiA5ODIsXG5cdFx0XHRlbnNwOiA4MTk0LFxuXHRcdFx0ZW1zcDogODE5NSxcblx0XHRcdHRoaW5zcDogODIwMSxcblx0XHRcdHp3bmo6IDgyMDQsXG5cdFx0XHR6d2o6IDgyMDUsXG5cdFx0XHRscm06IDgyMDYsXG5cdFx0XHRybG06IDgyMDcsXG5cdFx0XHRuZGFzaDogODIxMSxcblx0XHRcdG1kYXNoOiA4MjEyLFxuXHRcdFx0bHNxdW86IDgyMTYsXG5cdFx0XHRyc3F1bzogODIxNyxcblx0XHRcdHNicXVvOiA4MjE4LFxuXHRcdFx0bGRxdW86IDgyMjAsXG5cdFx0XHRyZHF1bzogODIyMSxcblx0XHRcdGJkcXVvOiA4MjIyLFxuXHRcdFx0ZGFnZ2VyOiA4MjI0LFxuXHRcdFx0RGFnZ2VyOiA4MjI1LFxuXHRcdFx0YnVsbDogODIyNixcblx0XHRcdGhlbGxpcDogODIzMCxcblx0XHRcdHBlcm1pbDogODI0MCxcblx0XHRcdHByaW1lOiA4MjQyLFxuXHRcdFx0UHJpbWU6IDgyNDMsXG5cdFx0XHRsc2FxdW86IDgyNDksXG5cdFx0XHRyc2FxdW86IDgyNTAsXG5cdFx0XHRvbGluZTogODI1NCxcblx0XHRcdGZyYXNsOiA4MjYwLFxuXHRcdFx0ZXVybzogODM2NCxcblx0XHRcdGltYWdlOiA4NDY1LFxuXHRcdFx0d2VpZXJwOiA4NDcyLFxuXHRcdFx0cmVhbDogODQ3Nixcblx0XHRcdHRyYWRlOiA4NDgyLFxuXHRcdFx0YWxlZnN5bTogODUwMSxcblx0XHRcdGxhcnI6IDg1OTIsXG5cdFx0XHR1YXJyOiA4NTkzLFxuXHRcdFx0cmFycjogODU5NCxcblx0XHRcdGRhcnI6IDg1OTUsXG5cdFx0XHRoYXJyOiA4NTk2LFxuXHRcdFx0Y3JhcnI6IDg2MjksXG5cdFx0XHRsQXJyOiA4NjU2LFxuXHRcdFx0dUFycjogODY1Nyxcblx0XHRcdHJBcnI6IDg2NTgsXG5cdFx0XHRkQXJyOiA4NjU5LFxuXHRcdFx0aEFycjogODY2MCxcblx0XHRcdGZvcmFsbDogODcwNCxcblx0XHRcdHBhcnQ6IDg3MDYsXG5cdFx0XHRleGlzdDogODcwNyxcblx0XHRcdGVtcHR5OiA4NzA5LFxuXHRcdFx0bmFibGE6IDg3MTEsXG5cdFx0XHRpc2luOiA4NzEyLFxuXHRcdFx0bm90aW46IDg3MTMsXG5cdFx0XHRuaTogODcxNSxcblx0XHRcdHByb2Q6IDg3MTksXG5cdFx0XHRzdW06IDg3MjEsXG5cdFx0XHRtaW51czogODcyMixcblx0XHRcdGxvd2FzdDogODcyNyxcblx0XHRcdHJhZGljOiA4NzMwLFxuXHRcdFx0cHJvcDogODczMyxcblx0XHRcdGluZmluOiA4NzM0LFxuXHRcdFx0YW5nOiA4NzM2LFxuXHRcdFx0YW5kOiA4NzQzLFxuXHRcdFx0b3I6IDg3NDQsXG5cdFx0XHRjYXA6IDg3NDUsXG5cdFx0XHRjdXA6IDg3NDYsXG5cdFx0XHQnaW50JzogODc0Nyxcblx0XHRcdHRoZXJlNDogODc1Nixcblx0XHRcdHNpbTogODc2NCxcblx0XHRcdGNvbmc6IDg3NzMsXG5cdFx0XHRhc3ltcDogODc3Nixcblx0XHRcdG5lOiA4ODAwLFxuXHRcdFx0ZXF1aXY6IDg4MDEsXG5cdFx0XHRsZTogODgwNCxcblx0XHRcdGdlOiA4ODA1LFxuXHRcdFx0c3ViOiA4ODM0LFxuXHRcdFx0c3VwOiA4ODM1LFxuXHRcdFx0bnN1YjogODgzNixcblx0XHRcdHN1YmU6IDg4MzgsXG5cdFx0XHRzdXBlOiA4ODM5LFxuXHRcdFx0b3BsdXM6IDg4NTMsXG5cdFx0XHRvdGltZXM6IDg4NTUsXG5cdFx0XHRwZXJwOiA4ODY5LFxuXHRcdFx0c2RvdDogODkwMSxcblx0XHRcdGxjZWlsOiA4OTY4LFxuXHRcdFx0cmNlaWw6IDg5NjksXG5cdFx0XHRsZmxvb3I6IDg5NzAsXG5cdFx0XHRyZmxvb3I6IDg5NzEsXG5cdFx0XHRsYW5nOiA5MDAxLFxuXHRcdFx0cmFuZzogOTAwMixcblx0XHRcdGxvejogOTY3NCxcblx0XHRcdHNwYWRlczogOTgyNCxcblx0XHRcdGNsdWJzOiA5ODI3LFxuXHRcdFx0aGVhcnRzOiA5ODI5LFxuXHRcdFx0ZGlhbXM6IDk4MzBcblx0XHR9O1xuXHRcdGNvbnRyb2xDaGFyYWN0ZXJzID0gW1xuXHRcdFx0ODM2NCxcblx0XHRcdDEyOSxcblx0XHRcdDgyMTgsXG5cdFx0XHQ0MDIsXG5cdFx0XHQ4MjIyLFxuXHRcdFx0ODIzMCxcblx0XHRcdDgyMjQsXG5cdFx0XHQ4MjI1LFxuXHRcdFx0NzEwLFxuXHRcdFx0ODI0MCxcblx0XHRcdDM1Mixcblx0XHRcdDgyNDksXG5cdFx0XHQzMzgsXG5cdFx0XHQxNDEsXG5cdFx0XHQzODEsXG5cdFx0XHQxNDMsXG5cdFx0XHQxNDQsXG5cdFx0XHQ4MjE2LFxuXHRcdFx0ODIxNyxcblx0XHRcdDgyMjAsXG5cdFx0XHQ4MjIxLFxuXHRcdFx0ODIyNixcblx0XHRcdDgyMTEsXG5cdFx0XHQ4MjEyLFxuXHRcdFx0NzMyLFxuXHRcdFx0ODQ4Mixcblx0XHRcdDM1Myxcblx0XHRcdDgyNTAsXG5cdFx0XHQzMzksXG5cdFx0XHQxNTcsXG5cdFx0XHQzODIsXG5cdFx0XHQzNzZcblx0XHRdO1xuXHRcdGVudGl0eVBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnJigjPyg/OnhbXFxcXHdcXFxcZF0rfFxcXFxkK3wnICsgT2JqZWN0LmtleXMoIGh0bWxFbnRpdGllcyApLmpvaW4oICd8JyApICsgJykpOz8nLCAnZycgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoIGh0bWwgKSB7XG5cdFx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCBlbnRpdHlQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsIGVudGl0eSApIHtcblx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdC8vIEhhbmRsZSBuYW1lZCBlbnRpdGllc1xuXHRcdFx0XHRpZiAoIGVudGl0eVsgMCBdICE9PSAnIycgKSB7XG5cdFx0XHRcdFx0Y29kZSA9IGh0bWxFbnRpdGllc1sgZW50aXR5IF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVudGl0eVsgMSBdID09PSAneCcgKSB7XG5cdFx0XHRcdFx0Y29kZSA9IHBhcnNlSW50KCBlbnRpdHkuc3Vic3RyaW5nKCAyICksIDE2ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29kZSA9IHBhcnNlSW50KCBlbnRpdHkuc3Vic3RyaW5nKCAxICksIDEwICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhY29kZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoIHZhbGlkYXRlQ29kZSggY29kZSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHQvLyBzb21lIGNvZGUgcG9pbnRzIGFyZSB2ZXJib3Rlbi4gSWYgd2Ugd2VyZSBpbnNlcnRpbmcgSFRNTCwgdGhlIGJyb3dzZXIgd291bGQgcmVwbGFjZSB0aGUgaWxsZWdhbFxuXHRcdC8vIGNvZGUgcG9pbnRzIHdpdGggYWx0ZXJuYXRpdmVzIGluIHNvbWUgY2FzZXMgLSBzaW5jZSB3ZSdyZSBieXBhc3NpbmcgdGhhdCBtZWNoYW5pc20sIHdlIG5lZWRcblx0XHQvLyB0byByZXBsYWNlIHRoZW0gb3Vyc2VsdmVzXG5cdFx0Ly9cblx0XHQvLyBTb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmFjdGVyX2VuY29kaW5nc19pbl9IVE1MI0lsbGVnYWxfY2hhcmFjdGVyc1xuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlQ29kZSggY29kZSApIHtcblx0XHRcdGlmICggIWNvZGUgKSB7XG5cdFx0XHRcdHJldHVybiA2NTUzMztcblx0XHRcdH1cblx0XHRcdC8vIGxpbmUgZmVlZCBiZWNvbWVzIGdlbmVyaWMgd2hpdGVzcGFjZVxuXHRcdFx0aWYgKCBjb2RlID09PSAxMCApIHtcblx0XHRcdFx0cmV0dXJuIDMyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQVNDSUkgcmFuZ2UuIChXaHkgc29tZW9uZSB3b3VsZCB1c2UgSFRNTCBlbnRpdGllcyBmb3IgQVNDSUkgY2hhcmFjdGVycyBJIGRvbid0IGtub3csIGJ1dC4uLilcblx0XHRcdGlmICggY29kZSA8IDEyOCApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG5cdFx0XHQvLyB0byBjb3JyZWN0IHRoZSBtaXN0YWtlIG9yIHdlJ2xsIGVuZCB1cCB3aXRoIG1pc3Npbmcg4oKsIHNpZ25zIGFuZCBzbyBvblxuXHRcdFx0aWYgKCBjb2RlIDw9IDE1OSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRyb2xDaGFyYWN0ZXJzWyBjb2RlIC0gMTI4IF07XG5cdFx0XHR9XG5cdFx0XHQvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblx0XHRcdGlmICggY29kZSA8IDU1Mjk2ICkge1xuXHRcdFx0XHRyZXR1cm4gY29kZTtcblx0XHRcdH1cblx0XHRcdC8vIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG5cdFx0XHRpZiAoIGNvZGUgPD0gNTczNDMgKSB7XG5cdFx0XHRcdHJldHVybiA2NTUzMztcblx0XHRcdH1cblx0XHRcdC8vIHJlc3Qgb2YgdGhlIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuXHRcdFx0aWYgKCBjb2RlIDw9IDY1NTM1ICkge1xuXHRcdFx0XHRyZXR1cm4gY29kZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiA2NTUzMztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBsZWdhY3kgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3RleHQuanMgKi9cblx0dmFyIHRleHQgPSBmdW5jdGlvbiggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBpbmRleCwgcmVtYWluaW5nLCBkaXNhbGxvd2VkLCBiYXJyaWVyO1xuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyAnPC8nICsgcGFyc2VyLmluc2lkZSA6ICc8Jztcblx0XHRcdGlmICggcGFyc2VyLmluc2lkZSAmJiAhcGFyc2VyLmludGVycG9sYXRlWyBwYXJzZXIuaW5zaWRlIF0gKSB7XG5cdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGJhcnJpZXIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FsbG93ZWQgPSBbXG5cdFx0XHRcdFx0cGFyc2VyLmRlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIudHJpcGxlRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci5zdGF0aWNEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnN0YXRpY1RyaXBsZURlbGltaXRlcnNbIDAgXVxuXHRcdFx0XHRdO1xuXHRcdFx0XHQvLyBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC1hdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICggcGFyc2VyLmluQXR0cmlidXRlID09PSB0cnVlICkge1xuXHRcdFx0XHRcdC8vIHdlJ3JlIGluc2lkZSBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcblx0XHRcdFx0XHRkaXNhbGxvd2VkLnB1c2goICdcIicsICdcXCcnLCAnPScsICc8JywgJz4nLCAnYCcgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyc2VyLmluQXR0cmlidXRlICkge1xuXHRcdFx0XHRcdC8vIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcblx0XHRcdFx0XHRkaXNhbGxvd2VkLnB1c2goIHBhcnNlci5pbkF0dHJpYnV0ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggYmFycmllciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIHJlbWFpbmluZywgZGlzYWxsb3dlZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhaW5kZXggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRyZXR1cm4gcGFyc2VyLmluc2lkZSA/IHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkgOiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApICk7XG5cdFx0fTtcblx0fSggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvY2xvc2luZ1RhZy5qcyAqL1xuXHR2YXIgY2xvc2luZ1RhZyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBjbG9zaW5nVGFnUGF0dGVybiA9IC9eKFthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qKVxccypcXD4vO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRhZztcblx0XHRcdC8vIGFyZSB3ZSBsb29raW5nIGF0IGEgY2xvc2luZyB0YWc/XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc8LycgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGNsb3NpbmdUYWdQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQ0xPU0lOR19UQUcsXG5cdFx0XHRcdFx0ZTogdGFnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGFuIGlsbGVnYWwgY2xvc2luZyB0YWcsIHJlcG9ydCBpdFxuXHRcdFx0cGFyc2VyLnBvcyAtPSAyO1xuXHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCBjbG9zaW5nIHRhZycgKTtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9hdHRyaWJ1dGUuanMgKi9cblx0dmFyIGF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBnZXRMb3dlc3RJbmRleCwgZ2V0TXVzdGFjaGUsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuID0gL15bXlxcc1wiJz5cXC89XSsvLFxuXHRcdFx0dW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuID0gL15bXlxcc1wiJz08PmBdKy87XG5cdFx0X19leHBvcnQgPSBnZXRBdHRyaWJ1dGU7XG5cblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoIHBhcnNlciApIHtcblx0XHRcdHZhciBhdHRyLCBuYW1lLCB2YWx1ZTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBhdHRyaWJ1dGVOYW1lUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhbmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHR9O1xuXHRcdFx0dmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRhdHRyLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXR0cjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB2YWx1ZVN0YXJ0LCBzdGFydERlcHRoLCB2YWx1ZTtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR2YWx1ZVN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHN0YXJ0RGVwdGggPSBwYXJzZXIuc2VjdGlvbkRlcHRoO1xuXHRcdFx0dmFsdWUgPSBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCAnXFwnJyApIHx8IGdldFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsICdcIicgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKTtcblx0XHRcdGlmICggcGFyc2VyLnNlY3Rpb25EZXB0aCAhPT0gc3RhcnREZXB0aCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0FuIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGNvbnRhaW4gYXMgbWFueSBvcGVuaW5nIHNlY3Rpb24gdGFncyBhcyBjbG9zaW5nIHNlY3Rpb24gdGFncycgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF2YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWyAwIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggdmFsdWVbIDAgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB0ZXh0LCBoYXlzdGFjaywgbmVlZGxlcywgaW5kZXg7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHR0ZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICF0ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGhheXN0YWNrID0gdGV4dDtcblx0XHRcdG5lZWRsZXMgPSBbXG5cdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci50cmlwbGVEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5zdGF0aWNEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWyAwIF1cblx0XHRcdF07XG5cdFx0XHRpZiAoICggaW5kZXggPSBnZXRMb3dlc3RJbmRleCggaGF5c3RhY2ssIG5lZWRsZXMgKSApICE9PSAtMSApIHtcblx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyKCAwLCBpbmRleCApO1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciApIHtcblx0XHRcdHZhciB0b2tlbnMsIHRva2VuO1xuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gdHJ1ZTtcblx0XHRcdHRva2VucyA9IFtdO1xuXHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKCBwYXJzZXIgKTtcblx0XHRcdHdoaWxlICggdG9rZW4gIT09IG51bGwgKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdG9rZW5zLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0b2tlbnM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgcXVvdGVNYXJrICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB0b2tlbnMsIHRva2VuO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBxdW90ZU1hcmsgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBxdW90ZU1hcms7XG5cdFx0XHR0b2tlbnMgPSBbXTtcblx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApO1xuXHRcdFx0d2hpbGUgKCB0b2tlbiAhPT0gbnVsbCApIHtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBxdW90ZU1hcmsgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRva2Vucztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGluZGV4LCBoYXlzdGFjaywgbmVlZGxlcztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGhheXN0YWNrID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0bmVlZGxlcyA9IFtcblx0XHRcdFx0cXVvdGVNYXJrLFxuXHRcdFx0XHRwYXJzZXIuZGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIudHJpcGxlRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sgMCBdXG5cdFx0XHRdO1xuXHRcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleCggaGF5c3RhY2ssIG5lZWRsZXMgKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdRdW90ZWQgYXR0cmlidXRlIHZhbHVlIG11c3QgaGF2ZSBhIGNsb3NpbmcgcXVvdGUnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0cmV0dXJuIGhheXN0YWNrLnN1YnN0ciggMCwgaW5kZXggKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBnZXRMb3dlc3RJbmRleCwgbXVzdGFjaGUsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiB1dGlscy9wYXJzZUpTT04uanMgKi9cblx0dmFyIHBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBQYXJzZXIsIGdldFN0cmluZ0xpdGVyYWwsIGdldEtleSApIHtcblxuXHRcdHZhciBKc29uUGFyc2VyLCBzcGVjaWFscywgc3BlY2lhbHNQYXR0ZXJuLCBudW1iZXJQYXR0ZXJuLCBwbGFjZWhvbGRlclBhdHRlcm4sIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4sIG9ubHlXaGl0ZXNwYWNlO1xuXHRcdHNwZWNpYWxzID0ge1xuXHRcdFx0J3RydWUnOiB0cnVlLFxuXHRcdFx0J2ZhbHNlJzogZmFsc2UsXG5cdFx0XHQndW5kZWZpbmVkJzogdW5kZWZpbmVkLFxuXHRcdFx0J251bGwnOiBudWxsXG5cdFx0fTtcblx0XHRzcGVjaWFsc1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXig/OicgKyBPYmplY3Qua2V5cyggc3BlY2lhbHMgKS5qb2luKCAnfCcgKSArICcpJyApO1xuXHRcdG51bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuXHRcdHBsYWNlaG9sZGVyUGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblx0XHRwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuXHRcdG9ubHlXaGl0ZXNwYWNlID0gL15cXHMqJC87XG5cdFx0SnNvblBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdHRoaXMuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR9LFxuXHRcdFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cdFx0XHRcdGlmICggcmVzdWx0Lmxlbmd0aCAhPT0gMSB8fCAhb25seVdoaXRlc3BhY2UudGVzdCggdGhpcy5sZWZ0b3ZlciApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJlc3VsdFsgMCBdLnZcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzOiBbXG5cblx0XHRcdFx0ZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLnZhbHVlcyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwbGFjZWhvbGRlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gKTtcblx0XHRcdFx0XHRpZiAoIHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkoIHBsYWNlaG9sZGVyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBwYXJzZXIudmFsdWVzWyBwbGFjZWhvbGRlciBdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3BlY2lhbCggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBzcGVjaWFsO1xuXHRcdFx0XHRcdGlmICggc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHNwZWNpYWxzUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogc3BlY2lhbHNbIHNwZWNpYWwgXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldE51bWJlciggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBudW1iZXI7XG5cdFx0XHRcdFx0aWYgKCBudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiArbnVtYmVyXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3RyaW5nKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSxcblx0XHRcdFx0XHRcdHZhbHVlcztcblx0XHRcdFx0XHRpZiAoIHN0cmluZ0xpdGVyYWwgJiYgKCB2YWx1ZXMgPSBwYXJzZXIudmFsdWVzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBzdHJpbmdMaXRlcmFsLnYucmVwbGFjZSggcGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAkMSBpbiB2YWx1ZXMgPyB2YWx1ZXNbICQxIF0gOiAkMTtcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0T2JqZWN0KCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCwgcGFpcjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd7JyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggcGFpciA9IGdldEtleVZhbHVlUGFpciggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRbIHBhaXIua2V5IF0gPSBwYWlyLnZhbHVlO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRBcnJheSggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQsIHZhbHVlVG9rZW47XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIHZhbHVlVG9rZW4udiApO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSApO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIga2V5LCB2YWx1ZVRva2VuLCBwYWlyO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0a2V5ID0gZ2V0S2V5KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWtleSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlyID0ge1xuXHRcdFx0XHRrZXk6IGtleVxuXHRcdFx0fTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCk7XG5cdFx0XHRpZiAoICF2YWx1ZVRva2VuICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cdFx0XHRyZXR1cm4gcGFpcjtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHIsIHZhbHVlcyApIHtcblx0XHRcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlciggc3RyLCB7XG5cdFx0XHRcdHZhbHVlczogdmFsdWVzXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcGFyc2VyLnJlc3VsdDtcblx0XHR9O1xuXHR9KCBQYXJzZXIsIHN0cmluZ0xpdGVyYWwsIGtleSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9wcm9jZXNzRGlyZWN0aXZlLmpzICovXG5cdHZhciBwcm9jZXNzRGlyZWN0aXZlID0gZnVuY3Rpb24oIFBhcnNlciwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uLCBwYXJzZUpTT04gKSB7XG5cblx0XHR2YXIgbWV0aG9kQ2FsbFBhdHRlcm4gPSAvXihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFwoLyxcblx0XHRcdEV4cHJlc3Npb25QYXJzZXI7XG5cdFx0RXhwcmVzc2lvblBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGNvbnZlcnRlcnM6IFsgY29uZGl0aW9uYWwgXVxuXHRcdH0gKTtcblx0XHQvLyBUT0RPIGNsZWFuIHRoaXMgdXAsIGl0J3Mgc2hvY2tpbmdcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRva2VucyApIHtcblx0XHRcdHZhciByZXN1bHQsIG1hdGNoLCBwYXJzZXIsIGFyZ3MsIHRva2VuLCBjb2xvbkluZGV4LCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzLCBwYXJzZWQ7XG5cdFx0XHRpZiAoIHR5cGVvZiB0b2tlbnMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoIG1hdGNoID0gbWV0aG9kQ2FsbFBhdHRlcm4uZXhlYyggdG9rZW5zICkgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdFx0bTogbWF0Y2hbIDEgXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YXJncyA9ICdbJyArIHRva2Vucy5zbGljZSggcmVzdWx0Lm0ubGVuZ3RoICsgMSwgLTEgKSArICddJztcblx0XHRcdFx0XHRwYXJzZXIgPSBuZXcgRXhwcmVzc2lvblBhcnNlciggYXJncyApO1xuXHRcdFx0XHRcdHJlc3VsdC5hID0gZmxhdHRlbkV4cHJlc3Npb24oIHBhcnNlci5yZXN1bHRbIDAgXSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0b2tlbnMuaW5kZXhPZiggJzonICkgPT09IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMudHJpbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRva2VucyA9IFsgdG9rZW5zIF07XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdGRpcmVjdGl2ZU5hbWUgPSBbXTtcblx0XHRcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblx0XHRcdGlmICggdG9rZW5zICkge1xuXHRcdFx0XHR3aGlsZSAoIHRva2Vucy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRjb2xvbkluZGV4ID0gdG9rZW4uaW5kZXhPZiggJzonICk7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9uSW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cblx0XHRcdFx0XHRcdFx0aWYgKCBjb2xvbkluZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG5vXG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbi5zdWJzdHIoIDAsIGNvbG9uSW5kZXggKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIHRoZSBjb2xvbiBpbiB0aGlzIHRva2VuLCB0cmVhdFxuXHRcdFx0XHRcdFx0XHQvLyBpdCBhcyB0aGUgZmlyc3QgdG9rZW4gb2YgdGhlIGRpcmVjdGl2ZUFyZ3MgZnJhZ21lbnRcblx0XHRcdFx0XHRcdFx0aWYgKCB0b2tlbi5sZW5ndGggPiBjb2xvbkluZGV4ICsgMSApIHtcblx0XHRcdFx0XHRcdFx0XHRkaXJlY3RpdmVBcmdzWyAwIF0gPSB0b2tlbi5zdWJzdHJpbmcoIGNvbG9uSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlyZWN0aXZlQXJncyA9IGRpcmVjdGl2ZUFyZ3MuY29uY2F0KCB0b2tlbnMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWRpcmVjdGl2ZU5hbWUubGVuZ3RoICkge1xuXHRcdFx0XHRyZXN1bHQgPSAnJztcblx0XHRcdH0gZWxzZSBpZiAoIGRpcmVjdGl2ZUFyZ3MubGVuZ3RoIHx8IHR5cGVvZiBkaXJlY3RpdmVOYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByZWFsbHkgbmVjZXNzYXJ5PyBqdXN0IHVzZSB0aGUgYXJyYXlcblx0XHRcdFx0XHRuOiBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVsgMCBdID09PSAnc3RyaW5nJyA/IGRpcmVjdGl2ZU5hbWVbIDAgXSA6IGRpcmVjdGl2ZU5hbWVcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlQXJnc1sgMCBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oICdbJyArIGRpcmVjdGl2ZUFyZ3NbIDAgXSArICddJyApO1xuXHRcdFx0XHRcdHJlc3VsdC5hID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogZGlyZWN0aXZlQXJnc1sgMCBdLnRyaW0oKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQuZCA9IGRpcmVjdGl2ZUFyZ3M7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IGRpcmVjdGl2ZU5hbWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIFBhcnNlciwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uLCBwYXJzZUpTT04gKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQuanMgKi9cblx0dmFyIGVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIHZvaWRFbGVtZW50TmFtZXMsIGdldE11c3RhY2hlLCBnZXRDb21tZW50LCBnZXRUZXh0LCBnZXRDbG9zaW5nVGFnLCBnZXRBdHRyaWJ1dGUsIHByb2Nlc3NEaXJlY3RpdmUgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi8sXG5cdFx0XHR2YWxpZFRhZ05hbWVGb2xsb3dlciA9IC9eW1xcc1xcblxcLz5dLyxcblx0XHRcdG9uUGF0dGVybiA9IC9eb24vLFxuXHRcdFx0cHJveHlFdmVudFBhdHRlcm4gPSAvXm9uLShbYS16QS1aXFxcXCpcXFxcLiRfXVthLXpBLVpcXFxcKlxcXFwuJF8wLTlcXC1dKykkLyxcblx0XHRcdHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZXxjb25zdHJ1Y3R8Y29uZmlnfGluaXR8cmVuZGVyfHVucmVuZGVyfGRldGFjaHxpbnNlcnQpJC8sXG5cdFx0XHRkaXJlY3RpdmVzID0ge1xuXHRcdFx0XHQnaW50cm8tb3V0cm8nOiAndDAnLFxuXHRcdFx0XHRpbnRybzogJ3QxJyxcblx0XHRcdFx0b3V0cm86ICd0MicsXG5cdFx0XHRcdGRlY29yYXRvcjogJ28nXG5cdFx0XHR9LFxuXHRcdFx0ZXhjbHVkZSA9IHtcblx0XHRcdFx0ZXhjbHVkZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGNvbnZlcnRlcnMsIGRpc2FsbG93ZWRDb250ZW50cztcblx0XHQvLyBEaWZmZXJlbnQgc2V0IG9mIGNvbnZlcnRlcnMsIGJlY2F1c2UgdGhpcyB0aW1lIHdlJ3JlIGxvb2tpbmcgZm9yIGNsb3NpbmcgdGFnc1xuXHRcdGNvbnZlcnRlcnMgPSBbXG5cdFx0XHRnZXRNdXN0YWNoZSxcblx0XHRcdGdldENvbW1lbnQsXG5cdFx0XHRnZXRFbGVtZW50LFxuXHRcdFx0Z2V0VGV4dCxcblx0XHRcdGdldENsb3NpbmdUYWdcblx0XHRdO1xuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LXRhZy1vbWlzc2lvblxuXHRcdGRpc2FsbG93ZWRDb250ZW50cyA9IHtcblx0XHRcdGxpOiBbICdsaScgXSxcblx0XHRcdGR0OiBbXG5cdFx0XHRcdCdkdCcsXG5cdFx0XHRcdCdkZCdcblx0XHRcdF0sXG5cdFx0XHRkZDogW1xuXHRcdFx0XHQnZHQnLFxuXHRcdFx0XHQnZGQnXG5cdFx0XHRdLFxuXHRcdFx0cDogJ2FkZHJlc3MgYXJ0aWNsZSBhc2lkZSBibG9ja3F1b3RlIGRpdiBkbCBmaWVsZHNldCBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkZXIgaGdyb3VwIGhyIG1haW4gbWVudSBuYXYgb2wgcCBwcmUgc2VjdGlvbiB0YWJsZSB1bCcuc3BsaXQoICcgJyApLFxuXHRcdFx0cnQ6IFtcblx0XHRcdFx0J3J0Jyxcblx0XHRcdFx0J3JwJ1xuXHRcdFx0XSxcblx0XHRcdHJwOiBbXG5cdFx0XHRcdCdydCcsXG5cdFx0XHRcdCdycCdcblx0XHRcdF0sXG5cdFx0XHRvcHRncm91cDogWyAnb3B0Z3JvdXAnIF0sXG5cdFx0XHRvcHRpb246IFtcblx0XHRcdFx0J29wdGlvbicsXG5cdFx0XHRcdCdvcHRncm91cCdcblx0XHRcdF0sXG5cdFx0XHR0aGVhZDogW1xuXHRcdFx0XHQndGJvZHknLFxuXHRcdFx0XHQndGZvb3QnXG5cdFx0XHRdLFxuXHRcdFx0dGJvZHk6IFtcblx0XHRcdFx0J3Rib2R5Jyxcblx0XHRcdFx0J3Rmb290J1xuXHRcdFx0XSxcblx0XHRcdHRmb290OiBbICd0Ym9keScgXSxcblx0XHRcdHRyOiBbXG5cdFx0XHRcdCd0cicsXG5cdFx0XHRcdCd0Ym9keSdcblx0XHRcdF0sXG5cdFx0XHR0ZDogW1xuXHRcdFx0XHQndGQnLFxuXHRcdFx0XHQndGgnLFxuXHRcdFx0XHQndHInXG5cdFx0XHRdLFxuXHRcdFx0dGg6IFtcblx0XHRcdFx0J3RkJyxcblx0XHRcdFx0J3RoJyxcblx0XHRcdFx0J3RyJ1xuXHRcdFx0XVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBnZXRFbGVtZW50O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RWxlbWVudCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBlbGVtZW50LCBsb3dlckNhc2VOYW1lLCBkaXJlY3RpdmVOYW1lLCBtYXRjaCwgYWRkUHJveHlFdmVudCwgYXR0cmlidXRlLCBkaXJlY3RpdmUsIHNlbGZDbG9zaW5nLCBjaGlsZHJlbiwgY2hpbGQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoIHBhcnNlci5pbnNpZGUgfHwgcGFyc2VyLmluQXR0cmlidXRlICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzwnICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG5cdFx0XHRpZiAoIHBhcnNlci5uZXh0Q2hhcigpID09PSAnLycgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudCA9IHtcblx0XHRcdFx0dDogdHlwZXMuRUxFTUVOVFxuXHRcdFx0fTtcblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRlbGVtZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyggc3RhcnQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnIScgKSApIHtcblx0XHRcdFx0ZWxlbWVudC55ID0gMTtcblx0XHRcdH1cblx0XHRcdC8vIGVsZW1lbnQgbmFtZVxuXHRcdFx0ZWxlbWVudC5lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdGFnTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIWVsZW1lbnQuZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcblx0XHRcdGlmICggIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QoIHBhcnNlci5uZXh0Q2hhcigpICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgdGFnIG5hbWUnICk7XG5cdFx0XHR9XG5cdFx0XHRhZGRQcm94eUV2ZW50ID0gZnVuY3Rpb24oIG5hbWUsIGRpcmVjdGl2ZSApIHtcblx0XHRcdFx0dmFyIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubiB8fCBkaXJlY3RpdmU7XG5cdFx0XHRcdGlmICggcmVzZXJ2ZWRFdmVudE5hbWVzLnRlc3QoIGRpcmVjdGl2ZU5hbWUgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zIC09IGRpcmVjdGl2ZU5hbWUubGVuZ3RoO1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0Nhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUsIGNvbnN0cnVjdCwgY29uZmlnLCBpbml0LCByZW5kZXIsIHVucmVuZGVyLCBkZXRhY2gsIGluc2VydCknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbWVudC52WyBuYW1lIF0gPSBkaXJlY3RpdmU7XG5cdFx0XHR9O1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gZGlyZWN0aXZlcyBhbmQgYXR0cmlidXRlc1xuXHRcdFx0d2hpbGUgKCBhdHRyaWJ1dGUgPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Ly8gcmVndWxhciBhdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICggYXR0cmlidXRlLm5hbWUgKSB7XG5cdFx0XHRcdFx0Ly8gaW50cm8sIG91dHJvLCBkZWNvcmF0b3Jcblx0XHRcdFx0XHRpZiAoIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVzWyBhdHRyaWJ1dGUubmFtZSBdICkge1xuXHRcdFx0XHRcdFx0ZWxlbWVudFsgZGlyZWN0aXZlTmFtZSBdID0gcHJvY2Vzc0RpcmVjdGl2ZSggYXR0cmlidXRlLnZhbHVlICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZWxlbWVudC52IClcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC52ID0ge307XG5cdFx0XHRcdFx0XHRkaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlKCBhdHRyaWJ1dGUudmFsdWUgKTtcblx0XHRcdFx0XHRcdGFkZFByb3h5RXZlbnQoIG1hdGNoWyAxIF0sIGRpcmVjdGl2ZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoICFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICFlbGVtZW50LmEgKVxuXHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQuYSA9IHt9O1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmFbIGF0dHJpYnV0ZS5uYW1lIF0gPSBhdHRyaWJ1dGUudmFsdWUgfHwgMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCAhZWxlbWVudC5tIClcblx0XHRcdFx0XHRcdGVsZW1lbnQubSA9IFtdO1xuXHRcdFx0XHRcdGVsZW1lbnQubS5wdXNoKCBhdHRyaWJ1dGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nIHNvbGlkdXNcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIHNlbGYtY2xvc2luZyBzb2xpZHVzP1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcvJyApICkge1xuXHRcdFx0XHRzZWxmQ2xvc2luZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBjbG9zaW5nIGFuZ2xlIGJyYWNrZXRcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz4nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0bG93ZXJDYXNlTmFtZSA9IGVsZW1lbnQuZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKCAhc2VsZkNsb3NpbmcgJiYgIXZvaWRFbGVtZW50TmFtZXMudGVzdCggZWxlbWVudC5lICkgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGlmIHdlIG9wZW4gYSBzY3JpcHQgZWxlbWVudCwgZnVydGhlciB0YWdzIHNob3VsZFxuXHRcdFx0XHQvLyBiZSBpZ25vcmVkIHVubGVzcyB0aGV5J3JlIGEgY2xvc2luZyBzY3JpcHQgZWxlbWVudFxuXHRcdFx0XHRpZiAoIGxvd2VyQ2FzZU5hbWUgPT09ICdzY3JpcHQnIHx8IGxvd2VyQ2FzZU5hbWUgPT09ICdzdHlsZScgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmluc2lkZSA9IGxvd2VyQ2FzZU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBjYW5Db250YWluKCBsb3dlckNhc2VOYW1lLCBwYXJzZXIucmVtYWluaW5nKCkgKSAmJiAoIGNoaWxkID0gcGFyc2VyLnJlYWQoIGNvbnZlcnRlcnMgKSApICkge1xuXHRcdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGNsb3Npbmcgc2VjdGlvbiB0YWdcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HX1RBRyApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdGVsZW1lbnQuZiA9IGNoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5zaWRlID0gbnVsbDtcblx0XHRcdGlmICggcGFyc2VyLnNhbml0aXplRWxlbWVudHMgJiYgcGFyc2VyLnNhbml0aXplRWxlbWVudHMuaW5kZXhPZiggbG93ZXJDYXNlTmFtZSApICE9PSAtMSApIHtcblx0XHRcdFx0cmV0dXJuIGV4Y2x1ZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYW5Db250YWluKCBuYW1lLCByZW1haW5pbmcgKSB7XG5cdFx0XHR2YXIgbWF0Y2gsIGRpc2FsbG93ZWQ7XG5cdFx0XHRtYXRjaCA9IC9ePChbYS16QS1aXVthLXpBLVowLTldKikvLmV4ZWMoIHJlbWFpbmluZyApO1xuXHRcdFx0ZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWRDb250ZW50c1sgbmFtZSBdO1xuXHRcdFx0aWYgKCAhbWF0Y2ggfHwgIWRpc2FsbG93ZWQgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICF+ZGlzYWxsb3dlZC5pbmRleE9mKCBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgdm9pZEVsZW1lbnROYW1lcywgbXVzdGFjaGUsIGNvbW1lbnQsIHRleHQsIGNsb3NpbmdUYWcsIGF0dHJpYnV0ZSwgcHJvY2Vzc0RpcmVjdGl2ZSApO1xuXG5cdC8qIHBhcnNlL3V0aWxzL3RyaW1XaGl0ZXNwYWNlLmpzICovXG5cdHZhciB0cmltV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gL15bIFxcdFxcZlxcclxcbl0rLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBpdGVtcywgbGVhZGluZywgdHJhaWxpbmcgKSB7XG5cdFx0XHR2YXIgaXRlbTtcblx0XHRcdGlmICggbGVhZGluZyApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyAwIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoIGxlYWRpbmdXaGl0ZXNwYWNlLCAnJyApO1xuXHRcdFx0XHRcdGlmICggIWl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgMCBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggdHJhaWxpbmcgKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKCB0cmFpbGluZ1doaXRlc3BhY2UsICcnICk7XG5cdFx0XHRcdFx0aWYgKCAhaXRlbSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvdXRpbHMvc3RyaXBTdGFuZGFsb25lcy5qcyAqL1xuXHR2YXIgc3RyaXBTdGFuZGFsb25lcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgbGVhZGluZ0xpbmVicmVhayA9IC9eXFxzKlxccj9cXG4vLFxuXHRcdFx0dHJhaWxpbmdMaW5lYnJlYWsgPSAvXFxyP1xcblxccyokLztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcblx0XHRcdHZhciBpLCBjdXJyZW50LCBiYWNrT25lLCBiYWNrVHdvLCBsYXN0U2VjdGlvbkl0ZW07XG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRjdXJyZW50ID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0YmFja09uZSA9IGl0ZW1zWyBpIC0gMSBdO1xuXHRcdFx0XHRiYWNrVHdvID0gaXRlbXNbIGkgLSAyIF07XG5cdFx0XHRcdC8vIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgYSBbdGV4dF1bY29tbWVudF1bdGV4dF0gc2VxdWVuY2UuLi5cblx0XHRcdFx0aWYgKCBpc1N0cmluZyggY3VycmVudCApICYmIGlzQ29tbWVudCggYmFja09uZSApICYmIGlzU3RyaW5nKCBiYWNrVHdvICkgKSB7XG5cdFx0XHRcdFx0Ly8gLi4uIGFuZCB0aGUgY29tbWVudCBpcyBhIHN0YW5kYWxvbmUgKGkuZS4gbGluZSBicmVha3MgZWl0aGVyIHNpZGUpLi4uXG5cdFx0XHRcdFx0aWYgKCB0cmFpbGluZ0xpbmVicmVhay50ZXN0KCBiYWNrVHdvICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi4gdGhlbiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBhZnRlciB0aGUgZmlyc3QgbGluZSBicmVha1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgLSAyIF0gPSBiYWNrVHdvLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0Ly8gYW5kIHRoZSBsZWFkaW5nIGxpbmUgYnJlYWsgb2YgdGhlIHNlY29uZCB0ZXh0IHRva2VuXG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gY3VycmVudC5yZXBsYWNlKCBsZWFkaW5nTGluZWJyZWFrLCAnJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgY3VycmVudCBpdGVtIGlzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIHByZWNlZGVkIGJ5IGEgbGluZWJyZWFrLCBhbmRcblx0XHRcdFx0Ly8gaXRzIGZpcnN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cblx0XHRcdFx0aWYgKCBpc1NlY3Rpb24oIGN1cnJlbnQgKSAmJiBpc1N0cmluZyggYmFja09uZSApICkge1xuXHRcdFx0XHRcdGlmICggdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggYmFja09uZSApICYmIGlzU3RyaW5nKCBjdXJyZW50LmZbIDAgXSApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudC5mWyAwIF0gKSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIC0gMSBdID0gYmFja09uZS5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdGN1cnJlbnQuZlsgMCBdID0gY3VycmVudC5mWyAwIF0ucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGxhc3QgaXRlbSB3YXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgZm9sbG93ZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuXHRcdFx0XHQvLyBpdHMgbGFzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG5cdFx0XHRcdGlmICggaXNTdHJpbmcoIGN1cnJlbnQgKSAmJiBpc1NlY3Rpb24oIGJhY2tPbmUgKSApIHtcblx0XHRcdFx0XHRsYXN0U2VjdGlvbkl0ZW0gPSBiYWNrT25lLmZbIGJhY2tPbmUuZi5sZW5ndGggLSAxIF07XG5cdFx0XHRcdFx0aWYgKCBpc1N0cmluZyggbGFzdFNlY3Rpb25JdGVtICkgJiYgdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggbGFzdFNlY3Rpb25JdGVtICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50ICkgKSB7XG5cdFx0XHRcdFx0XHRiYWNrT25lLmZbIGJhY2tPbmUuZi5sZW5ndGggLSAxIF0gPSBsYXN0U2VjdGlvbkl0ZW0ucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gY3VycmVudC5yZXBsYWNlKCBsZWFkaW5nTGluZWJyZWFrLCAnJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1N0cmluZyggaXRlbSApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDb21tZW50KCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udCA9PT0gdHlwZXMuQ09NTUVOVCB8fCBpdGVtLnQgPT09IHR5cGVzLkRFTElNQ0hBTkdFO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU2VjdGlvbiggaXRlbSApIHtcblx0XHRcdHJldHVybiAoIGl0ZW0udCA9PT0gdHlwZXMuU0VDVElPTiB8fCBpdGVtLnQgPT09IHR5cGVzLklOVkVSVEVEICkgJiYgaXRlbS5mO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzICk7XG5cblx0LyogdXRpbHMvZXNjYXBlUmVnRXhwLmpzICovXG5cdHZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBwYXR0ZXJuID0gL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCggc3RyICkge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCBwYXR0ZXJuLCAnXFxcXCQmJyApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9fcGFyc2UuanMgKi9cblx0dmFyIHBhcnNlID0gZnVuY3Rpb24oIHR5cGVzLCBQYXJzZXIsIG11c3RhY2hlLCBjb21tZW50LCBlbGVtZW50LCB0ZXh0LCB0cmltV2hpdGVzcGFjZSwgc3RyaXBTdGFuZGFsb25lcywgZXNjYXBlUmVnRXhwICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBTdGFuZGFyZFBhcnNlciwgcGFyc2UsIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSsvZyxcblx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzID0gL14oPzpwcmV8c2NyaXB0fHN0eWxlfHRleHRhcmVhKSQvaSxcblx0XHRcdGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9cXHMrJC87XG5cdFx0U3RhbmRhcmRQYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHQvLyBjb25maWdcblx0XHRcdFx0c2V0RGVsaW1pdGVycyggb3B0aW9ucywgdGhpcyApO1xuXHRcdFx0XHR0aGlzLnNlY3Rpb25EZXB0aCA9IDA7XG5cdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGUgPSB7XG5cdFx0XHRcdFx0c2NyaXB0OiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnNjcmlwdCAhPT0gZmFsc2UsXG5cdFx0XHRcdFx0c3R5bGU6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc3R5bGUgIT09IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggb3B0aW9ucy5zYW5pdGl6ZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRvcHRpb25zLnNhbml0aXplID0ge1xuXHRcdFx0XHRcdFx0Ly8gYmxhY2tsaXN0IGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtY2FqYS9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2NhamEvbGFuZy9odG1sL2h0bWw0LWVsZW1lbnRzLXdoaXRlbGlzdC5qc29uXG5cdFx0XHRcdFx0XHRlbGVtZW50czogJ2FwcGxldCBiYXNlIGJhc2Vmb250IGJvZHkgZnJhbWUgZnJhbWVzZXQgaGVhZCBodG1sIGlzaW5kZXggbGluayBtZXRhIG5vZnJhbWVzIG5vc2NyaXB0IG9iamVjdCBwYXJhbSBzY3JpcHQgc3R5bGUgdGl0bGUnLnNwbGl0KCAnICcgKSxcblx0XHRcdFx0XHRcdGV2ZW50QXR0cmlidXRlczogdHJ1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zYW5pdGl6ZUVsZW1lbnRzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmVsZW1lbnRzO1xuXHRcdFx0XHR0aGlzLnNhbml0aXplRXZlbnRBdHRyaWJ1dGVzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmV2ZW50QXR0cmlidXRlcztcblx0XHRcdFx0dGhpcy5pbmNsdWRlTGluZVBvc2l0aW9ucyA9IG9wdGlvbnMuaW5jbHVkZUxpbmVQb3NpdGlvbnM7XG5cdFx0XHR9LFxuXHRcdFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uKCBpdGVtcywgb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNlY3Rpb25EZXB0aCA+IDAgKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvciggJ0Egc2VjdGlvbiB3YXMgbGVmdCBvcGVuJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNsZWFudXAoIGl0ZW1zLCBvcHRpb25zLnN0cmlwQ29tbWVudHMgIT09IGZhbHNlLCBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgIW9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAhb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIG9wdGlvbnMucmV3cml0ZUVsc2UgIT09IGZhbHNlICk7XG5cdFx0XHRcdHJldHVybiBpdGVtcztcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzOiBbXG5cdFx0XHRcdG11c3RhY2hlLFxuXHRcdFx0XHRjb21tZW50LFxuXHRcdFx0XHRlbGVtZW50LFxuXHRcdFx0XHR0ZXh0XG5cdFx0XHRdXG5cdFx0fSApO1xuXHRcdHBhcnNlID0gZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0dmFyIHJlc3VsdCwgcmVtYWluaW5nLCBwYXJ0aWFscywgbmFtZSwgc3RhcnRNYXRjaCwgZW5kTWF0Y2gsIGlubGluZVBhcnRpYWxTdGFydCwgaW5saW5lUGFydGlhbEVuZDtcblx0XHRcdHNldERlbGltaXRlcnMoIG9wdGlvbnMgKTtcblx0XHRcdGlubGluZVBhcnRpYWxTdGFydCA9IG5ldyBSZWdFeHAoICc8IS0tXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggb3B0aW9ucy5kZWxpbWl0ZXJzWyAwIF0gKSArICdcXFxccyo+XFxcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXFxccyonICsgZXNjYXBlUmVnRXhwKCBvcHRpb25zLmRlbGltaXRlcnNbIDEgXSApICsgJ1xcXFxzKi0tPicgKTtcblx0XHRcdGlubGluZVBhcnRpYWxFbmQgPSBuZXcgUmVnRXhwKCAnPCEtLVxcXFxzKicgKyBlc2NhcGVSZWdFeHAoIG9wdGlvbnMuZGVsaW1pdGVyc1sgMCBdICkgKyAnXFxcXHMqXFxcXC9cXFxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKVxcXFxzKicgKyBlc2NhcGVSZWdFeHAoIG9wdGlvbnMuZGVsaW1pdGVyc1sgMSBdICkgKyAnXFxcXHMqLS0+JyApO1xuXHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHR2OiAxXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBpbmxpbmVQYXJ0aWFsU3RhcnQudGVzdCggdGVtcGxhdGUgKSApIHtcblx0XHRcdFx0cmVtYWluaW5nID0gdGVtcGxhdGU7XG5cdFx0XHRcdHRlbXBsYXRlID0gJyc7XG5cdFx0XHRcdHdoaWxlICggc3RhcnRNYXRjaCA9IGlubGluZVBhcnRpYWxTdGFydC5leGVjKCByZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRuYW1lID0gc3RhcnRNYXRjaFsgMSBdO1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IHJlbWFpbmluZy5zdWJzdHIoIDAsIHN0YXJ0TWF0Y2guaW5kZXggKTtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBzdGFydE1hdGNoLmluZGV4ICsgc3RhcnRNYXRjaFsgMCBdLmxlbmd0aCApO1xuXHRcdFx0XHRcdGVuZE1hdGNoID0gaW5saW5lUGFydGlhbEVuZC5leGVjKCByZW1haW5pbmcgKTtcblx0XHRcdFx0XHRpZiAoICFlbmRNYXRjaCB8fCBlbmRNYXRjaFsgMSBdICE9PSBuYW1lICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW5saW5lIHBhcnRpYWxzIG11c3QgaGF2ZSBhIGNsb3NpbmcgZGVsaW1pdGVyLCBhbmQgY2Fubm90IGJlIG5lc3RlZC4gRXhwZWN0ZWQgY2xvc2luZyBmb3IgXCInICsgbmFtZSArICdcIiwgYnV0ICcgKyAoIGVuZE1hdGNoID8gJ2luc3RlYWQgZm91bmQgXCInICsgZW5kTWF0Y2hbIDEgXSArICdcIicgOiAnIG5vIGNsb3NpbmcgZm91bmQnICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KCBwYXJ0aWFscyB8fCAoIHBhcnRpYWxzID0ge30gKSApWyBuYW1lIF0gPSBuZXcgU3RhbmRhcmRQYXJzZXIoIHJlbWFpbmluZy5zdWJzdHIoIDAsIGVuZE1hdGNoLmluZGV4ICksIG9wdGlvbnMgKS5yZXN1bHQ7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggZW5kTWF0Y2guaW5kZXggKyBlbmRNYXRjaFsgMCBdLmxlbmd0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlICs9IHJlbWFpbmluZztcblx0XHRcdFx0cmVzdWx0LnAgPSBwYXJ0aWFscztcblx0XHRcdH1cblx0XHRcdHJlc3VsdC50ID0gbmV3IFN0YW5kYXJkUGFyc2VyKCB0ZW1wbGF0ZSwgb3B0aW9ucyApLnJlc3VsdDtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IHBhcnNlO1xuXG5cdFx0ZnVuY3Rpb24gY2xlYW51cCggaXRlbXMsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSwgcmV3cml0ZUVsc2UgKSB7XG5cdFx0XHR2YXIgaSwgaXRlbSwgcHJldmlvdXNJdGVtLCBuZXh0SXRlbSwgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCB1bmxlc3NCbG9jaywga2V5O1xuXHRcdFx0Ly8gRmlyc3QgcGFzcyAtIHJlbW92ZSBzdGFuZGFsb25lcyBhbmQgY29tbWVudHMgZXRjXG5cdFx0XHRzdHJpcFN0YW5kYWxvbmVzKCBpdGVtcyApO1xuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0Ly8gUmVtb3ZlIGRlbGltaXRlciBjaGFuZ2VzLCB1bnNhZmUgZWxlbWVudHMgZXRjXG5cdFx0XHRcdGlmICggaXRlbS5leGNsdWRlICkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdHJpcENvbW1lbnRzICYmIGl0ZW0udCA9PT0gdHlwZXMuQ09NTUVOVCApIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgbmVjZXNzYXJ5LCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuXHRcdFx0dHJpbVdoaXRlc3BhY2UoIGl0ZW1zLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlICk7XG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0XHQvLyBSZWN1cnNlXG5cdFx0XHRcdGlmICggaXRlbS5mICkge1xuXHRcdFx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gcHJlc2VydmVXaGl0ZXNwYWNlIHx8IGl0ZW0udCA9PT0gdHlwZXMuRUxFTUVOVCAmJiBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cy50ZXN0KCBpdGVtLmUgKTtcblx0XHRcdFx0XHRpZiAoICFwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdHByZXZpb3VzSXRlbSA9IGl0ZW1zWyBpIC0gMSBdO1xuXHRcdFx0XHRcdFx0bmV4dEl0ZW0gPSBpdGVtc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBwcmV2aW91cyBpdGVtIHdhcyBhIHRleHQgaXRlbSB3aXRoIHRyYWlsaW5nIHdoaXRlc3BhY2UsXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgZnJhZ21lbnRcblx0XHRcdFx0XHRcdGlmICggIXByZXZpb3VzSXRlbSB8fCB0eXBlb2YgcHJldmlvdXNJdGVtID09PSAnc3RyaW5nJyAmJiB0cmFpbGluZ1doaXRlc3BhY2UudGVzdCggcHJldmlvdXNJdGVtICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYW5kIHZpY2UgdmVyc2Fcblx0XHRcdFx0XHRcdGlmICggIW5leHRJdGVtIHx8IHR5cGVvZiBuZXh0SXRlbSA9PT0gJ3N0cmluZycgJiYgbGVhZGluZ1doaXRlc3BhY2UudGVzdCggbmV4dEl0ZW0gKSApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBTcGxpdCBpZi1lbHNlIGJsb2NrcyBpbnRvIHR3byAoYW4gaWYsIGFuZCBhbiB1bmxlc3MpXG5cdFx0XHRcdGlmICggaXRlbS5sICkge1xuXHRcdFx0XHRcdGNsZWFudXAoIGl0ZW0ubCwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0XHRpZiAoIHJld3JpdGVFbHNlICkge1xuXHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sgPSB7XG5cdFx0XHRcdFx0XHRcdHQ6IDQsXG5cdFx0XHRcdFx0XHRcdG46IHR5cGVzLlNFQ1RJT05fVU5MRVNTLFxuXHRcdFx0XHRcdFx0XHRmOiBpdGVtLmxcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHQvLyBjb3B5IHRoZSBjb25kaXRpb25hbCBiYXNlZCBvbiBpdHMgdHlwZVxuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLnIgKSB7XG5cdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnIgPSBpdGVtLnI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0ueCApIHtcblx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sueCA9IGl0ZW0ueDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaXRlbS5yeCApIHtcblx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sucnggPSBpdGVtLnJ4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpICsgMSwgMCwgdW5sZXNzQmxvY2sgKTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBpdGVtLmw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENsZWFuIHVwIGVsZW1lbnQgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGl0ZW0uYSApIHtcblx0XHRcdFx0XHRmb3IgKCBrZXkgaW4gaXRlbS5hICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLmEuaGFzT3duUHJvcGVydHkoIGtleSApICYmIHR5cGVvZiBpdGVtLmFbIGtleSBdICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5hWyBrZXkgXSwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGZpbmFsIHBhc3MgLSBmdXNlIHRleHQgbm9kZXMgdG9nZXRoZXJcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbXNbIGkgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbXNbIGkgKyAxIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGl0ZW1zWyBpIF0gKyBpdGVtc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSArIDEsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlICkge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGl0ZW1zWyBpIF0ucmVwbGFjZSggY29udGlndW91c1doaXRlc3BhY2UsICcgJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGl0ZW1zWyBpIF0gPT09ICcnICkge1xuXHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0RGVsaW1pdGVycyggc291cmNlICkge1xuXHRcdFx0dmFyIHRhcmdldCA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHZvaWQgMCApXG5cdFx0XHRcdHRhcmdldCA9IHNvdXJjZTtcblx0XHRcdHRhcmdldC5kZWxpbWl0ZXJzID0gc291cmNlLmRlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQne3snLFxuXHRcdFx0XHQnfX0nXG5cdFx0XHRdO1xuXHRcdFx0dGFyZ2V0LnRyaXBsZURlbGltaXRlcnMgPSBzb3VyY2UudHJpcGxlRGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdCd7e3snLFxuXHRcdFx0XHQnfX19J1xuXHRcdFx0XTtcblx0XHRcdHRhcmdldC5zdGF0aWNEZWxpbWl0ZXJzID0gc291cmNlLnN0YXRpY0RlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQnW1snLFxuXHRcdFx0XHQnXV0nXG5cdFx0XHRdO1xuXHRcdFx0dGFyZ2V0LnN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBzb3VyY2Uuc3RhdGljVHJpcGxlRGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdCdbW1snLFxuXHRcdFx0XHQnXV1dJ1xuXHRcdFx0XTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgUGFyc2VyLCBtdXN0YWNoZSwgY29tbWVudCwgZWxlbWVudCwgdGV4dCwgdHJpbVdoaXRlc3BhY2UsIHN0cmlwU3RhbmRhbG9uZXMsIGVzY2FwZVJlZ0V4cCApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2dyb3Vwcy9vcHRpb25Hcm91cC5qcyAqL1xuXHR2YXIgb3B0aW9uR3JvdXAgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVPcHRpb25Hcm91cCgga2V5cywgY29uZmlnICkge1xuXHRcdFx0dmFyIGdyb3VwID0ga2V5cy5tYXAoIGNvbmZpZyApO1xuXHRcdFx0a2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5LCBpICkge1xuXHRcdFx0XHRncm91cFsga2V5IF0gPSBncm91cFsgaSBdO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGdyb3VwO1xuXHRcdH07XG5cdH0oIGxlZ2FjeSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2dyb3Vwcy9wYXJzZU9wdGlvbnMuanMgKi9cblx0dmFyIHBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uKCBvcHRpb25Hcm91cCApIHtcblxuXHRcdHZhciBrZXlzLCBwYXJzZU9wdGlvbnM7XG5cdFx0a2V5cyA9IFtcblx0XHRcdCdwcmVzZXJ2ZVdoaXRlc3BhY2UnLFxuXHRcdFx0J3Nhbml0aXplJyxcblx0XHRcdCdzdHJpcENvbW1lbnRzJyxcblx0XHRcdCdkZWxpbWl0ZXJzJyxcblx0XHRcdCd0cmlwbGVEZWxpbWl0ZXJzJyxcblx0XHRcdCdpbnRlcnBvbGF0ZSdcblx0XHRdO1xuXHRcdHBhcnNlT3B0aW9ucyA9IG9wdGlvbkdyb3VwKCBrZXlzLCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHBhcnNlT3B0aW9ucztcblx0fSggb3B0aW9uR3JvdXAgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy90ZW1wbGF0ZS9wYXJzZXIuanMgKi9cblx0dmFyIHBhcnNlciA9IGZ1bmN0aW9uKCBlcnJvcnMsIGlzQ2xpZW50LCBwYXJzZSwgY3JlYXRlLCBwYXJzZU9wdGlvbnMgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0ge1xuXHRcdFx0cGFyc2U6IGRvUGFyc2UsXG5cdFx0XHRmcm9tSWQ6IGZyb21JZCxcblx0XHRcdGlzSGFzaGVkSWQ6IGlzSGFzaGVkSWQsXG5cdFx0XHRpc1BhcnNlZDogaXNQYXJzZWQsXG5cdFx0XHRnZXRQYXJzZU9wdGlvbnM6IGdldFBhcnNlT3B0aW9ucyxcblx0XHRcdGNyZWF0ZUhlbHBlcjogY3JlYXRlSGVscGVyXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUhlbHBlciggcGFyc2VPcHRpb25zICkge1xuXHRcdFx0dmFyIGhlbHBlciA9IGNyZWF0ZSggcGFyc2VyICk7XG5cdFx0XHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiggdGVtcGxhdGUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiBkb1BhcnNlKCB0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMgKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaGVscGVyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvUGFyc2UoIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoICFwYXJzZSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvcnMubWlzc2luZ1BhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zIHx8IHRoaXMub3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZyb21JZCggaWQsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGVtcGxhdGU7XG5cdFx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IHJldHJpZXZlIHRlbXBsYXRlICMnICsgaWQgKyAnIGFzIFJhY3RpdmUgaXMgbm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLicgKTtcblx0XHRcdH1cblx0XHRcdGlmICggaXNIYXNoZWRJZCggaWQgKSApIHtcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHJpbmcoIDEgKTtcblx0XHRcdH1cblx0XHRcdGlmICggISggdGVtcGxhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggaWQgKSApICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgIycgKyBpZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdTQ1JJUFQnICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgIycgKyBpZCArICcsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50JyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0hhc2hlZElkKCBpZCApIHtcblx0XHRcdHJldHVybiBpZCAmJiBpZC5jaGFyQXQoIDAgKSA9PT0gJyMnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzUGFyc2VkKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHJldHVybiAhKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkge1xuXHRcdFx0Ly8gQ291bGQgYmUgUmFjdGl2ZSBvciBhIENvbXBvbmVudFxuXHRcdFx0aWYgKCByYWN0aXZlLmRlZmF1bHRzICkge1xuXHRcdFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5kZWZhdWx0cztcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJzZU9wdGlvbnMucmVkdWNlKCBmdW5jdGlvbiggdmFsLCBrZXkgKSB7XG5cdFx0XHRcdHZhbFsga2V5IF0gPSByYWN0aXZlWyBrZXkgXTtcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0sIHt9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJzZXI7XG5cdH0oIGVycm9ycywgaXNDbGllbnQsIHBhcnNlLCBjcmVhdGUsIHBhcnNlT3B0aW9ucyApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL3RlbXBsYXRlL3RlbXBsYXRlLmpzICovXG5cdHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKCBwYXJzZXIsIHBhcnNlICkge1xuXG5cdFx0dmFyIHRlbXBsYXRlQ29uZmlnID0ge1xuXHRcdFx0bmFtZTogJ3RlbXBsYXRlJyxcblx0XHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGU7XG5cdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGV4aXN0c1xuXHRcdFx0XHRpZiAoICd0ZW1wbGF0ZScgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcoIHRlbXBsYXRlLCBwcm90byApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uIGluaXQoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlLCBmbjtcblx0XHRcdFx0Ly8gVE9ETyBiZWNhdXNlIG9mIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHdlIG1pZ2h0IGp1c3QgYmUgYWJsZSB0byB1c2Vcblx0XHRcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZSwgYW5kIG5vdCBib3RoZXIgcGFzc2luZyB0aHJvdWdoIHRoZSBQYXJlbnQgb2JqZWN0LlxuXHRcdFx0XHQvLyBBdCBwcmVzZW50IHRoYXQgYnJlYWtzIHRoZSB0ZXN0IG1vY2tzJyBleHBlY3RhdGlvbnNcblx0XHRcdFx0dGVtcGxhdGUgPSAndGVtcGxhdGUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRlbXBsYXRlIDogUGFyZW50LnByb3RvdHlwZS50ZW1wbGF0ZTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0Zm4gPSB0ZW1wbGF0ZTtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgZm4gKTtcblx0XHRcdFx0XHRyYWN0aXZlLl9jb25maWcudGVtcGxhdGUgPSB7XG5cdFx0XHRcdFx0XHRmbjogZm4sXG5cdFx0XHRcdFx0XHRyZXN1bHQ6IHRlbXBsYXRlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcoIHRlbXBsYXRlLCByYWN0aXZlICk7XG5cdFx0XHRcdC8vIFRPRE8gdGhlIG5hbWluZyBvZiB0aGlzIGlzIGNvbmZ1c2luZyAtIHJhY3RpdmUudGVtcGxhdGUgcmVmZXJzIHRvIFsuLi5dLFxuXHRcdFx0XHQvLyBidXQgQ29tcG9uZW50LnByb3RvdHlwZS50ZW1wbGF0ZSByZWZlcnMgdG8ge3Y6MSx0OltdLHA6W119Li4uXG5cdFx0XHRcdC8vIGl0J3MgdW5uZWNlc3NhcnksIGJlY2F1c2UgdGhlIGRldmVsb3BlciBuZXZlciBuZWVkcyB0byBhY2Nlc3Ncblx0XHRcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZVxuXHRcdFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gdGVtcGxhdGUudDtcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZS5wICkge1xuXHRcdFx0XHRcdGV4dGVuZFBhcnRpYWxzKCByYWN0aXZlLnBhcnRpYWxzLCB0ZW1wbGF0ZS5wICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNldDogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSByZXNldFZhbHVlKCByYWN0aXZlICksXG5cdFx0XHRcdFx0cGFyc2VkO1xuXHRcdFx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdFx0XHRwYXJzZWQgPSBwYXJzZUlmU3RyaW5nKCByZXN1bHQsIHJhY3RpdmUgKTtcblx0XHRcdFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gcGFyc2VkLnQ7XG5cdFx0XHRcdFx0ZXh0ZW5kUGFydGlhbHMoIHJhY3RpdmUucGFydGlhbHMsIHBhcnNlZC5wLCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRWYWx1ZSggcmFjdGl2ZSApIHtcblx0XHRcdHZhciBpbml0aWFsID0gcmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlLFxuXHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHQvLyBJZiB0aGlzIGlzbid0IGEgZHluYW1pYyB0ZW1wbGF0ZSwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG5cdFx0XHRpZiAoICFpbml0aWFsIHx8ICFpbml0aWFsLmZuICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGluaXRpYWwuZm4gKTtcblx0XHRcdC8vIFRPRE8gZGVlcCBlcXVhbGl0eSBjaGVjayB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcmluZ1xuXHRcdFx0Ly8gaW4gdGhlIGNhc2Ugb2YgYWxyZWFkeS1wYXJzZWQgdGVtcGxhdGVzXG5cdFx0XHRpZiAoIHJlc3VsdCAhPT0gaW5pdGlhbC5yZXN1bHQgKSB7XG5cdFx0XHRcdGluaXRpYWwucmVzdWx0ID0gcmVzdWx0O1xuXHRcdFx0XHRyZXN1bHQgPSBwYXJzZUlmU3RyaW5nKCByZXN1bHQsIHJhY3RpdmUgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGZuICkge1xuXHRcdFx0dmFyIGhlbHBlciA9IHBhcnNlci5jcmVhdGVIZWxwZXIoIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0cmV0dXJuIGZuLmNhbGwoIHJhY3RpdmUsIHJhY3RpdmUuZGF0YSwgaGVscGVyICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHJhY3RpdmUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdC8vIElEIG9mIGFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgdGVtcGxhdGU/XG5cdFx0XHRcdGlmICggdGVtcGxhdGVbIDAgXSA9PT0gJyMnICkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gcGFyc2VyLmZyb21JZCggdGVtcGxhdGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS52ICE9PSAxICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNaXNtYXRjaGVkIHRlbXBsYXRlIHZlcnNpb24hIFBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgUmFjdGl2ZS5qcyBpbiB5b3VyIGJ1aWxkIHByb2Nlc3MgYXMgd2VsbCBhcyBpbiB5b3VyIGFwcCcgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZW1wbGF0ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmRQYXJ0aWFscyggZXhpc3RpbmdQYXJ0aWFscywgbmV3UGFydGlhbHMsIG92ZXJ3cml0ZSApIHtcblx0XHRcdGlmICggIW5ld1BhcnRpYWxzIClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Ly8gVE9ETyB0aGVyZSdzIGFuIGFtYmlndWl0eSBoZXJlIC0gd2UgbmVlZCB0byBvdmVyd3JpdGUgaW4gdGhlIGByZXNldCgpYFxuXHRcdFx0Ly8gY2FzZSwgYnV0IG5vdCBpbml0aWFsbHkuLi5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gbmV3UGFydGlhbHMgKSB7XG5cdFx0XHRcdGlmICggb3ZlcndyaXRlIHx8ICFleGlzdGluZ1BhcnRpYWxzLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHRleGlzdGluZ1BhcnRpYWxzWyBrZXkgXSA9IG5ld1BhcnRpYWxzWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGVtcGxhdGVDb25maWc7XG5cdH0oIHBhcnNlciwgcGFyc2UgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9SZWdpc3RyeS5qcyAqL1xuXHR2YXIgUmVnaXN0cnkgPSBmdW5jdGlvbiggY3JlYXRlICkge1xuXG5cdFx0ZnVuY3Rpb24gUmVnaXN0cnkoIG5hbWUsIHVzZURlZmF1bHRzICkge1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMudXNlRGVmYXVsdHMgPSB1c2VEZWZhdWx0cztcblx0XHR9XG5cdFx0UmVnaXN0cnkucHJvdG90eXBlID0ge1xuXHRcdFx0Y29uc3RydWN0b3I6IFJlZ2lzdHJ5LFxuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5jb25maWd1cmUoIHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsIHRoaXMudXNlRGVmYXVsdHMgPyBwcm90byA6IHByb3RvLmNvbnN0cnVjdG9yLCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5jb25maWd1cmUoIHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHRjb25maWd1cmU6IGZ1bmN0aW9uKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgbmFtZSBdLFxuXHRcdFx0XHRcdHJlZ2lzdHJ5O1xuXHRcdFx0XHRyZWdpc3RyeSA9IGNyZWF0ZSggUGFyZW50WyBuYW1lIF0gKTtcblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmVnaXN0cnlbIGtleSBdID0gb3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IHJlZ2lzdHJ5O1xuXHRcdFx0fSxcblx0XHRcdHJlc2V0OiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dmFyIHJlZ2lzdHJ5ID0gcmFjdGl2ZVsgdGhpcy5uYW1lIF07XG5cdFx0XHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRcdE9iamVjdC5rZXlzKCByZWdpc3RyeSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSByZWdpc3RyeVsga2V5IF07XG5cdFx0XHRcdFx0aWYgKCBpdGVtLl9mbiApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbS5fZm4uaXNPd25lciApIHtcblx0XHRcdFx0XHRcdFx0cmVnaXN0cnlbIGtleSBdID0gaXRlbS5fZm47XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgcmVnaXN0cnlbIGtleSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRPd25lcjogZnVuY3Rpb24oIHJhY3RpdmUsIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIHJhY3RpdmVbIHRoaXMubmFtZSBdLmhhc093blByb3BlcnR5KCBrZXkgKSA/IHJhY3RpdmUgOiB0aGlzLmZpbmRDb25zdHJ1Y3RvciggcmFjdGl2ZS5jb25zdHJ1Y3Rvciwga2V5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbnN0cnVjdG9yOiBmdW5jdGlvbiggY29uc3RydWN0b3IsIGtleSApIHtcblx0XHRcdFx0aWYgKCAhY29uc3RydWN0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb25zdHJ1Y3RvclsgdGhpcy5uYW1lIF0uaGFzT3duUHJvcGVydHkoIGtleSApID8gY29uc3RydWN0b3IgOiB0aGlzLmZpbmRDb25zdHJ1Y3RvciggY29uc3RydWN0b3IuX3BhcmVudCwga2V5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZDogZnVuY3Rpb24oIHJhY3RpdmUsIGtleSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJbIHRoaXMkMC5uYW1lIF1bIGtleSBdO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEluc3RhbmNlOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2VGaW5kKCByYWN0aXZlLCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRyZXR1cm4gclsgdGhpcyQwLm5hbWUgXVsga2V5IF0gPyByIDogdm9pZCAwO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlY3Vyc2VGaW5kKCByYWN0aXZlLCBmbiApIHtcblx0XHRcdHZhciBmaW5kLCBwYXJlbnQ7XG5cdFx0XHRpZiAoIGZpbmQgPSBmbiggcmFjdGl2ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gZmluZDtcblx0XHRcdH1cblx0XHRcdGlmICggIXJhY3RpdmUuaXNvbGF0ZWQgJiYgKCBwYXJlbnQgPSByYWN0aXZlLl9wYXJlbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2VGaW5kKCBwYXJlbnQsIGZuICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBSZWdpc3RyeTtcblx0fSggY3JlYXRlLCBsZWdhY3kgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvcmVnaXN0cmllcy5qcyAqL1xuXHR2YXIgcmVnaXN0cmllcyA9IGZ1bmN0aW9uKCBvcHRpb25Hcm91cCwgUmVnaXN0cnkgKSB7XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdFx0J2FkYXB0b3JzJyxcblx0XHRcdFx0J2NvbXBvbmVudHMnLFxuXHRcdFx0XHQnY29tcHV0ZWQnLFxuXHRcdFx0XHQnZGVjb3JhdG9ycycsXG5cdFx0XHRcdCdlYXNpbmcnLFxuXHRcdFx0XHQnZXZlbnRzJyxcblx0XHRcdFx0J2ludGVycG9sYXRvcnMnLFxuXHRcdFx0XHQncGFydGlhbHMnLFxuXHRcdFx0XHQndHJhbnNpdGlvbnMnXG5cdFx0XHRdLFxuXHRcdFx0cmVnaXN0cmllcyA9IG9wdGlvbkdyb3VwKCBrZXlzLCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2lzdHJ5KCBrZXksIGtleSA9PT0gJ2NvbXB1dGVkJyApO1xuXHRcdFx0fSApO1xuXHRcdHJldHVybiByZWdpc3RyaWVzO1xuXHR9KCBvcHRpb25Hcm91cCwgUmVnaXN0cnkgKTtcblxuXHQvKiB1dGlscy9ub29wLmpzICovXG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKiB1dGlscy93cmFwUHJvdG90eXBlTWV0aG9kLmpzICovXG5cdHZhciB3cmFwUHJvdG90eXBlTWV0aG9kID0gZnVuY3Rpb24oIG5vb3AgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiB3cmFwKCBwYXJlbnQsIG5hbWUsIG1ldGhvZCApIHtcblx0XHRcdGlmICggIS9fc3VwZXIvLnRlc3QoIG1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwU3VwZXIoKSB7XG5cdFx0XHRcdHZhciBzdXBlck1ldGhvZCA9IGdldFN1cGVyTWV0aG9kKCB3cmFwcGVyLl9wYXJlbnQsIG5hbWUgKSxcblx0XHRcdFx0XHRoYXNTdXBlciA9ICdfc3VwZXInIGluIHRoaXMsXG5cdFx0XHRcdFx0b2xkU3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGlmICggaGFzU3VwZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fc3VwZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHR3cmFwcGVyLl9tZXRob2QgPSBtZXRob2Q7XG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0U3VwZXJNZXRob2QoIHBhcmVudCwgbmFtZSApIHtcblx0XHRcdHZhciBtZXRob2Q7XG5cdFx0XHRpZiAoIG5hbWUgaW4gcGFyZW50ICkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJlbnRbIG5hbWUgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gZnVuY3Rpb24gcmV0dXJuVmFsdWUoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWV0aG9kID0gbm9vcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbm9vcCApO1xuXG5cdC8qIGNvbmZpZy9kZXByZWNhdGUuanMgKi9cblx0dmFyIGRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCB3YXJuLCBpc0FycmF5ICkge1xuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlKCBvcHRpb25zLCBkZXByZWNhdGVkLCBjb3JyZWN0ICkge1xuXHRcdFx0aWYgKCBkZXByZWNhdGVkIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggISggY29ycmVjdCBpbiBvcHRpb25zICkgKSB7XG5cdFx0XHRcdFx0d2FybiggZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCApICk7XG5cdFx0XHRcdFx0b3B0aW9uc1sgY29ycmVjdCBdID0gb3B0aW9uc1sgZGVwcmVjYXRlZCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCwgdHJ1ZSApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0LCBpc0Vycm9yICkge1xuXHRcdFx0cmV0dXJuICdvcHRpb25zLicgKyBkZXByZWNhdGVkICsgJyBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBvcHRpb25zLicgKyBjb3JyZWN0ICsgJy4nICsgKCBpc0Vycm9yID8gJyBZb3UgY2Fubm90IHNwZWNpZnkgYm90aCBvcHRpb25zLCBwbGVhc2UgdXNlIG9wdGlvbnMuJyArIGNvcnJlY3QgKyAnLicgOiAnJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZUV2ZW50RGVmaW5pdGlvbnMoIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdldmVudERlZmluaXRpb25zJywgJ2V2ZW50cycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGVBZGFwdG9ycyggb3B0aW9ucyApIHtcblx0XHRcdC8vIFVzaW5nIGV4dGVuZCB3aXRoIENvbXBvbmVudCBpbnN0ZWFkIG9mIG9wdGlvbnMsXG5cdFx0XHQvLyBsaWtlIEh1bWFuLmV4dGVuZCggU3BpZGVyICkgbWVhbnMgYWRhcHRvcnMgYXMgYSByZWdpc3RyeVxuXHRcdFx0Ly8gZ2V0cyBjb3BpZWQgdG8gb3B0aW9ucy4gU28gd2UgaGF2ZSB0byBjaGVjayBpZiBhY3R1YWxseSBhbiBhcnJheVxuXHRcdFx0aWYgKCBpc0FycmF5KCBvcHRpb25zLmFkYXB0b3JzICkgKSB7XG5cdFx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2FkYXB0b3JzJywgJ2FkYXB0JyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24gZGVwcmVjYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2JlZm9yZUluaXQnLCAnb25jb25zdHJ1Y3QnICk7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdpbml0JywgJ29ucmVuZGVyJyApO1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnY29tcGxldGUnLCAnb25jb21wbGV0ZScgKTtcblx0XHRcdGRlcHJlY2F0ZUV2ZW50RGVmaW5pdGlvbnMoIG9wdGlvbnMgKTtcblx0XHRcdGRlcHJlY2F0ZUFkYXB0b3JzKCBvcHRpb25zICk7XG5cdFx0fTtcblx0fSggd2FybiwgaXNBcnJheSApO1xuXG5cdC8qIGNvbmZpZy9jb25maWcuanMgKi9cblx0dmFyIGNvbmZpZyA9IGZ1bmN0aW9uKCBjc3MsIGRhdGEsIGRlZmF1bHRzLCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zLCByZWdpc3RyaWVzLCB3cmFwUHJvdG90eXBlLCBkZXByZWNhdGUgKSB7XG5cblx0XHR2YXIgY3VzdG9tLCBvcHRpb25zLCBjb25maWcsIGJsYWNrbGlzdGVkO1xuXHRcdC8vIHdvdWxkIGJlIG5pY2UgdG8gbm90IGhhdmUgdGhlc2UgaGVyZSxcblx0XHQvLyB0aGV5IGdldCBhZGRlZCBkdXJpbmcgaW5pdGlhbGlzZSwgc28gZm9yIG5vdyB3ZSBoYXZlXG5cdFx0Ly8gdG8gbWFrZSBzdXJlIG5vdCB0byB0cnkgYW5kIGV4dGVuZCB0aGVtLlxuXHRcdC8vIFBvc3NpYmx5LCB3ZSBjb3VsZCByZS1vcmRlciBhbmQgbm90IGFkZCB0aWxsIGxhdGVyXG5cdFx0Ly8gaW4gcHJvY2Vzcy5cblx0XHRibGFja2xpc3RlZCA9IHtcblx0XHRcdCdfcGFyZW50JzogdHJ1ZSxcblx0XHRcdCdfY29tcG9uZW50JzogdHJ1ZVxuXHRcdH07XG5cdFx0Y3VzdG9tID0ge1xuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdGNzczogY3NzXG5cdFx0fTtcblx0XHRvcHRpb25zID0gT2JqZWN0LmtleXMoIGRlZmF1bHRzICkuZmlsdGVyKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuICFyZWdpc3RyaWVzWyBrZXkgXSAmJiAhY3VzdG9tWyBrZXkgXSAmJiAhcGFyc2VPcHRpb25zWyBrZXkgXTtcblx0XHR9ICk7XG5cdFx0Ly8gdGhpcyBkZWZpbmVzIHRoZSBvcmRlcjpcblx0XHRjb25maWcgPSBbXS5jb25jYXQoIGN1c3RvbS5kYXRhLCBwYXJzZU9wdGlvbnMsIG9wdGlvbnMsIHJlZ2lzdHJpZXMsIGN1c3RvbS50ZW1wbGF0ZSwgY3VzdG9tLmNzcyApO1xuXHRcdGZvciAoIHZhciBrZXkgaW4gY3VzdG9tICkge1xuXHRcdFx0Y29uZmlnWyBrZXkgXSA9IGN1c3RvbVsga2V5IF07XG5cdFx0fVxuXHRcdC8vIGZvciBpdGVyYXRpb25cblx0XHRjb25maWcua2V5cyA9IE9iamVjdC5rZXlzKCBkZWZhdWx0cyApLmNvbmNhdCggcmVnaXN0cmllcy5tYXAoIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0cmV0dXJuIHIubmFtZTtcblx0XHR9ICkgKS5jb25jYXQoIFsgJ2NzcycgXSApO1xuXHRcdC8vIGFkZCB0aGVzZSB0byBibGFja2xpc3RlZCBrZXkncyB0aGF0IHdlIGRvbid0IGRvdWJsZSBleHRlbmRcblx0XHRjb25maWcua2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGJsYWNrbGlzdGVkWyBrZXkgXSA9IHRydWU7XG5cdFx0fSApO1xuXHRcdGNvbmZpZy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG5cdFx0Y29uZmlnLnJlZ2lzdHJpZXMgPSByZWdpc3RyaWVzO1xuXG5cdFx0ZnVuY3Rpb24gY3VzdG9tQ29uZmlnKCBtZXRob2QsIGtleSwgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApIHtcblx0XHRcdGN1c3RvbVsga2V5IF1bIG1ldGhvZCBdKCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0fVxuXHRcdGNvbmZpZy5leHRlbmQgPSBmdW5jdGlvbiggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdGNvbmZpZ3VyZSggJ2V4dGVuZCcsIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdGNvbmZpZy5pbml0ID0gZnVuY3Rpb24oIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdGNvbmZpZ3VyZSggJ2luaXQnLCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTdGFuZGFyZERlZmF1bHRLZXkoIGtleSApIHtcblx0XHRcdHJldHVybiBrZXkgaW4gZGVmYXVsdHMgJiYgISgga2V5IGluIGNvbmZpZy5wYXJzZU9wdGlvbnMgKSAmJiAhKCBrZXkgaW4gY3VzdG9tICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29uZmlndXJlKCBtZXRob2QsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMgKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAnZGF0YScsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGNvbmZpZy5wYXJzZU9wdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0aWYgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIGlzU3RhbmRhcmREZWZhdWx0S2V5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwUHJvdG90eXBlKCBQYXJlbnQucHJvdG90eXBlLCBrZXksIHZhbHVlICkgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uZmlnLnJlZ2lzdHJpZXMuZm9yRWFjaCggZnVuY3Rpb24oIHJlZ2lzdHJ5ICkge1xuXHRcdFx0XHRyZWdpc3RyeVsgbWV0aG9kIF0oIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdH0gKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAndGVtcGxhdGUnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ2NzcycsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGV4dGVuZE90aGVyTWV0aG9kcyggUGFyZW50LnByb3RvdHlwZSwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmRPdGhlck1ldGhvZHMoIHBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggISgga2V5IGluIGJsYWNrbGlzdGVkICkgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0dmFyIG1lbWJlciA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgdGhhdCBvdmVyd3JpdGVzIGEgbWV0aG9kLCB3cmFwIGl0OlxuXHRcdFx0XHRcdGlmICggdHlwZW9mIG1lbWJlciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdG1lbWJlciA9IHdyYXBQcm90b3R5cGUoIHBhcmVudCwga2V5LCBtZW1iZXIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zdGFuY2VbIGtleSBdID0gbWVtYmVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbmZpZy5yZXNldCA9IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5maWx0ZXIoIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0XHRyZXR1cm4gYy5yZXNldCAmJiBjLnJlc2V0KCByYWN0aXZlICk7XG5cdFx0XHR9ICkubWFwKCBmdW5jdGlvbiggYyApIHtcblx0XHRcdFx0cmV0dXJuIGMubmFtZTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdGNvbmZpZy5nZXRDb25zdHJ1Y3RUYXJnZXQgPSBmdW5jdGlvbiggcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdGlmICggb3B0aW9ucy5vbmNvbnN0cnVjdCApIHtcblx0XHRcdFx0Ly8gcHJldGVuZCB0aGlzIG9iamVjdCBsaXRlcmFsIGlzIHRoZSByYWN0aXZlIGluc3RhbmNlXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0b25jb25zdHJ1Y3Q6IHdyYXBQcm90b3R5cGUoIHJhY3RpdmUsICdvbmNvbnN0cnVjdCcsIG9wdGlvbnMub25jb25zdHJ1Y3QgKS5iaW5kKCByYWN0aXZlICksXG5cdFx0XHRcdFx0ZmlyZTogcmFjdGl2ZS5maXJlLmJpbmQoIHJhY3RpdmUgKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJhY3RpdmU7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gY29uZmlnO1xuXHR9KCBjc3MsIGRhdGEsIG9wdGlvbnMsIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMsIHJlZ2lzdHJpZXMsIHdyYXBQcm90b3R5cGVNZXRob2QsIGRlcHJlY2F0ZSApO1xuXG5cdC8qIHNoYXJlZC9pbnRlcnBvbGF0ZS5qcyAqL1xuXHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggY2lyY3VsYXIsIHdhcm4sIGludGVycG9sYXRvcnMsIGNvbmZpZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggZnJvbSwgdG8sIHJhY3RpdmUsIHR5cGUgKSB7XG5cdFx0XHRpZiAoIGZyb20gPT09IHRvICkge1xuXHRcdFx0XHRyZXR1cm4gc25hcCggdG8gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZSApIHtcblx0XHRcdFx0dmFyIGludGVycG9sID0gY29uZmlnLnJlZ2lzdHJpZXMuaW50ZXJwb2xhdG9ycy5maW5kKCByYWN0aXZlLCB0eXBlICk7XG5cdFx0XHRcdGlmICggaW50ZXJwb2wgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVycG9sKCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2FybiggJ01pc3NpbmcgXCInICsgdHlwZSArICdcIiBpbnRlcnBvbGF0b3IuIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiBmcm9tIFtUT0RPXScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbnRlcnBvbGF0b3JzLm51bWJlciggZnJvbSwgdG8gKSB8fCBpbnRlcnBvbGF0b3JzLmFycmF5KCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMub2JqZWN0KCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0fTtcblx0XHRjaXJjdWxhci5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuXHRcdF9fZXhwb3J0ID0gaW50ZXJwb2xhdGU7XG5cblx0XHRmdW5jdGlvbiBzbmFwKCB0byApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRvO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjaXJjdWxhciwgd2FybiwgaW50ZXJwb2xhdG9ycywgY29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYW5pbWF0ZS9BbmltYXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkYW5pbWF0ZV9BbmltYXRpb24gPSBmdW5jdGlvbiggd2FybiwgcnVubG9vcCwgaW50ZXJwb2xhdGUgKSB7XG5cblx0XHR2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIga2V5O1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0Ly8gZnJvbSBhbmQgdG9cblx0XHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHRoaXNbIGtleSBdID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGUoIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5yb290LCB0aGlzLmludGVycG9sYXRvciApO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMudGljaygpO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdHRpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxhcHNlZCwgdCwgdmFsdWUsIHRpbWVOb3csIGluZGV4LCBrZXlwYXRoO1xuXHRcdFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuXHRcdFx0XHRpZiAoIHRoaXMucnVubmluZyApIHtcblx0XHRcdFx0XHR0aW1lTm93ID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRlbGFwc2VkID0gdGltZU5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuXHRcdFx0XHRcdGlmICggZWxhcHNlZCA+PSB0aGlzLmR1cmF0aW9uICkge1xuXHRcdFx0XHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHRoaXMudG8gKTtcblx0XHRcdFx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0ZXAoIDEsIHRoaXMudG8gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuY29tcGxldGUoIHRoaXMudG8gKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm4oICdBbmltYXRpb24gd2FzIG5vdCBmb3VuZCcgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dCA9IHRoaXMuZWFzaW5nID8gdGhpcy5lYXNpbmcoIGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uICkgOiBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbjtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdG9yKCB0ICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0ZXAoIHQsIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0d2FybiggJ0FuaW1hdGlvbiB3YXMgbm90IGZvdW5kJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQW5pbWF0aW9uO1xuXHR9KCB3YXJuLCBydW5sb29wLCBpbnRlcnBvbGF0ZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2FuaW1hdGUuanMgKi9cblx0dmFyIFJhY3RpdmUkYW5pbWF0ZSA9IGZ1bmN0aW9uKCBpc0VxdWFsLCBQcm9taXNlLCBub3JtYWxpc2VLZXlwYXRoLCBhbmltYXRpb25zLCBBbmltYXRpb24gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9LFxuXHRcdFx0bm9BbmltYXRpb24gPSB7XG5cdFx0XHRcdHN0b3A6IG5vb3Bcblx0XHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBSYWN0aXZlJGFuaW1hdGUoIGtleXBhdGgsIHRvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2UsIGssIGFuaW1hdGlvbiwgYW5pbWF0aW9ucywgZWFzaW5nLCBkdXJhdGlvbiwgc3RlcCwgY29tcGxldGUsIG1ha2VWYWx1ZUNvbGxlY3RvciwgY3VycmVudFZhbHVlcywgY29sbGVjdFZhbHVlLCBkdW1teSwgZHVtbXlPcHRpb25zO1xuXHRcdFx0cHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsICkge1xuXHRcdFx0XHRmdWxmaWxQcm9taXNlID0gZnVsZmlsO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gYW5pbWF0ZSBtdWx0aXBsZSBrZXlwYXRoc1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB0byB8fCB7fTtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0YW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgdGhlIGBzdGVwYCBhbmQgYGNvbXBsZXRlYCBoYW5kbGVycywgYXMgdGhleSB3aWxsXG5cdFx0XHRcdC8vIHJ1biBmb3IgZWFjaCBhbmltYXRpb24hIFNvIGluc3RlYWQgd2UnbGwgc3RvcmUgdGhlIGhhbmRsZXJzIGFuZCBjcmVhdGVcblx0XHRcdFx0Ly8gb3VyIG93bi4uLlxuXHRcdFx0XHRzdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRjdXJyZW50VmFsdWVzID0ge307XG5cdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gbnVsbDtcblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gbnVsbDtcblx0XHRcdFx0XHRtYWtlVmFsdWVDb2xsZWN0b3IgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGsgaW4ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGguaGFzT3duUHJvcGVydHkoIGsgKSApIHtcblx0XHRcdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdFx0Y29sbGVjdFZhbHVlID0gbWFrZVZhbHVlQ29sbGVjdG9yKCBrICk7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGlmICggc3RlcCApIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBjb2xsZWN0VmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZSA/IGNvbGxlY3RWYWx1ZSA6IG5vb3A7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGFuaW1hdGUoIHRoaXMsIGssIGtleXBhdGhbIGsgXSwgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiwgdG8gZmFjaWxpdGF0ZSBzdGVwL2NvbXBsZXRlXG5cdFx0XHRcdC8vIGNhbGxiYWNrcywgYW5kIFByb21pc2UgZnVsZmlsbWVudFxuXHRcdFx0XHRkdW1teU9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggc3RlcCApIHtcblx0XHRcdFx0XHRkdW1teU9wdGlvbnMuc3RlcCA9IGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdFx0c3RlcCggdCwgY3VycmVudFZhbHVlcyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGUoIHQsIGN1cnJlbnRWYWx1ZXMgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHVtbXlPcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblx0XHRcdFx0ZHVtbXkgPSBhbmltYXRlKCB0aGlzLCBudWxsLCBudWxsLCBkdW1teU9wdGlvbnMgKTtcblx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBkdW1teSApO1xuXHRcdFx0XHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uO1xuXHRcdFx0XHRcdHdoaWxlICggYW5pbWF0aW9uID0gYW5pbWF0aW9ucy5wb3AoKSApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggZHVtbXkgKSB7XG5cdFx0XHRcdFx0XHRkdW1teS5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1cblx0XHRcdC8vIGFuaW1hdGUgYSBzaW5nbGUga2V5cGF0aFxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRpZiAoIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRlKCB0aGlzLCBrZXlwYXRoLCB0bywgb3B0aW9ucyApO1xuXHRcdFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGFuaW1hdGUoIHJvb3QsIGtleXBhdGgsIHRvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGVhc2luZywgZHVyYXRpb24sIGFuaW1hdGlvbiwgZnJvbTtcblx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0ZnJvbSA9IHJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2FuY2VsIGFueSBleGlzdGluZyBhbmltYXRpb25cblx0XHRcdC8vIFRPRE8gd2hhdCBhYm91dCB1cHN0cmVhbS9kb3duc3RyZWFtIGtleXBhdGhzP1xuXHRcdFx0YW5pbWF0aW9ucy5hYm9ydCgga2V5cGF0aCwgcm9vdCApO1xuXHRcdFx0Ly8gZG9uJ3QgYm90aGVyIGFuaW1hdGluZyB2YWx1ZXMgdGhhdCBzdGF5IHRoZSBzYW1lXG5cdFx0XHRpZiAoIGlzRXF1YWwoIGZyb20sIHRvICkgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5jb21wbGV0ZSApIHtcblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlKCBvcHRpb25zLnRvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vQW5pbWF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZWFzaW5nIGZ1bmN0aW9uXG5cdFx0XHRpZiAoIG9wdGlvbnMuZWFzaW5nICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlYXNpbmcgPSByb290LmVhc2luZ1sgb3B0aW9ucy5lYXNpbmcgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBlYXNpbmcgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZHVyYXRpb25cblx0XHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gNDAwIDogb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdC8vIFRPRE8gc3RvcmUga2V5cywgdXNlIGFuIGludGVybmFsIHNldCBtZXRob2Rcblx0XHRcdGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oIHtcblx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcblx0XHRcdFx0ZnJvbTogZnJvbSxcblx0XHRcdFx0dG86IHRvLFxuXHRcdFx0XHRyb290OiByb290LFxuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuXHRcdFx0XHRpbnRlcnBvbGF0b3I6IG9wdGlvbnMuaW50ZXJwb2xhdG9yLFxuXHRcdFx0XHQvLyBUT0RPIHdyYXAgY2FsbGJhY2tzIGlmIG5lY2Vzc2FyeSwgdG8gdXNlIGluc3RhbmNlIGFzIGNvbnRleHRcblx0XHRcdFx0c3RlcDogb3B0aW9ucy5zdGVwLFxuXHRcdFx0XHRjb21wbGV0ZTogb3B0aW9ucy5jb21wbGV0ZVxuXHRcdFx0fSApO1xuXHRcdFx0YW5pbWF0aW9ucy5hZGQoIGFuaW1hdGlvbiApO1xuXHRcdFx0cm9vdC5fYW5pbWF0aW9ucy5wdXNoKCBhbmltYXRpb24gKTtcblx0XHRcdHJldHVybiBhbmltYXRpb247XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggaXNFcXVhbCwgUHJvbWlzZSwgbm9ybWFsaXNlS2V5cGF0aCwgYW5pbWF0aW9ucywgUmFjdGl2ZSRhbmltYXRlX0FuaW1hdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRkZXRhY2ggPSBmdW5jdGlvbiggSG9vaywgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIGRldGFjaEhvb2sgPSBuZXcgSG9vayggJ2RldGFjaCcgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRkZXRhY2goKSB7XG5cdFx0XHRpZiAoIHRoaXMuZGV0YWNoZWQgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmVsICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRldGFjaGVkID0gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdGRldGFjaEhvb2suZmlyZSggdGhpcyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kID0gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdXRpbHMvbWF0Y2hlcy5qcyAqL1xuXHR2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApIHtcblxuXHRcdHZhciBtYXRjaGVzLCBkaXYsIG1ldGhvZE5hbWVzLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgaSwgaiwgbWFrZUZ1bmN0aW9uO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0bWF0Y2hlcyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdiA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0XHRtZXRob2ROYW1lcyA9IFtcblx0XHRcdFx0J21hdGNoZXMnLFxuXHRcdFx0XHQnbWF0Y2hlc1NlbGVjdG9yJ1xuXHRcdFx0XTtcblx0XHRcdG1ha2VGdW5jdGlvbiA9IGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlWyBtZXRob2ROYW1lIF0oIHNlbGVjdG9yICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0aSA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICYmICFtYXRjaGVzICkge1xuXHRcdFx0XHR1bnByZWZpeGVkID0gbWV0aG9kTmFtZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBkaXZbIHVucHJlZml4ZWQgXSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKCB1bnByZWZpeGVkICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aiA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0cHJlZml4ZWQgPSB2ZW5kb3JzWyBpIF0gKyB1bnByZWZpeGVkLnN1YnN0ciggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXZbIHByZWZpeGVkIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24oIHByZWZpeGVkICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSUU4Li4uXG5cdFx0XHRpZiAoICFtYXRjaGVzICkge1xuXHRcdFx0XHRtYXRjaGVzID0gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHZhciBub2RlcywgcGFyZW50Tm9kZSwgaTtcblx0XHRcdFx0XHRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdGlmICggIXBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBlbXB0eSBkdW1teSA8ZGl2PlxuXHRcdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRpdjtcblx0XHRcdFx0XHRcdG5vZGUgPSBub2RlLmNsb25lTm9kZSgpO1xuXHRcdFx0XHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBub2RlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGVzID0gcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVzWyBpIF0gPT09IG5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9KCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvdGVzdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3Rlc3QgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbSwgbm9EaXJ0eSApIHtcblx0XHRcdHZhciBpdGVtTWF0Y2hlcyA9IHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAhdGhpcy5zZWxlY3RvciB8fCBpdGVtLm5hbWUgPT09IHRoaXMuc2VsZWN0b3IgOiBtYXRjaGVzKCBpdGVtLm5vZGUsIHRoaXMuc2VsZWN0b3IgKTtcblx0XHRcdGlmICggaXRlbU1hdGNoZXMgKSB7XG5cdFx0XHRcdHRoaXMucHVzaCggaXRlbS5ub2RlIHx8IGl0ZW0uaW5zdGFuY2UgKTtcblx0XHRcdFx0aWYgKCAhbm9EaXJ0eSApIHtcblx0XHRcdFx0XHR0aGlzLl9tYWtlRGlydHkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9jYW5jZWwuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9jYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHNlbGVjdG9yLCBpbmRleDtcblx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX3Jvb3RbIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAnbGl2ZUNvbXBvbmVudFF1ZXJpZXMnIDogJ2xpdmVRdWVyaWVzJyBdO1xuXHRcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvcjtcblx0XHRpbmRleCA9IGxpdmVRdWVyaWVzLmluZGV4T2YoIHNlbGVjdG9yICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydEJ5SXRlbVBvc2l0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhbmNlc3RyeUEsIGFuY2VzdHJ5Qiwgb2xkZXN0QSwgb2xkZXN0QiwgbXV0dWFsQW5jZXN0b3IsIGluZGV4QSwgaW5kZXhCLCBmcmFnbWVudHMsIGZyYWdtZW50QSwgZnJhZ21lbnRCO1xuXHRcdFx0YW5jZXN0cnlBID0gZ2V0QW5jZXN0cnkoIGEuY29tcG9uZW50IHx8IGEuX3JhY3RpdmUucHJveHkgKTtcblx0XHRcdGFuY2VzdHJ5QiA9IGdldEFuY2VzdHJ5KCBiLmNvbXBvbmVudCB8fCBiLl9yYWN0aXZlLnByb3h5ICk7XG5cdFx0XHRvbGRlc3RBID0gYW5jZXN0cnlBWyBhbmNlc3RyeUEubGVuZ3RoIC0gMSBdO1xuXHRcdFx0b2xkZXN0QiA9IGFuY2VzdHJ5QlsgYW5jZXN0cnlCLmxlbmd0aCAtIDEgXTtcblx0XHRcdC8vIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgYm90aCBhbmNlc3RyaWVzIGFzIGxvbmcgYXMgdGhleSBhcmUgaWRlbnRpY2FsXG5cdFx0XHQvLyAtIHRoZSBmaW5hbCBvbmUgcmVtb3ZlZCBpcyB0aGUgY2xvc2VzdCBtdXR1YWwgYW5jZXN0b3Jcblx0XHRcdHdoaWxlICggb2xkZXN0QSAmJiBvbGRlc3RBID09PSBvbGRlc3RCICkge1xuXHRcdFx0XHRhbmNlc3RyeUEucG9wKCk7XG5cdFx0XHRcdGFuY2VzdHJ5Qi5wb3AoKTtcblx0XHRcdFx0bXV0dWFsQW5jZXN0b3IgPSBvbGRlc3RBO1xuXHRcdFx0XHRvbGRlc3RBID0gYW5jZXN0cnlBWyBhbmNlc3RyeUEubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRvbGRlc3RCID0gYW5jZXN0cnlCWyBhbmNlc3RyeUIubGVuZ3RoIC0gMSBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgbXV0dWFsIGFuY2VzdG9yLCB3ZSBjYW4gZmluZCB3aGljaCBpcyBlYXJsaWVzdFxuXHRcdFx0b2xkZXN0QSA9IG9sZGVzdEEuY29tcG9uZW50IHx8IG9sZGVzdEE7XG5cdFx0XHRvbGRlc3RCID0gb2xkZXN0Qi5jb21wb25lbnQgfHwgb2xkZXN0Qjtcblx0XHRcdGZyYWdtZW50QSA9IG9sZGVzdEEucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRmcmFnbWVudEIgPSBvbGRlc3RCLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gaWYgYm90aCBpdGVtcyBzaGFyZSBhIHBhcmVudCBmcmFnbWVudCwgb3VyIGpvYiBpcyBlYXN5XG5cdFx0XHRpZiAoIGZyYWdtZW50QSA9PT0gZnJhZ21lbnRCICkge1xuXHRcdFx0XHRpbmRleEEgPSBmcmFnbWVudEEuaXRlbXMuaW5kZXhPZiggb2xkZXN0QSApO1xuXHRcdFx0XHRpbmRleEIgPSBmcmFnbWVudEIuaXRlbXMuaW5kZXhPZiggb2xkZXN0QiApO1xuXHRcdFx0XHQvLyBpZiBpdCdzIHRoZSBzYW1lIGluZGV4LCBpdCBtZWFucyBvbmUgY29udGFpbnMgdGhlIG90aGVyLFxuXHRcdFx0XHQvLyBzbyB3ZSBzZWUgd2hpY2ggaGFzIHRoZSBsb25nZXN0IGFuY2VzdHJ5XG5cdFx0XHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBtdXR1YWwgYW5jZXN0b3IgaXMgYSBzZWN0aW9uLCB3ZSBmaXJzdCB0ZXN0IHRvIHNlZSB3aGljaCBzZWN0aW9uXG5cdFx0XHQvLyBmcmFnbWVudCBjb21lcyBmaXJzdFxuXHRcdFx0aWYgKCBmcmFnbWVudHMgPSBtdXR1YWxBbmNlc3Rvci5mcmFnbWVudHMgKSB7XG5cdFx0XHRcdGluZGV4QSA9IGZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudEEgKTtcblx0XHRcdFx0aW5kZXhCID0gZnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50QiApO1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQW4gdW5leHBlY3RlZCBjb25kaXRpb24gd2FzIG1ldCB3aGlsZSBjb21wYXJpbmcgdGhlIHBvc2l0aW9uIG9mIHR3byBjb21wb25lbnRzLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIScgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFyZW50KCBpdGVtICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50O1xuXHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudCA9IGl0ZW0ucGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcblx0XHRcdH1cblx0XHRcdGlmICggaXRlbS5jb21wb25lbnQgJiYgKCBwYXJlbnRGcmFnbWVudCA9IGl0ZW0uY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBbmNlc3RyeSggaXRlbSApIHtcblx0XHRcdHZhciBhbmNlc3RyeSwgYW5jZXN0b3I7XG5cdFx0XHRhbmNlc3RyeSA9IFsgaXRlbSBdO1xuXHRcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoIGl0ZW0gKTtcblx0XHRcdHdoaWxlICggYW5jZXN0b3IgKSB7XG5cdFx0XHRcdGFuY2VzdHJ5LnB1c2goIGFuY2VzdG9yICk7XG5cdFx0XHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KCBhbmNlc3RvciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFuY2VzdHJ5O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnRCeURvY3VtZW50UG9zaXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24oIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggbm9kZSwgb3RoZXJOb2RlICkge1xuXHRcdFx0dmFyIGJpdG1hc2s7XG5cdFx0XHRpZiAoIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XG5cdFx0XHRcdGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBvdGhlck5vZGUgKTtcblx0XHRcdFx0cmV0dXJuIGJpdG1hc2sgJiAyID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuXHRcdFx0Ly8gY29tcGFyaW5nIGNvbXBvbmVudCBwb3NpdGlvbnNcblx0XHRcdHJldHVybiBzb3J0QnlJdGVtUG9zaXRpb24oIG5vZGUsIG90aGVyTm9kZSApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0ID0gZnVuY3Rpb24oIHNvcnRCeURvY3VtZW50UG9zaXRpb24sIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc29ydCggdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IHNvcnRCeUl0ZW1Qb3NpdGlvbiA6IHNvcnRCeURvY3VtZW50UG9zaXRpb24gKTtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeURvY3VtZW50UG9zaXRpb24sIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L2RpcnR5LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfZGlydHkgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0aWYgKCAhdGhpcy5fZGlydHkgKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gT25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQsIGVuc3VyZSB0aGUgcXVlcnlcblx0XHRcdFx0Ly8gaXMgY29ycmVjdGx5IG9yZGVyZWRcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMkMC5fc29ydCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvcmVtb3ZlLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfcmVtb3ZlID0gZnVuY3Rpb24oIG5vZGVPckNvbXBvbmVudCApIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBub2RlT3JDb21wb25lbnQuaW5zdGFuY2UgOiBub2RlT3JDb21wb25lbnQgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdHRoaXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L19tYWtlUXVlcnkuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnRpZXMsIHRlc3QsIGNhbmNlbCwgc29ydCwgZGlydHksIHJlbW92ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBtYWtlUXVlcnkoIHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5ICkge1xuXHRcdFx0dmFyIHF1ZXJ5ID0gW107XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBxdWVyeSwge1xuXHRcdFx0XHRzZWxlY3Rvcjoge1xuXHRcdFx0XHRcdHZhbHVlOiBzZWxlY3RvclxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGxpdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2lzQ29tcG9uZW50UXVlcnk6IHtcblx0XHRcdFx0XHR2YWx1ZTogaXNDb21wb25lbnRRdWVyeVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfdGVzdDoge1xuXHRcdFx0XHRcdHZhbHVlOiB0ZXN0XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGlmICggIWxpdmUgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMoIHF1ZXJ5LCB7XG5cdFx0XHRcdGNhbmNlbDoge1xuXHRcdFx0XHRcdHZhbHVlOiBjYW5jZWxcblx0XHRcdFx0fSxcblx0XHRcdFx0X3Jvb3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogcmFjdGl2ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfc29ydDoge1xuXHRcdFx0XHRcdHZhbHVlOiBzb3J0XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9tYWtlRGlydHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogZGlydHlcblx0XHRcdFx0fSxcblx0XHRcdFx0X3JlbW92ZToge1xuXHRcdFx0XHRcdHZhbHVlOiByZW1vdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2RpcnR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGZhbHNlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBkZWZpbmVQcm9wZXJ0aWVzLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfdGVzdCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2NhbmNlbCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnQsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9kaXJ0eSwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3JlbW92ZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZEFsbCA9IGZ1bmN0aW9uKCBtYWtlUXVlcnkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgZmFsc2UgKTtcblx0XHRcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuXHRcdFx0Ly8gaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCBxdWVyeS5saXZlICkge1xuXHRcdFx0XHRsaXZlUXVlcmllcy5wdXNoKCBzZWxlY3RvciApO1xuXHRcdFx0XHRsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXSA9IHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIG1ha2VRdWVyeSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZUNvbXBvbmVudFF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgdHJ1ZSApO1xuXHRcdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG5cdFx0XHQvLyBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzLnB1c2goIHNlbGVjdG9yICk7XG5cdFx0XHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB1dGlscy9nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuanMgKi9cblx0dmFyIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBzdGFyTWFwcyA9IHt9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBrZXlwYXRoIHN1Y2ggYXMgJ2Zvby5iYXIuYmF6JywgYW5kIHJldHVybnNcblx0XHQvLyBhbGwgdGhlIHZhcmlhbnRzIG9mIHRoYXQga2V5cGF0aCB0aGF0IGluY2x1ZGUgYSB3aWxkY2FyZCBpbiBwbGFjZVxuXHRcdC8vIG9mIGEga2V5LCBzdWNoIGFzICdmb28uYmFyLionLCAnZm9vLiouYmF6JywgJ2Zvby4qLionIGFuZCBzbyBvbi5cblx0XHQvLyBUaGVzZSBhcmUgdGhlbiBjaGVja2VkIGFnYWluc3QgdGhlIGRlcGVuZGFudHMgbWFwIChyYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwKVxuXHRcdC8vIHRvIHNlZSBpZiBhbnkgcGF0dGVybiBvYnNlcnZlcnMgYXJlIGRvd25zdHJlYW0gb2Ygb25lIG9yIG1vcmUgb2Zcblx0XHQvLyB0aGVzZSB3aWxkY2FyZCBrZXlwYXRocyAoZS5nLiAnZm9vLmJhci4qLnN0YXR1cycpXG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCBpLCByZXN1bHQsIHdpbGRjYXJkS2V5cGF0aDtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdGlmICggISggc3Rhck1hcCA9IHN0YXJNYXBzWyBrZXlzLmxlbmd0aCBdICkgKSB7XG5cdFx0XHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKCBrZXlzLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggc3RhciwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHN0YXIgPyAnKicgOiBrZXlzWyBpIF07XG5cdFx0XHR9O1xuXHRcdFx0aSA9IHN0YXJNYXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdHdpbGRjYXJkS2V5cGF0aCA9IHN0YXJNYXBbIGkgXS5tYXAoIG1hcHBlciApLmpvaW4oICcuJyApO1xuXHRcdFx0XHRpZiAoICFyZXN1bHQuaGFzT3duUHJvcGVydHkoIHdpbGRjYXJkS2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCB3aWxkY2FyZEtleXBhdGggKTtcblx0XHRcdFx0XHRyZXN1bHRbIHdpbGRjYXJkS2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuXHRcdC8vIGEgZ2l2ZW4gbnVtYmVyIC0gZS5nLiBmb3IgdHdvLCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zIGFyZVxuXHRcdC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cblx0XHQvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuXHRcdGZ1bmN0aW9uIGdldFN0YXJNYXAoIG51bSApIHtcblx0XHRcdHZhciBvbmVzID0gJycsXG5cdFx0XHRcdG1heCwgYmluYXJ5LCBzdGFyTWFwLCBtYXBwZXIsIGk7XG5cdFx0XHRpZiAoICFzdGFyTWFwc1sgbnVtIF0gKSB7XG5cdFx0XHRcdHN0YXJNYXAgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBvbmVzLmxlbmd0aCA8IG51bSApIHtcblx0XHRcdFx0XHRvbmVzICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4ID0gcGFyc2VJbnQoIG9uZXMsIDIgKTtcblx0XHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIGRpZ2l0ICkge1xuXHRcdFx0XHRcdHJldHVybiBkaWdpdCA9PT0gJzEnO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8PSBtYXg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKCAyICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBiaW5hcnkubGVuZ3RoIDwgbnVtICkge1xuXHRcdFx0XHRcdFx0YmluYXJ5ID0gJzAnICsgYmluYXJ5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFyTWFwWyBpIF0gPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoIGJpbmFyeSwgbWFwcGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Rhck1hcHNbIG51bSBdID0gc3Rhck1hcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGFyTWFwc1sgbnVtIF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9maXJlRXZlbnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCA9IGZ1bmN0aW9uKCBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBmaXJlRXZlbnQoIHJhY3RpdmUsIGV2ZW50TmFtZSApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdGlmICggIWV2ZW50TmFtZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhb3B0aW9ucy5ldmVudCApIHtcblx0XHRcdFx0b3B0aW9ucy5ldmVudCA9IHtcblx0XHRcdFx0XHRuYW1lOiBldmVudE5hbWUsXG5cdFx0XHRcdFx0Y29udGV4dDogcmFjdGl2ZS5kYXRhLFxuXHRcdFx0XHRcdGtleXBhdGg6ICcnLFxuXHRcdFx0XHRcdC8vIHVudGlsIGV2ZW50IG5vdCBpbmNsdWRlZCBhcyBhcmd1bWVudCBkZWZhdWx0XG5cdFx0XHRcdFx0X25vQXJnOiB0cnVlXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLmV2ZW50Lm5hbWUgPSBldmVudE5hbWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXZlbnROYW1lcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyggZXZlbnROYW1lICk7XG5cdFx0XHRmaXJlRXZlbnRBcyggcmFjdGl2ZSwgZXZlbnROYW1lcywgb3B0aW9ucy5ldmVudCwgb3B0aW9ucy5hcmdzLCB0cnVlICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGZpcmVFdmVudEFzKCByYWN0aXZlLCBldmVudE5hbWVzLCBldmVudCwgYXJncyApIHtcblx0XHRcdHZhciBpbml0aWFsRmlyZSA9IGFyZ3VtZW50c1sgNCBdO1xuXHRcdFx0aWYgKCBpbml0aWFsRmlyZSA9PT0gdm9pZCAwIClcblx0XHRcdFx0aW5pdGlhbEZpcmUgPSBmYWxzZTtcblx0XHRcdHZhciBzdWJzY3JpYmVycywgaSwgYnViYmxlID0gdHJ1ZTtcblx0XHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZXZlbnQgPSBldmVudDtcblx0XHRcdH1cblx0XHRcdGZvciAoIGkgPSBldmVudE5hbWVzLmxlbmd0aDsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRcdHN1YnNjcmliZXJzID0gcmFjdGl2ZS5fc3Vic1sgZXZlbnROYW1lc1sgaSBdIF07XG5cdFx0XHRcdGlmICggc3Vic2NyaWJlcnMgKSB7XG5cdFx0XHRcdFx0YnViYmxlID0gbm90aWZ5U3Vic2NyaWJlcnMoIHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncyApICYmIGJ1YmJsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBldmVudCApIHtcblx0XHRcdFx0ZGVsZXRlIHJhY3RpdmUuZXZlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJhY3RpdmUuX3BhcmVudCAmJiBidWJibGUgKSB7XG5cdFx0XHRcdGlmICggaW5pdGlhbEZpcmUgJiYgcmFjdGl2ZS5jb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0dmFyIGZ1bGxOYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSArICcuJyArIGV2ZW50TmFtZXNbIGV2ZW50TmFtZXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdGV2ZW50TmFtZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGZ1bGxOYW1lICk7XG5cdFx0XHRcdFx0aWYgKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LmNvbXBvbmVudCA9IHJhY3RpdmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZpcmVFdmVudEFzKCByYWN0aXZlLl9wYXJlbnQsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5U3Vic2NyaWJlcnMoIHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncyApIHtcblx0XHRcdHZhciBvcmlnaW5hbEV2ZW50ID0gbnVsbCxcblx0XHRcdFx0c3RvcEV2ZW50ID0gZmFsc2U7XG5cdFx0XHRpZiAoIGV2ZW50ICYmICFldmVudC5fbm9BcmcgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIGV2ZW50IF0uY29uY2F0KCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzWyBpIF0uYXBwbHkoIHJhY3RpdmUsIGFyZ3MgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0c3RvcEV2ZW50ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBldmVudCAmJiAhZXZlbnQuX25vQXJnICYmIHN0b3BFdmVudCAmJiAoIG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbCApICkge1xuXHRcdFx0XHRvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0ICYmIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0b3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24gJiYgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhc3RvcEV2ZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpcmUuanMgKi9cblx0dmFyIFJhY3RpdmUkZmlyZSA9IGZ1bmN0aW9uKCBmaXJlRXZlbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaXJlKCBldmVudE5hbWUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdFx0YXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApXG5cdFx0XHR9O1xuXHRcdFx0ZmlyZUV2ZW50KCB0aGlzLCBldmVudE5hbWUsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9nZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkZ2V0ID0gZnVuY3Rpb24oIG5vcm1hbGlzZUtleXBhdGgsIHJlc29sdmVSZWYgKSB7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdGNhcHR1cmU6IHRydWVcblx0XHR9O1xuXHRcdC8vIHRvcC1sZXZlbCBjYWxscyBzaG91bGQgYmUgaW50ZXJjZXB0ZWRcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRnZXQoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGgsIG9wdGlvbnMgKTtcblx0XHRcdC8vIENyZWF0ZSBpbnRlci1jb21wb25lbnQgYmluZGluZywgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy5fcGFyZW50ICYmICF0aGlzLmlzb2xhdGVkICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVSZWYoIHRoaXMsIGtleXBhdGgsIHRoaXMuZnJhZ21lbnQgKSApIHtcblx0XHRcdFx0XHQvLyBjcmVhdGVzIGJpbmRpbmcgYXMgc2lkZS1lZmZlY3QsIGlmIGFwcHJvcHJpYXRlXG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZUtleXBhdGgsIHJlc29sdmVSZWYgKTtcblxuXHQvKiB1dGlscy9nZXRFbGVtZW50LmpzICovXG5cdHZhciBnZXRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudCggaW5wdXQgKSB7XG5cdFx0dmFyIG91dHB1dDtcblx0XHRpZiAoICFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhZG9jdW1lbnQgfHwgIWlucHV0ICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdC8vIFdlIGFscmVhZHkgaGF2ZSBhIERPTSBub2RlIC0gbm8gd29yayB0byBkby4gKER1Y2sgdHlwaW5nIGFsZXJ0ISlcblx0XHRpZiAoIGlucHV0Lm5vZGVUeXBlICkge1xuXHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdH1cblx0XHQvLyBHZXQgbm9kZSBmcm9tIHN0cmluZ1xuXHRcdGlmICggdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIHRyeSBJRCBmaXJzdFxuXHRcdFx0b3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlucHV0ICk7XG5cdFx0XHQvLyB0aGVuIGFzIHNlbGVjdG9yLCBpZiBwb3NzaWJsZVxuXHRcdFx0aWYgKCAhb3V0cHV0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgKSB7XG5cdFx0XHRcdG91dHB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGlucHV0ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBkaWQgaXQgd29yaz9cblx0XHRcdGlmICggb3V0cHV0ICYmIG91dHB1dC5ub2RlVHlwZSApIHtcblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNvbGxlY3Rpb24gKGpRdWVyeSwgWmVwdG8gZXRjKSwgZXh0cmFjdCB0aGUgZmlyc3QgaXRlbVxuXHRcdGlmICggaW5wdXRbIDAgXSAmJiBpbnB1dFsgMCBdLm5vZGVUeXBlICkge1xuXHRcdFx0cmV0dXJuIGlucHV0WyAwIF07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2luc2VydC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRpbnNlcnQgPSBmdW5jdGlvbiggSG9vaywgZ2V0RWxlbWVudCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgaW5zZXJ0SG9vayA9IG5ldyBIb29rKCAnaW5zZXJ0JyApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gUmFjdGl2ZSRpbnNlcnQoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0aWYgKCAhdGhpcy5mcmFnbWVudC5yZW5kZXJlZCApIHtcblx0XHRcdFx0Ly8gVE9ETyBjcmVhdGUsIGFuZCBsaW5rIHRvLCBkb2N1bWVudGF0aW9uIGV4cGxhaW5pbmcgdGhpc1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgQVBJIGhhcyBjaGFuZ2VkIC0geW91IG11c3QgY2FsbCBgcmFjdGl2ZS5yZW5kZXIodGFyZ2V0WywgYW5jaG9yXSlgIHRvIHJlbmRlciB5b3VyIFJhY3RpdmUgaW5zdGFuY2UuIE9uY2UgcmVuZGVyZWQgeW91IGNhbiB1c2UgYHJhY3RpdmUuaW5zZXJ0KClgLicgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9IGdldEVsZW1lbnQoIHRhcmdldCApO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgbnVsbDtcblx0XHRcdGlmICggIXRhcmdldCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IG11c3Qgc3BlY2lmeSBhIHZhbGlkIHRhcmdldCB0byBpbnNlcnQgaW50bycgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZGV0YWNoKCksIGFuY2hvciApO1xuXHRcdFx0dGhpcy5lbCA9IHRhcmdldDtcblx0XHRcdCggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAoIHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSApICkucHVzaCggdGhpcyApO1xuXHRcdFx0dGhpcy5kZXRhY2hlZCA9IG51bGw7XG5cdFx0XHRmaXJlSW5zZXJ0SG9vayggdGhpcyApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlSW5zZXJ0SG9vayggcmFjdGl2ZSApIHtcblx0XHRcdGluc2VydEhvb2suZmlyZSggcmFjdGl2ZSApO1xuXHRcdFx0cmFjdGl2ZS5maW5kQWxsQ29tcG9uZW50cyggJyonICkuZm9yRWFjaCggZnVuY3Rpb24oIGNoaWxkICkge1xuXHRcdFx0XHRmaXJlSW5zZXJ0SG9vayggY2hpbGQuaW5zdGFuY2UgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBnZXRFbGVtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvbWVyZ2UuanMgKi9cblx0dmFyIFJhY3RpdmUkbWVyZ2UgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNBcnJheSwgbm9ybWFsaXNlS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG1lcmdlKCBrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBjdXJyZW50QXJyYXksIHByb21pc2U7XG5cdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0Y3VycmVudEFycmF5ID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHQvLyBJZiBlaXRoZXIgdGhlIGV4aXN0aW5nIHZhbHVlIG9yIHRoZSBuZXcgdmFsdWUgaXNuJ3QgYW5cblx0XHRcdC8vIGFycmF5LCBqdXN0IGRvIGEgcmVndWxhciBzZXRcblx0XHRcdGlmICggIWlzQXJyYXkoIGN1cnJlbnRBcnJheSApIHx8ICFpc0FycmF5KCBhcnJheSApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXQoIGtleXBhdGgsIGFycmF5LCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIE1hbmFnZSB0cmFuc2l0aW9uc1xuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHRoaXMudmlld21vZGVsLm1lcmdlKCBrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zICk7XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0Ly8gYXR0YWNoIGNhbGxiYWNrIGFzIGZ1bGZpbG1lbnQgaGFuZGxlciwgaWYgc3BlY2lmaWVkXG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBpc0FycmF5LCBub3JtYWxpc2VLZXlwYXRoICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9PYnNlcnZlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX09ic2VydmVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXHRcdFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG5cdFx0fTtcblx0XHRPYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW1tZWRpYXRlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5jYWxsYmFjay5jYWxsKCB0aGlzLmNvbnRleHQsIHRoaXMudmFsdWUsIHRoaXMub2xkVmFsdWUsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIE9ic2VydmVyO1xuXHR9KCBydW5sb29wLCBpc0VxdWFsICk7XG5cblx0Lyogc2hhcmVkL2dldE1hdGNoaW5nS2V5cGF0aHMuanMgKi9cblx0dmFyIGdldE1hdGNoaW5nS2V5cGF0aHMgPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRNYXRjaGluZ0tleXBhdGhzKCByYWN0aXZlLCBwYXR0ZXJuICkge1xuXHRcdFx0dmFyIGtleXMsIGtleSwgbWF0Y2hpbmdLZXlwYXRocztcblx0XHRcdGtleXMgPSBwYXR0ZXJuLnNwbGl0KCAnLicgKTtcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBbICcnIF07XG5cdFx0XHR3aGlsZSAoIGtleSA9IGtleXMuc2hpZnQoKSApIHtcblx0XHRcdFx0aWYgKCBrZXkgPT09ICcqJyApIHtcblx0XHRcdFx0XHQvLyBleHBhbmQgdG8gZmluZCBhbGwgdmFsaWQgY2hpbGQga2V5cGF0aHNcblx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5yZWR1Y2UoIGV4cGFuZCwgW10gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG1hdGNoaW5nS2V5cGF0aHNbIDAgXSA9PT0gJycgKSB7XG5cdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXlcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHNbIDAgXSA9IGtleTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMubWFwKCBjb25jYXRlbmF0ZSgga2V5ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXG5cdFx0XHRmdW5jdGlvbiBleHBhbmQoIG1hdGNoaW5nS2V5cGF0aHMsIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwga2V5LCBjaGlsZEtleXBhdGg7XG5cdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsga2V5cGF0aCBdID8gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsga2V5cGF0aCBdLmdldCgpIDogcmFjdGl2ZS5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0Zm9yICgga2V5IGluIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggdmFsdWUuaGFzT3duUHJvcGVydHkoIGtleSApICYmICgga2V5ICE9PSAnX3JhY3RpdmUnIHx8ICFpc0FycmF5KCB2YWx1ZSApICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBmb3IgYmVuZWZpdCBvZiBJRThcblx0XHRcdFx0XHRcdGNoaWxkS2V5cGF0aCA9IGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocy5wdXNoKCBjaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvbmNhdGVuYXRlKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4ga2V5cGF0aCA/IGtleXBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvZ2V0UGF0dGVybi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX2dldFBhdHRlcm4gPSBmdW5jdGlvbiggZ2V0TWF0Y2hpbmdLZXlwYXRocyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRQYXR0ZXJuKCByYWN0aXZlLCBwYXR0ZXJuICkge1xuXHRcdFx0dmFyIG1hdGNoaW5nS2V5cGF0aHMsIHZhbHVlcztcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBnZXRNYXRjaGluZ0tleXBhdGhzKCByYWN0aXZlLCBwYXR0ZXJuICk7XG5cdFx0XHR2YWx1ZXMgPSB7fTtcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gcmFjdGl2ZS5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0fTtcblx0fSggZ2V0TWF0Y2hpbmdLZXlwYXRocyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvUGF0dGVybk9ic2VydmVyLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfUGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzRXF1YWwsIGdldFBhdHRlcm4gKSB7XG5cblx0XHR2YXIgUGF0dGVybk9ic2VydmVyLCB3aWxkY2FyZCA9IC9cXCovLFxuXHRcdFx0c2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0UGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdHRoaXMucmVnZXggPSBuZXcgUmVnRXhwKCAnXicgKyBrZXlwYXRoLnJlcGxhY2UoIC9cXC4vZywgJ1xcXFwuJyApLnJlcGxhY2UoIC9cXCovZywgJyhbXlxcXFwuXSspJyApICsgJyQnICk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IHt9O1xuXHRcdFx0aWYgKCB0aGlzLmRlZmVyICkge1xuXHRcdFx0XHR0aGlzLnByb3hpZXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuXHRcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuXHRcdH07XG5cdFx0UGF0dGVybk9ic2VydmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBpbW1lZGlhdGUgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMsIGtleXBhdGg7XG5cdFx0XHRcdHZhbHVlcyA9IGdldFBhdHRlcm4oIHRoaXMucm9vdCwgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW1tZWRpYXRlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIHZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGlmICggdmFsdWVzLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZXM7XG5cdFx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IGdldFBhdHRlcm4oIHRoaXMucm9vdCwga2V5cGF0aCApO1xuXHRcdFx0XHRcdGZvciAoIGtleXBhdGggaW4gdmFsdWVzICkge1xuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZXMuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGFycmF5IG11dGF0aW9uIHNob3VsZCBub3QgdHJpZ2dlciBgYXJyYXkuKmBcblx0XHRcdFx0Ly8gcGF0dGVybiBvYnNlcnZlciB3aXRoIGBhcnJheS5sZW5ndGhgXG5cdFx0XHRcdGlmICggdGhpcy5yb290LnZpZXdtb2RlbC5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5nZXRQcm94eSgga2V5cGF0aCApLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yZWFsbHlVcGRhdGUoIGtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRyZWFsbHlVcGRhdGU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleXMsIGFyZ3M7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gKSB8fCAhdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRrZXlzID0gc2xpY2UuY2FsbCggdGhpcy5yZWdleC5leGVjKCBrZXlwYXRoICksIDEgKTtcblx0XHRcdFx0XHRhcmdzID0gW1xuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHR0aGlzLnZhbHVlc1sga2V5cGF0aCBdLFxuXHRcdFx0XHRcdFx0a2V5cGF0aFxuXHRcdFx0XHRcdF0uY29uY2F0KCBrZXlzICk7XG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFjay5hcHBseSggdGhpcy5jb250ZXh0LCBhcmdzICk7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRnZXRQcm94eTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0aWYgKCAhdGhpcy5wcm94aWVzWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm94aWVzWyBrZXlwYXRoIF0gPSB7XG5cdFx0XHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnJlYWxseVVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMucHJveGllc1sga2V5cGF0aCBdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFBhdHRlcm5PYnNlcnZlcjtcblx0fSggcnVubG9vcCwgaXNFcXVhbCwgUmFjdGl2ZSRvYnNlcnZlX2dldFBhdHRlcm4gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL2dldE9ic2VydmVyRmFjYWRlLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgPSBmdW5jdGlvbiggbm9ybWFsaXNlS2V5cGF0aCwgT2JzZXJ2ZXIsIFBhdHRlcm5PYnNlcnZlciApIHtcblxuXHRcdHZhciB3aWxkY2FyZCA9IC9cXCovLFxuXHRcdFx0ZW1wdHlPYmplY3QgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGYWNhZGUoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciwgY2FuY2VsbGVkO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T2JqZWN0O1xuXHRcdFx0Ly8gcGF0dGVybiBvYnNlcnZlcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHlcblx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRvYnNlcnZlciA9IG5ldyBQYXR0ZXJuT2JzZXJ2ZXIoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMucHVzaCggb2JzZXJ2ZXIgKTtcblx0XHRcdFx0aXNQYXR0ZXJuT2JzZXJ2ZXIgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyID8gJ3BhdHRlcm5PYnNlcnZlcnMnIDogJ29ic2VydmVycycgKTtcblx0XHRcdG9ic2VydmVyLmluaXQoIG9wdGlvbnMuaW5pdCApO1xuXHRcdFx0Ly8gVGhpcyBmbGFnIGFsbG93cyBvYnNlcnZlcnMgdG8gaW5pdGlhbGlzZSBldmVuIHdpdGggdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0b2JzZXJ2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0aWYgKCBjYW5jZWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggaXNQYXR0ZXJuT2JzZXJ2ZXIgKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuaW5kZXhPZiggb2JzZXJ2ZXIgKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsICdwYXR0ZXJuT2JzZXJ2ZXJzJyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCBvYnNlcnZlciwgJ29ic2VydmVycycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoLCBSYWN0aXZlJG9ic2VydmVfT2JzZXJ2ZXIsIFJhY3RpdmUkb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmUgPSBmdW5jdGlvbiggaXNPYmplY3QsIGdldE9ic2VydmVyRmFjYWRlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZSgga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgb2JzZXJ2ZXJzLCBtYXAsIGtleXBhdGhzLCBpO1xuXHRcdFx0Ly8gQWxsb3cgYSBtYXAgb2Yga2V5cGF0aHMgdG8gaGFuZGxlcnNcblx0XHRcdGlmICggaXNPYmplY3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0aWYgKCBtYXAuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbWFwWyBrZXlwYXRoIF07XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggdGhpcy5vYnNlcnZlKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHdoaWxlICggb2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEFsbG93IGByYWN0aXZlLm9ic2VydmUoIGNhbGxiYWNrIClgIC0gaS5lLiBvYnNlcnZlIGVudGlyZSBtb2RlbFxuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0a2V5cGF0aHMgPSBrZXlwYXRoLnNwbGl0KCAnICcgKTtcblx0XHRcdC8vIFNpbmdsZSBrZXlwYXRoXG5cdFx0XHRpZiAoIGtleXBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGtleXBhdGhzXG5cdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdGkgPSBrZXlwYXRocy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyBpIF07XG5cdFx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR3aGlsZSAoIG9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzT2JqZWN0LCBSYWN0aXZlJG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvdHJpbS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfdHJpbSA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL25vdEVtcHR5U3RyaW5nLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ciAhPT0gJyc7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2ZmLmpzICovXG5cdHZhciBSYWN0aXZlJG9mZiA9IGZ1bmN0aW9uKCB0cmltLCBub3RFbXB0eVN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkLCByZW1vdmUgYWxsIGNhbGxiYWNrc1xuXHRcdFx0aWYgKCAhZXZlbnROYW1lICkge1xuXHRcdFx0XHQvLyBUT0RPIHVzZSB0aGlzIGNvZGUgaW5zdGVhZCwgb25jZSB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkXG5cdFx0XHRcdC8vIGluIFBoYW50b21KUyAodGVzdHMgYXJlIHVucGFzc2FibGUgb3RoZXJ3aXNlISlcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE4NTZcblx0XHRcdFx0Ly8gZGVmaW5lUHJvcGVydHkoIHRoaXMsICdfc3VicycsIHsgdmFsdWU6IGNyZWF0ZSggbnVsbCApLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiB0aGlzLl9zdWJzICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9zdWJzWyBldmVudE5hbWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuXHRcdFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KCAnICcgKS5tYXAoIHRyaW0gKS5maWx0ZXIoIG5vdEVtcHR5U3RyaW5nICk7XG5cdFx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGluZGV4O1xuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQuLi5cblx0XHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzID0gdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSApIHtcblx0XHRcdFx0XHRcdC8vIC4uLmlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdFxuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRzdWJzY3JpYmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb24uanMgKi9cblx0dmFyIFJhY3RpdmUkb24gPSBmdW5jdGlvbiggdHJpbSwgbm90RW1wdHlTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvbiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRsaXN0ZW5lcnMsIG4sIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBhbGxvdyBtdXRsaXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG5cdFx0XHRpZiAoIHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRsaXN0ZW5lcnMgPSBbXTtcblx0XHRcdFx0Zm9yICggbiBpbiBldmVudE5hbWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudE5hbWUuaGFzT3duUHJvcGVydHkoIG4gKSApIHtcblx0XHRcdFx0XHRcdGxpc3RlbmVycy5wdXNoKCB0aGlzLm9uKCBuLCBldmVudE5hbWVbIG4gXSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBsaXN0ZW5lcjtcblx0XHRcdFx0XHRcdHdoaWxlICggbGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcblx0XHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0KCB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdIHx8ICggdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSA9IFtdICkgKS5wdXNoKCBjYWxsYmFjayApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLm9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0Lyogc2hhcmVkL2dldE5ld0luZGljZXMuanMgKi9cblx0dmFyIGdldE5ld0luZGljZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5LCB0aGUgbmFtZSBvZiBhIG11dGF0b3IgbWV0aG9kLCBhbmQgdGhlXG5cdFx0Ly8gYXJndW1lbnRzIHRvIGNhbGwgdGhhdCBtdXRhdG9yIG1ldGhvZCB3aXRoLCBhbmQgcmV0dXJucyBhbiBhcnJheSB0aGF0XG5cdFx0Ly8gbWFwcyB0aGUgb2xkIGluZGljZXMgdG8gdGhlaXIgbmV3IGluZGljZXMuXG5cdFx0Ly8gU28gaWYgeW91IGhhZCBzb21ldGhpbmcgbGlrZSB0aGlzLi4uXG5cdFx0Ly9cblx0XHQvLyAgICAgYXJyYXkgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXHRcdC8vICAgICBhcnJheS5wdXNoKCAnZScgKTtcblx0XHQvL1xuXHRcdC8vIC4uLnlvdSdkIGdldCBgWyAwLCAxLCAyLCAzIF1gIC0gaW4gb3RoZXIgd29yZHMsIG5vbmUgb2YgdGhlIG9sZCBpbmRpY2VzXG5cdFx0Ly8gaGF2ZSBjaGFuZ2VkLiBJZiB5b3UgdGhlbiBkaWQgdGhpcy4uLlxuXHRcdC8vXG5cdFx0Ly8gICAgIGFycmF5LnVuc2hpZnQoICd6JyApO1xuXHRcdC8vXG5cdFx0Ly8gLi4udGhlIGluZGljZXMgd291bGQgYmUgYFsgMSwgMiwgMywgNCwgNSBdYCAtIGV2ZXJ5IGl0ZW0gaGFzIGJlZW4gbW92ZWRcblx0XHQvLyBvbmUgaGlnaGVyIHRvIG1ha2Ugcm9vbSBmb3IgdGhlICd6Jy4gSWYgeW91IHJlbW92ZWQgYW4gaXRlbSwgdGhlIG5ldyBpbmRleFxuXHRcdC8vIHdvdWxkIGJlIC0xLi4uXG5cdFx0Ly9cblx0XHQvLyAgICAgYXJyYXkuc3BsaWNlKCAyLCAyICk7XG5cdFx0Ly9cblx0XHQvLyAuLi50aGlzIHdvdWxkIHJlc3VsdCBpbiBbIDAsIDEsIC0xLCAtMSwgMiwgMyBdLlxuXHRcdC8vXG5cdFx0Ly8gVGhpcyBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIGVuYWJsZSBmYXN0LCBub24tZGVzdHJ1Y3RpdmUgc2h1ZmZsaW5nIG9mIGxpc3Rcblx0XHQvLyBzZWN0aW9ucyB3aGVuIHlvdSBkbyBlLmcuIGByYWN0aXZlLnNwbGljZSggJ2l0ZW1zJywgMiwgMiApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZ2V0TmV3SW5kaWNlcyggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgc3BsaWNlQXJndW1lbnRzLCBsZW4sIG5ld0luZGljZXMgPSBbXSxcblx0XHRcdFx0cmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCwgYmFsYW5jZSwgaTtcblx0XHRcdHNwbGljZUFyZ3VtZW50cyA9IGdldFNwbGljZUVxdWl2YWxlbnQoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICk7XG5cdFx0XHRpZiAoICFzcGxpY2VBcmd1bWVudHMgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0YmFsYW5jZSA9IHNwbGljZUFyZ3VtZW50cy5sZW5ndGggLSAyIC0gc3BsaWNlQXJndW1lbnRzWyAxIF07XG5cdFx0XHRyZW1vdmVTdGFydCA9IE1hdGgubWluKCBsZW4sIHNwbGljZUFyZ3VtZW50c1sgMCBdICk7XG5cdFx0XHRyZW1vdmVFbmQgPSByZW1vdmVTdGFydCArIHNwbGljZUFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCByZW1vdmVTdGFydDsgaSArPSAxICkge1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgaSA8IHJlbW92ZUVuZDsgaSArPSAxICkge1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIC0xICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpICsgYmFsYW5jZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ld0luZGljZXM7XG5cdFx0fTtcblx0XHQvLyBUaGUgcG9wLCBwdXNoLCBzaGlmdCBhbiB1bnNoaWZ0IG1ldGhvZHMgY2FuIGFsbCBiZSByZXByZXNlbnRlZFxuXHRcdC8vIGFzIGFuIGVxdWl2YWxlbnQgc3BsaWNlXG5cdFx0ZnVuY3Rpb24gZ2V0U3BsaWNlRXF1aXZhbGVudCggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKSB7XG5cdFx0XHRzd2l0Y2ggKCBtZXRob2ROYW1lICkge1xuXHRcdFx0XHRjYXNlICdzcGxpY2UnOlxuXHRcdFx0XHRcdGlmICggYXJnc1sgMCBdICE9PSB1bmRlZmluZWQgJiYgYXJnc1sgMCBdIDwgMCApIHtcblx0XHRcdFx0XHRcdGFyZ3NbIDAgXSA9IGFycmF5Lmxlbmd0aCArIE1hdGgubWF4KCBhcmdzWyAwIF0sIC1hcnJheS5sZW5ndGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCBhcmdzLmxlbmd0aCA8IDIgKSB7XG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZW5zdXJlIHdlIG9ubHkgcmVtb3ZlIGVsZW1lbnRzIHRoYXQgZXhpc3Rcblx0XHRcdFx0XHRhcmdzWyAxIF0gPSBNYXRoLm1pbiggYXJnc1sgMSBdLCBhcnJheS5sZW5ndGggLSBhcmdzWyAwIF0gKTtcblx0XHRcdFx0XHRyZXR1cm4gYXJncztcblx0XHRcdFx0Y2FzZSAnc29ydCc6XG5cdFx0XHRcdGNhc2UgJ3JldmVyc2UnOlxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRjYXNlICdwb3AnOlxuXHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFx0YXJyYXkubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRcdFx0MVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdGNhc2UgJ3B1c2gnOlxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRhcnJheS5sZW5ndGgsXG5cdFx0XHRcdFx0XHQwXG5cdFx0XHRcdFx0XS5jb25jYXQoIGFyZ3MgKTtcblx0XHRcdFx0Y2FzZSAnc2hpZnQnOlxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0MVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdGNhc2UgJ3Vuc2hpZnQnOlxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0MFxuXHRcdFx0XHRcdF0uY29uY2F0KCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlQXJyYXlNZXRob2QuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCA9IGZ1bmN0aW9uKCBpc0FycmF5LCBydW5sb29wLCBnZXROZXdJbmRpY2VzICkge1xuXG5cdFx0dmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHRcdFx0dmFyIGFyZ3MgPSBTTElDRSQwLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdFx0XHR2YXIgYXJyYXksIG5ld0luZGljZXMgPSBbXSxcblx0XHRcdFx0XHRsZW4sIHByb21pc2UsIHJlc3VsdDtcblx0XHRcdFx0YXJyYXkgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cdFx0XHRcdGlmICggIWlzQXJyYXkoIGFycmF5ICkgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2FsbGVkIHJhY3RpdmUuJyArIG1ldGhvZE5hbWUgKyAnKFxcJycgKyBrZXlwYXRoICsgJ1xcJyksIGJ1dCBcXCcnICsga2V5cGF0aCArICdcXCcgZG9lcyBub3QgcmVmZXIgdG8gYW4gYXJyYXknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXMoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICk7XG5cdFx0XHRcdHJlc3VsdCA9IGFycmF5UHJvdG9bIG1ldGhvZE5hbWUgXS5hcHBseSggYXJyYXksIGFyZ3MgKTtcblx0XHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggISFuZXdJbmRpY2VzICkge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSggaXNBcnJheSwgcnVubG9vcCwgZ2V0TmV3SW5kaWNlcyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3BvcC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwb3AgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3BvcCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcHVzaC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwdXNoID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdwdXNoJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBnbG9iYWwvY3NzLmpzICovXG5cdHZhciBnbG9iYWxfY3NzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIGNzcywgdXBkYXRlLCBydW5sb29wLCBzdHlsZUVsZW1lbnQsIGhlYWQsIHN0eWxlU2hlZXQsIGluRG9tLCBwcmVmaXggPSAnLyogUmFjdGl2ZS5qcyBjb21wb25lbnQgc3R5bGVzICovXFxuJyxcblx0XHRcdGNvbXBvbmVudHNJblBhZ2UgPSB7fSxcblx0XHRcdHN0eWxlcyA9IFtdO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Y3NzID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AgPSBjaXJjdWxhci5ydW5sb29wO1xuXHRcdFx0fSApO1xuXHRcdFx0c3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuXHRcdFx0c3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnaGVhZCcgKVsgMCBdO1xuXHRcdFx0aW5Eb20gPSBmYWxzZTtcblx0XHRcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gdXNlIHN0eWxlU2hlZXQuY3NzVGV4dCBpbnN0ZWFkXG5cdFx0XHRzdHlsZVNoZWV0ID0gc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQ7XG5cdFx0XHR1cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNzcztcblx0XHRcdFx0aWYgKCBzdHlsZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNzcyA9IHByZWZpeCArIHN0eWxlcy5qb2luKCAnICcgKTtcblx0XHRcdFx0XHRpZiAoIHN0eWxlU2hlZXQgKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWluRG9tICkge1xuXHRcdFx0XHRcdFx0aGVhZC5hcHBlbmRDaGlsZCggc3R5bGVFbGVtZW50ICk7XG5cdFx0XHRcdFx0XHRpbkRvbSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpbkRvbSApIHtcblx0XHRcdFx0XHRoZWFkLnJlbW92ZUNoaWxkKCBzdHlsZUVsZW1lbnQgKTtcblx0XHRcdFx0XHRpbkRvbSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Y3NzID0ge1xuXHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKCBDb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhQ29tcG9uZW50LmNzcyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHQvLyB3ZSBjcmVhdGUgdGhpcyBjb3VudGVyIHNvIHRoYXQgd2UgY2FuIGluL2RlY3JlbWVudCBpdCBhc1xuXHRcdFx0XHRcdFx0Ly8gaW5zdGFuY2VzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZC4gV2hlbiBhbGwgY29tcG9uZW50cyBhcmVcblx0XHRcdFx0XHRcdC8vIHJlbW92ZWQsIHRoZSBzdHlsZSBpcyB0b29cblx0XHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdID0gMDtcblx0XHRcdFx0XHRcdHN0eWxlcy5wdXNoKCBDb21wb25lbnQuY3NzICk7XG5cdFx0XHRcdFx0XHR1cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKz0gMTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggQ29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGlmICggIUNvbXBvbmVudC5jc3MgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdIC09IDE7XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHN0eWxlcywgQ29tcG9uZW50LmNzcyApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIHVwZGF0ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNzcztcblx0fSggY2lyY3VsYXIsIGlzQ2xpZW50LCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkcmVuZGVyID0gZnVuY3Rpb24oIGNzcywgSG9vaywgZ2V0RWxlbWVudCwgcnVubG9vcCApIHtcblxuXHRcdHZhciByZW5kZXJIb29rID0gbmV3IEhvb2soICdyZW5kZXInICksXG5cdFx0XHRjb21wbGV0ZUhvb2sgPSBuZXcgSG9vayggJ2NvbXBsZXRlJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlciggdGFyZ2V0LCBhbmNob3IgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwcm9taXNlLCBpbnN0YW5jZXMsIHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdC8vIGlmIGBub0ludHJvYCBpcyBgdHJ1ZWAsIHRlbXBvcmFyaWx5IGRpc2FibGUgdHJhbnNpdGlvbnNcblx0XHRcdHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdFx0aWYgKCB0aGlzLm5vSW50cm8gKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gcmVuZGVySG9vay5maXJlKCB0aGlzJDAgKTtcblx0XHRcdH0sIHRydWUgKTtcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudC5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IGNhbm5vdCBjYWxsIHJhY3RpdmUucmVuZGVyKCkgb24gYW4gYWxyZWFkeSByZW5kZXJlZCBpbnN0YW5jZSEgQ2FsbCByYWN0aXZlLnVucmVuZGVyKCkgZmlyc3QnICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKSB8fCB0aGlzLmVsO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgdGhpcy5hbmNob3I7XG5cdFx0XHR0aGlzLmVsID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cdFx0XHQvLyBBZGQgQ1NTLCBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHRoaXMuY29uc3RydWN0b3IuY3NzICkge1xuXHRcdFx0XHRjc3MuYWRkKCB0aGlzLmNvbnN0cnVjdG9yICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhcmdldCApIHtcblx0XHRcdFx0aWYgKCAhKCBpbnN0YW5jZXMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFsgdGhpcyBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGluc3RhbmNlcy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhbmNob3IgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSwgYW5jaG9yICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdC8vIEl0IGlzIG5vdyBtb3JlIHByb2JsZW1hdGljIHRvIGtub3cgaWYgdGhlIGNvbXBsZXRlIGhvb2tcblx0XHRcdC8vIHdvdWxkIGZpcmUuIE1ldGhvZCBjaGVja2luZyBpcyBzdHJhaWdodC1mb3J3YXJkLCBidXQgd291bGRcblx0XHRcdC8vIGFsc28gcmVxdWlyZSBwcmVmbGlnaHRpbmcgZXZlbnQgc3Vic2NyaXB0aW9ucy4gV2hpY2ggc2VlbXNcblx0XHRcdC8vIGxpa2UgbW9yZSB3b3JrIHRoZW4ganVzdCBsZXR0aW5nIHRoZSBwcm9taXNlIGhhcHBlbi5cblx0XHRcdC8vIEJ1dCBwZXJoYXBzIEknbSB3cm9uZyBhYm91dCB0aGF0Li4uXG5cdFx0XHRwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gY29tcGxldGVIb29rLmZpcmUoIHRoaXMkMCApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggZ2xvYmFsX2NzcywgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgZ2V0RWxlbWVudCwgcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRidWJibGUgPSBmdW5jdGlvbiBGcmFnbWVudCRidWJibGUoKSB7XG5cdFx0dGhpcy5kaXJ0eVZhbHVlID0gdGhpcy5kaXJ0eUFyZ3MgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5ib3VuZCAmJiB0eXBlb2YgdGhpcy5vd25lci5idWJibGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZGV0YWNoID0gZnVuY3Rpb24gRnJhZ21lbnQkZGV0YWNoKCkge1xuXHRcdHZhciBkb2NGcmFnO1xuXHRcdGlmICggdGhpcy5pdGVtcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVtc1sgMCBdLmRldGFjaCgpO1xuXHRcdH1cblx0XHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHR2YXIgbm9kZSA9IGl0ZW0uZGV0YWNoKCk7XG5cdFx0XHQvLyBUT0RPIFRoZSBpZiB7Li4ufSB3YXNuJ3QgcHJldmlvdXNseSByZXF1aXJlZCAtIGl0IGlzIG5vdywgYmVjYXVzZSB3ZSdyZVxuXHRcdFx0Ly8gZm9yY2libHkgZGV0YWNoaW5nIGV2ZXJ5dGhpbmcgdG8gcmVvcmRlciBzZWN0aW9ucyBhZnRlciBhbiB1cGRhdGUuIFRoYXQnc1xuXHRcdFx0Ly8gYSBub24taWRlYWwgYnJ1dGUgZm9yY2UgYXBwcm9hY2gsIGltcGxlbWVudGVkIHRvIGdldCBhbGwgdGhlIHRlc3RzIHRvIHBhc3Ncblx0XHRcdC8vIC0gYXMgc29vbiBhcyBpdCdzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZWxlZ2FudCwgdGhpcyBzaG91bGRcblx0XHRcdC8vIHJldmVydCB0byBgZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApYFxuXHRcdFx0aWYgKCBub2RlICkge1xuXHRcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBkb2NGcmFnO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRBbGwgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcXVlcnk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW07XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZEFsbENvbXBvbmVudHMgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBsZW4sIGksIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRDb21wb25lbnQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kTmV4dE5vZGUoIGl0ZW0gKSB7XG5cdFx0dmFyIGluZGV4ID0gaXRlbS5pbmRleCxcblx0XHRcdG5vZGU7XG5cdFx0aWYgKCB0aGlzLml0ZW1zWyBpbmRleCArIDEgXSApIHtcblx0XHRcdG5vZGUgPSB0aGlzLml0ZW1zWyBpbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm93bmVyID09PSB0aGlzLnJvb3QgKSB7XG5cdFx0XHRpZiAoICF0aGlzLm93bmVyLmNvbXBvbmVudCApIHtcblx0XHRcdFx0Ly8gVE9ETyBidXQgc29tZXRoaW5nIGVsc2UgY291bGQgaGF2ZSBiZWVuIGFwcGVuZGVkIHRvXG5cdFx0XHRcdC8vIHRoaXMucm9vdC5lbCwgbm8/XG5cdFx0XHRcdG5vZGUgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMub3duZXIuY29tcG9uZW50LmZpbmROZXh0Tm9kZSgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlID0gdGhpcy5vd25lci5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXNbIDAgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZ2V0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRnZXROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZ2V0Tm9kZSgpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSB0aGlzO1xuXHRcdGRvIHtcblx0XHRcdGlmICggZnJhZ21lbnQucEVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBmcmFnbWVudC5wRWxlbWVudC5ub2RlO1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdHJldHVybiB0aGlzLnJvb3QuZGV0YWNoZWQgfHwgdGhpcy5yb290LmVsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2dldFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldFZhbHVlID0gZnVuY3Rpb24oIHBhcnNlSlNPTiApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEZyYWdtZW50JGdldFZhbHVlKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IGVtcHR5O1xuXHRcdFx0dmFyIGFzQXJncywgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgY2FjaGVkUmVzdWx0LCBkaXJ0eUZsYWcsIHJlc3VsdDtcblx0XHRcdGFzQXJncyA9IG9wdGlvbnMuYXJncztcblx0XHRcdGNhY2hlZFJlc3VsdCA9IGFzQXJncyA/ICdhcmdzTGlzdCcgOiAndmFsdWUnO1xuXHRcdFx0ZGlydHlGbGFnID0gYXNBcmdzID8gJ2RpcnR5QXJncycgOiAnZGlydHlWYWx1ZSc7XG5cdFx0XHRpZiAoIHRoaXNbIGRpcnR5RmxhZyBdICkge1xuXHRcdFx0XHRzb3VyY2UgPSBwcm9jZXNzSXRlbXMoIHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQgKTtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCBhc0FyZ3MgPyAnWycgKyBzb3VyY2UgKyAnXScgOiBzb3VyY2UsIHZhbHVlcyApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gYXNBcmdzID8gWyB0aGlzLnRvU3RyaW5nKCkgXSA6IHRoaXMudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1sgY2FjaGVkUmVzdWx0IF0gPSByZXN1bHQ7XG5cdFx0XHRcdHRoaXNbIGRpcnR5RmxhZyBdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1sgY2FjaGVkUmVzdWx0IF07XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyggaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApIHtcblx0XHRcdGNvdW50ZXIgPSBjb3VudGVyIHx8IDA7XG5cdFx0XHRyZXR1cm4gaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0dmFyIHBsYWNlaG9sZGVySWQsIHdyYXBwZWQsIHZhbHVlO1xuXHRcdFx0XHRpZiAoIGl0ZW0udGV4dCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS50ZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaXRlbS5mcmFnbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0uZnJhZ21lbnRzLm1hcCggZnVuY3Rpb24oIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NJdGVtcyggZnJhZ21lbnQuaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApO1xuXHRcdFx0XHRcdH0gKS5qb2luKCAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsYWNlaG9sZGVySWQgPSBndWlkICsgJy0nICsgY291bnRlcisrO1xuXHRcdFx0XHRpZiAoIHdyYXBwZWQgPSBpdGVtLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIGl0ZW0ua2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZXNbIHBsYWNlaG9sZGVySWQgXSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gJyR7JyArIHBsYWNlaG9sZGVySWQgKyAnfSc7XG5cdFx0XHR9ICkuam9pbiggJycgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBwYXJzZUpTT04gKTtcblxuXHQvKiB1dGlscy9lc2NhcGVIdG1sLmpzICovXG5cdHZhciBlc2NhcGVIdG1sID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGVzc1RoYW4gPSAvPC9nO1xuXHRcdHZhciBncmVhdGVyVGhhbiA9IC8+L2c7XG5cdFx0dmFyIGFtcCA9IC8mL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGVzY2FwZUh0bWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggYW1wLCAnJmFtcDsnICkucmVwbGFjZSggbGVzc1RoYW4sICcmbHQ7JyApLnJlcGxhY2UoIGdyZWF0ZXJUaGFuLCAnJmd0OycgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvZGV0YWNoTm9kZS5qcyAqL1xuXHR2YXIgZGV0YWNoTm9kZSA9IGZ1bmN0aW9uIGRldGFjaE5vZGUoIG5vZGUgKSB7XG5cdFx0aWYgKCBub2RlICYmIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9kZXRhY2guanMgKi9cblx0dmFyIGRldGFjaCA9IGZ1bmN0aW9uKCBkZXRhY2hOb2RlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRldGFjaE5vZGUoIHRoaXMubm9kZSApO1xuXHRcdH07XG5cdH0oIGRldGFjaE5vZGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RleHQuanMgKi9cblx0dmFyIFRleHQgPSBmdW5jdGlvbiggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApIHtcblxuXHRcdHZhciBUZXh0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5URVhUO1xuXHRcdFx0dGhpcy50ZXh0ID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHR9O1xuXHRcdFRleHQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggdGhpcy50ZXh0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIGVzY2FwZSApIHtcblx0XHRcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoIHRoaXMudGV4dCApIDogdGhpcy50ZXh0O1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmRldGFjaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVGV4dDtcblx0fSggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3VuYmluZC5qcyAqL1xuXHR2YXIgdW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kKCkge1xuXHRcdGlmICggdGhpcy5yZWdpc3RlcmVkICkge1xuXHRcdFx0Ly8gdGhpcyB3YXMgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGFudFxuXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlc29sdmVyICkge1xuXHRcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvZ2V0VmFsdWUuanMgKi9cblx0dmFyIGdldFZhbHVlID0gZnVuY3Rpb24gTXVzdGFjaGUkZ2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvc3RhcnRzV2l0aEtleXBhdGguanMgKi9cblx0dmFyIHN0YXJ0c1dpdGhLZXlwYXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldCwga2V5cGF0aCApIHtcblx0XHRyZXR1cm4gdGFyZ2V0ICYmIGtleXBhdGggJiYgdGFyZ2V0LnN1YnN0ciggMCwga2V5cGF0aC5sZW5ndGggKyAxICkgPT09IGtleXBhdGggKyAnLic7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvZ2V0TmV3S2V5cGF0aC5qcyAqL1xuXHR2YXIgZ2V0TmV3S2V5cGF0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXROZXdLZXlwYXRoKCB0YXJnZXRLZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0Ly8gZXhhY3QgbWF0Y2hcblx0XHRcdGlmICggdGFyZ2V0S2V5cGF0aCA9PT0gb2xkS2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIG5ld0tleXBhdGggIT09IHVuZGVmaW5lZCA/IG5ld0tleXBhdGggOiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcGFydGlhbCBtYXRjaCBiYXNlZCBvbiBsZWFkaW5nIGtleXBhdGggc2VnbWVudHNcblx0XHRcdGlmICggc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldEtleXBhdGgsIG9sZEtleXBhdGggKSApIHtcblx0XHRcdFx0cmV0dXJuIG5ld0tleXBhdGggPT09IG51bGwgPyBuZXdLZXlwYXRoIDogdGFyZ2V0S2V5cGF0aC5yZXBsYWNlKCBvbGRLZXlwYXRoICsgJy4nLCBuZXdLZXlwYXRoICsgJy4nICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggc3RhcnRzV2l0aEtleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlUmVzb2x2ZXIuanMgKi9cblx0dmFyIFJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHJlc29sdmVSZWYsIGdldE5ld0tleXBhdGggKSB7XG5cblx0XHR2YXIgUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiggb3duZXIsIHJlZiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIga2V5cGF0aDtcblx0XHRcdHRoaXMucmVmID0gcmVmO1xuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5yb290ID0gb3duZXIucm9vdDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCBvd25lci5yb290LCByZWYsIG93bmVyLnBhcmVudEZyYWdtZW50ICk7XG5cdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRydW5sb29wLmFkZFVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy5jYWxsYmFjaygga2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZSggdGhpcy5yZWYgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoO1xuXHRcdFx0XHRpZiAoIHRoaXMua2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGtleXBhdGggPSBnZXROZXdLZXlwYXRoKCB0aGlzLmtleXBhdGgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHQvLyB3YXMgYSBuZXcga2V5cGF0aCBjcmVhdGVkP1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Ly8gcmVzb2x2ZSBpdFxuXHRcdFx0XHRcdFx0dGhpcy5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5yZXNvbHZlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLnJlbW92ZVVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFJlZmVyZW5jZVJlc29sdmVyO1xuXHR9KCBydW5sb29wLCByZXNvbHZlUmVmLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1NwZWNpYWxSZXNvbHZlci5qcyAqL1xuXHR2YXIgU3BlY2lhbFJlc29sdmVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgU3BlY2lhbFJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCByZWYsIGNhbGxiYWNrICkge1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZWYgPSByZWY7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLnJlYmluZCgpO1xuXHRcdH07XG5cdFx0U3BlY2lhbFJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZWYgPSB0aGlzLnJlZixcblx0XHRcdFx0XHRmcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRcdGlmICggcmVmID09PSAnQGtleXBhdGgnICkge1xuXHRcdFx0XHRcdHdoaWxlICggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICEhZnJhZ21lbnQuY29udGV4dCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soICdAJyArIGZyYWdtZW50LmNvbnRleHQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHJlZiA9PT0gJ0BpbmRleCcgfHwgcmVmID09PSAnQGtleScgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBmcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdGlmICggZnJhZ21lbnQuaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soICdAJyArIGZyYWdtZW50LmluZGV4ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biBzcGVjaWFsIHJlZmVyZW5jZSBcIicgKyByZWYgKyAnXCIgLSB2YWxpZCByZWZlcmVuY2VzIGFyZSBAaW5kZXgsIEBrZXkgYW5kIEBrZXlwYXRoJyApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cdFx0cmV0dXJuIFNwZWNpYWxSZXNvbHZlcjtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9JbmRleFJlc29sdmVyLmpzICovXG5cdHZhciBJbmRleFJlc29sdmVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgSW5kZXhSZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcmVmLCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVmID0gcmVmO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5yZWJpbmQoKTtcblx0XHR9O1xuXHRcdEluZGV4UmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmViaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJlZiA9IHRoaXMucmVmLFxuXHRcdFx0XHRcdGluZGV4UmVmcyA9IHRoaXMucGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzLFxuXHRcdFx0XHRcdGluZGV4ID0gaW5kZXhSZWZzWyByZWYgXTtcblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2soICdAJyArIGluZGV4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge31cblx0XHR9O1xuXHRcdHJldHVybiBJbmRleFJlc29sdmVyO1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLmpzICovXG5cdHZhciBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBSZWZlcmVuY2VSZXNvbHZlciwgU3BlY2lhbFJlc29sdmVyLCBJbmRleFJlc29sdmVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCBvd25lciwgcmVmLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBpbmRleFJlZnMsIGluZGV4O1xuXHRcdFx0aWYgKCByZWYuY2hhckF0KCAwICkgPT09ICdAJyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBTcGVjaWFsUmVzb2x2ZXIoIG93bmVyLCByZWYsIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRpbmRleFJlZnMgPSBvd25lci5wYXJlbnRGcmFnbWVudC5pbmRleFJlZnM7XG5cdFx0XHRpZiAoIGluZGV4UmVmcyAmJiAoIGluZGV4ID0gaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgSW5kZXhSZXNvbHZlciggb3duZXIsIHJlZiwgY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUmVmZXJlbmNlUmVzb2x2ZXIoIG93bmVyLCByZWYsIGNhbGxiYWNrICk7XG5cdFx0fTtcblx0fSggUmVmZXJlbmNlUmVzb2x2ZXIsIFNwZWNpYWxSZXNvbHZlciwgSW5kZXhSZXNvbHZlciApO1xuXG5cdC8qIHNoYXJlZC9nZXRGdW5jdGlvbkZyb21TdHJpbmcuanMgKi9cblx0dmFyIGdldEZ1bmN0aW9uRnJvbVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNhY2hlID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEZ1bmN0aW9uRnJvbVN0cmluZyggc3RyLCBpICkge1xuXHRcdFx0dmFyIGZuLCBhcmdzO1xuXHRcdFx0aWYgKCBjYWNoZVsgc3RyIF0gKSB7XG5cdFx0XHRcdHJldHVybiBjYWNoZVsgc3RyIF07XG5cdFx0XHR9XG5cdFx0XHRhcmdzID0gW107XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0YXJnc1sgaSBdID0gJ18nICsgaTtcblx0XHRcdH1cblx0XHRcdGZuID0gbmV3IEZ1bmN0aW9uKCBhcmdzLmpvaW4oICcsJyApLCAncmV0dXJuKCcgKyBzdHIgKyAnKScgKTtcblx0XHRcdGNhY2hlWyBzdHIgXSA9IGZuO1xuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvRXhwcmVzc2lvblJlc29sdmVyLmpzICovXG5cdHZhciBFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggZGVmaW5lUHJvcGVydHksIGlzTnVtZXJpYywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGdldEZ1bmN0aW9uRnJvbVN0cmluZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRXhwcmVzc2lvblJlc29sdmVyLCBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cdFx0RXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCBwYXJlbnRGcmFnbWVudCwgZXhwcmVzc2lvbiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBpbmRleFJlZnM7XG5cdFx0XHRyYWN0aXZlID0gb3duZXIucm9vdDtcblx0XHRcdHJlc29sdmVyLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0cmVzb2x2ZXIucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlc29sdmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXNvbHZlci5vd25lciA9IG93bmVyO1xuXHRcdFx0cmVzb2x2ZXIuc3RyID0gZXhwcmVzc2lvbi5zO1xuXHRcdFx0cmVzb2x2ZXIua2V5cGF0aHMgPSBbXTtcblx0XHRcdGluZGV4UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG5cdFx0XHRyZXNvbHZlci5wZW5kaW5nID0gZXhwcmVzc2lvbi5yLmxlbmd0aDtcblx0XHRcdHJlc29sdmVyLnJlZlJlc29sdmVycyA9IGV4cHJlc3Npb24uci5tYXAoIGZ1bmN0aW9uKCByZWYsIGkgKSB7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggcmVzb2x2ZXIsIHJlZiwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIucmVzb2x2ZSggaSwga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXNvbHZlci5yZWFkeSA9IHRydWU7XG5cdFx0XHRyZXNvbHZlci5idWJibGUoKTtcblx0XHR9O1xuXHRcdEV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVuaXF1ZVN0cmluZyA9IGdldFVuaXF1ZVN0cmluZyggdGhpcy5zdHIsIHRoaXMua2V5cGF0aHMgKTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0gZ2V0S2V5cGF0aCggdGhpcy51bmlxdWVTdHJpbmcgKTtcblx0XHRcdFx0dGhpcy5jcmVhdGVFdmFsdWF0b3IoKTtcblx0XHRcdFx0dGhpcy5jYWxsYmFjayggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJlc29sdmVyO1xuXHRcdFx0XHR3aGlsZSAoIHJlc29sdmVyID0gdGhpcy5yZWZSZXNvbHZlcnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbiggaW5kZXgsIGtleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMua2V5cGF0aHNbIGluZGV4IF0gPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZUV2YWx1YXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdFx0Y29tcHV0YXRpb24sIHZhbHVlR2V0dGVycywgc2lnbmF0dXJlLCBrZXlwYXRoLCBmbjtcblx0XHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGF0aW9uc1sgdGhpcy5rZXlwYXRoIF07XG5cdFx0XHRcdC8vIG9ubHkgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQhXG5cdFx0XHRcdGlmICggIWNvbXB1dGF0aW9uICkge1xuXHRcdFx0XHRcdGZuID0gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKCB0aGlzLnN0ciwgdGhpcy5yZWZSZXNvbHZlcnMubGVuZ3RoICk7XG5cdFx0XHRcdFx0dmFsdWVHZXR0ZXJzID0gdGhpcy5rZXlwYXRocy5tYXAoIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0XHRcdFx0aWYgKCBrZXlwYXRoID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyAnc3BlY2lhbCcga2V5cGF0aHMgZW5jb2RlIGEgdmFsdWVcblx0XHRcdFx0XHRcdGlmICgga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0ga2V5cGF0aC5zbGljZSggMSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaXNOdW1lcmljKCB2YWx1ZSApID8gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICt2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fSA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcyQwLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBGdW5jdGlvbiggdmFsdWUsIHNlbGYucm9vdCApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHNpZ25hdHVyZSA9IHtcblx0XHRcdFx0XHRcdGRlcHM6IHRoaXMua2V5cGF0aHMuZmlsdGVyKCBpc1ZhbGlkRGVwZW5kZW5jeSApLFxuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSB2YWx1ZUdldHRlcnMubWFwKCBjYWxsICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmbi5hcHBseSggbnVsbCwgYXJncyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGUoIHRoaXMua2V5cGF0aCwgc2lnbmF0dXJlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5tYXJrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0Ly8gVE9ETyBvbmx5IGJ1YmJsZSBvbmNlLCBubyBtYXR0ZXIgaG93IG1hbnkgcmVmZXJlbmNlcyBhcmUgYWZmZWN0ZWQgYnkgdGhlIHJlYmluZFxuXHRcdFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRyZXR1cm4gci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IEV4cHJlc3Npb25SZXNvbHZlcjtcblxuXHRcdGZ1bmN0aW9uIGNhbGwoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLmNhbGwoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbmlxdWVTdHJpbmcoIHN0ciwga2V5cGF0aHMgKSB7XG5cdFx0XHQvLyBnZXQgc3RyaW5nIHRoYXQgaXMgdW5pcXVlIHRvIHRoaXMgZXhwcmVzc2lvblxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXyhbMC05XSspL2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoLCB2YWx1ZTtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyAkMSBdO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gJ3VuZGVmaW5lZCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBrZXlwYXRoWyAwIF0gPT09ICdAJyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGtleXBhdGguc2xpY2UoIDEgKTtcblx0XHRcdFx0XHRyZXR1cm4gaXNOdW1lcmljKCB2YWx1ZSApID8gdmFsdWUgOiAnXCInICsgdmFsdWUgKyAnXCInO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBrZXlwYXRoO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEtleXBhdGgoIHVuaXF1ZVN0cmluZyApIHtcblx0XHRcdC8vIFNhbml0aXplIGJ5IHJlbW92aW5nIGFueSBwZXJpb2RzIG9yIHNxdWFyZSBicmFja2V0cy4gT3RoZXJ3aXNlXG5cdFx0XHQvLyB3ZSBjYW4ndCBzcGxpdCB0aGUga2V5cGF0aCBpbnRvIGtleXMhXG5cdFx0XHRyZXR1cm4gJyR7JyArIHVuaXF1ZVN0cmluZy5yZXBsYWNlKCAvW1xcLlxcW1xcXV0vZywgJy0nICkgKyAnfSc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNWYWxpZERlcGVuZGVuY3koIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4ga2V5cGF0aCAhPT0gdW5kZWZpbmVkICYmIGtleXBhdGhbIDAgXSAhPT0gJ0AnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdyYXBGdW5jdGlvbiggZm4sIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgd3JhcHBlZCwgcHJvcCwga2V5O1xuXHRcdFx0aWYgKCBmbi5fbm9XcmFwICkge1xuXHRcdFx0XHRyZXR1cm4gZm47XG5cdFx0XHR9XG5cdFx0XHRwcm9wID0gJ19fcmFjdGl2ZV8nICsgcmFjdGl2ZS5fZ3VpZDtcblx0XHRcdHdyYXBwZWQgPSBmblsgcHJvcCBdO1xuXHRcdFx0aWYgKCB3cmFwcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gd3JhcHBlZDtcblx0XHRcdH0gZWxzZSBpZiAoIC90aGlzLy50ZXN0KCBmbi50b1N0cmluZygpICkgKSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KCBmbiwgcHJvcCwge1xuXHRcdFx0XHRcdHZhbHVlOiBiaW5kLmNhbGwoIGZuLCByYWN0aXZlIClcblx0XHRcdFx0fSApO1xuXHRcdFx0XHQvLyBBZGQgcHJvcGVydGllcy9tZXRob2RzIHRvIHdyYXBwZWQgZnVuY3Rpb25cblx0XHRcdFx0Zm9yICgga2V5IGluIGZuICkge1xuXHRcdFx0XHRcdGlmICggZm4uaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdFx0Zm5bIHByb3AgXVsga2V5IF0gPSBmblsga2V5IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmblsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIGZuLCAnX19yYWN0aXZlX25vd3JhcCcsIHtcblx0XHRcdFx0dmFsdWU6IGZuXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gZm4uX19yYWN0aXZlX25vd3JhcDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBkZWZpbmVQcm9wZXJ0eSwgaXNOdW1lcmljLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nLCBsZWdhY3kgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyL01lbWJlclJlc29sdmVyLmpzICovXG5cdHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApIHtcblxuXHRcdHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uKCB0ZW1wbGF0ZSwgcmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0dmFyIG1lbWJlciA9IHRoaXMsXG5cdFx0XHRcdGtleXBhdGg7XG5cdFx0XHRtZW1iZXIucmVzb2x2ZXIgPSByZXNvbHZlcjtcblx0XHRcdG1lbWJlci5yb290ID0gcmVzb2x2ZXIucm9vdDtcblx0XHRcdG1lbWJlci5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuXHRcdFx0bWVtYmVyLnZpZXdtb2RlbCA9IHJlc29sdmVyLnJvb3Qudmlld21vZGVsO1xuXHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRtZW1iZXIudmFsdWUgPSB0ZW1wbGF0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0bWVtYmVyLnJlZlJlc29sdmVyID0gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIHRoaXMsIHRlbXBsYXRlLm4sIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdG1lbWJlci5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ldyBFeHByZXNzaW9uUmVzb2x2ZXIoIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdG1lbWJlci5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdE1lbWJlclJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIHRoaXMua2V5cGF0aCApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIHRoaXMucmVmUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy51bnJlc29sdmVkICkge1xuXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZC51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZWZSZXNvbHZlciApIHtcblx0XHRcdFx0XHR0aGlzLnJlZlJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gTWVtYmVyUmVzb2x2ZXI7XG5cdH0oIHR5cGVzLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgRXhwcmVzc2lvblJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIuanMgKi9cblx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCByZXNvbHZlUmVmLCBSZWZlcmVuY2VSZXNvbHZlciwgTWVtYmVyUmVzb2x2ZXIgKSB7XG5cblx0XHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIG11c3RhY2hlLCB0ZW1wbGF0ZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciByZXNvbHZlciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIHJlZiwga2V5cGF0aCwgcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZXNvbHZlci5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50ID0gbXVzdGFjaGUucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZXNvbHZlci5yb290ID0gcmFjdGl2ZSA9IG11c3RhY2hlLnJvb3Q7XG5cdFx0XHRyZXNvbHZlci5tdXN0YWNoZSA9IG11c3RhY2hlO1xuXHRcdFx0cmVzb2x2ZXIucmVmID0gcmVmID0gdGVtcGxhdGUucjtcblx0XHRcdHJlc29sdmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXNvbHZlci51bnJlc29sdmVkID0gW107XG5cdFx0XHQvLyBGaW5kIGJhc2Uga2V5cGF0aFxuXHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc29sdmVyLmJhc2VSZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VSZXNvbHZlciggdGhpcywgcmVmLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuXHRcdFx0XHRcdHJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaW5kIHZhbHVlcyBmb3IgbWVtYmVycywgb3IgbWFyayB0aGVtIGFzIHVucmVzb2x2ZWRcblx0XHRcdHJlc29sdmVyLm1lbWJlcnMgPSB0ZW1wbGF0ZS5tLm1hcCggZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IE1lbWJlclJlc29sdmVyKCB0ZW1wbGF0ZSwgdGhpcyQwLCBwYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmVzb2x2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0S2V5cGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1lbWJlcnMubWFwKCBnZXRWYWx1ZSApO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXMuZXZlcnkoIGlzRGVmaW5lZCApIHx8IHRoaXMuYmFzZVJlc29sdmVyICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmJhc2UgKyAnLicgKyB2YWx1ZXMuam9pbiggJy4nICk7XG5cdFx0XHR9LFxuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5yZWFkeSB8fCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jYWxsYmFjayggdGhpcy5nZXRLZXlwYXRoKCkgKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgY2hhbmdlZDtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBtZW1iZXJzICkge1xuXHRcdFx0XHRcdGlmICggbWVtYmVycy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHR0aGlzLmJhc2UgPSB0aGlzLnJlZjtcblx0XHRcdFx0XHR0aGlzLmJhc2VSZXNvbHZlci51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBtICkge1xuXHRcdFx0XHRcdHJldHVybiBtLmZvcmNlUmVzb2x1dGlvbigpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlKCBtZW1iZXIgKSB7XG5cdFx0XHRyZXR1cm4gbWVtYmVyLnZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzRGVmaW5lZCggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgIT0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggbWVtYmVyICkge1xuXHRcdFx0bWVtYmVyLnVuYmluZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyO1xuXHR9KCByZXNvbHZlUmVmLCBSZWZlcmVuY2VSZXNvbHZlciwgTWVtYmVyUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9pbml0aWFsaXNlLmpzICovXG5cdHZhciBpbml0aWFsaXNlID0gZnVuY3Rpb24oIHR5cGVzLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gTXVzdGFjaGUkaW5pdCggbXVzdGFjaGUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcmVmLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRtdXN0YWNoZS5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdG11c3RhY2hlLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRtdXN0YWNoZS5wRWxlbWVudCA9IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXHRcdFx0bXVzdGFjaGUudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0bXVzdGFjaGUuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG5cdFx0XHRtdXN0YWNoZS5pc1N0YXRpYyA9IG9wdGlvbnMudGVtcGxhdGUucztcblx0XHRcdG11c3RhY2hlLnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLnQ7XG5cdFx0XHRtdXN0YWNoZS5yZWdpc3RlcmVkID0gZmFsc2U7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgc2ltcGxlIG11c3RhY2hlLCB3aXRoIGEgcmVmZXJlbmNlLCB3ZSBqdXN0IG5lZWQgdG8gcmVzb2x2ZVxuXHRcdFx0Ly8gdGhlIHJlZmVyZW5jZSB0byBhIGtleXBhdGhcblx0XHRcdGlmICggcmVmID0gdGVtcGxhdGUuciApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIG11c3RhY2hlLCByZWYsIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIGl0J3MgYW4gZXhwcmVzc2lvbiwgd2UgaGF2ZSBhIGJpdCBtb3JlIHdvcmsgdG8gZG9cblx0XHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS54ICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBFeHByZXNzaW9uUmVzb2x2ZXIoIG11c3RhY2hlLCBwYXJlbnRGcmFnbWVudCwgb3B0aW9ucy50ZW1wbGF0ZS54LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4gKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS5yeCApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKCBtdXN0YWNoZSwgb3B0aW9ucy50ZW1wbGF0ZS5yeCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpbnZlcnRlZCBzZWN0aW9uc1xuXHRcdFx0aWYgKCBtdXN0YWNoZS50ZW1wbGF0ZS5uID09PSB0eXBlcy5TRUNUSU9OX1VOTEVTUyAmJiAhbXVzdGFjaGUuaGFzT3duUHJvcGVydHkoICd2YWx1ZScgKSApIHtcblx0XHRcdFx0bXVzdGFjaGUuc2V0VmFsdWUoIHVuZGVmaW5lZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBrZXlwYXRoICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiggbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG9sZEtleXBhdGggPSBtdXN0YWNoZS5rZXlwYXRoO1xuXHRcdFx0XHRpZiAoIG5ld0tleXBhdGggIT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZSggbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRcdGlmICggb2xkS2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuZnJhZ21lbnRzICYmIG11c3RhY2hlLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRcdFx0Zi5yZWJpbmQoIG51bGwsIG51bGwsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciwgRXhwcmVzc2lvblJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvcmVzb2x2ZS5qcyAqL1xuXHR2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uKCBpc051bWVyaWMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gTXVzdGFjaGUkcmVzb2x2ZSgga2V5cGF0aCApIHtcblx0XHRcdHZhciB3YXNSZXNvbHZlZCwgdmFsdWUsIHR3b3dheUJpbmRpbmc7XG5cdFx0XHQvLyAnU3BlY2lhbCcga2V5cGF0aHMsIGUuZy4gQGZvbyBvciBANywgZW5jb2RlIGEgdmFsdWVcblx0XHRcdGlmICgga2V5cGF0aCAmJiBrZXlwYXRoWyAwIF0gPT09ICdAJyApIHtcblx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnNsaWNlKCAxICk7XG5cdFx0XHRcdGlmICggaXNOdW1lcmljKCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHZhbHVlID0gK3ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHdlIHJlc29sdmVkIHByZXZpb3VzbHksIHdlIG5lZWQgdG8gdW5yZWdpc3RlclxuXHRcdFx0aWYgKCB0aGlzLnJlZ2lzdGVyZWQgKSB7XG5cdFx0XHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXHRcdFx0XHR3YXNSZXNvbHZlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0Ly8gSWYgdGhlIG5ldyBrZXlwYXRoIGV4aXN0cywgd2UgbmVlZCB0byByZWdpc3RlclxuXHRcdFx0Ly8gd2l0aCB0aGUgdmlld21vZGVsXG5cdFx0XHRpZiAoIGtleXBhdGggIT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIEVpdGhlciB3YXkgd2UgbmVlZCB0byBxdWV1ZSB1cCBhIHJlbmRlciAoYHZhbHVlYFxuXHRcdFx0Ly8gd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGVyZSdzIG5vIGtleXBhdGgpXG5cdFx0XHR0aGlzLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0Ly8gVHdvLXdheSBiaW5kaW5ncyBuZWVkIHRvIHBvaW50IHRvIHRoZWlyIG5ldyB0YXJnZXQga2V5cGF0aFxuXHRcdFx0aWYgKCB3YXNSZXNvbHZlZCAmJiAoIHR3b3dheUJpbmRpbmcgPSB0aGlzLnR3b3dheUJpbmRpbmcgKSApIHtcblx0XHRcdFx0dHdvd2F5QmluZGluZy5yZWJvdW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNOdW1lcmljICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvcmViaW5kLmpzICovXG5cdHZhciByZWJpbmQgPSBmdW5jdGlvbiBNdXN0YWNoZSRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHQvLyBDaGlsZHJlbiBmaXJzdFxuXHRcdGlmICggdGhpcy5mcmFnbWVudHMgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0cmV0dXJuIGYucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0Ly8gRXhwcmVzc2lvbiBtdXN0YWNoZT9cblx0XHRpZiAoIHRoaXMucmVzb2x2ZXIgKSB7XG5cdFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL19NdXN0YWNoZS5qcyAqL1xuXHR2YXIgTXVzdGFjaGUgPSBmdW5jdGlvbiggZ2V0VmFsdWUsIGluaXQsIHJlc29sdmUsIHJlYmluZCApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXRWYWx1ZTogZ2V0VmFsdWUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcblx0XHRcdHJlYmluZDogcmViaW5kXG5cdFx0fTtcblx0fSggZ2V0VmFsdWUsIGluaXRpYWxpc2UsIHJlc29sdmUsIHJlYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvSW50ZXJwb2xhdG9yLmpzICovXG5cdHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggdHlwZXMsIHJ1bmxvb3AsIGVzY2FwZUh0bWwsIGRldGFjaE5vZGUsIGlzRXF1YWwsIHVuYmluZCwgTXVzdGFjaGUsIGRldGFjaCApIHtcblxuXHRcdHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEludGVycG9sYXRvci5wcm90b3R5cGUgPSB7XG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm5vZGUuZGF0YSA9IHRoaXMudmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB0aGlzLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6ICcnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0XHRkZXRhY2hOb2RlKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblx0XHRcdC8vIFRFTVBcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB3cmFwcGVyO1xuXHRcdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIHRoaXMua2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIGVzY2FwZSApIHtcblx0XHRcdFx0dmFyIHN0cmluZyA9IHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gJycgKyB0aGlzLnZhbHVlIDogJyc7XG5cdFx0XHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKCBzdHJpbmcgKSA6IHN0cmluZztcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBJbnRlcnBvbGF0b3I7XG5cdH0oIHR5cGVzLCBydW5sb29wLCBlc2NhcGVIdG1sLCBkZXRhY2hOb2RlLCBpc0VxdWFsLCB1bmJpbmQsIE11c3RhY2hlLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGJ1YmJsZSA9IGZ1bmN0aW9uIFNlY3Rpb24kYnViYmxlKCkge1xuXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRkZXRhY2ggPSBmdW5jdGlvbiBTZWN0aW9uJGRldGFjaCgpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1sgMCBdLmRldGFjaCgpO1xuXHRcdH1cblx0XHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZG9jRnJhZztcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmQoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW47XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbjtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzWyBpIF0uZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmROZXh0Tm9kZSggZnJhZ21lbnQgKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50c1sgZnJhZ21lbnQuaW5kZXggKyAxIF0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdLmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIFNlY3Rpb24kZmlyc3ROb2RlKCkge1xuXHRcdHZhciBsZW4sIGksIG5vZGU7XG5cdFx0aWYgKCBsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpZiAoIG5vZGUgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpcnN0Tm9kZSgpICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvc2h1ZmZsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNodWZmbGUgPSBmdW5jdGlvbiggdHlwZXMsIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFNlY3Rpb24kc2h1ZmZsZSggbmV3SW5kaWNlcyApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLFxuXHRcdFx0XHRwYXJlbnRGcmFnbWVudCwgZmlyc3RDaGFuZ2UsIGksIG5ld0xlbmd0aCwgcmVib3VuZEZyYWdtZW50cywgZnJhZ21lbnRPcHRpb25zLCBmcmFnbWVudDtcblx0XHRcdC8vIHNob3J0IGNpcmN1aXQgYW55IGRvdWJsZS11cGRhdGVzLCBhbmQgZW5zdXJlIHRoYXQgdGhpcyBpc24ndCBhcHBsaWVkIHRvXG5cdFx0XHQvLyBub24tbGlzdCBzZWN0aW9uc1xuXHRcdFx0aWYgKCB0aGlzLnNodWZmbGluZyB8fCB0aGlzLnVuYm91bmQgfHwgdGhpcy5zdWJ0eXBlICYmIHRoaXMuc3VidHlwZSAhPT0gdHlwZXMuU0VDVElPTl9FQUNIICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNodWZmbGluZyA9IHRydWU7XG5cdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzJDAuc2h1ZmZsaW5nID0gZmFsc2U7XG5cdFx0XHR9ICk7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZWJvdW5kRnJhZ21lbnRzID0gW107XG5cdFx0XHQvLyBmaXJzdCwgcmViaW5kIGV4aXN0aW5nIGZyYWdtZW50c1xuXHRcdFx0bmV3SW5kaWNlcy5mb3JFYWNoKCBmdW5jdGlvbiByZWJpbmRJZk5lY2Vzc2FyeSggbmV3SW5kZXgsIG9sZEluZGV4ICkge1xuXHRcdFx0XHR2YXIgZnJhZ21lbnQsIGJ5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXHRcdFx0XHRpZiAoIG5ld0luZGV4ID09PSBvbGRJbmRleCApIHtcblx0XHRcdFx0XHRyZWJvdW5kRnJhZ21lbnRzWyBuZXdJbmRleCBdID0gc2VjdGlvbi5mcmFnbWVudHNbIG9sZEluZGV4IF07XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbIG9sZEluZGV4IF07XG5cdFx0XHRcdGlmICggZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRmaXJzdENoYW5nZSA9IG9sZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvZXMgdGhpcyBmcmFnbWVudCBuZWVkIHRvIGJlIHRvcm4gZG93bj9cblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgaXQgbmVlZHMgdG8gYmUgcmVib3VuZCB0byBhIG5ldyBpbmRleFxuXHRcdFx0XHRieSA9IG5ld0luZGV4IC0gb2xkSW5kZXg7XG5cdFx0XHRcdG9sZEtleXBhdGggPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBvbGRJbmRleDtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIG5ld0luZGV4O1xuXHRcdFx0XHRmcmFnbWVudC5yZWJpbmQoIHNlY3Rpb24udGVtcGxhdGUuaSwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0ZnJhZ21lbnQuaW5kZXggPSBuZXdJbmRleDtcblx0XHRcdFx0cmVib3VuZEZyYWdtZW50c1sgbmV3SW5kZXggXSA9IGZyYWdtZW50O1xuXHRcdFx0fSApO1xuXHRcdFx0bmV3TGVuZ3RoID0gdGhpcy5yb290LmdldCggdGhpcy5rZXlwYXRoICkubGVuZ3RoO1xuXHRcdFx0Ly8gSWYgbm90aGluZyBjaGFuZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGZyYWdtZW50cywgdGhlbiB3ZSBzdGFydCBhZGRpbmdcblx0XHRcdC8vIG5ldyBmcmFnbWVudHMgYXQgdGhlIGVuZC4uLlxuXHRcdFx0aWYgKCBmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyAuLi51bmxlc3MgdGhlcmUgYXJlIG5vIG5ldyBmcmFnbWVudHMgdG8gYWRkXG5cdFx0XHRcdGlmICggdGhpcy5sZW5ndGggPT09IG5ld0xlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Zmlyc3RDaGFuZ2UgPSB0aGlzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHRoaXMubGVuZ3RoID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID0gbmV3TGVuZ3RoO1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIFByZXBhcmUgbmV3IGZyYWdtZW50IG9wdGlvbnNcblx0XHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fTtcblx0XHRcdGlmICggdGhpcy50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSB0aGlzLnRlbXBsYXRlLmk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgYXMgbWFueSBuZXcgZnJhZ21lbnRzIGFzIHdlIG5lZWQgdG8sIG9yIGFkZCBiYWNrIGV4aXN0aW5nXG5cdFx0XHQvLyAoZGV0YWNoZWQpIGZyYWdtZW50c1xuXHRcdFx0Zm9yICggaSA9IGZpcnN0Q2hhbmdlOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gcmVib3VuZEZyYWdtZW50c1sgaSBdO1xuXHRcdFx0XHRpZiAoICFmcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdID0gZnJhZ21lbnQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRyZW5kZXIgPSBmdW5jdGlvbiBTZWN0aW9uJHJlbmRlcigpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRkb2NGcmFnID0gdGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdXRpbHMvaXNBcnJheUxpa2UuanMgKi9cblx0dmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcGF0dGVybiA9IC9eXFxbb2JqZWN0ICg/OkFycmF5fEZpbGVMaXN0KVxcXSQvLFxuXHRcdFx0dG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdG9TdHJpbmcuY2FsbCggb2JqICkgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9zZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNldFZhbHVlID0gZnVuY3Rpb24oIHR5cGVzLCBpc0FycmF5TGlrZSwgaXNPYmplY3QsIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gU2VjdGlvbiRzZXRWYWx1ZSggdmFsdWUgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciB3cmFwcGVyLCBmcmFnbWVudE9wdGlvbnM7XG5cdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdC8vIElmIGEgY2hpbGQgb2YgdGhpcyBzZWN0aW9uIGNhdXNlcyBhIHJlLWV2YWx1YXRpb24gLSBmb3IgZXhhbXBsZSwgYW5cblx0XHRcdFx0Ly8gZXhwcmVzc2lvbiByZWZlcnMgdG8gYSBmdW5jdGlvbiB0aGF0IG11dGF0ZXMgdGhlIGFycmF5IHRoYXQgdGhpc1xuXHRcdFx0XHQvLyBzZWN0aW9uIGRlcGVuZHMgb24gLSB3ZSdsbCBlbmQgdXAgd2l0aCBhIGRvdWJsZSByZW5kZXJpbmcgYnVnIChzZWVcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy83NDgpLiBUaGlzIHByZXZlbnRzIGl0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdC8vIHdpdGggc2VjdGlvbnMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBmYWtlIHZhbHVlIGlmIHdlIGhhdmUgYSB3cmFwcGVkIG9iamVjdFxuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYW55IGZyYWdtZW50cyBhcmUgYXdhaXRpbmcgY3JlYXRpb24gYWZ0ZXIgYSBzcGxpY2UsXG5cdFx0XHQvLyB0aGlzIGlzIHRoZSBwbGFjZSB0byBkbyBpdFxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCApIHtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzLnBFbGVtZW50LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdGluZGV4UmVmOiB0aGlzLnRlbXBsYXRlLmlcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5mb3JFYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdFx0dmFyIGZyYWdtZW50O1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gdGhpcyQwLmtleXBhdGggKyAnLicgKyBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0dGhpcyQwLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHRoaXMkMC5mcmFnbWVudHNbIGluZGV4IF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIHJlZXZhbHVhdGVTZWN0aW9uKCB0aGlzLCB2YWx1ZSApICkge1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZVNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlICkge1xuXHRcdFx0dmFyIGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHNlY3Rpb24udGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogc2VjdGlvbi5yb290LFxuXHRcdFx0XHRwRWxlbWVudDogc2VjdGlvbi5wYXJlbnRGcmFnbWVudC5wRWxlbWVudCxcblx0XHRcdFx0b3duZXI6IHNlY3Rpb25cblx0XHRcdH07XG5cdFx0XHQvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhlIHNlY3Rpb24gdHlwZSwgZ3JlYXRcblx0XHRcdC8vIFRPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkPyBpLmUuIHBpY2sgYW4gcmVldmFsdWF0ZVNlY3Rpb24gZnVuY3Rpb24gZHVyaW5nIGluaXRcblx0XHRcdC8vIGFuZCBhdm9pZCBkb2luZyB0aGlzIGVhY2ggdGltZT9cblx0XHRcdGlmICggc2VjdGlvbi5zdWJ0eXBlICkge1xuXHRcdFx0XHRzd2l0Y2ggKCBzZWN0aW9uLnN1YnR5cGUgKSB7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX0lGOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1VOTEVTUzpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgdHJ1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1dJVEg6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fSUZfV0lUSDpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9FQUNIOlxuXHRcdFx0XHRcdFx0aWYgKCBpc09iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3b3JrIG91dCB3aGF0IHNvcnQgb2Ygc2VjdGlvbiB3ZSdyZSBkZWFsaW5nIHdpdGhcblx0XHRcdHNlY3Rpb24ub3JkZXJlZCA9ICEhaXNBcnJheUxpa2UoIHZhbHVlICk7XG5cdFx0XHQvLyBPcmRlcmVkIGxpc3Qgc2VjdGlvblxuXHRcdFx0aWYgKCBzZWN0aW9uLm9yZGVyZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVub3JkZXJlZCBsaXN0LCBvciBjb250ZXh0XG5cdFx0XHRpZiAoIGlzT2JqZWN0KCB2YWx1ZSApIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gSW5kZXggcmVmZXJlbmNlIGluZGljYXRlcyBzZWN0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbGlzdFxuXHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBvYmplY3QgcHJvdmlkZXMgY29udGV4dCBmb3IgY29udGVudHNcblx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb25kaXRpb25hbCBzZWN0aW9uXG5cdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaSwgbGVuZ3RoLCBmcmFnbWVudDtcblx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdGlmICggbGVuZ3RoID09PSBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gTm90aGluZyB0byBkb1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIGl0IHdhcyBwcmV2aW91c2x5LCByZW1vdmUgaXRlbXNcblx0XHRcdGlmICggbGVuZ3RoIDwgc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggbGVuZ3RoLCBzZWN0aW9uLmxlbmd0aCAtIGxlbmd0aCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIGFkZCBhbnkgbmV3IG9uZXNcblx0XHRcdFx0XHRmb3IgKCBpID0gc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRcdC8vIGFwcGVuZCBsaXN0IGl0ZW0gdG8gY29udGV4dCBzdGFja1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBpO1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaTtcblx0XHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyBpIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBsZW5ndGg7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaWQsIGksIGhhc0tleSwgZnJhZ21lbnQsIGNoYW5nZWQ7XG5cdFx0XHRoYXNLZXkgPSBzZWN0aW9uLmhhc0tleSB8fCAoIHNlY3Rpb24uaGFzS2V5ID0ge30gKTtcblx0XHRcdC8vIHJlbW92ZSBhbnkgZnJhZ21lbnRzIHRoYXQgc2hvdWxkIG5vIGxvbmdlciBleGlzdFxuXHRcdFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBpIF07XG5cdFx0XHRcdGlmICggISggZnJhZ21lbnQuaW5kZXggaW4gdmFsdWUgKSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRoYXNLZXlbIGZyYWdtZW50LmluZGV4IF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGFueSB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldFxuXHRcdFx0Zm9yICggaWQgaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIWhhc0tleVsgaWQgXSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGlkO1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGlkO1xuXHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gc2VjdGlvbi50ZW1wbGF0ZS5pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0aGFzS2V5WyBpZCBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoIHNlY3Rpb24gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBmcmFnbWVudDtcblx0XHRcdC8vIC4uLnRoZW4gaWYgaXQgaXNuJ3QgcmVuZGVyZWQsIHJlbmRlciBpdCwgYWRkaW5nIHNlY3Rpb24ua2V5cGF0aCB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gKGlmIGl0IGlzIGFscmVhZHkgcmVuZGVyZWQsIHRoZW4gYW55IGNoaWxkcmVuIGRlcGVuZGVudCBvbiB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyB3aXRob3V0IGFueSBwcm9tcHRpbmcpXG5cdFx0XHRpZiAoICFzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gYXBwZW5kIHRoaXMgc2VjdGlvbiB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aDtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBpbnZlcnRlZCwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGRvUmVuZGVyLCBlbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgZnJhZ21lbnQsIG5hbWU7XG5cdFx0XHRlbXB0eUFycmF5ID0gaXNBcnJheUxpa2UoIHZhbHVlICkgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuXHRcdFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcblx0XHRcdGlmICggIWlzQXJyYXlMaWtlKCB2YWx1ZSApICYmIGlzT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRlbXB0eU9iamVjdCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gdmFsdWUgKSB7XG5cdFx0XHRcdFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbnZlcnRlZCApIHtcblx0XHRcdFx0ZG9SZW5kZXIgPSBlbXB0eUFycmF5IHx8IGVtcHR5T2JqZWN0IHx8ICF2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvUmVuZGVyID0gdmFsdWUgJiYgIWVtcHR5QXJyYXkgJiYgIWVtcHR5T2JqZWN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkb1JlbmRlciApIHtcblx0XHRcdFx0aWYgKCAhc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gbm8gY2hhbmdlIHRvIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHNlY3Rpb24ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDEgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKCBzZWN0aW9uICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyggc2VjdGlvbiApIHtcblx0XHRcdGlmICggc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggMCwgc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoICkuZmlsdGVyKCBpc1JlbmRlcmVkICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLmxlbmd0aCA9IDA7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1JlbmRlcmVkKCBmcmFnbWVudCApIHtcblx0XHRcdHJldHVybiBmcmFnbWVudC5yZW5kZXJlZDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgaXNBcnJheUxpa2UsIGlzT2JqZWN0LCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR0b1N0cmluZyA9IGZ1bmN0aW9uIFNlY3Rpb24kdG9TdHJpbmcoIGVzY2FwZSApIHtcblx0XHR2YXIgc3RyLCBpLCBsZW47XG5cdFx0c3RyID0gJyc7XG5cdFx0aSA9IDA7XG5cdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50c1sgaSBdLnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVuYmluZCA9IGZ1bmN0aW9uKCB1bmJpbmQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBTZWN0aW9uJHVuYmluZCgpIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIHVuYmluZEZyYWdtZW50ICk7XG5cdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy51bmJvdW5kID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kRnJhZ21lbnQoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBTZWN0aW9uJHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggc2hvdWxkRGVzdHJveSA/IHVucmVuZGVyQW5kRGVzdHJveSA6IHVucmVuZGVyICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVucmVuZGVyQW5kRGVzdHJveSggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggdHJ1ZSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVucmVuZGVyKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCBmYWxzZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVwZGF0ZSA9IGZ1bmN0aW9uIFNlY3Rpb24kdXBkYXRlKCkge1xuXHRcdHZhciBmcmFnbWVudCwgcmVuZGVySW5kZXgsIHJlbmRlcmVkRnJhZ21lbnRzLCBhbmNob3IsIHRhcmdldCwgaSwgbGVuO1xuXHRcdC8vIGB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzYCBpcyBpbiB0aGUgb3JkZXIgb2YgdGhlIHByZXZpb3VzIHJlbmRlci5cblx0XHQvLyBJZiBmcmFnbWVudHMgaGF2ZSBzaHVmZmxlZCBhYm91dCwgdGhpcyBhbGxvd3MgdXMgdG8gcXVpY2tseVxuXHRcdC8vIHJlaW5zZXJ0IHRoZW0gaW4gdGhlIGNvcnJlY3QgcGxhY2Vcblx0XHRyZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMucmVuZGVyZWRGcmFnbWVudHM7XG5cdFx0Ly8gUmVtb3ZlIGZyYWdtZW50cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgZm9yIGRlc3RydWN0aW9uXG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wb3AoKSApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCB0cnVlICk7XG5cdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoIHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50ICksIDEgKTtcblx0XHR9XG5cdFx0Ly8gUmVuZGVyIG5ldyBmcmFnbWVudHMgKGJ1dCBkb24ndCBpbnNlcnQgdGhlbSB5ZXQpXG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuc2hpZnQoKSApIHtcblx0XHRcdGZyYWdtZW50LnJlbmRlcigpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblx0XHR9XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzWyBpIF07XG5cdFx0XHRyZW5kZXJJbmRleCA9IHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50LCBpICk7XG5cdFx0XHQvLyBzZWFyY2ggZnJvbSBjdXJyZW50IGluZGV4IC0gaXQncyBndWFyYW50ZWVkIHRvIGJlIHRoZSBzYW1lIG9yIGhpZ2hlclxuXHRcdFx0aWYgKCByZW5kZXJJbmRleCA9PT0gaSApIHtcblx0XHRcdFx0Ly8gYWxyZWFkeSBpbiB0aGUgcmlnaHQgcGxhY2UuIGluc2VydCBhY2N1bXVsYXRlZCBub2RlcyAoaWYgYW55KSBhbmQgY2Fycnkgb25cblx0XHRcdFx0aWYgKCB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0YW5jaG9yID0gZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBhbmNob3IgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggZnJhZ21lbnQuZGV0YWNoKCkgKTtcblx0XHRcdC8vIHVwZGF0ZSByZW5kZXJlZEZyYWdtZW50c1xuXHRcdFx0aWYgKCByZW5kZXJJbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZSggcmVuZGVySW5kZXgsIDEgKTtcblx0XHRcdH1cblx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZSggaSwgMCwgZnJhZ21lbnQgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIGFuY2hvciApO1xuXHRcdH1cblx0XHQvLyBTYXZlIHRoZSByZW5kZXJpbmcgb3JkZXIgZm9yIG5leHQgdGltZVxuXHRcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cy5zbGljZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9fU2VjdGlvbi5qcyAqL1xuXHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCB0eXBlcywgTXVzdGFjaGUsIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIHNodWZmbGUsIHJlbmRlciwgc2V0VmFsdWUsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdHRoaXMuc3VidHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcblx0XHRcdHRoaXMuaW52ZXJ0ZWQgPSB0aGlzLnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fVU5MRVNTO1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZSA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1VucmVuZGVyID0gW107XG5cdFx0XHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gW107XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdFx0XHQvLyBudW1iZXIgb2YgdGltZXMgdGhpcyBzZWN0aW9uIGlzIHJlbmRlcmVkXG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRTZWN0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXHRcdFx0c2h1ZmZsZTogc2h1ZmZsZSxcblx0XHRcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0c2V0VmFsdWU6IHNldFZhbHVlLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIFNlY3Rpb247XG5cdH0oIHR5cGVzLCBNdXN0YWNoZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmQsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZE5leHROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2h1ZmZsZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNldFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bnJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVwZGF0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGRldGFjaCA9IGZ1bmN0aW9uIFRyaXBsZSRkZXRhY2goKSB7XG5cdFx0dmFyIGxlbiwgaTtcblx0XHRpZiAoIHRoaXMuZG9jRnJhZyApIHtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKCB0aGlzLm5vZGVzWyBpIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlSZXN1bHQ7XG5cdFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm5vZGVzWyBpIF07XG5cdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hdGNoZXMoIG5vZGUsIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBxdWVyeVJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3Rvciggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZEFsbCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnlSZXN1bHQgKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeUFsbFJlc3VsdCwgbnVtTm9kZXMsIGo7XG5cdFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm5vZGVzWyBpIF07XG5cdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hdGNoZXMoIG5vZGUsIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0cXVlcnlSZXN1bHQucHVzaCggbm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcXVlcnlBbGxSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0bnVtTm9kZXMgPSBxdWVyeUFsbFJlc3VsdC5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBudW1Ob2RlczsgaiArPSAxICkge1xuXHRcdFx0XHRcdFx0cXVlcnlSZXN1bHQucHVzaCggcXVlcnlBbGxSZXN1bHRbIGogXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaXJzdE5vZGUgPSBmdW5jdGlvbiBUcmlwbGUkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiB0aGlzLm5vZGVzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2Rlc1sgMCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9oZWxwZXJzL2luc2VydEh0bWwuanMgKi9cblx0dmFyIGluc2VydEh0bWwgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZWxlbWVudENhY2hlID0ge30sXG5cdFx0XHRpZUJ1ZywgaWVCbGFja2xpc3Q7XG5cdFx0dHJ5IHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQoICd0YWJsZScgKS5pbm5lckhUTUwgPSAnZm9vJztcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0aWVCdWcgPSB0cnVlO1xuXHRcdFx0aWVCbGFja2xpc3QgPSB7XG5cdFx0XHRcdFRBQkxFOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VEhFQUQ6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0aGVhZCBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3RoZWFkPjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUQk9EWTogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRib2R5IGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdGJvZHk+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRSOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dHIgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90cj48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0U0VMRUNUOiBbXG5cdFx0XHRcdFx0JzxzZWxlY3QgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC9zZWxlY3Q+J1xuXHRcdFx0XHRdXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBodG1sLCBub2RlLCBkb2NGcmFnICkge1xuXHRcdFx0dmFyIGNvbnRhaW5lciwgbm9kZXMgPSBbXSxcblx0XHRcdFx0d3JhcHBlciwgc2VsZWN0ZWRPcHRpb24sIGNoaWxkLCBpO1xuXHRcdFx0Ly8gcmVuZGVyIDAgYW5kIGZhbHNlXG5cdFx0XHRpZiAoIGh0bWwgIT0gbnVsbCAmJiBodG1sICE9PSAnJyApIHtcblx0XHRcdFx0aWYgKCBpZUJ1ZyAmJiAoIHdyYXBwZXIgPSBpZUJsYWNrbGlzdFsgbm9kZS50YWdOYW1lIF0gKSApIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KCAnRElWJyApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSB3cmFwcGVyWyAwIF0gKyBodG1sICsgd3JhcHBlclsgMSBdO1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCAnLngnICk7XG5cdFx0XHRcdFx0aWYgKCBjb250YWluZXIudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zWyBjb250YWluZXIuc2VsZWN0ZWRJbmRleCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnICkge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoICdESVYnICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnIGNsYXNzPVwieFwiPicgKyBodG1sICsgJzwvc3ZnPic7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoICcueCcgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KCBub2RlLnRhZ05hbWUgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcblx0XHRcdFx0XHRpZiAoIGNvbnRhaW5lci50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbIGNvbnRhaW5lci5zZWxlY3RlZEluZGV4IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZCApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGNoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVGhpcyBpcyByZWFsbHkgYW5ub3lpbmcuIEV4dHJhY3RpbmcgPG9wdGlvbj4gbm9kZXMgZnJvbSB0aGVcblx0XHRcdFx0Ly8gdGVtcG9yYXJ5IGNvbnRhaW5lciA8c2VsZWN0PiBjYXVzZXMgdGhlIHJlbWFpbmluZyBvbmVzIHRvXG5cdFx0XHRcdC8vIGJlY29tZSBzZWxlY3RlZC4gU28gbm93IHdlIGhhdmUgdG8gZGVzZWxlY3QgdGhlbS4gSUU4LCB5b3Vcblx0XHRcdFx0Ly8gYW1hemUgbWUuIFlvdSByZWFsbHkgZG9cblx0XHRcdFx0Ly8gLi4uYW5kIG5vdyBDaHJvbWUgdG9vXG5cdFx0XHRcdGlmICggbm9kZS50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcblx0XHRcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCBub2Rlc1sgaSBdICE9PSBzZWxlY3RlZE9wdGlvbiApIHtcblx0XHRcdFx0XHRcdFx0bm9kZXNbIGkgXS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGVzO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBlbGVtZW50KCB0YWdOYW1lICkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRDYWNoZVsgdGFnTmFtZSBdIHx8ICggZWxlbWVudENhY2hlWyB0YWdOYW1lIF0gPSBjcmVhdGVFbGVtZW50KCB0YWdOYW1lICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50ICk7XG5cblx0LyogdXRpbHMvdG9BcnJheS5qcyAqL1xuXHR2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoIGFycmF5TGlrZSApIHtcblx0XHR2YXIgYXJyYXkgPSBbXSxcblx0XHRcdGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YXJyYXlbIGkgXSA9IGFycmF5TGlrZVsgaSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvaGVscGVycy91cGRhdGVTZWxlY3QuanMgKi9cblx0dmFyIHVwZGF0ZVNlbGVjdCA9IGZ1bmN0aW9uKCB0b0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gdXBkYXRlU2VsZWN0KCBwYXJlbnRFbGVtZW50ICkge1xuXHRcdFx0dmFyIHNlbGVjdGVkT3B0aW9ucywgb3B0aW9uLCB2YWx1ZTtcblx0XHRcdGlmICggIXBhcmVudEVsZW1lbnQgfHwgcGFyZW50RWxlbWVudC5uYW1lICE9PSAnc2VsZWN0JyB8fCAhcGFyZW50RWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxlY3RlZE9wdGlvbnMgPSB0b0FycmF5KCBwYXJlbnRFbGVtZW50Lm5vZGUub3B0aW9ucyApLmZpbHRlciggaXNTZWxlY3RlZCApO1xuXHRcdFx0Ly8gSWYgb25lIG9mIHRoZW0gaGFkIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIHdlIG5lZWQgdG8gc3luY1xuXHRcdFx0Ly8gdGhlIG1vZGVsIHRvIHRoZSB2aWV3XG5cdFx0XHRpZiAoIHBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gc2VsZWN0ZWRPcHRpb25zLm1hcCggZnVuY3Rpb24oIG8gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG8udmFsdWU7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbiA9IHNlbGVjdGVkT3B0aW9uc1sgMCBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbi52YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cGFyZW50RWxlbWVudC5iaW5kaW5nLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0cGFyZW50RWxlbWVudC5idWJibGUoKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTZWxlY3RlZCggb3B0aW9uICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbi5zZWxlY3RlZDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0b0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkcmVuZGVyID0gZnVuY3Rpb24oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkcmVuZGVyKCkge1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gcmVuZGVyIGFuIGl0ZW0gdGhhdCB3YXMgYWxyZWFkeSByZW5kZXJlZCcgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKCB0aGlzLnZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSwgdGhpcy5kb2NGcmFnICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cblx0XHRcdHVwZGF0ZVNlbGVjdCggdGhpcy5wRWxlbWVudCApO1xuXHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuXHRcdH07XG5cdH0oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9zZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkc2V0VmFsdWUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkc2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdFx0dmFyIHdyYXBwZXI7XG5cdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR0b1N0cmluZyA9IGZ1bmN0aW9uKCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSR0b1N0cmluZygpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoICcnICsgdGhpcy52YWx1ZSApIDogJyc7XG5cdFx0fTtcblx0fSggZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdW5yZW5kZXIgPSBmdW5jdGlvbiggZGV0YWNoTm9kZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKCBkZXRhY2hOb2RlICk7XG5cdFx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBkZXRhY2hOb2RlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlID0gZnVuY3Rpb24oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5vZGUsIHBhcmVudE5vZGU7XG5cdFx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXhpc3Rpbmcgbm9kZXNcblx0XHRcdHdoaWxlICggdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXMucG9wKCk7XG5cdFx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW5zZXJ0IG5ldyBub2Rlc1xuXHRcdFx0cGFyZW50Tm9kZSA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXHRcdFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwoIHRoaXMudmFsdWUsIHBhcmVudE5vZGUsIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKSApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9fVHJpcGxlLmpzICovXG5cdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggdHlwZXMsIE11c3RhY2hlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpcnN0Tm9kZSwgcmVuZGVyLCBzZXRWYWx1ZSwgdG9TdHJpbmcsIHVucmVuZGVyLCB1cGRhdGUsIHVuYmluZCApIHtcblxuXHRcdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdFRyaXBsZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBzZXRWYWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBUcmlwbGU7XG5cdH0oIHR5cGVzLCBNdXN0YWNoZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkc2V0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1bnJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlLCB1bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRkZXRhY2ggPSBmdW5jdGlvbiBFbGVtZW50JGRldGFjaCgpIHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdHBhcmVudE5vZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Ly8gbmVlZCB0byBjaGVjayBmb3IgcGFyZW50IG5vZGUgLSBET00gbWF5IGhhdmUgYmVlbiBhbHRlcmVkXG5cdFx0XHQvLyBieSBzb21ldGhpbmcgb3RoZXIgdGhhbiBSYWN0aXZlISBlLmcuIGpRdWVyeSBVSS4uLlxuXHRcdFx0aWYgKCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdGlmICggbWF0Y2hlcyggdGhpcy5ub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmluZCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0Ly8gQWRkIHRoaXMgbm9kZSB0byB0aGUgcXVlcnksIGlmIGFwcGxpY2FibGUsIGFuZCByZWdpc3RlciB0aGVcblx0XHQvLyBxdWVyeSBvbiB0aGlzIGVsZW1lbnRcblx0XHRpZiAoIHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICkgJiYgcXVlcnkubGl2ZSApIHtcblx0XHRcdCggdGhpcy5saXZlUXVlcmllcyB8fCAoIHRoaXMubGl2ZVF1ZXJpZXMgPSBbXSApICkucHVzaCggcXVlcnkgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZmluZE5leHROb2RlKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gRWxlbWVudCRmaXJzdE5vZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2dldEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZ2V0QXR0cmlidXRlKCBuYW1lICkge1xuXHRcdGlmICggIXRoaXMuYXR0cmlidXRlcyB8fCAhdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXS52YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc2hhcmVkL2VuZm9yY2VDYXNlLmpzICovXG5cdHZhciBlbmZvcmNlQ2FzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzLCBjcmVhdGVNYXAsIG1hcDtcblx0XHRzdmdDYW1lbENhc2VFbGVtZW50cyA9ICdhbHRHbHlwaCBhbHRHbHlwaERlZiBhbHRHbHlwaEl0ZW0gYW5pbWF0ZUNvbG9yIGFuaW1hdGVNb3Rpb24gYW5pbWF0ZVRyYW5zZm9ybSBjbGlwUGF0aCBmZUJsZW5kIGZlQ29sb3JNYXRyaXggZmVDb21wb25lbnRUcmFuc2ZlciBmZUNvbXBvc2l0ZSBmZUNvbnZvbHZlTWF0cml4IGZlRGlmZnVzZUxpZ2h0aW5nIGZlRGlzcGxhY2VtZW50TWFwIGZlRGlzdGFudExpZ2h0IGZlRmxvb2QgZmVGdW5jQSBmZUZ1bmNCIGZlRnVuY0cgZmVGdW5jUiBmZUdhdXNzaWFuQmx1ciBmZUltYWdlIGZlTWVyZ2UgZmVNZXJnZU5vZGUgZmVNb3JwaG9sb2d5IGZlT2Zmc2V0IGZlUG9pbnRMaWdodCBmZVNwZWN1bGFyTGlnaHRpbmcgZmVTcG90TGlnaHQgZmVUaWxlIGZlVHVyYnVsZW5jZSBmb3JlaWduT2JqZWN0IGdseXBoUmVmIGxpbmVhckdyYWRpZW50IHJhZGlhbEdyYWRpZW50IHRleHRQYXRoIHZrZXJuJy5zcGxpdCggJyAnICk7XG5cdFx0c3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyA9ICdhdHRyaWJ1dGVOYW1lIGF0dHJpYnV0ZVR5cGUgYmFzZUZyZXF1ZW5jeSBiYXNlUHJvZmlsZSBjYWxjTW9kZSBjbGlwUGF0aFVuaXRzIGNvbnRlbnRTY3JpcHRUeXBlIGNvbnRlbnRTdHlsZVR5cGUgZGlmZnVzZUNvbnN0YW50IGVkZ2VNb2RlIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGdseXBoUmVmIGdyYWRpZW50VHJhbnNmb3JtIGdyYWRpZW50VW5pdHMga2VybmVsTWF0cml4IGtlcm5lbFVuaXRMZW5ndGgga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxpbWl0aW5nQ29uZUFuZ2xlIG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrQ29udGVudFVuaXRzIG1hc2tVbml0cyBudW1PY3RhdmVzIHBhdGhMZW5ndGggcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVHJhbnNmb3JtIHBhdHRlcm5Vbml0cyBwb2ludHNBdFggcG9pbnRzQXRZIHBvaW50c0F0WiBwcmVzZXJ2ZUFscGhhIHByZXNlcnZlQXNwZWN0UmF0aW8gcHJpbWl0aXZlVW5pdHMgcmVmWCByZWZZIHJlcGVhdENvdW50IHJlcGVhdER1ciByZXF1aXJlZEV4dGVuc2lvbnMgcmVxdWlyZWRGZWF0dXJlcyBzcGVjdWxhckNvbnN0YW50IHNwZWN1bGFyRXhwb25lbnQgc3ByZWFkTWV0aG9kIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdGl0Y2hUaWxlcyBzdXJmYWNlU2NhbGUgc3lzdGVtTGFuZ3VhZ2UgdGFibGVWYWx1ZXMgdGFyZ2V0WCB0YXJnZXRZIHRleHRMZW5ndGggdmlld0JveCB2aWV3VGFyZ2V0IHhDaGFubmVsU2VsZWN0b3IgeUNoYW5uZWxTZWxlY3RvciB6b29tQW5kUGFuJy5zcGxpdCggJyAnICk7XG5cdFx0Y3JlYXRlTWFwID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdFx0dmFyIG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG1hcFsgaXRlbXNbIGkgXS50b0xvd2VyQ2FzZSgpIF0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcDtcblx0XHR9O1xuXHRcdG1hcCA9IGNyZWF0ZU1hcCggc3ZnQ2FtZWxDYXNlRWxlbWVudHMuY29uY2F0KCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzICkgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnROYW1lICkge1xuXHRcdFx0dmFyIGxvd2VyQ2FzZUVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBtYXBbIGxvd2VyQ2FzZUVsZW1lbnROYW1lIF0gfHwgbG93ZXJDYXNlRWxlbWVudE5hbWU7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNFcXVhbCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkYnViYmxlKCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0Ly8gVE9ETyB0aGlzIGNhbiByZWdpc3RlciB0aGUgYXR0cmlidXRlIG11bHRpcGxlIHRpbWVzIChzZWUgcmVuZGVyIHRlc3Rcblx0XHRcdC8vICdBdHRyaWJ1dGUgd2l0aCBuZXN0ZWQgbXVzdGFjaGVzJylcblx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdC8vIE5lZWQgdG8gY2xlYXIgb2xkIGlkIGZyb20gcmFjdGl2ZS5ub2Rlc1xuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lkJyAmJiB0aGlzLnZhbHVlICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbIHRoaXMudmFsdWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGlmICggdGhpcy5uYW1lID09PSAndmFsdWUnICYmIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIHN0b3JlIHRoZSB2YWx1ZSBvbiB0aGUgRE9NIGxpa2UgdGhpcyBzbyB3ZVxuXHRcdFx0XHRcdC8vIGNhbiByZXRyaWV2ZSBpdCBsYXRlciB3aXRob3V0IGl0IGJlaW5nIGNvZXJjZWQgdG8gYSBzdHJpbmdcblx0XHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wLCBpc0VxdWFsICk7XG5cblx0LyogY29uZmlnL2Jvb2xlYW5BdHRyaWJ1dGVzLmpzICovXG5cdHZhciBib29sZWFuQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9odG1sLW1pbmlmaWVyL2lzc3Vlcy82MyNpc3N1ZWNvbW1lbnQtMzc3NjMzMTZcblx0XHR2YXIgYm9vbGVhbkF0dHJpYnV0ZXMgPSAvXihhbGxvd0Z1bGxzY3JlZW58YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNoZWNrZWR8Y29tcGFjdHxjb250cm9sc3xkZWNsYXJlfGRlZmF1bHR8ZGVmYXVsdENoZWNrZWR8ZGVmYXVsdE11dGVkfGRlZmF1bHRTZWxlY3RlZHxkZWZlcnxkaXNhYmxlZHxkcmFnZ2FibGV8ZW5hYmxlZHxmb3JtTm9WYWxpZGF0ZXxoaWRkZW58aW5kZXRlcm1pbmF0ZXxpbmVydHxpc01hcHxpdGVtU2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxub0hyZWZ8bm9SZXNpemV8bm9TaGFkZXxub1ZhbGlkYXRlfG5vV3JhcHxvcGVufHBhdXNlT25FeGl0fHJlYWRPbmx5fHJlcXVpcmVkfHJldmVyc2VkfHNjb3BlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cmFuc2xhdGV8dHJ1ZVNwZWVkfHR5cGVNdXN0TWF0Y2h8dmlzaWJsZSkkL2k7XG5cdFx0cmV0dXJuIGJvb2xlYW5BdHRyaWJ1dGVzO1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9oZWxwZXJzL2RldGVybWluZU5hbWVBbmROYW1lc3BhY2UuanMgKi9cblx0dmFyIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgZW5mb3JjZUNhc2UgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgbmFtZSApIHtcblx0XHRcdHZhciBjb2xvbkluZGV4LCBuYW1lc3BhY2VQcmVmaXg7XG5cdFx0XHQvLyBhcmUgd2UgZGVhbGluZyB3aXRoIGEgbmFtZXNwYWNlZCBhdHRyaWJ1dGUsIGUuZy4geGxpbms6aHJlZj9cblx0XHRcdGNvbG9uSW5kZXggPSBuYW1lLmluZGV4T2YoICc6JyApO1xuXHRcdFx0aWYgKCBjb2xvbkluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gbG9va3MgbGlrZSB3ZSBhcmUsIHllcy4uLlxuXHRcdFx0XHRuYW1lc3BhY2VQcmVmaXggPSBuYW1lLnN1YnN0ciggMCwgY29sb25JbmRleCApO1xuXHRcdFx0XHQvLyAuLi51bmxlc3MgaXQncyBhIG5hbWVzcGFjZSAqZGVjbGFyYXRpb24qLCB3aGljaCB3ZSBpZ25vcmUgKG9uIHRoZSBhc3N1bXB0aW9uXG5cdFx0XHRcdC8vIHRoYXQgb25seSB2YWxpZCBuYW1lc3BhY2VzIHdpbGwgYmUgdXNlZClcblx0XHRcdFx0aWYgKCBuYW1lc3BhY2VQcmVmaXggIT09ICd4bWxucycgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUuc3Vic3RyaW5nKCBjb2xvbkluZGV4ICsgMSApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gZW5mb3JjZUNhc2UoIG5hbWUgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlID0gbmFtZXNwYWNlc1sgbmFtZXNwYWNlUHJlZml4LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlUHJlZml4ID0gbmFtZXNwYWNlUHJlZml4O1xuXHRcdFx0XHRcdGlmICggIWF0dHJpYnV0ZS5uYW1lc3BhY2UgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnVW5rbm93biBuYW1lc3BhY2UgKFwiJyArIG5hbWVzcGFjZVByZWZpeCArICdcIiknO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFNWRyBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Ugc2Vuc2l0aXZlXG5cdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5lbGVtZW50Lm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlcy5odG1sID8gZW5mb3JjZUNhc2UoIG5hbWUgKSA6IG5hbWU7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgZW5mb3JjZUNhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZ2V0SW50ZXJwb2xhdG9yLmpzICovXG5cdHZhciBnZXRJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBhdHRyaWJ1dGUuZnJhZ21lbnQuaXRlbXM7XG5cdFx0XHRpZiAoIGl0ZW1zLmxlbmd0aCAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpdGVtc1sgMCBdLnR5cGUgPT09IHR5cGVzLklOVEVSUE9MQVRPUiApIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW1zWyAwIF07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZGV0ZXJtaW5lUHJvcGVydHlOYW1lLmpzICovXG5cdHZhciBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgcHJvcGVydHlOYW1lcyA9IHtcblx0XHRcdCdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0Jyxcblx0XHRcdGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG5cdFx0XHRiZ2NvbG9yOiAnYmdDb2xvcicsXG5cdFx0XHQnY2xhc3MnOiAnY2xhc3NOYW1lJyxcblx0XHRcdGNvZGViYXNlOiAnY29kZUJhc2UnLFxuXHRcdFx0Y29sc3BhbjogJ2NvbFNwYW4nLFxuXHRcdFx0Y29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcblx0XHRcdGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuXHRcdFx0ZGlybmFtZTogJ2Rpck5hbWUnLFxuXHRcdFx0J2Zvcic6ICdodG1sRm9yJyxcblx0XHRcdCdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG5cdFx0XHRpc21hcDogJ2lzTWFwJyxcblx0XHRcdG1heGxlbmd0aDogJ21heExlbmd0aCcsXG5cdFx0XHRub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG5cdFx0XHRwdWJkYXRlOiAncHViRGF0ZScsXG5cdFx0XHRyZWFkb25seTogJ3JlYWRPbmx5Jyxcblx0XHRcdHJvd3NwYW46ICdyb3dTcGFuJyxcblx0XHRcdHRhYmluZGV4OiAndGFiSW5kZXgnLFxuXHRcdFx0dXNlbWFwOiAndXNlTWFwJ1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcHJvcGVydHlOYW1lO1xuXHRcdFx0aWYgKCBhdHRyaWJ1dGUucE5vZGUgJiYgIWF0dHJpYnV0ZS5uYW1lc3BhY2UgJiYgKCAhb3B0aW9ucy5wTm9kZS5uYW1lc3BhY2VVUkkgfHwgb3B0aW9ucy5wTm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApICkge1xuXHRcdFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzWyBhdHRyaWJ1dGUubmFtZSBdIHx8IGF0dHJpYnV0ZS5uYW1lO1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMucE5vZGVbIHByb3BlcnR5TmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cblx0XHRcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcblx0XHRcdFx0aWYgKCBib29sZWFuQXR0cmlidXRlcy50ZXN0KCBwcm9wZXJ0eU5hbWUgKSB8fCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCBib29sZWFuQXR0cmlidXRlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQVRUUklCVVRFO1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0ZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSggdGhpcywgb3B0aW9ucy5uYW1lICk7XG5cdFx0XHQvLyBpZiBpdCdzIGFuIGVtcHR5IGF0dHJpYnV0ZSwgb3IganVzdCBhIHN0cmFpZ2h0IGtleS12YWx1ZSBwYWlyLCB3aXRoIG5vXG5cdFx0XHQvLyBtdXN0YWNoZSBzaGVuYW5pZ2Fucywgc2V0IHRoZSBhdHRyaWJ1dGUgYWNjb3JkaW5nbHkgYW5kIGdvIGhvbWVcblx0XHRcdGlmICggIW9wdGlvbnMudmFsdWUgfHwgdHlwZW9mIG9wdGlvbnMudmFsdWUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggdGhpcy5uYW1lICkgPyB0cnVlIDogb3B0aW9ucy52YWx1ZSB8fCAnJztcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZG8gc29tZSB3b3JrXG5cdFx0XHQvLyBzaGFyZSBwYXJlbnRGcmFnbWVudCB3aXRoIHBhcmVudCBlbGVtZW50XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHR0ZW1wbGF0ZTogb3B0aW9ucy52YWx1ZSxcblx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoaXMgYXR0cmlidXRlJ3MgaW50ZXJwb2xhdG9yLCBpZiBpdHMgZnJhZ21lbnRcblx0XHRcdC8vIHRha2VzIHRoZSBmb3JtIGB7e2Zvb319YC4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIHR3by13YXkgYmluZGluZyBhbmRcblx0XHRcdC8vIGZvciBjb3JyZWN0bHkgcmVuZGVyaW5nIEhUTUwgbGF0ZXJcblx0XHRcdHRoaXMuaW50ZXJwb2xhdG9yID0gZ2V0SW50ZXJwb2xhdG9yKCB0aGlzICk7XG5cdFx0XHR0aGlzLmlzQmluZGFibGUgPSAhIXRoaXMuaW50ZXJwb2xhdG9yICYmICF0aGlzLmludGVycG9sYXRvci5pc1N0YXRpYztcblx0XHRcdC8vIGNhbiB3ZSBlc3RhYmxpc2ggdGhpcyBhdHRyaWJ1dGUncyBwcm9wZXJ0eSBuYW1lIGVxdWl2YWxlbnQ/XG5cdFx0XHRkZXRlcm1pbmVQcm9wZXJ0eU5hbWUoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRcdC8vIG1hcmsgYXMgcmVhZHlcblx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBib29sZWFuQXR0cmlidXRlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlYmluZCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZW5kZXIgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgcHJvcGVydHlOYW1lcyA9IHtcblx0XHRcdCdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0Jyxcblx0XHRcdCdhY2Nlc3NrZXknOiAnYWNjZXNzS2V5Jyxcblx0XHRcdCdiZ2NvbG9yJzogJ2JnQ29sb3InLFxuXHRcdFx0J2NsYXNzJzogJ2NsYXNzTmFtZScsXG5cdFx0XHQnY29kZWJhc2UnOiAnY29kZUJhc2UnLFxuXHRcdFx0J2NvbHNwYW4nOiAnY29sU3BhbicsXG5cdFx0XHQnY29udGVudGVkaXRhYmxlJzogJ2NvbnRlbnRFZGl0YWJsZScsXG5cdFx0XHQnZGF0ZXRpbWUnOiAnZGF0ZVRpbWUnLFxuXHRcdFx0J2Rpcm5hbWUnOiAnZGlyTmFtZScsXG5cdFx0XHQnZm9yJzogJ2h0bWxGb3InLFxuXHRcdFx0J2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2Jyxcblx0XHRcdCdpc21hcCc6ICdpc01hcCcsXG5cdFx0XHQnbWF4bGVuZ3RoJzogJ21heExlbmd0aCcsXG5cdFx0XHQnbm92YWxpZGF0ZSc6ICdub1ZhbGlkYXRlJyxcblx0XHRcdCdwdWJkYXRlJzogJ3B1YkRhdGUnLFxuXHRcdFx0J3JlYWRvbmx5JzogJ3JlYWRPbmx5Jyxcblx0XHRcdCdyb3dzcGFuJzogJ3Jvd1NwYW4nLFxuXHRcdFx0J3RhYmluZGV4JzogJ3RhYkluZGV4Jyxcblx0XHRcdCd1c2VtYXAnOiAndXNlTWFwJ1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZW5kZXIoIG5vZGUgKSB7XG5cdFx0XHR2YXIgcHJvcGVydHlOYW1lO1xuXHRcdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHRcdC8vIHNob3VsZCB3ZSB1c2UgZGlyZWN0IHByb3BlcnR5IGFjY2Vzcywgb3Igc2V0QXR0cmlidXRlP1xuXHRcdFx0aWYgKCAhbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApIHtcblx0XHRcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1sgdGhpcy5uYW1lIF0gfHwgdGhpcy5uYW1lO1xuXHRcdFx0XHRpZiAoIG5vZGVbIHByb3BlcnR5TmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaXMgYXR0cmlidXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUgb3IgJ3ZhbHVlJz8gSWYgc28gd2UncmUgYmV0dGVyIG9mZiBkb2luZyBlLmcuXG5cdFx0XHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG5cdFx0XHRcdGlmICggYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggcHJvcGVydHlOYW1lICkgfHwgcHJvcGVydHlOYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdHRoaXMudXNlUHJvcGVydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcHJvcGVydHlOYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdHRoaXMudXNlUHJvcGVydHkgPSB0cnVlO1xuXHRcdFx0XHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR0b1N0cmluZyA9IGZ1bmN0aW9uKCBib29sZWFuQXR0cmlidXRlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR0b1N0cmluZygpIHtcblx0XHRcdHZhciBuYW1lID0gKCBmcmFnbWVudCA9IHRoaXMgKS5uYW1lLFxuXHRcdFx0XHRuYW1lc3BhY2VQcmVmaXggPSBmcmFnbWVudC5uYW1lc3BhY2VQcmVmaXgsXG5cdFx0XHRcdHZhbHVlID0gZnJhZ21lbnQudmFsdWUsXG5cdFx0XHRcdGludGVycG9sYXRvciA9IGZyYWdtZW50LmludGVycG9sYXRvcixcblx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5mcmFnbWVudDtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdCBhbmQgdGV4dGFyZWEgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuXHRcdFx0aWYgKCBuYW1lID09PSAndmFsdWUnICYmICggdGhpcy5lbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnIHx8IHRoaXMuZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnQgZWRpdGFibGVcblx0XHRcdGlmICggbmFtZSA9PT0gJ3ZhbHVlJyAmJiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWVzXG5cdFx0XHRpZiAoIG5hbWUgPT09ICduYW1lJyAmJiB0aGlzLmVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyAmJiBpbnRlcnBvbGF0b3IgKSB7XG5cdFx0XHRcdHJldHVybiAnbmFtZT17eycgKyAoIGludGVycG9sYXRvci5rZXlwYXRoIHx8IGludGVycG9sYXRvci5yZWYgKSArICd9fSc7XG5cdFx0XHR9XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXNcblx0XHRcdGlmICggYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyBuYW1lIDogJyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGZyYWdtZW50ICkge1xuXHRcdFx0XHR2YWx1ZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5hbWVzcGFjZVByZWZpeCApIHtcblx0XHRcdFx0bmFtZSA9IG5hbWVzcGFjZVByZWZpeCArICc6JyArIG5hbWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgPyBuYW1lICsgJz1cIicgKyBlc2NhcGUoIHZhbHVlICkgKyAnXCInIDogbmFtZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZXNjYXBlKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvJi9nLCAnJmFtcDsnICkucmVwbGFjZSggL1wiL2csICcmcXVvdDsnICkucmVwbGFjZSggLycvZywgJyYjMzk7JyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGJvb2xlYW5BdHRyaWJ1dGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVuYmluZCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1bmJpbmQoKSB7XG5cdFx0Ly8gaWdub3JlIG5vbi1keW5hbWljIGF0dHJpYnV0ZXNcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lkJyApIHtcblx0XHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbIHRoaXMudmFsdWUgXTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVNlbGVjdFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3QoKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdG9wdGlvbnMsIG9wdGlvbiwgb3B0aW9uVmFsdWUsIGk7XG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0Ly8gZG91YmxlIGVxdWFscyBhcyB3ZSBtYXkgYmUgY29tcGFyaW5nIG51bWJlcnMgd2l0aCBzdHJpbmdzXG5cdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiB1dGlscy9hcnJheUNvbnRhaW5zLmpzICovXG5cdHZhciBhcnJheUNvbnRhaW5zID0gZnVuY3Rpb24gYXJyYXlDb250YWlucyggYXJyYXksIHZhbHVlICkge1xuXHRcdGZvciAoIHZhciBpID0gMCwgYyA9IGFycmF5Lmxlbmd0aDsgaSA8IGM7IGkrKyApIHtcblx0XHRcdGlmICggYXJyYXlbIGkgXSA9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uKCBhcnJheUNvbnRhaW5zLCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdCgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG5cdFx0XHRcdG9wdGlvbnMsIGksIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRpZiAoICFpc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IFsgdmFsdWUgXTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IGFycmF5Q29udGFpbnMoIHZhbHVlLCBvcHRpb25WYWx1ZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGFycmF5Q29udGFpbnMsIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlUmFkaW9OYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lKCkge1xuXHRcdHZhciBub2RlID0gKCB2YWx1ZSA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZTtcblx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSBub2RlLl9yYWN0aXZlLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVSYWRpb1ZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWUoKSB7XG5cdFx0XHR2YXIgd2FzQ2hlY2tlZCwgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0YmluZGluZywgYmluZGluZ3MsIGk7XG5cdFx0XHR3YXNDaGVja2VkID0gbm9kZS5jaGVja2VkO1xuXHRcdFx0bm9kZS52YWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSA9PT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cdFx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gaWYgdGhlIGlucHV0IHdhcyBjaGVja2VkLCBhbmQgdGhlIHZhbHVlXG5cdFx0XHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBvdXQgb2YgZGF0ZS4gVG8gZml4IGl0IHdlIGhhdmUgdG8ganVtcCB0aHJvdWdoIHNvbWVcblx0XHRcdC8vIGhvb3BzLi4uIHRoaXMgaXMgYSBsaXR0bGUga2x1ZGd5IGJ1dCBpdCB3b3Jrc1xuXHRcdFx0aWYgKCB3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5lbGVtZW50LmJpbmRpbmcuc2libGluZ3M7XG5cdFx0XHRcdGlmICggaSA9IGJpbmRpbmdzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCAhYmluZGluZy5lbGVtZW50Lm5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLCBzaWJsaW5ncyBhcmUgc3RpbGwgcmVuZGVyaW5nIVxuXHRcdFx0XHRcdFx0XHQvLyB3ZSdsbCBjb21lIGJhY2sgbGF0ZXIuLi5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkICkge1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggYmluZGluZy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGJpbmRpbmcucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCB1bmRlZmluZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2hlY2tib3hOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUgPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lKCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSAoIHZhbHVlID0gdGhpcyApLmVsZW1lbnQsXG5cdFx0XHRcdG5vZGUgPSB2YWx1ZS5ub2RlLFxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlLFxuXHRcdFx0XHR2YWx1ZUF0dHJpYnV0ZSwgaTtcblx0XHRcdHZhbHVlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggIWlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IHZhbHVlQXR0cmlidXRlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZUF0dHJpYnV0ZSA9PSB2YWx1ZVsgaSBdICkge1xuXHRcdFx0XHRcdFx0bm9kZS5jaGVja2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVDbGFzc05hbWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdG5vZGUuY2xhc3NOYW1lID0gdmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUlkQXR0cmlidXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZSgpIHtcblx0XHR2YXIgbm9kZSA9ICggdmFsdWUgPSB0aGlzICkubm9kZSxcblx0XHRcdHZhbHVlID0gdmFsdWUudmFsdWU7XG5cdFx0dGhpcy5yb290Lm5vZGVzWyB2YWx1ZSBdID0gbm9kZTtcblx0XHRub2RlLmlkID0gdmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSgpIHtcblx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9XG5cdFx0bm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoICdjc3NUZXh0JywgdmFsdWUgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlKCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlVmFsdWUoKSB7XG5cdFx0dmFyIG5vZGUgPSAoIHZhbHVlID0gdGhpcyApLm5vZGUsXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuXHRcdC8vIHN0b3JlIGFjdHVhbCB2YWx1ZSwgc28gaXQgZG9lc24ndCBnZXQgY29lcmNlZCB0byBhIHN0cmluZ1xuXHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0bm9kZS52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVCb29sZWFuLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVCb29sZWFuID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGUoKSB7XG5cdFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuXHRcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2Vcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IHRoaXMudmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVFdmVyeXRoaW5nRWxzZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgPSBmdW5jdGlvbiggYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlKCkge1xuXHRcdFx0dmFyIG5vZGUgPSAoIGZyYWdtZW50ID0gdGhpcyApLm5vZGUsXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGZyYWdtZW50Lm5hbWVzcGFjZSxcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50Lm5hbWUsXG5cdFx0XHRcdHZhbHVlID0gZnJhZ21lbnQudmFsdWUsXG5cdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQuZnJhZ21lbnQ7XG5cdFx0XHRpZiAoIG5hbWVzcGFjZSApIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyggbmFtZXNwYWNlLCBuYW1lLCAoIGZyYWdtZW50IHx8IHZhbHVlICkudG9TdHJpbmcoKSApO1xuXHRcdFx0fSBlbHNlIGlmICggIWJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoIG5hbWUsICggZnJhZ21lbnQgfHwgdmFsdWUgKS50b1N0cmluZygpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCBuYW1lLCAnJyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBib29sZWFuQXR0cmlidXRlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgbm9vcCwgdXBkYXRlU2VsZWN0VmFsdWUsIHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUsIHVwZGF0ZVJhZGlvTmFtZSwgdXBkYXRlUmFkaW9WYWx1ZSwgdXBkYXRlQ2hlY2tib3hOYW1lLCB1cGRhdGVDbGFzc05hbWUsIHVwZGF0ZUlkQXR0cmlidXRlLCB1cGRhdGVJRVN0eWxlQXR0cmlidXRlLCB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSwgdXBkYXRlVmFsdWUsIHVwZGF0ZUJvb2xlYW4sIHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGUoKSB7XG5cdFx0XHR2YXIgbmFtZSA9ICggbm9kZSA9IHRoaXMgKS5uYW1lLFxuXHRcdFx0XHRlbGVtZW50ID0gbm9kZS5lbGVtZW50LFxuXHRcdFx0XHRub2RlID0gbm9kZS5ub2RlLFxuXHRcdFx0XHR0eXBlLCB1cGRhdGVNZXRob2Q7XG5cdFx0XHRpZiAoIG5hbWUgPT09ICdpZCcgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlkQXR0cmlidXRlO1xuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gc2VsZWN0c1xuXHRcdFx0XHRpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgJiYgbmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApID8gdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA6IHVwZGF0ZVNlbGVjdFZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICd0ZXh0YXJlYScgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyApIHtcblx0XHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRcdC8vIHR5cGU9J2ZpbGUnIHZhbHVlPSd7e2ZpbGVMaXN0fX0nPlxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2ZpbGUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9vcDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAncmFkaW8nICYmIGVsZW1lbnQuYmluZGluZyAmJiBlbGVtZW50LmJpbmRpbmcubmFtZSA9PT0gJ25hbWUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9WYWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnR3b3dheSAmJiBuYW1lID09PSAnbmFtZScgKSB7XG5cdFx0XHRcdGlmICggbm9kZS50eXBlID09PSAncmFkaW8nICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvTmFtZTtcblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS50eXBlID09PSAnY2hlY2tib3gnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNoZWNrYm94TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ3N0eWxlJyAmJiBub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdjbGFzcycgJiYgKCAhbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDbGFzc05hbWU7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnVzZVByb3BlcnR5ICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVCb29sZWFuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdXBkYXRlTWV0aG9kICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVFdmVyeXRoaW5nRWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlID0gdXBkYXRlTWV0aG9kO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBub29wLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9OYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNsYXNzTmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQm9vbGVhbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL19BdHRyaWJ1dGUuanMgKi9cblx0dmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBidWJibGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIEF0dHJpYnV0ZTtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlQXR0cmlidXRlcy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBBdHRyaWJ1dGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHR2YXIgbmFtZSwgYXR0cmlidXRlLCByZXN1bHQgPSBbXTtcblx0XHRcdGZvciAoIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cmlidXRlc1sgbmFtZSBdLFxuXHRcdFx0XHRcdFx0cm9vdDogZWxlbWVudC5yb290XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCByZXN1bHRbIG5hbWUgXSA9IGF0dHJpYnV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIEF0dHJpYnV0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9Db25kaXRpb25hbEF0dHJpYnV0ZS9fQ29uZGl0aW9uYWxBdHRyaWJ1dGUuanMgKi9cblx0dmFyIENvbmRpdGlvbmFsQXR0cmlidXRlID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50LCB0b0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBGcmFnbWVudCwgZGl2O1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdGRpdiA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0fVxuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0dmFyIENvbmRpdGlvbmFsQXR0cmlidXRlID0gZnVuY3Rpb24oIGVsZW1lbnQsIHRlbXBsYXRlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHJvb3Q6IGVsZW1lbnQucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdHRlbXBsYXRlOiBbIHRlbXBsYXRlIF1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5lbGVtZW50LmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oIG5vZGUgKSB7XG5cdFx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0XHRcdHRoaXMuaXNTdmcgPSBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmc7XG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHN0ciwgYXR0cnM7XG5cdFx0XHRcdHN0ciA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdFx0YXR0cnMgPSBwYXJzZUF0dHJpYnV0ZXMoIHN0ciwgdGhpcy5pc1N2ZyApO1xuXHRcdFx0XHQvLyBhbnkgYXR0cmlidXRlcyB0aGF0IHByZXZpb3VzbHkgZXhpc3RlZCBidXQgbm8gbG9uZ2VyIGRvXG5cdFx0XHRcdC8vIG11c3QgYmUgcmVtb3ZlZFxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90SW4oIGF0dHJzLCBhICk7XG5cdFx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHR0aGlzJDAubm9kZS5yZW1vdmVBdHRyaWJ1dGUoIGEubmFtZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGF0dHJzLmZvckVhY2goIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRcdHRoaXMkMC5ub2RlLnNldEF0dHJpYnV0ZSggYS5uYW1lLCBhLnZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cnM7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBDb25kaXRpb25hbEF0dHJpYnV0ZTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyggc3RyLCBpc1N2ZyApIHtcblx0XHRcdHZhciB0YWcgPSBpc1N2ZyA/ICdzdmcnIDogJ2Rpdic7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gJzwnICsgdGFnICsgJyAnICsgc3RyICsgJz48LycgKyB0YWcgKyAnPic7XG5cdFx0XHRyZXR1cm4gdG9BcnJheSggZGl2LmNoaWxkTm9kZXNbIDAgXS5hdHRyaWJ1dGVzICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90SW4oIGhheXN0YWNrLCBuZWVkbGUgKSB7XG5cdFx0XHR2YXIgaSA9IGhheXN0YWNrLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIGhheXN0YWNrWyBpIF0ubmFtZSA9PT0gbmVlZGxlLm5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjaXJjdWxhciwgbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCwgdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBDb25kaXRpb25hbEF0dHJpYnV0ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgYXR0cmlidXRlcyApIHtcblx0XHRcdGlmICggIWF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhdHRyaWJ1dGVzLm1hcCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQ29uZGl0aW9uYWxBdHRyaWJ1dGUoIGVsZW1lbnQsIGEgKTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBDb25kaXRpb25hbEF0dHJpYnV0ZSApO1xuXG5cdC8qIHV0aWxzL2V4dGVuZC5qcyAqL1xuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHR2YXIgc291cmNlcyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHByb3AsIHNvdXJjZTtcblx0XHR3aGlsZSAoIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKSApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xuXHRcdFx0XHRpZiAoIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRcdHRhcmdldFsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9CaW5kaW5nLmpzICovXG5cdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGludGVycG9sYXRvciwga2V5cGF0aCwgdmFsdWU7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbIHRoaXMubmFtZSB8fCAndmFsdWUnIF07XG5cdFx0XHRpbnRlcnBvbGF0b3IgPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3I7XG5cdFx0XHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cdFx0XHRpZiAoIGludGVycG9sYXRvci5rZXlwYXRoICYmIGludGVycG9sYXRvci5rZXlwYXRoLnN1YnN0ciggMCwgMiApID09PSAnJHsnICkge1xuXHRcdFx0XHR3YXJuKCAnVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCBleHByZXNzaW9ucyAoYCcgKyBpbnRlcnBvbGF0b3Iua2V5cGF0aC5zbGljZSggMiwgLTEgKSArICdgKScgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQSBtdXN0YWNoZSBtYXkgYmUgKmFtYmlndW91cyouIExldCdzIHNheSB3ZSB3ZXJlIGdpdmVuXG5cdFx0XHQvLyBgdmFsdWU9XCJ7e2Jhcn19XCJgLiBJZiB0aGUgY29udGV4dCB3YXMgYGZvb2AsIGFuZCBgZm9vLmJhcmBcblx0XHRcdC8vICp3YXNuJ3QqIGB1bmRlZmluZWRgLCB0aGUga2V5cGF0aCB3b3VsZCBiZSBgZm9vLmJhcmAuXG5cdFx0XHQvLyBUaGVuLCBhbnkgdXNlciBpbnB1dCB3b3VsZCByZXN1bHQgaW4gYGZvby5iYXJgIGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gSWYsIGhvd2V2ZXIsIGBmb28uYmFyYCAqd2FzKiB1bmRlZmluZWQsIGFuZCBzbyB3YXMgYGJhcmAsIHdlIHdvdWxkIGJlXG5cdFx0XHQvLyBsZWZ0IHdpdGggYW4gdW5yZXNvbHZlZCBwYXJ0aWFsIGtleXBhdGggLSBzbyB3ZSBhcmUgZm9yY2VkIHRvIG1ha2UgYW5cblx0XHRcdC8vIGFzc3VtcHRpb24uIFRoYXQgYXNzdW1wdGlvbiBpcyB0aGF0IHRoZSBpbnB1dCBpbiBxdWVzdGlvbiBzaG91bGRcblx0XHRcdC8vIGJlIGZvcmNlZCB0byByZXNvbHZlIHRvIGBiYXJgLCBhbmQgYW55IHVzZXIgaW5wdXQgd291bGQgYWZmZWN0IGBiYXJgXG5cdFx0XHQvLyBhbmQgbm90IGBmb28uYmFyYC5cblx0XHRcdC8vXG5cdFx0XHQvLyBEaWQgdGhhdCBtYWtlIGFueSBzZW5zZT8gTm8/IE9oLiBTb3JyeS4gV2VsbCB0aGUgbW9yYWwgb2YgdGhlIHN0b3J5IGlzXG5cdFx0XHQvLyBiZSBleHBsaWNpdCB3aGVuIHVzaW5nIHR3by13YXkgZGF0YS1iaW5kaW5nIGFib3V0IHdoYXQga2V5cGF0aCB5b3UncmVcblx0XHRcdC8vIHVwZGF0aW5nLiBVc2luZyBpdCBpbiBsaXN0cyBpcyBwcm9iYWJseSBhIHJlY2lwZSBmb3IgY29uZnVzaW9uLi4uXG5cdFx0XHRpZiAoICFpbnRlcnBvbGF0b3Iua2V5cGF0aCApIHtcblx0XHRcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoO1xuXHRcdFx0Ly8gaW5pdGlhbGlzZSB2YWx1ZSwgaWYgaXQncyB1bmRlZmluZWRcblx0XHRcdGlmICggdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0QmluZGluZy5wcm90b3R5cGUgPSB7XG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHRoaXMuZ2V0VmFsdWUoKSApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJvdW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGJpbmRpbmdzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuXHRcdFx0XHRuZXdLZXlwYXRoID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLmtleXBhdGg7XG5cdFx0XHRcdC8vIFRoZSBhdHRyaWJ1dGUgdGhpcyBiaW5kaW5nIGlzIGxpbmtlZCB0byBoYXMgYWxyZWFkeSBkb25lIHRoZSB3b3JrXG5cdFx0XHRcdGlmICggb2xkS2V5cGF0aCA9PT0gbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBvbGRLZXlwYXRoIF0sIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBuZXdLZXlwYXRoIF0gfHwgKCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBuZXdLZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblx0XHRCaW5kaW5nLmV4dGVuZCA9IGZ1bmN0aW9uKCBwcm9wZXJ0aWVzICkge1xuXHRcdFx0dmFyIFBhcmVudCA9IHRoaXMsXG5cdFx0XHRcdFNwZWNpYWxpc2VkQmluZGluZztcblx0XHRcdFNwZWNpYWxpc2VkQmluZGluZyA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0XHRCaW5kaW5nLmNhbGwoIHRoaXMsIGVsZW1lbnQgKTtcblx0XHRcdFx0aWYgKCB0aGlzLmluaXQgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRleHRlbmQoIFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUsIHByb3BlcnRpZXMgKTtcblx0XHRcdFNwZWNpYWxpc2VkQmluZGluZy5leHRlbmQgPSBCaW5kaW5nLmV4dGVuZDtcblx0XHRcdHJldHVybiBTcGVjaWFsaXNlZEJpbmRpbmc7XG5cdFx0fTtcblx0XHRyZXR1cm4gQmluZGluZztcblx0fSggcnVubG9vcCwgd2FybiwgY3JlYXRlLCBleHRlbmQsIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL3NoYXJlZC9oYW5kbGVEb21FdmVudC5qcyAqL1xuXHR2YXIgaGFuZGxlRG9tRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG5cdFx0dGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NvbnRlbnRFZGl0YWJsZUJpbmRpbmcuanMgKi9cblx0dmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ29udGVudEVkaXRhYmxlQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZyYWdtZW50ID8gdGhpcy5lbGVtZW50LmZyYWdtZW50LnRvU3RyaW5nKCkgOiAnJztcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5yb290LmxhenkgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuaW5uZXJIVE1MO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gQ29udGVudEVkaXRhYmxlQmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9zaGFyZWQvZ2V0U2libGluZ3MuanMgKi9cblx0dmFyIGdldFNpYmxpbmdzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc2V0cyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRTaWJsaW5ncyggaWQsIGdyb3VwLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGhhc2ggPSBpZCArIGdyb3VwICsga2V5cGF0aDtcblx0XHRcdHJldHVybiBzZXRzWyBoYXNoIF0gfHwgKCBzZXRzWyBoYXNoIF0gPSBbXSApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9SYWRpb0JpbmRpbmcuanMgKi9cblx0dmFyIFJhZGlvQmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGdldFNpYmxpbmdzLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBSYWRpb0JpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ2NoZWNrZWQnLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAncmFkaW8nLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLmZvckVhY2goIGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KCBiaW5kaW5nLmtleXBhdGgsIGJpbmRpbmcuZ2V0VmFsdWUoKSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIFJhZGlvQmluZGluZztcblx0fSggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9SYWRpb05hbWVCaW5kaW5nLmpzICovXG5cdHZhciBSYWRpb05hbWVCaW5kaW5nID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQsIGdldFNpYmxpbmdzICkge1xuXG5cdFx0dmFyIFJhZGlvTmFtZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ25hbWUnLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAncmFkaW9uYW1lJywgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0XHR0aGlzLnJhZGlvTmFtZSA9IHRydWU7XG5cdFx0XHRcdC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLnR3b3dheSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY2hlY2tlZCcgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5uYW1lID0gJ3t7JyArIHRoaXMua2V5cGF0aCArICd9fSc7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKSA9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRyZXR1cm4gbm9kZS5fcmFjdGl2ZSA/IG5vZGUuX3JhY3RpdmUudmFsdWUgOiBub2RlLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcblx0XHRcdFx0Ly8gYG5hbWVgIGtleXBhdGggZ2V0cyBzZXQgdG8gaXRzIHZhbHVlXG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZCApIHtcblx0XHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVib3VuZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLnJlYm91bmQuY2FsbCggdGhpcywgaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlICkge1xuXHRcdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBSYWRpb05hbWVCaW5kaW5nO1xuXHR9KCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50LCBnZXRTaWJsaW5ncyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NoZWNrYm94TmFtZUJpbmRpbmcuanMgKi9cblx0dmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBmdW5jdGlvbiggaXNBcnJheSwgYXJyYXlDb250YWlucywgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ2hlY2tib3hOYW1lQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRuYW1lOiAnbmFtZScsXG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgZ3JvdXAgKG9mIGlucHV0cyB0aGF0XG5cdFx0XHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuXHRcdFx0XHQvLyBpc24ndCBhbiBpbml0aWFsIHZhbHVlLiBCeSB0aGUgc2FtZSB0b2tlbiwgd2UgY2FuIG1ha2Vcblx0XHRcdFx0Ly8gYSBub3RlIG9mIHRoYXQgZmFjdCB0aGF0IHRoZXJlIHdhcyBubyBpbml0aWFsIHZhbHVlLFxuXHRcdFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcblx0XHRcdFx0Ly8gZXhpc3QgKHdoaWNoIHVzZXJzIHNob3VsZCBhdm9pZCwgYnV0IHdoaWNoIHdlIHNob3VsZFxuXHRcdFx0XHQvLyBzdXBwb3J0IGFueXdheSB0byBhdm9pZCBicmVha2luZyBleHBlY3RhdGlvbnMpXG5cdFx0XHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWU7XG5cdFx0XHRcdHRoaXMuY2hlY2tib3hOYW1lID0gdHJ1ZTtcblx0XHRcdFx0Ly8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUudHdvd2F5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gd2Ugc2V0IHRoaXMgcHJvcGVydHkgc28gdGhhdCB0aGUgYXR0cmlidXRlIGdldHMgdGhlIGNvcnJlY3QgdXBkYXRlIG1ldGhvZFxuXHRcdFx0XHQvLyBFYWNoIGlucHV0IGhhcyBhIHJlZmVyZW5jZSB0byBhbiBhcnJheSBjb250YWluaW5nIGl0IGFuZCBpdHNcblx0XHRcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG5cdFx0XHRcdC8vIHRoZSBzdGF0dXMgb2YgYWxsIGlucHV0cyB3aXRoaW4gdGhlIGdyb3VwXG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAnY2hlY2tib3hlcycsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0aWYgKCB0aGlzLm5vSW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIG5vIGluaXRpYWwgdmFsdWUgd2FzIHNldCwgYW5kIHRoaXMgaW5wdXQgaXMgY2hlY2tlZCwgd2Vcblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBtb2RlbFxuXHRcdFx0XHRpZiAoIHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICkgKSB7XG5cdFx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0ZXhpc3RpbmdWYWx1ZS5wdXNoKCBiaW5kaW5nVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG5cdFx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXHRcdFx0XHRleGlzdGluZ1ZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdGlmICggaXNBcnJheSggZXhpc3RpbmdWYWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gYXJyYXlDb250YWlucyggZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBleGlzdGluZ1ZhbHVlID09IGJpbmRpbmdWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5pc0NoZWNrZWQ7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIElFIGVtZXJnZW5jeSwgYmluZCB0byBjbGljayBldmVudCBhcyB3ZWxsXG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zaWJsaW5ncy5maWx0ZXIoIGlzQ2hlY2tlZCApLm1hcCggZ2V0VmFsdWUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRmdW5jdGlvbiBpc0NoZWNrZWQoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gQ2hlY2tib3hOYW1lQmluZGluZztcblx0fSggaXNBcnJheSwgYXJyYXlDb250YWlucywgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveEJpbmRpbmcuanMgKi9cblx0dmFyIENoZWNrYm94QmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBDaGVja2JveEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ2NoZWNrZWQnLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gQ2hlY2tib3hCaW5kaW5nO1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL1NlbGVjdEJpbmRpbmcuanMgKi9cblx0dmFyIFNlbGVjdEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgU2VsZWN0QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuXHRcdFx0XHRcdGxlbiwgaSwgdmFsdWUsIG9wdGlvbldhc1NlbGVjdGVkO1xuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGlmICggIWxlbiApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdGFrZSB0aGUgZmluYWwgc2VsZWN0ZWQgb3B0aW9uLi4uXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJyApICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb3IgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24sIGlmIG5vbmUgYXJlIHNlbGVjdGVkXG5cdFx0XHRcdGlmICggIW9wdGlvbldhc1NlbGVjdGVkICkge1xuXHRcdFx0XHRcdHdoaWxlICggKytpIDwgbGVuICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIChha2EgaGFjaykgdGhhdCBhbGxvd3MgdXMgdG8gZm9yZ28gc29tZVxuXHRcdFx0XHQvLyBvdGhlciBtb3JlIGV4cGVuc2l2ZSB3b3JrXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cmlidXRlcy52YWx1ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVE9ETyB0aGlzIG1ldGhvZCBpcyBhbiBhbm9tYWx5Li4uIGlzIGl0IG5lY2Vzc2FyeT9cblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucywgaSwgbGVuLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcblx0XHRcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgaSBdLnNlbGVjdGVkICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBTZWxlY3RCaW5kaW5nO1xuXHR9KCBydW5sb29wLCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHV0aWxzL2FycmF5Q29udGVudHNNYXRjaC5qcyAqL1xuXHR2YXIgYXJyYXlDb250ZW50c01hdGNoID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdGlmICggIWlzQXJyYXkoIGEgKSB8fCAhaXNBcnJheSggYiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGEubGVuZ3RoICE9PSBiLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggYVsgaSBdICE9PSBiWyBpIF0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KCBpc0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvTXVsdGlwbGVTZWxlY3RCaW5kaW5nLmpzICovXG5cdHZhciBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgYXJyYXlDb250ZW50c01hdGNoLCBTZWxlY3RCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBTZWxlY3RCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vcHRpb25zLmZpbHRlciggZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJyApO1xuXHRcdFx0XHR9ICkubWFwKCBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWVGcm9tTW9kZWw7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0dmFsdWVGcm9tTW9kZWwgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggdmFsdWVGcm9tTW9kZWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBnZXQgdmFsdWUgZnJvbSBET00sIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVDaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVE9ETyBub3QgaW1wbGVtZW50ZWQgeWV0JyApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNlbGVjdGVkVmFsdWVzLCBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRcdHNlbGVjdGVkVmFsdWVzID0gW107XG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuXHRcdFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0XHRcdHNlbGVjdGVkVmFsdWVzLnB1c2goIG9wdGlvblZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZWxlY3RlZFZhbHVlcztcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlLCBwcmV2aW91c1ZhbHVlLCB2YWx1ZTtcblx0XHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG5cdFx0XHRcdHByZXZpb3VzVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHByZXZpb3VzVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhYXJyYXlDb250ZW50c01hdGNoKCB2YWx1ZSwgcHJldmlvdXNWYWx1ZSApICkge1xuXHRcdFx0XHRcdFNlbGVjdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlTW9kZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlLnZhbHVlID09PSB1bmRlZmluZWQgfHwgIXRoaXMuYXR0cmlidXRlLnZhbHVlLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB0aGlzLmluaXRpYWxWYWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBNdWx0aXBsZVNlbGVjdEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIGFycmF5Q29udGVudHNNYXRjaCwgU2VsZWN0QmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9GaWxlTGlzdEJpbmRpbmcuanMgKi9cblx0dmFyIEZpbGVMaXN0QmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBGaWxlTGlzdEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmZpbGVzO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gRmlsZUxpc3RCaW5kaW5nO1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0dlbmVyaWNCaW5kaW5nLmpzICovXG5cdHZhciBHZW5lcmljQmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgR2VuZXJpY0JpbmRpbmcsIGdldE9wdGlvbnM7XG5cdFx0Z2V0T3B0aW9ucyA9IHtcblx0XHRcdGV2YWx1YXRlV3JhcHBlZDogdHJ1ZVxuXHRcdH07XG5cdFx0R2VuZXJpY0JpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoICF0aGlzLnJvb3QubGF6eSApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IEdlbmVyaWNCaW5kaW5nO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGhhbmRsZURvbUV2ZW50LmNhbGwoIHRoaXMgKTtcblx0XHRcdHZhbHVlID0gdGhpcy5fcmFjdGl2ZS5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMuX3JhY3RpdmUuYmluZGluZy5rZXlwYXRoLCBnZXRPcHRpb25zICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL051bWVyaWNCaW5kaW5nLmpzICovXG5cdHZhciBOdW1lcmljQmluZGluZyA9IGZ1bmN0aW9uKCBHZW5lcmljQmluZGluZyApIHtcblxuXHRcdHJldHVybiBHZW5lcmljQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KCB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZSApO1xuXHRcdFx0XHRyZXR1cm4gaXNOYU4oIHZhbHVlICkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0oIEdlbmVyaWNCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZVR3b3dheUJpbmRpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcgPSBmdW5jdGlvbiggbG9nLCBDb250ZW50RWRpdGFibGVCaW5kaW5nLCBSYWRpb0JpbmRpbmcsIFJhZGlvTmFtZUJpbmRpbmcsIENoZWNrYm94TmFtZUJpbmRpbmcsIENoZWNrYm94QmluZGluZywgU2VsZWN0QmluZGluZywgTXVsdGlwbGVTZWxlY3RCaW5kaW5nLCBGaWxlTGlzdEJpbmRpbmcsIE51bWVyaWNCaW5kaW5nLCBHZW5lcmljQmluZGluZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcyxcblx0XHRcdFx0dHlwZSwgQmluZGluZywgYmluZE5hbWUsIGJpbmRDaGVja2VkO1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGxhdGUgYmluZGluZywgYW5kIHRoZXJlJ3MgYWxyZWFkeSBvbmUsIGl0XG5cdFx0XHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cblx0XHRcdGlmICggZWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcblx0XHRcdFx0ZWxlbWVudC5iaW5kaW5nID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnRlbnRlZGl0YWJsZVxuXHRcdFx0aWYgKCAvLyBpZiB0aGUgY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZSBpcyB0cnVlIG9yIGlzIGJpbmRhYmxlIGFuZCBtYXkgdGh1cyBiZWNvbWUgdHJ1ZVxuXHRcdFx0XHQoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApIHx8ICEhYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgJiYgaXNCaW5kYWJsZSggYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgKSApICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgKSB7XG5cdFx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnICkge1xuXHRcdFx0XHRcdGJpbmROYW1lID0gaXNCaW5kYWJsZSggYXR0cmlidXRlcy5uYW1lICk7XG5cdFx0XHRcdFx0YmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLmNoZWNrZWQgKTtcblx0XHRcdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIGJpbmQgdGhlIG5hbWUgYXR0cmlidXRlLCBvciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aFxuXHRcdFx0XHRcdGlmICggYmluZE5hbWUgJiYgYmluZENoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ2JhZFJhZGlvSW5wdXRCaW5kaW5nJ1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGJpbmROYW1lICkge1xuXHRcdFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09ICdyYWRpbycgPyBSYWRpb05hbWVCaW5kaW5nIDogQ2hlY2tib3hOYW1lQmluZGluZztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBiaW5kQ2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAncmFkaW8nID8gUmFkaW9CaW5kaW5nIDogQ2hlY2tib3hCaW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2ZpbGUnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHRCaW5kaW5nID0gRmlsZUxpc3RCaW5kaW5nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdyYW5nZScgPyBOdW1lcmljQmluZGluZyA6IEdlbmVyaWNCaW5kaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgPyBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgOiBTZWxlY3RCaW5kaW5nO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IEdlbmVyaWNCaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBCaW5kaW5nICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJpbmRpbmcoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNCaW5kYWJsZSggYXR0cmlidXRlICkge1xuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCaW5kYWJsZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBsb2csIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcsIFJhZGlvQmluZGluZywgUmFkaW9OYW1lQmluZGluZywgQ2hlY2tib3hOYW1lQmluZGluZywgQ2hlY2tib3hCaW5kaW5nLCBTZWxlY3RCaW5kaW5nLCBNdWx0aXBsZVNlbGVjdEJpbmRpbmcsIEZpbGVMaXN0QmluZGluZywgTnVtZXJpY0JpbmRpbmcsIEdlbmVyaWNCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGJ1YmJsZSA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRidWJibGUoKSB7XG5cdFx0dmFyIGhhc0FjdGlvbiA9IHRoaXMuZ2V0QWN0aW9uKCk7XG5cdFx0aWYgKCBoYXNBY3Rpb24gJiYgIXRoaXMuaGFzTGlzdGVuZXIgKSB7XG5cdFx0XHR0aGlzLmxpc3RlbigpO1xuXHRcdH0gZWxzZSBpZiAoICFoYXNBY3Rpb24gJiYgdGhpcy5oYXNMaXN0ZW5lciApIHtcblx0XHRcdHRoaXMudW5yZW5kZXIoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvZmlyZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlID0gZnVuY3Rpb24oIGZpcmVFdmVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZmlyZSggZXZlbnQgKSB7XG5cdFx0XHRmaXJlRXZlbnQoIHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwge1xuXHRcdFx0XHRldmVudDogZXZlbnRcblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9nZXRBY3Rpb24uanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkZ2V0QWN0aW9uID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGdldEFjdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hY3Rpb24udG9TdHJpbmcoKS50cmltKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRpbml0ID0gZnVuY3Rpb24oIGdldEZ1bmN0aW9uRnJvbVN0cmluZywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGNpcmN1bGFyLCBmaXJlRXZlbnQsIGxvZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucyA9IHtcblx0XHRcdFx0YXJnczogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGV2ZW50UGF0dGVybiA9IC9eZXZlbnQoPzpcXC4oLispKT8vO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkaW5pdCggZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHRoaXMsXG5cdFx0XHRcdGFjdGlvbiwgcmVmcywgcmFjdGl2ZTtcblx0XHRcdGhhbmRsZXIuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRoYW5kbGVyLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRoYW5kbGVyLm5hbWUgPSBuYW1lO1xuXHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoICcqJyApICE9PSAtMSApIHtcblx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHRoaXMucm9vdC5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9FbGVtZW50UHJveHlFdmVudFdpbGRjYXJkcycsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudC50YWdOYW1lLFxuXHRcdFx0XHRcdFx0ZXZlbnQ6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5pbnZhbGlkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggdGVtcGxhdGUubSApIHtcblx0XHRcdFx0cmVmcyA9IHRlbXBsYXRlLmEucjtcblx0XHRcdFx0Ly8gVGhpcyBpcyBhIG1ldGhvZCBjYWxsXG5cdFx0XHRcdGhhbmRsZXIubWV0aG9kID0gdGVtcGxhdGUubTtcblx0XHRcdFx0aGFuZGxlci5rZXlwYXRocyA9IFtdO1xuXHRcdFx0XHRoYW5kbGVyLmZuID0gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKCB0ZW1wbGF0ZS5hLnMsIHJlZnMubGVuZ3RoICk7XG5cdFx0XHRcdGhhbmRsZXIucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0XHRyYWN0aXZlID0gaGFuZGxlci5yb290O1xuXHRcdFx0XHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuXHRcdFx0XHRoYW5kbGVyLnJlZlJlc29sdmVycyA9IHJlZnMubWFwKCBmdW5jdGlvbiggcmVmLCBpICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSB0aGUgYGV2ZW50YCBvYmplY3Rcblx0XHRcdFx0XHRpZiAoIG1hdGNoID0gZXZlbnRQYXR0ZXJuLmV4ZWMoIHJlZiApICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlci5rZXlwYXRoc1sgaSBdID0ge1xuXHRcdFx0XHRcdFx0XHRldmVudE9iamVjdDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0cmVmaW5lbWVudHM6IG1hdGNoWyAxIF0gPyBtYXRjaFsgMSBdLnNwbGl0KCAnLicgKSA6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggaGFuZGxlciwgcmVmLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIucmVzb2x2ZSggaSwga2V5cGF0aCApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlTWV0aG9kQ2FsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEdldCBhY3Rpb24gKCdmb28nIGluICdvbi1jbGljaz0nZm9vJylcblx0XHRcdFx0YWN0aW9uID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRhY3Rpb24gPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiBhY3Rpb24sXG5cdFx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFjdGlvbiA9IGFjdGlvbjtcblx0XHRcdFx0Ly8gR2V0IHBhcmFtZXRlcnNcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZS5kICkge1xuXHRcdFx0XHRcdHRoaXMuZHluYW1pY1BhcmFtcyA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoUGFyYW1zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGZpcmVNZXRob2RDYWxsKCBldmVudCApIHtcblx0XHRcdHZhciByYWN0aXZlLCB2YWx1ZXMsIGFyZ3M7XG5cdFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXHRcdFx0aWYgKCB0eXBlb2YgcmFjdGl2ZVsgdGhpcy5tZXRob2QgXSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIGNhbGwgYSBub24tZXhpc3RlbnQgbWV0aG9kIChcIicgKyB0aGlzLm1ldGhvZCArICdcIiknICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmtleXBhdGhzLm1hcCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgbGVuLCBpO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBub3QgeWV0IHJlc29sdmVkXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUT0RPIHRoZSByZWZpbmVtZW50cyBzdHVmZiB3b3VsZCBiZSBiZXR0ZXIgaGFuZGxlZCBhdCBwYXJzZSB0aW1lXG5cdFx0XHRcdGlmICgga2V5cGF0aC5ldmVudE9iamVjdCApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGV2ZW50O1xuXHRcdFx0XHRcdGlmICggbGVuID0ga2V5cGF0aC5yZWZpbmVtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlWyBrZXlwYXRoLnJlZmluZW1lbnRzWyBpIF0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9ICk7XG5cdFx0XHRyYWN0aXZlLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHRhcmdzID0gdGhpcy5mbi5hcHBseSggbnVsbCwgdmFsdWVzICk7XG5cdFx0XHRyYWN0aXZlWyB0aGlzLm1ldGhvZCBdLmFwcGx5KCByYWN0aXZlLCBhcmdzICk7XG5cdFx0XHRkZWxldGUgcmFjdGl2ZS5ldmVudDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRXaXRoUGFyYW1zKCBldmVudCApIHtcblx0XHRcdGZpcmVFdmVudCggdGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7XG5cdFx0XHRcdGV2ZW50OiBldmVudCxcblx0XHRcdFx0YXJnczogdGhpcy5wYXJhbXNcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcyggZXZlbnQgKSB7XG5cdFx0XHR2YXIgYXJncyA9IHRoaXMuZHluYW1pY1BhcmFtcy5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHQvLyBuZWVkIHRvIHN0cmlwIFtdIGZyb20gZW5kcyBpZiBhIHN0cmluZyFcblx0XHRcdGlmICggdHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRhcmdzID0gYXJncy5zdWJzdHIoIDEsIGFyZ3MubGVuZ3RoIC0gMiApO1xuXHRcdFx0fVxuXHRcdFx0ZmlyZUV2ZW50KCB0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHtcblx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRhcmdzOiBhcmdzXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgY2lyY3VsYXIsIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCwgbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9zaGFyZWQvZ2VuZXJpY0hhbmRsZXIuanMgKi9cblx0dmFyIGdlbmVyaWNIYW5kbGVyID0gZnVuY3Rpb24gZ2VuZXJpY0hhbmRsZXIoIGV2ZW50ICkge1xuXHRcdHZhciBzdG9yYWdlLCBoYW5kbGVyO1xuXHRcdHN0b3JhZ2UgPSB0aGlzLl9yYWN0aXZlO1xuXHRcdGhhbmRsZXIgPSBzdG9yYWdlLmV2ZW50c1sgZXZlbnQudHlwZSBdO1xuXHRcdGhhbmRsZXIuZmlyZSgge1xuXHRcdFx0bm9kZTogdGhpcyxcblx0XHRcdG9yaWdpbmFsOiBldmVudCxcblx0XHRcdGluZGV4OiBzdG9yYWdlLmluZGV4LFxuXHRcdFx0a2V5cGF0aDogc3RvcmFnZS5rZXlwYXRoLFxuXHRcdFx0Y29udGV4dDogc3RvcmFnZS5yb290LmdldCggc3RvcmFnZS5rZXlwYXRoIClcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvbGlzdGVuLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGxpc3RlbiA9IGZ1bmN0aW9uKCBjb25maWcsIGdlbmVyaWNIYW5kbGVyLCBsb2cgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGN1c3RvbUhhbmRsZXJzID0ge30sXG5cdFx0XHR0b3VjaEV2ZW50cyA9IHtcblx0XHRcdFx0dG91Y2hzdGFydDogdHJ1ZSxcblx0XHRcdFx0dG91Y2htb3ZlOiB0cnVlLFxuXHRcdFx0XHR0b3VjaGVuZDogdHJ1ZSxcblx0XHRcdFx0dG91Y2hjYW5jZWw6IHRydWUsXG5cdFx0XHRcdC8vbm90IHczYywgYnV0IHN1cHBvcnRlZCBpbiBzb21lIGJyb3dzZXJzXG5cdFx0XHRcdHRvdWNobGVhdmU6IHRydWVcblx0XHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkbGlzdGVuKCkge1xuXHRcdFx0dmFyIGRlZmluaXRpb24sIG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHRpZiAoIHRoaXMuaW52YWxpZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkZWZpbml0aW9uID0gY29uZmlnLnJlZ2lzdHJpZXMuZXZlbnRzLmZpbmQoIHRoaXMucm9vdCwgbmFtZSApICkge1xuXHRcdFx0XHR0aGlzLmN1c3RvbSA9IGRlZmluaXRpb24oIHRoaXMubm9kZSwgZ2V0Q3VzdG9tSGFuZGxlciggbmFtZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN0YW5kYXJkIERPTSBldmVudC4uLiBidXQgbGV0J3MgY2hlY2tcblx0XHRcdFx0aWYgKCAhKCAnb24nICsgbmFtZSBpbiB0aGlzLm5vZGUgKSAmJiAhKCB3aW5kb3cgJiYgJ29uJyArIG5hbWUgaW4gd2luZG93ICkgKSB7XG5cdFx0XHRcdFx0Ly8gb2theSB0byB1c2UgdG91Y2ggZXZlbnRzIGlmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlbVxuXHRcdFx0XHRcdGlmICggIXRvdWNoRXZlbnRzWyBuYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHRoaXMucm9vdC5kZWJ1Zyxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ21pc3NpbmdQbHVnaW4nLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cGx1Z2luOiAnZXZlbnQnLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoIG5hbWUsIGdlbmVyaWNIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oYXNMaXN0ZW5lciA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldEN1c3RvbUhhbmRsZXIoIG5hbWUgKSB7XG5cdFx0XHRpZiAoICFjdXN0b21IYW5kbGVyc1sgbmFtZSBdICkge1xuXHRcdFx0XHRjdXN0b21IYW5kbGVyc1sgbmFtZSBdID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdHZhciBzdG9yYWdlID0gZXZlbnQubm9kZS5fcmFjdGl2ZTtcblx0XHRcdFx0XHRldmVudC5pbmRleCA9IHN0b3JhZ2UuaW5kZXg7XG5cdFx0XHRcdFx0ZXZlbnQua2V5cGF0aCA9IHN0b3JhZ2Uua2V5cGF0aDtcblx0XHRcdFx0XHRldmVudC5jb250ZXh0ID0gc3RvcmFnZS5yb290LmdldCggc3RvcmFnZS5rZXlwYXRoICk7XG5cdFx0XHRcdFx0c3RvcmFnZS5ldmVudHNbIG5hbWUgXS5maXJlKCBldmVudCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGN1c3RvbUhhbmRsZXJzWyBuYW1lIF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY29uZmlnLCBnZW5lcmljSGFuZGxlciwgbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlYmluZCA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHR2YXIgZnJhZ21lbnQ7XG5cdFx0aWYgKCB0aGlzLm1ldGhvZCApIHtcblx0XHRcdGZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHRoaXMuYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHJlYmluZCggdGhpcy5hY3Rpb24gKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmR5bmFtaWNQYXJhbXMgKSB7XG5cdFx0XHRyZWJpbmQoIHRoaXMuZHluYW1pY1BhcmFtcyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlYmluZCggdGhpbmcgKSB7XG5cdFx0XHR0aGluZyAmJiB0aGluZy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVuZGVyID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlbmRlcigpIHtcblx0XHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG5cdFx0Ly8gdW5pdmVyc2FsIGhhbmRsZXJcblx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuZXZlbnRzWyB0aGlzLm5hbWUgXSA9IHRoaXM7XG5cdFx0aWYgKCB0aGlzLm1ldGhvZCB8fCB0aGlzLmdldEFjdGlvbigpICkge1xuXHRcdFx0dGhpcy5saXN0ZW4oKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvcmVzb2x2ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZXNvbHZlID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlc29sdmUoIGluZGV4LCBrZXlwYXRoICkge1xuXHRcdHRoaXMua2V5cGF0aHNbIGluZGV4IF0gPSBrZXlwYXRoO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bmJpbmQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bmJpbmQoKSB7XG5cdFx0XHRpZiAoIHRoaXMubWV0aG9kICkge1xuXHRcdFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgbmFtZVxuXHRcdFx0aWYgKCB0eXBlb2YgdGhpcy5hY3Rpb24gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLmFjdGlvbi51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdC8vIFRlYXIgZG93biBkeW5hbWljIHBhcmFtZXRlcnNcblx0XHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggeCApIHtcblx0XHRcdHgudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVucmVuZGVyID0gZnVuY3Rpb24oIGdlbmVyaWNIYW5kbGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bnJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5jdXN0b20gKSB7XG5cdFx0XHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggdGhpcy5uYW1lLCBnZW5lcmljSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFzTGlzdGVuZXIgPSBmYWxzZTtcblx0XHR9O1xuXHR9KCBnZW5lcmljSGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvX0V2ZW50SGFuZGxlci5qcyAqL1xuXHR2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oIGJ1YmJsZSwgZmlyZSwgZ2V0QWN0aW9uLCBpbml0LCBsaXN0ZW4sIHJlYmluZCwgcmVuZGVyLCByZXNvbHZlLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApIHtcblx0XHRcdHRoaXMuaW5pdCggZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUgKTtcblx0XHR9O1xuXHRcdEV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGZpcmU6IGZpcmUsXG5cdFx0XHRnZXRBY3Rpb246IGdldEFjdGlvbixcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRsaXN0ZW46IGxpc3Rlbixcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBFdmVudEhhbmRsZXI7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGZpcmUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkZ2V0QWN0aW9uLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkbGlzdGVuLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVzb2x2ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5yZW5kZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlRXZlbnRIYW5kbGVycy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uKCBFdmVudEhhbmRsZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGksIG5hbWUsIG5hbWVzLCBoYW5kbGVyLCByZXN1bHQgPSBbXTtcblx0XHRcdGZvciAoIG5hbWUgaW4gdGVtcGxhdGUgKSB7XG5cdFx0XHRcdGlmICggdGVtcGxhdGUuaGFzT3duUHJvcGVydHkoIG5hbWUgKSApIHtcblx0XHRcdFx0XHRuYW1lcyA9IG5hbWUuc3BsaXQoICctJyApO1xuXHRcdFx0XHRcdGkgPSBuYW1lcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlciggZWxlbWVudCwgbmFtZXNbIGkgXSwgdGVtcGxhdGVbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIGhhbmRsZXIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fSggRXZlbnRIYW5kbGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0RlY29yYXRvci9fRGVjb3JhdG9yLmpzICovXG5cdHZhciBEZWNvcmF0b3IgPSBmdW5jdGlvbiggbG9nLCBjaXJjdWxhciwgY29uZmlnICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBnZXRWYWx1ZU9wdGlvbnMsIERlY29yYXRvcjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdGdldFZhbHVlT3B0aW9ucyA9IHtcblx0XHRcdGFyZ3M6IHRydWVcblx0XHR9O1xuXHRcdERlY29yYXRvciA9IGZ1bmN0aW9uKCBlbGVtZW50LCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBkZWNvcmF0b3IgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblx0XHRcdGRlY29yYXRvci5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdGRlY29yYXRvci5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcblx0XHRcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IG5hbWUsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0ZGVjb3JhdG9yLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS5kICkge1xuXHRcdFx0XHRkZWNvcmF0b3IuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0ZGVjb3JhdG9yLnBhcmFtcyA9IGRlY29yYXRvci5mcmFnbWVudC5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHRcdGRlY29yYXRvci5mcmFnbWVudC5idWJibGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0ZGVjb3JhdG9yLnBhcmFtcyA9IHRoaXMuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRcdGlmICggZGVjb3JhdG9yLnJlYWR5ICkge1xuXHRcdFx0XHRcdFx0ZGVjb3JhdG9yLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGRlY29yYXRvci5mbiA9IGNvbmZpZy5yZWdpc3RyaWVzLmRlY29yYXRvcnMuZmluZCggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCAhZGVjb3JhdG9yLmZuICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cGx1Z2luOiAnZGVjb3JhdG9yJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdERlY29yYXRvci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRlY29yYXRvciA9IHRoaXMsXG5cdFx0XHRcdFx0bm9kZSwgcmVzdWx0LCBhcmdzO1xuXHRcdFx0XHRub2RlID0gZGVjb3JhdG9yLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0aWYgKCBkZWNvcmF0b3IucGFyYW1zICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBbIG5vZGUgXS5jb25jYXQoIGRlY29yYXRvci5wYXJhbXMgKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkZWNvcmF0b3IuZm4uYXBwbHkoIGRlY29yYXRvci5yb290LCBhcmdzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGVjb3JhdG9yLmZuLmNhbGwoIGRlY29yYXRvci5yb290LCBub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhcmVzdWx0IHx8ICFyZXN1bHQudGVhcmRvd24gKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRGVjb3JhdG9yIGRlZmluaXRpb24gbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYSB0ZWFyZG93biBtZXRob2QnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgbWFrZSBzZW5zZT9cblx0XHRcdFx0ZGVjb3JhdG9yLmFjdHVhbCA9IHJlc3VsdDtcblx0XHRcdFx0ZGVjb3JhdG9yLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYWN0dWFsLnVwZGF0ZSApIHtcblx0XHRcdFx0XHR0aGlzLmFjdHVhbC51cGRhdGUuYXBwbHkoIHRoaXMucm9vdCwgdGhpcy5wYXJhbXMgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93biggdHJ1ZSApO1xuXHRcdFx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCB1cGRhdGluZyApIHtcblx0XHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oKTtcblx0XHRcdFx0aWYgKCAhdXBkYXRpbmcgJiYgdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gRGVjb3JhdG9yO1xuXHR9KCBsb2csIGNpcmN1bGFyLCBjb25maWcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9zZWxlY3Qvc3luYy5qcyAqL1xuXHR2YXIgc3luYyA9IGZ1bmN0aW9uKCB0b0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gc3luY1NlbGVjdCggc2VsZWN0RWxlbWVudCApIHtcblx0XHRcdHZhciBzZWxlY3ROb2RlLCBzZWxlY3RWYWx1ZSwgaXNNdWx0aXBsZSwgb3B0aW9ucywgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cdFx0XHRzZWxlY3ROb2RlID0gc2VsZWN0RWxlbWVudC5ub2RlO1xuXHRcdFx0aWYgKCAhc2VsZWN0Tm9kZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IHRvQXJyYXkoIHNlbGVjdE5vZGUub3B0aW9ucyApO1xuXHRcdFx0c2VsZWN0VmFsdWUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICk7XG5cdFx0XHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuXHRcdFx0Ly8gdGhlc2Ugb3B0aW9uc1xuXHRcdFx0aWYgKCBzZWxlY3RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRvcHRpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuXHRcdFx0XHRcdHNob3VsZFNlbGVjdCA9IGlzTXVsdGlwbGUgPyB2YWx1ZUNvbnRhaW5zKCBzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUgKSA6IHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlO1xuXHRcdFx0XHRcdGlmICggc2hvdWxkU2VsZWN0ICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvLnNlbGVjdGVkID0gc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggIW9wdGlvbldhc1NlbGVjdGVkICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgMCBdICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc1sgMCBdLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHNlbGVjdEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHZhbHVlQ29udGFpbnMoIHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSApIHtcblx0XHRcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VsZWN0VmFsdWVbIGkgXSA9PSBvcHRpb25WYWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHRvQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9zZWxlY3QvYnViYmxlLmpzICovXG5cdHZhciBidWJibGUgPSBmdW5jdGlvbiggcnVubG9vcCwgc3luY1NlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBidWJibGVTZWxlY3QoKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG5cdFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c3luY1NlbGVjdCggdGhpcyQwICk7XG5cdFx0XHRcdFx0dGhpcyQwLmRpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgc3luYyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL29wdGlvbi9maW5kUGFyZW50U2VsZWN0LmpzICovXG5cdHZhciBmaW5kUGFyZW50U2VsZWN0ID0gZnVuY3Rpb24gZmluZFBhcmVudFNlbGVjdCggZWxlbWVudCApIHtcblx0XHRkbyB7XG5cdFx0XHRpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9vcHRpb24vaW5pdC5qcyAqL1xuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCBmaW5kUGFyZW50U2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGluaXRPcHRpb24oIG9wdGlvbiwgdGVtcGxhdGUgKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ID0gZmluZFBhcmVudFNlbGVjdCggb3B0aW9uLnBhcmVudCApO1xuXHRcdFx0Ly8gd2UgbWlnaHQgYmUgaW5zaWRlIGEgPGRhdGFsaXN0PiBlbGVtZW50XG5cdFx0XHRpZiAoICFvcHRpb24uc2VsZWN0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaCggb3B0aW9uICk7XG5cdFx0XHQvLyBJZiB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIG1pc3NpbmcsIHVzZSB0aGUgZWxlbWVudCdzIGNvbnRlbnRcblx0XHRcdGlmICggIXRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHRlbXBsYXRlLmEgPSB7fTtcblx0XHRcdH1cblx0XHRcdC8vIC4uLmFzIGxvbmcgYXMgaXQgaXNuJ3QgZGlzYWJsZWRcblx0XHRcdGlmICggdGVtcGxhdGUuYS52YWx1ZSA9PT0gdW5kZWZpbmVkICYmICF0ZW1wbGF0ZS5hLmhhc093blByb3BlcnR5KCAnZGlzYWJsZWQnICkgKSB7XG5cdFx0XHRcdHRlbXBsYXRlLmEudmFsdWUgPSB0ZW1wbGF0ZS5mO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgYnV0IHRoZSA8c2VsZWN0PlxuXHRcdFx0Ly8gYWxyZWFkeSBoYXMgYSB2YWx1ZSwgZGVsZXRlIGl0XG5cdFx0XHRpZiAoICdzZWxlY3RlZCcgaW4gdGVtcGxhdGUuYSAmJiBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRlbGV0ZSB0ZW1wbGF0ZS5hLnNlbGVjdGVkO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGZpbmRQYXJlbnRTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCBlbmZvcmNlQ2FzZSwgY3JlYXRlQXR0cmlidXRlcywgY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzLCBjcmVhdGVUd293YXlCaW5kaW5nLCBjcmVhdGVFdmVudEhhbmRsZXJzLCBEZWNvcmF0b3IsIGJ1YmJsZVNlbGVjdCwgaW5pdE9wdGlvbiwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gRWxlbWVudCRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3M7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5FTEVNRU5UO1xuXHRcdFx0Ly8gc3R1ZmYgd2UnbGwgbmVlZCBsYXRlclxuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UoIHRlbXBsYXRlLmUgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+IGVsZW1lbnRzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdGluaXRPcHRpb24oIHRoaXMsIHRlbXBsYXRlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMgPSBbXTtcblx0XHRcdFx0dGhpcy5idWJibGUgPSBidWJibGVTZWxlY3Q7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlcyggdGhpcywgdGVtcGxhdGUuYSApO1xuXHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMoIHRoaXMsIHRlbXBsYXRlLm0gKTtcblx0XHRcdC8vIGFwcGVuZCBjaGlsZHJlbiwgaWYgdGhlcmUgYXJlIGFueVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5mICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmYsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0XHRwRWxlbWVudDogdGhpc1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgdHdvd2F5IGJpbmRpbmdcblx0XHRcdGlmICggcmFjdGl2ZS50d293YXkgJiYgKCBiaW5kaW5nID0gY3JlYXRlVHdvd2F5QmluZGluZyggdGhpcywgdGVtcGxhdGUuYSApICkgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG5cdFx0XHRcdC8vIHJlZ2lzdGVyIHRoaXMgd2l0aCB0aGUgcm9vdCwgc28gdGhhdCB3ZSBjYW4gZG8gcmFjdGl2ZS51cGRhdGVNb2RlbCgpXG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF0gfHwgKCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBiaW5kaW5nLmtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSBldmVudCBwcm94aWVzXG5cdFx0XHRpZiAoIHRlbXBsYXRlLnYgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycyA9IGNyZWF0ZUV2ZW50SGFuZGxlcnMoIHRoaXMsIHRlbXBsYXRlLnYgKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSBkZWNvcmF0b3Jcblx0XHRcdGlmICggdGVtcGxhdGUubyApIHtcblx0XHRcdFx0dGhpcy5kZWNvcmF0b3IgPSBuZXcgRGVjb3JhdG9yKCB0aGlzLCB0ZW1wbGF0ZS5vICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgdHJhbnNpdGlvbnNcblx0XHRcdHRoaXMuaW50cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MTtcblx0XHRcdHRoaXMub3V0cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50Mjtcblx0XHR9O1xuXHR9KCB0eXBlcywgZW5mb3JjZUNhc2UsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUF0dHJpYnV0ZXMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlVHdvd2F5QmluZGluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlRXZlbnRIYW5kbGVycywgRGVjb3JhdG9yLCBidWJibGUsIGluaXQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvc3RhcnRzV2l0aC5qcyAqL1xuXHR2YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzdGFydHNXaXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0ID09PSBrZXlwYXRoIHx8IHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKTtcblx0XHR9O1xuXHR9KCBzdGFydHNXaXRoS2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2Fzc2lnbk5ld0tleXBhdGguanMgKi9cblx0dmFyIGFzc2lnbk5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhc3NpZ25OZXdLZXlwYXRoKCB0YXJnZXQsIHByb3BlcnR5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGV4aXN0aW5nS2V5cGF0aCA9IHRhcmdldFsgcHJvcGVydHkgXTtcblx0XHRcdGlmICggIWV4aXN0aW5nS2V5cGF0aCB8fCBzdGFydHNXaXRoKCBleGlzdGluZ0tleXBhdGgsIG5ld0tleXBhdGggKSB8fCAhc3RhcnRzV2l0aCggZXhpc3RpbmdLZXlwYXRoLCBvbGRLZXlwYXRoICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRhcmdldFsgcHJvcGVydHkgXSA9IGdldE5ld0tleXBhdGgoIGV4aXN0aW5nS2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGgsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBhc3NpZ25OZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgaSwgc3RvcmFnZSwgbGl2ZVF1ZXJpZXMsIHJhY3RpdmU7XG5cdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlcyApIHtcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcyApIHtcblx0XHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciApIHtcblx0XHRcdFx0cmViaW5kKCB0aGlzLmRlY29yYXRvciApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmViaW5kIGNoaWxkcmVuXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHJlYmluZCggdGhpcy5mcmFnbWVudCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVXBkYXRlIGxpdmUgcXVlcmllcywgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoIGxpdmVRdWVyaWVzID0gdGhpcy5saXZlUXVlcmllcyApIHtcblx0XHRcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblx0XHRcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0bGl2ZVF1ZXJpZXNbIGkgXS5fbWFrZURpcnR5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ub2RlICYmICggc3RvcmFnZSA9IHRoaXMubm9kZS5fcmFjdGl2ZSApICkge1xuXHRcdFx0XHQvLyBhZGp1c3Qga2V5cGF0aCBpZiBuZWVkZWRcblx0XHRcdFx0YXNzaWduTmV3S2V5cGF0aCggc3RvcmFnZSwgJ2tleXBhdGgnLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW5kZXhSZWYgIT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHN0b3JhZ2UuaW5kZXhbIGluZGV4UmVmIF0gPSBuZXdJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZWJpbmQoIHRoaW5nICkge1xuXHRcdFx0XHR0aGluZy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGFzc2lnbk5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9pbWcvcmVuZGVyLmpzICovXG5cdHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJJbWFnZSggaW1nICkge1xuXHRcdHZhciBsb2FkSGFuZGxlcjtcblx0XHQvLyBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heSBuZWVkIHRvIHByZXZlbnQgaXRcblx0XHQvLyBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcblx0XHRpZiAoIGltZy5hdHRyaWJ1dGVzLndpZHRoIHx8IGltZy5hdHRyaWJ1dGVzLmhlaWdodCApIHtcblx0XHRcdGltZy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHdpZHRoID0gaW1nLmdldEF0dHJpYnV0ZSggJ3dpZHRoJyApLFxuXHRcdFx0XHRcdGhlaWdodCA9IGltZy5nZXRBdHRyaWJ1dGUoICdoZWlnaHQnICk7XG5cdFx0XHRcdGlmICggd2lkdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoICd3aWR0aCcsIHdpZHRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBoZWlnaHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoICdoZWlnaHQnLCBoZWlnaHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbWcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIGxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fSwgZmFsc2UgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGluaXQgPSBmdW5jdGlvbiggbG9nLCBjb25maWcsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBnZXRWYWx1ZU9wdGlvbnMgPSB7fTtcblx0XHQvLyBUT0RPIHdoYXQgYXJlIHRoZSBvcHRpb25zP1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyYW5zaXRpb24kaW5pdCggZWxlbWVudCwgdGVtcGxhdGUsIGlzSW50cm8gKSB7XG5cdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXHRcdFx0dC5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHQucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0LmlzSW50cm8gPSBpc0ludHJvO1xuXHRcdFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRpZiAoIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0dC5uYW1lID0gbmFtZTtcblx0XHRcdGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0dC5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIHdheSB0byBpbnRlcnByZXQgZHluYW1pYyBhcmd1bWVudHMgd2l0aG91dCBhbGwgdGhlXG5cdFx0XHRcdC8vICdkZXBlbmRlbmN5IHRocmFzaGluZyc/XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHQucGFyYW1zID0gZnJhZ21lbnQuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdHQuX2ZuID0gY29uZmlnLnJlZ2lzdHJpZXMudHJhbnNpdGlvbnMuZmluZCggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCAhdC5fZm4gKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRwbHVnaW46ICd0cmFuc2l0aW9uJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGxvZywgY29uZmlnLCBjaXJjdWxhciApO1xuXG5cdC8qIHV0aWxzL2NhbWVsQ2FzZS5qcyAqL1xuXHR2YXIgY2FtZWxDYXNlID0gZnVuY3Rpb24oIGh5cGhlbmF0ZWRTdHIgKSB7XG5cdFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSggLy0oW2EtekEtWl0pL2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRyZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy9wcmVmaXguanMgKi9cblx0dmFyIHByZWZpeCA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlICkge1xuXG5cdFx0dmFyIHByZWZpeCwgcHJlZml4Q2FjaGUsIHRlc3RTdHlsZTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdHByZWZpeCA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByZWZpeENhY2hlID0ge307XG5cdFx0XHR0ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApLnN0eWxlO1xuXHRcdFx0cHJlZml4ID0gZnVuY3Rpb24oIHByb3AgKSB7XG5cdFx0XHRcdHZhciBpLCB2ZW5kb3IsIGNhcHBlZDtcblx0XHRcdFx0cHJvcCA9IGNhbWVsQ2FzZSggcHJvcCApO1xuXHRcdFx0XHRpZiAoICFwcmVmaXhDYWNoZVsgcHJvcCBdICkge1xuXHRcdFx0XHRcdGlmICggdGVzdFN0eWxlWyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdHByZWZpeENhY2hlWyBwcm9wIF0gPSBwcm9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB0ZXN0IHZlbmRvcnMuLi5cblx0XHRcdFx0XHRcdGNhcHBlZCA9IHByb3AuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKCAxICk7XG5cdFx0XHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgdmVuZG9yICsgY2FwcGVkIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVsgcHJvcCBdID0gdmVuZG9yICsgY2FwcGVkO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcmVmaXhDYWNoZVsgcHJvcCBdO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWZpeDtcblx0fSggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9nZXRTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kZ2V0U3R5bGUgPSBmdW5jdGlvbiggbGVnYWN5LCBpc0NsaWVudCwgaXNBcnJheSwgcHJlZml4ICkge1xuXG5cdFx0dmFyIGdldFN0eWxlLCBnZXRDb21wdXRlZFN0eWxlO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Z2V0U3R5bGUgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cdFx0XHRnZXRTdHlsZSA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGNvbXB1dGVkU3R5bGUsIHN0eWxlcywgaSwgcHJvcCwgdmFsdWU7XG5cdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVsgcHJlZml4KCBwcm9wcyApIF07XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBwcm9wcyApICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RyYW5zaXRpb24kZ2V0U3R5bGUgbXVzdCBiZSBwYXNzZWQgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIENTUyBwcm9wZXJ0aWVzJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlcyA9IHt9O1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRwcm9wID0gcHJvcHNbIGkgXTtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcCApIF07XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0eWxlc1sgcHJvcCBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0eWxlcztcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBnZXRTdHlsZTtcblx0fSggbGVnYWN5LCBpc0NsaWVudCwgaXNBcnJheSwgcHJlZml4ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3NldFN0eWxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzZXRTdHlsZSA9IGZ1bmN0aW9uKCBwcmVmaXggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0eWxlLCB2YWx1ZSApIHtcblx0XHRcdHZhciBwcm9wO1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbIHByZWZpeCggc3R5bGUgKSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHN0eWxlICkge1xuXHRcdFx0XHRcdGlmICggc3R5bGUuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IHN0eWxlWyBwcm9wIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KCBwcmVmaXggKTtcblxuXHQvKiBzaGFyZWQvVGlja2VyLmpzICovXG5cdHZhciBUaWNrZXIgPSBmdW5jdGlvbiggd2FybiwgZ2V0VGltZSwgYW5pbWF0aW9ucyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgVGlja2VyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZWFzaW5nO1xuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHR0aGlzLnN0ZXAgPSBvcHRpb25zLnN0ZXA7XG5cdFx0XHR0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblx0XHRcdC8vIGVhc2luZ1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLnJvb3QuZWFzaW5nWyBvcHRpb25zLmVhc2luZyBdO1xuXHRcdFx0XHRpZiAoICFlYXNpbmcgKSB7XG5cdFx0XHRcdFx0d2FybiggJ01pc3NpbmcgZWFzaW5nIGZ1bmN0aW9uIChcIicgKyBvcHRpb25zLmVhc2luZyArICdcIikuIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiBmcm9tIFtUT0RPXScgKTtcblx0XHRcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVhc2luZyA9IGVhc2luZztcblx0XHRcdHRoaXMuc3RhcnQgPSBnZXRUaW1lKCk7XG5cdFx0XHR0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdGFuaW1hdGlvbnMuYWRkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRUaWNrZXIucHJvdG90eXBlID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oIG5vdyApIHtcblx0XHRcdFx0dmFyIGVsYXBzZWQsIGVhc2VkO1xuXHRcdFx0XHRpZiAoICF0aGlzLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbm93ID4gdGhpcy5lbmQgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0ZXAoIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb21wbGV0ZSggMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxhcHNlZCA9IG5vdyAtIHRoaXMuc3RhcnQ7XG5cdFx0XHRcdGVhc2VkID0gdGhpcy5lYXNpbmcoIGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uICk7XG5cdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdHRoaXMuc3RlcCggZWFzZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmFib3J0ICkge1xuXHRcdFx0XHRcdHRoaXMuYWJvcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gVGlja2VyO1xuXG5cdFx0ZnVuY3Rpb24gbGluZWFyKCB0ICkge1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggd2FybiwgZ2V0VGltZSwgYW5pbWF0aW9ucyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvdW5wcmVmaXguanMgKi9cblx0dmFyIHVucHJlZml4ID0gZnVuY3Rpb24oIHZlbmRvcnMgKSB7XG5cblx0XHR2YXIgdW5wcmVmaXhQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14tKD86JyArIHZlbmRvcnMuam9pbiggJ3wnICkgKyAnKS0nICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwcm9wICkge1xuXHRcdFx0cmV0dXJuIHByb3AucmVwbGFjZSggdW5wcmVmaXhQYXR0ZXJuLCAnJyApO1xuXHRcdH07XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9oZWxwZXJzL2h5cGhlbmF0ZS5qcyAqL1xuXHR2YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24oIHZlbmRvcnMgKSB7XG5cblx0XHR2YXIgdmVuZG9yUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKD86JyArIHZlbmRvcnMuam9pbiggJ3wnICkgKyAnKShbQS1aXSknICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHR2YXIgaHlwaGVuYXRlZDtcblx0XHRcdGlmICggIXN0ciApIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2ZW5kb3JQYXR0ZXJuLnRlc3QoIHN0ciApICkge1xuXHRcdFx0XHRzdHIgPSAnLScgKyBzdHI7XG5cdFx0XHR9XG5cdFx0XHRoeXBoZW5hdGVkID0gc3RyLnJlcGxhY2UoIC9bQS1aXS9nLCBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGh5cGhlbmF0ZWQ7XG5cdFx0fTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9hbmltYXRlU3R5bGUvY3JlYXRlVHJhbnNpdGlvbnMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgd2FybiwgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlLCBpbnRlcnBvbGF0ZSwgVGlja2VyLCBwcmVmaXgsIHVucHJlZml4LCBoeXBoZW5hdGUgKSB7XG5cblx0XHR2YXIgY3JlYXRlVHJhbnNpdGlvbnMsIHRlc3RTdHlsZSwgVFJBTlNJVElPTiwgVFJBTlNJVElPTkVORCwgQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQsIFRSQU5TSVRJT05fRFVSQVRJT04sIFRSQU5TSVRJT05fUFJPUEVSVFksIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OLCBjYW5Vc2VDc3NUcmFuc2l0aW9ucyA9IHt9LFxuXHRcdFx0Y2Fubm90VXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKS5zdHlsZTtcblx0XHRcdC8vIGRldGVybWluZSBzb21lIGZhY3RzIGFib3V0IG91ciBlbnZpcm9ubWVudFxuXHRcdFx0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0ZXN0U3R5bGUudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG5cdFx0XHRcdFx0VFJBTlNJVElPTkVORCA9ICd0cmFuc2l0aW9uZW5kJztcblx0XHRcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRlc3RTdHlsZS53ZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0VFJBTlNJVElPTiA9ICd3ZWJraXRUcmFuc2l0aW9uJztcblx0XHRcdFx0XHRUUkFOU0lUSU9ORU5EID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KCkgKTtcblx0XHRcdGlmICggVFJBTlNJVElPTiApIHtcblx0XHRcdFx0VFJBTlNJVElPTl9EVVJBVElPTiA9IFRSQU5TSVRJT04gKyAnRHVyYXRpb24nO1xuXHRcdFx0XHRUUkFOU0lUSU9OX1BST1BFUlRZID0gVFJBTlNJVElPTiArICdQcm9wZXJ0eSc7XG5cdFx0XHRcdFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OID0gVFJBTlNJVElPTiArICdUaW1pbmdGdW5jdGlvbic7XG5cdFx0XHR9XG5cdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCB0LCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUgKSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiZWF0IChvdGhlcndpc2UgdGhlIHRhcmdldCBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIGltbWVkaWF0ZWx5KVxuXHRcdFx0XHQvLyBUT0RPIHVzZSBhIGZhc3Rkb20tc3R5bGUgbWVjaGFuaXNtP1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaGFzaFByZWZpeCwganNUcmFuc2l0aW9uc0NvbXBsZXRlLCBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlLCBjaGVja0NvbXBsZXRlLCB0cmFuc2l0aW9uRW5kSGFuZGxlcjtcblx0XHRcdFx0XHRjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGpzVHJhbnNpdGlvbnNDb21wbGV0ZSAmJiBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0XHQvLyB3aWxsIGNoYW5nZXMgdG8gZXZlbnRzIGFuZCBmaXJlIGhhdmUgYW4gdW5leHBlY3RlZCBjb25zZXF1ZW5jZSBoZXJlP1xuXHRcdFx0XHRcdFx0XHR0LnJvb3QuZmlyZSggdC5uYW1lICsgJzplbmQnLCB0Lm5vZGUsIHQuaXNJbnRybyApO1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHQvLyB0aGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBlbGVtZW50cyBjYW4gdXNlIENTUyB0byBhbmltYXRlXG5cdFx0XHRcdFx0Ly8gd2hpY2ggcHJvcGVydGllc1xuXHRcdFx0XHRcdGhhc2hQcmVmaXggPSAoIHQubm9kZS5uYW1lc3BhY2VVUkkgfHwgJycgKSArIHQubm9kZS50YWdOYW1lO1xuXHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgVFJBTlNJVElPTl9QUk9QRVJUWSBdID0gY2hhbmdlZFByb3BlcnRpZXMubWFwKCBwcmVmaXggKS5tYXAoIGh5cGhlbmF0ZSApLmpvaW4oICcsJyApO1xuXHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gXSA9IGh5cGhlbmF0ZSggb3B0aW9ucy5lYXNpbmcgfHwgJ2xpbmVhcicgKTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fRFVSQVRJT04gXSA9IG9wdGlvbnMuZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXHRcdFx0XHRcdHRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKCBjYW1lbENhc2UoIHVucHJlZml4KCBldmVudC5wcm9wZXJ0eU5hbWUgKSApICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHN0aWxsIHRyYW5zaXRpb25pbmcuLi5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIgaSA9IGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0aGFzaCwgb3JpZ2luYWxWYWx1ZSwgaW5kZXgsIHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzID0gW10sXG5cdFx0XHRcdFx0XHRcdHByb3AsIHN1ZmZpeDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRwcm9wID0gY2hhbmdlZFByb3BlcnRpZXNbIGkgXTtcblx0XHRcdFx0XHRcdFx0aGFzaCA9IGhhc2hQcmVmaXggKyBwcm9wO1xuXHRcdFx0XHRcdFx0XHRpZiAoIENTU19UUkFOU0lUSU9OU19FTkFCTEVEICYmICFjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IHN1cmUgaWYgQ1NTIHRyYW5zaXRpb25zIGFyZSBzdXBwb3J0ZWQgZm9yXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyB0YWcvcHJvcGVydHkgY29tYm8sIGZpbmQgb3V0IG5vd1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIWNhblVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZSggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhpcyBwcm9wZXJ0eSBpcyB0cmFuc2l0aW9uYWJsZSBpbiB0aGlzIGJyb3dzZXIsXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBzdHlsZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXQgc3R5bGVcblx0XHRcdFx0XHRcdFx0XHRcdGNhblVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gPSB0LmdldFN0eWxlKCBwcm9wICkgIT0gdG9bIHByb3AgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gPSAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJlc2V0LCBpZiB3ZSdyZSBnb2luZyB0byB1c2UgdGltZXJzIGFmdGVyIGFsbFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBvcmlnaW5hbFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoICFDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCB8fCBjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRpbWVyLWJhc2VkIHN0dWZmXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBvcmlnaW5hbFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZSggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBuZWVkIHRvIHJlbW92ZSB0aGlzIGZyb20gY2hhbmdlZFByb3BlcnRpZXMsIG90aGVyd2lzZSB0cmFuc2l0aW9uRW5kSGFuZGxlclxuXHRcdFx0XHRcdFx0XHRcdC8vIHdpbGwgZ2V0IGNvbmZ1c2VkXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3YXJuKCAnU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZCB3aXRoIHRyYW5zaXRpb25zLiBJZiB5b3Ugc2VlIHRoaXMgbWVzc2FnZSwgcGxlYXNlIGxldCBAUmFjdGl2ZUpTIGtub3cuIFRoYW5rcyEnICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGFuaW1hdGFibGUgYXQgYWxsXG5cdFx0XHRcdFx0XHRcdFx0c3VmZml4ID0gL1teXFxkXSokLy5leGVjKCB0b1sgcHJvcCBdIClbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi50aGVuIGtpY2sgb2ZmIGEgdGltZXItYmFzZWQgdHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHByZWZpeCggcHJvcCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yOiBpbnRlcnBvbGF0ZSggcGFyc2VGbG9hdCggb3JpZ2luYWxWYWx1ZSApLCBwYXJzZUZsb2F0KCB0b1sgcHJvcCBdICkgKSxcblx0XHRcdFx0XHRcdFx0XHRcdHN1ZmZpeDogc3VmZml4XG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBqYXZhc2NyaXB0IHRyYW5zaXRpb25zXG5cdFx0XHRcdFx0XHRpZiAoIHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0bmV3IFRpY2tlcigge1xuXHRcdFx0XHRcdFx0XHRcdHJvb3Q6IHQucm9vdCxcblx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmc6IGNhbWVsQ2FzZSggb3B0aW9ucy5lYXNpbmcgfHwgJycgKSxcblx0XHRcdFx0XHRcdFx0XHRzdGVwOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHByb3AsIGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcC5pbnRlcnBvbGF0b3IoIHBvcyApICsgcHJvcC5zdWZmaXg7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBhbmQgZGVhbCB3aXRoXG5cdFx0XHRcdFx0XHRcdC8vIHRoZSBmYWN0IHRoYXQgaXQgd2lsbCBuZXZlciBmaXJlXG5cdFx0XHRcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCAwICk7XG5cdFx0XHRcdH0sIG9wdGlvbnMuZGVsYXkgfHwgMCApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZVRyYW5zaXRpb25zO1xuXHR9KCBpc0NsaWVudCwgd2FybiwgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlLCBpbnRlcnBvbGF0ZSwgVGlja2VyLCBwcmVmaXgsIHVucHJlZml4LCBoeXBoZW5hdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL3Zpc2liaWxpdHkuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5ID0gZnVuY3Rpb24oIHZlbmRvcnMgKSB7XG5cblx0XHR2YXIgaGlkZGVuLCB2ZW5kb3IsIHByZWZpeCwgaSwgdmlzaWJpbGl0eTtcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRoaWRkZW4gPSAnaGlkZGVuJztcblx0XHRcdHZpc2liaWxpdHkgPSB7fTtcblx0XHRcdGlmICggaGlkZGVuIGluIGRvY3VtZW50ICkge1xuXHRcdFx0XHRwcmVmaXggPSAnJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSB2ZW5kb3JzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1sgaSBdO1xuXHRcdFx0XHRcdGhpZGRlbiA9IHZlbmRvciArICdIaWRkZW4nO1xuXHRcdFx0XHRcdGlmICggaGlkZGVuIGluIGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0cHJlZml4ID0gdmVuZG9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBwcmVmaXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggcHJlZml4ICsgJ3Zpc2liaWxpdHljaGFuZ2UnLCBvbkNoYW5nZSApO1xuXHRcdFx0XHQvLyBpbml0aWFsaXNlXG5cdFx0XHRcdG9uQ2hhbmdlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBnYWgsIHdlJ3JlIGluIGFuIG9sZCBicm93c2VyXG5cdFx0XHRcdGlmICggJ29uZm9jdXNvdXQnIGluIGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1c291dCcsIG9uSGlkZSApO1xuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1c2luJywgb25TaG93ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdwYWdlaGlkZScsIG9uSGlkZSApO1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsIG9uSGlkZSApO1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncGFnZXNob3cnLCBvblNob3cgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3VzJywgb25TaG93ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkNoYW5nZSgpIHtcblx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZG9jdW1lbnRbIGhpZGRlbiBdO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uSGlkZSgpIHtcblx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblNob3coKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmlzaWJpbGl0eTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9hbmltYXRlU3R5bGUvX2FuaW1hdGVTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX19hbmltYXRlU3R5bGUgPSBmdW5jdGlvbiggbGVnYWN5LCBpc0NsaWVudCwgd2FybiwgUHJvbWlzZSwgcHJlZml4LCBjcmVhdGVUcmFuc2l0aW9ucywgdmlzaWJpbGl0eSApIHtcblxuXHRcdHZhciBhbmltYXRlU3R5bGUsIGdldENvbXB1dGVkU3R5bGUsIHJlc29sdmVkO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0YW5pbWF0ZVN0eWxlID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXHRcdFx0YW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24oIHN0eWxlLCB2YWx1ZSwgb3B0aW9ucywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcyxcblx0XHRcdFx0XHR0bztcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gcGFnZSBpc24ndCB2aXNpYmxlLiBEb24ndCBhbmltYXRlIGFueXRoaW5nLCBiZWNhdXNlXG5cdFx0XHRcdC8vIHRoYXQgd2F5IHlvdSdsbCBuZXZlciBnZXQgQ1NTIHRyYW5zaXRpb25lbmQgZXZlbnRzXG5cdFx0XHRcdGlmICggdmlzaWJpbGl0eS5oaWRkZW4gKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRTdHlsZSggc3R5bGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc29sdmVkIHx8ICggcmVzb2x2ZWQgPSBQcm9taXNlLnJlc29sdmUoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR0byA9IHt9O1xuXHRcdFx0XHRcdHRvWyBzdHlsZSBdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG8gPSBzdHlsZTtcblx0XHRcdFx0XHQvLyBzaHVmZmxlIGFyZ3VtZW50c1xuXHRcdFx0XHRcdGNvbXBsZXRlID0gb3B0aW9ucztcblx0XHRcdFx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQXMgb2YgMC4zLjksIHRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgc3VwcGx5IGFuIGBvcHRpb25gIG9iamVjdCB3aXRoXG5cdFx0XHRcdC8vIGBkdXJhdGlvbmAgYW5kIGBlYXNpbmdgIHByb3BlcnRpZXMgKGFuZCBvcHRpb25hbCBgZGVsYXlgKSwgcGx1cyBhXG5cdFx0XHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcblx0XHRcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG5cdFx0XHRcdGlmICggIW9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0d2FybiggJ1RoZSBcIicgKyB0Lm5hbWUgKyAnXCIgdHJhbnNpdGlvbiBkb2VzIG5vdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gYHQuYW5pbWF0ZVN0eWxlKClgLiBUaGlzIHdpbGwgYnJlYWsgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzLzM0MCcgKTtcblx0XHRcdFx0XHRvcHRpb25zID0gdDtcblx0XHRcdFx0XHRjb21wbGV0ZSA9IHQuY29tcGxldGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIHJlc29sdmUgKSB7XG5cdFx0XHRcdFx0dmFyIHByb3BlcnR5TmFtZXMsIGNoYW5nZWRQcm9wZXJ0aWVzLCBjb21wdXRlZFN0eWxlLCBjdXJyZW50LCBmcm9tLCBpLCBwcm9wO1xuXHRcdFx0XHRcdC8vIEVkZ2UgY2FzZSAtIGlmIGR1cmF0aW9uIGlzIHplcm8sIHNldCBzdHlsZSBzeW5jaHJvbm91c2x5IGFuZCBjb21wbGV0ZVxuXHRcdFx0XHRcdGlmICggIW9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHRcdFx0XHR0LnNldFN0eWxlKCB0byApO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBHZXQgYSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHdlJ3JlIGFuaW1hdGluZ1xuXHRcdFx0XHRcdHByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyggdG8gKTtcblx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcyA9IFtdO1xuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBjdXJyZW50IHN0eWxlc1xuXHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0Lm5vZGUgKTtcblx0XHRcdFx0XHRmcm9tID0ge307XG5cdFx0XHRcdFx0aSA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnR5TmFtZXNbIGkgXTtcblx0XHRcdFx0XHRcdGN1cnJlbnQgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgoIHByb3AgKSBdO1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50ID09PSAnMHB4JyApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGtub3cgaWYgd2UncmUgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmdcblx0XHRcdFx0XHRcdGlmICggY3VycmVudCAhPSB0b1sgcHJvcCBdICkge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgIT0gaW5zdGVhZCBvZiAhPT0sIHNvIHdlIGNhbiBjb21wYXJlIHN0cmluZ3Mgd2l0aCBudW1iZXJzXG5cdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnB1c2goIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0Ly8gbWFrZSB0aGUgY29tcHV0ZWQgc3R5bGUgZXhwbGljaXQsIHNvIHdlIGNhbiBhbmltYXRlIHdoZXJlXG5cdFx0XHRcdFx0XHRcdC8vIGUuZy4gaGVpZ2h0PSdhdXRvJ1xuXHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3QgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmcsIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50XG5cdFx0XHRcdFx0Ly8gd2lsbCBuZXZlciBmaXJlISBTbyB3ZSBjb21wbGV0ZSBlYXJseVxuXHRcdFx0XHRcdGlmICggIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMoIHQsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdC8vIElmIGEgY2FsbGJhY2sgd2FzIHN1cHBsaWVkLCBkbyB0aGUgaG9ub3Vyc1xuXHRcdFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGZ1dHVyZVxuXHRcdFx0XHRpZiAoIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdHdhcm4oICd0LmFuaW1hdGVTdHlsZSByZXR1cm5zIGEgUHJvbWlzZSBhcyBvZiAwLjQuMC4gVHJhbnNpdGlvbiBhdXRob3JzIHNob3VsZCBkbyB0LmFuaW1hdGVTdHlsZSguLi4pLnRoZW4oY2FsbGJhY2spJyApO1xuXHRcdFx0XHRcdHByb21pc2UudGhlbiggY29tcGxldGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBhbmltYXRlU3R5bGU7XG5cdH0oIGxlZ2FjeSwgaXNDbGllbnQsIHdhcm4sIFByb21pc2UsIHByZWZpeCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSApO1xuXG5cdC8qIHV0aWxzL2ZpbGxHYXBzLmpzICovXG5cdHZhciBmaWxsR2FwcyA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0dmFyIHNvdXJjZXMgPSBTTElDRSQwLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHNvdXJjZXMuZm9yRWFjaCggZnVuY3Rpb24oIHMgKSB7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHMgKSB7XG5cdFx0XHRcdGlmICggcy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgISgga2V5IGluIHRhcmdldCApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSBzWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9wcm9jZXNzUGFyYW1zLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRwcm9jZXNzUGFyYW1zID0gZnVuY3Rpb24oIGZpbGxHYXBzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJhbXMsIGRlZmF1bHRzICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBwYXJhbXNcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoIHBhcmFtcyA9PT0gJ3Nsb3cnICkge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiA2MDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbXMgPT09ICdmYXN0JyApIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogMjAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogNDAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggIXBhcmFtcyApIHtcblx0XHRcdFx0cGFyYW1zID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmlsbEdhcHMoIHt9LCBwYXJhbXMsIGRlZmF1bHRzICk7XG5cdFx0fTtcblx0fSggZmlsbEdhcHMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvc3RhcnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBUcmFuc2l0aW9uJHN0YXJ0KCkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRub2RlLCBvcmlnaW5hbFN0eWxlLCBjb21wbGV0ZWQ7XG5cdFx0XHRub2RlID0gdC5ub2RlID0gdC5lbGVtZW50Lm5vZGU7XG5cdFx0XHRvcmlnaW5hbFN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKTtcblx0XHRcdC8vIGNyZWF0ZSB0LmNvbXBsZXRlKCkgLSB3ZSBkb24ndCB3YW50IHRoaXMgb24gdGhlIHByb3RvdHlwZSxcblx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBgdGhpc2Agc2lsbGluZXNzIHdoZW4gcGFzc2luZyBpdCBhc1xuXHRcdFx0Ly8gYW4gYXJndW1lbnRcblx0XHRcdHQuY29tcGxldGUgPSBmdW5jdGlvbiggbm9SZXNldCApIHtcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW5vUmVzZXQgJiYgdC5pc0ludHJvICkge1xuXHRcdFx0XHRcdHJlc2V0U3R5bGUoIG5vZGUsIG9yaWdpbmFsU3R5bGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuXHRcdFx0XHR0Ll9tYW5hZ2VyLnJlbW92ZSggdCApO1xuXHRcdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdC8vIElmIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3QsIGFib3J0XG5cdFx0XHRpZiAoICF0Ll9mbiApIHtcblx0XHRcdFx0dC5jb21wbGV0ZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbi5hcHBseSggdC5yb290LCBbIHQgXS5jb25jYXQoIHQucGFyYW1zICkgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRTdHlsZSggbm9kZSwgc3R5bGUgKSB7XG5cdFx0XHRpZiAoIHN0eWxlICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgc3R5bGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE5leHQgbGluZSBpcyBuZWNlc3NhcnksIHRvIHJlbW92ZSBlbXB0eSBzdHlsZSBhdHRyaWJ1dGUhXG5cdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTY3NTUzXG5cdFx0XHRcdG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL19UcmFuc2l0aW9uLmpzICovXG5cdHZhciBUcmFuc2l0aW9uID0gZnVuY3Rpb24oIGluaXQsIGdldFN0eWxlLCBzZXRTdHlsZSwgYW5pbWF0ZVN0eWxlLCBwcm9jZXNzUGFyYW1zLCBzdGFydCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIFRyYW5zaXRpb247XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRUcmFuc2l0aW9uID0gZnVuY3Rpb24oIG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3duZXIsIHRlbXBsYXRlLCBpc0ludHJvICk7XG5cdFx0fTtcblx0XHRUcmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRnZXRTdHlsZTogZ2V0U3R5bGUsXG5cdFx0XHRzZXRTdHlsZTogc2V0U3R5bGUsXG5cdFx0XHRhbmltYXRlU3R5bGU6IGFuaW1hdGVTdHlsZSxcblx0XHRcdHByb2Nlc3NQYXJhbXM6IHByb2Nlc3NQYXJhbXNcblx0XHR9O1xuXHRcdHJldHVybiBUcmFuc2l0aW9uO1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRnZXRTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc2V0U3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9fYW5pbWF0ZVN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRwcm9jZXNzUGFyYW1zLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzdGFydCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlbmRlciA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBpc0FycmF5LCB3YXJuLCBjcmVhdGUsIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBub29wLCBydW5sb29wLCBnZXRJbm5lckNvbnRleHQsIHJlbmRlckltYWdlLCBUcmFuc2l0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciB1cGRhdGVDc3MsIHVwZGF0ZVNjcmlwdDtcblx0XHR1cGRhdGVDc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuXHRcdFx0XHRjb250ZW50ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHRcdC8vIElFOCBoYXMgbm8gc3R5bGVTaGVldCB1bmxlc3MgdGhlcmUncyBhIHR5cGUgdGV4dC9jc3Ncblx0XHRcdGlmICggd2luZG93ICYmIHdpbmRvdy5hcHBlYXJzVG9CZUlFTGVzc0VxdWFsOCApIHtcblx0XHRcdFx0bm9kZS50eXBlID0gJ3RleHQvY3NzJztcblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS5zdHlsZVNoZWV0ICkge1xuXHRcdFx0XHRub2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIG5vZGUuaGFzQ2hpbGROb2RlcygpICkge1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBjb250ZW50ICkgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHVwZGF0ZVNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5ub2RlLnR5cGUgfHwgdGhpcy5ub2RlLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnICkge1xuXHRcdFx0XHR3YXJuKCAnU2NyaXB0IHRhZyB3YXMgdXBkYXRlZC4gVGhpcyBkb2VzIG5vdCBjYXVzZSB0aGUgY29kZSB0byBiZSByZS1ldmFsdWF0ZWQhJyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFbGVtZW50JHJlbmRlcigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHJvb3QgPSB0aGlzLnJvb3QsXG5cdFx0XHRcdG5hbWVzcGFjZSwgbm9kZTtcblx0XHRcdG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSggdGhpcyApO1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQoIHRoaXMubmFtZSwgbmFtZXNwYWNlICk7XG5cdFx0XHQvLyBJcyB0aGlzIGEgdG9wLWxldmVsIG5vZGUgb2YgYSBjb21wb25lbnQ/IElmIHNvLCB3ZSBtYXkgbmVlZCB0byBhZGRcblx0XHRcdC8vIGEgZGF0YS1ydmNndWlkIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG5cdFx0XHQvLyBOT1RFOiBjc3Mgbm8gbG9uZ2VyIGNvcGllZCB0byBpbnN0YW5jZSwgc28gd2UgY2hlY2sgY29uc3RydWN0b3IuY3NzIC1cblx0XHRcdC8vIHdlIGNhbiBlbmhhbmNlIHRvIGhhbmRsZSBpbnN0YW5jZSwgYnV0IHRoaXMgaXMgbW9yZSBcImNvcnJlY3RcIiB3aXRoIGN1cnJlbnRcblx0XHRcdC8vIGZ1bmN0aW9uYWxpdHlcblx0XHRcdGlmICggcm9vdC5jb25zdHJ1Y3Rvci5jc3MgJiYgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgPT09IHJvb3QuZWwgKSB7XG5cdFx0XHRcdHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoICdkYXRhLXJ2Y2d1aWQnLCByb290LmNvbnN0cnVjdG9yLl9ndWlkICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgX3JhY3RpdmUgcHJvcGVydHkgdG8gdGhlIG5vZGUgLSB3ZSB1c2UgdGhpcyBvYmplY3QgdG8gc3RvcmUgc3R1ZmZcblx0XHRcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHRoaXMubm9kZSwgJ19yYWN0aXZlJywge1xuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdHByb3h5OiB0aGlzLFxuXHRcdFx0XHRcdGtleXBhdGg6IGdldElubmVyQ29udGV4dCggdGhpcy5wYXJlbnRGcmFnbWVudCApLFxuXHRcdFx0XHRcdGluZGV4OiB0aGlzLnBhcmVudEZyYWdtZW50LmluZGV4UmVmcyxcblx0XHRcdFx0XHRldmVudHM6IGNyZWF0ZSggbnVsbCApLFxuXHRcdFx0XHRcdHJvb3Q6IHJvb3Rcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0cmV0dXJuIGEucmVuZGVyKCBub2RlICk7XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0cmV0dXJuIGEucmVuZGVyKCBub2RlICk7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBSZW5kZXIgY2hpbGRyZW5cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNjcmlwdD4gZWxlbWVudFxuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3NjcmlwdCcgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVTY3JpcHQ7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdFx0XHRcdC8vIGJ5cGFzcyB3YXJuaW5nIGluaXRpYWxseVxuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm5hbWUgPT09ICdzdHlsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVDc3M7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iaW5kaW5nICYmIHRoaXMuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgucmVuZGVyKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIGRlYWwgd2l0aCB0d28td2F5IGJpbmRpbmdzXG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZTogaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXlcblx0XHRcdC8vIG5lZWQgdG8gcHJldmVudCBpdCBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaW1nJyApIHtcblx0XHRcdFx0cmVuZGVySW1hZ2UoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIGFwcGx5IGRlY29yYXRvcihzKVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciAmJiB0aGlzLmRlY29yYXRvci5mbiApIHtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAuZGVjb3JhdG9yLmluaXQoKTtcblx0XHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHJpZ2dlciBpbnRybyB0cmFuc2l0aW9uXG5cdFx0XHRpZiAoIHJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMuaW50cm8gKSB7XG5cdFx0XHRcdHZhciB0cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb24oIHRoaXMsIHRoaXMuaW50cm8sIHRydWUgKTtcblx0XHRcdFx0cnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24oIHRyYW5zaXRpb24gKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG5cdFx0XHRcdH0sIHRydWUgKTtcblx0XHRcdFx0dGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0cHJvY2Vzc09wdGlvbiggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm5vZGUuYXV0b2ZvY3VzICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UuIFNvbWUgYnJvd3NlcnMgKCpjb3VnaCogRmlyZWZpeCAqY291Z2gqKSBoYXZlIGEgcHJvYmxlbVxuXHRcdFx0XHQvLyB3aXRoIGR5bmFtaWNhbGx5LWdlbmVyYXRlZCBlbGVtZW50cyBoYXZpbmcgYXV0b2ZvY3VzLCBhbmQgdGhleSB3b24ndFxuXHRcdFx0XHQvLyBhbGxvdyB5b3UgdG8gcHJvZ3JhbW1hdGljYWxseSBmb2N1cyB0aGUgZWxlbWVudCB1bnRpbCBpdCdzIGluIHRoZSBET01cblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAubm9kZS5mb2N1cygpO1xuXHRcdFx0XHR9LCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVMaXZlUXVlcmllcyggdGhpcyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0TmFtZXNwYWNlKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSwgeG1sbnMsIHBhcmVudDtcblx0XHRcdC8vIFVzZSBzcGVjaWZpZWQgbmFtZXNwYWNlLi4uXG5cdFx0XHRpZiAoIHhtbG5zID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd4bWxucycgKSApIHtcblx0XHRcdFx0bmFtZXNwYWNlID0geG1sbnM7XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzdmcnICkge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLnN2Zztcblx0XHRcdH0gZWxzZSBpZiAoIHBhcmVudCA9IGVsZW1lbnQucGFyZW50ICkge1xuXHRcdFx0XHQvLyAuLi5vciBIVE1MLCBpZiB0aGUgcGFyZW50IGlzIGEgPGZvcmVpZ25PYmplY3Q+XG5cdFx0XHRcdGlmICggcGFyZW50Lm5hbWUgPT09ICdmb3JlaWduT2JqZWN0JyApIHtcblx0XHRcdFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmh0bWw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlID0gcGFyZW50Lm5vZGUubmFtZXNwYWNlVVJJO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSBlbGVtZW50LnJvb3QuZWwubmFtZXNwYWNlVVJJO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5hbWVzcGFjZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzT3B0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXHRcdFx0aWYgKCAhb3B0aW9uLnNlbGVjdCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0VmFsdWUgPSBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBzZWxlY3RWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggb3B0aW9uLnNlbGVjdC5ub2RlLm11bHRpcGxlICYmIGlzQXJyYXkoIHNlbGVjdFZhbHVlICkgKSB7XG5cdFx0XHRcdGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWVbIGkgXSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVMaXZlUXVlcmllcyggZWxlbWVudCApIHtcblx0XHRcdHZhciBpbnN0YW5jZSwgbGl2ZVF1ZXJpZXMsIGksIHNlbGVjdG9yLCBxdWVyeTtcblx0XHRcdC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIGFkZGVkIHRvIGFueSBsaXZlIHF1ZXJpZXM/XG5cdFx0XHRpbnN0YW5jZSA9IGVsZW1lbnQucm9vdDtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGl2ZVF1ZXJpZXMgPSBpbnN0YW5jZS5fbGl2ZVF1ZXJpZXM7XG5cdFx0XHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gbGl2ZVF1ZXJpZXNbIGkgXTtcblx0XHRcdFx0XHRxdWVyeSA9IGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdO1xuXHRcdFx0XHRcdGlmICggcXVlcnkuX3Rlc3QoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0XHRcdC8vIGtlZXAgcmVnaXN0ZXIgb2YgYXBwbGljYWJsZSBzZWxlY3RvcnMsIGZvciB3aGVuIHdlIHRlYXJkb3duXG5cdFx0XHRcdFx0XHQoIGVsZW1lbnQubGl2ZVF1ZXJpZXMgfHwgKCBlbGVtZW50LmxpdmVRdWVyaWVzID0gW10gKSApLnB1c2goIHF1ZXJ5ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICggaW5zdGFuY2UgPSBpbnN0YW5jZS5fcGFyZW50ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbmFtZXNwYWNlcywgaXNBcnJheSwgd2FybiwgY3JlYXRlLCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgbm9vcCwgcnVubG9vcCwgZ2V0SW5uZXJDb250ZXh0LCByZW5kZXIsIFRyYW5zaXRpb24gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdG9TdHJpbmcgPSBmdW5jdGlvbiggdm9pZEVsZW1lbnROYW1lcywgaXNBcnJheSwgZXNjYXBlSHRtbCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0ciwgZXNjYXBlO1xuXHRcdFx0c3RyID0gJzwnICsgKCB0aGlzLnRlbXBsYXRlLnkgPyAnIURPQ1RZUEUnIDogdGhpcy50ZW1wbGF0ZS5lICk7XG5cdFx0XHRzdHIgKz0gdGhpcy5hdHRyaWJ1dGVzLm1hcCggc3RyaW5naWZ5QXR0cmlidXRlICkuam9pbiggJycgKSArIHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLm1hcCggc3RyaW5naWZ5QXR0cmlidXRlICkuam9pbiggJycgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyAmJiBvcHRpb25Jc1NlbGVjdGVkKCB0aGlzICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnIHNlbGVjdGVkJztcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHR3by13YXkgcmFkaW8gbmFtZSBiaW5kaW5nc1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpbnB1dCcgJiYgaW5wdXRJc0NoZWNrZWRSYWRpbyggdGhpcyApICkge1xuXHRcdFx0XHRzdHIgKz0gJyBjaGVja2VkJztcblx0XHRcdH1cblx0XHRcdHN0ciArPSAnPic7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB0ZXh0YXJlYVxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICd0ZXh0YXJlYScgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdHIgKz0gZXNjYXBlSHRtbCggdGhpcy5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSApO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c3RyICs9IHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdGVzY2FwZSA9IHRoaXMubmFtZSAhPT0gJ3NjcmlwdCcgJiYgdGhpcy5uYW1lICE9PSAnc3R5bGUnO1xuXHRcdFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZXNjYXBlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgYSBjbG9zaW5nIHRhZyBpZiB0aGlzIGlzbid0IGEgdm9pZCBlbGVtZW50XG5cdFx0XHRpZiAoICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoIHRoaXMudGVtcGxhdGUuZSApICkge1xuXHRcdFx0XHRzdHIgKz0gJzwvJyArIHRoaXMudGVtcGxhdGUuZSArICc+Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG9wdGlvbklzU2VsZWN0ZWQoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXHRcdFx0b3B0aW9uVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50LnNlbGVjdCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0VmFsdWUgPSBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSAmJiBpc0FycmF5KCBzZWxlY3RWYWx1ZSApICkge1xuXHRcdFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIHNlbGVjdFZhbHVlWyBpIF0gPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbnB1dElzQ2hlY2tlZFJhZGlvKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMsIHR5cGVBdHRyaWJ1dGUsIHZhbHVlQXR0cmlidXRlLCBuYW1lQXR0cmlidXRlO1xuXHRcdFx0YXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblx0XHRcdHR5cGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnR5cGU7XG5cdFx0XHR2YWx1ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudmFsdWU7XG5cdFx0XHRuYW1lQXR0cmlidXRlID0gYXR0cmlidXRlcy5uYW1lO1xuXHRcdFx0aWYgKCAhdHlwZUF0dHJpYnV0ZSB8fCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSAncmFkaW8nIHx8ICF2YWx1ZUF0dHJpYnV0ZSB8fCAhbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWVBdHRyaWJ1dGUudmFsdWUgPT09IG5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLnZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnlBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHZhciBzdHIgPSBhdHRyaWJ1dGUudG9TdHJpbmcoKTtcblx0XHRcdHJldHVybiBzdHIgPyAnICcgKyBzdHIgOiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB2b2lkRWxlbWVudE5hbWVzLCBpc0FycmF5LCBlc2NhcGVIdG1sICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X3NwZWNpYWxfb3B0aW9uX3VuYmluZCA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5iaW5kT3B0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3QgKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggb3B0aW9uLnNlbGVjdC5vcHRpb25zLCBvcHRpb24gKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVuYmluZCA9IGZ1bmN0aW9uKCB1bmJpbmRPcHRpb24gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFbGVtZW50JHVuYmluZCgpIHtcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5iaW5kaW5nICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj5cblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0dW5iaW5kT3B0aW9uKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCB4ICkge1xuXHRcdFx0eC51bmJpbmQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfc3BlY2lhbF9vcHRpb25fdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVucmVuZGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIFRyYW5zaXRpb24gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0dmFyIGJpbmRpbmcsIGJpbmRpbmdzO1xuXHRcdFx0aWYgKCB0aGlzLnRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbi5jb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGV0YWNoIGFzIHNvb24gYXMgd2UgY2FuXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuXHRcdFx0XHQvLyB0aGVpciBwYXJlbnQgPHNlbGVjdD4gZWxlbWVudCBzeW5jcyBjb3JyZWN0bHksIGFuZFxuXHRcdFx0XHQvLyBzaW5jZSBvcHRpb24gZWxlbWVudHMgY2FuJ3QgaGF2ZSB0cmFuc2l0aW9ucyBhbnl3YXlcblx0XHRcdFx0dGhpcy5kZXRhY2goKTtcblx0XHRcdH0gZWxzZSBpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHJ1bmxvb3AuZGV0YWNoV2hlblJlYWR5KCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG5cdFx0XHQvLyBoYW5kbGVkIGJ5IHRoZSBjdXJyZW50IHRyYW5zaXRpb25NYW5hZ2VyXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy51bnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IG51bGw7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF07XG5cdFx0XHRcdGJpbmRpbmdzLnNwbGljZSggYmluZGluZ3MuaW5kZXhPZiggYmluZGluZyApLCAxICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgudW5yZW5kZXIoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciApIHtcblx0XHRcdFx0dGhpcy5kZWNvcmF0b3IudGVhcmRvd24oKTtcblx0XHRcdH1cblx0XHRcdC8vIHRyaWdnZXIgb3V0cm8gdHJhbnNpdGlvbiBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggdGhpcy5yb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLm91dHJvICkge1xuXHRcdFx0XHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKCB0aGlzLCB0aGlzLm91dHJvLCBmYWxzZSApO1xuXHRcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIHRoaXMgbm9kZSBmcm9tIGFueSBsaXZlIHF1ZXJpZXNcblx0XHRcdGlmICggdGhpcy5saXZlUXVlcmllcyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlUXVlcmllcyggZWxlbWVudCApIHtcblx0XHRcdHZhciBxdWVyeSwgc2VsZWN0b3IsIGk7XG5cdFx0XHRpID0gZWxlbWVudC5saXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0cXVlcnkgPSBlbGVtZW50LmxpdmVRdWVyaWVzWyBpIF07XG5cdFx0XHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cdFx0XHRcdHF1ZXJ5Ll9yZW1vdmUoIGVsZW1lbnQubm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHJ1bmxvb3AsIFRyYW5zaXRpb24gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvX0VsZW1lbnQuanMgKi9cblx0dmFyIEVsZW1lbnQgPSBmdW5jdGlvbiggYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgZ2V0QXR0cmlidXRlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgRWxlbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRFbGVtZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gRWxlbWVudDtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZE5leHROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZ2V0QXR0cmlidXRlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5yZW5kZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvZGVJbmRlbnQuanMgKi9cblx0dmFyIGRlSW5kZW50ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGVtcHR5ID0gL15cXHMqJC8sXG5cdFx0XHRsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKi87XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0dmFyIGxpbmVzLCBmaXJzdExpbmUsIGxhc3RMaW5lLCBtaW5JbmRlbnQ7XG5cdFx0XHRsaW5lcyA9IHN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBsaW5lLCBpZiB0aGV5IG9ubHkgY29udGFpbiB3aGl0ZXNwYWNlXG5cdFx0XHRmaXJzdExpbmUgPSBsaW5lc1sgMCBdO1xuXHRcdFx0aWYgKCBmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBmaXJzdExpbmUgKSApIHtcblx0XHRcdFx0bGluZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHRcdGxhc3RMaW5lID0gbGluZXNbIGxpbmVzLmxlbmd0aCAtIDEgXTtcblx0XHRcdGlmICggbGFzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBsYXN0TGluZSApICkge1xuXHRcdFx0XHRsaW5lcy5wb3AoKTtcblx0XHRcdH1cblx0XHRcdG1pbkluZGVudCA9IGxpbmVzLnJlZHVjZSggcmVkdWNlciwgbnVsbCApO1xuXHRcdFx0aWYgKCBtaW5JbmRlbnQgKSB7XG5cdFx0XHRcdHN0ciA9IGxpbmVzLm1hcCggZnVuY3Rpb24oIGxpbmUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUucmVwbGFjZSggbWluSW5kZW50LCAnJyApO1xuXHRcdFx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZHVjZXIoIHByZXZpb3VzLCBsaW5lICkge1xuXHRcdFx0dmFyIGxpbmVJbmRlbnQgPSBsZWFkaW5nV2hpdGVzcGFjZS5leGVjKCBsaW5lIClbIDAgXTtcblx0XHRcdGlmICggcHJldmlvdXMgPT09IG51bGwgfHwgbGluZUluZGVudC5sZW5ndGggPCBwcmV2aW91cy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBsaW5lSW5kZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZXZpb3VzO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvZ2V0UGFydGlhbFRlbXBsYXRlLmpzICovXG5cdHZhciBnZXRQYXJ0aWFsVGVtcGxhdGUgPSBmdW5jdGlvbiggbG9nLCBjb25maWcsIHBhcnNlciwgZGVJbmRlbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBnZXRQYXJ0aWFsVGVtcGxhdGUoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcGFydGlhbDtcblx0XHRcdC8vIElmIHRoZSBwYXJ0aWFsIGluIGluc3RhbmNlIG9yIHZpZXcgaGVpcmFyY2h5IGluc3RhbmNlcywgZ3JlYXRcblx0XHRcdGlmICggcGFydGlhbCA9IGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRpYWw7XG5cdFx0XHR9XG5cdFx0XHQvLyBEb2VzIGl0IGV4aXN0IG9uIHRoZSBwYWdlIGFzIGEgc2NyaXB0IHRhZz9cblx0XHRcdHBhcnRpYWwgPSBwYXJzZXIuZnJvbUlkKCBuYW1lLCB7XG5cdFx0XHRcdG5vVGhyb3c6IHRydWVcblx0XHRcdH0gKTtcblx0XHRcdGlmICggcGFydGlhbCApIHtcblx0XHRcdFx0Ly8gaXMgdGhpcyBuZWNlc3Nhcnk/XG5cdFx0XHRcdHBhcnRpYWwgPSBkZUluZGVudCggcGFydGlhbCApO1xuXHRcdFx0XHQvLyBwYXJzZSBhbmQgcmVnaXN0ZXIgdG8gdGhpcyByYWN0aXZlIGluc3RhbmNlXG5cdFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoIHBhcnRpYWwsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0XHQvLyByZWdpc3RlciAoYW5kIHJldHVybiBtYWluIHBhcnRpYWwgaWYgdGhlcmUgYXJlIG90aGVycyBpbiB0aGUgdGVtcGxhdGUpXG5cdFx0XHRcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzWyBuYW1lIF0gPSBwYXJzZWQudDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFydGlhbEZyb21SZWdpc3RyeSggcmFjdGl2ZSwgbmFtZSApIHtcblx0XHRcdHZhciBwYXJ0aWFscyA9IGNvbmZpZy5yZWdpc3RyaWVzLnBhcnRpYWxzO1xuXHRcdFx0Ly8gZmluZCBmaXJzdCBpbnN0YW5jZSBpbiB0aGUgcmFjdGl2ZSBvciB2aWV3IGhpZXJhcmNoeSB0aGF0IGhhcyB0aGlzIHBhcnRpYWxcblx0XHRcdHZhciBpbnN0YW5jZSA9IHBhcnRpYWxzLmZpbmRJbnN0YW5jZSggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJ0aWFsID0gaW5zdGFuY2UucGFydGlhbHNbIG5hbWUgXSxcblx0XHRcdFx0Zm47XG5cdFx0XHQvLyBwYXJ0aWFsIGlzIGEgZnVuY3Rpb24/XG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRmbiA9IHBhcnRpYWwuYmluZCggaW5zdGFuY2UgKTtcblx0XHRcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLnBhcnRpYWxzLmhhc093blByb3BlcnR5KCBuYW1lICk7XG5cdFx0XHRcdHBhcnRpYWwgPSBmbiggaW5zdGFuY2UuZGF0YSwgcGFyc2VyICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFwYXJ0aWFsICkge1xuXHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4nLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdHJlZ2lzdHJ5OiAncGFydGlhbCcsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFkZGVkIG1hbnVhbGx5IHRvIHRoZSByZWdpc3RyeSxcblx0XHRcdC8vIGJ1dCBoYXNuJ3QgYmVlbiBwYXJzZWQsIHBhcnNlIGl0IG5vd1xuXHRcdFx0aWYgKCAhcGFyc2VyLmlzUGFyc2VkKCBwYXJ0aWFsICkgKSB7XG5cdFx0XHRcdC8vIHVzZSB0aGUgcGFyc2VPcHRpb25zIG9mIHRoZSByYWN0aXZlIGluc3RhbmNlIG9uIHdoaWNoIGl0IHdhcyBmb3VuZFxuXHRcdFx0XHR2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKCBwYXJ0aWFsLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCBpbnN0YW5jZSApICk7XG5cdFx0XHRcdC8vIFBhcnRpYWxzIGNhbm5vdCBjb250YWluIG5lc3RlZCBwYXJ0aWFscyFcblx0XHRcdFx0Ly8gVE9ETyBhZGQgYSB0ZXN0IGZvciB0aGlzXG5cdFx0XHRcdGlmICggcGFyc2VkLnAgKSB7XG5cdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogJ25vTmVzdGVkUGFydGlhbHMnLFxuXHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRybmFtZTogbmFtZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiBmbiwgdXNlIGluc3RhbmNlIHRvIHN0b3JlIHJlc3VsdCwgb3RoZXJ3aXNlIG5lZWRzIHRvIGdvXG5cdFx0XHRcdC8vIGluIHRoZSBjb3JyZWN0IHBvaW50IGluIHByb3RvdHlwZSBjaGFpbiBvbiBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvclxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZm4gPyBpbnN0YW5jZSA6IHBhcnRpYWxzLmZpbmRPd25lciggaW5zdGFuY2UsIG5hbWUgKTtcblx0XHRcdFx0Ly8gbWF5IGJlIGEgdGVtcGxhdGUgd2l0aCBwYXJ0aWFscywgd2hpY2ggbmVlZCB0byBiZSByZWdpc3RlcmVkIGFuZCBtYWluIHRlbXBsYXRlIGV4dHJhY3RlZFxuXHRcdFx0XHR0YXJnZXQucGFydGlhbHNbIG5hbWUgXSA9IHBhcnRpYWwgPSBwYXJzZWQudDtcblx0XHRcdH1cblx0XHRcdC8vIHN0b3JlIGZvciByZXNldFxuXHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0cGFydGlhbC5fZm4gPSBmbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJ0aWFsLnYgPyBwYXJ0aWFsLnQgOiBwYXJ0aWFsO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGxvZywgY29uZmlnLCBwYXJzZXIsIGRlSW5kZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2FwcGx5SW5kZW50LmpzICovXG5cdHZhciBhcHBseUluZGVudCA9IGZ1bmN0aW9uKCBzdHJpbmcsIGluZGVudCApIHtcblx0XHR2YXIgaW5kZW50ZWQ7XG5cdFx0aWYgKCAhaW5kZW50ICkge1xuXHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHR9XG5cdFx0aW5kZW50ZWQgPSBzdHJpbmcuc3BsaXQoICdcXG4nICkubWFwKCBmdW5jdGlvbiggbGluZSwgbm90Rmlyc3RMaW5lICkge1xuXHRcdFx0cmV0dXJuIG5vdEZpcnN0TGluZSA/IGluZGVudCArIGxpbmUgOiBsaW5lO1xuXHRcdH0gKS5qb2luKCAnXFxuJyApO1xuXHRcdHJldHVybiBpbmRlbnRlZDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvX1BhcnRpYWwuanMgKi9cblx0dmFyIFBhcnRpYWwgPSBmdW5jdGlvbiggbG9nLCB0eXBlcywgZ2V0UGFydGlhbFRlbXBsYXRlLCBhcHBseUluZGVudCwgY2lyY3VsYXIsIHJ1bmxvb3AsIE11c3RhY2hlLCByZWJpbmQsIHVuYmluZCApIHtcblxuXHRcdHZhciBQYXJ0aWFsLCBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdFBhcnRpYWwgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlBBUlRJQUw7XG5cdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUucjtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHQvLyBJZiB0aGlzIGRpZG4ndCByZXNvbHZlLCBpdCBtb3N0IGxpa2VseSBtZWFucyB3ZSBoYXZlIGEgbmFtZWQgcGFydGlhbFxuXHRcdFx0Ly8gKGkuZS4gYHt7PmZvb319YCBtZWFucyAndXNlIHRoZSBmb28gcGFydGlhbCcsIG5vdCAndXNlIHRoZSBwYXJ0aWFsXG5cdFx0XHQvLyB3aG9zZSBuYW1lIGlzIHRoZSB2YWx1ZSBvZiBgZm9vYCcpXG5cdFx0XHRpZiAoICF0aGlzLmtleXBhdGggJiYgKCB0ZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yb290LCB0aGlzLm5hbWUgKSApICkge1xuXHRcdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0XHQvLyBwcmV2ZW50IGFueSBmdXJ0aGVyIGNoYW5nZXNcblx0XHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSggdGVtcGxhdGUgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFBhcnRpYWwucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRkZXRhY2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbDogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0cmViaW5kLmNhbGwoIHRoaXMsIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdFx0Ly8gbm90aGluZyBoYXMgY2hhbmdlZCwgc28gbm8gd29yayB0byBiZSBkb25lXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlKCB0aGlzLnJvb3QsICcnICsgdmFsdWUgKTtcblx0XHRcdFx0Ly8gd2UgbWF5IGJlIGhlcmUgaWYgd2UgaGF2ZSBhIHBhcnRpYWwgbGlrZSBge3s+Zm9vfX1gIGFuZCBgZm9vYCBpcyB0aGVcblx0XHRcdFx0Ly8gbmFtZSBvZiBib3RoIGEgZGF0YSBwcm9wZXJ0eSAod2hvc2UgdmFsdWUgSVNOJ1QgdGhlIG5hbWUgb2YgYSBwYXJ0aWFsKVxuXHRcdFx0XHQvLyBhbmQgYSBwYXJ0aWFsLiBJbiB0aG9zZSBjYXNlcywgdGhpcyBiZWNvbWVzIGEgbmFtZWQgcGFydGlhbFxuXHRcdFx0XHRpZiAoICF0ZW1wbGF0ZSAmJiB0aGlzLm5hbWUgJiYgKCB0ZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yb290LCB0aGlzLm5hbWUgKSApICkge1xuXHRcdFx0XHRcdHVuYmluZC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF0ZW1wbGF0ZSApIHtcblx0XHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRcdGRlYnVnOiB0aGlzLnJvb3QuZGVidWcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnbm9UZW1wbGF0ZUZvclBhcnRpYWwnLFxuXHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB0aGlzLm5hbWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSggdGVtcGxhdGUgfHwgW10gKTtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRUZW1wbGF0ZTogZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IHRoaXMuZnJhZ21lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IHRoaXMucGFyZW50RnJhZ21lbnQucEVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiggdG9TdHJpbmcgKSB7XG5cdFx0XHRcdHZhciBzdHJpbmcsIHByZXZpb3VzSXRlbSwgbGFzdExpbmUsIG1hdGNoO1xuXHRcdFx0XHRzdHJpbmcgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0b1N0cmluZyApO1xuXHRcdFx0XHRwcmV2aW91c0l0ZW0gPSB0aGlzLnBhcmVudEZyYWdtZW50Lml0ZW1zWyB0aGlzLmluZGV4IC0gMSBdO1xuXHRcdFx0XHRpZiAoICFwcmV2aW91c0l0ZW0gfHwgcHJldmlvdXNJdGVtLnR5cGUgIT09IHR5cGVzLlRFWFQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0TGluZSA9IHByZXZpb3VzSXRlbS50ZXh0LnNwbGl0KCAnXFxuJyApLnBvcCgpO1xuXHRcdFx0XHRpZiAoIG1hdGNoID0gL15cXHMrJC8uZXhlYyggbGFzdExpbmUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYXBwbHlJbmRlbnQoIHN0cmluZywgbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5pc05hbWVkICkge1xuXHRcdFx0XHRcdC8vIGR5bmFtaWMgcGFydGlhbCAtIG5lZWQgdG8gdW5iaW5kIHNlbGZcblx0XHRcdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0LCBhbmNob3I7XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIudW5yZW5kZXIoIHRydWUgKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50VG9SZW5kZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50VG9SZW5kZXIucmVuZGVyKCkgKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblx0XHRcdFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgYW5jaG9yICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBQYXJ0aWFsO1xuXHR9KCBsb2csIHR5cGVzLCBnZXRQYXJ0aWFsVGVtcGxhdGUsIGFwcGx5SW5kZW50LCBjaXJjdWxhciwgcnVubG9vcCwgTXVzdGFjaGUsIHJlYmluZCwgdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvZ2V0Q29tcG9uZW50LmpzICovXG5cdHZhciBnZXRDb21wb25lbnQgPSBmdW5jdGlvbiggY29uZmlnLCBsb2csIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmU7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRSYWN0aXZlID0gY2lyY3VsYXIuUmFjdGl2ZTtcblx0XHR9ICk7XG5cdFx0Ly8gZmluZHMgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBpbiB0aGUgcmVnaXN0cnkgb3IgdmlldyBoaWVyYXJjaHkgcmVnaXN0cmllc1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRDb21wb25lbnQoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50LCBpbnN0YW5jZSA9IGNvbmZpZy5yZWdpc3RyaWVzLmNvbXBvbmVudHMuZmluZEluc3RhbmNlKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRjb21wb25lbnQgPSBpbnN0YW5jZS5jb21wb25lbnRzWyBuYW1lIF07XG5cdFx0XHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcblx0XHRcdFx0aWYgKCAhY29tcG9uZW50Ll9wYXJlbnQgKSB7XG5cdFx0XHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcblx0XHRcdFx0XHR2YXIgZm4gPSBjb21wb25lbnQuYmluZCggaW5zdGFuY2UgKTtcblx0XHRcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApO1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGZuKCBpbnN0YW5jZS5kYXRhICk7XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4nLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cmVnaXN0cnk6ICdjb21wb25lbnQnLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0Ly9hbGxvdyBzdHJpbmcgbG9va3VwXG5cdFx0XHRcdFx0XHRjb21wb25lbnQgPSBnZXRDb21wb25lbnQoIHJhY3RpdmUsIGNvbXBvbmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnQuX2ZuID0gZm47XG5cdFx0XHRcdFx0aW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdID0gY29tcG9uZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50O1xuXHRcdH07XG5cdH0oIGNvbmZpZywgbG9nLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGRldGFjaCA9IGZ1bmN0aW9uKCBIb29rICkge1xuXG5cdFx0dmFyIGRldGFjaEhvb2sgPSBuZXcgSG9vayggJ2RldGFjaCcgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gQ29tcG9uZW50JGRldGFjaCgpIHtcblx0XHRcdHZhciBkZXRhY2hlZCA9IHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHRkZXRhY2hIb29rLmZpcmUoIHRoaXMuaW5zdGFuY2UgKTtcblx0XHRcdHJldHVybiBkZXRhY2hlZDtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICk7XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdGlmICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSB0aGlzLm5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmROZXh0Tm9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBDb21wb25lbnQkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL0NvbXBvbmVudFBhcmFtZXRlci5qcyAqL1xuXHR2YXIgQ29tcG9uZW50UGFyYW1ldGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBDb21wb25lbnRQYXJhbWV0ZXI7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRDb21wb25lbnRQYXJhbWV0ZXIgPSBmdW5jdGlvbiggY29tcG9uZW50LCBrZXksIHZhbHVlICkge1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXHRcdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB2YWx1ZSxcblx0XHRcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdH07XG5cdFx0Q29tcG9uZW50UGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5LCB2YWx1ZSApO1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5jb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50UGFyYW1ldGVyO1xuXHR9KCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlTW9kZWwvUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlci5qcyAqL1xuXHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciA9IGZ1bmN0aW9uKCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKSB7XG5cblx0XHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciA9IGZ1bmN0aW9uKCBjb21wb25lbnQsIGNoaWxkS2V5cGF0aCwgdGVtcGxhdGUsIHRvQmluZCApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dGhpcy5yb290ID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZWFkeSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5oYXNoID0gbnVsbDtcblx0XHRcdHRoaXMucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKCB0aGlzLCB0ZW1wbGF0ZSwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdC8vIEFyZSB3ZSB1cGRhdGluZyBhbiBleGlzdGluZyBiaW5kaW5nP1xuXHRcdFx0XHRpZiAoIHRoaXMkMC5iaW5kaW5nIHx8ICggdGhpcyQwLmJpbmRpbmcgPSBjb21wb25lbnQuYmluZGluZ3NbIHRoaXMkMC5oYXNoIF0gKSApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuYmluZGluZ3NbIHRoaXMkMC5oYXNoIF0gPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMkMC5iaW5kaW5nLnJlYmluZCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMkMC5oYXNoID0ga2V5cGF0aCArICc9JyArIGNoaWxkS2V5cGF0aDtcblx0XHRcdFx0XHRjb21wb25lbnQuYmluZGluZ3NbIHRoaXMkMC5oYXNoIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcyQwLnJlYWR5ICkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGNoaWxkIGluc3RhbmNlIGlzbid0IGNyZWF0ZWQgeWV0LCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgYmluZGluZyBsYXRlclxuXHRcdFx0XHRcdFx0dG9CaW5kLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGRLZXlwYXRoOiBjaGlsZEtleXBhdGgsXG5cdFx0XHRcdFx0XHRcdHBhcmVudEtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBjb21wb25lbnQucm9vdCwga2V5cGF0aCwgY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMkMC52YWx1ZSA9IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyO1xuXHR9KCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL19jcmVhdGVNb2RlbC5qcyAqL1xuXHR2YXIgY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiggdHlwZXMsIHBhcnNlSlNPTiwgcmVzb2x2ZVJlZiwgQ29tcG9uZW50UGFyYW1ldGVyLCBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGNvbXBvbmVudCwgZGVmYXVsdERhdGEsIGF0dHJpYnV0ZXMsIHRvQmluZCApIHtcblx0XHRcdHZhciBkYXRhID0ge30sXG5cdFx0XHRcdGtleSwgdmFsdWU7XG5cdFx0XHQvLyBzb21lIHBhcmFtZXRlcnMsIGUuZy4gZm9vPVwiVGhlIHZhbHVlIGlzIHt7YmFyfX1cIiwgYXJlICdjb21wbGV4JyAtIGluXG5cdFx0XHQvLyBvdGhlciB3b3Jkcywgd2UgbmVlZCB0byBjb25zdHJ1Y3QgYSBzdHJpbmcgZnJhZ21lbnQgdG8gd2F0Y2hcblx0XHRcdC8vIHdoZW4gdGhleSBjaGFuZ2UuIFdlIHN0b3JlIHRoZXNlIHNvIHRoZXkgY2FuIGJlIHRvcm4gZG93biBsYXRlclxuXHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzID0gW107XG5cdFx0XHRmb3IgKCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGdldFZhbHVlKCBjb21wb25lbnQsIGtleSwgYXR0cmlidXRlc1sga2V5IF0sIHRvQmluZCApO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCB8fCBkZWZhdWx0RGF0YVsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZSwgdG9CaW5kICkge1xuXHRcdFx0dmFyIHBhcmFtZXRlciwgcGFyc2VkLCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIGtleXBhdGgsIGluZGV4UmVmO1xuXHRcdFx0cGFyZW50SW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHN0YXRpYyB2YWx1ZSwgZ3JlYXRcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCB0ZW1wbGF0ZSApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJzZWQudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBudWxsLCB3ZSB0cmVhdCBpdCBhcyBhIGJvb2xlYW4gYXR0cmlidXRlIChpLmUuIHRydWUpXG5cdFx0XHRpZiAoIHRlbXBsYXRlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIFNpbmdsZSBpbnRlcnBvbGF0b3I/XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmxlbmd0aCA9PT0gMSAmJiB0ZW1wbGF0ZVsgMCBdLnQgPT09IHR5cGVzLklOVEVSUE9MQVRPUiApIHtcblx0XHRcdFx0Ly8gSWYgaXQncyBhIHJlZ3VsYXIgaW50ZXJwb2xhdG9yLCB3ZSBiaW5kIHRvIGl0XG5cdFx0XHRcdGlmICggdGVtcGxhdGVbIDAgXS5yICkge1xuXHRcdFx0XHRcdC8vIElzIGl0IGFuIGluZGV4IHJlZmVyZW5jZT9cblx0XHRcdFx0XHRpZiAoIHBhcmVudEZyYWdtZW50LmluZGV4UmVmcyAmJiBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnNbIGluZGV4UmVmID0gdGVtcGxhdGVbIDAgXS5yIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGNvbXBvbmVudC5pbmRleFJlZkJpbmRpbmdzWyBpbmRleFJlZiBdID0ga2V5O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50LmluZGV4UmVmc1sgaW5kZXhSZWYgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gVE9ETyB3aGF0IGFib3V0IHJlZmVyZW5jZXMgdGhhdCByZXNvbHZlIGxhdGU/IFNob3VsZCB0aGVzZSBiZSBjb25zaWRlcmVkP1xuXHRcdFx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCBwYXJlbnRJbnN0YW5jZSwgdGVtcGxhdGVbIDAgXS5yLCBwYXJlbnRGcmFnbWVudCApIHx8IHRlbXBsYXRlWyAwIF0ucjtcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB1cCBiaW5kaW5ncyBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQsIGJ1dFxuXHRcdFx0XHRcdC8vIHdlIGNhbid0IGRvIGl0IHlldCBiZWNhdXNlIHRoZSBjaGlsZCBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0XG5cdFx0XHRcdFx0Ly8geWV0IC0gc28gd2UgbWFrZSBhIG5vdGUgaW5zdGVhZFxuXHRcdFx0XHRcdHRvQmluZC5wdXNoKCB7XG5cdFx0XHRcdFx0XHRjaGlsZEtleXBhdGg6IGtleSxcblx0XHRcdFx0XHRcdHBhcmVudEtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudEluc3RhbmNlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBpdCdzIGEgcmVmZXJlbmNlIGV4cHJlc3Npb24gKGUuZy4gYHt7Zm9vW2Jhcl19fWApLCB3ZSBuZWVkXG5cdFx0XHRcdC8vIHRvIHdhdGNoIHRoZSBrZXlwYXRoIGFuZCBjcmVhdGUvZGVzdHJveSBiaW5kaW5nc1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlWyAwIF0ucnggKSB7XG5cdFx0XHRcdFx0cGFyYW1ldGVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZVsgMCBdLnJ4LCB0b0JpbmQgKTtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMucHVzaCggcGFyYW1ldGVyICk7XG5cdFx0XHRcdFx0cGFyYW1ldGVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gcGFyYW1ldGVyLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGEgJ2NvbXBsZXggcGFyYW1ldGVyJyAtIHdlIG5lZWQgdG8gY3JlYXRlIGEgZnVsbC1ibG93biBzdHJpbmdcblx0XHRcdC8vIGZyYWdtZW50IGluIG9yZGVyIHRvIGV2YWx1YXRlIGFuZCBvYnNlcnZlIGl0cyB2YWx1ZVxuXHRcdFx0cGFyYW1ldGVyID0gbmV3IENvbXBvbmVudFBhcmFtZXRlciggY29tcG9uZW50LCBrZXksIHRlbXBsYXRlICk7XG5cdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMucHVzaCggcGFyYW1ldGVyICk7XG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVyLnZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBwYXJzZUpTT04sIHJlc29sdmVSZWYsIENvbXBvbmVudFBhcmFtZXRlciwgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlSW5zdGFuY2UuanMgKi9cblx0dmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggY29tcG9uZW50LCBDb21wb25lbnQsIGRhdGEsIGNvbnRlbnREZXNjcmlwdG9yICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBwYXJlbnRGcmFnbWVudCwgcGFydGlhbHMsIHJhY3RpdmU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJhY3RpdmUgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdC8vIE1ha2UgY29udGVudHMgYXZhaWxhYmxlIGFzIGEge3s+Y29udGVudH19IHBhcnRpYWxcblx0XHRcdHBhcnRpYWxzID0ge1xuXHRcdFx0XHRjb250ZW50OiBjb250ZW50RGVzY3JpcHRvciB8fCBbXVxuXHRcdFx0fTtcblx0XHRcdGlmICggQ29tcG9uZW50LmRlZmF1bHRzLmVsICkge1xuXHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdkZWZhdWx0RWxTcGVjaWZpZWQnLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdG5hbWU6IGNvbXBvbmVudC5uYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0YW5jZSA9IG5ldyBDb21wb25lbnQoIHtcblx0XHRcdFx0ZWw6IG51bGwsXG5cdFx0XHRcdGFwcGVuZDogdHJ1ZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuXHRcdFx0XHRtYWdpYzogcmFjdGl2ZS5tYWdpYyB8fCBDb21wb25lbnQuZGVmYXVsdHMubWFnaWMsXG5cdFx0XHRcdG1vZGlmeUFycmF5czogcmFjdGl2ZS5tb2RpZnlBcnJheXMsXG5cdFx0XHRcdF9wYXJlbnQ6IHJhY3RpdmUsXG5cdFx0XHRcdF9jb21wb25lbnQ6IGNvbXBvbmVudCxcblx0XHRcdFx0Ly8gbmVlZCB0byBpbmhlcml0IHJ1bnRpbWUgcGFyZW50IGFkYXB0b3JzXG5cdFx0XHRcdGFkYXB0OiByYWN0aXZlLmFkYXB0LFxuXHRcdFx0XHR5aWVsZDoge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBjb250ZW50RGVzY3JpcHRvcixcblx0XHRcdFx0XHRpbnN0YW5jZTogcmFjdGl2ZVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdFx0fTtcblx0fSggbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVCaW5kaW5ncy5qcyAqL1xuXHR2YXIgY3JlYXRlQmluZGluZ3MgPSBmdW5jdGlvbiggY3JlYXRlQ29tcG9uZW50QmluZGluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVJbml0aWFsQ29tcG9uZW50QmluZGluZ3MoIGNvbXBvbmVudCwgdG9CaW5kICkge1xuXHRcdFx0dG9CaW5kLmZvckVhY2goIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxDb21wb25lbnRCaW5kaW5nKCBwYWlyICkge1xuXHRcdFx0XHR2YXIgY2hpbGRWYWx1ZSwgcGFyZW50VmFsdWU7XG5cdFx0XHRcdGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIGNvbXBvbmVudCwgY29tcG9uZW50LnJvb3QsIHBhaXIucGFyZW50S2V5cGF0aCwgcGFpci5jaGlsZEtleXBhdGggKTtcblx0XHRcdFx0Y2hpbGRWYWx1ZSA9IGNvbXBvbmVudC5pbnN0YW5jZS52aWV3bW9kZWwuZ2V0KCBwYWlyLmNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbC5nZXQoIHBhaXIucGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGNoaWxkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwYXJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5yb290LnZpZXdtb2RlbC5zZXQoIHBhaXIucGFyZW50S2V5cGF0aCwgY2hpbGRWYWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggY3JlYXRlQ29tcG9uZW50QmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvcHJvcGFnYXRlRXZlbnRzLmpzICovXG5cdHZhciBwcm9wYWdhdGVFdmVudHMgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGZpcmVFdmVudCwgbG9nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnRzKCBjb21wb25lbnQsIGV2ZW50c0Rlc2NyaXB0b3IgKSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdFx0Zm9yICggZXZlbnROYW1lIGluIGV2ZW50c0Rlc2NyaXB0b3IgKSB7XG5cdFx0XHRcdGlmICggZXZlbnRzRGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eSggZXZlbnROYW1lICkgKSB7XG5cdFx0XHRcdFx0cHJvcGFnYXRlRXZlbnQoIGNvbXBvbmVudC5pbnN0YW5jZSwgY29tcG9uZW50LnJvb3QsIGV2ZW50TmFtZSwgZXZlbnRzRGVzY3JpcHRvclsgZXZlbnROYW1lIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9wYWdhdGVFdmVudCggY2hpbGRJbnN0YW5jZSwgcGFyZW50SW5zdGFuY2UsIGV2ZW50TmFtZSwgcHJveHlFdmVudE5hbWUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm94eUV2ZW50TmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiBwYXJlbnRJbnN0YW5jZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9Db21wb25lbnRFdmVudEFyZ3VtZW50cydcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGRJbnN0YW5jZS5vbiggZXZlbnROYW1lLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGV2ZW50LCBhcmdzO1xuXHRcdFx0XHQvLyBzZW1pLXdlYWsgdGVzdCwgYnV0IHdoYXQgZWxzZT8gdGFnIHRoZSBldmVudCBvYmogLl9pc0V2ZW50ID9cblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sgMCBdICYmIGFyZ3VtZW50c1sgMCBdLm5vZGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQgPSBBcnJheS5wcm90b3R5cGUuc2hpZnQuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZmlyZUV2ZW50KCBwYXJlbnRJbnN0YW5jZSwgcHJveHlFdmVudE5hbWUsIHtcblx0XHRcdFx0XHRldmVudDogZXZlbnQsXG5cdFx0XHRcdFx0YXJnczogYXJnc1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdC8vIGNhbmNlbCBidWJibGluZ1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCwgbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS91cGRhdGVMaXZlUXVlcmllcy5qcyAqL1xuXHR2YXIgdXBkYXRlTGl2ZVF1ZXJpZXMgPSBmdW5jdGlvbiggY29tcG9uZW50ICkge1xuXHRcdHZhciBhbmNlc3RvciwgcXVlcnk7XG5cdFx0Ly8gSWYgdGhlcmUncyBhIGxpdmUgcXVlcnkgZm9yIHRoaXMgY29tcG9uZW50IHR5cGUsIGFkZCBpdFxuXHRcdGFuY2VzdG9yID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0d2hpbGUgKCBhbmNlc3RvciApIHtcblx0XHRcdGlmICggcXVlcnkgPSBhbmNlc3Rvci5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIGNvbXBvbmVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdHF1ZXJ5LnB1c2goIGNvbXBvbmVudC5pbnN0YW5jZSApO1xuXHRcdFx0fVxuXHRcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5fcGFyZW50O1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgd2FybiwgY3JlYXRlTW9kZWwsIGNyZWF0ZUluc3RhbmNlLCBjcmVhdGVCaW5kaW5ncywgcHJvcGFnYXRlRXZlbnRzLCB1cGRhdGVMaXZlUXVlcmllcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBDb21wb25lbnQkaW5pdCggb3B0aW9ucywgQ29tcG9uZW50ICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCByb290LCBkYXRhLCB0b0JpbmQ7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnJvb3QgPSByb290O1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQ09NUE9ORU5UO1xuXHRcdFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5lO1xuXHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR0aGlzLmluZGV4UmVmQmluZGluZ3MgPSB7fTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSBbXTtcblx0XHRcdC8vIGV2ZW4gdGhvdWdoIG9ubHkgb25lIHlpZWxkZXIgaXMgYWxsb3dlZCwgd2UgbmVlZCB0byBoYXZlIGFuIGFycmF5IG9mIHRoZW1cblx0XHRcdC8vIGFzIGl0J3MgcG9zc2libGUgdG8gY2F1c2UgYSB5aWVsZGVyIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBsYXN0IG9uZVxuXHRcdFx0Ly8gd2FzIGRlc3Ryb3llZCBpbiB0aGUgc2FtZSB0dXJuIG9mIHRoZSBydW5sb29wXG5cdFx0XHR0aGlzLnlpZWxkZXJzID0gW107XG5cdFx0XHRpZiAoICFDb21wb25lbnQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NvbXBvbmVudCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgbm90IGZvdW5kJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmlyc3QsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbW9kZWwgZm9yIHRoZSBjb21wb25lbnQgLSBlLmcuIGlmIHdlXG5cdFx0XHQvLyBlbmNvdW50ZXIgPHdpZGdldCBmb289J2JhcicvPiB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGEgd2lkZ2V0XG5cdFx0XHQvLyB3aXRoIGBkYXRhOiB7IGZvbzogJ2JhcicgfWAuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gVGhpcyBtYXkgaW52b2x2ZSBzZXR0aW5nIHVwIHNvbWUgYmluZGluZ3MsIGJ1dCB3ZSBjYW4ndCBkbyBpdFxuXHRcdFx0Ly8geWV0IHNvIHdlIHRha2Ugc29tZSBub3RlcyBpbnN0ZWFkXG5cdFx0XHR0b0JpbmQgPSBbXTtcblx0XHRcdGRhdGEgPSBjcmVhdGVNb2RlbCggdGhpcywgQ29tcG9uZW50LmRlZmF1bHRzLmRhdGEgfHwge30sIG9wdGlvbnMudGVtcGxhdGUuYSwgdG9CaW5kICk7XG5cdFx0XHRjcmVhdGVJbnN0YW5jZSggdGhpcywgQ29tcG9uZW50LCBkYXRhLCBvcHRpb25zLnRlbXBsYXRlLmYgKTtcblx0XHRcdGNyZWF0ZUJpbmRpbmdzKCB0aGlzLCB0b0JpbmQgKTtcblx0XHRcdHByb3BhZ2F0ZUV2ZW50cyggdGhpcywgb3B0aW9ucy50ZW1wbGF0ZS52ICk7XG5cdFx0XHQvLyBpbnRybywgb3V0cm8gYW5kIGRlY29yYXRvciBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0XG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUudDEgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MiB8fCBvcHRpb25zLnRlbXBsYXRlLm8gKSB7XG5cdFx0XHRcdHdhcm4oICdUaGUgXCJpbnRyb1wiLCBcIm91dHJvXCIgYW5kIFwiZGVjb3JhdG9yXCIgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdCBvbiBjb21wb25lbnRzJyApO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHR9O1xuXHR9KCB0eXBlcywgd2FybiwgY3JlYXRlTW9kZWwsIGNyZWF0ZUluc3RhbmNlLCBjcmVhdGVCaW5kaW5ncywgcHJvcGFnYXRlRXZlbnRzLCB1cGRhdGVMaXZlUXVlcmllcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBydW5sb29wLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHZhciBjaGlsZEluc3RhbmNlID0gdGhpcy5pbnN0YW5jZSxcblx0XHRcdFx0cGFyZW50SW5zdGFuY2UgPSBjaGlsZEluc3RhbmNlLl9wYXJlbnQsXG5cdFx0XHRcdGluZGV4UmVmQWxpYXMsIHF1ZXJ5O1xuXHRcdFx0dGhpcy5iaW5kaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWQ7XG5cdFx0XHRcdGlmICggYmluZGluZy5yb290ICE9PSBwYXJlbnRJbnN0YW5jZSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB1cGRhdGVkID0gZ2V0TmV3S2V5cGF0aCggYmluZGluZy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0YmluZGluZy5yZWJpbmQoIHVwZGF0ZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5jb21wbGV4UGFyYW1ldGVycy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdGlmICggdGhpcy55aWVsZGVyc1sgMCBdICkge1xuXHRcdFx0XHRyZWJpbmQoIHRoaXMueWllbGRlcnNbIDAgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleFJlZkFsaWFzID0gdGhpcy5pbmRleFJlZkJpbmRpbmdzWyBpbmRleFJlZiBdICkge1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggY2hpbGRJbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0Y2hpbGRJbnN0YW5jZS52aWV3bW9kZWwuc2V0KCBpbmRleFJlZkFsaWFzLCBuZXdJbmRleCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBxdWVyeSA9IHRoaXMucm9vdC5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIHRoaXMubmFtZSBdICkge1xuXHRcdFx0XHRxdWVyeS5fbWFrZURpcnR5KCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlYmluZCggeCApIHtcblx0XHRcdFx0eC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZW5kZXIgPSBmdW5jdGlvbiBDb21wb25lbnQkcmVuZGVyKCkge1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cdFx0aW5zdGFuY2UucmVuZGVyKCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSApO1xuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiBpbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHRvU3RyaW5nID0gZnVuY3Rpb24gQ29tcG9uZW50JHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5iaW5kID0gZnVuY3Rpb24oIEhvb2ssIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgdGVhcmRvd25Ib29rID0gbmV3IEhvb2soICd0ZWFyZG93bicgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIENvbXBvbmVudCR1bmJpbmQoKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXHRcdFx0dGhpcy5jb21wbGV4UGFyYW1ldGVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRyZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoIHRoaXMgKTtcblx0XHRcdC8vIHRlYXJkb3duIHRoZSBpbnN0YW5jZVxuXHRcdFx0aW5zdGFuY2UuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRpbnN0YW5jZS52aWV3bW9kZWwudGVhcmRvd24oKTtcblx0XHRcdGlmICggaW5zdGFuY2UuZnJhZ21lbnQucmVuZGVyZWQgJiYgaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgaW5zdGFuY2UgKTtcblx0XHRcdH1cblx0XHRcdHRlYXJkb3duSG9vay5maXJlKCBpbnN0YW5jZSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIHRoaW5nICkge1xuXHRcdFx0dGhpbmcudW5iaW5kKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKCBjb21wb25lbnQgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UsIHF1ZXJ5O1xuXHRcdFx0aW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKCBxdWVyeSA9IGluc3RhbmNlLl9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgY29tcG9uZW50Lm5hbWUgXSApIHtcblx0XHRcdFx0XHRxdWVyeS5fcmVtb3ZlKCBjb21wb25lbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGluc3RhbmNlID0gaW5zdGFuY2UuX3BhcmVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiBDb21wb25lbnQkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcblx0XHR0aGlzLmluc3RhbmNlLnVucmVuZGVyKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvX0NvbXBvbmVudC5qcyAqL1xuXHR2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24oIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMsIENvbnN0cnVjdG9yICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zLCBDb25zdHJ1Y3RvciApO1xuXHRcdH07XG5cdFx0Q29tcG9uZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBDb21wb25lbnQ7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5yZW5kZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbW1lbnQuanMgKi9cblx0dmFyIENvbW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIGRldGFjaCApIHtcblxuXHRcdHZhciBDb21tZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5DT01NRU5UO1xuXHRcdFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudGVtcGxhdGUuYztcblx0XHR9O1xuXHRcdENvbW1lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCB0aGlzLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnPCEtLScgKyB0aGlzLnZhbHVlICsgJy0tPic7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMubm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tbWVudDtcblx0fSggdHlwZXMsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvWWllbGRlci5qcyAqL1xuXHR2YXIgWWllbGRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0dmFyIFlpZWxkZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHZhciBjb21wb25lbnRJbnN0YW5jZSwgY29tcG9uZW50O1xuXHRcdFx0Y29tcG9uZW50SW5zdGFuY2UgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGNvbXBvbmVudEluc3RhbmNlLmNvbXBvbmVudDtcblx0XHRcdHRoaXMuc3Vycm9nYXRlUGFyZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRyb290OiBjb21wb25lbnRJbnN0YW5jZS55aWVsZC5pbnN0YW5jZSxcblx0XHRcdFx0dGVtcGxhdGU6IGNvbXBvbmVudEluc3RhbmNlLnlpZWxkLnRlbXBsYXRlLFxuXHRcdFx0XHRwRWxlbWVudDogdGhpcy5zdXJyb2dhdGVQYXJlbnQucEVsZW1lbnRcblx0XHRcdH0gKTtcblx0XHRcdGNvbXBvbmVudC55aWVsZGVycy5wdXNoKCB0aGlzICk7XG5cdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY29tcG9uZW50LnlpZWxkZXJzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQSBjb21wb25lbnQgdGVtcGxhdGUgY2FuIG9ubHkgaGF2ZSBvbmUge3t5aWVsZH19IGRlY2xhcmF0aW9uIGF0IGEgdGltZScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0WWllbGRlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbDogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3Vycm9nYXRlUGFyZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5yZW5kZXIoKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuY29tcG9uZW50LnlpZWxkZXJzLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFlpZWxkZXI7XG5cdH0oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUl0ZW0uanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdF9jcmVhdGVJdGVtID0gZnVuY3Rpb24oIHR5cGVzLCBUZXh0LCBJbnRlcnBvbGF0b3IsIFNlY3Rpb24sIFRyaXBsZSwgRWxlbWVudCwgUGFydGlhbCwgZ2V0Q29tcG9uZW50LCBDb21wb25lbnQsIENvbW1lbnQsIFlpZWxkZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlSXRlbSggb3B0aW9ucyApIHtcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRleHQoIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoIG9wdGlvbnMudGVtcGxhdGUudCApIHtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlRFUlBPTEFUT1I6XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnIgPT09ICd5aWVsZCcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFlpZWxkZXIoIG9wdGlvbnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBJbnRlcnBvbGF0b3IoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgU2VjdGlvbiggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlRSSVBMRTpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRyaXBsZSggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkVMRU1FTlQ6XG5cdFx0XHRcdFx0dmFyIGNvbnN0cnVjdG9yO1xuXHRcdFx0XHRcdGlmICggY29uc3RydWN0b3IgPSBnZXRDb21wb25lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdCwgb3B0aW9ucy50ZW1wbGF0ZS5lICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IENvbXBvbmVudCggb3B0aW9ucywgY29uc3RydWN0b3IgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBFbGVtZW50KCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuUEFSVElBTDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhcnRpYWwoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5DT01NRU5UOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgQ29tbWVudCggb3B0aW9ucyApO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1NvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMuIFRoYW5rcyEnICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIFRleHQsIEludGVycG9sYXRvciwgU2VjdGlvbiwgVHJpcGxlLCBFbGVtZW50LCBQYXJ0aWFsLCBnZXRDb21wb25lbnQsIENvbXBvbmVudCwgQ29tbWVudCwgWWllbGRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlLCBjcmVhdGVJdGVtICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgcGFyZW50UmVmcywgcmVmO1xuXHRcdFx0Ly8gVGhlIGl0ZW0gdGhhdCBvd25zIHRoaXMgZnJhZ21lbnQgLSBhbiBlbGVtZW50LCBzZWN0aW9uLCBwYXJ0aWFsLCBvciBhdHRyaWJ1dGVcblx0XHRcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudCA9IHRoaXMub3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHQvLyBpbmhlcml0ZWQgcHJvcGVydGllc1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdFx0XHQvLyBJZiBwYXJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIHRoaXMgbWF5IG5vdCBiZSB0aGUgb25seSBmcmFnbWVudFxuXHRcdFx0Ly8gdGhhdCBiZWxvbmdzIHRvIGl0IC0gd2UgbmVlZCB0byBtYWtlIGEgbm90ZSBvZiB0aGUgaW5kZXhcblx0XHRcdGlmICggdGhpcy5vd25lci50eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdH1cblx0XHRcdC8vIGluZGV4IHJlZmVyZW5jZXMgKHRoZSAnaScgaW4ge3sjc2VjdGlvbjppfX0uLi57ey9zZWN0aW9ufX0pIG5lZWQgdG8gY2FzY2FkZVxuXHRcdFx0Ly8gZG93biB0aGUgdHJlZVxuXHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdFx0cGFyZW50UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdFx0aWYgKCBwYXJlbnRSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHRcdFx0Ly8gYXZvaWRzIG5lZWQgZm9yIGhhc093blByb3BlcnR5XG5cdFx0XHRcdFx0Zm9yICggcmVmIGluIHBhcmVudFJlZnMgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgcmVmIF0gPSBwYXJlbnRSZWZzWyByZWYgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy5pbmRleFJlZiApIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5pbmRleFJlZnMgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbmRleFJlZnMgPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgb3B0aW9ucy5pbmRleFJlZiBdID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWUgdG8gY3JlYXRlIHRoaXMgZnJhZ21lbnQncyBjaGlsZCBpdGVtc1xuXHRcdFx0Ly8gVEVNUCBzaG91bGQgdGhpcyBiZSBoYXBwZW5pbmc/XG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0b3B0aW9ucy50ZW1wbGF0ZSA9IFsgb3B0aW9ucy50ZW1wbGF0ZSBdO1xuXHRcdFx0fSBlbHNlIGlmICggIW9wdGlvbnMudGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9wdGlvbnMudGVtcGxhdGUgPSBbXTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaXRlbXMgPSBvcHRpb25zLnRlbXBsYXRlLm1hcCggZnVuY3Rpb24oIHRlbXBsYXRlLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlSXRlbSgge1xuXHRcdFx0XHRcdHBhcmVudEZyYWdtZW50OiB0aGlzJDAsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IG9wdGlvbnMucEVsZW1lbnQsXG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmFyZ3NMaXN0ID0gbnVsbDtcblx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblx0XHRcdHRoaXMuYm91bmQgPSB0cnVlO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBjcmVhdGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdF9jcmVhdGVJdGVtICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBhc3NpZ25OZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dGhpcy5pbmRleCA9IG5ld0luZGV4O1xuXHRcdFx0Ly8gYXNzaWduIG5ldyBjb250ZXh0IGtleXBhdGggaWYgbmVlZGVkXG5cdFx0XHRhc3NpZ25OZXdLZXlwYXRoKCB0aGlzLCAnY29udGV4dCcsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdGlmICggdGhpcy5pbmRleFJlZnMgJiYgdGhpcy5pbmRleFJlZnNbIGluZGV4UmVmIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIGluZGV4UmVmIF0gPSBuZXdJbmRleDtcblx0XHRcdH1cblx0XHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdGlmICggaXRlbS5yZWJpbmQgKSB7XG5cdFx0XHRcdFx0aXRlbS5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggYXNzaWduTmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRyZW5kZXIgPSBmdW5jdGlvbiBGcmFnbWVudCRyZW5kZXIoKSB7XG5cdFx0dmFyIHJlc3VsdDtcblx0XHRpZiAoIHRoaXMuaXRlbXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cmVzdWx0ID0gdGhpcy5pdGVtc1sgMCBdLnJlbmRlcigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRyZXN1bHQuYXBwZW5kQ2hpbGQoIGl0ZW0ucmVuZGVyKCkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR0b1N0cmluZyA9IGZ1bmN0aW9uIEZyYWdtZW50JHRvU3RyaW5nKCBlc2NhcGUgKSB7XG5cdFx0aWYgKCAhdGhpcy5pdGVtcyApIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtLnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHR9ICkuam9pbiggJycgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5iaW5kID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBGcmFnbWVudCR1bmJpbmQoKSB7XG5cdFx0XHRpZiAoICF0aGlzLmJvdW5kICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIHVuYmluZEl0ZW0gKTtcblx0XHRcdHRoaXMuYm91bmQgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kSXRlbSggaXRlbSApIHtcblx0XHRcdGlmICggaXRlbS51bmJpbmQgKSB7XG5cdFx0XHRcdGl0ZW0udW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVucmVuZGVyID0gZnVuY3Rpb24gRnJhZ21lbnQkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0aWYgKCAhdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0F0dGVtcHRlZCB0byB1bnJlbmRlciBhIGZyYWdtZW50IHRoYXQgd2FzIG5vdCByZW5kZXJlZCcgKTtcblx0XHR9XG5cdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHJldHVybiBpLnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0fSApO1xuXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50LmpzICovXG5cdHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uKCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBnZXROb2RlLCBnZXRWYWx1ZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRGcmFnbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldE5vZGU6IGdldE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogZ2V0VmFsdWUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRjaXJjdWxhci5GcmFnbWVudCA9IEZyYWdtZW50O1xuXHRcdHJldHVybiBGcmFnbWVudDtcblx0fSggdmlydHVhbGRvbV9GcmFnbWVudCRidWJibGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZGV0YWNoLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9GcmFnbWVudCRmaXJzdE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0Tm9kZSwgdmlydHVhbGRvbV9GcmFnbWVudCRnZXRWYWx1ZSwgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0LCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlYmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCRyZW5kZXIsIHZpcnR1YWxkb21fRnJhZ21lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5iaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVucmVuZGVyLCBjaXJjdWxhciApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3Jlc2V0LmpzICovXG5cdHZhciBSYWN0aXZlJHJlc2V0ID0gZnVuY3Rpb24oIEhvb2ssIHJ1bmxvb3AsIEZyYWdtZW50LCBjb25maWcgKSB7XG5cblx0XHR2YXIgc2hvdWxkUmVyZW5kZXIgPSBbXG5cdFx0XHRcdCd0ZW1wbGF0ZScsXG5cdFx0XHRcdCdwYXJ0aWFscycsXG5cdFx0XHRcdCdjb21wb25lbnRzJyxcblx0XHRcdFx0J2RlY29yYXRvcnMnLFxuXHRcdFx0XHQnZXZlbnRzJ1xuXHRcdFx0XSxcblx0XHRcdHJlc2V0SG9vayA9IG5ldyBIb29rKCAncmVzZXQnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXQoIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2UsIHdyYXBwZXIsIGNoYW5nZXMsIGksIHJlcmVuZGVyO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YScgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZSByb290IG9iamVjdCBpcyB3cmFwcGVkLCB0cnkgYW5kIHVzZSB0aGUgd3JhcHBlcidzIHJlc2V0IHZhbHVlXG5cdFx0XHRpZiAoICggd3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbICcnIF0gKSAmJiB3cmFwcGVyLnJlc2V0ICkge1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIucmVzZXQoIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgd2FzIHJlamVjdGVkLCB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIG9iamVjdFxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcblx0XHRcdGNoYW5nZXMgPSBjb25maWcucmVzZXQoIHRoaXMgKTtcblx0XHRcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZFJlcmVuZGVyLmluZGV4T2YoIGNoYW5nZXNbIGkgXSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmVyZW5kZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlcmVuZGVyICkge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50O1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG5cdFx0XHRcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuXHRcdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcblx0XHRcdFx0aWYgKCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51bnJlbmRlcigpO1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdHJvb3Q6IHRoaXMsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fVxuXHRcdFx0cmVzZXRIb29rLmZpcmUoIHRoaXMsIGRhdGEgKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJ1bmxvb3AsIEZyYWdtZW50LCBjb25maWcgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXNldFRlbXBsYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJHJlc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiggY29uZmlnLCBGcmFnbWVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0VGVtcGxhdGUoIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIHRyYW5zaXRpb25zRW5hYmxlZCwgY29tcG9uZW50O1xuXHRcdFx0Y29uZmlnLnRlbXBsYXRlLmluaXQoIG51bGwsIHRoaXMsIHtcblx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlXG5cdFx0XHR9ICk7XG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG5cdFx0XHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcblx0XHRcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuXHRcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcblx0XHRcdGlmICggY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQgKSB7XG5cdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMudW5yZW5kZXIoKTtcblx0XHRcdGlmICggY29tcG9uZW50ICkge1xuXHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVtb3ZlIGV4aXN0aW5nIGZyYWdtZW50IGFuZCBjcmVhdGUgbmV3IG9uZVxuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG5cdFx0XHRcdHJvb3Q6IHRoaXMsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnJlbmRlciggdGhpcy5lbCwgdGhpcy5hbmNob3IgKTtcblx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdH07XG5cdH0oIGNvbmZpZywgRnJhZ21lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXZlcnNlLmpzICovXG5cdHZhciBSYWN0aXZlJHJldmVyc2UgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3JldmVyc2UnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzZXQgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNPYmplY3QsIG5vcm1hbGlzZUtleXBhdGgsIGdldE1hdGNoaW5nS2V5cGF0aHMgKSB7XG5cblx0XHR2YXIgd2lsZGNhcmQgPSAvXFwqLztcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRzZXQoIGtleXBhdGgsIHZhbHVlLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIG1hcCwgcHJvbWlzZTtcblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHQvLyBTZXQgbXVsdGlwbGUga2V5cGF0aHMgaW4gb25lIGdvXG5cdFx0XHRpZiAoIGlzT2JqZWN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdG1hcCA9IGtleXBhdGg7XG5cdFx0XHRcdGNhbGxiYWNrID0gdmFsdWU7XG5cdFx0XHRcdGZvciAoIGtleXBhdGggaW4gbWFwICkge1xuXHRcdFx0XHRcdGlmICggbWFwLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG1hcFsga2V5cGF0aCBdO1xuXHRcdFx0XHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGdldE1hdGNoaW5nS2V5cGF0aHMoIHRoaXMsIGtleXBhdGggKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMkMC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNPYmplY3QsIG5vcm1hbGlzZUtleXBhdGgsIGdldE1hdGNoaW5nS2V5cGF0aHMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGlmdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGlmdCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc2hpZnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NvcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc29ydCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc29ydCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc3BsaWNlLmpzICovXG5cdHZhciBSYWN0aXZlJHNwbGljZSA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc3BsaWNlJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zdWJ0cmFjdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzdWJ0cmFjdCA9IGZ1bmN0aW9uKCBhZGQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRzdWJ0cmFjdCgga2V5cGF0aCwgZCApIHtcblx0XHRcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IC0xIDogLWQgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9hZGQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR0ZWFyZG93biA9IGZ1bmN0aW9uKCBIb29rLCBQcm9taXNlLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgdGVhcmRvd25Ib29rID0gbmV3IEhvb2soICd0ZWFyZG93bicgKTtcblx0XHQvLyBUZWFyZG93bi4gVGhpcyBnb2VzIHRocm91Z2ggdGhlIHJvb3QgZnJhZ21lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW4sIHJlbW92aW5nIG9ic2VydmVyc1xuXHRcdC8vIGFuZCBnZW5lcmFsbHkgY2xlYW5pbmcgdXAgYWZ0ZXIgaXRzZWxmXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdGVhcmRvd24oIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2U7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwudGVhcmRvd24oKTtcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudC5yZW5kZXJlZCAmJiB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zaG91bGREZXN0cm95ID0gdHJ1ZTtcblx0XHRcdHByb21pc2UgPSB0aGlzLmZyYWdtZW50LnJlbmRlcmVkID8gdGhpcy51bnJlbmRlcigpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHR0ZWFyZG93bkhvb2suZmlyZSggdGhpcyApO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0Ly8gVE9ETyBkZXByZWNhdGUgdGhpcz9cblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIFByb21pc2UsIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3RvZ2dsZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR0b2dnbGUgPSBmdW5jdGlvbiggbG9nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdG9nZ2xlKCBrZXlwYXRoLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsb2cuZXJyb3JPbmx5KCB7XG5cdFx0XHRcdFx0ZGVidWc6IHRoaXMuZGVidWcsXG5cdFx0XHRcdFx0bWVzc3NhZ2U6ICdiYWRBcmd1bWVudHMnLFxuXHRcdFx0XHRcdGFyZzoge1xuXHRcdFx0XHRcdFx0YXJndW1lbnRzOiBrZXlwYXRoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoIGtleXBhdGgsICF2YWx1ZSwgY2FsbGJhY2sgKTtcblx0XHR9O1xuXHR9KCBsb2cgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90b0hUTUwuanMgKi9cblx0dmFyIFJhY3RpdmUkdG9IVE1MID0gZnVuY3Rpb24gUmFjdGl2ZSR0b0hUTUwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIHRydWUgKTtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1bnJlbmRlciA9IGZ1bmN0aW9uKCBjc3MsIEhvb2ssIGxvZywgUHJvbWlzZSwgcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICkge1xuXG5cdFx0dmFyIHVucmVuZGVySG9vayA9IG5ldyBIb29rKCAndW5yZW5kZXInICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdW5yZW5kZXIoKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwcm9taXNlLCBzaG91bGREZXN0cm95O1xuXHRcdFx0aWYgKCAhdGhpcy5mcmFnbWVudC5yZW5kZXJlZCApIHtcblx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAncmFjdGl2ZS51bnJlbmRlcigpIHdhcyBjYWxsZWQgb24gYSBSYWN0aXZlIGluc3RhbmNlIHRoYXQgd2FzIG5vdCByZW5kZXJlZCdcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgYW5kIHRoZSBjb21wb25lbnQgaXNuJ3QgbWFya2VkIGZvciBkZXN0cnVjdGlvbixcblx0XHRcdC8vIGRvbid0IGRldGFjaCBub2RlcyBmcm9tIHRoZSBET00gdW5uZWNlc3NhcmlseVxuXHRcdFx0c2hvdWxkRGVzdHJveSA9ICF0aGlzLmNvbXBvbmVudCB8fCB0aGlzLmNvbXBvbmVudC5zaG91bGREZXN0cm95IHx8IHRoaXMuc2hvdWxkRGVzdHJveTtcblx0XHRcdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5jc3MgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y3NzLnJlbW92ZSggdGhpcyQwLmNvbnN0cnVjdG9yICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIENhbmNlbCBhbnkgYW5pbWF0aW9ucyBpbiBwcm9ncmVzc1xuXHRcdFx0d2hpbGUgKCB0aGlzLl9hbmltYXRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnNbIDAgXS5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHR1bnJlbmRlckhvb2suZmlyZSggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIGdsb2JhbF9jc3MsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIGxvZywgUHJvbWlzZSwgcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5zaGlmdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1bnNoaWZ0ID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICd1bnNoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdXBkYXRlID0gZnVuY3Rpb24oIEhvb2ssIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgdXBkYXRlSG9vayA9IG5ldyBIb29rKCAndXBkYXRlJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZSgga2V5cGF0aCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9ICcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGggfHwgJyc7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwubWFyaygga2V5cGF0aCApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdHVwZGF0ZUhvb2suZmlyZSggdGhpcywga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJ1bmxvb3AgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91cGRhdGVNb2RlbC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1cGRhdGVNb2RlbCA9IGZ1bmN0aW9uKCBhcnJheUNvbnRlbnRzTWF0Y2gsIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKCBrZXlwYXRoLCBjYXNjYWRlICkge1xuXHRcdFx0dmFyIHZhbHVlcztcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRrZXlwYXRoID0gJyc7XG5cdFx0XHRcdGNhc2NhZGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCB0aGlzLCBrZXlwYXRoLCB2YWx1ZXMgPSB7fSwgY2FzY2FkZSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCB2YWx1ZXMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCByYWN0aXZlLCBrZXlwYXRoLCB2YWx1ZXMsIGNhc2NhZGUgKSB7XG5cdFx0XHR2YXIgYmluZGluZ3MsIGNoaWxkRGVwcywgaSwgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjaGVja2JveEdyb3VwcyA9IFtdO1xuXHRcdFx0YmluZGluZ3MgPSByYWN0aXZlLl90d293YXlCaW5kaW5nc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBiaW5kaW5ncyAmJiAoIGkgPSBiaW5kaW5ncy5sZW5ndGggKSApIHtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuXHRcdFx0XHRcdGlmICggYmluZGluZy5yYWRpb05hbWUgJiYgIWJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cblx0XHRcdFx0XHQvLyB3ZSB3YW50IHRvIGdldCB0aGUgdmFsdWUgb25jZSBhdCBtb3N0XG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmNoZWNrYm94TmFtZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNoZWNrYm94R3JvdXBzWyBiaW5kaW5nLmtleXBhdGggXSAmJiAhYmluZGluZy5jaGFuZ2VkKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goIGJpbmRpbmcua2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRjaGVja2JveEdyb3Vwc1sgYmluZGluZy5rZXlwYXRoIF0gPSBiaW5kaW5nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCBhcnJheUNvbnRlbnRzTWF0Y2goIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWlzRXF1YWwoIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0dmFsdWVzWyBrZXlwYXRoIF0gPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBncm91cHMgb2YgYDxpbnB1dCB0eXBlPSdjaGVja2JveCcgbmFtZT0ne3tmb299fScgLi4uPmBcblx0XHRcdGlmICggY2hlY2tib3hHcm91cHMubGVuZ3RoICkge1xuXHRcdFx0XHRjaGVja2JveEdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXHRcdFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1sga2V5cGF0aCBdO1xuXHRcdFx0XHRcdC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCAhYXJyYXlDb250ZW50c01hdGNoKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gbmV3VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjYXNjYWRlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXNjYWRlXG5cdFx0XHRjaGlsZERlcHMgPSByYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwWyAnZGVmYXVsdCcgXVsga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjaGlsZERlcHMgKSB7XG5cdFx0XHRcdGkgPSBjaGlsZERlcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHJhY3RpdmUsIGNoaWxkRGVwc1sgaSBdLCB2YWx1ZXMsIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGFycmF5Q29udGVudHNNYXRjaCwgaXNFcXVhbCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlLmpzICovXG5cdHZhciBwcm90b3R5cGUgPSBmdW5jdGlvbiggYWRkLCBhbmltYXRlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaXJlLCBnZXQsIGluc2VydCwgbWVyZ2UsIG9ic2VydmUsIG9mZiwgb24sIHBvcCwgcHVzaCwgcmVuZGVyLCByZXNldCwgcmVzZXRUZW1wbGF0ZSwgcmV2ZXJzZSwgc2V0LCBzaGlmdCwgc29ydCwgc3BsaWNlLCBzdWJ0cmFjdCwgdGVhcmRvd24sIHRvZ2dsZSwgdG9IVE1MLCB1bnJlbmRlciwgdW5zaGlmdCwgdXBkYXRlLCB1cGRhdGVNb2RlbCApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRhZGQ6IGFkZCxcblx0XHRcdGFuaW1hdGU6IGFuaW1hdGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpcmU6IGZpcmUsXG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdGluc2VydDogaW5zZXJ0LFxuXHRcdFx0bWVyZ2U6IG1lcmdlLFxuXHRcdFx0b2JzZXJ2ZTogb2JzZXJ2ZSxcblx0XHRcdG9mZjogb2ZmLFxuXHRcdFx0b246IG9uLFxuXHRcdFx0cG9wOiBwb3AsXG5cdFx0XHRwdXNoOiBwdXNoLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNldDogcmVzZXQsXG5cdFx0XHRyZXNldFRlbXBsYXRlOiByZXNldFRlbXBsYXRlLFxuXHRcdFx0cmV2ZXJzZTogcmV2ZXJzZSxcblx0XHRcdHNldDogc2V0LFxuXHRcdFx0c2hpZnQ6IHNoaWZ0LFxuXHRcdFx0c29ydDogc29ydCxcblx0XHRcdHNwbGljZTogc3BsaWNlLFxuXHRcdFx0c3VidHJhY3Q6IHN1YnRyYWN0LFxuXHRcdFx0dGVhcmRvd246IHRlYXJkb3duLFxuXHRcdFx0dG9nZ2xlOiB0b2dnbGUsXG5cdFx0XHR0b0hUTUw6IHRvSFRNTCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlcixcblx0XHRcdHVuc2hpZnQ6IHVuc2hpZnQsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZSxcblx0XHRcdHVwZGF0ZU1vZGVsOiB1cGRhdGVNb2RlbFxuXHRcdH07XG5cdH0oIFJhY3RpdmUkYWRkLCBSYWN0aXZlJGFuaW1hdGUsIFJhY3RpdmUkZGV0YWNoLCBSYWN0aXZlJGZpbmQsIFJhY3RpdmUkZmluZEFsbCwgUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cywgUmFjdGl2ZSRmaW5kQ29tcG9uZW50LCBSYWN0aXZlJGZpcmUsIFJhY3RpdmUkZ2V0LCBSYWN0aXZlJGluc2VydCwgUmFjdGl2ZSRtZXJnZSwgUmFjdGl2ZSRvYnNlcnZlLCBSYWN0aXZlJG9mZiwgUmFjdGl2ZSRvbiwgUmFjdGl2ZSRwb3AsIFJhY3RpdmUkcHVzaCwgUmFjdGl2ZSRyZW5kZXIsIFJhY3RpdmUkcmVzZXQsIFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSwgUmFjdGl2ZSRyZXZlcnNlLCBSYWN0aXZlJHNldCwgUmFjdGl2ZSRzaGlmdCwgUmFjdGl2ZSRzb3J0LCBSYWN0aXZlJHNwbGljZSwgUmFjdGl2ZSRzdWJ0cmFjdCwgUmFjdGl2ZSR0ZWFyZG93biwgUmFjdGl2ZSR0b2dnbGUsIFJhY3RpdmUkdG9IVE1MLCBSYWN0aXZlJHVucmVuZGVyLCBSYWN0aXZlJHVuc2hpZnQsIFJhY3RpdmUkdXBkYXRlLCBSYWN0aXZlJHVwZGF0ZU1vZGVsICk7XG5cblx0LyogdXRpbHMvZ2V0R3VpZC5qcyAqL1xuXHR2YXIgZ2V0R3VpZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKCAvW3h5XS9nLCBmdW5jdGlvbiggYyApIHtcblx0XHRcdHZhciByLCB2O1xuXHRcdFx0ciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG5cdFx0XHR2ID0gYyA9PSAneCcgPyByIDogciAmIDMgfCA4O1xuXHRcdFx0cmV0dXJuIHYudG9TdHJpbmcoIDE2ICk7XG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHV0aWxzL2dldE5leHROdW1iZXIuanMgKi9cblx0dmFyIGdldE5leHROdW1iZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBpID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJ3ItJyArIGkrKztcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2hvb2tzL0hvb2tRdWV1ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9va1F1ZXVlID0gZnVuY3Rpb24oIEhvb2sgKSB7XG5cblx0XHRmdW5jdGlvbiBIb29rUXVldWUoIGV2ZW50ICkge1xuXHRcdFx0dGhpcy5ob29rID0gbmV3IEhvb2soIGV2ZW50ICk7XG5cdFx0XHR0aGlzLmluUHJvY2VzcyA9IHt9O1xuXHRcdFx0dGhpcy5xdWV1ZSA9IHt9O1xuXHRcdH1cblx0XHRIb29rUXVldWUucHJvdG90eXBlID0ge1xuXHRcdFx0Y29uc3RydWN0b3I6IEhvb2tRdWV1ZSxcblx0XHRcdGJlZ2luOiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dGhpcy5pblByb2Nlc3NbIHJhY3RpdmUuX2d1aWQgXSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0ZW5kOiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dmFyIHBhcmVudCA9IHJhY3RpdmUuX3BhcmVudDtcblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyAqaXNuJ3QqIGEgY2hpbGQgb2YgYSBjb21wb25lbnQgdGhhdCdzIGluIHByb2Nlc3MsXG5cdFx0XHRcdC8vIGl0IHNob3VsZCBjYWxsIG1ldGhvZHMgb3IgZmlyZSBhdCB0aGlzIHBvaW50XG5cdFx0XHRcdGlmICggIXBhcmVudCB8fCAhdGhpcy5pblByb2Nlc3NbIHBhcmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdGZpcmUoIHRoaXMsIHJhY3RpdmUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnZXRDaGlsZFF1ZXVlKCB0aGlzLnF1ZXVlLCBwYXJlbnQgKS5wdXNoKCByYWN0aXZlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHRoaXMuaW5Qcm9jZXNzWyByYWN0aXZlLl9ndWlkIF07XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldENoaWxkUXVldWUoIHF1ZXVlLCByYWN0aXZlICkge1xuXHRcdFx0cmV0dXJuIHF1ZXVlWyByYWN0aXZlLl9ndWlkIF0gfHwgKCBxdWV1ZVsgcmFjdGl2ZS5fZ3VpZCBdID0gW10gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaXJlKCBob29rUXVldWUsIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgY2hpbGRRdWV1ZSA9IGdldENoaWxkUXVldWUoIGhvb2tRdWV1ZS5xdWV1ZSwgcmFjdGl2ZSApO1xuXHRcdFx0aG9va1F1ZXVlLmhvb2suZmlyZSggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gcXVldWUgaXMgXCJsaXZlXCIgYmVjYXVzZSBjb21wb25lbnRzIGNhbiBlbmQgdXAgYmVpbmdcblx0XHRcdC8vIGFkZGVkIHdoaWxlIGhvb2tzIGZpcmUgb24gcGFyZW50cyB0aGF0IG1vZGlmeSBkYXRhIHZhbHVlcy5cblx0XHRcdHdoaWxlICggY2hpbGRRdWV1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdGZpcmUoIGhvb2tRdWV1ZSwgY2hpbGRRdWV1ZS5zaGlmdCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgaG9va1F1ZXVlLnF1ZXVlWyByYWN0aXZlLl9ndWlkIF07XG5cdFx0fVxuXHRcdHJldHVybiBIb29rUXVldWU7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2sgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcHJvY2Vzc1dyYXBwZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3Byb2Nlc3NXcmFwcGVyID0gZnVuY3Rpb24oIHdyYXBwZXIsIGFycmF5LCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzICkge1xuXHRcdHZhciByb290ID0gd3JhcHBlci5yb290LFxuXHRcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblx0XHQvLyBJZiB0aGlzIGlzIGEgc29ydCBvciByZXZlcnNlLCB3ZSBqdXN0IGRvIHJvb3Quc2V0KCkuLi5cblx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cblx0XHRpZiAoIG1ldGhvZE5hbWUgPT09ICdzb3J0JyB8fCBtZXRob2ROYW1lID09PSAncmV2ZXJzZScgKSB7XG5cdFx0XHRyb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIGFycmF5ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJvb3Qudmlld21vZGVsLnNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyApO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L2FycmF5QWRhcHRvci9wYXRjaC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcGF0Y2ggPSBmdW5jdGlvbiggcnVubG9vcCwgZGVmaW5lUHJvcGVydHksIGdldE5ld0luZGljZXMsIHByb2Nlc3NXcmFwcGVyICkge1xuXG5cdFx0dmFyIHBhdGNoZWRBcnJheVByb3RvID0gW10sXG5cdFx0XHRtdXRhdG9yTWV0aG9kcyA9IFtcblx0XHRcdFx0J3BvcCcsXG5cdFx0XHRcdCdwdXNoJyxcblx0XHRcdFx0J3JldmVyc2UnLFxuXHRcdFx0XHQnc2hpZnQnLFxuXHRcdFx0XHQnc29ydCcsXG5cdFx0XHRcdCdzcGxpY2UnLFxuXHRcdFx0XHQndW5zaGlmdCdcblx0XHRcdF0sXG5cdFx0XHR0ZXN0T2JqLCBwYXRjaEFycmF5TWV0aG9kcywgdW5wYXRjaEFycmF5TWV0aG9kcztcblx0XHRtdXRhdG9yTWV0aG9kcy5mb3JFYWNoKCBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdHZhciBtZXRob2QgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0XHRcdHZhciBhcmdzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblx0XHRcdFx0dmFyIG5ld0luZGljZXMsIHJlc3VsdCwgd3JhcHBlciwgaTtcblx0XHRcdFx0bmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXMoIHRoaXMsIG1ldGhvZE5hbWUsIGFyZ3MgKTtcblx0XHRcdFx0Ly8gYXBwbHkgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG5cdFx0XHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVsgbWV0aG9kTmFtZSBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0Ly8gdHJpZ2dlciBjaGFuZ2VzXG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoKTtcblx0XHRcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aSA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHR3cmFwcGVyID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVyc1sgaSBdO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB3cmFwcGVyLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cHJvY2Vzc1dyYXBwZXIoIHdyYXBwZXIsIHRoaXMsIG1ldGhvZE5hbWUsIG5ld0luZGljZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggcGF0Y2hlZEFycmF5UHJvdG8sIG1ldGhvZE5hbWUsIHtcblx0XHRcdFx0dmFsdWU6IG1ldGhvZFxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0XHQvLyBjYW4gd2UgdXNlIHByb3RvdHlwZSBjaGFpbiBpbmplY3Rpb24/XG5cdFx0Ly8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaG93LWVjbWFzY3JpcHQtNS1zdGlsbC1kb2VzLW5vdC1hbGxvdy10by1zdWJjbGFzcy1hbi1hcnJheS8jd3JhcHBlcnNfcHJvdG90eXBlX2NoYWluX2luamVjdGlvblxuXHRcdHRlc3RPYmogPSB7fTtcblx0XHRpZiAoIHRlc3RPYmouX19wcm90b19fICkge1xuXHRcdFx0Ly8geWVzLCB3ZSBjYW5cblx0XHRcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHRhcnJheS5fX3Byb3RvX18gPSBwYXRjaGVkQXJyYXlQcm90bztcblx0XHRcdH07XG5cdFx0XHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHRhcnJheS5fX3Byb3RvX18gPSBBcnJheS5wcm90b3R5cGU7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBubywgd2UgY2FuJ3Rcblx0XHRcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHR2YXIgaSwgbWV0aG9kTmFtZTtcblx0XHRcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0bWV0aG9kTmFtZSA9IG11dGF0b3JNZXRob2RzWyBpIF07XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCBtZXRob2ROYW1lLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogcGF0Y2hlZEFycmF5UHJvdG9bIG1ldGhvZE5hbWUgXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRkZWxldGUgYXJyYXlbIG11dGF0b3JNZXRob2RzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cGF0Y2hBcnJheU1ldGhvZHMudW5wYXRjaCA9IHVucGF0Y2hBcnJheU1ldGhvZHM7XG5cdFx0cmV0dXJuIHBhdGNoQXJyYXlNZXRob2RzO1xuXHR9KCBydW5sb29wLCBkZWZpbmVQcm9wZXJ0eSwgZ2V0TmV3SW5kaWNlcywgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcHJvY2Vzc1dyYXBwZXIgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnR5LCBpc0FycmF5LCBwYXRjaCApIHtcblxuXHRcdHZhciBhcnJheUFkYXB0b3IsXG5cdFx0XHQvLyBoZWxwZXJzXG5cdFx0XHRBcnJheVdyYXBwZXIsIGVycm9yTWVzc2FnZTtcblx0XHRhcnJheUFkYXB0b3IgPSB7XG5cdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cdFx0XHRcdC8vIHdyYXAgdGhlIGFycmF5IGlmIGEpIGIpIGl0J3MgYW4gYXJyYXksIGFuZCBiKSBlaXRoZXIgaXQgaGFzbid0IGJlZW4gd3JhcHBlZCBhbHJlYWR5LFxuXHRcdFx0XHQvLyBvciB0aGUgYXJyYXkgZGlkbid0IHRyaWdnZXIgdGhlIGdldCgpIGl0c2VsZlxuXHRcdFx0XHRyZXR1cm4gaXNBcnJheSggb2JqZWN0ICkgJiYgKCAhb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcblx0XHRcdGlmICggIWFycmF5Ll9yYWN0aXZlICkge1xuXHRcdFx0XHQvLyBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBfcmFjdGl2ZSBwcm9wZXJ0eSB0byBzdG9yZSB0aGUgd3JhcHBlcnNcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCAnX3JhY3RpdmUnLCB7XG5cdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdHdyYXBwZXJzOiBbXSxcblx0XHRcdFx0XHRcdGluc3RhbmNlczogW10sXG5cdFx0XHRcdFx0XHRzZXR0aW5nOiBmYWxzZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cGF0Y2goIGFycmF5ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuXHRcdFx0aWYgKCAhYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gKSB7XG5cdFx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdID0gMDtcblx0XHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2goIHJhY3RpdmUgKTtcblx0XHRcdH1cblx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdICs9IDE7XG5cdFx0XHRhcnJheS5fcmFjdGl2ZS53cmFwcGVycy5wdXNoKCB0aGlzICk7XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJyYXksIHN0b3JhZ2UsIHdyYXBwZXJzLCBpbnN0YW5jZXMsIGluZGV4O1xuXHRcdFx0XHRhcnJheSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHN0b3JhZ2UgPSBhcnJheS5fcmFjdGl2ZTtcblx0XHRcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuXHRcdFx0XHRpbnN0YW5jZXMgPSBzdG9yYWdlLmluc3RhbmNlcztcblx0XHRcdFx0Ly8gaWYgdGVhcmRvd24oKSB3YXMgaW52b2tlZCBiZWNhdXNlIHdlJ3JlIGNsZWFyaW5nIHRoZSBjYWNoZSBhcyBhIHJlc3VsdCBvZlxuXHRcdFx0XHQvLyBhIGNoYW5nZSB0aGF0IHRoZSBhcnJheSBpdHNlbGYgdHJpZ2dlcmVkLCB3ZSBjYW4gc2F2ZSBvdXJzZWx2ZXMgdGhlIHRlYXJkb3duXG5cdFx0XHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcblx0XHRcdFx0aWYgKCBzdG9yYWdlLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdyYXBwZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcblx0XHRcdFx0Ly8gbmF0dXJhbCBzdGF0ZVxuXHRcdFx0XHRpZiAoICF3cmFwcGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5Ll9yYWN0aXZlO1xuXHRcdFx0XHRcdHBhdGNoLnVucGF0Y2goIHRoaXMudmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgcmFjdGl2ZSBpbnN0YW5jZSBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdGluc3RhbmNlc1sgdGhpcy5yb290Ll9ndWlkIF0gLT0gMTtcblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbnN0YW5jZXMuaW5kZXhPZiggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGluc3RhbmNlcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRlcnJvck1lc3NhZ2UgPSAnU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5Jztcblx0XHRyZXR1cm4gYXJyYXlBZGFwdG9yO1xuXHR9KCBkZWZpbmVQcm9wZXJ0eSwgaXNBcnJheSwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcGF0Y2ggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9tYWdpY0FycmF5QWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciA9IGZ1bmN0aW9uKCBtYWdpY0FkYXB0b3IsIGFycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cdFx0aWYgKCBtYWdpY0FkYXB0b3IgKSB7XG5cdFx0XHRtYWdpY0FycmF5QWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHJldHVybiBtYWdpY0FkYXB0b3IuZmlsdGVyKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSAmJiBhcnJheUFkYXB0b3IuZmlsdGVyKCBvYmplY3QgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBtYWdpY0FkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5hcnJheVdyYXBwZXIgPSBhcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyLnRlYXJkb3duKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gbWFnaWNBcnJheUFkYXB0b3I7XG5cdH0oIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvYWRhcHQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhZGFwdCA9IGZ1bmN0aW9uKCBjb25maWcsIGFycmF5QWRhcHRvciwgbG9nLCBtYWdpY0FkYXB0b3IsIG1hZ2ljQXJyYXlBZGFwdG9yICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBwcmVmaXhlcnMgPSB7fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRhZGFwdCgga2V5cGF0aCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcmFjdGl2ZSA9IHRoaXMucmFjdGl2ZSxcblx0XHRcdFx0bGVuLCBpLCBhZGFwdG9yLCB3cmFwcGVkO1xuXHRcdFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuXHRcdFx0bGVuID0gcmFjdGl2ZS5hZGFwdC5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRhZGFwdG9yID0gcmFjdGl2ZS5hZGFwdFsgaSBdO1xuXHRcdFx0XHQvLyBBZGFwdG9ycyBjYW4gYmUgc3BlY2lmaWVkIGFzIGUuZy4gWyAnQmFja2JvbmUuTW9kZWwnLCAnQmFja2JvbmUuQ29sbGVjdGlvbicgXSAtXG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gZ2V0IHRoZSBhY3R1YWwgYWRhcHRvciBpZiB0aGF0J3MgdGhlIGNhc2Vcblx0XHRcdFx0aWYgKCB0eXBlb2YgYWRhcHRvciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dmFyIGZvdW5kID0gY29uZmlnLnJlZ2lzdHJpZXMuYWRhcHRvcnMuZmluZCggcmFjdGl2ZSwgYWRhcHRvciApO1xuXHRcdFx0XHRcdGlmICggIWZvdW5kICkge1xuXHRcdFx0XHRcdFx0Ly8gd2lsbCB0aHJvdy4gXCJyZXR1cm5cIiBmb3Igc2FmZXR5LCBpZiB3ZSBkb3duZ3JhZGUgOilcblx0XHRcdFx0XHRcdHJldHVybiBsb2cuY3JpdGljYWwoIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHBsdWdpbjogJ2FkYXB0b3InLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGFkYXB0b3Jcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhZGFwdG9yID0gcmFjdGl2ZS5hZGFwdFsgaSBdID0gZm91bmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0XHR3cmFwcGVkID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBhZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoLCBnZXRQcmVmaXhlcigga2V5cGF0aCApICk7XG5cdFx0XHRcdFx0d3JhcHBlZC52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByYWN0aXZlLm1hZ2ljICkge1xuXHRcdFx0XHRpZiAoIG1hZ2ljQXJyYXlBZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZWRbIGtleXBhdGggXSA9IG1hZ2ljQXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hZ2ljQWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBtYWdpY0FkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggcmFjdGl2ZS5tb2RpZnlBcnJheXMgJiYgYXJyYXlBZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBhcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJlZml4S2V5cGF0aCggb2JqLCBwcmVmaXggKSB7XG5cdFx0XHR2YXIgcHJlZml4ZWQgPSB7fSxcblx0XHRcdFx0a2V5O1xuXHRcdFx0aWYgKCAhcHJlZml4ICkge1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fVxuXHRcdFx0cHJlZml4ICs9ICcuJztcblx0XHRcdGZvciAoIGtleSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggb2JqLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHRwcmVmaXhlZFsgcHJlZml4ICsga2V5IF0gPSBvYmpbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJlZml4ZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UHJlZml4ZXIoIHJvb3RLZXlwYXRoICkge1xuXHRcdFx0dmFyIHJvb3REb3Q7XG5cdFx0XHRpZiAoICFwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHJvb3REb3QgPSByb290S2V5cGF0aCA/IHJvb3RLZXlwYXRoICsgJy4nIDogJyc7XG5cdFx0XHRcdHByZWZpeGVyc1sgcm9vdEtleXBhdGggXSA9IGZ1bmN0aW9uKCByZWxhdGl2ZUtleXBhdGgsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBvYmo7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdG9iaiA9IHt9O1xuXHRcdFx0XHRcdFx0b2JqWyByb290RG90ICsgcmVsYXRpdmVLZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdFx0XHQvLyAncmVsYXRpdmVLZXlwYXRoJyBpcyBpbiBmYWN0IGEgaGFzaCwgbm90IGEga2V5cGF0aFxuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3REb3QgPyBwcmVmaXhLZXlwYXRoKCByZWxhdGl2ZUtleXBhdGgsIHJvb3RLZXlwYXRoICkgOiByZWxhdGl2ZUtleXBhdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWZpeGVyc1sgcm9vdEtleXBhdGggXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjb25maWcsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yLCBsb2csIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X21hZ2ljQXJyYXlBZGFwdG9yICk7XG5cblx0Lyogdmlld21vZGVsL2hlbHBlcnMvZ2V0VXBzdHJlYW1DaGFuZ2VzLmpzICovXG5cdHZhciBnZXRVcHN0cmVhbUNoYW5nZXMgPSBmdW5jdGlvbiBnZXRVcHN0cmVhbUNoYW5nZXMoIGNoYW5nZXMgKSB7XG5cdFx0dmFyIHVwc3RyZWFtQ2hhbmdlcyA9IFsgJycgXSxcblx0XHRcdGksIGtleXBhdGgsIGtleXMsIHVwc3RyZWFtS2V5cGF0aDtcblx0XHRpID0gY2hhbmdlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRrZXlwYXRoID0gY2hhbmdlc1sgaSBdO1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHVwc3RyZWFtS2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdGlmICggdXBzdHJlYW1DaGFuZ2VzLmluZGV4T2YoIHVwc3RyZWFtS2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMucHVzaCggdXBzdHJlYW1LZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVwc3RyZWFtQ2hhbmdlcztcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy9nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHN0YXJNYXBzID0ge307XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuXHRcdC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG5cdFx0Ly8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuXHRcdC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG5cdFx0Ly8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuXHRcdC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcygga2V5cGF0aCApIHtcblx0XHRcdHZhciBrZXlzLCBzdGFyTWFwLCBtYXBwZXIsIHJlc3VsdDtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKCBrZXlzLmxlbmd0aCApO1xuXHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIHN0YXIsIGkgKSB7XG5cdFx0XHRcdHJldHVybiBzdGFyID8gJyonIDoga2V5c1sgaSBdO1xuXHRcdFx0fTtcblx0XHRcdHJlc3VsdCA9IHN0YXJNYXAubWFwKCBmdW5jdGlvbiggbWFzayApIHtcblx0XHRcdFx0cmV0dXJuIG1hc2subWFwKCBtYXBwZXIgKS5qb2luKCAnLicgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHRoZSBwb3NzaWJsZSB0cnVlL2ZhbHNlIGNvbWJpbmF0aW9ucyBmb3Jcblx0XHQvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcblx0XHQvLyBbIHRydWUsIHRydWUgXSwgWyB0cnVlLCBmYWxzZSBdLCBbIGZhbHNlLCB0cnVlIF0sIFsgZmFsc2UsIGZhbHNlIF0uXG5cdFx0Ly8gSXQgZG9lcyBzbyBieSBnZXR0aW5nIGFsbCB0aGUgYmluYXJ5IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGUuZy4gMTFcblx0XHRmdW5jdGlvbiBnZXRTdGFyTWFwKCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgb25lcyA9ICcnLFxuXHRcdFx0XHRtYXgsIGJpbmFyeSwgc3Rhck1hcCwgbWFwcGVyLCBpO1xuXHRcdFx0aWYgKCAhc3Rhck1hcHNbIGxlbmd0aCBdICkge1xuXHRcdFx0XHRzdGFyTWFwID0gW107XG5cdFx0XHRcdHdoaWxlICggb25lcy5sZW5ndGggPCBsZW5ndGggKSB7XG5cdFx0XHRcdFx0b25lcyArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heCA9IHBhcnNlSW50KCBvbmVzLCAyICk7XG5cdFx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBkaWdpdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGlnaXQgPT09ICcxJztcblx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPD0gbWF4OyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YmluYXJ5ID0gaS50b1N0cmluZyggMiApO1xuXHRcdFx0XHRcdHdoaWxlICggYmluYXJ5Lmxlbmd0aCA8IGxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGJpbmFyeSA9ICcwJyArIGJpbmFyeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Rhck1hcFsgaSBdID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKCBiaW5hcnksIG1hcHBlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJNYXBzWyBsZW5ndGggXSA9IHN0YXJNYXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3Rhck1hcHNbIGxlbmd0aCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy9ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMgPSBmdW5jdGlvbiggZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBsYXN0S2V5ID0gL1teXFwuXSskLztcblx0XHRfX2V4cG9ydCA9IG5vdGlmeVBhdHRlcm5PYnNlcnZlcnM7XG5cblx0XHRmdW5jdGlvbiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGtleXBhdGgsIG9ubHlEaXJlY3QgKSB7XG5cdFx0XHR2YXIgcG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzO1xuXHRcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGtleXBhdGggKTtcblx0XHRcdGlmICggb25seURpcmVjdCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBrZXlwYXRoICk7XG5cdFx0XHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuZm9yRWFjaCggZnVuY3Rpb24oIHVwc3RyZWFtUGF0dGVybiApIHtcblx0XHRcdFx0Y2FzY2FkZSggdmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYXNjYWRlKCB2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCApIHtcblx0XHRcdHZhciBncm91cCwgbWFwLCBhY3R1YWxDaGlsZEtleXBhdGg7XG5cdFx0XHRncm91cCA9IHZpZXdtb2RlbC5kZXBzTWFwLnBhdHRlcm5PYnNlcnZlcnM7XG5cdFx0XHRtYXAgPSBncm91cFsgdXBzdHJlYW1QYXR0ZXJuIF07XG5cdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0bWFwLmZvckVhY2goIGZ1bmN0aW9uKCBjaGlsZEtleXBhdGggKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGxhc3RLZXkuZXhlYyggY2hpbGRLZXlwYXRoIClbIDAgXTtcblx0XHRcdFx0XHQvLyAnYmF6J1xuXHRcdFx0XHRcdGFjdHVhbENoaWxkS2V5cGF0aCA9IGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHRcdC8vICdmb28uYmFyLmJheidcblx0XHRcdFx0XHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwgYWN0dWFsQ2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0Y2FzY2FkZSggdmlld21vZGVsLCBjaGlsZEtleXBhdGgsIGFjdHVhbENoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR2aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5mb3JFYWNoKCBmdW5jdGlvbiggb2JzZXJ2ZXIgKSB7XG5cdFx0XHRcdGlmICggb2JzZXJ2ZXIucmVnZXgudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdG9ic2VydmVyLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdmlld21vZGVsJGFwcGx5Q2hhbmdlc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uKCBnZXRVcHN0cmVhbUNoYW5nZXMsIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGNoYW5nZXMsIHVwc3RyZWFtQ2hhbmdlcywgaGFzaCA9IHt9O1xuXHRcdFx0Y2hhbmdlcyA9IHRoaXMuY2hhbmdlcztcblx0XHRcdGlmICggIWNoYW5nZXMubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBUT0RPIHdlIGVuZCB1cCBoZXJlIG9uIGluaXRpYWwgcmVuZGVyLiBQZXJoYXBzIHdlIHNob3VsZG4ndD9cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYXNjYWRlKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgbWFwLCBkZXBlbmRhbnRzLCBrZXlzO1xuXHRcdFx0XHRpZiAoIHNlbGYubm9DYXNjYWRlLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZGVwZW5kYW50cyA9IHNlbGYuZGVwcy5jb21wdXRlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGRlcGVuZGFudHMuZm9yRWFjaCggaW52YWxpZGF0ZSApO1xuXHRcdFx0XHRcdGtleXMgPSBkZXBlbmRhbnRzLm1hcCggZ2V0S2V5ICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBtYXJrICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXAgPSBzZWxmLmRlcHNNYXAuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRtYXAuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG1hcmsoIGtleXBhdGggKSB7XG5cdFx0XHRcdHNlbGYubWFyaygga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHR1cHN0cmVhbUNoYW5nZXMgPSBnZXRVcHN0cmVhbUNoYW5nZXMoIGNoYW5nZXMgKTtcblx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGRlcGVuZGFudHMsIGtleXM7XG5cdFx0XHRcdGlmICggZGVwZW5kYW50cyA9IHNlbGYuZGVwcy5jb21wdXRlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGRlcGVuZGFudHMuZm9yRWFjaCggaW52YWxpZGF0ZSApO1xuXHRcdFx0XHRcdGtleXMgPSBkZXBlbmRhbnRzLm1hcCggZ2V0S2V5ICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBtYXJrICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXHRcdFx0Ly8gUGF0dGVybiBvYnNlcnZlcnMgYXJlIGEgd2VpcmQgc3BlY2lhbCBjYXNlXG5cdFx0XHRpZiAoIHRoaXMucGF0dGVybk9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoLCB0cnVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZXBzLm9ic2VydmVycyApIHtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoIHRoaXMkMCwgbnVsbCwga2V5cGF0aCwgJ29ic2VydmVycycgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKCB0aGlzLCBjaGFuZ2VzLCAnb2JzZXJ2ZXJzJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlcHNbICdkZWZhdWx0JyBdICkge1xuXHRcdFx0XHR2YXIgYmluZGluZ3MgPSBbXTtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoIHRoaXMkMCwgYmluZGluZ3MsIGtleXBhdGgsICdkZWZhdWx0JyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggYmluZGluZ3MubGVuZ3RoICkge1xuXHRcdFx0XHRcdG5vdGlmeUJpbmRpbmdzKCB0aGlzLCBiaW5kaW5ncywgY2hhbmdlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vdGlmeUFsbERlcGVuZGFudHMoIHRoaXMsIGNoYW5nZXMsICdkZWZhdWx0JyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmV0dXJuIGEgaGFzaCBvZiBrZXlwYXRocyB0byB1cGRhdGVkIHZhbHVlc1xuXHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0aGFzaFsga2V5cGF0aCBdID0gdGhpcyQwLmdldCgga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcblx0XHRcdHRoaXMubm9DYXNjYWRlID0ge307XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW52YWxpZGF0ZSggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0S2V5KCBjb21wdXRhdGlvbiApIHtcblx0XHRcdHJldHVybiBjb21wdXRhdGlvbi5rZXk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGJpbmRpbmdzLCBrZXlwYXRoLCBncm91cE5hbWUgKSB7XG5cdFx0XHR2YXIgZGVwZW5kYW50cywgdmFsdWU7XG5cdFx0XHRpZiAoIGRlcGVuZGFudHMgPSBmaW5kRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUgKSApIHtcblx0XHRcdFx0dmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGRlcGVuZGFudHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgXCJzZXRcIiB0aGUgcGFyZW50IHZhbHVlLCByZWZpbmUgaXRcblx0XHRcdFx0XHQvLyBpLmUuIG5vdCBkYXRhID0gdmFsdWUsIGJ1dCBkYXRhW2Zvb10gPSBmb29WYWx1ZVxuXHRcdFx0XHRcdGlmICggYmluZGluZ3MgJiYgZC5yZWZpbmVWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGJpbmRpbmdzLnB1c2goIGQgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZC5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3RpZnlCaW5kaW5ncyggdmlld21vZGVsLCBiaW5kaW5ncywgY2hhbmdlcyApIHtcblx0XHRcdGJpbmRpbmdzLmZvckVhY2goIGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXHRcdFx0XHR2YXIgdXNlU2V0ID0gZmFsc2UsXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0bGVuZ3RoID0gY2hhbmdlcy5sZW5ndGgsXG5cdFx0XHRcdFx0cmVmaW5lbWVudHMgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBpIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdHZhciBrZXlwYXRoID0gY2hhbmdlc1sgaSBdO1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aCA9PT0gYmluZGluZy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0dXNlU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGtleXBhdGguc2xpY2UoIDAsIGJpbmRpbmcua2V5cGF0aC5sZW5ndGggKSA9PT0gYmluZGluZy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0cmVmaW5lbWVudHMucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB1c2VTZXQgKSB7XG5cdFx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZSggdmlld21vZGVsLmdldCggYmluZGluZy5rZXlwYXRoICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHJlZmluZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJlZmluZVZhbHVlKCByZWZpbmVtZW50cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5QWxsRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRocywgZ3JvdXBOYW1lICkge1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0XHRhZGRLZXlwYXRocygga2V5cGF0aHMgKTtcblx0XHRcdHF1ZXVlLmZvckVhY2goIGRpc3BhdGNoICk7XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEtleXBhdGhzKCBrZXlwYXRocyApIHtcblx0XHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggYWRkS2V5cGF0aCApO1xuXHRcdFx0XHRrZXlwYXRocy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEtleXBhdGgoIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBkZXBzID0gZmluZERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICk7XG5cdFx0XHRcdGlmICggZGVwcyApIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCB7XG5cdFx0XHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuXHRcdFx0XHRcdFx0ZGVwczogZGVwc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYXNjYWRlKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgY2hpbGREZXBzO1xuXHRcdFx0XHRpZiAoIGNoaWxkRGVwcyA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cE5hbWUgXVsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGFkZEtleXBhdGhzKCBjaGlsZERlcHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBkaXNwYXRjaCggc2V0ICkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBzZXQua2V5cGF0aCApO1xuXHRcdFx0XHRzZXQuZGVwcy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZC5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBncm91cCA9IHZpZXdtb2RlbC5kZXBzWyBncm91cE5hbWUgXTtcblx0XHRcdHJldHVybiBncm91cCA/IGdyb3VwWyBrZXlwYXRoIF0gOiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGdldFVwc3RyZWFtQ2hhbmdlcywgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jYXB0dXJlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY2FwdHVyZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRjYXB0dXJlKCkge1xuXHRcdHRoaXMuY2FwdHVyZUdyb3Vwcy5wdXNoKCBbXSApO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvY2xlYXJDYWNoZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBWaWV3bW9kZWwkY2xlYXJDYWNoZSgga2V5cGF0aCwgZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHR2YXIgY2FjaGVNYXAsIHdyYXBwZXI7XG5cdFx0aWYgKCAhZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG5cdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0Ly8gRGlkIHdlIHVud3JhcCBpdD9cblx0XHRcdFx0aWYgKCB3cmFwcGVyLnRlYXJkb3duKCkgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdC8vIElzIHRoaXMgcmlnaHQ/XG5cdFx0XHRcdFx0Ly8gV2hhdCdzIHRoZSBtZWFuaW5nIG9mIHJldHVybmluZyBmYWxzZSBmcm9tIHRlYXJkb3duP1xuXHRcdFx0XHRcdC8vIENvdWxkIHRoZXJlIGJlIGEgR0MgcmFtaWZpY2F0aW9uIGlmIHRoaXMgaXMgYSBcInJlYWxcIiByYWN0aXZlLnRlYXJkb3duKCk/XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuY2FjaGVbIGtleXBhdGggXSA9IHVuZGVmaW5lZDtcblx0XHRpZiAoIGNhY2hlTWFwID0gdGhpcy5jYWNoZU1hcFsga2V5cGF0aCBdICkge1xuXHRcdFx0d2hpbGUgKCBjYWNoZU1hcC5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJDYWNoZSggY2FjaGVNYXAucG9wKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL2dldENvbXB1dGF0aW9uU2lnbmF0dXJlLmpzICovXG5cdHZhciBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBwYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIHNpZ25hdHVyZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRnZXQ6IHNpZ25hdHVyZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRnZXQ6IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlIClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRzaWduYXR1cmUgPSB7XG5cdFx0XHRcdFx0Z2V0OiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZS5nZXQgKSxcblx0XHRcdFx0XHRzZXQ6IHNpZ25hdHVyZS5zZXRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzaWduYXR1cmU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlICkge1xuXHRcdFx0dmFyIGZ1bmN0aW9uQm9keSA9ICd2YXIgX19yYWN0aXZlPXRoaXM7cmV0dXJuKCcgKyBzaWduYXR1cmUucmVwbGFjZSggcGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCBrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm4gJ19fcmFjdGl2ZS5nZXQoXCInICsga2V5cGF0aCArICdcIiknO1xuXHRcdFx0fSApICsgJyknO1xuXHRcdFx0cmV0dXJuIG5ldyBGdW5jdGlvbiggZnVuY3Rpb25Cb2R5ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9Db21wdXRhdGlvbi5qcyAqL1xuXHR2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiggbG9nLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwgPSByYWN0aXZlLnZpZXdtb2RlbDtcblx0XHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdFx0dGhpcy5nZXR0ZXIgPSBzaWduYXR1cmUuZ2V0O1xuXHRcdFx0dGhpcy5zZXR0ZXIgPSBzaWduYXR1cmUuc2V0O1xuXHRcdFx0dGhpcy5oYXJkRGVwcyA9IHNpZ25hdHVyZS5kZXBzIHx8IFtdO1xuXHRcdFx0dGhpcy5zb2Z0RGVwcyA9IFtdO1xuXHRcdFx0dGhpcy5kZXBWYWx1ZXMgPSB7fTtcblx0XHRcdGlmICggdGhpcy5oYXJkRGVwcyApIHtcblx0XHRcdFx0dGhpcy5oYXJkRGVwcy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoIGQsIHRoaXMkMCwgJ2NvbXB1dGVkJyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IHRoaXMuX2ZpcnN0UnVuID0gdHJ1ZTtcblx0XHR9O1xuXHRcdENvbXB1dGF0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGNvbnN0cnVjdG9yOiBDb21wdXRhdGlvbixcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5pdGlhbDtcblx0XHRcdFx0dGhpcy5ieXBhc3MgPSB0cnVlO1xuXHRcdFx0XHRpbml0aWFsID0gdGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5ICk7XG5cdFx0XHRcdHRoaXMucmFjdGl2ZS52aWV3bW9kZWwuY2xlYXJDYWNoZSggdGhpcy5rZXkgKTtcblx0XHRcdFx0dGhpcy5ieXBhc3MgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRlciAmJiBpbml0aWFsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXQoIGluaXRpYWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGludmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciByYWN0aXZlLCBuZXdEZXBzLCBkZXBlbmRlbmNpZXNDaGFuZ2VkLCBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRoaXMuZ2V0dGluZyApIHtcblx0XHRcdFx0XHQvLyBwcmV2ZW50IGRvdWJsZS1jb21wdXRhdGlvbiAoZS5nLiBjYXVzZWQgYnkgYXJyYXkgbXV0YXRpb24gaW5zaWRlIGNvbXB1dGF0aW9uKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmdldHRpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIHRoaXMuX2RpcnR5ICkge1xuXHRcdFx0XHRcdHJhY3RpdmUgPSB0aGlzLnJhY3RpdmU7XG5cdFx0XHRcdFx0Ly8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGlucHV0cyBoYXZlIGNoYW5nZWQsIGluIGNhc2UgdGhpcyBkZXBlbmRzIG9uXG5cdFx0XHRcdFx0Ly8gb3RoZXIgY29tcHV0ZWQgdmFsdWVzXG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9maXJzdFJ1biB8fCAhdGhpcy5oYXJkRGVwcy5sZW5ndGggJiYgIXRoaXMuc29mdERlcHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdHRoaXMuaGFyZERlcHMsXG5cdFx0XHRcdFx0XHRcdHRoaXMuc29mdERlcHNcblx0XHRcdFx0XHRcdF0uZm9yRWFjaCggZnVuY3Rpb24oIGRlcHMgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBrZXlwYXRoLCB2YWx1ZSwgaTtcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSA9IGRlcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0XHRrZXlwYXRoID0gZGVwc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMkMC5kZXBWYWx1ZXNbIGtleXBhdGggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcyQwLmRlcFZhbHVlc1sga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgKSB7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCggcmFjdGl2ZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnZmFpbGVkQ29tcHV0YXRpb24nLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGtleTogdGhpcy5rZXksXG5cdFx0XHRcdFx0XHRcdFx0XHRlcnI6IGVyci5tZXNzYWdlIHx8IGVyclxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdm9pZCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bmV3RGVwcyA9IHJhY3RpdmUudmlld21vZGVsLnJlbGVhc2UoKTtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZURlcGVuZGVuY2llcyggbmV3RGVwcyApO1xuXHRcdFx0XHRcdFx0aWYgKCBkZXBlbmRlbmNpZXNDaGFuZ2VkICkge1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5oYXJkRGVwcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNvZnREZXBzXG5cdFx0XHRcdFx0XHRcdF0uZm9yRWFjaCggZnVuY3Rpb24oIGRlcHMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVwcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMkMC5kZXBWYWx1ZXNbIGtleXBhdGggXSA9IHJhY3RpdmUudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZ2V0dGluZyA9IHRoaXMuX2ZpcnN0UnVuID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZyApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXRoaXMuc2V0dGVyICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NvbXB1dGVkIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJzIGFyZSByZWFkLW9ubHkuIChUaGlzIG1heSBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlISknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zZXR0ZXIuY2FsbCggdGhpcy5yYWN0aXZlLCB2YWx1ZSApO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZURlcGVuZGVuY2llczogZnVuY3Rpb24oIG5ld0RlcHMgKSB7XG5cdFx0XHRcdHZhciBpLCBvbGREZXBzLCBrZXlwYXRoLCBkZXBlbmRlbmNpZXNDaGFuZ2VkO1xuXHRcdFx0XHRvbGREZXBzID0gdGhpcy5zb2Z0RGVwcztcblx0XHRcdFx0Ly8gcmVtb3ZlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZFxuXHRcdFx0XHRpID0gb2xkRGVwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGtleXBhdGggPSBvbGREZXBzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBuZXdEZXBzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZXMgZm9yIGFueSBuZXcgZGVwZW5kZW5jaWVzXG5cdFx0XHRcdGkgPSBuZXdEZXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0a2V5cGF0aCA9IG5ld0RlcHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9sZERlcHMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSAmJiAoICF0aGlzLmhhcmREZXBzIHx8IHRoaXMuaGFyZERlcHMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgdGhpcywgJ2NvbXB1dGVkJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGRlcGVuZGVuY2llc0NoYW5nZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zb2Z0RGVwcyA9IG5ld0RlcHMuc2xpY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzQ2hhbmdlZDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBDb21wdXRhdGlvbjtcblx0fSggbG9nLCBpc0VxdWFsICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jb21wdXRlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY29tcHV0ZSA9IGZ1bmN0aW9uKCBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSwgQ29tcHV0YXRpb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGNvbXB1dGUoIGtleSwgc2lnbmF0dXJlICkge1xuXHRcdFx0c2lnbmF0dXJlID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUoIHNpZ25hdHVyZSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY29tcHV0YXRpb25zWyBrZXkgXSA9IG5ldyBDb21wdXRhdGlvbiggdGhpcy5yYWN0aXZlLCBrZXksIHNpZ25hdHVyZSApO1xuXHRcdH07XG5cdH0oIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlLCBDb21wdXRhdGlvbiApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L0ZBSUxFRF9MT09LVVAuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfRkFJTEVEX0xPT0tVUCA9IHtcblx0XHRGQUlMRURfTE9PS1VQOiB0cnVlXG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9VbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApIHtcblxuXHRcdHZhciBlbXB0eSA9IHt9O1xuXHRcdHZhciBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gZnVuY3Rpb24oIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHRoaXMudmlld21vZGVsID0gdmlld21vZGVsO1xuXHRcdFx0dGhpcy5yb290ID0gdmlld21vZGVsLnJhY3RpdmU7XG5cdFx0XHQvLyBUT0RPIGVsaW1pbmF0ZSB0aGlzXG5cdFx0XHR0aGlzLnJlZiA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZW1wdHk7XG5cdFx0XHR2aWV3bW9kZWwudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzWyBrZXlwYXRoIF0gPSB0cnVlO1xuXHRcdFx0dmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcy5wdXNoKCB0aGlzICk7XG5cdFx0XHRydW5sb29wLmFkZFVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kucHJvdG90eXBlID0ge1xuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIHRoaXMucmVmICk7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sgdGhpcy5yZWYgXSA9IGZhbHNlO1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMudmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXQgPSBmdW5jdGlvbiggaXNOdW1lcmljLCBGQUlMRURfTE9PS1VQLCBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBlbXB0eSA9IHt9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJGdldCgga2V5cGF0aCApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSBlbXB0eTtcblx0XHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlLFxuXHRcdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUsXG5cdFx0XHRcdHZhbHVlLCBjb21wdXRhdGlvbiwgd3JhcHBlZCwgY2FwdHVyZUdyb3VwO1xuXHRcdFx0aWYgKCBrZXlwYXRoWyAwIF0gPT09ICdAJyApIHtcblx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnNsaWNlKCAxICk7XG5cdFx0XHRcdHJldHVybiBpc051bWVyaWMoIHZhbHVlICkgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggY2FjaGVbIGtleXBhdGggXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBJcyB0aGlzIGEgY29tcHV0ZWQgcHJvcGVydHk/XG5cdFx0XHRcdGlmICggKCBjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zWyBrZXlwYXRoIF0gKSAmJiAhY29tcHV0YXRpb24uYnlwYXNzICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG5cdFx0XHRcdFx0dGhpcy5hZGFwdCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggd3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGFwdCggJycsIHJhY3RpdmUuZGF0YSApO1xuXHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS5kYXRhO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gcmV0cmlldmUoIHRoaXMsIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWNoZVsga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IGNhY2hlWyBrZXlwYXRoIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMuZXZhbHVhdGVXcmFwcGVkICYmICggd3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlZC5nZXQoKTtcblx0XHRcdH1cblx0XHRcdC8vIGNhcHR1cmUgdGhlIGtleXBhdGgsIGlmIHdlJ3JlIGluc2lkZSBhIGNvbXB1dGF0aW9uXG5cdFx0XHRpZiAoIG9wdGlvbnMuY2FwdHVyZSAmJiAoIGNhcHR1cmVHcm91cCA9IHRoaXMuY2FwdHVyZUdyb3Vwc1sgdGhpcy5jYXB0dXJlR3JvdXBzLmxlbmd0aCAtIDEgXSApICkge1xuXHRcdFx0XHRpZiAoICF+Y2FwdHVyZUdyb3VwLmluZGV4T2YoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRjYXB0dXJlR3JvdXAucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdC8vIGlmIHdlIGNvdWxkbid0IHJlc29sdmUgdGhlIGtleXBhdGgsIHdlIG5lZWQgdG8gbWFrZSBpdCBhcyBhIGZhaWxlZFxuXHRcdFx0XHRcdC8vIGxvb2t1cCwgc28gdGhhdCB0aGUgY29tcHV0YXRpb24gdXBkYXRlcyBjb3JyZWN0bHkgb25jZSB3ZSBDQU5cblx0XHRcdFx0XHQvLyByZXNvbHZlIHRoZSBrZXlwYXRoXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCAmJiB0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sga2V5cGF0aCBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0bmV3IFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3koIHRoaXMsIGtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCA/IHZvaWQgMCA6IHZhbHVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXRyaWV2ZSggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIGtleSwgcGFyZW50S2V5cGF0aCwgcGFyZW50VmFsdWUsIGNhY2hlTWFwLCB2YWx1ZSwgd3JhcHBlZDtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdGtleSA9IGtleXMucG9wKCk7XG5cdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0aWYgKCB3cmFwcGVkID0gdmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXSApIHtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJlbnRWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgY2FjaGUgbWFwXG5cdFx0XHRpZiAoICEoIGNhY2hlTWFwID0gdmlld21vZGVsLmNhY2hlTWFwWyBwYXJlbnRLZXlwYXRoIF0gKSApIHtcblx0XHRcdFx0dmlld21vZGVsLmNhY2hlTWFwWyBwYXJlbnRLZXlwYXRoIF0gPSBbIGtleXBhdGggXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggY2FjaGVNYXAuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0XHRjYWNoZU1hcC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBleGlzdCwgd2UgcmV0dXJuIGEgc2VudGluZWwgdmFsdWVcblx0XHRcdC8vIHNvIHRoYXQgd2Uga25vdyB0byBxdWVyeSBwYXJlbnQgc2NvcGUgKGlmIHN1Y2ggdGhlcmUgYmUpXG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgISgga2V5IGluIHBhcmVudFZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB2aWV3bW9kZWwuY2FjaGVbIGtleXBhdGggXSA9IEZBSUxFRF9MT09LVVA7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHBhcmVudFZhbHVlWyBrZXkgXTtcblx0XHRcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cblx0XHRcdHZpZXdtb2RlbC5hZGFwdCgga2V5cGF0aCwgdmFsdWUsIGZhbHNlICk7XG5cdFx0XHQvLyBVcGRhdGUgY2FjaGVcblx0XHRcdHZpZXdtb2RlbC5jYWNoZVsga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggaXNOdW1lcmljLCB2aWV3bW9kZWwkZ2V0X0ZBSUxFRF9MT09LVVAsIHZpZXdtb2RlbCRnZXRfVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGluaXQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRpbml0KCkge1xuXHRcdFx0dmFyIGtleSwgY29tcHV0YXRpb24sIGNvbXB1dGF0aW9ucyA9IFtdO1xuXHRcdFx0Zm9yICgga2V5IGluIHRoaXMucmFjdGl2ZS5jb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGUoIGtleSwgdGhpcy5yYWN0aXZlLmNvbXB1dGVkWyBrZXkgXSApO1xuXHRcdFx0XHRjb21wdXRhdGlvbnMucHVzaCggY29tcHV0YXRpb24gKTtcblx0XHRcdH1cblx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKCBpbml0ICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXQoIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0Y29tcHV0YXRpb24uaW5pdCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL21hcmsuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtYXJrID0gZnVuY3Rpb24gVmlld21vZGVsJG1hcmsoIGtleXBhdGgsIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGNvbXB1dGF0aW9uO1xuXHRcdC8vIGltcGxpY2l0IGNoYW5nZXMgKGkuZS4gYGZvby5sZW5ndGhgIG9uIGByYWN0aXZlLnB1c2goJ2ZvbycsNDIpYClcblx0XHQvLyBzaG91bGQgbm90IGJlIHBpY2tlZCB1cCBieSBwYXR0ZXJuIG9ic2VydmVyc1xuXHRcdGlmICggb3B0aW9ucyApIHtcblx0XHRcdGlmICggb3B0aW9ucy5pbXBsaWNpdCApIHtcblx0XHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMubm9DYXNjYWRlICkge1xuXHRcdFx0XHR0aGlzLm5vQ2FzY2FkZVsga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5jaGFuZ2VzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHR0aGlzLmNoYW5nZXMucHVzaCgga2V5cGF0aCApO1xuXHRcdH1cblx0XHR0aGlzLmNsZWFyQ2FjaGUoIGtleXBhdGggKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL21lcmdlL21hcE9sZFRvTmV3SW5kZXguanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtZXJnZV9tYXBPbGRUb05ld0luZGV4ID0gZnVuY3Rpb24oIG9sZEFycmF5LCBuZXdBcnJheSApIHtcblx0XHR2YXIgdXNlZEluZGljZXMsIGZpcnN0VW51c2VkSW5kZXgsIG5ld0luZGljZXMsIGNoYW5nZWQ7XG5cdFx0dXNlZEluZGljZXMgPSB7fTtcblx0XHRmaXJzdFVudXNlZEluZGV4ID0gMDtcblx0XHRuZXdJbmRpY2VzID0gb2xkQXJyYXkubWFwKCBmdW5jdGlvbiggaXRlbSwgaSApIHtcblx0XHRcdHZhciBpbmRleCwgc3RhcnQsIGxlbjtcblx0XHRcdHN0YXJ0ID0gZmlyc3RVbnVzZWRJbmRleDtcblx0XHRcdGxlbiA9IG5ld0FycmF5Lmxlbmd0aDtcblx0XHRcdGRvIHtcblx0XHRcdFx0aW5kZXggPSBuZXdBcnJheS5pbmRleE9mKCBpdGVtLCBzdGFydCApO1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnQgPSBpbmRleCArIDE7XG5cdFx0XHR9IHdoaWxlICggdXNlZEluZGljZXNbIGluZGV4IF0gJiYgc3RhcnQgPCBsZW4gKTtcblx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHVudXNlZCBpbmRleCwgc28gd2UgZG9uJ3Qgc2VhcmNoXG5cdFx0XHQvLyB0aGUgd2hvbGUgb2YgbmV3QXJyYXkgZm9yIGVhY2ggaXRlbSBpbiBvbGRBcnJheSB1bm5lY2Vzc2FyaWx5XG5cdFx0XHRpZiAoIGluZGV4ID09PSBmaXJzdFVudXNlZEluZGV4ICkge1xuXHRcdFx0XHRmaXJzdFVudXNlZEluZGV4ICs9IDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ICE9PSBpICkge1xuXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHVzZWRJbmRpY2VzWyBpbmRleCBdID0gdHJ1ZTtcblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIG5ld0luZGljZXM7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tZXJnZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1lcmdlID0gZnVuY3Rpb24oIHdhcm4sIG1hcE9sZFRvTmV3SW5kZXggKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGNvbXBhcmF0b3JzID0ge307XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkbWVyZ2UoIGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgb2xkQXJyYXksIG5ld0FycmF5LCBjb21wYXJhdG9yLCBuZXdJbmRpY2VzO1xuXHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJlICkge1xuXHRcdFx0XHRjb21wYXJhdG9yID0gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKCBvcHRpb25zLmNvbXBhcmUgKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheS5tYXAoIGNvbXBhcmF0b3IgKTtcblx0XHRcdFx0XHRuZXdBcnJheSA9IGFycmF5Lm1hcCggY29tcGFyYXRvciApO1xuXHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdC8vIGZhbGxiYWNrIHRvIGFuIGlkZW50aXR5IGNoZWNrIC0gd29yc3QgY2FzZSBzY2VuYXJpbyB3ZSBoYXZlXG5cdFx0XHRcdFx0Ly8gdG8gZG8gbW9yZSBET00gbWFuaXB1bGF0aW9uIHRoYW4gd2UgdGhvdWdodC4uLlxuXHRcdFx0XHRcdC8vIC4uLnVubGVzcyB3ZSdyZSBpbiBkZWJ1ZyBtb2RlIG9mIGNvdXJzZVxuXHRcdFx0XHRcdGlmICggdGhpcy5kZWJ1ZyApIHtcblx0XHRcdFx0XHRcdHRocm93IGVycjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0d2FybiggJ01lcmdlIG9wZXJhdGlvbjogY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG5cdFx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG5cdFx0XHRcdG5ld0FycmF5ID0gYXJyYXk7XG5cdFx0XHR9XG5cdFx0XHQvLyBmaW5kIG5ldyBpbmRpY2VzIGZvciBtZW1iZXJzIG9mIG9sZEFycmF5XG5cdFx0XHRuZXdJbmRpY2VzID0gbWFwT2xkVG9OZXdJbmRleCggb2xkQXJyYXksIG5ld0FycmF5ICk7XG5cdFx0XHR0aGlzLnNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcywgY3VycmVudEFycmF5Lmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeSggaXRlbSApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggaXRlbSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbXBhcmF0b3JGdW5jdGlvbiggY29tcGFyYXRvciApIHtcblx0XHRcdC8vIElmIGBjb21wYXJlYCBpcyBgdHJ1ZWAsIHdlIHVzZSBKU09OLnN0cmluZ2lmeSB0byBjb21wYXJlXG5cdFx0XHQvLyBvYmplY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHNoYXBlLCBidXQgbm9uLWlkZW50aWNhbCAtIGkuZS5cblx0XHRcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuXHRcdFx0aWYgKCBjb21wYXJhdG9yID09PSB0cnVlICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggIWNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF0gKSB7XG5cdFx0XHRcdFx0Y29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXSA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW1bIGNvbXBhcmF0b3IgXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgYGNvbXBhcmVgIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24sIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBpZGVudGlmeWluZyBmaWVsZCAob3IgYHRydWVgIHRvIHVzZSBKU09OLnN0cmluZ2lmeSknICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggd2Fybiwgdmlld21vZGVsJG1lcmdlX21hcE9sZFRvTmV3SW5kZXggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3JlZ2lzdGVyLmpzICovXG5cdHZhciB2aWV3bW9kZWwkcmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWdpc3Rlcigga2V5cGF0aCwgZGVwZW5kYW50ICkge1xuXHRcdFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIGdyb3VwID09PSB2b2lkIDAgKVxuXHRcdFx0XHRncm91cCA9ICdkZWZhdWx0Jztcblx0XHRcdHZhciBkZXBzQnlLZXlwYXRoLCBkZXBzO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnQuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlcHNCeUtleXBhdGggPSB0aGlzLmRlcHNbIGdyb3VwIF0gfHwgKCB0aGlzLmRlcHNbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0ZGVwcyA9IGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSB8fCAoIGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRkZXBzLnB1c2goIGRlcGVuZGFudCApO1xuXHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlRGVwZW5kYW50c01hcCggdGhpcywga2V5cGF0aCwgZ3JvdXAgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlRGVwZW5kYW50c01hcCggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cCApIHtcblx0XHRcdHZhciBrZXlzLCBwYXJlbnRLZXlwYXRoLCBtYXAsIHBhcmVudDtcblx0XHRcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdIHx8ICggdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0XHRwYXJlbnQgPSBtYXBbIHBhcmVudEtleXBhdGggXSB8fCAoIG1hcFsgcGFyZW50S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0aWYgKCBwYXJlbnRbIGtleXBhdGggXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdID0gMDtcblx0XHRcdFx0XHRwYXJlbnQucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdICs9IDE7XG5cdFx0XHRcdGtleXBhdGggPSBwYXJlbnRLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3JlbGVhc2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRyZWxlYXNlID0gZnVuY3Rpb24gVmlld21vZGVsJHJlbGVhc2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FwdHVyZUdyb3Vwcy5wb3AoKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3NldC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHNldCA9IGZ1bmN0aW9uKCBpc0VxdWFsLCBjcmVhdGVCcmFuY2ggKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgc2lsZW50ICkge1xuXHRcdFx0dmFyIGNvbXB1dGF0aW9uLCB3cmFwcGVyLCBkb250VGVhcmRvd25XcmFwcGVyO1xuXHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjb21wdXRhdGlvbiApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRhdGlvbi5zZXR0aW5nICkge1xuXHRcdFx0XHRcdC8vIGxldCB0aGUgb3RoZXIgY29tcHV0YXRpb24gc2V0KCkgaGFuZGxlIHRoaW5ncy4uLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb21wdXRhdGlvbi5zZXQoIHZhbHVlICk7XG5cdFx0XHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGlzRXF1YWwoIHRoaXMuY2FjaGVbIGtleXBhdGggXSwgdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdO1xuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHdyYXBwZXIgd2l0aCBhIGByZXNldCgpYCBtZXRob2QsIHdlIHRyeSBhbmQgdXNlIGl0LiBJZiB0aGVcblx0XHRcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG5cdFx0XHQvLyAobW9zdCBsaWtlbHkpIGEgbmV3IG9uZSBzaG91bGQgYmUgY3JlYXRlZCBsYXRlclxuXHRcdFx0aWYgKCB3cmFwcGVyICYmIHdyYXBwZXIucmVzZXQgKSB7XG5cdFx0XHRcdGRvbnRUZWFyZG93bldyYXBwZXIgPSB3cmFwcGVyLnJlc2V0KCB2YWx1ZSApICE9PSBmYWxzZTtcblx0XHRcdFx0aWYgKCBkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhY29tcHV0YXRpb24gJiYgIWRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0XHRcdHJlc29sdmVTZXQoIHRoaXMsIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFzaWxlbnQgKSB7XG5cdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UncmUgc2V0dGluZyBhIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdGFyZ2V0IGtleXBhdGggKGkuZS5cblx0XHRcdFx0Ly8gY3JlYXRpbmcgYSBmcmVzaCBicmFuY2gpIC0gd2UgbmVlZCB0byBjbGVhciB0aGUgY2FjaGUsIGJ1dFxuXHRcdFx0XHQvLyBub3QgbWFyayBpdCBhcyBhIGNoYW5nZVxuXHRcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVNldCggdmlld21vZGVsLCBrZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdHZhciBrZXlzLCBsYXN0S2V5LCBwYXJlbnRLZXlwYXRoLCB3cmFwcGVyLCBwYXJlbnRWYWx1ZSwgd3JhcHBlclNldCwgdmFsdWVTZXQ7XG5cdFx0XHR3cmFwcGVyU2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggd3JhcHBlci5zZXQgKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5zZXQoIGxhc3RLZXksIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0XHRcdHZhbHVlU2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR2YWx1ZVNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFwYXJlbnRWYWx1ZSApIHtcblx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaCggbGFzdEtleSApO1xuXHRcdFx0XHRcdHZpZXdtb2RlbC5zZXQoIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50VmFsdWVbIGxhc3RLZXkgXSA9IHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdGxhc3RLZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHR3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXTtcblx0XHRcdGlmICggd3JhcHBlciApIHtcblx0XHRcdFx0d3JhcHBlclNldCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdC8vIG1heSBoYXZlIGJlZW4gd3JhcHBlZCB2aWEgdGhlIGFib3ZlIC5nZXQoKVxuXHRcdFx0XHQvLyBjYWxsIG9uIHZpZXdtb2RlbCBpZiB0aGlzIGlzIGZpcnN0IGFjY2VzcyB2aWEgLnNldCgpIVxuXHRcdFx0XHRpZiAoIHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHdyYXBwZXJTZXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZVNldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggaXNFcXVhbCwgY3JlYXRlQnJhbmNoICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9zbWFydFVwZGF0ZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHNtYXJ0VXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGltcGxpY2l0T3B0aW9uID0ge1xuXHRcdFx0XHRpbXBsaWNpdDogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdG5vQ2FzY2FkZU9wdGlvbiA9IHtcblx0XHRcdFx0bm9DYXNjYWRlOiB0cnVlXG5cdFx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJHNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIGRlcGVuZGFudHMsIG9sZExlbmd0aDtcblx0XHRcdG9sZExlbmd0aCA9IG5ld0luZGljZXMubGVuZ3RoO1xuXHRcdFx0Ly8gSW5kaWNlcyB0aGF0IGFyZSBiZWluZyByZW1vdmVkIHNob3VsZCBiZSBtYXJrZWQgYXMgZGlydHlcblx0XHRcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24oIG5ld0luZGV4LCBvbGRJbmRleCApIHtcblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dGhpcyQwLm1hcmsoIGtleXBhdGggKyAnLicgKyBvbGRJbmRleCwgbm9DYXNjYWRlT3B0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdC8vIFVwZGF0ZSB0aGUgbW9kZWxcblx0XHRcdC8vIFRPRE8gYWxsb3cgZXhpc3RpbmcgYXJyYXkgdG8gYmUgdXBkYXRlZCBpbiBwbGFjZSwgcmF0aGVyIHRoYW4gcmVwbGFjZWQ/XG5cdFx0XHR0aGlzLnNldCgga2V5cGF0aCwgYXJyYXksIHRydWUgKTtcblx0XHRcdGlmICggZGVwZW5kYW50cyA9IHRoaXMuZGVwc1sgJ2RlZmF1bHQnIF1bIGtleXBhdGggXSApIHtcblx0XHRcdFx0ZGVwZW5kYW50cy5maWx0ZXIoIGNhblNodWZmbGUgKS5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZC5zaHVmZmxlKCBuZXdJbmRpY2VzLCBhcnJheSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9sZExlbmd0aCAhPT0gYXJyYXkubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKyAnLmxlbmd0aCcsIGltcGxpY2l0T3B0aW9uICk7XG5cdFx0XHRcdGZvciAoIHZhciBpID0gb2xkTGVuZ3RoOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICsgJy4nICsgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvbid0IGFsbG93IHJlbW92ZWQgaW5kZXhlcyBiZXlvbmQgZW5kIG9mIG5ldyBhcnJheSB0byB0cmlnZ2VyIHJlY29tcHV0YXRpb25zXG5cdFx0XHRcdGZvciAoIHZhciBpJDAgPSBhcnJheS5sZW5ndGg7IGkkMCA8IG9sZExlbmd0aDsgaSQwICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICsgJy4nICsgaSQwLCBub0Nhc2NhZGVPcHRpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjYW5TaHVmZmxlKCBkZXBlbmRhbnQgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGRlcGVuZGFudC5zaHVmZmxlID09PSAnZnVuY3Rpb24nO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3RlYXJkb3duLmpzICovXG5cdHZhciB2aWV3bW9kZWwkdGVhcmRvd24gPSBmdW5jdGlvbiBWaWV3bW9kZWwkdGVhcmRvd24oKSB7XG5cdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0dmFyIHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cdFx0Ly8gQ2xlYXIgZW50aXJlIGNhY2hlIC0gdGhpcyBoYXMgdGhlIGRlc2lyZWQgc2lkZS1lZmZlY3Rcblx0XHQvLyBvZiB1bndyYXBwaW5nIGFkYXB0ZWQgdmFsdWVzIChlLmcuIGFycmF5cylcblx0XHRPYmplY3Qua2V5cyggdGhpcy5jYWNoZSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMkMC5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0fSApO1xuXHRcdC8vIFRlYXJkb3duIGFueSBmYWlsZWQgbG9va3VwcyAtIHdlIGRvbid0IG5lZWQgdGhlbSB0byByZXNvbHZlIGFueSBtb3JlXG5cdFx0d2hpbGUgKCB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucG9wKCkgKSB7XG5cdFx0XHR1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnRlYXJkb3duKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvdW5yZWdpc3Rlci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHVucmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCR1bnJlZ2lzdGVyKCBrZXlwYXRoLCBkZXBlbmRhbnQgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbIDIgXTtcblx0XHRcdGlmICggZ3JvdXAgPT09IHZvaWQgMCApXG5cdFx0XHRcdGdyb3VwID0gJ2RlZmF1bHQnO1xuXHRcdFx0dmFyIGRlcHMsIGluZGV4O1xuXHRcdFx0aWYgKCBkZXBlbmRhbnQuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlcHMgPSB0aGlzLmRlcHNbIGdyb3VwIF1bIGtleXBhdGggXTtcblx0XHRcdGluZGV4ID0gZGVwcy5pbmRleE9mKCBkZXBlbmRhbnQgKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgZGVwZW5kYW50IHRoYXQgd2FzIG5vIGxvbmdlciByZWdpc3RlcmVkISBUaGlzIHNob3VsZCBub3QgaGFwcGVuLiBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIGJ1ZyBpbiBkZXZlbG9wbWVudCBwbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcycgKTtcblx0XHRcdH1cblx0XHRcdGRlcHMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlRGVwZW5kYW50c01hcCggdGhpcywga2V5cGF0aCwgZ3JvdXAgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlRGVwZW5kYW50c01hcCggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cCApIHtcblx0XHRcdHZhciBrZXlzLCBwYXJlbnRLZXlwYXRoLCBtYXAsIHBhcmVudDtcblx0XHRcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdO1xuXHRcdFx0XHRwYXJlbnQgPSBtYXBbIHBhcmVudEtleXBhdGggXTtcblx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gLT0gMTtcblx0XHRcdFx0aWYgKCAhcGFyZW50WyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIGZyb20gcGFyZW50IGRlcHMgbWFwXG5cdFx0XHRcdFx0cGFyZW50LnNwbGljZSggcGFyZW50LmluZGV4T2YoIGtleXBhdGggKSwgMSApO1xuXHRcdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSBwYXJlbnRLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvYWRhcHRDb25maWcuanMgKi9cblx0dmFyIGFkYXB0Q29uZmlnID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBzaG91bGQgdGhpcyBiZSBjb21iaW5lZCB3aXRoIHByb3RvdHlwZS9hZGFwdC5qcz9cblx0XHR2YXIgY29uZmlndXJlID0ge1xuXHRcdFx0bG9va3VwOiBmdW5jdGlvbiggdGFyZ2V0LCBhZGFwdG9ycyApIHtcblx0XHRcdFx0dmFyIGksIGFkYXB0ID0gdGFyZ2V0LmFkYXB0O1xuXHRcdFx0XHRpZiAoICFhZGFwdCB8fCAhYWRhcHQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFkYXB0b3JzICYmIE9iamVjdC5rZXlzKCBhZGFwdG9ycyApLmxlbmd0aCAmJiAoIGkgPSBhZGFwdC5sZW5ndGggKSApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHZhciBhZGFwdG9yID0gYWRhcHRbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGFkYXB0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0XHRhZGFwdFsgaSBdID0gYWRhcHRvcnNbIGFkYXB0b3IgXSB8fCBhZGFwdG9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHR9LFxuXHRcdFx0Y29tYmluZTogZnVuY3Rpb24oIHBhcmVudCwgYWRhcHQgKSB7XG5cdFx0XHRcdC8vIG5vcm1hbGl6ZSAnRm9vJyB0byBbICdGb28nIF1cblx0XHRcdFx0cGFyZW50ID0gYXJyYXlJZlN0cmluZyggcGFyZW50ICk7XG5cdFx0XHRcdGFkYXB0ID0gYXJyYXlJZlN0cmluZyggYWRhcHQgKTtcblx0XHRcdFx0Ly8gbm8gcGFyZW50PyByZXR1cm4gYWRhcHRcblx0XHRcdFx0aWYgKCAhcGFyZW50IHx8ICFwYXJlbnQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBubyBhZGFwdD8gcmV0dXJuICdjb3B5JyBvZiBwYXJlbnRcblx0XHRcdFx0aWYgKCAhYWRhcHQgfHwgIWFkYXB0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LnNsaWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRkIHBhcmVudCBhZGFwdG9ycyB0byBvcHRpb25zXG5cdFx0XHRcdHBhcmVudC5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHQvLyBkb24ndCBwdXQgaW4gZHVwbGljYXRlc1xuXHRcdFx0XHRcdGlmICggYWRhcHQuaW5kZXhPZiggYSApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGFkYXB0LnB1c2goIGEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhcnJheUlmU3RyaW5nKCBhZGFwdCApIHtcblx0XHRcdGlmICggdHlwZW9mIGFkYXB0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YWRhcHQgPSBbIGFkYXB0IF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0fVxuXHRcdHJldHVybiBjb25maWd1cmU7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvVmlld21vZGVsLmpzICovXG5cdHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiggY3JlYXRlLCBhZGFwdCwgYXBwbHlDaGFuZ2VzLCBjYXB0dXJlLCBjbGVhckNhY2hlLCBjb21wdXRlLCBnZXQsIGluaXQsIG1hcmssIG1lcmdlLCByZWdpc3RlciwgcmVsZWFzZSwgc2V0LCBzbWFydFVwZGF0ZSwgdGVhcmRvd24sIHVucmVnaXN0ZXIsIGFkYXB0Q29uZmlnICkge1xuXG5cdFx0dmFyIG5vTWFnaWM7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgge30sICd0ZXN0Jywge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSApO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRub01hZ2ljID0gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdC8vIFRPRE8gZXZlbnR1YWxseSwgd2Ugc2hvdWxkbid0IG5lZWQgdGhpcyByZWZlcmVuY2Vcblx0XHRcdFZpZXdtb2RlbC5leHRlbmQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUgKTtcblx0XHRcdHRoaXMuY2FjaGUgPSB7fTtcblx0XHRcdC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byB1c2UgaGFzT3duUHJvcGVydHksIHNvIGNhbid0IGluaGVyaXQgZnJvbSBudWxsXG5cdFx0XHR0aGlzLmNhY2hlTWFwID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmRlcHMgPSB7XG5cdFx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdFx0J2RlZmF1bHQnOiB7fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMuZGVwc01hcCA9IHtcblx0XHRcdFx0Y29tcHV0ZWQ6IHt9LFxuXHRcdFx0XHQnZGVmYXVsdCc6IHt9XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzID0gW107XG5cdFx0XHR0aGlzLndyYXBwZWQgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdHRoaXMuY29tcHV0YXRpb25zID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmNhcHR1cmVHcm91cHMgPSBbXTtcblx0XHRcdHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHR0aGlzLmNoYW5nZXMgPSBbXTtcblx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG5cdFx0XHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXHRcdH07XG5cdFx0Vmlld21vZGVsLmV4dGVuZCA9IGZ1bmN0aW9uKCBQYXJlbnQsIGluc3RhbmNlICkge1xuXHRcdFx0aWYgKCBpbnN0YW5jZS5tYWdpYyAmJiBub01hZ2ljICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdHZXR0ZXJzIGFuZCBzZXR0ZXJzIChtYWdpYyBtb2RlKSBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0YW5jZS5hZGFwdCA9IGFkYXB0Q29uZmlnLmNvbWJpbmUoIFBhcmVudC5wcm90b3R5cGUuYWRhcHQsIGluc3RhbmNlLmFkYXB0ICkgfHwgW107XG5cdFx0XHRpbnN0YW5jZS5hZGFwdCA9IGFkYXB0Q29uZmlnLmxvb2t1cCggaW5zdGFuY2UsIGluc3RhbmNlLmFkYXB0b3JzICk7XG5cdFx0fTtcblx0XHRWaWV3bW9kZWwucHJvdG90eXBlID0ge1xuXHRcdFx0YWRhcHQ6IGFkYXB0LFxuXHRcdFx0YXBwbHlDaGFuZ2VzOiBhcHBseUNoYW5nZXMsXG5cdFx0XHRjYXB0dXJlOiBjYXB0dXJlLFxuXHRcdFx0Y2xlYXJDYWNoZTogY2xlYXJDYWNoZSxcblx0XHRcdGNvbXB1dGU6IGNvbXB1dGUsXG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRtYXJrOiBtYXJrLFxuXHRcdFx0bWVyZ2U6IG1lcmdlLFxuXHRcdFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxuXHRcdFx0cmVsZWFzZTogcmVsZWFzZSxcblx0XHRcdHNldDogc2V0LFxuXHRcdFx0c21hcnRVcGRhdGU6IHNtYXJ0VXBkYXRlLFxuXHRcdFx0dGVhcmRvd246IHRlYXJkb3duLFxuXHRcdFx0dW5yZWdpc3RlcjogdW5yZWdpc3RlclxuXHRcdH07XG5cdFx0cmV0dXJuIFZpZXdtb2RlbDtcblx0fSggY3JlYXRlLCB2aWV3bW9kZWwkYWRhcHQsIHZpZXdtb2RlbCRhcHBseUNoYW5nZXMsIHZpZXdtb2RlbCRjYXB0dXJlLCB2aWV3bW9kZWwkY2xlYXJDYWNoZSwgdmlld21vZGVsJGNvbXB1dGUsIHZpZXdtb2RlbCRnZXQsIHZpZXdtb2RlbCRpbml0LCB2aWV3bW9kZWwkbWFyaywgdmlld21vZGVsJG1lcmdlLCB2aWV3bW9kZWwkcmVnaXN0ZXIsIHZpZXdtb2RlbCRyZWxlYXNlLCB2aWV3bW9kZWwkc2V0LCB2aWV3bW9kZWwkc21hcnRVcGRhdGUsIHZpZXdtb2RlbCR0ZWFyZG93biwgdmlld21vZGVsJHVucmVnaXN0ZXIsIGFkYXB0Q29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9pbml0aWFsaXNlLmpzICovXG5cdHZhciBSYWN0aXZlX2luaXRpYWxpc2UgPSBmdW5jdGlvbiggY29uZmlnLCBjcmVhdGUsIEZyYWdtZW50LCBnZXRFbGVtZW50LCBnZXROZXh0TnVtYmVyLCBIb29rLCBIb29rUXVldWUsIFZpZXdtb2RlbCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgY29uc3RydWN0SG9vayA9IG5ldyBIb29rKCAnY29uc3RydWN0JyApLFxuXHRcdFx0Y29uZmlnSG9vayA9IG5ldyBIb29rKCAnY29uZmlnJyApLFxuXHRcdFx0aW5pdEhvb2sgPSBuZXcgSG9va1F1ZXVlKCAnaW5pdCcgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2UoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHRpbml0aWFsaXNlUHJvcGVydGllcyggcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gbWFrZSB0aGlzIG9wdGlvbiBkbyB3aGF0IHdvdWxkIGJlIGV4cGVjdGVkIGlmIHNvbWVvbmVcblx0XHRcdC8vIGRpZCBpbmNsdWRlIGl0IG9uIGEgbmV3IFJhY3RpdmUoKSBvciBuZXcgQ29tcG9uZW50KCkgY2FsbC5cblx0XHRcdC8vIFNpbGx5IHRvIGRvIHNvIChwdXQgYSBob29rIG9uIHRoZSB2ZXJ5IG9wdGlvbnMgYmVpbmcgdXNlZCksXG5cdFx0XHQvLyBidXQgaGFuZGxlIGl0IGNvcnJlY3RseSwgY29uc2lzdGVudCB3aXRoIHRoZSBpbnRlbnQuXG5cdFx0XHRjb25zdHJ1Y3RIb29rLmZpcmUoIGNvbmZpZy5nZXRDb25zdHJ1Y3RUYXJnZXQoIHJhY3RpdmUsIG9wdGlvbnMgKSwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gaW5pdCBjb25maWcgZnJvbSBQYXJlbnQgYW5kIG9wdGlvbnNcblx0XHRcdGNvbmZpZy5pbml0KCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHRjb25maWdIb29rLmZpcmUoIHJhY3RpdmUgKTtcblx0XHRcdC8vIFRlYXJkb3duIGFueSBleGlzdGluZyBpbnN0YW5jZXMgKmJlZm9yZSogdHJ5aW5nIHRvIHNldCB1cCB0aGUgbmV3IG9uZSAtXG5cdFx0XHQvLyBhdm9pZHMgY2VydGFpbiB3ZWlyZCBidWdzXG5cdFx0XHRpZiAoIGVsID0gZ2V0RWxlbWVudCggcmFjdGl2ZS5lbCApICkge1xuXHRcdFx0XHRpZiAoICFyYWN0aXZlLmFwcGVuZCApIHtcblx0XHRcdFx0XHRpZiAoIGVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXy5zcGxpY2UoIDAsIGVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXy5sZW5ndGggKS5mb3JFYWNoKCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge31cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGluaXRIb29rLmJlZ2luKCByYWN0aXZlICk7XG5cdFx0XHQvLyBURU1QT1JBUlkuIFRoaXMgaXMgc28gd2UgY2FuIGltcGxlbWVudCBWaWV3bW9kZWwgZ3JhZHVhbGx5XG5cdFx0XHRyYWN0aXZlLnZpZXdtb2RlbCA9IG5ldyBWaWV3bW9kZWwoIHJhY3RpdmUgKTtcblx0XHRcdC8vIGhhY2t5IGNpcmN1bGFyIHByb2JsZW0gdW50aWwgd2UgZ2V0IHRoaXMgc29ydGVkIG91dFxuXHRcdFx0Ly8gaWYgdmlld21vZGVsIGltbWVkaWF0ZWx5IHByb2Nlc3NlcyBjb21wdXRlZCBwcm9wZXJ0aWVzLFxuXHRcdFx0Ly8gdGhleSBtYXkgY2FsbCByYWN0aXZlLmdldCwgd2hpY2ggY2FsbHMgcmFjdGl2ZS52aWV3bW9kZWwsXG5cdFx0XHQvLyB3aGljaCBoYXNuJ3QgYmVlbiBzZXQgdGlsbCBsaW5lIGFib3ZlIGZpbmlzaGVzLlxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuaW5pdCgpO1xuXHRcdFx0Ly8gUmVuZGVyIG91ciAqcm9vdCBmcmFnbWVudCpcblx0XHRcdGlmICggcmFjdGl2ZS50ZW1wbGF0ZSApIHtcblx0XHRcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiByYWN0aXZlLnRlbXBsYXRlLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IHJhY3RpdmVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aW5pdEhvb2suZW5kKCByYWN0aXZlICk7XG5cdFx0XHQvLyByZW5kZXIgYXV0b21hdGljYWxseSAoIGlmIGBlbGAgaXMgc3BlY2lmaWVkIClcblx0XHRcdGlmICggZWwgKSB7XG5cdFx0XHRcdHJhY3RpdmUucmVuZGVyKCBlbCwgcmFjdGl2ZS5hcHBlbmQgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG5cdFx0XHQvLyBleGlzdGVkXG5cdFx0XHRyYWN0aXZlLl9ndWlkID0gZ2V0TmV4dE51bWJlcigpO1xuXHRcdFx0Ly8gZXZlbnRzXG5cdFx0XHRyYWN0aXZlLl9zdWJzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuXHRcdFx0Ly8gbGlrZSBkeW5hbWljIGZ1bmN0aW9ucyBvciBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHJhY3RpdmUuX2NvbmZpZyA9IHt9O1xuXHRcdFx0Ly8gdHdvLXdheSBiaW5kaW5nc1xuXHRcdFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdC8vIGFuaW1hdGlvbnMgKHNvIHdlIGNhbiBzdG9wIGFueSBpbiBwcm9ncmVzcyBhdCB0ZWFyZG93bilcblx0XHRcdHJhY3RpdmUuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRcdC8vIG5vZGVzIHJlZ2lzdHJ5XG5cdFx0XHRyYWN0aXZlLm5vZGVzID0ge307XG5cdFx0XHQvLyBsaXZlIHF1ZXJpZXNcblx0XHRcdHJhY3RpdmUuX2xpdmVRdWVyaWVzID0gW107XG5cdFx0XHRyYWN0aXZlLl9saXZlQ29tcG9uZW50UXVlcmllcyA9IFtdO1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudFxuXHRcdFx0aWYgKCBvcHRpb25zLl9wYXJlbnQgJiYgb3B0aW9ucy5fY29tcG9uZW50ICkge1xuXHRcdFx0XHRyYWN0aXZlLl9wYXJlbnQgPSBvcHRpb25zLl9wYXJlbnQ7XG5cdFx0XHRcdHJhY3RpdmUuY29tcG9uZW50ID0gb3B0aW9ucy5fY29tcG9uZW50O1xuXHRcdFx0XHQvLyBBbmQgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9uIHRoZSBjb21wb25lbnRcblx0XHRcdFx0b3B0aW9ucy5fY29tcG9uZW50Lmluc3RhbmNlID0gcmFjdGl2ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjb25maWcsIGNyZWF0ZSwgRnJhZ21lbnQsIGdldEVsZW1lbnQsIGdldE5leHROdW1iZXIsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2tRdWV1ZSwgVmlld21vZGVsICk7XG5cblx0LyogZXh0ZW5kL3Vud3JhcEV4dGVuZGVkLmpzICovXG5cdHZhciB1bndyYXBFeHRlbmRlZCA9IGZ1bmN0aW9uKCB3cmFwLCBjb25maWcsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBSYWN0aXZlO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0UmFjdGl2ZSA9IGNpcmN1bGFyLlJhY3RpdmU7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gdW53cmFwRXh0ZW5kZWQoIENoaWxkICkge1xuXHRcdFx0aWYgKCAhKCBDaGlsZC5wcm90b3R5cGUgaW5zdGFuY2VvZiBSYWN0aXZlICkgKSB7XG5cdFx0XHRcdHJldHVybiBDaGlsZDtcblx0XHRcdH1cblx0XHRcdHZhciBvcHRpb25zID0ge307XG5cdFx0XHR3aGlsZSAoIENoaWxkICkge1xuXHRcdFx0XHRjb25maWcucmVnaXN0cmllcy5mb3JFYWNoKCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRhZGRSZWdpc3RyeSggci51c2VEZWZhdWx0cyA/IENoaWxkLnByb3RvdHlwZSA6IENoaWxkLCBvcHRpb25zLCByLm5hbWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRPYmplY3Qua2V5cyggQ2hpbGQucHJvdG90eXBlICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRpZiAoIGtleSA9PT0gJ2NvbXB1dGVkJyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gQ2hpbGQucHJvdG90eXBlWyBrZXkgXTtcblx0XHRcdFx0XHRpZiAoICEoIGtleSBpbiBvcHRpb25zICkgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlLl9tZXRob2QgPyB2YWx1ZS5fbWV0aG9kIDogdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIG9wdGlvbnNbIGtleSBdID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zWyBrZXkgXS5fbWV0aG9kICkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdCwgbmVlZHNTdXBlciA9IHZhbHVlLl9tZXRob2Q7XG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzU3VwZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuX21ldGhvZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHJld3JhcCBib3VuZCBkaXJlY3RseSB0byBwYXJlbnQgZm5cblx0XHRcdFx0XHRcdHJlc3VsdCA9IHdyYXAoIG9wdGlvbnNbIGtleSBdLl9tZXRob2QsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzU3VwZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5fbWV0aG9kID0gcmVzdWx0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSByZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggQ2hpbGQuX3BhcmVudCAhPT0gUmFjdGl2ZSApIHtcblx0XHRcdFx0XHRDaGlsZCA9IENoaWxkLl9wYXJlbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Q2hpbGQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGFkZFJlZ2lzdHJ5KCB0YXJnZXQsIG9wdGlvbnMsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcmVnaXN0cnksIGtleXMgPSBPYmplY3Qua2V5cyggdGFyZ2V0WyBuYW1lIF0gKTtcblx0XHRcdGlmICggIWtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEoIHJlZ2lzdHJ5ID0gb3B0aW9uc1sgbmFtZSBdICkgKSB7XG5cdFx0XHRcdHJlZ2lzdHJ5ID0gb3B0aW9uc1sgbmFtZSBdID0ge307XG5cdFx0XHR9XG5cdFx0XHRrZXlzLmZpbHRlciggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuICEoIGtleSBpbiByZWdpc3RyeSApO1xuXHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiByZWdpc3RyeVsga2V5IF0gPSB0YXJnZXRbIG5hbWUgXVsga2V5IF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggd3JhcE1ldGhvZCwgY29uZmlnLCBjaXJjdWxhciApO1xuXG5cdC8qIGV4dGVuZC9fZXh0ZW5kLmpzICovXG5cdHZhciBSYWN0aXZlX2V4dGVuZCA9IGZ1bmN0aW9uKCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgaW5pdGlhbGlzZSwgVmlld21vZGVsLCB1bndyYXAgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0dmFyIFBhcmVudCA9IHRoaXMsXG5cdFx0XHRcdENoaWxkLCBwcm90bywgc3RhdGljUHJvcGVydGllcztcblx0XHRcdC8vIGlmIHdlJ3JlIGV4dGVuZGluZyB3aXRoIGFub3RoZXIgUmFjdGl2ZSBpbnN0YW5jZSwgaW5oZXJpdCBpdHNcblx0XHRcdC8vIHByb3RvdHlwZSBtZXRob2RzIGFuZCBkZWZhdWx0IG9wdGlvbnMgYXMgd2VsbFxuXHRcdFx0b3B0aW9ucyA9IHVud3JhcCggb3B0aW9ucyApO1xuXHRcdFx0Ly8gY3JlYXRlIENoaWxkIGNvbnN0cnVjdG9yXG5cdFx0XHRDaGlsZCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHRpbml0aWFsaXNlKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvdG8gPSBjcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcblx0XHRcdHByb3RvLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG5cdFx0XHRzdGF0aWNQcm9wZXJ0aWVzID0ge1xuXHRcdFx0XHQvLyBlYWNoIGNvbXBvbmVudCBuZWVkcyBhIGd1aWQsIGZvciBtYW5hZ2luZyBDU1MgZXRjXG5cdFx0XHRcdF9ndWlkOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGdldEd1aWQoKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcblx0XHRcdFx0ZGVmYXVsdHM6IHtcblx0XHRcdFx0XHR2YWx1ZTogcHJvdG9cblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gZXh0ZW5kYWJsZVxuXHRcdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogZXh0ZW5kLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBQYXJlbnQgLSBmb3IgSUU4LCBjYW4ndCB1c2UgT2JqZWN0LmdldFByb3RvdHlwZU9mXG5cdFx0XHRcdF9wYXJlbnQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogUGFyZW50XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBDaGlsZCwgc3RhdGljUHJvcGVydGllcyApO1xuXHRcdFx0Ly8gZXh0ZW5kIGNvbmZpZ3VyYXRpb25cblx0XHRcdGNvbmZpZy5leHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHRcdFZpZXdtb2RlbC5leHRlbmQoIFBhcmVudCwgcHJvdG8gKTtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdH07XG5cdH0oIGNyZWF0ZSwgZGVmaW5lUHJvcGVydGllcywgZ2V0R3VpZCwgY29uZmlnLCBSYWN0aXZlX2luaXRpYWxpc2UsIFZpZXdtb2RlbCwgdW53cmFwRXh0ZW5kZWQgKTtcblxuXHQvKiBSYWN0aXZlLmpzICovXG5cdHZhciBSYWN0aXZlID0gZnVuY3Rpb24oIGRlZmF1bHRzLCBlYXNpbmcsIGludGVycG9sYXRvcnMsIHN2ZywgbWFnaWMsIGRlZmluZVByb3BlcnRpZXMsIHByb3RvLCBQcm9taXNlLCBleHRlbmRPYmosIGV4dGVuZCwgcGFyc2UsIGluaXRpYWxpc2UsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmUsIHByb3BlcnRpZXM7XG5cdFx0Ly8gTWFpbiBSYWN0aXZlIHJlcXVpcmVkIG9iamVjdFxuXHRcdFJhY3RpdmUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdGluaXRpYWxpc2UoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdC8vIFJhY3RpdmUgcHJvcGVydGllc1xuXHRcdHByb3BlcnRpZXMgPSB7XG5cdFx0XHQvLyBzdGF0aWMgbWV0aG9kczpcblx0XHRcdGV4dGVuZDoge1xuXHRcdFx0XHR2YWx1ZTogZXh0ZW5kXG5cdFx0XHR9LFxuXHRcdFx0cGFyc2U6IHtcblx0XHRcdFx0dmFsdWU6IHBhcnNlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gTmFtZXNwYWNlZCBjb25zdHJ1Y3RvcnNcblx0XHRcdFByb21pc2U6IHtcblx0XHRcdFx0dmFsdWU6IFByb21pc2Vcblx0XHRcdH0sXG5cdFx0XHQvLyBzdXBwb3J0XG5cdFx0XHRzdmc6IHtcblx0XHRcdFx0dmFsdWU6IHN2Z1xuXHRcdFx0fSxcblx0XHRcdG1hZ2ljOiB7XG5cdFx0XHRcdHZhbHVlOiBtYWdpY1xuXHRcdFx0fSxcblx0XHRcdC8vIHZlcnNpb25cblx0XHRcdFZFUlNJT046IHtcblx0XHRcdFx0dmFsdWU6ICcwLjYuMSdcblx0XHRcdH0sXG5cdFx0XHQvLyBQbHVnaW5zXG5cdFx0XHRhZGFwdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0Y29tcG9uZW50czoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0ZGVjb3JhdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0ZWFzaW5nOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogZWFzaW5nXG5cdFx0XHR9LFxuXHRcdFx0ZXZlbnRzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHRpbnRlcnBvbGF0b3JzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogaW50ZXJwb2xhdG9yc1xuXHRcdFx0fSxcblx0XHRcdHBhcnRpYWxzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHR0cmFuc2l0aW9uczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvLyBSYWN0aXZlIHByb3BlcnRpZXNcblx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBSYWN0aXZlLCBwcm9wZXJ0aWVzICk7XG5cdFx0UmFjdGl2ZS5wcm90b3R5cGUgPSBleHRlbmRPYmooIHByb3RvLCBkZWZhdWx0cyApO1xuXHRcdFJhY3RpdmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZTtcblx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcblx0XHRSYWN0aXZlLmRlZmF1bHRzID0gUmFjdGl2ZS5wcm90b3R5cGU7XG5cdFx0Ly8gQ2VydGFpbiBtb2R1bGVzIGhhdmUgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLiBJZiB3ZSB3ZXJlIGJ1bmRsaW5nIGFcblx0XHQvLyBtb2R1bGUgbG9hZGVyLCBlLmcuIGFsbW9uZC5qcywgdGhpcyB3b3VsZG4ndCBiZSBhIHByb2JsZW0sIGJ1dCB3ZSdyZVxuXHRcdC8vIG5vdCAtIHdlJ3JlIHVzaW5nIGFtZGNsZWFuIGFzIHBhcnQgb2YgdGhlIGJ1aWxkIHByb2Nlc3MuIEJlY2F1c2Ugb2Zcblx0XHQvLyB0aGlzLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgYWxsIG1vZHVsZXMgaGF2ZSBsb2FkZWQgYmVmb3JlIHRob3NlXG5cdFx0Ly8gY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGNhbiBiZSByZXF1aXJlZC5cblx0XHRjaXJjdWxhci5SYWN0aXZlID0gUmFjdGl2ZTtcblx0XHR3aGlsZSAoIGNpcmN1bGFyLmxlbmd0aCApIHtcblx0XHRcdGNpcmN1bGFyLnBvcCgpKCk7XG5cdFx0fVxuXHRcdC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG5cdFx0Ly8gb2xkZXIgYnJvd3NlcnMsIHRoZXNlIGFyZSBtYWRlIGF2YWlsYWJsZSB2aWEgYSBzaGltIC0gaGVyZSwgd2UgZG8gYSBxdWlja1xuXHRcdC8vIHByZS1mbGlnaHQgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgZWl0aGVyIGEpIHdlJ3JlIG5vdCBpbiBhIHNoaXQgYnJvd3Nlcixcblx0XHQvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG5cdFx0dmFyIEZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblx0XHRpZiAoIHR5cGVvZiBEYXRlLm5vdyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIE9iamVjdC5rZXlzICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5tYXAgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmlsdGVyICE9PSBGVU5DVElPTiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IEZVTkNUSU9OICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBSYWN0aXZlLmpzIGluIGFuIG9sZGVyIGJyb3dzZXIuIFlvdVxcJ2xsIG5lZWQgdG8gdXNlIG9uZSBvZiB0aGUgXFwnbGVnYWN5IGJ1aWxkc1xcJyBpbiBvcmRlciB0byBjb250aW51ZSAtIHNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9sZWdhY3ktYnVpbGRzIGZvciBtb3JlIGluZm9ybWF0aW9uLicgKTtcblx0XHR9XG5cdFx0cmV0dXJuIFJhY3RpdmU7XG5cdH0oIG9wdGlvbnMsIGVhc2luZywgaW50ZXJwb2xhdG9ycywgc3ZnLCBtYWdpYywgZGVmaW5lUHJvcGVydGllcywgcHJvdG90eXBlLCBQcm9taXNlLCBleHRlbmQsIFJhY3RpdmVfZXh0ZW5kLCBwYXJzZSwgUmFjdGl2ZV9pbml0aWFsaXNlLCBjaXJjdWxhciApO1xuXG5cblx0Ly8gZXhwb3J0IGFzIENvbW1vbiBKUyBtb2R1bGUuLi5cblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gUmFjdGl2ZTtcblx0fVxuXG5cdC8vIC4uLiBvciBhcyBBTUQgbW9kdWxlXG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFJhY3RpdmU7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gLi4uIG9yIGFzIGJyb3dzZXIgZ2xvYmFsXG5cdGdsb2JhbC5SYWN0aXZlID0gUmFjdGl2ZTtcblxuXHRSYWN0aXZlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcblx0XHRnbG9iYWwuUmFjdGl2ZSA9IG5vQ29uZmxpY3Q7XG5cdFx0cmV0dXJuIFJhY3RpdmU7XG5cdH07XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyApICk7XG4iXX0=
