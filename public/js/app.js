(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./source/js/app.coffee":[function(require,module,exports){
require("./module/index");

require("./../../vendor/gsap/src/uncompressed/TweenMax.js");

require("./../../vendor/ractive-events-tap/ractive-events-tap.js");

require("./../../vendor/ractive-touch/index.js");

require("./../../vendor/ractive-transitions-fade/ractive-transitions-fade.js");

require("./../../vendor/ractive-transitions-fly/ractive-transitions-fly.js");

require("./../../vendor/ractive-transitions-slide/ractive-transitions-slide.js");

require('./../../vendor/domready/ready.js')(function() {
  var View;
  if ("development" === "development") {
    require("./app-debug")();
  }
  View = require("./view/main-view");
  return window._view = new View();
});



},{"./../../vendor/domready/ready.js":"/Users/luke/dev/040715/vendor/domready/ready.js","./../../vendor/gsap/src/uncompressed/TweenMax.js":"/Users/luke/dev/040715/vendor/gsap/src/uncompressed/TweenMax.js","./../../vendor/ractive-events-tap/ractive-events-tap.js":"/Users/luke/dev/040715/vendor/ractive-events-tap/ractive-events-tap.js","./../../vendor/ractive-touch/index.js":"/Users/luke/dev/040715/vendor/ractive-touch/index.js","./../../vendor/ractive-transitions-fade/ractive-transitions-fade.js":"/Users/luke/dev/040715/vendor/ractive-transitions-fade/ractive-transitions-fade.js","./../../vendor/ractive-transitions-fly/ractive-transitions-fly.js":"/Users/luke/dev/040715/vendor/ractive-transitions-fly/ractive-transitions-fly.js","./../../vendor/ractive-transitions-slide/ractive-transitions-slide.js":"/Users/luke/dev/040715/vendor/ractive-transitions-slide/ractive-transitions-slide.js","./app-debug":"/Users/luke/dev/040715/source/js/app-debug.coffee","./module/index":"/Users/luke/dev/040715/source/js/module/index.coffee","./view/main-view":"/Users/luke/dev/040715/source/js/view/main-view.coffee"}],"/Users/luke/dev/040715/node_modules/dat-gui/index.js":[function(require,module,exports){
module.exports = require('./vendor/dat.gui')
module.exports.color = require('./vendor/dat.color')
},{"./vendor/dat.color":"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.color.js","./vendor/dat.gui":"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.gui.js"}],"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.color.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);
},{}],"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.gui.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
},{}],"/Users/luke/dev/040715/node_modules/firebase/lib/firebase-web.js":[function(require,module,exports){
/*! @license Firebase v2.2.0 - License: https://www.firebase.com/terms/terms-of-service.html */ (function() {var h,aa=this;function m(a){return void 0!==a}function ba(){}function ca(a){a.Ob=function(){return a.kf?a.kf:a.kf=new a}}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return"array"==da(a)}function fa(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"string"==typeof a}function ga(a){return"number"==typeof a}function ha(a){return"function"==da(a)}function ia(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ja(a,b,c){return a.call.apply(a.bind,arguments)}
function ka(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){q=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ja:ka;return q.apply(null,arguments)}var la=Date.now||function(){return+new Date};
function ma(a,b){function c(){}c.prototype=b.prototype;a.Kg=b.prototype;a.prototype=new c;a.Gg=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};function na(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function oa(){this.Md=void 0}
function pa(a,b,c){switch(typeof b){case "string":qa(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(ea(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],pa(a,a.Md?a.Md.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),qa(f,c),
c.push(":"),pa(a,a.Md?a.Md.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var ra={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},sa=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function qa(a,b){b.push('"',a.replace(sa,function(a){if(a in ra)return ra[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return ra[a]=e+b.toString(16)}),'"')};function ta(a){return"undefined"!==typeof JSON&&m(JSON.parse)?JSON.parse(a):na(a)}function r(a){if("undefined"!==typeof JSON&&m(JSON.stringify))a=JSON.stringify(a);else{var b=[];pa(new oa,a,b);a=b.join("")}return a};function s(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function t(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function ua(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])}function va(a){var b={};ua(a,function(a,d){b[a]=d});return b};function wa(a){this.vc=a;this.Jd="firebase:"}h=wa.prototype;h.set=function(a,b){null==b?this.vc.removeItem(this.Jd+a):this.vc.setItem(this.Jd+a,r(b))};h.get=function(a){a=this.vc.getItem(this.Jd+a);return null==a?null:ta(a)};h.remove=function(a){this.vc.removeItem(this.Jd+a)};h.lf=!1;h.toString=function(){return this.vc.toString()};function xa(){this.pc={}}xa.prototype.set=function(a,b){null==b?delete this.pc[a]:this.pc[a]=b};xa.prototype.get=function(a){return s(this.pc,a)?this.pc[a]:null};xa.prototype.remove=function(a){delete this.pc[a]};xa.prototype.lf=!0;function ya(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new wa(b)}}catch(c){}return new xa}var za=ya("localStorage"),v=ya("sessionStorage");function Aa(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.Bb=b;this.ub=c;this.Eg=d;this.Id=e||"";this.Ma=za.get("host:"+a)||this.host}function Ba(a,b){b!==a.Ma&&(a.Ma=b,"s-"===a.Ma.substr(0,2)&&za.set("host:"+a.host,a.Ma))}Aa.prototype.toString=function(){var a=(this.Bb?"https://":"http://")+this.host;this.Id&&(a+="<"+this.Id+">");return a};function Ca(){this.Sa=-1};function Da(){this.Sa=-1;this.Sa=64;this.R=[];this.ge=[];this.Ef=[];this.Fd=[];this.Fd[0]=128;for(var a=1;a<this.Sa;++a)this.Fd[a]=0;this.Yd=this.Tb=0;this.reset()}ma(Da,Ca);Da.prototype.reset=function(){this.R[0]=1732584193;this.R[1]=4023233417;this.R[2]=2562383102;this.R[3]=271733878;this.R[4]=3285377520;this.Yd=this.Tb=0};
function Ea(a,b,c){c||(c=0);var d=a.Ef;if(p(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.R[0];c=a.R[1];for(var g=a.R[2],k=a.R[3],l=a.R[4],n,e=0;80>e;e++)40>e?20>e?(f=k^c&(g^k),n=1518500249):(f=c^g^k,n=1859775393):60>e?(f=c&g|k&(c|g),n=2400959708):(f=c^g^k,n=3395469782),f=(b<<
5|b>>>27)+f+l+n+d[e]&4294967295,l=k,k=g,g=(c<<30|c>>>2)&4294967295,c=b,b=f;a.R[0]=a.R[0]+b&4294967295;a.R[1]=a.R[1]+c&4294967295;a.R[2]=a.R[2]+g&4294967295;a.R[3]=a.R[3]+k&4294967295;a.R[4]=a.R[4]+l&4294967295}
Da.prototype.update=function(a,b){m(b)||(b=a.length);for(var c=b-this.Sa,d=0,e=this.ge,f=this.Tb;d<b;){if(0==f)for(;d<=c;)Ea(this,a,d),d+=this.Sa;if(p(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Sa){Ea(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Sa){Ea(this,e);f=0;break}}this.Tb=f;this.Yd+=b};function Fa(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^la()).toString(36)};var w=Array.prototype,Ga=w.indexOf?function(a,b,c){return w.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return p(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Ha=w.forEach?function(a,b,c){w.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Ia=w.filter?function(a,b,c){return w.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=p(a)?
a.split(""):a,k=0;k<d;k++)if(k in g){var l=g[k];b.call(c,l,k,a)&&(e[f++]=l)}return e},Ja=w.map?function(a,b,c){return w.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=p(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Ka=w.reduce?function(a,b,c,d){d&&(b=q(b,d));return w.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;Ha(a,function(c,g){e=b.call(d,e,c,g,a)});return e},La=w.every?function(a,b,c){return w.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=
p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Ma(a,b){var c=Na(a,b,void 0);return 0>c?null:p(a)?a.charAt(c):a[c]}function Na(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Oa(a,b){var c=Ga(a,b);0<=c&&w.splice.call(a,c,1)}function Pa(a,b,c){return 2>=arguments.length?w.slice.call(a,b):w.slice.call(a,b,c)}function Qa(a,b){a.sort(b||Ra)}function Ra(a,b){return a>b?1:a<b?-1:0};var Sa;a:{var Ta=aa.navigator;if(Ta){var Ua=Ta.userAgent;if(Ua){Sa=Ua;break a}}Sa=""}function Va(a){return-1!=Sa.indexOf(a)};var Wa=Va("Opera")||Va("OPR"),Xa=Va("Trident")||Va("MSIE"),Ya=Va("Gecko")&&-1==Sa.toLowerCase().indexOf("webkit")&&!(Va("Trident")||Va("MSIE")),Za=-1!=Sa.toLowerCase().indexOf("webkit");(function(){var a="",b;if(Wa&&aa.opera)return a=aa.opera.version,ha(a)?a():a;Ya?b=/rv\:([^\);]+)(\)|;)/:Xa?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:Za&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(Sa))?a[1]:"");return Xa&&(b=(b=aa.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var $a=null,ab=null,bb=null;function cb(a,b){if(!fa(a))throw Error("encodeByteArray takes an array as a parameter");db();for(var c=b?ab:$a,d=[],e=0;e<a.length;e+=3){var f=a[e],g=e+1<a.length,k=g?a[e+1]:0,l=e+2<a.length,n=l?a[e+2]:0,u=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|n>>6,n=n&63;l||(n=64,g||(k=64));d.push(c[u],c[f],c[k],c[n])}return d.join("")}
function db(){if(!$a){$a={};ab={};bb={};for(var a=0;65>a;a++)$a[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),ab[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),bb[ab[a]]=a}};var eb=function(){var a=1;return function(){return a++}}();function y(a,b){if(!a)throw fb(b);}function fb(a){return Error("Firebase INTERNAL ASSERT FAILED:"+a)}
function gb(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{db();for(var c=bb,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],g=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var l=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==g||null==k||null==l)throw Error();d.push(f<<2|g>>4);64!=k&&(d.push(g<<4&240|k>>2),64!=l&&d.push(k<<6&192|l))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Pa(d,c,
c+8192));b=a}}return b}catch(n){hb("base64Decode failed: ",n)}return null}function ib(a){var b=jb(a);a=new Da;a.update(b);var b=[],c=8*a.Yd;56>a.Tb?a.update(a.Fd,56-a.Tb):a.update(a.Fd,a.Sa-(a.Tb-56));for(var d=a.Sa-1;56<=d;d--)a.ge[d]=c&255,c/=256;Ea(a,a.ge);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.R[d]>>e&255,++c;return cb(b)}
function kb(a){for(var b="",c=0;c<arguments.length;c++)b=fa(arguments[c])?b+kb.apply(null,arguments[c]):"object"===typeof arguments[c]?b+r(arguments[c]):b+arguments[c],b+=" ";return b}var lb=null,mb=!0;function hb(a){!0===mb&&(mb=!1,null===lb&&!0===v.get("logging_enabled")&&nb(!0));if(lb){var b=kb.apply(null,arguments);lb(b)}}function ob(a){return function(){hb(a,arguments)}}
function pb(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+kb.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function qb(a){var b=kb.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function z(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+kb.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function rb(a){var b="",c="",d="",e="",f=!0,g="https",k=443;if(p(a)){var l=a.indexOf("//");0<=l&&(g=a.substring(0,l-1),a=a.substring(l+2));l=a.indexOf("/");-1===l&&(l=a.length);b=a.substring(0,l);e="";a=a.substring(l).split("/");for(l=0;l<a.length;l++)if(0<a[l].length){var n=a[l];try{n=decodeURIComponent(n.replace(/\+/g," "))}catch(u){}e+="/"+n}a=b.split(".");3===a.length?(c=a[1],d=a[0].toLowerCase()):2===a.length&&(c=a[0]);l=b.indexOf(":");0<=l&&(f="https"===g||"wss"===g,k=b.substring(l+1),isFinite(k)&&
(k=String(k)),k=p(k)?/^\s*-?0x/i.test(k)?parseInt(k,16):parseInt(k,10):NaN)}return{host:b,port:k,domain:c,Bg:d,Bb:f,scheme:g,Pc:e}}function sb(a){return ga(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function tb(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function ub(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=vb(a),d=vb(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function wb(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+r(b));}
function xb(a){if("object"!==typeof a||null===a)return r(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=r(b[d]),c+=":",c+=xb(a[b[d]]);return c+"}"}function yb(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function zb(a,b){if(ea(a))for(var c=0;c<a.length;++c)b(c,a[c]);else A(a,b)}
function Ab(a){y(!sb(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;a-=1)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;a-=1)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var Bb=/^-?\d{1,10}$/;function vb(a){return Bb.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function Cb(a){try{a()}catch(b){setTimeout(function(){z("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function B(a,b){if(ha(a)){var c=Array.prototype.slice.call(arguments,1).slice();Cb(function(){a.apply(null,c)})}};function Db(a,b,c,d){this.pe=b;this.Sd=c;this.Kd=d;this.kd=a}Db.prototype.Rb=function(){var a=this.Sd.dc();return"value"===this.kd?a.path:a.parent().path};Db.prototype.te=function(){return this.kd};Db.prototype.Mb=function(){return this.pe.Mb(this)};Db.prototype.toString=function(){return this.Rb().toString()+":"+this.kd+":"+r(this.Sd.cf())};function Eb(a,b,c){this.pe=a;this.error=b;this.path=c}Eb.prototype.Rb=function(){return this.path};Eb.prototype.te=function(){return"cancel"};
Eb.prototype.Mb=function(){return this.pe.Mb(this)};Eb.prototype.toString=function(){return this.path.toString()+":cancel"};function C(a,b,c,d){this.type=a;this.Ha=b;this.Ua=c;this.Ee=d;this.Kd=void 0}function Fb(a){return new C(Gb,a)}var Gb="value";function Hb(a,b,c){this.Hb=a;this.lb=b;this.nb=c||null}h=Hb.prototype;h.wf=function(a){return"value"===a};h.createEvent=function(a,b){var c=b.n.g;return new Db("value",this,new D(a.Ha,b.dc(),c))};h.Mb=function(a){var b=this.nb;if("cancel"===a.te()){y(this.lb,"Raising a cancel event on a listener with no cancel callback");var c=this.lb;return function(){c.call(b,a.error)}}var d=this.Hb;return function(){d.call(b,a.Sd)}};h.Ze=function(a,b){return this.lb?new Eb(this,a,b):null};
h.matches=function(a){return a instanceof Hb?a.Hb&&this.Hb?a.Hb===this.Hb&&a.nb===this.nb:!0:!1};h.jf=function(){return null!==this.Hb};function Ib(a,b,c){this.ea=a;this.lb=b;this.nb=c}h=Ib.prototype;h.wf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.ea};h.Ze=function(a,b){return this.lb?new Eb(this,a,b):null};
h.createEvent=function(a,b){y(null!=a.Ua,"Child events should have a childName.");var c=b.dc().u(a.Ua);return new Db(a.type,this,new D(a.Ha,c,b.n.g),a.Kd)};h.Mb=function(a){var b=this.nb;if("cancel"===a.te()){y(this.lb,"Raising a cancel event on a listener with no cancel callback");var c=this.lb;return function(){c.call(b,a.error)}}var d=this.ea[a.kd];return function(){d.call(b,a.Sd,a.Kd)}};
h.matches=function(a){if(a instanceof Ib){if(!this.ea||!a.ea)return!0;if(this.nb===a.nb){var b=Jb(a.ea);if(b===Jb(this.ea)){if(1===b){var b=Kb(a.ea),c=Kb(this.ea);return c===b&&(!a.ea[b]||!this.ea[c]||a.ea[b]===this.ea[c])}return Lb(this.ea,function(b,c){return a.ea[c]===b})}}}return!1};h.jf=function(){return null!==this.ea};function jb(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,y(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b};function E(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function G(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function H(a,b,c,d){if((!d||m(c))&&!ha(c))throw Error(G(a,b,d)+"must be a valid function.");}function Mb(a,b,c){if(m(c)&&(!ia(c)||null===c))throw Error(G(a,b,!0)+"must be a valid context object.");};var Nb=/[\[\].#$\/\u0000-\u001F\u007F]/,Ob=/[\[\].#$\u0000-\u001F\u007F]/;function Pb(a){return p(a)&&0!==a.length&&!Nb.test(a)}function Qb(a){return null===a||p(a)||ga(a)&&!sb(a)||ia(a)&&s(a,".sv")}function Rb(a,b,c){c&&!m(b)||Sb(G(a,1,c),b)}
function Sb(a,b,c,d){c||(c=0);var e=d||[];if(!m(b))throw Error(a+"contains undefined"+Tb(e));if(ha(b))throw Error(a+"contains a function"+Tb(e)+" with contents: "+b.toString());if(sb(b))throw Error(a+"contains "+b.toString()+Tb(e));if(1E3<c)throw new TypeError(a+"contains a cyclic object value ("+e.slice(0,100).join(".")+"...)");if(p(b)&&b.length>10485760/3&&10485760<jb(b).length)throw Error(a+"contains a string greater than 10485760 utf8 bytes"+Tb(e)+" ('"+b.substring(0,50)+"...')");if(ia(b)){var f=
!1,g=!1;ua(b,function(b,d){if(".value"===b)f=!0;else if(".priority"!==b&&".sv"!==b&&(g=!0,!Pb(b)))throw Error(a+" contains an invalid key ("+b+")"+Tb(e)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');e.push(b);Sb(a,d,c+1,e);e.pop()});if(f&&g)throw Error(a+' contains ".value" child'+Tb(e)+" in addition to actual children.");}}function Tb(a){return 0==a.length?"":" in property '"+a.join(".")+"'"}
function Ub(a,b){if(!ia(b)||ea(b))throw Error(G(a,1,!1)+" must be an Object containing the children to replace.");if(s(b,".value"))throw Error(G(a,1,!1)+' must not contain ".value".  To overwrite with a leaf value, just use .set() instead.');Rb(a,b,!1)}
function Vb(a,b,c){if(sb(c))throw Error(G(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!Qb(c))throw Error(G(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function Wb(a,b,c){if(!c||m(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(G(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function Xb(a,b,c,d){if((!d||m(c))&&!Pb(c))throw Error(G(a,b,d)+'was an invalid key: "'+c+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function Yb(a,b){if(!p(b)||0===b.length||Ob.test(b))throw Error(G(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function Zb(a,b){if(".info"===I(b))throw Error(a+" failed: Can't modify data under /.info/");}function $b(a,b){if(!p(b))throw Error(G(a,1,!1)+"must be a valid credential (a string).");}function ac(a,b,c){if(!p(c))throw Error(G(a,b,!1)+"must be a valid string.");}
function J(a,b,c,d){if(!d||m(c))if(!ia(c)||null===c)throw Error(G(a,b,d)+"must be a valid object.");}function K(a,b,c){if(!ia(b)||null===b||!s(b,c))throw Error(G(a,1,!1)+'must contain the key "'+c+'"');if(!p(t(b,c)))throw Error(G(a,1,!1)+'must contain the key "'+c+'" with type "string"');};function bc(a){this.g=a}h=bc.prototype;h.D=function(a,b,c,d,e){y(a.Bc(this.g),"A node must be indexed if only a child is updated");d=a.K(b);if(d.aa(c))return a;null!=e&&(c.e()?a.Da(b)?cc(e,new C("child_removed",d,b)):y(a.M(),"A child remove without an old child only makes sense on a leaf node"):d.e()?cc(e,new C("child_added",c,b)):cc(e,new C("child_changed",c,b,d)));return a.M()&&c.e()?a:a.P(b,c).hb(this.g)};
h.oa=function(a,b,c){null!=c&&(a.M()||a.U(L,function(a,e){b.Da(a)||cc(c,new C("child_removed",e,a))}),b.M()||b.U(L,function(b,e){if(a.Da(b)){var f=a.K(b);f.aa(e)||cc(c,new C("child_changed",e,b,f))}else cc(c,new C("child_added",e,b))}));return b.hb(this.g)};h.$=function(a,b){return a.e()?M:a.$(b)};h.Ca=function(){return!1};h.Nb=function(){return this};function dc(a){this.ve=new bc(a.g);this.g=a.g;var b;a.ia?(b=ec(a),b=a.g.ud(fc(a),b)):b=a.g.yd();this.Vc=b;a.qa?(b=gc(a),a=a.g.ud(hc(a),b)):a=a.g.wd();this.xc=a}h=dc.prototype;h.matches=function(a){return 0>=this.g.compare(this.Vc,a)&&0>=this.g.compare(a,this.xc)};h.D=function(a,b,c,d,e){this.matches(new N(b,c))||(c=M);return this.ve.D(a,b,c,d,e)};h.oa=function(a,b,c){b.M()&&(b=M);var d=b.hb(this.g),d=d.$(M),e=this;b.U(L,function(a,b){e.matches(new N(a,b))||(d=d.P(a,M))});return this.ve.oa(a,d,c)};
h.$=function(a){return a};h.Ca=function(){return!0};h.Nb=function(){return this.ve};function ic(a,b){return ub(a.name,b.name)}function jc(a,b){return ub(a,b)};function kc(){}var lc={};function mc(a){return q(a.compare,a)}kc.prototype.we=function(a,b){return 0!==this.compare(new N("[MIN_NAME]",a),new N("[MIN_NAME]",b))};kc.prototype.yd=function(){return nc};function oc(a){this.Vb=a}ma(oc,kc);h=oc.prototype;h.sd=function(a){return!a.K(this.Vb).e()};h.compare=function(a,b){var c=a.V.K(this.Vb),d=b.V.K(this.Vb),c=c.dd(d);return 0===c?ub(a.name,b.name):c};h.ud=function(a,b){var c=O(a),c=M.P(this.Vb,c);return new N(b,c)};
h.wd=function(){var a=M.P(this.Vb,pc);return new N("[MAX_NAME]",a)};h.toString=function(){return this.Vb};var L=new oc(".priority");function qc(){}ma(qc,kc);h=qc.prototype;h.compare=function(a,b){return ub(a.name,b.name)};h.sd=function(){throw fb("KeyIndex.isDefinedOn not expected to be called.");};h.we=function(){return!1};h.yd=function(){return nc};h.wd=function(){return new N("[MAX_NAME]",M)};h.ud=function(a){y(p(a),"KeyIndex indexValue must always be a string.");return new N(a,M)};
h.toString=function(){return".key"};var rc=new qc;function sc(){}ma(sc,kc);h=sc.prototype;h.compare=function(a,b){var c=a.V.dd(b.V);return 0===c?ub(a.name,b.name):c};h.sd=function(){return!0};h.we=function(a,b){return!a.aa(b)};h.yd=function(){return nc};h.wd=function(){return tc};h.ud=function(a,b){var c=O(a);return new N(b,c)};h.toString=function(){return".value"};var uc=new sc;function vc(){}vc.prototype.ff=function(){return null};vc.prototype.se=function(){return null};var wc=new vc;function xc(a,b,c){this.Bf=a;this.Ia=b;this.Ed=c}xc.prototype.ff=function(a){var b=this.Ia.B;if(yc(b,a))return b.j().K(a);b=null!=this.Ed?new zc(this.Ed,!0,!1):this.Ia.o();return this.Bf.Ta(a,b)};xc.prototype.se=function(a,b,c){var d=null!=this.Ed?this.Ed:Ac(this.Ia);a=this.Bf.he(d,b,1,c,a);return 0===a.length?null:a[0]};function Bc(){this.Za={}}
function cc(a,b){var c=b.type,d=b.Ua;y("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");y(".priority"!==d,"Only non-priority child changes can be tracked.");var e=t(a.Za,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.Ha);else if("child_removed"==c&&"child_added"==f)delete a.Za[d];else if("child_removed"==c&&"child_changed"==f)a.Za[d]=new C("child_removed",e.Ee,d);else if("child_changed"==c&&
"child_added"==f)a.Za[d]=new C("child_added",b.Ha,d);else if("child_changed"==c&&"child_changed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.Ee);else throw fb("Illegal combination of changes: "+b+" occurred after "+e);}else a.Za[d]=b};function N(a,b){this.name=a;this.V=b}function Cc(a,b){return new N(a,b)};function Dc(a){this.ma=new dc(a);this.g=a.g;y(a.ka,"Only valid if limit has been set");this.sa=a.sa;this.Ab=!(""===a.Fb?a.ia:"l"===a.Fb)}h=Dc.prototype;h.D=function(a,b,c,d,e){this.ma.matches(new N(b,c))||(c=M);return a.K(b).aa(c)?a:a.vb()<this.sa?this.ma.Nb().D(a,b,c,d,e):Ec(this,a,b,c,d,e)};
h.oa=function(a,b,c){var d;if(b.M()||b.e())d=M.hb(this.g);else if(2*this.sa<b.vb()&&b.Bc(this.g)){d=M.hb(this.g);b=this.Ab?b.Sb(this.ma.xc,this.g):b.Qb(this.ma.Vc,this.g);for(var e=0;0<b.Na.length&&e<this.sa;){var f=P(b),g;if(g=this.Ab?0>=this.g.compare(this.ma.Vc,f):0>=this.g.compare(f,this.ma.xc))d=d.P(f.name,f.V),e++;else break}}else{d=b.hb(this.g);d=d.$(M);var k,l,n;if(this.Ab){b=d.hf(this.g);k=this.ma.xc;l=this.ma.Vc;var u=mc(this.g);n=function(a,b){return u(b,a)}}else b=d.Pb(this.g),k=this.ma.Vc,
l=this.ma.xc,n=mc(this.g);for(var e=0,x=!1;0<b.Na.length;)f=P(b),!x&&0>=n(k,f)&&(x=!0),(g=x&&e<this.sa&&0>=n(f,l))?e++:d=d.P(f.name,M)}return this.ma.Nb().oa(a,d,c)};h.$=function(a){return a};h.Ca=function(){return!0};h.Nb=function(){return this.ma.Nb()};
function Ec(a,b,c,d,e,f){var g;if(a.Ab){var k=mc(a.g);g=function(a,b){return k(b,a)}}else g=mc(a.g);y(b.vb()==a.sa,"");var l=new N(c,d),n=a.Ab?Fc(b,a.g):Gc(b,a.g),u=a.ma.matches(l);if(b.Da(c)){var x=b.K(c),n=e.se(a.g,n,a.Ab);null!=n&&n.name==c&&(n=e.se(a.g,n,a.Ab));e=null==n?1:g(n,l);if(u&&!d.e()&&0<=e)return null!=f&&cc(f,new C("child_changed",d,c,x)),b.P(c,d);null!=f&&cc(f,new C("child_removed",x,c));b=b.P(c,M);return null!=n&&a.ma.matches(n)?(null!=f&&cc(f,new C("child_added",n.V,n.name)),b.P(n.name,
n.V)):b}return d.e()?b:u&&0<=g(n,l)?(null!=f&&(cc(f,new C("child_removed",n.V,n.name)),cc(f,new C("child_added",d,c))),b.P(c,d).P(n.name,M)):b};function Hc(){this.wc=this.qa=this.lc=this.ia=this.ka=!1;this.sa=0;this.Fb="";this.Ac=null;this.Xb="";this.zc=null;this.Ub="";this.g=L}var Ic=new Hc;function fc(a){y(a.ia,"Only valid if start has been set");return a.Ac}function ec(a){y(a.ia,"Only valid if start has been set");return a.lc?a.Xb:"[MIN_NAME]"}function hc(a){y(a.qa,"Only valid if end has been set");return a.zc}function gc(a){y(a.qa,"Only valid if end has been set");return a.wc?a.Ub:"[MAX_NAME]"}
function Jc(a){var b=new Hc;b.ka=a.ka;b.sa=a.sa;b.ia=a.ia;b.Ac=a.Ac;b.lc=a.lc;b.Xb=a.Xb;b.qa=a.qa;b.zc=a.zc;b.wc=a.wc;b.Ub=a.Ub;b.g=a.g;return b}h=Hc.prototype;h.Be=function(a){var b=Jc(this);b.ka=!0;b.sa=a;b.Fb="";return b};h.Ce=function(a){var b=Jc(this);b.ka=!0;b.sa=a;b.Fb="l";return b};h.De=function(a){var b=Jc(this);b.ka=!0;b.sa=a;b.Fb="r";return b};h.Td=function(a,b){var c=Jc(this);c.ia=!0;m(a)||(a=null);c.Ac=a;null!=b?(c.lc=!0,c.Xb=b):(c.lc=!1,c.Xb="");return c};
h.jd=function(a,b){var c=Jc(this);c.qa=!0;m(a)||(a=null);c.zc=a;m(b)?(c.wc=!0,c.Ub=b):(c.Jg=!1,c.Ub="");return c};function Kc(a,b){var c=Jc(a);c.g=b;return c}function Lc(a){var b={};a.ia&&(b.sp=a.Ac,a.lc&&(b.sn=a.Xb));a.qa&&(b.ep=a.zc,a.wc&&(b.en=a.Ub));if(a.ka){b.l=a.sa;var c=a.Fb;""===c&&(c=a.ia?"l":"r");b.vf=c}a.g!==L&&(b.i=a.g.toString());return b}function Mc(a){return!(a.ia||a.qa||a.ka)}h.toString=function(){return r(Lc(this))};function Q(a,b,c,d){this.k=a;this.path=b;this.n=c;this.bc=d}
function Nc(a){var b=null,c=null;a.ia&&(b=fc(a));a.qa&&(c=hc(a));if(a.g===rc){if(a.ia){if("[MIN_NAME]"!=ec(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.qa){if("[MAX_NAME]"!=gc(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==
typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===L){if(null!=b&&!Qb(b)||null!=c&&!Qb(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(y(a.g instanceof oc||a.g===uc,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function Oc(a){if(a.ia&&a.qa&&a.ka&&(!a.ka||""===a.Fb))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function Pc(a,b){if(!0===a.bc)throw Error(b+": You can't combine multiple orderBy calls.");}Q.prototype.dc=function(){E("Query.ref",0,0,arguments.length);return new R(this.k,this.path)};Q.prototype.ref=Q.prototype.dc;
Q.prototype.wb=function(a,b,c,d){E("Query.on",2,4,arguments.length);Wb("Query.on",a,!1);H("Query.on",2,b,!1);var e=Qc("Query.on",c,d);if("value"===a)Rc(this.k,this,new Hb(b,e.cancel||null,e.Ka||null));else{var f={};f[a]=b;Rc(this.k,this,new Ib(f,e.cancel,e.Ka))}return b};Q.prototype.on=Q.prototype.wb;
Q.prototype.$b=function(a,b,c){E("Query.off",0,3,arguments.length);Wb("Query.off",a,!0);H("Query.off",2,b,!0);Mb("Query.off",3,c);var d=null,e=null;"value"===a?d=new Hb(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new Ib(e,null,c||null));e=this.k;d=".info"===I(this.path)?e.rd.gb(this,d):e.N.gb(this,d);Sc(e.ba,this.path,d)};Q.prototype.off=Q.prototype.$b;
Q.prototype.lg=function(a,b){function c(g){f&&(f=!1,e.$b(a,c),b.call(d.Ka,g))}E("Query.once",2,4,arguments.length);Wb("Query.once",a,!1);H("Query.once",2,b,!1);var d=Qc("Query.once",arguments[2],arguments[3]),e=this,f=!0;this.wb(a,c,function(b){e.$b(a,c);d.cancel&&d.cancel.call(d.Ka,b)})};Q.prototype.once=Q.prototype.lg;
Q.prototype.Be=function(a){z("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");E("Query.limit",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limit: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");var b=this.n.Be(a);Oc(b);return new Q(this.k,this.path,b,this.bc)};Q.prototype.limit=Q.prototype.Be;
Q.prototype.Ce=function(a){E("Query.limitToFirst",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.Ce(a),this.bc)};Q.prototype.limitToFirst=Q.prototype.Ce;
Q.prototype.De=function(a){E("Query.limitToLast",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.De(a),this.bc)};Q.prototype.limitToLast=Q.prototype.De;
Q.prototype.mg=function(a){E("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');if("$value"===a)throw Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');Xb("Query.orderByChild",1,a,!1);Pc(this,"Query.orderByChild");var b=Kc(this.n,new oc(a));Nc(b);return new Q(this.k,
this.path,b,!0)};Q.prototype.orderByChild=Q.prototype.mg;Q.prototype.ng=function(){E("Query.orderByKey",0,0,arguments.length);Pc(this,"Query.orderByKey");var a=Kc(this.n,rc);Nc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByKey=Q.prototype.ng;Q.prototype.og=function(){E("Query.orderByPriority",0,0,arguments.length);Pc(this,"Query.orderByPriority");var a=Kc(this.n,L);Nc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByPriority=Q.prototype.og;
Q.prototype.pg=function(){E("Query.orderByValue",0,0,arguments.length);Pc(this,"Query.orderByValue");var a=Kc(this.n,uc);Nc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByValue=Q.prototype.pg;
Q.prototype.Td=function(a,b){E("Query.startAt",0,2,arguments.length);Rb("Query.startAt",a,!0);Xb("Query.startAt",2,b,!0);var c=this.n.Td(a,b);Oc(c);Nc(c);if(this.n.ia)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");m(a)||(b=a=null);return new Q(this.k,this.path,c,this.bc)};Q.prototype.startAt=Q.prototype.Td;
Q.prototype.jd=function(a,b){E("Query.endAt",0,2,arguments.length);Rb("Query.endAt",a,!0);Xb("Query.endAt",2,b,!0);var c=this.n.jd(a,b);Oc(c);Nc(c);if(this.n.qa)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new Q(this.k,this.path,c,this.bc)};Q.prototype.endAt=Q.prototype.jd;
Q.prototype.Tf=function(a,b){E("Query.equalTo",1,2,arguments.length);Rb("Query.equalTo",a,!1);Xb("Query.equalTo",2,b,!0);if(this.n.ia)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.qa)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.Td(a,b).jd(a,b)};Q.prototype.equalTo=Q.prototype.Tf;Q.prototype.Fa=function(){var a=xb(Lc(this.n));return"{}"===a?"default":a};
function Qc(a,b,c){var d={cancel:null,Ka:null};if(b&&c)d.cancel=b,H(a,3,d.cancel,!0),d.Ka=c,Mb(a,4,d.Ka);else if(b)if("object"===typeof b&&null!==b)d.Ka=b;else if("function"===typeof b)d.cancel=b;else throw Error(G(a,3,!0)+" must either be a cancel callback or a context object.");return d};function S(a,b){if(1==arguments.length){this.w=a.split("/");for(var c=0,d=0;d<this.w.length;d++)0<this.w[d].length&&(this.w[c]=this.w[d],c++);this.w.length=c;this.da=0}else this.w=a,this.da=b}function I(a){return a.da>=a.w.length?null:a.w[a.da]}function Tc(a){return a.w.length-a.da}function T(a){var b=a.da;b<a.w.length&&b++;return new S(a.w,b)}function Uc(a){return a.da<a.w.length?a.w[a.w.length-1]:null}
S.prototype.toString=function(){for(var a="",b=this.da;b<this.w.length;b++)""!==this.w[b]&&(a+="/"+this.w[b]);return a||"/"};S.prototype.parent=function(){if(this.da>=this.w.length)return null;for(var a=[],b=this.da;b<this.w.length-1;b++)a.push(this.w[b]);return new S(a,0)};
S.prototype.u=function(a){for(var b=[],c=this.da;c<this.w.length;c++)b.push(this.w[c]);if(a instanceof S)for(c=a.da;c<a.w.length;c++)b.push(a.w[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new S(b,0)};S.prototype.e=function(){return this.da>=this.w.length};var U=new S("");function V(a,b){var c=I(a);if(null===c)return b;if(c===I(b))return V(T(a),T(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
S.prototype.aa=function(a){if(Tc(this)!==Tc(a))return!1;for(var b=this.da,c=a.da;b<=this.w.length;b++,c++)if(this.w[b]!==a.w[c])return!1;return!0};S.prototype.contains=function(a){var b=this.da,c=a.da;if(Tc(this)>Tc(a))return!1;for(;b<this.w.length;){if(this.w[b]!==a.w[c])return!1;++b;++c}return!0};function Vc(){this.children={};this.bd=0;this.value=null}function Wc(a,b,c){this.zd=a?a:"";this.Oc=b?b:null;this.A=c?c:new Vc}function Xc(a,b){for(var c=b instanceof S?b:new S(b),d=a,e;null!==(e=I(c));)d=new Wc(e,d,t(d.A.children,e)||new Vc),c=T(c);return d}h=Wc.prototype;h.za=function(){return this.A.value};function Yc(a,b){y("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;Zc(a)}h.clear=function(){this.A.value=null;this.A.children={};this.A.bd=0;Zc(this)};
h.md=function(){return 0<this.A.bd};h.e=function(){return null===this.za()&&!this.md()};h.U=function(a){var b=this;A(this.A.children,function(c,d){a(new Wc(d,b,c))})};function $c(a,b,c,d){c&&!d&&b(a);a.U(function(a){$c(a,b,!0,d)});c&&d&&b(a)}function ad(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}h.path=function(){return new S(null===this.Oc?this.zd:this.Oc.path()+"/"+this.zd)};h.name=function(){return this.zd};h.parent=function(){return this.Oc};
function Zc(a){if(null!==a.Oc){var b=a.Oc,c=a.zd,d=a.e(),e=s(b.A.children,c);d&&e?(delete b.A.children[c],b.A.bd--,Zc(b)):d||e||(b.A.children[c]=a.A,b.A.bd++,Zc(b))}};function bd(a,b){this.Ja=a;this.va=b?b:cd}h=bd.prototype;h.La=function(a,b){return new bd(this.Ja,this.va.La(a,b,this.Ja).Y(null,null,!1,null,null))};h.remove=function(a){return new bd(this.Ja,this.va.remove(a,this.Ja).Y(null,null,!1,null,null))};h.get=function(a){for(var b,c=this.va;!c.e();){b=this.Ja(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function dd(a,b){for(var c,d=a.va,e=null;!d.e();){c=a.Ja(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}h.e=function(){return this.va.e()};h.count=function(){return this.va.count()};h.Ic=function(){return this.va.Ic()};h.Yb=function(){return this.va.Yb()};h.fa=function(a){return this.va.fa(a)};
h.Pb=function(a){return new ed(this.va,null,this.Ja,!1,a)};h.Qb=function(a,b){return new ed(this.va,a,this.Ja,!1,b)};h.Sb=function(a,b){return new ed(this.va,a,this.Ja,!0,b)};h.hf=function(a){return new ed(this.va,null,this.Ja,!0,a)};function ed(a,b,c,d,e){this.Nd=e||null;this.ze=d;this.Na=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.ze?a.left:a.right;else if(0===e){this.Na.push(a);break}else this.Na.push(a),a=this.ze?a.right:a.left}
function P(a){if(0===a.Na.length)return null;var b=a.Na.pop(),c;c=a.Nd?a.Nd(b.key,b.value):{key:b.key,value:b.value};if(a.ze)for(b=b.left;!b.e();)a.Na.push(b),b=b.right;else for(b=b.right;!b.e();)a.Na.push(b),b=b.left;return c}function fd(a){if(0===a.Na.length)return null;var b;b=a.Na;b=b[b.length-1];return a.Nd?a.Nd(b.key,b.value):{key:b.key,value:b.value}}function gd(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:cd;this.right=null!=e?e:cd}h=gd.prototype;
h.Y=function(a,b,c,d,e){return new gd(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};h.count=function(){return this.left.count()+1+this.right.count()};h.e=function(){return!1};h.fa=function(a){return this.left.fa(a)||a(this.key,this.value)||this.right.fa(a)};function hd(a){return a.left.e()?a:hd(a.left)}h.Ic=function(){return hd(this).key};h.Yb=function(){return this.right.e()?this.key:this.right.Yb()};
h.La=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.Y(null,null,null,e.left.La(a,b,c),null):0===d?e.Y(null,b,null,null,null):e.Y(null,null,null,null,e.right.La(a,b,c));return id(e)};function jd(a){if(a.left.e())return cd;a.left.ca()||a.left.left.ca()||(a=kd(a));a=a.Y(null,null,null,jd(a.left),null);return id(a)}
h.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.ca()||c.left.left.ca()||(c=kd(c)),c=c.Y(null,null,null,c.left.remove(a,b),null);else{c.left.ca()&&(c=md(c));c.right.e()||c.right.ca()||c.right.left.ca()||(c=nd(c),c.left.left.ca()&&(c=md(c),c=nd(c)));if(0===b(a,c.key)){if(c.right.e())return cd;d=hd(c.right);c=c.Y(d.key,d.value,null,null,jd(c.right))}c=c.Y(null,null,null,null,c.right.remove(a,b))}return id(c)};h.ca=function(){return this.color};
function id(a){a.right.ca()&&!a.left.ca()&&(a=od(a));a.left.ca()&&a.left.left.ca()&&(a=md(a));a.left.ca()&&a.right.ca()&&(a=nd(a));return a}function kd(a){a=nd(a);a.right.left.ca()&&(a=a.Y(null,null,null,null,md(a.right)),a=od(a),a=nd(a));return a}function od(a){return a.right.Y(null,null,a.color,a.Y(null,null,!0,null,a.right.left),null)}function md(a){return a.left.Y(null,null,a.color,null,a.Y(null,null,!0,a.left.right,null))}
function nd(a){return a.Y(null,null,!a.color,a.left.Y(null,null,!a.left.color,null,null),a.right.Y(null,null,!a.right.color,null,null))}function pd(){}h=pd.prototype;h.Y=function(){return this};h.La=function(a,b){return new gd(a,b,null)};h.remove=function(){return this};h.count=function(){return 0};h.e=function(){return!0};h.fa=function(){return!1};h.Ic=function(){return null};h.Yb=function(){return null};h.ca=function(){return!1};var cd=new pd;function qd(a,b){this.F=a;y(m(this.F)&&null!==this.F,"LeafNode shouldn't be created with null/undefined value.");this.ha=b||M;rd(this.ha);this.tb=null}h=qd.prototype;h.M=function(){return!0};h.L=function(){return this.ha};h.$=function(a){return new qd(this.F,a)};h.K=function(a){return".priority"===a?this.ha:M};h.ra=function(a){return a.e()?this:".priority"===I(a)?this.ha:M};h.Da=function(){return!1};h.gf=function(){return null};
h.P=function(a,b){return".priority"===a?this.$(b):b.e()&&".priority"!==a?this:M.P(a,b).$(this.ha)};h.D=function(a,b){var c=I(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;y(".priority"!==c||1===Tc(a),".priority must be the last token in a path");return this.P(c,M.D(T(a),b))};h.e=function(){return!1};h.vb=function(){return 0};h.I=function(a){return a&&!this.L().e()?{".value":this.za(),".priority":this.L().I()}:this.za()};
h.hash=function(){if(null===this.tb){var a="";this.ha.e()||(a+="priority:"+sd(this.ha.I())+":");var b=typeof this.F,a=a+(b+":"),a="number"===b?a+Ab(this.F):a+this.F;this.tb=ib(a)}return this.tb};h.za=function(){return this.F};h.dd=function(a){if(a===M)return 1;if(a instanceof W)return-1;y(a.M(),"Unknown node type");var b=typeof a.F,c=typeof this.F,d=Ga(td,b),e=Ga(td,c);y(0<=d,"Unknown leaf type: "+b);y(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.F<a.F?-1:this.F===a.F?0:1:e-d};
var td=["object","boolean","number","string"];qd.prototype.hb=function(){return this};qd.prototype.Bc=function(){return!0};qd.prototype.aa=function(a){return a===this?!0:a.M()?this.F===a.F&&this.ha.aa(a.ha):!1};qd.prototype.toString=function(){return r(this.I(!0))};function ud(a,b){this.qd=a;this.Wb=b}ud.prototype.get=function(a){var b=t(this.qd,a);if(!b)throw Error("No index defined for "+a);return b===lc?null:b};function vd(a,b,c){var d=wd(a.qd,function(d,f){var g=t(a.Wb,f);y(g,"Missing index implementation for "+f);if(d===lc){if(g.sd(b.V)){for(var k=[],l=c.Pb(Cc),n=P(l);n;)n.name!=b.name&&k.push(n),n=P(l);k.push(b);return xd(k,mc(g))}return lc}g=c.get(b.name);k=d;g&&(k=k.remove(new N(b.name,g)));return k.La(b,b.V)});return new ud(d,a.Wb)}
function yd(a,b,c){var d=wd(a.qd,function(a){if(a===lc)return a;var d=c.get(b.name);return d?a.remove(new N(b.name,d)):a});return new ud(d,a.Wb)}var zd=new ud({".priority":lc},{".priority":L});function W(a,b,c){this.m=a;(this.ha=b)&&rd(this.ha);this.pb=c;this.tb=null}h=W.prototype;h.M=function(){return!1};h.L=function(){return this.ha||M};h.$=function(a){return new W(this.m,a,this.pb)};h.K=function(a){if(".priority"===a)return this.L();a=this.m.get(a);return null===a?M:a};h.ra=function(a){var b=I(a);return null===b?this:this.K(b).ra(T(a))};h.Da=function(a){return null!==this.m.get(a)};
h.P=function(a,b){y(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.$(b);var c=new N(a,b),d;b.e()?(d=this.m.remove(a),c=yd(this.pb,c,this.m)):(d=this.m.La(a,b),c=vd(this.pb,c,this.m));return new W(d,this.ha,c)};h.D=function(a,b){var c=I(a);if(null===c)return b;y(".priority"!==I(a)||1===Tc(a),".priority must be the last token in a path");var d=this.K(c).D(T(a),b);return this.P(c,d)};h.e=function(){return this.m.e()};h.vb=function(){return this.m.count()};var Ad=/^(0|[1-9]\d*)$/;
h=W.prototype;h.I=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.U(L,function(f,g){b[f]=g.I(a);c++;e&&Ad.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],g;for(g in b)f[g]=b[g];return f}a&&!this.L().e()&&(b[".priority"]=this.L().I());return b};h.hash=function(){if(null===this.tb){var a="";this.L().e()||(a+="priority:"+sd(this.L().I())+":");this.U(L,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.tb=""===a?"":ib(a)}return this.tb};
h.gf=function(a,b,c){return(c=Bd(this,c))?(a=dd(c,new N(a,b)))?a.name:null:dd(this.m,a)};function Fc(a,b){var c;c=(c=Bd(a,b))?(c=c.Ic())&&c.name:a.m.Ic();return c?new N(c,a.m.get(c)):null}function Gc(a,b){var c;c=(c=Bd(a,b))?(c=c.Yb())&&c.name:a.m.Yb();return c?new N(c,a.m.get(c)):null}h.U=function(a,b){var c=Bd(this,a);return c?c.fa(function(a){return b(a.name,a.V)}):this.m.fa(b)};h.Pb=function(a){return this.Qb(a.yd(),a)};
h.Qb=function(a,b){var c=Bd(this,b);if(c)return c.Qb(a,function(a){return a});for(var c=this.m.Qb(a.name,Cc),d=fd(c);null!=d&&0>b.compare(d,a);)P(c),d=fd(c);return c};h.hf=function(a){return this.Sb(a.wd(),a)};h.Sb=function(a,b){var c=Bd(this,b);if(c)return c.Sb(a,function(a){return a});for(var c=this.m.Sb(a.name,Cc),d=fd(c);null!=d&&0<b.compare(d,a);)P(c),d=fd(c);return c};h.dd=function(a){return this.e()?a.e()?0:-1:a.M()||a.e()?1:a===pc?-1:0};
h.hb=function(a){if(a===rc||Cd(this.pb.Wb,a.toString()))return this;var b=this.pb,c=this.m;y(a!==rc,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.Pb(Cc),f=P(c);f;)e=e||a.sd(f.V),d.push(f),f=P(c);d=e?xd(d,mc(a)):lc;e=a.toString();c=Dd(b.Wb);c[e]=a;a=Dd(b.qd);a[e]=d;return new W(this.m,this.ha,new ud(a,c))};h.Bc=function(a){return a===rc||Cd(this.pb.Wb,a.toString())};
h.aa=function(a){if(a===this)return!0;if(a.M())return!1;if(this.L().aa(a.L())&&this.m.count()===a.m.count()){var b=this.Pb(L);a=a.Pb(L);for(var c=P(b),d=P(a);c&&d;){if(c.name!==d.name||!c.V.aa(d.V))return!1;c=P(b);d=P(a)}return null===c&&null===d}return!1};function Bd(a,b){return b===rc?null:a.pb.get(b.toString())}h.toString=function(){return r(this.I(!0))};function O(a,b){if(null===a)return M;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);y(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new qd(a,O(c));if(a instanceof Array){var d=M,e=a;A(e,function(a,b){if(s(e,b)&&"."!==b.substring(0,1)){var c=O(a);if(c.M()||!c.e())d=
d.P(b,c)}});return d.$(O(c))}var f=[],g=!1,k=a;ua(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=O(k[a]);b.e()||(g=g||!b.L().e(),f.push(new N(a,b)))}});var l=xd(f,ic,function(a){return a.name},jc);if(g){var n=xd(f,mc(L));return new W(l,O(c),new ud({".priority":n},{".priority":L}))}return new W(l,O(c),zd)}var Ed=Math.log(2);function Fd(a){this.count=parseInt(Math.log(a+1)/Ed,10);this.af=this.count-1;this.Nf=a+1&parseInt(Array(this.count+1).join("1"),2)}
function Gd(a){var b=!(a.Nf&1<<a.af);a.af--;return b}
function xd(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var n=a[b],u=c?c(n):n;return new gd(u,n.V,!1,null,null)}var n=parseInt(f/2,10)+b,f=e(b,n),x=e(n+1,d),n=a[n],u=c?c(n):n;return new gd(u,n.V,!1,f,x)}a.sort(b);var f=function(b){function d(b,g){var k=u-b,x=u;u-=b;var x=e(k+1,x),k=a[k],F=c?c(k):k,x=new gd(F,k.V,g,null,x);f?f.left=x:n=x;f=x}for(var f=null,n=null,u=a.length,x=0;x<b.count;++x){var F=Gd(b),ld=Math.pow(2,b.count-(x+1));F?d(ld,!1):(d(ld,!1),d(ld,!0))}return n}(new Fd(a.length));
return null!==f?new bd(d||b,f):new bd(d||b)}function sd(a){return"number"===typeof a?"number:"+Ab(a):"string:"+a}function rd(a){if(a.M()){var b=a.I();y("string"===typeof b||"number"===typeof b||"object"===typeof b&&s(b,".sv"),"Priority must be a string or number.")}else y(a===pc||a.e(),"priority of unexpected type.");y(a===pc||a.L().e(),"Priority nodes can't have a priority of their own.")}var M=new W(new bd(jc),null,zd);function Hd(){W.call(this,new bd(jc),M,zd)}ma(Hd,W);h=Hd.prototype;
h.dd=function(a){return a===this?0:1};h.aa=function(a){return a===this};h.L=function(){throw fb("Why is this called?");};h.K=function(){return M};h.e=function(){return!1};var pc=new Hd,nc=new N("[MIN_NAME]",M),tc=new N("[MAX_NAME]",pc);function D(a,b,c){this.A=a;this.W=b;this.g=c}D.prototype.I=function(){E("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.I()};D.prototype.val=D.prototype.I;D.prototype.cf=function(){E("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.I(!0)};D.prototype.exportVal=D.prototype.cf;D.prototype.Wf=function(){E("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};D.prototype.exists=D.prototype.Wf;
D.prototype.u=function(a){E("Firebase.DataSnapshot.child",0,1,arguments.length);ga(a)&&(a=String(a));Yb("Firebase.DataSnapshot.child",a);var b=new S(a),c=this.W.u(b);return new D(this.A.ra(b),c,L)};D.prototype.child=D.prototype.u;D.prototype.Da=function(a){E("Firebase.DataSnapshot.hasChild",1,1,arguments.length);Yb("Firebase.DataSnapshot.hasChild",a);var b=new S(a);return!this.A.ra(b).e()};D.prototype.hasChild=D.prototype.Da;
D.prototype.L=function(){E("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.L().I()};D.prototype.getPriority=D.prototype.L;D.prototype.forEach=function(a){E("Firebase.DataSnapshot.forEach",1,1,arguments.length);H("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.M())return!1;var b=this;return!!this.A.U(this.g,function(c,d){return a(new D(d,b.W.u(c),L))})};D.prototype.forEach=D.prototype.forEach;
D.prototype.md=function(){E("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.M()?!1:!this.A.e()};D.prototype.hasChildren=D.prototype.md;D.prototype.name=function(){z("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");E("Firebase.DataSnapshot.name",0,0,arguments.length);return this.key()};D.prototype.name=D.prototype.name;D.prototype.key=function(){E("Firebase.DataSnapshot.key",0,0,arguments.length);return this.W.key()};
D.prototype.key=D.prototype.key;D.prototype.vb=function(){E("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.vb()};D.prototype.numChildren=D.prototype.vb;D.prototype.dc=function(){E("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.W};D.prototype.ref=D.prototype.dc;function Id(a){y(ea(a)&&0<a.length,"Requires a non-empty array");this.Ff=a;this.Gc={}}Id.prototype.$d=function(a,b){for(var c=this.Gc[a]||[],d=0;d<c.length;d++)c[d].rc.apply(c[d].Ka,Array.prototype.slice.call(arguments,1))};Id.prototype.wb=function(a,b,c){Jd(this,a);this.Gc[a]=this.Gc[a]||[];this.Gc[a].push({rc:b,Ka:c});(a=this.ue(a))&&b.apply(c,a)};Id.prototype.$b=function(a,b,c){Jd(this,a);a=this.Gc[a]||[];for(var d=0;d<a.length;d++)if(a[d].rc===b&&(!c||c===a[d].Ka)){a.splice(d,1);break}};
function Jd(a,b){y(Ma(a.Ff,function(a){return a===b}),"Unknown event: "+b)};function Kd(){Id.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.nc=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.nc&&(c.nc=b,c.$d("visible",b))},!1)}}ma(Kd,Id);ca(Kd);Kd.prototype.ue=function(a){y("visible"===a,"Unknown event type: "+a);return[this.nc]};function A(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function wd(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function Lb(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function Jb(a){var b=0,c;for(c in a)b++;return b}function Kb(a){for(var b in a)return b}function Ld(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Md(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Cd(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function Nd(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function Od(a,b){var c=Nd(a,b,void 0);return c&&a[c]}function Pd(a){for(var b in a)return!1;return!0}function Qd(a,b){return b in a?a[b]:void 0}function Dd(a){var b={},c;for(c in a)b[c]=a[c];return b}var Rd="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Sd(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Rd.length;f++)c=Rd[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Td(){this.uc={}}function Ud(a,b,c){m(c)||(c=1);s(a.uc,b)||(a.uc[b]=0);a.uc[b]+=c}Td.prototype.get=function(){return Dd(this.uc)};function Vd(a){this.Pf=a;this.td=null}Vd.prototype.get=function(){var a=this.Pf.get(),b=Dd(a);if(this.td)for(var c in this.td)b[c]-=this.td[c];this.td=a;return b};function Wd(a,b){this.zf={};this.Ud=new Vd(a);this.S=b;var c=1E4+2E4*Math.random();setTimeout(q(this.tf,this),Math.floor(c))}Wd.prototype.tf=function(){var a=this.Ud.get(),b={},c=!1,d;for(d in a)0<a[d]&&s(this.zf,d)&&(b[d]=a[d],c=!0);c&&(a=this.S,a.ja&&(b={c:b},a.f("reportStats",b),a.Ba("s",b)));setTimeout(q(this.tf,this),Math.floor(6E5*Math.random()))};var Xd={},Yd={};function Zd(a){a=a.toString();Xd[a]||(Xd[a]=new Td);return Xd[a]}function $d(a,b){var c=a.toString();Yd[c]||(Yd[c]=b());return Yd[c]};var ae=null;"undefined"!==typeof MozWebSocket?ae=MozWebSocket:"undefined"!==typeof WebSocket&&(ae=WebSocket);function be(a,b,c){this.me=a;this.f=ob(this.me);this.frames=this.Cc=null;this.jb=this.kb=this.Ue=0;this.Ra=Zd(b);this.$a=(b.Bb?"wss://":"ws://")+b.Ma+"/.ws?v=5";"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(this.$a+="&r=f");b.host!==b.Ma&&(this.$a=this.$a+"&ns="+b.ub);c&&(this.$a=this.$a+"&s="+c)}var ce;
be.prototype.open=function(a,b){this.fb=b;this.hg=a;this.f("Websocket connecting to "+this.$a);this.yc=!1;za.set("previous_websocket_failure",!0);try{this.ua=new ae(this.$a)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.eb();return}var e=this;this.ua.onopen=function(){e.f("Websocket connected.");e.yc=!0};this.ua.onclose=function(){e.f("Websocket connection was disconnected.");e.ua=null;e.eb()};this.ua.onmessage=function(a){if(null!==e.ua)if(a=a.data,e.jb+=
a.length,Ud(e.Ra,"bytes_received",a.length),de(e),null!==e.frames)ee(e,a);else{a:{y(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.Ue=b;e.frames=[];a=null;break a}}e.Ue=1;e.frames=[]}null!==a&&ee(e,a)}};this.ua.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.eb()}};be.prototype.start=function(){};
be.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==ae&&!ce};be.responsesRequiredToBeHealthy=2;be.healthyTimeout=3E4;h=be.prototype;h.vd=function(){za.remove("previous_websocket_failure")};function ee(a,b){a.frames.push(b);if(a.frames.length==a.Ue){var c=a.frames.join("");a.frames=null;c=ta(c);a.hg(c)}}
h.send=function(a){de(this);a=r(a);this.kb+=a.length;Ud(this.Ra,"bytes_sent",a.length);a=yb(a,16384);1<a.length&&this.ua.send(String(a.length));for(var b=0;b<a.length;b++)this.ua.send(a[b])};h.Uc=function(){this.rb=!0;this.Cc&&(clearInterval(this.Cc),this.Cc=null);this.ua&&(this.ua.close(),this.ua=null)};h.eb=function(){this.rb||(this.f("WebSocket is closing itself"),this.Uc(),this.fb&&(this.fb(this.yc),this.fb=null))};h.close=function(){this.rb||(this.f("WebSocket is being closed"),this.Uc())};
function de(a){clearInterval(a.Cc);a.Cc=setInterval(function(){a.ua&&a.ua.send("0");de(a)},Math.floor(45E3))};function fe(a){this.ac=a;this.Hd=[];this.Jb=0;this.le=-1;this.xb=null}function ge(a,b,c){a.le=b;a.xb=c;a.le<a.Jb&&(a.xb(),a.xb=null)}function he(a,b,c){for(a.Hd[b]=c;a.Hd[a.Jb];){var d=a.Hd[a.Jb];delete a.Hd[a.Jb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;Cb(function(){f.ac(d[e])})}if(a.Jb===a.le){a.xb&&(clearTimeout(a.xb),a.xb(),a.xb=null);break}a.Jb++}};function ie(){this.set={}}h=ie.prototype;h.add=function(a,b){this.set[a]=null!==b?b:!0};h.contains=function(a){return s(this.set,a)};h.get=function(a){return this.contains(a)?this.set[a]:void 0};h.remove=function(a){delete this.set[a]};h.clear=function(){this.set={}};h.e=function(){return Pd(this.set)};h.count=function(){return Jb(this.set)};function je(a,b){A(a.set,function(a,d){b(d,a)})};function ke(a,b,c){this.me=a;this.f=ob(a);this.jb=this.kb=0;this.Ra=Zd(b);this.Rd=c;this.yc=!1;this.Zc=function(a){b.host!==b.Ma&&(a.ns=b.ub);var c=[],f;for(f in a)a.hasOwnProperty(f)&&c.push(f+"="+a[f]);return(b.Bb?"https://":"http://")+b.Ma+"/.lp?"+c.join("&")}}var le,me;
ke.prototype.open=function(a,b){this.$e=0;this.ga=b;this.mf=new fe(a);this.rb=!1;var c=this;this.mb=setTimeout(function(){c.f("Timed out trying to connect.");c.eb();c.mb=null},Math.floor(3E4));tb(function(){if(!c.rb){c.Pa=new ne(function(a,b,d,k,l){oe(c,arguments);if(c.Pa)if(c.mb&&(clearTimeout(c.mb),c.mb=null),c.yc=!0,"start"==a)c.id=b,c.rf=d;else if("close"===a)b?(c.Pa.Pd=!1,ge(c.mf,b,function(){c.eb()})):c.eb();else throw Error("Unrecognized command received: "+a);},function(a,b){oe(c,arguments);
he(c.mf,a,b)},function(){c.eb()},c.Zc);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Pa.ae&&(a.cb=c.Pa.ae);a.v="5";c.Rd&&(a.s=c.Rd);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.Zc(a);c.f("Connecting via long-poll to "+a);pe(c.Pa,a,function(){})}})};
ke.prototype.start=function(){var a=this.Pa,b=this.rf;a.cg=this.id;a.dg=b;for(a.fe=!0;qe(a););a=this.id;b=this.rf;this.Zb=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.Zb.src=this.Zc(c);this.Zb.style.display="none";document.body.appendChild(this.Zb)};ke.isAvailable=function(){return!me&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.Fg)&&(le||!0)};h=ke.prototype;
h.vd=function(){};h.Uc=function(){this.rb=!0;this.Pa&&(this.Pa.close(),this.Pa=null);this.Zb&&(document.body.removeChild(this.Zb),this.Zb=null);this.mb&&(clearTimeout(this.mb),this.mb=null)};h.eb=function(){this.rb||(this.f("Longpoll is closing itself"),this.Uc(),this.ga&&(this.ga(this.yc),this.ga=null))};h.close=function(){this.rb||(this.f("Longpoll is being closed."),this.Uc())};
h.send=function(a){a=r(a);this.kb+=a.length;Ud(this.Ra,"bytes_sent",a.length);a=jb(a);a=cb(a,!0);a=yb(a,1840);for(var b=0;b<a.length;b++){var c=this.Pa;c.Qc.push({ug:this.$e,Cg:a.length,bf:a[b]});c.fe&&qe(c);this.$e++}};function oe(a,b){var c=r(b).length;a.jb+=c;Ud(a.Ra,"bytes_received",c)}
function ne(a,b,c,d){this.Zc=d;this.fb=c;this.Je=new ie;this.Qc=[];this.oe=Math.floor(1E8*Math.random());this.Pd=!0;this.ae=eb();window["pLPCommand"+this.ae]=a;window["pRTLPCB"+this.ae]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||hb("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.ab=a.contentDocument:a.contentWindow?a.ab=a.contentWindow.document:a.document&&(a.ab=a.document);this.Aa=a;a="";this.Aa.src&&"javascript:"===this.Aa.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Aa.ab.open(),this.Aa.ab.write(a),this.Aa.ab.close()}catch(f){hb("frame writing exception"),f.stack&&hb(f.stack),hb(f)}}
ne.prototype.close=function(){this.fe=!1;if(this.Aa){this.Aa.ab.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Aa&&(document.body.removeChild(a.Aa),a.Aa=null)},Math.floor(0))}var b=this.fb;b&&(this.fb=null,b())};
function qe(a){if(a.fe&&a.Pd&&a.Je.count()<(0<a.Qc.length?2:1)){a.oe++;var b={};b.id=a.cg;b.pw=a.dg;b.ser=a.oe;for(var b=a.Zc(b),c="",d=0;0<a.Qc.length;)if(1870>=a.Qc[0].bf.length+30+c.length){var e=a.Qc.shift(),c=c+"&seg"+d+"="+e.ug+"&ts"+d+"="+e.Cg+"&d"+d+"="+e.bf;d++}else break;re(a,b+c,a.oe);return!0}return!1}function re(a,b,c){function d(){a.Je.remove(c);qe(a)}a.Je.add(c);var e=setTimeout(d,Math.floor(25E3));pe(a,b,function(){clearTimeout(e);d()})}
function pe(a,b,c){setTimeout(function(){try{if(a.Pd){var d=a.Aa.ab.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){hb("Long-poll script failed to load: "+b);a.Pd=!1;a.close()};a.Aa.ab.body.appendChild(d)}}catch(e){}},Math.floor(1))};function se(a){te(this,a)}var ue=[ke,be];function te(a,b){var c=be&&be.isAvailable(),d=c&&!(za.lf||!0===za.get("previous_websocket_failure"));b.Eg&&(c||z("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.Xc=[be];else{var e=a.Xc=[];zb(ue,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function ve(a){if(0<a.Xc.length)return a.Xc[0];throw Error("No transports available");};function we(a,b,c,d,e,f){this.id=a;this.f=ob("c:"+this.id+":");this.ac=c;this.Kc=d;this.ga=e;this.He=f;this.O=b;this.Gd=[];this.Ye=0;this.Af=new se(b);this.Qa=0;this.f("Connection created");xe(this)}
function xe(a){var b=ve(a.Af);a.J=new b("c:"+a.id+":"+a.Ye++,a.O);a.Le=b.responsesRequiredToBeHealthy||0;var c=ye(a,a.J),d=ze(a,a.J);a.Yc=a.J;a.Tc=a.J;a.C=null;a.sb=!1;setTimeout(function(){a.J&&a.J.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.od=setTimeout(function(){a.od=null;a.sb||(a.J&&102400<a.J.jb?(a.f("Connection exceeded healthy timeout but has received "+a.J.jb+" bytes.  Marking connection healthy."),a.sb=!0,a.J.vd()):a.J&&10240<a.J.kb?a.f("Connection exceeded healthy timeout but has sent "+
a.J.kb+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function ze(a,b){return function(c){b===a.J?(a.J=null,c||0!==a.Qa?1===a.Qa&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.O.Ma.substr(0,2)&&(za.remove("host:"+a.O.host),a.O.Ma=a.O.host)),a.close()):b===a.C?(a.f("Secondary connection lost."),c=a.C,a.C=null,a.Yc!==c&&a.Tc!==c||a.close()):a.f("closing an old connection")}}
function ye(a,b){return function(c){if(2!=a.Qa)if(b===a.Tc){var d=wb("t",c);c=wb("d",c);if("c"==d){if(d=wb("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.Rd=c.s;Ba(a.O,f);0==a.Qa&&(a.J.start(),Ae(a,a.J,d),"5"!==e&&z("Protocol version mismatch detected"),c=a.Af,(c=1<c.Xc.length?c.Xc[1]:null)&&Be(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.Tc=a.C;for(c=0;c<a.Gd.length;++c)a.Cd(a.Gd[c]);a.Gd=[];Ce(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.He&&(a.He(c),a.He=null),a.ga=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),Ba(a.O,c),1===a.Qa?a.close():(De(a),xe(a))):"e"===d?pb("Server Error: "+c):"o"===d?(a.f("got pong on primary."),Ee(a),Fe(a)):pb("Unknown control packet command: "+d)}else"d"==d&&a.Cd(c)}else if(b===a.C)if(d=wb("t",c),c=wb("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?Ge(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.C.close(),a.Yc!==a.C&&a.Tc!==a.C||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.yf--,Ge(a)));else if("d"==d)a.Gd.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}we.prototype.Ba=function(a){He(this,{t:"d",d:a})};function Ce(a){a.Yc===a.C&&a.Tc===a.C&&(a.f("cleaning up and promoting a connection: "+a.C.me),a.J=a.C,a.C=null)}
function Ge(a){0>=a.yf?(a.f("Secondary connection is healthy."),a.sb=!0,a.C.vd(),a.C.start(),a.f("sending client ack on secondary"),a.C.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.J.send({t:"c",d:{t:"n",d:{}}}),a.Yc=a.C,Ce(a)):(a.f("sending ping on secondary."),a.C.send({t:"c",d:{t:"p",d:{}}}))}we.prototype.Cd=function(a){Ee(this);this.ac(a)};function Ee(a){a.sb||(a.Le--,0>=a.Le&&(a.f("Primary connection is healthy."),a.sb=!0,a.J.vd()))}
function Be(a,b){a.C=new b("c:"+a.id+":"+a.Ye++,a.O,a.Rd);a.yf=b.responsesRequiredToBeHealthy||0;a.C.open(ye(a,a.C),ze(a,a.C));setTimeout(function(){a.C&&(a.f("Timed out trying to upgrade."),a.C.close())},Math.floor(6E4))}function Ae(a,b,c){a.f("Realtime connection established.");a.J=b;a.Qa=1;a.Kc&&(a.Kc(c),a.Kc=null);0===a.Le?(a.f("Primary connection is healthy."),a.sb=!0):setTimeout(function(){Fe(a)},Math.floor(5E3))}
function Fe(a){a.sb||1!==a.Qa||(a.f("sending ping on primary."),He(a,{t:"c",d:{t:"p",d:{}}}))}function He(a,b){if(1!==a.Qa)throw"Connection is not connected";a.Yc.send(b)}we.prototype.close=function(){2!==this.Qa&&(this.f("Closing realtime connection."),this.Qa=2,De(this),this.ga&&(this.ga(),this.ga=null))};function De(a){a.f("Shutting down all connections");a.J&&(a.J.close(),a.J=null);a.C&&(a.C.close(),a.C=null);a.od&&(clearTimeout(a.od),a.od=null)};function Ie(){Id.call(this,["online"]);this.Lc=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.Lc||a.$d("online",!0);a.Lc=!0},!1);window.addEventListener("offline",function(){a.Lc&&a.$d("online",!1);a.Lc=!1},!1)}}ma(Ie,Id);ca(Ie);Ie.prototype.ue=function(a){y("online"===a,"Unknown event type: "+a);return[this.Lc]};function Je(a){var b={},c={},d={},e="";try{var f=a.split("."),b=ta(gb(f[0])||""),c=ta(gb(f[1])||""),e=f[2],d=c.d||{};delete c.d}catch(g){}return{Hg:b,ke:c,data:d,yg:e}}function Ke(a){a=Je(a).ke;return"object"===typeof a&&a.hasOwnProperty("iat")?t(a,"iat"):null}function Le(a){a=Je(a);var b=a.ke;return!!a.yg&&!!b&&"object"===typeof b&&b.hasOwnProperty("iat")};function Me(a,b,c,d){this.id=Ne++;this.f=ob("p:"+this.id+":");this.Db=!0;this.ta={};this.la=[];this.Nc=0;this.Jc=[];this.ja=!1;this.Wa=1E3;this.xd=3E5;this.Dd=b;this.Bd=c;this.Ie=d;this.O=a;this.Pe=null;this.Sc={};this.tg=0;this.Dc=this.Ae=null;Oe(this,0);Kd.Ob().wb("visible",this.kg,this);-1===a.host.indexOf("fblocal")&&Ie.Ob().wb("online",this.ig,this)}var Ne=0,Pe=0;h=Me.prototype;
h.Ba=function(a,b,c){var d=++this.tg;a={r:d,a:a,b:b};this.f(r(a));y(this.ja,"sendRequest call when we're not connected not allowed.");this.Oa.Ba(a);c&&(this.Sc[d]=c)};function Qe(a,b,c,d,e){var f=b.Fa(),g=b.path.toString();a.f("Listen called for "+g+" "+f);a.ta[g]=a.ta[g]||{};y(!a.ta[g][f],"listen() called twice for same path/queryId.");b={H:e,nd:c,qg:Lc(b.n),tag:d};a.ta[g][f]=b;a.ja&&Re(a,g,f,b)}
function Re(a,b,c,d){a.f("Listen on "+b+" for "+c);var e={p:b};d.tag&&(e.q=d.qg,e.t=d.tag);e.h=d.nd();a.Ba("q",e,function(e){if((a.ta[b]&&a.ta[b][c])===d){a.f("listen response",e);var g=e.s;"ok"!==g&&Se(a,b,c);e=e.d;d.H&&d.H(g,e)}})}h.Q=function(a,b,c){this.Ib={Rf:a,df:!1,rc:b,ad:c};this.f("Authenticating using credential: "+a);Te(this);(b=40==a.length)||(a=Je(a).ke,b="object"===typeof a&&!0===t(a,"admin"));b&&(this.f("Admin auth credential detected.  Reducing max reconnect time."),this.xd=3E4)};
h.Ve=function(a){delete this.Ib;this.ja&&this.Ba("unauth",{},function(b){a(b.s,b.d)})};function Te(a){var b=a.Ib;a.ja&&b&&a.Ba("auth",{cred:b.Rf},function(c){var d=c.s;c=c.d||"error";"ok"!==d&&a.Ib===b&&delete a.Ib;b.df?"ok"!==d&&b.ad&&b.ad(d,c):(b.df=!0,b.rc&&b.rc(d,c))})}function Ue(a,b,c,d){a.ja?Ve(a,"o",b,c,d):a.Jc.push({Pc:b,action:"o",data:c,H:d})}function We(a,b,c,d){a.ja?Ve(a,"om",b,c,d):a.Jc.push({Pc:b,action:"om",data:c,H:d})}
h.Ge=function(a,b){this.ja?Ve(this,"oc",a,null,b):this.Jc.push({Pc:a,action:"oc",data:null,H:b})};function Ve(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.Ba(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}h.put=function(a,b,c,d){Xe(this,"p",a,b,c,d)};function Ye(a,b,c,d){Xe(a,"m",b,c,d,void 0)}function Xe(a,b,c,d,e,f){d={p:c,d:d};m(f)&&(d.h=f);a.la.push({action:b,uf:d,H:e});a.Nc++;b=a.la.length-1;a.ja?Ze(a,b):a.f("Buffering put: "+c)}
function Ze(a,b){var c=a.la[b].action,d=a.la[b].uf,e=a.la[b].H;a.la[b].rg=a.ja;a.Ba(c,d,function(d){a.f(c+" response",d);delete a.la[b];a.Nc--;0===a.Nc&&(a.la=[]);e&&e(d.s,d.d)})}
h.Cd=function(a){if("r"in a){this.f("from server: "+r(a));var b=a.r,c=this.Sc[b];c&&(delete this.Sc[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,c=a.b,this.f("handleServerMessage",b,c),"d"===b?this.Dd(c.p,c.d,!1,c.t):"m"===b?this.Dd(c.p,c.d,!0,c.t):"c"===b?$e(this,c.p,c.q):"ac"===b?(a=c.s,b=c.d,c=this.Ib,delete this.Ib,c&&c.ad&&c.ad(a,b)):"sd"===b?this.Pe?this.Pe(c):"msg"in c&&"undefined"!==typeof console&&console.log("FIREBASE: "+c.msg.replace("\n",
"\nFIREBASE: ")):pb("Unrecognized action received from server: "+r(b)+"\nAre you using the latest client?"))}};h.Kc=function(a){this.f("connection ready");this.ja=!0;this.Dc=(new Date).getTime();this.Ie({serverTimeOffset:a-(new Date).getTime()});af(this);this.Bd(!0)};function Oe(a,b){y(!a.Oa,"Scheduling a connect when we're already connected/ing?");a.Kb&&clearTimeout(a.Kb);a.Kb=setTimeout(function(){a.Kb=null;bf(a)},Math.floor(b))}
h.kg=function(a){a&&!this.nc&&this.Wa===this.xd&&(this.f("Window became visible.  Reducing delay."),this.Wa=1E3,this.Oa||Oe(this,0));this.nc=a};h.ig=function(a){a?(this.f("Browser went online.  Reconnecting."),this.Wa=1E3,this.Db=!0,this.Oa||Oe(this,0)):(this.f("Browser went offline.  Killing connection; don't reconnect."),this.Db=!1,this.Oa&&this.Oa.close())};
h.of=function(){this.f("data client disconnected");this.ja=!1;this.Oa=null;for(var a=0;a<this.la.length;a++){var b=this.la[a];b&&"h"in b.uf&&b.rg&&(b.H&&b.H("disconnect"),delete this.la[a],this.Nc--)}0===this.Nc&&(this.la=[]);if(this.Db)this.nc?this.Dc&&(3E4<(new Date).getTime()-this.Dc&&(this.Wa=1E3),this.Dc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.Wa=this.xd,this.Ae=(new Date).getTime()),a=Math.max(0,this.Wa-((new Date).getTime()-this.Ae)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),Oe(this,a),this.Wa=Math.min(this.xd,1.3*this.Wa);else for(var c in this.Sc)delete this.Sc[c];this.Bd(!1)};function bf(a){if(a.Db){a.f("Making a connection attempt");a.Ae=(new Date).getTime();a.Dc=null;var b=q(a.Cd,a),c=q(a.Kc,a),d=q(a.of,a),e=a.id+":"+Pe++;a.Oa=new we(e,a.O,b,c,d,function(b){z(b+" ("+a.O.toString()+")");a.Db=!1})}}h.qb=function(){this.Db=!1;this.Oa?this.Oa.close():(this.Kb&&(clearTimeout(this.Kb),this.Kb=null),this.ja&&this.of())};
h.ic=function(){this.Db=!0;this.Wa=1E3;this.Oa||Oe(this,0)};function $e(a,b,c){c=c?Ja(c,function(a){return xb(a)}).join("$"):"default";(a=Se(a,b,c))&&a.H&&a.H("permission_denied")}function Se(a,b,c){b=(new S(b)).toString();var d;m(a.ta[b])?(d=a.ta[b][c],delete a.ta[b][c],0===Jb(a.ta[b])&&delete a.ta[b]):d=void 0;return d}
function af(a){Te(a);A(a.ta,function(b,d){A(b,function(b,c){Re(a,d,c,b)})});for(var b=0;b<a.la.length;b++)a.la[b]&&Ze(a,b);for(;a.Jc.length;)b=a.Jc.shift(),Ve(a,b.action,b.Pc,b.data,b.H)};function cf(){this.m=this.F=null}cf.prototype.ec=function(a,b){if(a.e())this.F=b,this.m=null;else if(null!==this.F)this.F=this.F.D(a,b);else{null==this.m&&(this.m=new ie);var c=I(a);this.m.contains(c)||this.m.add(c,new cf);c=this.m.get(c);a=T(a);c.ec(a,b)}};
function df(a,b){if(b.e())return a.F=null,a.m=null,!0;if(null!==a.F){if(a.F.M())return!1;var c=a.F;a.F=null;c.U(L,function(b,c){a.ec(new S(b),c)});return df(a,b)}return null!==a.m?(c=I(b),b=T(b),a.m.contains(c)&&df(a.m.get(c),b)&&a.m.remove(c),a.m.e()?(a.m=null,!0):!1):!0}function ef(a,b,c){null!==a.F?c(b,a.F):a.U(function(a,e){var f=new S(b.toString()+"/"+a);ef(e,f,c)})}cf.prototype.U=function(a){null!==this.m&&je(this.m,function(b,c){a(b,c)})};function ff(){this.Od=M}ff.prototype.j=function(a){return this.Od.ra(a)};ff.prototype.toString=function(){return this.Od.toString()};function gf(){this.ob=[]}function hf(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.Rb();null===c||f.aa(c.Rb())||(a.ob.push(c),c=null);null===c&&(c=new jf(f));c.add(e)}c&&a.ob.push(c)}function Sc(a,b,c){hf(a,c);kf(a,function(a){return a.aa(b)})}function lf(a,b,c){hf(a,c);kf(a,function(a){return a.contains(b)||b.contains(a)})}
function kf(a,b){for(var c=!0,d=0;d<a.ob.length;d++){var e=a.ob[d];if(e)if(e=e.Rb(),b(e)){for(var e=a.ob[d],f=0;f<e.ld.length;f++){var g=e.ld[f];if(null!==g){e.ld[f]=null;var k=g.Mb();lb&&hb("event: "+g.toString());Cb(k)}}a.ob[d]=null}else c=!1}c&&(a.ob=[])}function jf(a){this.Ea=a;this.ld=[]}jf.prototype.add=function(a){this.ld.push(a)};jf.prototype.Rb=function(){return this.Ea};var mf="auth.firebase.com";function nf(a,b,c){this.cd=a||{};this.Zd=b||{};this.Xa=c||{};this.cd.remember||(this.cd.remember="default")}var of=["remember","redirectTo"];function pf(a){var b={},c={};ua(a||{},function(a,e){0<=Ga(of,a)?b[a]=e:c[a]=e});return new nf(b,{},c)};var qf={NETWORK_ERROR:"Unable to contact the Firebase server.",SERVER_ERROR:"An unknown server error occurred.",TRANSPORT_UNAVAILABLE:"There are no login transports available for the requested method.",REQUEST_INTERRUPTED:"The browser redirected the page before the login request could complete.",USER_CANCELLED:"The user cancelled authentication."};function X(a){var b=Error(t(qf,a),a);b.code=a;return b};function rf(){var a=window.opener.frames,b;for(b=a.length-1;0<=b;b--)try{if(a[b].location.protocol===window.location.protocol&&a[b].location.host===window.location.host&&"__winchan_relay_frame"===a[b].name)return a[b]}catch(c){}return null}function sf(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,!1)}function tf(a,b,c){a.detachEvent?a.detachEvent("on"+b,c):a.removeEventListener&&a.removeEventListener(b,c,!1)}
function uf(a){/^https?:\/\//.test(a)||(a=window.location.href);var b=/^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);return b?b[1]:a}function vf(a){var b="";try{a=a.replace("#","");var c={},d=a.replace(/^\?/,"").split("&");for(a=0;a<d.length;a++)if(d[a]){var e=d[a].split("=");c[e[0]]=e[1]}c&&s(c,"__firebase_request_key")&&(b=t(c,"__firebase_request_key"))}catch(f){}return b}
function wf(a){var b=[],c;for(c in a)if(s(a,c)){var d=t(a,c);if(ea(d))for(var e=0;e<d.length;e++)b.push(encodeURIComponent(c)+"="+encodeURIComponent(d[e]));else b.push(encodeURIComponent(c)+"="+encodeURIComponent(t(a,c)))}return b?"&"+b.join("&"):""}function xf(){var a=rb(mf);return a.scheme+"://"+a.host+"/v2"}function yf(a){return xf()+"/"+a+"/auth/channel"};function zf(){return!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(navigator.userAgent)}function Af(){var a=navigator.userAgent;if("Microsoft Internet Explorer"===navigator.appName){if((a=a.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1])}else if(-1<a.indexOf("Trident")&&(a=a.match(/rv:([0-9]{2,2}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1]);return!1};function Bf(a){a.method||(a.method="GET");a.headers||(a.headers={});a.headers.content_type||(a.headers.content_type="application/json");a.headers.content_type=a.headers.content_type.toLowerCase();this.options=a}
Bf.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}var e=new XMLHttpRequest,f=this.options.method.toUpperCase(),g;sf(window,"beforeunload",d);e.onreadystatechange=function(){if(c&&4===e.readyState){var a;if(200<=e.status&&300>e.status){try{a=ta(e.responseText)}catch(b){}c(null,a)}else 500<=e.status&&600>e.status?c(X("SERVER_ERROR")):c(X("NETWORK_ERROR"));c=null;tf(window,"beforeunload",d)}};if("GET"===f)a+=(/\?/.test(a)?"":"?")+wf(b),g=null;else{var k=this.options.headers.content_type;
"application/json"===k&&(g=r(b));"application/x-www-form-urlencoded"===k&&(g=wf(b))}e.open(f,a,!0);a={"X-Requested-With":"XMLHttpRequest",Accept:"application/json;text/plain"};Sd(a,this.options.headers);for(var l in a)e.setRequestHeader(l,a[l]);e.send(g)};Bf.isAvailable=function(){return!!window.XMLHttpRequest&&"string"===typeof(new XMLHttpRequest).responseType&&(!(navigator.userAgent.match(/MSIE/)||navigator.userAgent.match(/Trident/))||Af())};Bf.prototype.tc=function(){return"json"};function Cf(a){this.gc=Fa()+Fa()+Fa();this.pf=a}
Cf.prototype.open=function(a,b,c){function d(){c&&(c(X("USER_CANCELLED")),c=null)}var e=this,f=rb(mf),g;b.requestId=this.gc;b.redirectTo=f.scheme+"://"+f.host+"/blank/page.html";a+=/\?/.test(a)?"":"?";a+=wf(b);(g=window.open(a,"_blank","location=no"))&&ha(g.addEventListener)?(g.addEventListener("loadstart",function(a){var b;if(b=a&&a.url)a:{var n=a.url;try{var u=document.createElement("a");u.href=n;b=u.host===f.host&&"/blank/page.html"===u.pathname;break a}catch(x){}b=!1}b&&(a=vf(a.url),g.removeEventListener("exit",
d),g.close(),a=new nf(null,null,{requestId:e.gc,requestKey:a}),e.pf.requestWithCredential("/auth/session",a,c),c=null)}),g.addEventListener("exit",d)):c(X("TRANSPORT_UNAVAILABLE"))};Cf.isAvailable=function(){return zf()};Cf.prototype.tc=function(){return"redirect"};function Df(a){if(!a.window_features||-1!==navigator.userAgent.indexOf("Fennec/")||-1!==navigator.userAgent.indexOf("Firefox/")&&-1!==navigator.userAgent.indexOf("Android"))a.window_features=void 0;a.window_name||(a.window_name="_blank");this.options=a}
Df.prototype.open=function(a,b,c){function d(a){g&&(document.body.removeChild(g),g=void 0);u&&(u=clearInterval(u));tf(window,"message",e);tf(window,"unload",d);if(n&&!a)try{n.close()}catch(b){k.postMessage("die",l)}n=k=void 0}function e(a){if(a.origin===l)try{var b=ta(a.data);"ready"===b.a?k.postMessage(x,l):"error"===b.a?(d(!1),c&&(c(b.d),c=null)):"response"===b.a&&(d(b.forceKeepWindowOpen),c&&(c(null,b.d),c=null))}catch(e){}}var f=Af(),g,k;if(!this.options.relay_url)return c(Error("invalid arguments: origin of url and relay_url must match"));
var l=uf(a);if(l!==uf(this.options.relay_url))c&&setTimeout(function(){c(Error("invalid arguments: origin of url and relay_url must match"))},0);else{f&&(g=document.createElement("iframe"),g.setAttribute("src",this.options.relay_url),g.style.display="none",g.setAttribute("name","__winchan_relay_frame"),document.body.appendChild(g),k=g.contentWindow);a+=(/\?/.test(a)?"":"?")+wf(b);var n=window.open(a,this.options.window_name,this.options.window_features);k||(k=n);var u=setInterval(function(){n&&n.closed&&
(d(!1),c&&(c(X("USER_CANCELLED")),c=null))},500),x=r({a:"request",d:b});sf(window,"unload",d);sf(window,"message",e)}};
Df.isAvailable=function(){return"postMessage"in window&&!/^file:\//.test(location.href)&&!(zf()||navigator.userAgent.match(/Windows Phone/)||window.Windows&&/^ms-appx:/.test(location.href)||navigator.userAgent.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)||navigator.userAgent.match(/CriOS/)||navigator.userAgent.match(/Twitter for iPhone/)||navigator.userAgent.match(/FBAN\/FBIOS/)||window.navigator.standalone)&&!navigator.userAgent.match(/PhantomJS/)};Df.prototype.tc=function(){return"popup"};function Ef(a){a.callback_parameter||(a.callback_parameter="callback");this.options=a;window.__firebase_auth_jsonp=window.__firebase_auth_jsonp||{}}
Ef.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}function e(){setTimeout(function(){window.__firebase_auth_jsonp[f]=void 0;Pd(window.__firebase_auth_jsonp)&&(window.__firebase_auth_jsonp=void 0);try{var a=document.getElementById(f);a&&a.parentNode.removeChild(a)}catch(b){}},1);tf(window,"beforeunload",d)}var f="fn"+(new Date).getTime()+Math.floor(99999*Math.random());b[this.options.callback_parameter]="__firebase_auth_jsonp."+f;a+=(/\?/.test(a)?"":"?")+wf(b);
sf(window,"beforeunload",d);window.__firebase_auth_jsonp[f]=function(a){c&&(c(null,a),c=null);e()};Ff(f,a,c)};
function Ff(a,b,c){setTimeout(function(){try{var d=document.createElement("script");d.type="text/javascript";d.id=a;d.async=!0;d.src=b;d.onerror=function(){var b=document.getElementById(a);null!==b&&b.parentNode.removeChild(b);c&&c(X("NETWORK_ERROR"))};var e=document.getElementsByTagName("head");(e&&0!=e.length?e[0]:document.documentElement).appendChild(d)}catch(f){c&&c(X("NETWORK_ERROR"))}},0)}Ef.isAvailable=function(){return!zf()};Ef.prototype.tc=function(){return"json"};function Gf(a,b){this.Ke=["session",a.Id,a.ub].join(":");this.Wd=b}Gf.prototype.set=function(a,b){if(!b)if(this.Wd.length)b=this.Wd[0];else throw Error("fb.login.SessionManager : No storage options available!");b.set(this.Ke,a)};Gf.prototype.get=function(){var a=Ja(this.Wd,q(this.Zf,this)),a=Ia(a,function(a){return null!==a});Qa(a,function(a,c){return Ke(c.token)-Ke(a.token)});return 0<a.length?a.shift():null};Gf.prototype.Zf=function(a){try{var b=a.get(this.Ke);if(b&&b.token)return b}catch(c){}return null};
Gf.prototype.clear=function(){var a=this;Ha(this.Wd,function(b){b.remove(a.Ke)})};function Hf(a){this.gc=Fa()+Fa()+Fa();this.pf=a}Hf.prototype.open=function(a,b){v.set("redirect_request_id",this.gc);v.set("redirect_request_id",this.gc);b.requestId=this.gc;b.redirectTo=b.redirectTo||window.location.href;a+=(/\?/.test(a)?"":"?")+wf(b);window.location=a};Hf.isAvailable=function(){return!/^file:\//.test(location.href)&&!zf()};Hf.prototype.tc=function(){return"redirect"};function If(a,b,c,d){Id.call(this,["auth_status"]);this.O=a;this.Xe=b;this.Dg=c;this.Fe=d;this.jc=new Gf(a,[za,v]);this.ib=null;Jf(this)}ma(If,Id);h=If.prototype;h.re=function(){return this.ib||null};function Jf(a){v.get("redirect_request_id")&&Kf(a);var b=a.jc.get();b&&b.token?(Lf(a,b),a.Xe(b.token,function(c,d){Mf(a,c,d,!1,b.token,b)},function(b,d){Nf(a,"resumeSession()",b,d)})):Lf(a,null)}
function Of(a,b,c,d,e,f){"firebaseio-demo.com"===a.O.domain&&z("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");a.Xe(b,function(f,k){Mf(a,f,k,!0,b,c,d||{},e)},function(b,c){Nf(a,"auth()",b,c,f)})}function Pf(a,b){a.jc.clear();Lf(a,null);a.Dg(function(a,d){if("ok"===a)B(b,null);else{var e=(a||"error").toUpperCase(),f=e;d&&(f+=": "+d);f=Error(f);f.code=e;B(b,f)}})}
function Mf(a,b,c,d,e,f,g,k){"ok"===b?(d&&(b=c.auth,f.auth=b,f.expires=c.expires,f.token=Le(e)?e:"",c=null,b&&s(b,"uid")?c=t(b,"uid"):s(f,"uid")&&(c=t(f,"uid")),f.uid=c,c="custom",b&&s(b,"provider")?c=t(b,"provider"):s(f,"provider")&&(c=t(f,"provider")),f.provider=c,a.jc.clear(),Le(e)&&(g=g||{},c=za,"sessionOnly"===g.remember&&(c=v),"none"!==g.remember&&a.jc.set(f,c)),Lf(a,f)),B(k,null,f)):(a.jc.clear(),Lf(a,null),f=a=(b||"error").toUpperCase(),c&&(f+=": "+c),f=Error(f),f.code=a,B(k,f))}
function Nf(a,b,c,d,e){z(b+" was canceled: "+d);a.jc.clear();Lf(a,null);a=Error(d);a.code=c.toUpperCase();B(e,a)}function Qf(a,b,c,d,e){Rf(a);c=new nf(d||{},{},c||{});Sf(a,[Bf,Ef],"/auth/"+b,c,e)}
function Tf(a,b,c,d){Rf(a);var e=[Df,Cf];c=pf(c);"anonymous"===b||"password"===b?setTimeout(function(){B(d,X("TRANSPORT_UNAVAILABLE"))},0):(c.Zd.window_features="menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top="+("object"===typeof screen?.5*(screen.height-625):0)+",left="+("object"===typeof screen?.5*(screen.width-625):0),c.Zd.relay_url=yf(a.O.ub),c.Zd.requestWithCredential=q(a.hc,a),Sf(a,e,"/auth/"+b,c,d))}
function Kf(a){var b=v.get("redirect_request_id");if(b){var c=v.get("redirect_client_options");v.remove("redirect_request_id");v.remove("redirect_client_options");var d=[Bf,Ef],b={requestId:b,requestKey:vf(document.location.hash)},c=new nf(c,{},b);try{document.location.hash=document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/,"")}catch(e){}Sf(a,d,"/auth/session",c)}}h.ne=function(a,b){Rf(this);var c=pf(a);c.Xa._method="POST";this.hc("/users",c,function(a,c){a?B(b,a):B(b,a,c)})};
h.Me=function(a,b){var c=this;Rf(this);var d="/users/"+encodeURIComponent(a.email),e=pf(a);e.Xa._method="DELETE";this.hc(d,e,function(a,d){!a&&d&&d.uid&&c.ib&&c.ib.uid&&c.ib.uid===d.uid&&Pf(c);B(b,a)})};h.je=function(a,b){Rf(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=pf(a);d.Xa._method="PUT";d.Xa.password=a.newPassword;this.hc(c,d,function(a){B(b,a)})};
h.ie=function(a,b){Rf(this);var c="/users/"+encodeURIComponent(a.oldEmail)+"/email",d=pf(a);d.Xa._method="PUT";d.Xa.email=a.newEmail;d.Xa.password=a.password;this.hc(c,d,function(a){B(b,a)})};h.Ne=function(a,b){Rf(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=pf(a);d.Xa._method="POST";this.hc(c,d,function(a){B(b,a)})};h.hc=function(a,b,c){Uf(this,[Bf,Ef],a,b,c)};
function Sf(a,b,c,d,e){Uf(a,b,c,d,function(b,c){!b&&c&&c.token&&c.uid?Of(a,c.token,c,d.cd,function(a,b){a?B(e,a):B(e,null,b)}):B(e,b||X("UNKNOWN_ERROR"))})}
function Uf(a,b,c,d,e){b=Ia(b,function(a){return"function"===typeof a.isAvailable&&a.isAvailable()});0===b.length?setTimeout(function(){B(e,X("TRANSPORT_UNAVAILABLE"))},0):(b=new (b.shift())(d.Zd),d=va(d.Xa),d.v="js-2.2.0",d.transport=b.tc(),d.suppress_status_codes=!0,a=xf()+"/"+a.O.ub+c,b.open(a,d,function(a,b){if(a)B(e,a);else if(b&&b.error){var c=Error(b.error.message);c.code=b.error.code;c.details=b.error.details;B(e,c)}else B(e,null,b)}))}
function Lf(a,b){var c=null!==a.ib||null!==b;a.ib=b;c&&a.$d("auth_status",b);a.Fe(null!==b)}h.ue=function(a){y("auth_status"===a,'initial event must be of type "auth_status"');return[this.ib]};function Rf(a){var b=a.O;if("firebaseio.com"!==b.domain&&"firebaseio-demo.com"!==b.domain&&"auth.firebase.com"===mf)throw Error("This custom Firebase server ('"+a.O.domain+"') does not support delegated login.");};function Vf(a,b){return a&&"object"===typeof a?(y(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function Wf(a,b){var c=new cf;ef(a,new S(""),function(a,e){c.ec(a,Xf(e,b))});return c}function Xf(a,b){var c=a.L().I(),c=Vf(c,b),d;if(a.M()){var e=Vf(a.za(),b);return e!==a.za()||c!==a.L().I()?new qd(e,O(c)):a}d=a;c!==a.L().I()&&(d=d.$(new qd(c)));a.U(L,function(a,c){var e=Xf(c,b);e!==c&&(d=d.P(a,e))});return d};function Yf(a,b){this.value=a;this.children=b||Zf}var Zf=new bd(function(a,b){return a===b?0:a<b?-1:1}),$f=new Yf(null);function ag(a){var b=$f;A(a,function(a,d){b=b.set(new S(d),a)});return b}h=Yf.prototype;h.e=function(){return null===this.value&&this.children.e()};function bg(a,b,c){if(null!=a.value&&c(a.value))return{path:U,value:a.value};if(b.e())return null;var d=I(b);a=a.children.get(d);return null!==a?(b=bg(a,T(b),c),null!=b?{path:(new S(d)).u(b.path),value:b.value}:null):null}
function cg(a,b){return bg(a,b,function(){return!0})}h.subtree=function(a){if(a.e())return this;var b=this.children.get(I(a));return null!==b?b.subtree(T(a)):$f};h.set=function(a,b){if(a.e())return new Yf(b,this.children);var c=I(a),d=(this.children.get(c)||$f).set(T(a),b),c=this.children.La(c,d);return new Yf(this.value,c)};
h.remove=function(a){if(a.e())return this.children.e()?$f:new Yf(null,this.children);var b=I(a),c=this.children.get(b);return c?(a=c.remove(T(a)),b=a.e()?this.children.remove(b):this.children.La(b,a),null===this.value&&b.e()?$f:new Yf(this.value,b)):this};h.get=function(a){if(a.e())return this.value;var b=this.children.get(I(a));return b?b.get(T(a)):null};
function dg(a,b,c){if(b.e())return c;var d=I(b);b=dg(a.children.get(d)||$f,T(b),c);d=b.e()?a.children.remove(d):a.children.La(d,b);return new Yf(a.value,d)}function eg(a,b){return fg(a,U,b)}function fg(a,b,c){var d={};a.children.fa(function(a,f){d[a]=fg(f,b.u(a),c)});return c(b,a.value,d)}function gg(a,b,c){return hg(a,b,U,c)}function hg(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=I(b);return(a=a.children.get(e))?hg(a,T(b),c.u(e),d):null}
function ig(a,b,c){if(!b.e()){var d=!0;a.value&&(d=c(U,a.value));!0===d&&(d=I(b),(a=a.children.get(d))&&jg(a,T(b),U.u(d),c))}}function jg(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=I(b);return(a=a.children.get(e))?jg(a,T(b),c.u(e),d):$f}function kg(a,b){lg(a,U,b)}function lg(a,b,c){a.children.fa(function(a,e){lg(e,b.u(a),c)});a.value&&c(b,a.value)}function mg(a,b){a.children.fa(function(a,d){d.value&&b(a,d.value)})}
h.toString=function(){var a={};kg(this,function(b,c){a[b.toString()]=c.toString()});return r(a)};function ng(a,b){this.ce=a;this.Of=b}function og(a){this.G=a}
og.prototype.Ya=function(a,b,c,d){var e=new Bc,f;if(b.type===pg)b.source.qe?c=qg(this,a,b.path,b.Ga,c,d,e):(y(b.source.ef,"Unknown source."),f=b.source.Te,c=rg(this,a,b.path,b.Ga,c,d,f,e));else if(b.type===sg)b.source.qe?c=tg(this,a,b.path,b.children,c,d,e):(y(b.source.ef,"Unknown source."),f=b.source.Te,c=ug(this,a,b.path,b.children,c,d,f,e));else if(b.type===vg)if(b.Oe)if(f=b.path,null!=c.kc(f))c=a;else{b=new xc(c,a,d);d=a.B.j();if(f.e()||".priority"===I(f))wg(a.o())?b=c.pa(Ac(a)):(b=a.o().j(),
y(b instanceof W,"serverChildren would be complete if leaf node"),b=c.qc(b)),b=this.G.oa(d,b,e);else{f=I(f);var g=c.Ta(f,a.o());null==g&&yc(a.o(),f)&&(g=d.K(f));b=null!=g?this.G.D(d,f,g,b,e):a.B.j().Da(f)?this.G.D(d,f,M,b,e):d;b.e()&&wg(a.o())&&(d=c.pa(Ac(a)),d.M()&&(b=this.G.oa(b,d,e)))}d=wg(a.o())||null!=c.kc(U);c=xg(a,b,d,this.G.Ca())}else c=yg(this,a,b.path,c,d,e);else if(b.type===zg)d=b.path,b=a.o(),f=b.j(),g=b.Z||d.e(),c=Ag(this,new Bg(a.B,new zc(f,g,b.Lb)),d,c,wc,e);else throw fb("Unknown operation type: "+
b.type);e=Ld(e.Za);d=c;b=d.B;b.Z&&(f=b.j().M()||b.j().e(),g=Cg(a),(0<e.length||!a.B.Z||f&&!b.j().aa(g)||!b.j().L().aa(g.L()))&&e.push(Fb(Cg(d))));return new ng(c,e)};
function Ag(a,b,c,d,e,f){var g=b.B;if(null!=d.kc(c))return b;var k;if(c.e())y(wg(b.o()),"If change path is empty, we must have complete server data"),b.o().Lb?(e=Ac(b),d=d.qc(e instanceof W?e:M)):d=d.pa(Ac(b)),f=a.G.oa(b.B.j(),d,f);else{var l=I(c);if(".priority"==l)y(1==Tc(c),"Can't have a priority with additional path components"),f=g.j(),k=b.o().j(),d=d.$c(c,f,k),f=null!=d?a.G.$(f,d):g.j();else{var n=T(c);yc(g,l)?(k=b.o().j(),d=d.$c(c,g.j(),k),d=null!=d?g.j().K(l).D(n,d):g.j().K(l)):d=d.Ta(l,b.o());
f=null!=d?a.G.D(g.j(),l,d,e,f):g.j()}}return xg(b,f,g.Z||c.e(),a.G.Ca())}function rg(a,b,c,d,e,f,g,k){var l=b.o();g=g?a.G:a.G.Nb();if(c.e())d=g.oa(l.j(),d,null);else if(g.Ca()&&!l.Lb)d=l.j().D(c,d),d=g.oa(l.j(),d,null);else{var n=I(c);if((c.e()?!l.Z||l.Lb:!yc(l,I(c)))&&1<Tc(c))return b;d=l.j().K(n).D(T(c),d);d=".priority"==n?g.$(l.j(),d):g.D(l.j(),n,d,wc,null)}l=l.Z||c.e();b=new Bg(b.B,new zc(d,l,g.Ca()));return Ag(a,b,c,e,new xc(e,b,f),k)}
function qg(a,b,c,d,e,f,g){var k=b.B;e=new xc(e,b,f);if(c.e())g=a.G.oa(b.B.j(),d,g),a=xg(b,g,!0,a.G.Ca());else if(f=I(c),".priority"===f)g=a.G.$(b.B.j(),d),a=xg(b,g,k.Z,k.Lb);else{var l=T(c);c=k.j().K(f);if(!l.e()){var n=e.ff(f);d=null!=n?".priority"===Uc(l)&&n.ra(l.parent()).e()?n:n.D(l,d):M}c.aa(d)?a=b:(g=a.G.D(k.j(),f,d,e,g),a=xg(b,g,k.Z,a.G.Ca()))}return a}
function tg(a,b,c,d,e,f,g){var k=b;kg(d,function(d,n){var u=c.u(d);yc(b.B,I(u))&&(k=qg(a,k,u,n,e,f,g))});kg(d,function(d,n){var u=c.u(d);yc(b.B,I(u))||(k=qg(a,k,u,n,e,f,g))});return k}function Dg(a,b){kg(b,function(b,d){a=a.D(b,d)});return a}
function ug(a,b,c,d,e,f,g,k){if(b.o().j().e()&&!wg(b.o()))return b;var l=b;c=c.e()?d:dg($f,c,d);var n=b.o().j();c.children.fa(function(c,d){if(n.Da(c)){var F=b.o().j().K(c),F=Dg(F,d);l=rg(a,l,new S(c),F,e,f,g,k)}});c.children.fa(function(c,d){var F=!wg(b.o())&&null==d.value;n.Da(c)||F||(F=b.o().j().K(c),F=Dg(F,d),l=rg(a,l,new S(c),F,e,f,g,k))});return l}
function yg(a,b,c,d,e,f){if(null!=d.kc(c))return b;var g=new xc(d,b,e),k=e=b.B.j();if(wg(b.o())){if(c.e())e=d.pa(Ac(b)),k=a.G.oa(b.B.j(),e,f);else if(".priority"===I(c)){var l=d.Ta(I(c),b.o());null==l||e.e()||e.L().aa(l)||(k=a.G.$(e,l))}else l=I(c),e=d.Ta(l,b.o()),null!=e&&(k=a.G.D(b.B.j(),l,e,g,f));e=!0}else if(b.B.Z||c.e())k=e,e=b.B.j(),e.M()||e.U(L,function(c){var e=d.Ta(c,b.o());null!=e&&(k=a.G.D(k,c,e,g,f))}),e=b.B.Z;else{l=I(c);if(1==Tc(c)||yc(b.B,l))c=d.Ta(l,b.o()),null!=c&&(k=a.G.D(e,l,c,
g,f));e=!1}return xg(b,k,e,a.G.Ca())};function Eg(a){this.W=a;this.g=a.n.g}function Fg(a,b,c,d){var e=[],f=[];Ha(b,function(b){"child_changed"===b.type&&a.g.we(b.Ee,b.Ha)&&f.push(new C("child_moved",b.Ha,b.Ua))});Gg(a,e,"child_removed",b,d,c);Gg(a,e,"child_added",b,d,c);Gg(a,e,"child_moved",f,d,c);Gg(a,e,"child_changed",b,d,c);Gg(a,e,Gb,b,d,c);return e}function Gg(a,b,c,d,e,f){d=Ia(d,function(a){return a.type===c});Qa(d,q(a.Qf,a));Ha(d,function(c){var d=Hg(a,c,f);Ha(e,function(e){e.wf(c.type)&&b.push(e.createEvent(d,a.W))})})}
function Hg(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Kd=c.gf(b.Ua,b.Ha,a.g));return b}Eg.prototype.Qf=function(a,b){if(null==a.Ua||null==b.Ua)throw fb("Should only compare child_ events.");return this.g.compare(new N(a.Ua,a.Ha),new N(b.Ua,b.Ha))};function zc(a,b,c){this.A=a;this.Z=b;this.Lb=c}function wg(a){return a.Z}function yc(a,b){return a.Z&&!a.Lb||a.A.Da(b)}zc.prototype.j=function(){return this.A};function Bg(a,b){this.B=a;this.Qd=b}function xg(a,b,c,d){return new Bg(new zc(b,c,d),a.Qd)}function Cg(a){return a.B.Z?a.B.j():null}Bg.prototype.o=function(){return this.Qd};function Ac(a){return a.Qd.Z?a.Qd.j():null};function Ig(a,b){this.W=a;var c=a.n,d=new bc(c.g),c=Mc(c)?new bc(c.g):c.ka?new Dc(c):new dc(c);this.sf=new og(c);var e=b.o(),f=b.B,g=d.oa(M,e.j(),null),k=c.oa(M,f.j(),null);this.Ia=new Bg(new zc(k,f.Z,c.Ca()),new zc(g,e.Z,d.Ca()));this.Va=[];this.Uf=new Eg(a)}function Jg(a){return a.W}h=Ig.prototype;h.o=function(){return this.Ia.o().j()};h.bb=function(a){var b=Ac(this.Ia);return b&&(Mc(this.W.n)||!a.e()&&!b.K(I(a)).e())?b.ra(a):null};h.e=function(){return 0===this.Va.length};h.Gb=function(a){this.Va.push(a)};
h.gb=function(a,b){var c=[];if(b){y(null==a,"A cancel should cancel all event registrations.");var d=this.W.path;Ha(this.Va,function(a){(a=a.Ze(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.Va.length;++f){var g=this.Va[f];if(!g.matches(a))e.push(g);else if(a.jf()){e=e.concat(this.Va.slice(f+1));break}}this.Va=e}else this.Va=[];return c};
h.Ya=function(a,b,c){a.type===sg&&null!==a.source.zb&&(y(Ac(this.Ia),"We should always have a full cache before handling merges"),y(Cg(this.Ia),"Missing event cache, even though we have a server cache"));var d=this.Ia;a=this.sf.Ya(d,a,b,c);b=this.sf;c=a.ce;y(c.B.j().Bc(b.G.g),"Event snap not indexed");y(c.o().j().Bc(b.G.g),"Server snap not indexed");y(wg(a.ce.o())||!wg(d.o()),"Once a server snap is complete, it should never go back");this.Ia=a.ce;return Kg(this,a.Of,a.ce.B.j(),null)};
function Lg(a,b){var c=a.Ia.B,d=[];c.j().M()||c.j().U(L,function(a,b){d.push(new C("child_added",b,a))});c.Z&&d.push(Fb(c.j()));return Kg(a,d,c.j(),b)}function Kg(a,b,c,d){return Fg(a.Uf,b,c,d?[d]:a.Va)};function Mg(){this.wa={}}h=Mg.prototype;h.e=function(){return Pd(this.wa)};h.Ya=function(a,b,c){var d=a.source.zb;if(null!==d)return d=t(this.wa,d),y(null!=d,"SyncTree gave us an op for an invalid query."),d.Ya(a,b,c);var e=[];A(this.wa,function(d){e=e.concat(d.Ya(a,b,c))});return e};h.Gb=function(a,b,c,d,e){var f=a.Fa(),g=t(this.wa,f);if(!g){var g=c.pa(e?d:null),k=!1;g?k=!0:(g=d instanceof W?c.qc(d):M,k=!1);g=new Ig(a,new Bg(new zc(g,k,!1),new zc(d,e,!1)));this.wa[f]=g}g.Gb(b);return Lg(g,b)};
h.gb=function(a,b,c){var d=a.Fa(),e=[],f=[],g=null!=Ng(this);if("default"===d){var k=this;A(this.wa,function(a,d){f=f.concat(a.gb(b,c));a.e()&&(delete k.wa[d],Mc(a.W.n)||e.push(a.W))})}else{var l=t(this.wa,d);l&&(f=f.concat(l.gb(b,c)),l.e()&&(delete this.wa[d],Mc(l.W.n)||e.push(l.W)))}g&&null==Ng(this)&&e.push(new R(a.k,a.path));return{sg:e,Vf:f}};function Og(a){return Ia(Ld(a.wa),function(a){return!Mc(a.W.n)})}h.bb=function(a){var b=null;A(this.wa,function(c){b=b||c.bb(a)});return b};
function Pg(a,b){if(Mc(b.n))return Ng(a);var c=b.Fa();return t(a.wa,c)}function Ng(a){return Od(a.wa,function(a){return Mc(a.W.n)})||null};function Qg(a){this.X=a}var Rg=new Qg(new Yf(null));function Sg(a,b,c){if(b.e())return new Qg(new Yf(c));var d=cg(a.X,b);if(null!=d){var e=d.path,d=d.value;b=V(e,b);d=d.D(b,c);return new Qg(a.X.set(e,d))}a=dg(a.X,b,new Yf(c));return new Qg(a)}function Tg(a,b,c){var d=a;ua(c,function(a,c){d=Sg(d,b.u(a),c)});return d}Qg.prototype.Ld=function(a){if(a.e())return Rg;a=dg(this.X,a,$f);return new Qg(a)};function Ug(a,b){var c=cg(a.X,b);return null!=c?a.X.get(c.path).ra(V(c.path,b)):null}
function Vg(a){var b=[],c=a.X.value;null!=c?c.M()||c.U(L,function(a,c){b.push(new N(a,c))}):a.X.children.fa(function(a,c){null!=c.value&&b.push(new N(a,c.value))});return b}function Wg(a,b){if(b.e())return a;var c=Ug(a,b);return null!=c?new Qg(new Yf(c)):new Qg(a.X.subtree(b))}Qg.prototype.e=function(){return this.X.e()};Qg.prototype.apply=function(a){return Xg(U,this.X,a)};
function Xg(a,b,c){if(null!=b.value)return c.D(a,b.value);var d=null;b.children.fa(function(b,f){".priority"===b?(y(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=Xg(a.u(b),f,c)});c.ra(a).e()||null===d||(c=c.D(a.u(".priority"),d));return c};function Yg(){this.T=Rg;this.xa=[];this.Ec=-1}h=Yg.prototype;
h.Ld=function(a){var b=Na(this.xa,function(b){return b.de===a});y(0<=b,"removeWrite called with nonexistent writeId.");var c=this.xa[b];this.xa.splice(b,1);for(var d=c.visible,e=!1,f=this.xa.length-1;d&&0<=f;){var g=this.xa[f];g.visible&&(f>=b&&Zg(g,c.path)?d=!1:c.path.contains(g.path)&&(e=!0));f--}if(d){if(e)this.T=$g(this.xa,ah,U),this.Ec=0<this.xa.length?this.xa[this.xa.length-1].de:-1;else if(c.Ga)this.T=this.T.Ld(c.path);else{var k=this;A(c.children,function(a,b){k.T=k.T.Ld(c.path.u(b))})}return c.path}return null};
h.pa=function(a,b,c,d){if(c||d){var e=Wg(this.T,a);return!d&&e.e()?b:d||null!=b||null!=Ug(e,U)?(e=$g(this.xa,function(b){return(b.visible||d)&&(!c||!(0<=Ga(c,b.de)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||M,e.apply(b)):null}e=Ug(this.T,a);if(null!=e)return e;e=Wg(this.T,a);return e.e()?b:null!=b||null!=Ug(e,U)?(b=b||M,e.apply(b)):null};
h.qc=function(a,b){var c=M,d=Ug(this.T,a);if(d)d.M()||d.U(L,function(a,b){c=c.P(a,b)});else if(b){var e=Wg(this.T,a);b.U(L,function(a,b){var d=Wg(e,new S(a)).apply(b);c=c.P(a,d)});Ha(Vg(e),function(a){c=c.P(a.name,a.V)})}else e=Wg(this.T,a),Ha(Vg(e),function(a){c=c.P(a.name,a.V)});return c};h.$c=function(a,b,c,d){y(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.u(b);if(null!=Ug(this.T,a))return null;a=Wg(this.T,a);return a.e()?d.ra(b):a.apply(d.ra(b))};
h.Ta=function(a,b,c){a=a.u(b);var d=Ug(this.T,a);return null!=d?d:yc(c,b)?Wg(this.T,a).apply(c.j().K(b)):null};h.kc=function(a){return Ug(this.T,a)};h.he=function(a,b,c,d,e,f){var g;a=Wg(this.T,a);g=Ug(a,U);if(null==g)if(null!=b)g=a.apply(b);else return[];g=g.hb(f);if(g.e()||g.M())return[];b=[];a=mc(f);e=e?g.Sb(c,f):g.Qb(c,f);for(f=P(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=P(e);return b};
function Zg(a,b){return a.Ga?a.path.contains(b):!!Nd(a.children,function(c,d){return a.path.u(d).contains(b)})}function ah(a){return a.visible}
function $g(a,b,c){for(var d=Rg,e=0;e<a.length;++e){var f=a[e];if(b(f)){var g=f.path;if(f.Ga)c.contains(g)?(g=V(c,g),d=Sg(d,g,f.Ga)):g.contains(c)&&(g=V(g,c),d=Sg(d,U,f.Ga.ra(g)));else if(f.children)if(c.contains(g))g=V(c,g),d=Tg(d,g,f.children);else{if(g.contains(c))if(g=V(g,c),g.e())d=Tg(d,U,f.children);else if(f=t(f.children,I(g)))f=f.ra(T(g)),d=Sg(d,U,f)}else throw fb("WriteRecord should have .snap or .children");}}return d}function bh(a,b){this.Eb=a;this.X=b}h=bh.prototype;
h.pa=function(a,b,c){return this.X.pa(this.Eb,a,b,c)};h.qc=function(a){return this.X.qc(this.Eb,a)};h.$c=function(a,b,c){return this.X.$c(this.Eb,a,b,c)};h.kc=function(a){return this.X.kc(this.Eb.u(a))};h.he=function(a,b,c,d,e){return this.X.he(this.Eb,a,b,c,d,e)};h.Ta=function(a,b){return this.X.Ta(this.Eb,a,b)};h.u=function(a){return new bh(this.Eb.u(a),this.X)};function ch(a,b,c){this.type=pg;this.source=a;this.path=b;this.Ga=c}ch.prototype.Mc=function(a){return this.path.e()?new ch(this.source,U,this.Ga.K(a)):new ch(this.source,T(this.path),this.Ga)};ch.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ga.toString()+")"};function dh(a,b){this.type=vg;this.source=eh;this.path=a;this.Oe=b}dh.prototype.Mc=function(){return this.path.e()?this:new dh(T(this.path),this.Oe)};dh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Oe+")"};function fh(a,b){this.type=zg;this.source=a;this.path=b}fh.prototype.Mc=function(){return this.path.e()?new fh(this.source,U):new fh(this.source,T(this.path))};fh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function gh(a,b,c){this.type=sg;this.source=a;this.path=b;this.children=c}gh.prototype.Mc=function(a){if(this.path.e())return a=this.children.subtree(new S(a)),a.e()?null:a.value?new ch(this.source,U,a.value):new gh(this.source,U,a);y(I(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new gh(this.source,T(this.path),this.children)};gh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};var pg=0,sg=1,vg=2,zg=3;function hh(a,b,c,d){this.qe=a;this.ef=b;this.zb=c;this.Te=d;y(!d||b,"Tagged queries must be from server.")}var eh=new hh(!0,!1,null,!1),ih=new hh(!1,!0,null,!1);hh.prototype.toString=function(){return this.qe?"user":this.Te?"server(queryID="+this.zb+")":"server"};function jh(a){this.na=$f;this.yb=new Yg;this.Wc={};this.cc={};this.Fc=a}function kh(a,b,c,d,e){var f=a.yb,g=e;y(d>f.Ec,"Stacking an older write on top of newer ones");m(g)||(g=!0);f.xa.push({path:b,Ga:c,de:d,visible:g});g&&(f.T=Sg(f.T,b,c));f.Ec=d;return e?lh(a,new ch(eh,b,c)):[]}function mh(a,b,c,d){var e=a.yb;y(d>e.Ec,"Stacking an older merge on top of newer ones");e.xa.push({path:b,children:c,de:d,visible:!0});e.T=Tg(e.T,b,c);e.Ec=d;c=ag(c);return lh(a,new gh(eh,b,c))}
function nh(a,b,c){c=c||!1;b=a.yb.Ld(b);return null==b?[]:lh(a,new dh(b,c))}function oh(a,b,c){c=ag(c);return lh(a,new gh(ih,b,c))}function ph(a,b,c,d){d=Qd(a.Wc,"_"+d);if(null!=d){var e=qh(d);d=e.path;e=e.zb;b=V(d,b);c=new ch(new hh(!1,!0,e,!0),b,c);return rh(a,d,c)}return[]}function sh(a,b,c,d){if(d=Qd(a.Wc,"_"+d)){var e=qh(d);d=e.path;e=e.zb;b=V(d,b);c=ag(c);c=new gh(new hh(!1,!0,e,!0),b,c);return rh(a,d,c)}return[]}
jh.prototype.Gb=function(a,b){var c=a.path,d=null,e=!1;ig(this.na,c,function(a,b){var f=V(a,c);d=b.bb(f);e=e||null!=Ng(b);return!d});var f=this.na.get(c);f?(e=e||null!=Ng(f),d=d||f.bb(U)):(f=new Mg,this.na=this.na.set(c,f));var g;null!=d?g=!0:(g=!1,d=M,mg(this.na.subtree(c),function(a,b){var c=b.bb(U);c&&(d=d.P(a,c))}));var k=null!=Pg(f,a);if(!k&&!Mc(a.n)){var l=th(a);y(!(l in this.cc),"View does not exist, but we have a tag");var n=uh++;this.cc[l]=n;this.Wc["_"+n]=l}g=f.Gb(a,b,new bh(c,this.yb),
d,g);k||e||(f=Pg(f,a),g=g.concat(vh(this,a,f)));return g};
jh.prototype.gb=function(a,b,c){var d=a.path,e=this.na.get(d),f=[];if(e&&("default"===a.Fa()||null!=Pg(e,a))){f=e.gb(a,b,c);e.e()&&(this.na=this.na.remove(d));e=f.sg;f=f.Vf;b=-1!==Na(e,function(a){return Mc(a.n)});var g=gg(this.na,d,function(a,b){return null!=Ng(b)});if(b&&!g&&(d=this.na.subtree(d),!d.e()))for(var d=wh(d),k=0;k<d.length;++k){var l=d[k],n=l.W,l=xh(this,l);this.Fc.Qe(n,yh(this,n),l.nd,l.H)}if(!g&&0<e.length&&!c)if(b)this.Fc.Vd(a,null);else{var u=this;Ha(e,function(a){a.Fa();var b=u.cc[th(a)];
u.Fc.Vd(a,b)})}zh(this,e)}return f};jh.prototype.pa=function(a,b){var c=this.yb,d=gg(this.na,a,function(b,c){var d=V(b,a);if(d=c.bb(d))return d});return c.pa(a,d,b,!0)};function wh(a){return eg(a,function(a,c,d){if(c&&null!=Ng(c))return[Ng(c)];var e=[];c&&(e=Og(c));A(d,function(a){e=e.concat(a)});return e})}function zh(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!Mc(d.n)){var d=th(d),e=a.cc[d];delete a.cc[d];delete a.Wc["_"+e]}}}
function vh(a,b,c){var d=b.path,e=yh(a,b);c=xh(a,c);b=a.Fc.Qe(b,e,c.nd,c.H);d=a.na.subtree(d);if(e)y(null==Ng(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=eg(d,function(a,b,c){if(!a.e()&&b&&null!=Ng(b))return[Jg(Ng(b))];var d=[];b&&(d=d.concat(Ja(Og(b),function(a){return a.W})));A(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Fc.Vd(c,yh(a,c));return b}
function xh(a,b){var c=b.W,d=yh(a,c);return{nd:function(){return(b.o()||M).hash()},H:function(b,f){if("ok"===b){if(f&&"object"===typeof f&&s(f,"w")){var g=t(f,"w");ea(g)&&0<=Ga(g,"no_index")&&z("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}if(d){var k=c.path;if(g=Qd(a.Wc,"_"+d))var l=qh(g),g=l.path,l=l.zb,k=V(g,k),k=new fh(new hh(!1,!0,l,!0),k),g=rh(a,g,k);else g=[]}else g=lh(a,new fh(ih,
c.path));return g}g="Unknown Error";"too_big"===b?g="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?g="Client doesn't have permission to access the desired data.":"unavailable"==b&&(g="The service is unavailable");g=Error(b+": "+g);g.code=b.toUpperCase();return a.gb(c,null,g)}}}function th(a){return a.path.toString()+"$"+a.Fa()}
function qh(a){var b=a.indexOf("$");y(-1!==b&&b<a.length-1,"Bad queryKey.");return{zb:a.substr(b+1),path:new S(a.substr(0,b))}}function yh(a,b){var c=th(b);return t(a.cc,c)}var uh=1;function rh(a,b,c){var d=a.na.get(b);y(d,"Missing sync point for query tag that we're tracking");return d.Ya(c,new bh(b,a.yb),null)}function lh(a,b){return Ah(a,b,a.na,null,new bh(U,a.yb))}
function Ah(a,b,c,d,e){if(b.path.e())return Bh(a,b,c,d,e);var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[],k=I(b.path),l=b.Mc(k);if((c=c.children.get(k))&&l)var n=d?d.K(k):null,k=e.u(k),g=g.concat(Ah(a,l,c,n,k));f&&(g=g.concat(f.Ya(b,e,d)));return g}function Bh(a,b,c,d,e){var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[];c.children.fa(function(c,f){var n=d?d.K(c):null,u=e.u(c),x=b.Mc(c);x&&(g=g.concat(Bh(a,x,f,n,u)))});f&&(g=g.concat(f.Ya(b,e,d)));return g};function Ch(a){this.O=a;this.Ra=Zd(a);this.ba=new gf;this.Ad=1;this.S=new Me(this.O,q(this.Dd,this),q(this.Bd,this),q(this.Ie,this));this.Ag=$d(a,q(function(){return new Wd(this.Ra,this.S)},this));this.mc=new Wc;this.xe=new ff;var b=this;this.rd=new jh({Qe:function(a,d,e,f){d=[];e=b.xe.j(a.path);e.e()||(d=lh(b.rd,new ch(ih,a.path,e)),setTimeout(function(){f("ok")},0));return d},Vd:ba});Dh(this,"connected",!1);this.ga=new cf;this.Q=new If(a,q(this.S.Q,this.S),q(this.S.Ve,this.S),q(this.Fe,this));this.hd=
0;this.ye=null;this.N=new jh({Qe:function(a,d,e,f){Qe(b.S,a,e,d,function(d,e){var l=f(d,e);lf(b.ba,a.path,l)});return[]},Vd:function(a,d){var e=b.S,f=a.path.toString(),g=a.Fa();e.f("Unlisten called for "+f+" "+g);if(Se(e,f,g)&&e.ja){var k=Lc(a.n);e.f("Unlisten on "+f+" for "+g);f={p:f};d&&(f.q=k,f.t=d);e.Ba("n",f)}}})}h=Ch.prototype;h.toString=function(){return(this.O.Bb?"https://":"http://")+this.O.host};h.name=function(){return this.O.ub};
function Eh(a){a=a.xe.j(new S(".info/serverTimeOffset")).I()||0;return(new Date).getTime()+a}function Fh(a){a=a={timestamp:Eh(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}h.Dd=function(a,b,c,d){this.hd++;var e=new S(a);b=this.ye?this.ye(a,b):b;a=[];d?c?(b=wd(b,function(a){return O(a)}),a=sh(this.N,e,b,d)):(b=O(b),a=ph(this.N,e,b,d)):c?(d=wd(b,function(a){return O(a)}),a=oh(this.N,e,d)):(d=O(b),a=lh(this.N,new ch(ih,e,d)));d=e;0<a.length&&(d=Gh(this,e));lf(this.ba,d,a)};
h.Bd=function(a){Dh(this,"connected",a);!1===a&&Hh(this)};h.Ie=function(a){var b=this;zb(a,function(a,d){Dh(b,d,a)})};h.Fe=function(a){Dh(this,"authenticated",a)};function Dh(a,b,c){b=new S("/.info/"+b);c=O(c);var d=a.xe;d.Od=d.Od.D(b,c);c=lh(a.rd,new ch(ih,b,c));lf(a.ba,b,c)}
h.Cb=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,Ig:c});var e=Fh(this);b=O(b,c);var e=Xf(b,e),f=this.Ad++,e=kh(this.N,a,e,f,!0);hf(this.ba,e);var g=this;this.S.put(a.toString(),b.I(!0),function(b,c){var e="ok"===b;e||z("set at "+a+" failed: "+b);e=nh(g.N,f,!e);lf(g.ba,a,e);Ih(d,b,c)});e=Jh(this,a);Gh(this,e);lf(this.ba,e,[])};
h.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=Fh(this),f={};A(b,function(a,b){d=!1;var c=O(a);f[b]=Xf(c,e)});if(d)hb("update() called with empty data.  Don't do anything."),Ih(c,"ok");else{var g=this.Ad++,k=mh(this.N,a,f,g);hf(this.ba,k);var l=this;Ye(this.S,a.toString(),b,function(b,d){y("ok"===b||"permission_denied"===b,"merge at "+a+" failed.");var e="ok"===b;e||z("update at "+a+" failed: "+b);var e=nh(l.N,g,!e),f=a;0<e.length&&(f=Gh(l,a));lf(l.ba,f,e);Ih(c,b,
d)});b=Jh(this,a);Gh(this,b);lf(this.ba,a,[])}};function Hh(a){a.f("onDisconnectEvents");var b=Fh(a),c=[];ef(Wf(a.ga,b),U,function(b,e){c=c.concat(lh(a.N,new ch(ih,b,e)));var f=Jh(a,b);Gh(a,f)});a.ga=new cf;lf(a.ba,U,c)}h.Ge=function(a,b){var c=this;this.S.Ge(a.toString(),function(d,e){"ok"===d&&df(c.ga,a);Ih(b,d,e)})};function Kh(a,b,c,d){var e=O(c);Ue(a.S,b.toString(),e.I(!0),function(c,g){"ok"===c&&a.ga.ec(b,e);Ih(d,c,g)})}
function Lh(a,b,c,d,e){var f=O(c,d);Ue(a.S,b.toString(),f.I(!0),function(c,d){"ok"===c&&a.ga.ec(b,f);Ih(e,c,d)})}function Mh(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(hb("onDisconnect().update() called with empty data.  Don't do anything."),Ih(d,"ok")):We(a.S,b.toString(),c,function(e,f){if("ok"===e)for(var l in c){var n=O(c[l]);a.ga.ec(b.u(l),n)}Ih(d,e,f)})}function Rc(a,b,c){c=".info"===I(b.path)?a.rd.Gb(b,c):a.N.Gb(b,c);Sc(a.ba,b.path,c)}h.qb=function(){this.S.qb()};h.ic=function(){this.S.ic()};
h.Re=function(a){if("undefined"!==typeof console){a?(this.Ud||(this.Ud=new Vd(this.Ra)),a=this.Ud.get()):a=this.Ra.get();var b=Ka(Md(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};h.Se=function(a){Ud(this.Ra,a);this.Ag.zf[a]=!0};h.f=function(a){hb("r:"+this.S.id+":",arguments)};function Ih(a,b,c){a&&Cb(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function Nh(a,b,c,d,e){function f(){}a.f("transaction on "+b);var g=new R(a,b);g.wb("value",f);c={path:b,update:c,H:d,status:null,qf:eb(),We:e,xf:0,be:function(){g.$b("value",f)},ee:null,ya:null,ed:null,fd:null,gd:null};d=a.N.pa(b,void 0)||M;c.ed=d;d=c.update(d.I());if(m(d)){Sb("transaction failed: Data returned ",d);c.status=1;e=Xc(a.mc,b);var k=e.za()||[];k.push(c);Yc(e,k);"object"===typeof d&&null!==d&&s(d,".priority")?(k=t(d,".priority"),y(Qb(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.N.pa(b)||M).L().I();e=Fh(a);d=O(d,k);e=Xf(d,e);c.fd=d;c.gd=e;c.ya=a.Ad++;c=kh(a.N,b,e,c.ya,c.We);lf(a.ba,b,c);Oh(a)}else c.be(),c.fd=null,c.gd=null,c.H&&(a=new D(c.ed,new R(a,c.path),L),c.H(null,!1,a))}function Oh(a,b){var c=b||a.mc;b||Ph(a,c);if(null!==c.za()){var d=Qh(a,c);y(0<d.length,"Sending zero length transaction queue");La(d,function(a){return 1===a.status})&&Rh(a,c.path(),d)}else c.md()&&c.U(function(b){Oh(a,b)})}
function Rh(a,b,c){for(var d=Ja(c,function(a){return a.ya}),e=a.N.pa(b,d)||M,d=e,e=e.hash(),f=0;f<c.length;f++){var g=c[f];y(1===g.status,"tryToSendTransactionQueue_: items in queue should all be run.");g.status=2;g.xf++;var k=V(b,g.path),d=d.D(k,g.fd)}d=d.I(!0);a.S.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(nh(a.N,c[f].ya));if(c[f].H){var g=c[f].gd,k=new R(a,c[f].path);d.push(q(c[f].H,
null,null,!0,new D(g,k,L)))}c[f].be()}Ph(a,Xc(a.mc,b));Oh(a);lf(a.ba,b,e);for(f=0;f<d.length;f++)Cb(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(z("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].ee=d;Gh(a,b)}},e)}function Gh(a,b){var c=Sh(a,b),d=c.path(),c=Qh(a,c);Th(a,c,d);return d}
function Th(a,b,c){if(0!==b.length){for(var d=[],e=[],f=Ja(b,function(a){return a.ya}),g=0;g<b.length;g++){var k=b[g],l=V(c,k.path),n=!1,u;y(null!==l,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)n=!0,u=k.ee,e=e.concat(nh(a.N,k.ya,!0));else if(1===k.status)if(25<=k.xf)n=!0,u="maxretry",e=e.concat(nh(a.N,k.ya,!0));else{var x=a.N.pa(k.path,f)||M;k.ed=x;var F=b[g].update(x.I());m(F)?(Sb("transaction failed: Data returned ",F),l=O(F),"object"===typeof F&&null!=F&&s(F,
".priority")||(l=l.$(x.L())),x=k.ya,F=Fh(a),F=Xf(l,F),k.fd=l,k.gd=F,k.ya=a.Ad++,Oa(f,x),e=e.concat(kh(a.N,k.path,F,k.ya,k.We)),e=e.concat(nh(a.N,x,!0))):(n=!0,u="nodata",e=e.concat(nh(a.N,k.ya,!0)))}lf(a.ba,c,e);e=[];n&&(b[g].status=3,setTimeout(b[g].be,Math.floor(0)),b[g].H&&("nodata"===u?(k=new R(a,b[g].path),d.push(q(b[g].H,null,null,!1,new D(b[g].ed,k,L)))):d.push(q(b[g].H,null,Error(u),!1,null))))}Ph(a,a.mc);for(g=0;g<d.length;g++)Cb(d[g]);Oh(a)}}
function Sh(a,b){for(var c,d=a.mc;null!==(c=I(b))&&null===d.za();)d=Xc(d,c),b=T(b);return d}function Qh(a,b){var c=[];Uh(a,b,c);c.sort(function(a,b){return a.qf-b.qf});return c}function Uh(a,b,c){var d=b.za();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.U(function(b){Uh(a,b,c)})}function Ph(a,b){var c=b.za();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;Yc(b,0<c.length?c:null)}b.U(function(b){Ph(a,b)})}
function Jh(a,b){var c=Sh(a,b).path(),d=Xc(a.mc,b);ad(d,function(b){Vh(a,b)});Vh(a,d);$c(d,function(b){Vh(a,b)});return c}
function Vh(a,b){var c=b.za();if(null!==c){for(var d=[],e=[],f=-1,g=0;g<c.length;g++)4!==c[g].status&&(2===c[g].status?(y(f===g-1,"All SENT items should be at beginning of queue."),f=g,c[g].status=4,c[g].ee="set"):(y(1===c[g].status,"Unexpected transaction status in abort"),c[g].be(),e=e.concat(nh(a.N,c[g].ya,!0)),c[g].H&&d.push(q(c[g].H,null,Error("set"),!1,null))));-1===f?Yc(b,null):c.length=f+1;lf(a.ba,b.path(),e);for(g=0;g<d.length;g++)Cb(d[g])}};function Wh(){this.fc={}}ca(Wh);Wh.prototype.qb=function(){for(var a in this.fc)this.fc[a].qb()};Wh.prototype.interrupt=Wh.prototype.qb;Wh.prototype.ic=function(){for(var a in this.fc)this.fc[a].ic()};Wh.prototype.resume=Wh.prototype.ic;function Xh(a){var b=this;this.sc=a;this.Xd="*";Af()?this.Hc=this.pd=rf():(this.Hc=window.opener,this.pd=window);if(!b.Hc)throw"Unable to find relay frame";sf(this.pd,"message",q(this.ac,this));sf(this.pd,"message",q(this.nf,this));try{Yh(this,{a:"ready"})}catch(c){sf(this.Hc,"load",function(){Yh(b,{a:"ready"})})}sf(window,"unload",q(this.jg,this))}function Yh(a,b){b=r(b);Af()?a.Hc.doPost(b,a.Xd):a.Hc.postMessage(b,a.Xd)}
Xh.prototype.ac=function(a){var b=this,c;try{c=ta(a.data)}catch(d){}c&&"request"===c.a&&(tf(window,"message",this.ac),this.Xd=a.origin,this.sc&&setTimeout(function(){b.sc(b.Xd,c.d,function(a,c){b.Mf=!c;b.sc=void 0;Yh(b,{a:"response",d:a,forceKeepWindowOpen:c})})},0))};Xh.prototype.jg=function(){try{tf(this.pd,"message",this.nf)}catch(a){}this.sc&&(Yh(this,{a:"error",d:"unknown closed window"}),this.sc=void 0);try{window.close()}catch(b){}};Xh.prototype.nf=function(a){if(this.Mf&&"die"===a.data)try{window.close()}catch(b){}};var Y={Xf:function(){le=ce=!0}};Y.forceLongPolling=Y.Xf;Y.Yf=function(){me=!0};Y.forceWebSockets=Y.Yf;Y.xg=function(a,b){a.k.S.Pe=b};Y.setSecurityDebugCallback=Y.xg;Y.Re=function(a,b){a.k.Re(b)};Y.stats=Y.Re;Y.Se=function(a,b){a.k.Se(b)};Y.statsIncrementCounter=Y.Se;Y.hd=function(a){return a.k.hd};Y.dataUpdateCount=Y.hd;Y.ag=function(a,b){a.k.ye=b};Y.interceptServerData=Y.ag;Y.gg=function(a){new Xh(a)};Y.onPopupOpen=Y.gg;Y.vg=function(a){mf=a};Y.setAuthenticationServer=Y.vg;function Z(a,b){this.Rc=a;this.Ea=b}Z.prototype.cancel=function(a){E("Firebase.onDisconnect().cancel",0,1,arguments.length);H("Firebase.onDisconnect().cancel",1,a,!0);this.Rc.Ge(this.Ea,a||null)};Z.prototype.cancel=Z.prototype.cancel;Z.prototype.remove=function(a){E("Firebase.onDisconnect().remove",0,1,arguments.length);Zb("Firebase.onDisconnect().remove",this.Ea);H("Firebase.onDisconnect().remove",1,a,!0);Kh(this.Rc,this.Ea,null,a)};Z.prototype.remove=Z.prototype.remove;
Z.prototype.set=function(a,b){E("Firebase.onDisconnect().set",1,2,arguments.length);Zb("Firebase.onDisconnect().set",this.Ea);Rb("Firebase.onDisconnect().set",a,!1);H("Firebase.onDisconnect().set",2,b,!0);Kh(this.Rc,this.Ea,a,b)};Z.prototype.set=Z.prototype.set;
Z.prototype.Cb=function(a,b,c){E("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);Zb("Firebase.onDisconnect().setWithPriority",this.Ea);Rb("Firebase.onDisconnect().setWithPriority",a,!1);Vb("Firebase.onDisconnect().setWithPriority",2,b);H("Firebase.onDisconnect().setWithPriority",3,c,!0);Lh(this.Rc,this.Ea,a,b,c)};Z.prototype.setWithPriority=Z.prototype.Cb;
Z.prototype.update=function(a,b){E("Firebase.onDisconnect().update",1,2,arguments.length);Zb("Firebase.onDisconnect().update",this.Ea);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.onDisconnect().update",a);H("Firebase.onDisconnect().update",2,b,!0);Mh(this.Rc,
this.Ea,a,b)};Z.prototype.update=Z.prototype.update;var $={};$.oc=Me;$.DataConnection=$.oc;Me.prototype.zg=function(a,b){this.Ba("q",{p:a},b)};$.oc.prototype.simpleListen=$.oc.prototype.zg;Me.prototype.Sf=function(a,b){this.Ba("echo",{d:a},b)};$.oc.prototype.echo=$.oc.prototype.Sf;Me.prototype.interrupt=Me.prototype.qb;$.Df=we;$.RealTimeConnection=$.Df;we.prototype.sendRequest=we.prototype.Ba;we.prototype.close=we.prototype.close;
$.$f=function(a){var b=Me.prototype.put;Me.prototype.put=function(c,d,e,f){m(f)&&(f=a());b.call(this,c,d,e,f)};return function(){Me.prototype.put=b}};$.hijackHash=$.$f;$.Cf=Aa;$.ConnectionTarget=$.Cf;$.Fa=function(a){return a.Fa()};$.queryIdentifier=$.Fa;$.bg=function(a){return a.k.S.ta};$.listens=$.bg;var Zh=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);y(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);y(20===c.length,"NextPushId: Length should be 20.");
return c}}();function R(a,b){var c,d,e;if(a instanceof Ch)c=a,d=b;else{E("new Firebase",1,2,arguments.length);d=rb(arguments[0]);c=d.Bg;"firebase"===d.domain&&qb(d.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");c||qb("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d.Bb||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&z("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
c=new Aa(d.host,d.Bb,c,"ws"===d.scheme||"wss"===d.scheme);d=new S(d.Pc);e=d.toString();var f;!(f=!p(c.host)||0===c.host.length||!Pb(c.ub))&&(f=0!==e.length)&&(e&&(e=e.replace(/^\/*\.info(\/|$)/,"/")),f=!(p(e)&&0!==e.length&&!Ob.test(e)));if(f)throw Error(G("new Firebase",1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');if(b)if(b instanceof Wh)e=b;else if(p(b))e=Wh.Ob(),c.Id=b;else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()");
else e=Wh.Ob();f=c.toString();var g=t(e.fc,f);g||(g=new Ch(c),e.fc[f]=g);c=g}Q.call(this,c,d,Ic,!1)}ma(R,Q);var $h=R,ai=["Firebase"],bi=aa;ai[0]in bi||!bi.execScript||bi.execScript("var "+ai[0]);for(var ci;ai.length&&(ci=ai.shift());)!ai.length&&m($h)?bi[ci]=$h:bi=bi[ci]?bi[ci]:bi[ci]={};R.prototype.name=function(){z("Firebase.name() being deprecated. Please use Firebase.key() instead.");E("Firebase.name",0,0,arguments.length);return this.key()};R.prototype.name=R.prototype.name;
R.prototype.key=function(){E("Firebase.key",0,0,arguments.length);return this.path.e()?null:Uc(this.path)};R.prototype.key=R.prototype.key;R.prototype.u=function(a){E("Firebase.child",1,1,arguments.length);if(ga(a))a=String(a);else if(!(a instanceof S))if(null===I(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));Yb("Firebase.child",b)}else Yb("Firebase.child",a);return new R(this.k,this.path.u(a))};R.prototype.child=R.prototype.u;
R.prototype.parent=function(){E("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new R(this.k,a)};R.prototype.parent=R.prototype.parent;R.prototype.root=function(){E("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.parent();)a=a.parent();return a};R.prototype.root=R.prototype.root;
R.prototype.toString=function(){E("Firebase.toString",0,0,arguments.length);var a;if(null===this.parent())a=this.k.toString();else{a=this.parent().toString()+"/";var b=this.key();a+=encodeURIComponent(String(b))}return a};R.prototype.toString=R.prototype.toString;R.prototype.set=function(a,b){E("Firebase.set",1,2,arguments.length);Zb("Firebase.set",this.path);Rb("Firebase.set",a,!1);H("Firebase.set",2,b,!0);this.k.Cb(this.path,a,null,b||null)};R.prototype.set=R.prototype.set;
R.prototype.update=function(a,b){E("Firebase.update",1,2,arguments.length);Zb("Firebase.update",this.path);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.update",a);H("Firebase.update",2,b,!0);this.k.update(this.path,a,b||null)};R.prototype.update=R.prototype.update;
R.prototype.Cb=function(a,b,c){E("Firebase.setWithPriority",2,3,arguments.length);Zb("Firebase.setWithPriority",this.path);Rb("Firebase.setWithPriority",a,!1);Vb("Firebase.setWithPriority",2,b);H("Firebase.setWithPriority",3,c,!0);if(".length"===this.key()||".keys"===this.key())throw"Firebase.setWithPriority failed: "+this.key()+" is a read-only object.";this.k.Cb(this.path,a,b,c||null)};R.prototype.setWithPriority=R.prototype.Cb;
R.prototype.remove=function(a){E("Firebase.remove",0,1,arguments.length);Zb("Firebase.remove",this.path);H("Firebase.remove",1,a,!0);this.set(null,a)};R.prototype.remove=R.prototype.remove;
R.prototype.transaction=function(a,b,c){E("Firebase.transaction",1,3,arguments.length);Zb("Firebase.transaction",this.path);H("Firebase.transaction",1,a,!1);H("Firebase.transaction",2,b,!0);if(m(c)&&"boolean"!=typeof c)throw Error(G("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.key()||".keys"===this.key())throw"Firebase.transaction failed: "+this.key()+" is a read-only object.";"undefined"===typeof c&&(c=!0);Nh(this.k,this.path,a,b||null,c)};R.prototype.transaction=R.prototype.transaction;
R.prototype.wg=function(a,b){E("Firebase.setPriority",1,2,arguments.length);Zb("Firebase.setPriority",this.path);Vb("Firebase.setPriority",1,a);H("Firebase.setPriority",2,b,!0);this.k.Cb(this.path.u(".priority"),a,null,b)};R.prototype.setPriority=R.prototype.wg;R.prototype.push=function(a,b){E("Firebase.push",0,2,arguments.length);Zb("Firebase.push",this.path);Rb("Firebase.push",a,!0);H("Firebase.push",2,b,!0);var c=Eh(this.k),c=Zh(c),c=this.u(c);"undefined"!==typeof a&&null!==a&&c.set(a,b);return c};
R.prototype.push=R.prototype.push;R.prototype.fb=function(){Zb("Firebase.onDisconnect",this.path);return new Z(this.k,this.path)};R.prototype.onDisconnect=R.prototype.fb;R.prototype.Q=function(a,b,c){z("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");E("Firebase.auth",1,3,arguments.length);$b("Firebase.auth",a);H("Firebase.auth",2,b,!0);H("Firebase.auth",3,b,!0);Of(this.k.Q,a,{},{remember:"none"},b,c)};R.prototype.auth=R.prototype.Q;
R.prototype.Ve=function(a){E("Firebase.unauth",0,1,arguments.length);H("Firebase.unauth",1,a,!0);Pf(this.k.Q,a)};R.prototype.unauth=R.prototype.Ve;R.prototype.re=function(){E("Firebase.getAuth",0,0,arguments.length);return this.k.Q.re()};R.prototype.getAuth=R.prototype.re;R.prototype.fg=function(a,b){E("Firebase.onAuth",1,2,arguments.length);H("Firebase.onAuth",1,a,!1);Mb("Firebase.onAuth",2,b);this.k.Q.wb("auth_status",a,b)};R.prototype.onAuth=R.prototype.fg;
R.prototype.eg=function(a,b){E("Firebase.offAuth",1,2,arguments.length);H("Firebase.offAuth",1,a,!1);Mb("Firebase.offAuth",2,b);this.k.Q.$b("auth_status",a,b)};R.prototype.offAuth=R.prototype.eg;R.prototype.Hf=function(a,b,c){E("Firebase.authWithCustomToken",2,3,arguments.length);$b("Firebase.authWithCustomToken",a);H("Firebase.authWithCustomToken",2,b,!1);J("Firebase.authWithCustomToken",3,c,!0);Of(this.k.Q,a,{},c||{},b)};R.prototype.authWithCustomToken=R.prototype.Hf;
R.prototype.If=function(a,b,c){E("Firebase.authWithOAuthPopup",2,3,arguments.length);ac("Firebase.authWithOAuthPopup",1,a);H("Firebase.authWithOAuthPopup",2,b,!1);J("Firebase.authWithOAuthPopup",3,c,!0);Tf(this.k.Q,a,c,b)};R.prototype.authWithOAuthPopup=R.prototype.If;
R.prototype.Jf=function(a,b,c){E("Firebase.authWithOAuthRedirect",2,3,arguments.length);ac("Firebase.authWithOAuthRedirect",1,a);H("Firebase.authWithOAuthRedirect",2,b,!1);J("Firebase.authWithOAuthRedirect",3,c,!0);var d=this.k.Q;Rf(d);var e=[Hf],f=pf(c);"anonymous"===a||"firebase"===a?B(b,X("TRANSPORT_UNAVAILABLE")):(v.set("redirect_client_options",f.cd),Sf(d,e,"/auth/"+a,f,b))};R.prototype.authWithOAuthRedirect=R.prototype.Jf;
R.prototype.Kf=function(a,b,c,d){E("Firebase.authWithOAuthToken",3,4,arguments.length);ac("Firebase.authWithOAuthToken",1,a);H("Firebase.authWithOAuthToken",3,c,!1);J("Firebase.authWithOAuthToken",4,d,!0);p(b)?(ac("Firebase.authWithOAuthToken",2,b),Qf(this.k.Q,a+"/token",{access_token:b},d,c)):(J("Firebase.authWithOAuthToken",2,b,!1),Qf(this.k.Q,a+"/token",b,d,c))};R.prototype.authWithOAuthToken=R.prototype.Kf;
R.prototype.Gf=function(a,b){E("Firebase.authAnonymously",1,2,arguments.length);H("Firebase.authAnonymously",1,a,!1);J("Firebase.authAnonymously",2,b,!0);Qf(this.k.Q,"anonymous",{},b,a)};R.prototype.authAnonymously=R.prototype.Gf;
R.prototype.Lf=function(a,b,c){E("Firebase.authWithPassword",2,3,arguments.length);J("Firebase.authWithPassword",1,a,!1);K("Firebase.authWithPassword",a,"email");K("Firebase.authWithPassword",a,"password");H("Firebase.authAnonymously",2,b,!1);J("Firebase.authAnonymously",3,c,!0);Qf(this.k.Q,"password",a,c,b)};R.prototype.authWithPassword=R.prototype.Lf;
R.prototype.ne=function(a,b){E("Firebase.createUser",2,2,arguments.length);J("Firebase.createUser",1,a,!1);K("Firebase.createUser",a,"email");K("Firebase.createUser",a,"password");H("Firebase.createUser",2,b,!1);this.k.Q.ne(a,b)};R.prototype.createUser=R.prototype.ne;R.prototype.Me=function(a,b){E("Firebase.removeUser",2,2,arguments.length);J("Firebase.removeUser",1,a,!1);K("Firebase.removeUser",a,"email");K("Firebase.removeUser",a,"password");H("Firebase.removeUser",2,b,!1);this.k.Q.Me(a,b)};
R.prototype.removeUser=R.prototype.Me;R.prototype.je=function(a,b){E("Firebase.changePassword",2,2,arguments.length);J("Firebase.changePassword",1,a,!1);K("Firebase.changePassword",a,"email");K("Firebase.changePassword",a,"oldPassword");K("Firebase.changePassword",a,"newPassword");H("Firebase.changePassword",2,b,!1);this.k.Q.je(a,b)};R.prototype.changePassword=R.prototype.je;
R.prototype.ie=function(a,b){E("Firebase.changeEmail",2,2,arguments.length);J("Firebase.changeEmail",1,a,!1);K("Firebase.changeEmail",a,"oldEmail");K("Firebase.changeEmail",a,"newEmail");K("Firebase.changeEmail",a,"password");H("Firebase.changeEmail",2,b,!1);this.k.Q.ie(a,b)};R.prototype.changeEmail=R.prototype.ie;
R.prototype.Ne=function(a,b){E("Firebase.resetPassword",2,2,arguments.length);J("Firebase.resetPassword",1,a,!1);K("Firebase.resetPassword",a,"email");H("Firebase.resetPassword",2,b,!1);this.k.Q.Ne(a,b)};R.prototype.resetPassword=R.prototype.Ne;R.goOffline=function(){E("Firebase.goOffline",0,0,arguments.length);Wh.Ob().qb()};R.goOnline=function(){E("Firebase.goOnline",0,0,arguments.length);Wh.Ob().ic()};
function nb(a,b){y(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?lb=q(console.log,console):"object"===typeof console.log&&(lb=function(a){console.log(a)})),b&&v.set("logging_enabled",!0)):a?lb=a:(lb=null,v.remove("logging_enabled"))}R.enableLogging=nb;R.ServerValue={TIMESTAMP:{".sv":"timestamp"}};R.SDK_VERSION="2.2.0";R.INTERNAL=Y;R.Context=Wh;R.TEST_ACCESS=$;})();
module.exports = Firebase;

},{}],"/Users/luke/dev/040715/node_modules/mout/array.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'append' : require('./array/append'),
    'collect' : require('./array/collect'),
    'combine' : require('./array/combine'),
    'compact' : require('./array/compact'),
    'contains' : require('./array/contains'),
    'difference' : require('./array/difference'),
    'equals' : require('./array/equals'),
    'every' : require('./array/every'),
    'filter' : require('./array/filter'),
    'find' : require('./array/find'),
    'findIndex' : require('./array/findIndex'),
    'findLast' : require('./array/findLast'),
    'findLastIndex' : require('./array/findLastIndex'),
    'flatten' : require('./array/flatten'),
    'forEach' : require('./array/forEach'),
    'groupBy' : require('./array/groupBy'),
    'indexOf' : require('./array/indexOf'),
    'insert' : require('./array/insert'),
    'intersection' : require('./array/intersection'),
    'invoke' : require('./array/invoke'),
    'join' : require('./array/join'),
    'last' : require('./array/last'),
    'lastIndexOf' : require('./array/lastIndexOf'),
    'map' : require('./array/map'),
    'max' : require('./array/max'),
    'min' : require('./array/min'),
    'pick' : require('./array/pick'),
    'pluck' : require('./array/pluck'),
    'range' : require('./array/range'),
    'reduce' : require('./array/reduce'),
    'reduceRight' : require('./array/reduceRight'),
    'reject' : require('./array/reject'),
    'remove' : require('./array/remove'),
    'removeAll' : require('./array/removeAll'),
    'shuffle' : require('./array/shuffle'),
    'slice' : require('./array/slice'),
    'some' : require('./array/some'),
    'sort' : require('./array/sort'),
    'sortBy' : require('./array/sortBy'),
    'split' : require('./array/split'),
    'take' : require('./array/take'),
    'toLookup' : require('./array/toLookup'),
    'union' : require('./array/union'),
    'unique' : require('./array/unique'),
    'xor' : require('./array/xor'),
    'zip' : require('./array/zip')
};



},{"./array/append":"/Users/luke/dev/040715/node_modules/mout/array/append.js","./array/collect":"/Users/luke/dev/040715/node_modules/mout/array/collect.js","./array/combine":"/Users/luke/dev/040715/node_modules/mout/array/combine.js","./array/compact":"/Users/luke/dev/040715/node_modules/mout/array/compact.js","./array/contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./array/difference":"/Users/luke/dev/040715/node_modules/mout/array/difference.js","./array/equals":"/Users/luke/dev/040715/node_modules/mout/array/equals.js","./array/every":"/Users/luke/dev/040715/node_modules/mout/array/every.js","./array/filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./array/find":"/Users/luke/dev/040715/node_modules/mout/array/find.js","./array/findIndex":"/Users/luke/dev/040715/node_modules/mout/array/findIndex.js","./array/findLast":"/Users/luke/dev/040715/node_modules/mout/array/findLast.js","./array/findLastIndex":"/Users/luke/dev/040715/node_modules/mout/array/findLastIndex.js","./array/flatten":"/Users/luke/dev/040715/node_modules/mout/array/flatten.js","./array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","./array/groupBy":"/Users/luke/dev/040715/node_modules/mout/array/groupBy.js","./array/indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js","./array/insert":"/Users/luke/dev/040715/node_modules/mout/array/insert.js","./array/intersection":"/Users/luke/dev/040715/node_modules/mout/array/intersection.js","./array/invoke":"/Users/luke/dev/040715/node_modules/mout/array/invoke.js","./array/join":"/Users/luke/dev/040715/node_modules/mout/array/join.js","./array/last":"/Users/luke/dev/040715/node_modules/mout/array/last.js","./array/lastIndexOf":"/Users/luke/dev/040715/node_modules/mout/array/lastIndexOf.js","./array/map":"/Users/luke/dev/040715/node_modules/mout/array/map.js","./array/max":"/Users/luke/dev/040715/node_modules/mout/array/max.js","./array/min":"/Users/luke/dev/040715/node_modules/mout/array/min.js","./array/pick":"/Users/luke/dev/040715/node_modules/mout/array/pick.js","./array/pluck":"/Users/luke/dev/040715/node_modules/mout/array/pluck.js","./array/range":"/Users/luke/dev/040715/node_modules/mout/array/range.js","./array/reduce":"/Users/luke/dev/040715/node_modules/mout/array/reduce.js","./array/reduceRight":"/Users/luke/dev/040715/node_modules/mout/array/reduceRight.js","./array/reject":"/Users/luke/dev/040715/node_modules/mout/array/reject.js","./array/remove":"/Users/luke/dev/040715/node_modules/mout/array/remove.js","./array/removeAll":"/Users/luke/dev/040715/node_modules/mout/array/removeAll.js","./array/shuffle":"/Users/luke/dev/040715/node_modules/mout/array/shuffle.js","./array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./array/some":"/Users/luke/dev/040715/node_modules/mout/array/some.js","./array/sort":"/Users/luke/dev/040715/node_modules/mout/array/sort.js","./array/sortBy":"/Users/luke/dev/040715/node_modules/mout/array/sortBy.js","./array/split":"/Users/luke/dev/040715/node_modules/mout/array/split.js","./array/take":"/Users/luke/dev/040715/node_modules/mout/array/take.js","./array/toLookup":"/Users/luke/dev/040715/node_modules/mout/array/toLookup.js","./array/union":"/Users/luke/dev/040715/node_modules/mout/array/union.js","./array/unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js","./array/xor":"/Users/luke/dev/040715/node_modules/mout/array/xor.js","./array/zip":"/Users/luke/dev/040715/node_modules/mout/array/zip.js"}],"/Users/luke/dev/040715/node_modules/mout/array/append.js":[function(require,module,exports){


    /**
     * Appends an array to the end of another.
     * The first array will be modified.
     */
    function append(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var pad = arr1.length,
            i = -1,
            len = arr2.length;
        while (++i < len) {
            arr1[pad + i] = arr2[i];
        }
        return arr1;
    }
    module.exports = append;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/collect.js":[function(require,module,exports){
var append = require('./append');
var makeIterator = require('../function/makeIterator_');

    /**
     * Maps the items in the array and concatenates the result arrays.
     */
    function collect(arr, callback, thisObj){
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            var value = callback(arr[i], i, arr);
            if (value != null) {
                append(results, value);
            }
        }

        return results;
    }

    module.exports = collect;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./append":"/Users/luke/dev/040715/node_modules/mout/array/append.js"}],"/Users/luke/dev/040715/node_modules/mout/array/combine.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/compact.js":[function(require,module,exports){
var filter = require('./filter');

    /**
     * Remove all null/undefined items from array.
     */
    function compact(arr) {
        return filter(arr, function(val){
            return (val != null);
        });
    }

    module.exports = compact;


},{"./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/array/contains.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/difference.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./some":"/Users/luke/dev/040715/node_modules/mout/array/some.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/equals.js":[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./every":"/Users/luke/dev/040715/node_modules/mout/array/every.js"}],"/Users/luke/dev/040715/node_modules/mout/array/every.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/filter.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/find.js":[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":"/Users/luke/dev/040715/node_modules/mout/array/findIndex.js"}],"/Users/luke/dev/040715/node_modules/mout/array/findIndex.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/findLast.js":[function(require,module,exports){
var findLastIndex = require('./findLastIndex');

    /**
     * Returns last item that matches criteria
     */
    function findLast(arr, iterator, thisObj){
        var idx = findLastIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = findLast;



},{"./findLastIndex":"/Users/luke/dev/040715/node_modules/mout/array/findLastIndex.js"}],"/Users/luke/dev/040715/node_modules/mout/array/findLastIndex.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the last item that matches criteria
     */
    function findLastIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var n = arr.length;
        while (--n >= 0) {
            if (iterator(arr[n], n, arr)) {
                return n;
            }
        }

        return -1;
    }

    module.exports = findLastIndex;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/flatten.js":[function(require,module,exports){
var isArray = require('../lang/isArray');
var append = require('./append');

    /*
     * Helper function to flatten to a destination array.
     * Used to remove the need to create intermediate arrays while flattening.
     */
    function flattenTo(arr, result, level) {
        if (arr == null) {
            return result;
        } else if (level === 0) {
            append(result, arr);
            return result;
        }

        var value,
            i = -1,
            len = arr.length;
        while (++i < len) {
            value = arr[i];
            if (isArray(value)) {
                flattenTo(value, result, level - 1);
            } else {
                result.push(value);
            }
        }
        return result;
    }

    /**
     * Recursively flattens an array.
     * A new array containing all the elements is returned.
     * If `shallow` is true, it will only flatten one level.
     */
    function flatten(arr, level) {
        level = level == null? -1 : level;
        return flattenTo(arr, [], level);
    }

    module.exports = flatten;




},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./append":"/Users/luke/dev/040715/node_modules/mout/array/append.js"}],"/Users/luke/dev/040715/node_modules/mout/array/forEach.js":[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/groupBy.js":[function(require,module,exports){
var forEach = require('../array/forEach');
var identity = require('../function/identity');
var makeIterator = require('../function/makeIterator_');

    /**
     * Bucket the array values.
     */
    function groupBy(arr, categorize, thisObj) {
        if (categorize) {
            categorize = makeIterator(categorize, thisObj);
        } else {
            // Default to identity function.
            categorize = identity;
        }

        var buckets = {};
        forEach(arr, function(element) {
            var bucket = categorize(element);
            if (!(bucket in buckets)) {
                buckets[bucket] = [];
            }

            buckets[bucket].push(element);
        });

        return buckets;
    }

    module.exports = groupBy;


},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../function/identity":"/Users/luke/dev/040715/node_modules/mout/function/identity.js","../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js":[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/insert.js":[function(require,module,exports){
var difference = require('./difference');
var slice = require('./slice');

    /**
     * Insert item into array if not already present.
     */
    function insert(arr, rest_items) {
        var diff = difference(slice(arguments, 1), arr);
        if (diff.length) {
            Array.prototype.push.apply(arr, diff);
        }
        return arr.length;
    }
    module.exports = insert;


},{"./difference":"/Users/luke/dev/040715/node_modules/mout/array/difference.js","./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/array/intersection.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./every":"/Users/luke/dev/040715/node_modules/mout/array/every.js","./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/invoke.js":[function(require,module,exports){
var slice = require('./slice');

    /**
     * Call `methodName` on each item of the array passing custom arguments if
     * needed.
     */
    function invoke(arr, methodName, var_args){
        if (arr == null) {
            return arr;
        }

        var args = slice(arguments, 2);
        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            value[methodName].apply(value, args);
        }

        return arr;
    }

    module.exports = invoke;


},{"./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/array/join.js":[function(require,module,exports){
var filter = require('./filter');

    function isValidString(val) {
        return (val != null && val !== '');
    }

    /**
     * Joins strings with the specified separator inserted between each value.
     * Null values and empty strings will be excluded.
     */
    function join(items, separator) {
        separator = separator || '';
        return filter(items, isValidString).join(separator);
    }

    module.exports = join;


},{"./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/array/last.js":[function(require,module,exports){


    /**
     * Returns last element of array.
     */
    function last(arr){
        if (arr == null || arr.length < 1) {
            return undefined;
        }

        return arr[arr.length - 1];
    }

    module.exports = last;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/lastIndexOf.js":[function(require,module,exports){


    /**
     * Array lastIndexOf
     */
    function lastIndexOf(arr, item, fromIndex) {
        if (arr == null) {
            return -1;
        }

        var len = arr.length;
        fromIndex = (fromIndex == null || fromIndex >= len)? len - 1 : fromIndex;
        fromIndex = (fromIndex < 0)? len + fromIndex : fromIndex;

        while (fromIndex >= 0) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[fromIndex] === item) {
                return fromIndex;
            }
            fromIndex--;
        }

        return -1;
    }

    module.exports = lastIndexOf;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/map.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/max.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return maximum value inside array
     */
    function max(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return Infinity;
        } else if (arr.length && !iterator) {
            return Math.max.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = -Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp > compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = max;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/min.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return minimum value inside array
     */
    function min(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return -Infinity;
        } else if (arr.length && !iterator) {
            return Math.min.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp < compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = min;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/pick.js":[function(require,module,exports){
var randInt = require('../random/randInt');

    /**
     * Remove random item(s) from the Array and return it.
     * Returns an Array of items if [nItems] is provided or a single item if
     * it isn't specified.
     */
    function pick(arr, nItems){
        if (nItems != null) {
            var result = [];
            if (nItems > 0 && arr && arr.length) {
                nItems = nItems > arr.length? arr.length : nItems;
                while (nItems--) {
                    result.push( pickOne(arr) );
                }
            }
            return result;
        }
        return (arr && arr.length)? pickOne(arr) : void(0);
    }


    function pickOne(arr){
        var idx = randInt(0, arr.length - 1);
        return arr.splice(idx, 1)[0];
    }


    module.exports = pick;



},{"../random/randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/array/pluck.js":[function(require,module,exports){
var map = require('./map');

    /**
     * Extract a list of property values.
     */
    function pluck(arr, propName){
        return map(arr, propName);
    }

    module.exports = pluck;



},{"./map":"/Users/luke/dev/040715/node_modules/mout/array/map.js"}],"/Users/luke/dev/040715/node_modules/mout/array/range.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');

    /**
     * Returns an Array of numbers inside range.
     */
    function range(start, stop, step) {
        if (stop == null) {
            stop = start;
            start = 0;
        }
        step = step || 1;

        var result = [],
            nSteps = countSteps(stop - start, step),
            i = start;

        while (i <= stop) {
            result.push(i);
            i += step;
        }

        return result;
    }

    module.exports = range;



},{"../math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js"}],"/Users/luke/dev/040715/node_modules/mout/array/reduce.js":[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/reduceRight.js":[function(require,module,exports){


    /**
     * Array reduceRight
     */
    function reduceRight(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2;

        if (arr == null || !arr.length) {
            if (hasInit) {
                return initVal;
            } else {
                throw new Error('reduce of empty array with no initial value');
            }
        }

        var i = arr.length, result = initVal, value;
        while (--i >= 0) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            value = arr[i];
            if (!hasInit) {
                result = value;
                hasInit = true;
            } else {
                result = fn(result, value, i, arr);
            }
        }
        return result;
    }

    module.exports = reduceRight;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/reject.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array reject
     */
    function reject(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (!callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = reject;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/remove.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/removeAll.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove all instances of an item from array.
     */
    function removeAll(arr, item){
        var idx = indexOf(arr, item);
        while (idx !== -1) {
            arr.splice(idx, 1);
            idx = indexOf(arr, item, idx);
        }
    }

    module.exports = removeAll;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/shuffle.js":[function(require,module,exports){
var randInt = require('../random/randInt');

    /**
     * Shuffle array items.
     */
    function shuffle(arr) {
        var results = [],
            rnd;
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            if (!i) {
                results[0] = arr[0];
            } else {
                rnd = randInt(0, i);
                results[i] = results[rnd];
                results[rnd] = arr[i];
            }
        }

        return results;
    }

    module.exports = shuffle;


},{"../random/randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/array/slice.js":[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/some.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/sort.js":[function(require,module,exports){


    /**
     * Merge sort (http://en.wikipedia.org/wiki/Merge_sort)
     */
    function mergeSort(arr, compareFn) {
        if (arr == null) {
            return [];
        } else if (arr.length < 2) {
            return arr;
        }

        if (compareFn == null) {
            compareFn = defaultCompare;
        }

        var mid, left, right;

        mid   = ~~(arr.length / 2);
        left  = mergeSort( arr.slice(0, mid), compareFn );
        right = mergeSort( arr.slice(mid, arr.length), compareFn );

        return merge(left, right, compareFn);
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : (a > b? 1 : 0);
    }

    function merge(left, right, compareFn) {
        var result = [];

        while (left.length && right.length) {
            if (compareFn(left[0], right[0]) <= 0) {
                // if 0 it should preserve same order (stable)
                result.push(left.shift());
            } else {
                result.push(right.shift());
            }
        }

        if (left.length) {
            result.push.apply(result, left);
        }

        if (right.length) {
            result.push.apply(result, right);
        }

        return result;
    }

    module.exports = mergeSort;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/sortBy.js":[function(require,module,exports){
var sort = require('./sort');
var makeIterator = require('../function/makeIterator_');

    /*
     * Sort array by the result of the callback
     */
    function sortBy(arr, callback, context){
        callback = makeIterator(callback, context);

        return sort(arr, function(a, b) {
            a = callback(a);
            b = callback(b);
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        });
    }

    module.exports = sortBy;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./sort":"/Users/luke/dev/040715/node_modules/mout/array/sort.js"}],"/Users/luke/dev/040715/node_modules/mout/array/split.js":[function(require,module,exports){


    /**
     * Split array into a fixed number of segments.
     */
    function split(array, segments) {
        segments = segments || 2;
        var results = [];
        if (array == null) {
            return results;
        }

        var minLength = Math.floor(array.length / segments),
            remainder = array.length % segments,
            i = 0,
            len = array.length,
            segmentIndex = 0,
            segmentLength;

        while (i < len) {
            segmentLength = minLength;
            if (segmentIndex < remainder) {
                segmentLength++;
            }

            results.push(array.slice(i, i + segmentLength));

            segmentIndex++;
            i += segmentLength;
        }

        return results;
    }
    module.exports = split;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/take.js":[function(require,module,exports){


    /**
     * Iterates over a callback a set amount of times
     * returning the results
     */
    function take(n, callback, thisObj){
        var i = -1;
        var arr = [];
        if( !thisObj ){
            while(++i < n){
                arr[i] = callback(i, n);
            }
        } else {
            while(++i < n){
                arr[i] = callback.call(thisObj, i, n);
            }
        }
        return arr;
    }

    module.exports = take;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/toLookup.js":[function(require,module,exports){
var isFunction = require('../lang/isFunction');

    /**
     * Creates an object that holds a lookup for the objects in the array.
     */
    function toLookup(arr, key) {
        var result = {};
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length, value;
        if (isFunction(key)) {
            while (++i < len) {
                value = arr[i];
                result[key(value)] = value;
            }
        } else {
            while (++i < len) {
                value = arr[i];
                result[value[key]] = value;
            }
        }

        return result;
    }
    module.exports = toLookup;


},{"../lang/isFunction":"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js"}],"/Users/luke/dev/040715/node_modules/mout/array/union.js":[function(require,module,exports){
var unique = require('./unique');
var append = require('./append');

    /**
     * Concat multiple arrays and remove duplicates
     */
    function union(arrs) {
        var results = [];
        var i = -1, len = arguments.length;
        while (++i < len) {
            append(results, arguments[i]);
        }

        return unique(results);
    }

    module.exports = union;



},{"./append":"/Users/luke/dev/040715/node_modules/mout/array/append.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/unique.js":[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/array/xor.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var contains = require('./contains');


    /**
     * Exclusive OR. Returns items that are present in a single array.
     * - like ptyhon's `symmetric_difference`
     */
    function xor(arr1, arr2) {
        arr1 = unique(arr1);
        arr2 = unique(arr2);

        var a1 = filter(arr1, function(item){
                return !contains(arr2, item);
            }),
            a2 = filter(arr2, function(item){
                return !contains(arr1, item);
            });

        return a1.concat(a2);
    }

    module.exports = xor;



},{"./contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/zip.js":[function(require,module,exports){
var max = require('./max');
var map = require('./map');

    function getLength(arr) {
        return arr == null ? 0 : arr.length;
    }

    /**
     * Merges together the values of each of the arrays with the values at the
     * corresponding position.
     */
    function zip(arr){
        var len = arr ? max(map(arguments, getLength)) : 0,
            results = [],
            i = -1;
        while (++i < len) {
            // jshint loopfunc: true
            results.push(map(arguments, function(item) {
                return item == null ? undefined : item[i];
            }));
        }

        return results;
    }

    module.exports = zip;



},{"./map":"/Users/luke/dev/040715/node_modules/mout/array/map.js","./max":"/Users/luke/dev/040715/node_modules/mout/array/max.js"}],"/Users/luke/dev/040715/node_modules/mout/collection.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'contains' : require('./collection/contains'),
    'every' : require('./collection/every'),
    'filter' : require('./collection/filter'),
    'find' : require('./collection/find'),
    'forEach' : require('./collection/forEach'),
    'make_' : require('./collection/make_'),
    'map' : require('./collection/map'),
    'max' : require('./collection/max'),
    'min' : require('./collection/min'),
    'pluck' : require('./collection/pluck'),
    'reduce' : require('./collection/reduce'),
    'reject' : require('./collection/reject'),
    'size' : require('./collection/size'),
    'some' : require('./collection/some')
};



},{"./collection/contains":"/Users/luke/dev/040715/node_modules/mout/collection/contains.js","./collection/every":"/Users/luke/dev/040715/node_modules/mout/collection/every.js","./collection/filter":"/Users/luke/dev/040715/node_modules/mout/collection/filter.js","./collection/find":"/Users/luke/dev/040715/node_modules/mout/collection/find.js","./collection/forEach":"/Users/luke/dev/040715/node_modules/mout/collection/forEach.js","./collection/make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js","./collection/map":"/Users/luke/dev/040715/node_modules/mout/collection/map.js","./collection/max":"/Users/luke/dev/040715/node_modules/mout/collection/max.js","./collection/min":"/Users/luke/dev/040715/node_modules/mout/collection/min.js","./collection/pluck":"/Users/luke/dev/040715/node_modules/mout/collection/pluck.js","./collection/reduce":"/Users/luke/dev/040715/node_modules/mout/collection/reduce.js","./collection/reject":"/Users/luke/dev/040715/node_modules/mout/collection/reject.js","./collection/size":"/Users/luke/dev/040715/node_modules/mout/collection/size.js","./collection/some":"/Users/luke/dev/040715/node_modules/mout/collection/some.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/contains.js":[function(require,module,exports){
var make = require('./make_');
var arrContains = require('../array/contains');
var objContains = require('../object/contains');

    /**
     */
    module.exports = make(arrContains, objContains);



},{"../array/contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","../object/contains":"/Users/luke/dev/040715/node_modules/mout/object/contains.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/every.js":[function(require,module,exports){
var make = require('./make_');
var arrEvery = require('../array/every');
var objEvery = require('../object/every');

    /**
     */
    module.exports = make(arrEvery, objEvery);



},{"../array/every":"/Users/luke/dev/040715/node_modules/mout/array/every.js","../object/every":"/Users/luke/dev/040715/node_modules/mout/object/every.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/filter.js":[function(require,module,exports){
var forEach = require('./forEach');
var makeIterator = require('../function/makeIterator_');

    /**
     * filter collection values, returns array.
     */
    function filter(list, iterator, thisObj) {
        iterator = makeIterator(iterator, thisObj);
        var results = [];
        if (!list) {
            return results;
        }
        forEach(list, function(value, index, list) {
            if (iterator(value, index, list)) {
                results[results.length] = value;
            }
        });
        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forEach":"/Users/luke/dev/040715/node_modules/mout/collection/forEach.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/find.js":[function(require,module,exports){
var make = require('./make_');
var arrFind = require('../array/find');
var objFind = require('../object/find');

    /**
     * Find value that returns true on iterator check.
     */
    module.exports = make(arrFind, objFind);



},{"../array/find":"/Users/luke/dev/040715/node_modules/mout/array/find.js","../object/find":"/Users/luke/dev/040715/node_modules/mout/object/find.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/forEach.js":[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/make_.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/map.js":[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":"/Users/luke/dev/040715/node_modules/mout/array/map.js","../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","../lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","../object/values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/max.js":[function(require,module,exports){
var make = require('./make_');
var arrMax = require('../array/max');
var objMax = require('../object/max');

    /**
     * Get maximum value inside collection
     */
    module.exports = make(arrMax, objMax);



},{"../array/max":"/Users/luke/dev/040715/node_modules/mout/array/max.js","../object/max":"/Users/luke/dev/040715/node_modules/mout/object/max.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/min.js":[function(require,module,exports){
var make = require('./make_');
var arrMin = require('../array/min');
var objMin = require('../object/min');

    /**
     * Get minimum value inside collection.
     */
    module.exports = make(arrMin, objMin);



},{"../array/min":"/Users/luke/dev/040715/node_modules/mout/array/min.js","../object/min":"/Users/luke/dev/040715/node_modules/mout/object/min.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/pluck.js":[function(require,module,exports){
var map = require('./map');

    /**
     * Extract a list of property values.
     */
    function pluck(list, key) {
        return map(list, function(value) {
            return value[key];
        });
    }

    module.exports = pluck;



},{"./map":"/Users/luke/dev/040715/node_modules/mout/collection/map.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/reduce.js":[function(require,module,exports){
var make = require('./make_');
var arrReduce = require('../array/reduce');
var objReduce = require('../object/reduce');

    /**
     */
    module.exports = make(arrReduce, objReduce);



},{"../array/reduce":"/Users/luke/dev/040715/node_modules/mout/array/reduce.js","../object/reduce":"/Users/luke/dev/040715/node_modules/mout/object/reduce.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/reject.js":[function(require,module,exports){
var filter = require('./filter');
var makeIterator = require('../function/makeIterator_');

    /**
     * Inverse or collection/filter
     */
    function reject(list, iterator, thisObj) {
        iterator = makeIterator(iterator, thisObj);
        return filter(list, function(value, index, list) {
            return !iterator(value, index, list);
        }, thisObj);
    }

    module.exports = reject;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./filter":"/Users/luke/dev/040715/node_modules/mout/collection/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/size.js":[function(require,module,exports){
var isArray = require('../lang/isArray');
var objSize = require('../object/size');

    /**
     * Get collection size
     */
    function size(list) {
        if (!list) {
            return 0;
        }
        if (isArray(list)) {
            return list.length;
        }
        return objSize(list);
    }

    module.exports = size;



},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","../object/size":"/Users/luke/dev/040715/node_modules/mout/object/size.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/some.js":[function(require,module,exports){
var make = require('./make_');
var arrSome = require('../array/some');
var objSome = require('../object/some');

    /**
     */
    module.exports = make(arrSome, objSome);



},{"../array/some":"/Users/luke/dev/040715/node_modules/mout/array/some.js","../object/some":"/Users/luke/dev/040715/node_modules/mout/object/some.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/date.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'dayOfTheYear' : require('./date/dayOfTheYear'),
    'diff' : require('./date/diff'),
    'i18n_' : require('./date/i18n_'),
    'isLeapYear' : require('./date/isLeapYear'),
    'isSame' : require('./date/isSame'),
    'parseIso' : require('./date/parseIso'),
    'quarter' : require('./date/quarter'),
    'startOf' : require('./date/startOf'),
    'strftime' : require('./date/strftime'),
    'timezoneAbbr' : require('./date/timezoneAbbr'),
    'timezoneOffset' : require('./date/timezoneOffset'),
    'totalDaysInMonth' : require('./date/totalDaysInMonth'),
    'totalDaysInYear' : require('./date/totalDaysInYear'),
    'weekOfTheYear' : require('./date/weekOfTheYear')
};



},{"./date/dayOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js","./date/diff":"/Users/luke/dev/040715/node_modules/mout/date/diff.js","./date/i18n_":"/Users/luke/dev/040715/node_modules/mout/date/i18n_.js","./date/isLeapYear":"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js","./date/isSame":"/Users/luke/dev/040715/node_modules/mout/date/isSame.js","./date/parseIso":"/Users/luke/dev/040715/node_modules/mout/date/parseIso.js","./date/quarter":"/Users/luke/dev/040715/node_modules/mout/date/quarter.js","./date/startOf":"/Users/luke/dev/040715/node_modules/mout/date/startOf.js","./date/strftime":"/Users/luke/dev/040715/node_modules/mout/date/strftime.js","./date/timezoneAbbr":"/Users/luke/dev/040715/node_modules/mout/date/timezoneAbbr.js","./date/timezoneOffset":"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js","./date/totalDaysInMonth":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInMonth.js","./date/totalDaysInYear":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInYear.js","./date/weekOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/weekOfTheYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js":[function(require,module,exports){
var isDate = require('../lang/isDate');

    /**
     * return the day of the year (1..366)
     */
    function dayOfTheYear(date){
        return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) -
                Date.UTC(date.getFullYear(), 0, 1)) / 86400000 + 1;
    }

    module.exports = dayOfTheYear;



},{"../lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js"}],"/Users/luke/dev/040715/node_modules/mout/date/diff.js":[function(require,module,exports){
var totalDaysInMonth = require('./totalDaysInMonth');
var totalDaysInYear = require('./totalDaysInYear');
var convert = require('../time/convert');

    /**
     * calculate the difference between dates (range)
     */
    function diff(start, end, unitName){
        // sort the dates to make it easier to process (specially year/month)
        if (start > end) {
            var swap = start;
            start = end;
            end = swap;
        }

        var output;

        if (unitName === 'month') {
            output = getMonthsDiff(start, end);
        } else if (unitName === 'year'){
            output = getYearsDiff(start, end);
        } else if (unitName != null) {
            if (unitName === 'day') {
                // ignore timezone difference because of daylight savings time
                start = toUtc(start);
                end = toUtc(end);
            }
            output = convert(end - start, 'ms', unitName);
        } else {
            output = end - start;
        }

        return output;
    }


    function toUtc(d){
        // we ignore timezone differences on purpose because of daylight
        // savings time, otherwise it would return fractional days/weeks even
        // if a full day elapsed. eg:
        // Wed Feb 12 2014 00:00:00 GMT-0200 (BRST)
        // Sun Feb 16 2014 00:00:00 GMT-0300 (BRT)
        // diff should be 4 days and not 4.041666666666667
        return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(),
                        d.getHours(), d.getMinutes(), d.getSeconds(),
                        d.getMilliseconds());
    }


    function getMonthsDiff(start, end){
        return getElapsedMonths(start, end) +
               getElapsedYears(start, end) * 12 +
               getFractionalMonth(start, end);
    }


    function getYearsDiff(start, end){
        var elapsedYears = getElapsedYears(start, end);
        return elapsedYears + getFractionalYear(start, end, elapsedYears);
    }


    function getElapsedMonths(start, end){
        var monthDiff = end.getMonth() - start.getMonth();
        if (monthDiff < 0) {
            monthDiff += 12;
        }
        // less than a full month
        if (start.getDate() > end.getDate()) {
            monthDiff -= 1;
        }
        return monthDiff;
    }


    function getElapsedYears(start, end){
        var yearDiff = end.getFullYear() - start.getFullYear();
        // less than a full year
        if (start.getMonth() > end.getMonth()) {
            yearDiff -= 1;
        }
        return yearDiff;
    }


    function getFractionalMonth(start, end){
        var fractionalDiff = 0;
        var startDay = start.getDate();
        var endDay = end.getDate();

        if (startDay !== endDay) {
            var startTotalDays = totalDaysInMonth(start);
            var endTotalDays = totalDaysInMonth(end);
            var totalDays;
            var daysElapsed;

            if (startDay > endDay) {
                // eg: Jan 29 - Feb 27 (29 days elapsed but not a full month)
                var baseDay = startTotalDays - startDay;
                daysElapsed = endDay + baseDay;
                // total days should be relative to 1st day of next month if
                // startDay > endTotalDays
                totalDays = (startDay > endTotalDays)?
                    endTotalDays + baseDay + 1 : startDay + baseDay;
            } else {
                // fractional is only based on endMonth eg: Jan 12 - Feb 18
                // (6 fractional days, 28 days until next full month)
                daysElapsed = endDay - startDay;
                totalDays = endTotalDays;
            }

            fractionalDiff = daysElapsed / totalDays;
        }

        return fractionalDiff;
    }


    function getFractionalYear(start, end, elapsedYears){
        var base = elapsedYears?
            new Date(end.getFullYear(), start.getMonth(), start.getDate()) :
            start;
        var elapsedDays = diff(base, end, 'day');
        return elapsedDays / totalDaysInYear(end);
    }


    module.exports = diff;



},{"../time/convert":"/Users/luke/dev/040715/node_modules/mout/time/convert.js","./totalDaysInMonth":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInMonth.js","./totalDaysInYear":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/i18n/en-US.js":[function(require,module,exports){

    // en-US (English, United States)
    module.exports = {
        "am" : "AM",
        "pm" : "PM",

        "x": "%m/%d/%y",
        "X": "%H:%M:%S",
        "c": "%a %d %b %Y %I:%M:%S %p %Z",

        "months" : [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ],

        "months_abbr" : [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ],

        "days" : [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ],

        "days_abbr" : [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ]
    };


},{}],"/Users/luke/dev/040715/node_modules/mout/date/i18n_.js":[function(require,module,exports){
var mixIn = require('../object/mixIn');
var enUS = require('./i18n/en-US');

    // we also use mixIn to make sure we don't affect the original locale
    var activeLocale = mixIn({}, enUS, {
        // we expose a "set" method to allow overriding the global locale
        set : function(localeData){
            mixIn(activeLocale, localeData);
        }
    });

    module.exports = activeLocale;



},{"../object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js","./i18n/en-US":"/Users/luke/dev/040715/node_modules/mout/date/i18n/en-US.js"}],"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js":[function(require,module,exports){
var isDate = require('../lang/isDate');

    /**
     * checks if it's a leap year
     */
    function isLeapYear(fullYear){
        if (isDate(fullYear)) {
            fullYear = fullYear.getFullYear();
        }
        return fullYear % 400 === 0 || (fullYear % 100 !== 0 && fullYear % 4 === 0);
    }

    module.exports = isLeapYear;



},{"../lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js"}],"/Users/luke/dev/040715/node_modules/mout/date/isSame.js":[function(require,module,exports){
var startOf = require('./startOf');

    /**
     * Check if date is "same" with optional period
     */
    function isSame(date1, date2, period){
        if (period) {
            date1 = startOf(date1, period);
            date2 = startOf(date2, period);
        }
        return Number(date1) === Number(date2);
    }

    module.exports = isSame;



},{"./startOf":"/Users/luke/dev/040715/node_modules/mout/date/startOf.js"}],"/Users/luke/dev/040715/node_modules/mout/date/parseIso.js":[function(require,module,exports){
var some = require('../array/some');

    var datePatterns = [
        /^([0-9]{4})$/,                        // YYYY
        /^([0-9]{4})-([0-9]{2})$/,             // YYYY-MM (YYYYMM not allowed)
        /^([0-9]{4})-?([0-9]{2})-?([0-9]{2})$/ // YYYY-MM-DD or YYYYMMDD
    ];
    var ORD_DATE = /^([0-9]{4})-?([0-9]{3})$/; // YYYY-DDD

    var timePatterns = [
        /^([0-9]{2}(?:\.[0-9]*)?)$/,                      // HH.hh
        /^([0-9]{2}):?([0-9]{2}(?:\.[0-9]*)?)$/,          // HH:MM.mm
        /^([0-9]{2}):?([0-9]{2}):?([0-9]{2}(\.[0-9]*)?)$/ // HH:MM:SS.ss
    ];

    var DATE_TIME = /^(.+)T(.+)$/;
    var TIME_ZONE = /^(.+)([+\-])([0-9]{2}):?([0-9]{2})$/;

    function matchAll(str, patterns) {
        var match;
        var found = some(patterns, function(pattern) {
            return !!(match = pattern.exec(str));
        });

        return found ? match : null;
    }

    function getDate(year, month, day) {
        var date = new Date(Date.UTC(year, month, day));

        // Explicitly set year to avoid Date.UTC making dates < 100 relative to
        // 1900
        date.setUTCFullYear(year);

        var valid =
            date.getUTCFullYear() === year &&
            date.getUTCMonth() === month &&
            date.getUTCDate() === day;
        return valid ? +date : NaN;
    }

    function parseOrdinalDate(str) {
        var match = ORD_DATE.exec(str);
        if (match ) {
            var year = +match[1],
                day = +match[2],
                date = new Date(Date.UTC(year, 0, day));

            if (date.getUTCFullYear() === year) {
                return +date;
            }
        }

        return NaN;
    }

    function parseDate(str) {
        var match, year, month, day;

        match = matchAll(str, datePatterns);
        if (match === null) {
            // Ordinal dates are verified differently.
            return parseOrdinalDate(str);
        }

        year = (match[1] === void 0) ? 0 : +match[1];
        month = (match[2] === void 0) ? 0 : +match[2] - 1;
        day = (match[3] === void 0) ? 1 : +match[3];

        return getDate(year, month, day);
    }

    function getTime(hr, min, sec) {
        var valid =
            (hr < 24 && hr >= 0 &&
             min < 60 && min >= 0 &&
             sec < 60 && min >= 0) ||
            (hr === 24 && min === 0 && sec === 0);
        if (!valid) {
            return NaN;
        }

        return ((hr * 60 + min) * 60 + sec) * 1000;
    }

    function parseOffset(str) {
        var match;
        if (str.charAt(str.length - 1) === 'Z') {
            str = str.substring(0, str.length - 1);
        } else {
            match = TIME_ZONE.exec(str);
            if (match) {
                var hours = +match[3],
                    minutes = (match[4] === void 0) ? 0 : +match[4],
                    offset = getTime(hours, minutes, 0);

                if (match[2] === '-') {
                    offset *= -1;
                }

                return { offset: offset, time: match[1] };
            }
        }

        // No time zone specified, assume UTC
        return { offset: 0, time: str };
    }

    function parseTime(str) {
        var match;
        var offset = parseOffset(str);

        str = offset.time;
        offset = offset.offset;
        if (isNaN(offset)) {
            return NaN;
        }

        match = matchAll(str, timePatterns);
        if (match === null) {
            return NaN;
        }

        var hours = (match[1] === void 0) ? 0 : +match[1],
            minutes = (match[2] === void 0) ? 0 : +match[2],
            seconds = (match[3] === void 0) ? 0 : +match[3];

        return getTime(hours, minutes, seconds) - offset;
    }

    /**
     * Parse an ISO8601 formatted date string, and return a Date object.
     */
    function parseISO8601(str){
        var match = DATE_TIME.exec(str);
        if (!match) {
            // No time specified
            return parseDate(str);
        }

        return parseDate(match[1]) + parseTime(match[2]);
    }

    module.exports = parseISO8601;



},{"../array/some":"/Users/luke/dev/040715/node_modules/mout/array/some.js"}],"/Users/luke/dev/040715/node_modules/mout/date/quarter.js":[function(require,module,exports){


    /**
     * gets date quarter
     */
    function quarter(date){
        var month = date.getMonth();
        if (month < 3) return 1;
        if (month < 6) return 2;
        if (month < 9) return 3;
        return 4;
    }

    module.exports = quarter;



},{}],"/Users/luke/dev/040715/node_modules/mout/date/startOf.js":[function(require,module,exports){
var clone = require('../lang/clone');

    /**
     * get a new Date object representing start of period
     */
    function startOf(date, period){
        date = clone(date);

        // intentionally removed "break" from switch since start of
        // month/year/etc should also reset the following periods
        switch (period) {
            case 'year':
                date.setMonth(0);
            /* falls through */
            case 'month':
                date.setDate(1);
            /* falls through */
            case 'week':
            case 'day':
                date.setHours(0);
            /* falls through */
            case 'hour':
                date.setMinutes(0);
            /* falls through */
            case 'minute':
                date.setSeconds(0);
            /* falls through */
            case 'second':
                date.setMilliseconds(0);
                break;
            default:
                throw new Error('"'+ period +'" is not a valid period');
        }

        // week is the only case that should reset the weekDay and maybe even
        // overflow to previous month
        if (period === 'week') {
            var weekDay = date.getDay();
            var baseDate = date.getDate();
            if (weekDay) {
                if (weekDay >= baseDate) {
                    //start of the week is on previous month
                    date.setDate(0);
                }
                date.setDate(date.getDate() - date.getDay());
            }
        }

        return date;
    }

    module.exports = startOf;



},{"../lang/clone":"/Users/luke/dev/040715/node_modules/mout/lang/clone.js"}],"/Users/luke/dev/040715/node_modules/mout/date/strftime.js":[function(require,module,exports){
var pad = require('../number/pad');
var lpad = require('../string/lpad');
var i18n = require('./i18n_');
var dayOfTheYear = require('./dayOfTheYear');
var timezoneOffset = require('./timezoneOffset');
var timezoneAbbr = require('./timezoneAbbr');
var weekOfTheYear = require('./weekOfTheYear');

    var _combinations = {
        'D': '%m/%d/%y',
        'F': '%Y-%m-%d',
        'r': '%I:%M:%S %p',
        'R': '%H:%M',
        'T': '%H:%M:%S',
        'x': 'locale',
        'X': 'locale',
        'c': 'locale'
    };


    /**
     * format date based on strftime format
     */
    function strftime(date, format, localeData){
        localeData = localeData  || i18n;
        var reToken = /%([a-z%])/gi;

        function makeIterator(fn) {
            return function(match, token){
                return fn(date, token, localeData);
            };
        }

        return format
            .replace(reToken, makeIterator(expandCombinations))
            .replace(reToken, makeIterator(convertToken));
    }


    function expandCombinations(date, token, l10n){
        if (token in _combinations) {
            var expanded = _combinations[token];
            return expanded === 'locale'? l10n[token] : expanded;
        } else {
            return '%'+ token;
        }
    }


    function convertToken(date, token, l10n){
        switch (token){
            case 'a':
                return l10n.days_abbr[date.getDay()];
            case 'A':
                return l10n.days[date.getDay()];
            case 'h':
            case 'b':
                return l10n.months_abbr[date.getMonth()];
            case 'B':
                return l10n.months[date.getMonth()];
            case 'C':
                return pad(Math.floor(date.getFullYear() / 100), 2);
            case 'd':
                return pad(date.getDate(), 2);
            case 'e':
                return pad(date.getDate(), 2, ' ');
            case 'H':
                return pad(date.getHours(), 2);
            case 'I':
                return pad(date.getHours() % 12, 2);
            case 'j':
                return pad(dayOfTheYear(date), 3);
            case 'l':
                return lpad(date.getHours() % 12, 2);
            case 'L':
                return pad(date.getMilliseconds(), 3);
            case 'm':
                return pad(date.getMonth() + 1, 2);
            case 'M':
                return pad(date.getMinutes(), 2);
            case 'n':
                return '\n';
            case 'p':
                return date.getHours() >= 12? l10n.pm : l10n.am;
            case 'P':
                return convertToken(date, 'p', l10n).toLowerCase();
            case 's':
                return date.getTime() / 1000;
            case 'S':
                return pad(date.getSeconds(), 2);
            case 't':
                return '\t';
            case 'u':
                var day = date.getDay();
                return day === 0? 7 : day;
            case 'U':
                return pad(weekOfTheYear(date), 2);
            case 'w':
                return date.getDay();
            case 'W':
                return pad(weekOfTheYear(date, 1), 2);
            case 'y':
                return pad(date.getFullYear() % 100, 2);
            case 'Y':
                return pad(date.getFullYear(), 4);
            case 'z':
                return timezoneOffset(date);
            case 'Z':
                return timezoneAbbr(date);
            case '%':
                return '%';
            default:
                // keep unrecognized tokens
                return '%'+ token;
        }
    }


    module.exports = strftime;



},{"../number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js","../string/lpad":"/Users/luke/dev/040715/node_modules/mout/string/lpad.js","./dayOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js","./i18n_":"/Users/luke/dev/040715/node_modules/mout/date/i18n_.js","./timezoneAbbr":"/Users/luke/dev/040715/node_modules/mout/date/timezoneAbbr.js","./timezoneOffset":"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js","./weekOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/weekOfTheYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/timezoneAbbr.js":[function(require,module,exports){
var timezoneOffset = require('./timezoneOffset');

    /**
     * Abbreviated time zone name or similar information.
     */
    function timezoneAbbr(date){
        // Date.toString gives different results depending on the
        // browser/system so we fallback to timezone offset
        // chrome: 'Mon Apr 08 2013 09:02:04 GMT-0300 (BRT)'
        // IE: 'Mon Apr 8 09:02:04 UTC-0300 2013'
        var tz = /\(([A-Z]{3,4})\)/.exec(date.toString());
        return tz? tz[1] : timezoneOffset(date);
    }

    module.exports = timezoneAbbr;



},{"./timezoneOffset":"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js"}],"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js":[function(require,module,exports){
var pad = require('../number/pad');

    /**
     * time zone as hour and minute offset from UTC (e.g. +0900)
     */
    function timezoneOffset(date){
        var offset = date.getTimezoneOffset();
        var abs = Math.abs(offset);
        var h = pad(Math.floor(abs / 60), 2);
        var m = pad(abs % 60, 2);
        return (offset > 0? '-' : '+') + h + m;
    }

    module.exports = timezoneOffset;



},{"../number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js"}],"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInMonth.js":[function(require,module,exports){
var isDate = require('../lang/isDate');
var isLeapYear = require('./isLeapYear');

    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    /**
     * returns the total amount of days in the month (considering leap years)
     */
    function totalDaysInMonth(fullYear, monthIndex){
        if (isDate(fullYear)) {
            monthIndex = fullYear.getMonth();
        }

        if (monthIndex === 1 && isLeapYear(fullYear)) {
            return 29;
        } else {
            return DAYS_IN_MONTH[monthIndex];
        }
    }

    module.exports = totalDaysInMonth;



},{"../lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js","./isLeapYear":"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInYear.js":[function(require,module,exports){
var isLeapYear = require('./isLeapYear');

    /**
     * return the amount of days in the year following the gregorian calendar
     * and leap years
     */
    function totalDaysInYear(fullYear){
        return isLeapYear(fullYear)? 366 : 365;
    }

    module.exports = totalDaysInYear;



},{"./isLeapYear":"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/weekOfTheYear.js":[function(require,module,exports){
var dayOfTheYear = require('./dayOfTheYear');

    /**
     * Return the week of the year based on given firstDayOfWeek
     */
    function weekOfTheYear(date, firstDayOfWeek){
        firstDayOfWeek = firstDayOfWeek == null? 0 : firstDayOfWeek;
        var doy = dayOfTheYear(date);
        var dow = (7 + date.getDay() - firstDayOfWeek) % 7;
        var relativeWeekDay = 6 - firstDayOfWeek - dow;
        return Math.floor((doy + relativeWeekDay) / 7);
    }

    module.exports = weekOfTheYear;



},{"./dayOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js"}],"/Users/luke/dev/040715/node_modules/mout/function.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'awaitDelay' : require('./function/awaitDelay'),
    'bind' : require('./function/bind'),
    'compose' : require('./function/compose'),
    'constant' : require('./function/constant'),
    'debounce' : require('./function/debounce'),
    'func' : require('./function/func'),
    'identity' : require('./function/identity'),
    'makeIterator_' : require('./function/makeIterator_'),
    'partial' : require('./function/partial'),
    'prop' : require('./function/prop'),
    'series' : require('./function/series'),
    'throttle' : require('./function/throttle'),
    'timeout' : require('./function/timeout'),
    'times' : require('./function/times'),
    'wrap' : require('./function/wrap')
};



},{"./function/awaitDelay":"/Users/luke/dev/040715/node_modules/mout/function/awaitDelay.js","./function/bind":"/Users/luke/dev/040715/node_modules/mout/function/bind.js","./function/compose":"/Users/luke/dev/040715/node_modules/mout/function/compose.js","./function/constant":"/Users/luke/dev/040715/node_modules/mout/function/constant.js","./function/debounce":"/Users/luke/dev/040715/node_modules/mout/function/debounce.js","./function/func":"/Users/luke/dev/040715/node_modules/mout/function/func.js","./function/identity":"/Users/luke/dev/040715/node_modules/mout/function/identity.js","./function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./function/partial":"/Users/luke/dev/040715/node_modules/mout/function/partial.js","./function/prop":"/Users/luke/dev/040715/node_modules/mout/function/prop.js","./function/series":"/Users/luke/dev/040715/node_modules/mout/function/series.js","./function/throttle":"/Users/luke/dev/040715/node_modules/mout/function/throttle.js","./function/timeout":"/Users/luke/dev/040715/node_modules/mout/function/timeout.js","./function/times":"/Users/luke/dev/040715/node_modules/mout/function/times.js","./function/wrap":"/Users/luke/dev/040715/node_modules/mout/function/wrap.js"}],"/Users/luke/dev/040715/node_modules/mout/function/awaitDelay.js":[function(require,module,exports){
var now = require('../time/now');
var timeout = require('./timeout');
var append = require('../array/append');

    /**
     * Ensure a minimum delay for callbacks
     */
    function awaitDelay( callback, delay ){
        var baseTime = now() + delay;
        return function() {
            // ensure all browsers will execute it asynchronously (avoid hard
            // to catch errors) not using "0" because of old browsers and also
            // since new browsers increase the value to be at least "4"
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout
            var ms = Math.max(baseTime - now(), 4);
            return timeout.apply(this, append([callback, ms, this], arguments));
        };
    }

    module.exports = awaitDelay;



},{"../array/append":"/Users/luke/dev/040715/node_modules/mout/array/append.js","../time/now":"/Users/luke/dev/040715/node_modules/mout/time/now.js","./timeout":"/Users/luke/dev/040715/node_modules/mout/function/timeout.js"}],"/Users/luke/dev/040715/node_modules/mout/function/bind.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a function that will execute in the given context, optionally adding any additional supplied parameters to the beginning of the arguments collection.
     * @param {Function} fn  Function.
     * @param {object} context   Execution context.
     * @param {rest} args    Arguments (0...n arguments).
     * @return {Function} Wrapped Function.
     */
    function bind(fn, context, args){
        var argsArr = slice(arguments, 2); //curried args
        return function(){
            return fn.apply(context, argsArr.concat(slice(arguments)));
        };
    }

    module.exports = bind;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/function/compose.js":[function(require,module,exports){


    /**
     * Returns a function that composes multiple functions, passing results to
     * each other.
     */
    function compose() {
        var fns = arguments;
        return function(arg){
            // only cares about the first argument since the chain can only
            // deal with a single return value anyway. It should start from
            // the last fn.
            var n = fns.length;
            while (n--) {
                arg = fns[n].call(this, arg);
            }
            return arg;
         };
     }

     module.exports = compose;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/constant.js":[function(require,module,exports){


    /**
     * Returns a new function that will return the value
     */
    function constant(value){
        return function() {
            return value;
        };
    }

    module.exports = constant;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/debounce.js":[function(require,module,exports){


    /**
     * Debounce callback execution
     */
    function debounce(fn, threshold, isAsap){
        var timeout, result;
        function debounced(){
            var args = arguments, context = this;
            function delayed(){
                if (! isAsap) {
                    result = fn.apply(context, args);
                }
                timeout = null;
            }
            if (timeout) {
                clearTimeout(timeout);
            } else if (isAsap) {
                result = fn.apply(context, args);
            }
            timeout = setTimeout(delayed, threshold);
            return result;
        }
        debounced.cancel = function(){
            clearTimeout(timeout);
        };
        return debounced;
    }

    module.exports = debounce;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/func.js":[function(require,module,exports){


    /**
     * Returns a function that call a method on the passed object
     */
    function func(name){
        return function(obj){
            return obj[name]();
        };
    }

    module.exports = func;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/identity.js":[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js":[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":"/Users/luke/dev/040715/node_modules/mout/object/deepMatches.js","./identity":"/Users/luke/dev/040715/node_modules/mout/function/identity.js","./prop":"/Users/luke/dev/040715/node_modules/mout/function/prop.js"}],"/Users/luke/dev/040715/node_modules/mout/function/partial.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Creates a partially applied function.
     */
    function partial(f) {
        var as = slice(arguments, 1);
        return function() {
            var args = as.concat(slice(arguments));
            for (var i = args.length; i--;) {
                if (args[i] === partial._) {
                    args[i] = args.splice(-1)[0];
                }
            }
            return f.apply(this, args);
        };
    }

    partial._ = {};

    module.exports = partial;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/function/prop.js":[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/series.js":[function(require,module,exports){


    /**
     * Returns a function that will execute a list of functions in sequence
     * passing the same arguments to each one. (useful for batch processing
     * items during a forEach loop)
     */
    function series(){
        var fns = arguments;
        return function(){
            var i = 0,
                n = fns.length;
            while (i < n) {
                fns[i].apply(this, arguments);
                i += 1;
            }
        };
    }

    module.exports = series;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/throttle.js":[function(require,module,exports){
var now = require('../time/now');

    /**
     */
    function throttle(fn, delay){
        var context, timeout, result, args,
            diff, prevCall = 0;
        function delayed(){
            prevCall = now();
            timeout = null;
            result = fn.apply(context, args);
        }
        function throttled(){
            context = this;
            args = arguments;
            diff = delay - (now() - prevCall);
            if (diff <= 0) {
                clearTimeout(timeout);
                delayed();
            } else if (! timeout) {
                timeout = setTimeout(delayed, diff);
            }
            return result;
        }
        throttled.cancel = function(){
            clearTimeout(timeout);
        };
        return throttled;
    }

    module.exports = throttle;



},{"../time/now":"/Users/luke/dev/040715/node_modules/mout/time/now.js"}],"/Users/luke/dev/040715/node_modules/mout/function/timeout.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Delays the call of a function within a given context.
     */
    function timeout(fn, millis, context){

        var args = slice(arguments, 3);

        return setTimeout(function() {
            fn.apply(context, args);
        }, millis);
    }

    module.exports = timeout;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/function/times.js":[function(require,module,exports){


    /**
     * Iterates over a callback a set amount of times
     */
    function times(n, callback, thisObj){
        var i = -1;
        while (++i < n) {
            if ( callback.call(thisObj, i) === false ) {
                break;
            }
        }
    }

    module.exports = times;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/wrap.js":[function(require,module,exports){
var partial = require('./partial');

    /**
     * Returns the first function passed as an argument to the second,
     * allowing you to adjust arguments, run code before and after, and
     * conditionally execute the original function.
     */
    function wrap(fn, wrapper){
        return partial(wrapper, fn);
    }

    module.exports = wrap;



},{"./partial":"/Users/luke/dev/040715/node_modules/mout/function/partial.js"}],"/Users/luke/dev/040715/node_modules/mout/index.js":[function(require,module,exports){
/**@license
 * mout v0.11.0 | http://moutjs.com | MIT license
 */


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'VERSION' : '0.11.0',
    'array' : require('./array'),
    'collection' : require('./collection'),
    'date' : require('./date'),
    'function' : require('./function'),
    'lang' : require('./lang'),
    'math' : require('./math'),
    'number' : require('./number'),
    'object' : require('./object'),
    'queryString' : require('./queryString'),
    'random' : require('./random'),
    'string' : require('./string'),
    'time' : require('./time'),
    'fn' : require('./function')
};



},{"./array":"/Users/luke/dev/040715/node_modules/mout/array.js","./collection":"/Users/luke/dev/040715/node_modules/mout/collection.js","./date":"/Users/luke/dev/040715/node_modules/mout/date.js","./function":"/Users/luke/dev/040715/node_modules/mout/function.js","./lang":"/Users/luke/dev/040715/node_modules/mout/lang.js","./math":"/Users/luke/dev/040715/node_modules/mout/math.js","./number":"/Users/luke/dev/040715/node_modules/mout/number.js","./object":"/Users/luke/dev/040715/node_modules/mout/object.js","./queryString":"/Users/luke/dev/040715/node_modules/mout/queryString.js","./random":"/Users/luke/dev/040715/node_modules/mout/random.js","./string":"/Users/luke/dev/040715/node_modules/mout/string.js","./time":"/Users/luke/dev/040715/node_modules/mout/time.js"}],"/Users/luke/dev/040715/node_modules/mout/lang.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'GLOBAL' : require('./lang/GLOBAL'),
    'clone' : require('./lang/clone'),
    'createObject' : require('./lang/createObject'),
    'ctorApply' : require('./lang/ctorApply'),
    'deepClone' : require('./lang/deepClone'),
    'deepEquals' : require('./lang/deepEquals'),
    'defaults' : require('./lang/defaults'),
    'inheritPrototype' : require('./lang/inheritPrototype'),
    'is' : require('./lang/is'),
    'isArguments' : require('./lang/isArguments'),
    'isArray' : require('./lang/isArray'),
    'isBoolean' : require('./lang/isBoolean'),
    'isDate' : require('./lang/isDate'),
    'isEmpty' : require('./lang/isEmpty'),
    'isFinite' : require('./lang/isFinite'),
    'isFunction' : require('./lang/isFunction'),
    'isInteger' : require('./lang/isInteger'),
    'isKind' : require('./lang/isKind'),
    'isNaN' : require('./lang/isNaN'),
    'isNull' : require('./lang/isNull'),
    'isNumber' : require('./lang/isNumber'),
    'isObject' : require('./lang/isObject'),
    'isPlainObject' : require('./lang/isPlainObject'),
    'isPrimitive' : require('./lang/isPrimitive'),
    'isRegExp' : require('./lang/isRegExp'),
    'isString' : require('./lang/isString'),
    'isUndefined' : require('./lang/isUndefined'),
    'isnt' : require('./lang/isnt'),
    'kindOf' : require('./lang/kindOf'),
    'toArray' : require('./lang/toArray'),
    'toNumber' : require('./lang/toNumber'),
    'toString' : require('./lang/toString')
};



},{"./lang/GLOBAL":"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js","./lang/clone":"/Users/luke/dev/040715/node_modules/mout/lang/clone.js","./lang/createObject":"/Users/luke/dev/040715/node_modules/mout/lang/createObject.js","./lang/ctorApply":"/Users/luke/dev/040715/node_modules/mout/lang/ctorApply.js","./lang/deepClone":"/Users/luke/dev/040715/node_modules/mout/lang/deepClone.js","./lang/deepEquals":"/Users/luke/dev/040715/node_modules/mout/lang/deepEquals.js","./lang/defaults":"/Users/luke/dev/040715/node_modules/mout/lang/defaults.js","./lang/inheritPrototype":"/Users/luke/dev/040715/node_modules/mout/lang/inheritPrototype.js","./lang/is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","./lang/isArguments":"/Users/luke/dev/040715/node_modules/mout/lang/isArguments.js","./lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./lang/isBoolean":"/Users/luke/dev/040715/node_modules/mout/lang/isBoolean.js","./lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js","./lang/isEmpty":"/Users/luke/dev/040715/node_modules/mout/lang/isEmpty.js","./lang/isFinite":"/Users/luke/dev/040715/node_modules/mout/lang/isFinite.js","./lang/isFunction":"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js","./lang/isInteger":"/Users/luke/dev/040715/node_modules/mout/lang/isInteger.js","./lang/isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js","./lang/isNaN":"/Users/luke/dev/040715/node_modules/mout/lang/isNaN.js","./lang/isNull":"/Users/luke/dev/040715/node_modules/mout/lang/isNull.js","./lang/isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js","./lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","./lang/isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./lang/isPrimitive":"/Users/luke/dev/040715/node_modules/mout/lang/isPrimitive.js","./lang/isRegExp":"/Users/luke/dev/040715/node_modules/mout/lang/isRegExp.js","./lang/isString":"/Users/luke/dev/040715/node_modules/mout/lang/isString.js","./lang/isUndefined":"/Users/luke/dev/040715/node_modules/mout/lang/isUndefined.js","./lang/isnt":"/Users/luke/dev/040715/node_modules/mout/lang/isnt.js","./lang/kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js","./lang/toArray":"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js","./lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js","./lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js":[function(require,module,exports){


    // Reference to the global context (works on ES3 and ES5-strict mode)
    //jshint -W061, -W064
    module.exports = Function('return this')();



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/clone.js":[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js","./isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/createObject.js":[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/ctorApply.js":[function(require,module,exports){


    function F(){}

    /**
     * Do fn.apply on a constructor.
     */
    function ctorApply(ctor, args) {
        F.prototype = ctor.prototype;
        var instance = new F();
        ctor.apply(instance, args);
        return instance;
    }

    module.exports = ctorApply;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/deepClone.js":[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./clone":"/Users/luke/dev/040715/node_modules/mout/lang/clone.js","./isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/deepEquals.js":[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":"/Users/luke/dev/040715/node_modules/mout/array/equals.js","../object/equals":"/Users/luke/dev/040715/node_modules/mout/object/equals.js","./is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","./isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/defaults.js":[function(require,module,exports){
var toArray = require('./toArray');
var find = require('../array/find');

    /**
     * Return first non void argument
     */
    function defaults(var_args){
        return find(toArray(arguments), nonVoid);
    }

    function nonVoid(val){
        return val != null;
    }

    module.exports = defaults;



},{"../array/find":"/Users/luke/dev/040715/node_modules/mout/array/find.js","./toArray":"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/inheritPrototype.js":[function(require,module,exports){
var createObject = require('./createObject');

    /**
    * Inherit prototype from another Object.
    * - inspired by Nicholas Zackas <http://nczonline.net> Solution
    * @param {object} child Child object
    * @param {object} parent    Parent Object
    */
    function inheritPrototype(child, parent){
        var p = createObject(parent.prototype);
        p.constructor = child;
        child.prototype = p;
        child.super_ = parent;
        return p;
    }

    module.exports = inheritPrototype;


},{"./createObject":"/Users/luke/dev/040715/node_modules/mout/lang/createObject.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/is.js":[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isArguments.js":[function(require,module,exports){
var isKind = require('./isKind');

    /**
     */
    var isArgs = isKind(arguments, 'Arguments')?
            function(val){
                return isKind(val, 'Arguments');
            } :
            function(val){
                // Arguments is an Object on IE7
                return !!(val && Object.prototype.hasOwnProperty.call(val, 'callee'));
            };

    module.exports = isArgs;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isBoolean.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isBoolean(val) {
        return isKind(val, 'Boolean');
    }
    module.exports = isBoolean;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isDate(val) {
        return isKind(val, 'Date');
    }
    module.exports = isDate;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isEmpty.js":[function(require,module,exports){
var forOwn = require('../object/forOwn');
var isArray = require('./isArray');

    function isEmpty(val){
        if (val == null) {
            // typeof null == 'object' so we check it first
            return true;
        } else if ( typeof val === 'string' || isArray(val) ) {
            return !val.length;
        } else if ( typeof val === 'object' ) {
            var result = true;
            forOwn(val, function(){
                result = false;
                return false; // break loop
            });
            return result;
        } else {
            return true;
        }
    }

    module.exports = isEmpty;



},{"../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isFinite.js":[function(require,module,exports){
var isNumber = require('./isNumber');
var GLOBAL = require('./GLOBAL');

    /**
     * Check if value is finite
     */
    function isFinite(val){
        var is = false;
        if (typeof val === 'string' && val !== '') {
            is = GLOBAL.isFinite( parseFloat(val) );
        } else if (isNumber(val)){
            // need to use isNumber because of Number constructor
            is = GLOBAL.isFinite( val );
        }
        return is;
    }

    module.exports = isFinite;



},{"./GLOBAL":"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js","./isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isFunction(val) {
        return isKind(val, 'Function');
    }
    module.exports = isFunction;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isInteger.js":[function(require,module,exports){
var isNumber = require('./isNumber');

    /**
     * Check if value is an integer
     */
    function isInteger(val){
        return isNumber(val) && (val % 1 === 0);
    }

    module.exports = isInteger;



},{"./isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js":[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isNaN.js":[function(require,module,exports){
var isNumber = require('./isNumber');
var $isNaN = require('../number/isNaN');

    /**
     * Check if value is NaN for realz
     */
    function isNaN(val){
        // based on the fact that NaN !== NaN
        // need to check if it's a number to avoid conflicts with host objects
        // also need to coerce ToNumber to avoid edge case `new Number(NaN)`
        return !isNumber(val) || $isNaN(Number(val));
    }

    module.exports = isNaN;



},{"../number/isNaN":"/Users/luke/dev/040715/node_modules/mout/number/isNaN.js","./isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isNull.js":[function(require,module,exports){

    /**
     */
    function isNull(val){
        return val === null;
    }
    module.exports = isNull;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js":[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isPrimitive.js":[function(require,module,exports){


    /**
     * Checks if the object is a primitive
     */
    function isPrimitive(value) {
        // Using switch fallthrough because it's simple to read and is
        // generally fast: http://jsperf.com/testing-value-is-primitive/5
        switch (typeof value) {
            case "string":
            case "number":
            case "boolean":
                return true;
        }

        return value == null;
    }

    module.exports = isPrimitive;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isRegExp.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isString.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isString(val) {
        return isKind(val, 'String');
    }
    module.exports = isString;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isUndefined.js":[function(require,module,exports){

    var UNDEF;

    /**
     */
    function isUndef(val){
        return val === UNDEF;
    }
    module.exports = isUndef;


},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isnt.js":[function(require,module,exports){
var is = require('./is');

    /**
     * Check if both values are not identical/egal
     */
    function isnt(x, y){
        return !is(x, y);
    }

    module.exports = isnt;



},{"./is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js":[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js":[function(require,module,exports){
var kindOf = require('./kindOf');
var GLOBAL = require('./GLOBAL');

    /**
     * Convert array-like object into array
     */
    function toArray(val){
        var ret = [],
            kind = kindOf(val),
            n;

        if (val != null) {
            if ( val.length == null || kind === 'String' || kind === 'Function' || kind === 'RegExp' || val === GLOBAL ) {
                //string, regexp, function have .length but user probably just want
                //to wrap value into an array..
                ret[ret.length] = val;
            } else {
                //window returns true on isObject in IE7 and may have length
                //property. `typeof NodeList` returns `function` on Safari so
                //we can't use it (#58)
                n = val.length;
                while (n--) {
                    ret[n] = val[n];
                }
            }
        }
        return ret;
    }
    module.exports = toArray;


},{"./GLOBAL":"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js","./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js":[function(require,module,exports){
var isArray = require('./isArray');

    /**
     * covert value into number if numeric
     */
    function toNumber(val){
        // numberic values should come first because of -0
        if (typeof val === 'number') return val;
        // we want all falsy values (besides -0) to return zero to avoid
        // headaches
        if (!val) return 0;
        if (typeof val === 'string') return parseFloat(val);
        // arrays are edge cases. `Number([4]) === 4`
        if (isArray(val)) return NaN;
        return Number(val);
    }

    module.exports = toNumber;



},{"./isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/toString.js":[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],"/Users/luke/dev/040715/node_modules/mout/math.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'ceil' : require('./math/ceil'),
    'clamp' : require('./math/clamp'),
    'countSteps' : require('./math/countSteps'),
    'floor' : require('./math/floor'),
    'inRange' : require('./math/inRange'),
    'isNear' : require('./math/isNear'),
    'lerp' : require('./math/lerp'),
    'loop' : require('./math/loop'),
    'map' : require('./math/map'),
    'norm' : require('./math/norm'),
    'round' : require('./math/round')
};



},{"./math/ceil":"/Users/luke/dev/040715/node_modules/mout/math/ceil.js","./math/clamp":"/Users/luke/dev/040715/node_modules/mout/math/clamp.js","./math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js","./math/floor":"/Users/luke/dev/040715/node_modules/mout/math/floor.js","./math/inRange":"/Users/luke/dev/040715/node_modules/mout/math/inRange.js","./math/isNear":"/Users/luke/dev/040715/node_modules/mout/math/isNear.js","./math/lerp":"/Users/luke/dev/040715/node_modules/mout/math/lerp.js","./math/loop":"/Users/luke/dev/040715/node_modules/mout/math/loop.js","./math/map":"/Users/luke/dev/040715/node_modules/mout/math/map.js","./math/norm":"/Users/luke/dev/040715/node_modules/mout/math/norm.js","./math/round":"/Users/luke/dev/040715/node_modules/mout/math/round.js"}],"/Users/luke/dev/040715/node_modules/mout/math/ceil.js":[function(require,module,exports){

    /**
     * Round value up with a custom radix.
     */
    function ceil(val, step){
        step = Math.abs(step || 1);
        return Math.ceil(val / step) * step;
    }

    module.exports = ceil;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/clamp.js":[function(require,module,exports){

    /**
     * Clamps value inside range.
     */
    function clamp(val, min, max){
        return val < min? min : (val > max? max : val);
    }
    module.exports = clamp;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js":[function(require,module,exports){

    /**
    * Count number of full steps.
    */
    function countSteps(val, step, overflow){
        val = Math.floor(val / step);

        if (overflow) {
            return val % overflow;
        }

        return val;
    }

    module.exports = countSteps;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/floor.js":[function(require,module,exports){

    /**
    * Floor value to full steps.
    */
    function floor(val, step){
        step = Math.abs(step || 1);
        return Math.floor(val / step) * step;
    }
    module.exports = floor;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/inRange.js":[function(require,module,exports){

    /**
    * Checks if value is inside the range.
    */
    function inRange(val, min, max, threshold){
        threshold = threshold || 0;
        return (val + threshold >= min && val - threshold <= max);
    }

    module.exports = inRange;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/isNear.js":[function(require,module,exports){

    /**
    * Check if value is close to target.
    */
    function isNear(val, target, threshold){
        return (Math.abs(val - target) <= threshold);
    }
    module.exports = isNear;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/lerp.js":[function(require,module,exports){

    /**
    * Linear interpolation.
    * IMPORTANT:will return `Infinity` if numbers overflow Number.MAX_VALUE
    */
    function lerp(ratio, start, end){
        return start + (end - start) * ratio;
    }

    module.exports = lerp;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/loop.js":[function(require,module,exports){

    /**
    * Loops value inside range.
    */
    function loop(val, min, max){
        return val < min? max : (val > max? min : val);
    }

    module.exports = loop;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/map.js":[function(require,module,exports){
var lerp = require('./lerp');
var norm = require('./norm');
    /**
    * Maps a number from one scale to another.
    * @example map(3, 0, 4, -1, 1) -> 0.5
    */
    function map(val, min1, max1, min2, max2){
        return lerp( norm(val, min1, max1), min2, max2 );
    }
    module.exports = map;


},{"./lerp":"/Users/luke/dev/040715/node_modules/mout/math/lerp.js","./norm":"/Users/luke/dev/040715/node_modules/mout/math/norm.js"}],"/Users/luke/dev/040715/node_modules/mout/math/norm.js":[function(require,module,exports){

    /**
    * Gets normalized ratio of value inside range.
    */
    function norm(val, min, max){
        if (val < min || val > max) {
            throw new RangeError('value (' + val + ') must be between ' + min + ' and ' + max);
        }

        return val === max ? 1 : (val - min) / (max - min);
    }
    module.exports = norm;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/round.js":[function(require,module,exports){

    /**
     * Round number to a specific radix
     */
    function round(value, radix){
        radix = radix || 1; // default round 1
        return Math.round(value / radix) * radix;
    }

    module.exports = round;



},{}],"/Users/luke/dev/040715/node_modules/mout/number.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'MAX_INT' : require('./number/MAX_INT'),
    'MAX_SAFE_INTEGER' : require('./number/MAX_SAFE_INTEGER'),
    'MAX_UINT' : require('./number/MAX_UINT'),
    'MIN_INT' : require('./number/MIN_INT'),
    'abbreviate' : require('./number/abbreviate'),
    'currencyFormat' : require('./number/currencyFormat'),
    'enforcePrecision' : require('./number/enforcePrecision'),
    'isNaN' : require('./number/isNaN'),
    'nth' : require('./number/nth'),
    'ordinal' : require('./number/ordinal'),
    'pad' : require('./number/pad'),
    'rol' : require('./number/rol'),
    'ror' : require('./number/ror'),
    'sign' : require('./number/sign'),
    'toInt' : require('./number/toInt'),
    'toUInt' : require('./number/toUInt'),
    'toUInt31' : require('./number/toUInt31')
};



},{"./number/MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js","./number/MAX_SAFE_INTEGER":"/Users/luke/dev/040715/node_modules/mout/number/MAX_SAFE_INTEGER.js","./number/MAX_UINT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_UINT.js","./number/MIN_INT":"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js","./number/abbreviate":"/Users/luke/dev/040715/node_modules/mout/number/abbreviate.js","./number/currencyFormat":"/Users/luke/dev/040715/node_modules/mout/number/currencyFormat.js","./number/enforcePrecision":"/Users/luke/dev/040715/node_modules/mout/number/enforcePrecision.js","./number/isNaN":"/Users/luke/dev/040715/node_modules/mout/number/isNaN.js","./number/nth":"/Users/luke/dev/040715/node_modules/mout/number/nth.js","./number/ordinal":"/Users/luke/dev/040715/node_modules/mout/number/ordinal.js","./number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js","./number/rol":"/Users/luke/dev/040715/node_modules/mout/number/rol.js","./number/ror":"/Users/luke/dev/040715/node_modules/mout/number/ror.js","./number/sign":"/Users/luke/dev/040715/node_modules/mout/number/sign.js","./number/toInt":"/Users/luke/dev/040715/node_modules/mout/number/toInt.js","./number/toUInt":"/Users/luke/dev/040715/node_modules/mout/number/toUInt.js","./number/toUInt31":"/Users/luke/dev/040715/node_modules/mout/number/toUInt31.js"}],"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js":[function(require,module,exports){
/**
 * @constant Maximum 32-bit signed integer value. (2^31 - 1)
 */

    module.exports = 2147483647;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/MAX_SAFE_INTEGER.js":[function(require,module,exports){


    // maximum safe integer (Math.pow(2, 53) - 1)
    // see: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer
    module.exports = 9007199254740991;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/MAX_UINT.js":[function(require,module,exports){
/**
 * @constant Maximum 32-bit unsigned integet value (2^32 - 1)
 */

    module.exports = 4294967295;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js":[function(require,module,exports){
/**
 * @constant Minimum 32-bit signed integer value (-2^31).
 */

    module.exports = -2147483648;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/abbreviate.js":[function(require,module,exports){
var enforcePrecision = require('./enforcePrecision');

    var _defaultDict = {
        thousand : 'K',
        million : 'M',
        billion : 'B'
    };

    /**
     * Abbreviate number if bigger than 1000. (eg: 2.5K, 17.5M, 3.4B, ...)
     */
    function abbreviateNumber(val, nDecimals, dict){
        nDecimals = nDecimals != null? nDecimals : 1;
        dict = dict || _defaultDict;
        val = enforcePrecision(val, nDecimals);

        var str, mod;

        if (val < 1000000) {
            mod = enforcePrecision(val / 1000, nDecimals);
            // might overflow to next scale during rounding
            str = mod < 1000? mod + dict.thousand : 1 + dict.million;
        } else if (val < 1000000000) {
            mod = enforcePrecision(val / 1000000, nDecimals);
            str = mod < 1000? mod + dict.million : 1 + dict.billion;
        } else {
            str = enforcePrecision(val / 1000000000, nDecimals) + dict.billion;
        }

        return str;
    }

    module.exports = abbreviateNumber;



},{"./enforcePrecision":"/Users/luke/dev/040715/node_modules/mout/number/enforcePrecision.js"}],"/Users/luke/dev/040715/node_modules/mout/number/currencyFormat.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');

    /**
     * Converts number into currency format
     */
    function currencyFormat(val, nDecimalDigits, decimalSeparator, thousandsSeparator) {
        val = toNumber(val);
        nDecimalDigits = nDecimalDigits == null? 2 : nDecimalDigits;
        decimalSeparator = decimalSeparator == null? '.' : decimalSeparator;
        thousandsSeparator = thousandsSeparator == null? ',' : thousandsSeparator;

        //can't use enforce precision since it returns a number and we are
        //doing a RegExp over the string
        var fixed = val.toFixed(nDecimalDigits),
            //separate begin [$1], middle [$2] and decimal digits [$4]
            parts = new RegExp('^(-?\\d{1,3})((?:\\d{3})+)(\\.(\\d{'+ nDecimalDigits +'}))?$').exec( fixed );

        if(parts){ //val >= 1000 || val <= -1000
            return parts[1] + parts[2].replace(/\d{3}/g, thousandsSeparator + '$&') + (parts[4] ? decimalSeparator + parts[4] : '');
        }else{
            return fixed.replace('.', decimalSeparator);
        }
    }

    module.exports = currencyFormat;



},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/number/enforcePrecision.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');
    /**
     * Enforce a specific amount of decimal digits and also fix floating
     * point rounding issues.
     */
    function enforcePrecision(val, nDecimalDigits){
        val = toNumber(val);
        var pow = Math.pow(10, nDecimalDigits);
        return +(Math.round(val * pow) / pow).toFixed(nDecimalDigits);
    }
    module.exports = enforcePrecision;


},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/number/isNaN.js":[function(require,module,exports){


    /**
     * ES6 Number.isNaN
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
     */
    function isNaN(val){
        // jshint eqeqeq:false
        return typeof val === 'number' && val != val;
    }

    module.exports = isNaN;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/nth.js":[function(require,module,exports){


    /**
     * Returns "nth" of number (1 = "st", 2 = "nd", 3 = "rd", 4..10 = "th", ...)
     */
    function nth(i) {
        var t = (i % 100);
        if (t >= 10 && t <= 20) {
            return 'th';
        }
        switch(i % 10) {
            case 1:
                return 'st';
            case 2:
                return 'nd';
            case 3:
                return 'rd';
            default:
                return 'th';
        }
    }

    module.exports = nth;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/ordinal.js":[function(require,module,exports){
var toInt = require('./toInt');
var nth = require('./nth');

    /**
     * converts number into ordinal form (1st, 2nd, 3rd, 4th, ...)
     */
    function ordinal(n){
       n = toInt(n);
       return n + nth(n);
    }

    module.exports = ordinal;



},{"./nth":"/Users/luke/dev/040715/node_modules/mout/number/nth.js","./toInt":"/Users/luke/dev/040715/node_modules/mout/number/toInt.js"}],"/Users/luke/dev/040715/node_modules/mout/number/pad.js":[function(require,module,exports){
var lpad = require('../string/lpad');
var toNumber = require('../lang/toNumber');

    /**
     * Add padding zeros if n.length < minLength.
     */
    function pad(n, minLength, char){
        n = toNumber(n);
        return lpad(''+ n, minLength, char || '0');
    }

    module.exports = pad;



},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js","../string/lpad":"/Users/luke/dev/040715/node_modules/mout/string/lpad.js"}],"/Users/luke/dev/040715/node_modules/mout/number/rol.js":[function(require,module,exports){

    /**
     * Bitwise circular shift left
     * http://en.wikipedia.org/wiki/Circular_shift
     */
    function rol(val, shift){
        return (val << shift) | (val >> (32 - shift));
    }
    module.exports = rol;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/ror.js":[function(require,module,exports){

    /**
     * Bitwise circular shift right
     * http://en.wikipedia.org/wiki/Circular_shift
     */
    function ror(val, shift){
        return (val >> shift) | (val << (32 - shift));
    }
    module.exports = ror;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/sign.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');

    /**
     * Get sign of the value.
     */
    function sign(val) {
        var num = toNumber(val);
        if (num === 0) return num; // +0 and +0 === 0
        if (isNaN(num)) return num; // NaN
        return num < 0? -1 : 1;
    }

    module.exports = sign;



},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/number/toInt.js":[function(require,module,exports){


    /**
     * "Convert" value into an 32-bit integer.
     * Works like `Math.floor` if val > 0 and `Math.ceil` if val < 0.
     * IMPORTANT: val will wrap at 2^31 and -2^31.
     * Perf tests: http://jsperf.com/vs-vs-parseint-bitwise-operators/7
     */
    function toInt(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return ~~val;
    }

    module.exports = toInt;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/toUInt.js":[function(require,module,exports){


    /**
     * "Convert" value into a 32-bit unsigned integer.
     * IMPORTANT: Value will wrap at 2^32.
     */
    function toUInt(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return val >>> 0;
    }

    module.exports = toUInt;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/toUInt31.js":[function(require,module,exports){
var MAX_INT = require('./MAX_INT');

    /**
     * "Convert" value into an 31-bit unsigned integer (since 1 bit is used for sign).
     * IMPORTANT: value wil wrap at 2^31, if negative will return 0.
     */
    function toUInt31(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return (val <= 0)? 0 : (val > MAX_INT? ~~(val % (MAX_INT + 1)) : ~~val);
    }

    module.exports = toUInt31;



},{"./MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js"}],"/Users/luke/dev/040715/node_modules/mout/object.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'bindAll' : require('./object/bindAll'),
    'contains' : require('./object/contains'),
    'deepFillIn' : require('./object/deepFillIn'),
    'deepMatches' : require('./object/deepMatches'),
    'deepMixIn' : require('./object/deepMixIn'),
    'equals' : require('./object/equals'),
    'every' : require('./object/every'),
    'fillIn' : require('./object/fillIn'),
    'filter' : require('./object/filter'),
    'find' : require('./object/find'),
    'forIn' : require('./object/forIn'),
    'forOwn' : require('./object/forOwn'),
    'functions' : require('./object/functions'),
    'get' : require('./object/get'),
    'has' : require('./object/has'),
    'hasOwn' : require('./object/hasOwn'),
    'keys' : require('./object/keys'),
    'map' : require('./object/map'),
    'matches' : require('./object/matches'),
    'max' : require('./object/max'),
    'merge' : require('./object/merge'),
    'min' : require('./object/min'),
    'mixIn' : require('./object/mixIn'),
    'namespace' : require('./object/namespace'),
    'omit' : require('./object/omit'),
    'pick' : require('./object/pick'),
    'pluck' : require('./object/pluck'),
    'reduce' : require('./object/reduce'),
    'reject' : require('./object/reject'),
    'result' : require('./object/result'),
    'set' : require('./object/set'),
    'size' : require('./object/size'),
    'some' : require('./object/some'),
    'unset' : require('./object/unset'),
    'values' : require('./object/values')
};



},{"./object/bindAll":"/Users/luke/dev/040715/node_modules/mout/object/bindAll.js","./object/contains":"/Users/luke/dev/040715/node_modules/mout/object/contains.js","./object/deepFillIn":"/Users/luke/dev/040715/node_modules/mout/object/deepFillIn.js","./object/deepMatches":"/Users/luke/dev/040715/node_modules/mout/object/deepMatches.js","./object/deepMixIn":"/Users/luke/dev/040715/node_modules/mout/object/deepMixIn.js","./object/equals":"/Users/luke/dev/040715/node_modules/mout/object/equals.js","./object/every":"/Users/luke/dev/040715/node_modules/mout/object/every.js","./object/fillIn":"/Users/luke/dev/040715/node_modules/mout/object/fillIn.js","./object/filter":"/Users/luke/dev/040715/node_modules/mout/object/filter.js","./object/find":"/Users/luke/dev/040715/node_modules/mout/object/find.js","./object/forIn":"/Users/luke/dev/040715/node_modules/mout/object/forIn.js","./object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./object/functions":"/Users/luke/dev/040715/node_modules/mout/object/functions.js","./object/get":"/Users/luke/dev/040715/node_modules/mout/object/get.js","./object/has":"/Users/luke/dev/040715/node_modules/mout/object/has.js","./object/hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js","./object/keys":"/Users/luke/dev/040715/node_modules/mout/object/keys.js","./object/map":"/Users/luke/dev/040715/node_modules/mout/object/map.js","./object/matches":"/Users/luke/dev/040715/node_modules/mout/object/matches.js","./object/max":"/Users/luke/dev/040715/node_modules/mout/object/max.js","./object/merge":"/Users/luke/dev/040715/node_modules/mout/object/merge.js","./object/min":"/Users/luke/dev/040715/node_modules/mout/object/min.js","./object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js","./object/namespace":"/Users/luke/dev/040715/node_modules/mout/object/namespace.js","./object/omit":"/Users/luke/dev/040715/node_modules/mout/object/omit.js","./object/pick":"/Users/luke/dev/040715/node_modules/mout/object/pick.js","./object/pluck":"/Users/luke/dev/040715/node_modules/mout/object/pluck.js","./object/reduce":"/Users/luke/dev/040715/node_modules/mout/object/reduce.js","./object/reject":"/Users/luke/dev/040715/node_modules/mout/object/reject.js","./object/result":"/Users/luke/dev/040715/node_modules/mout/object/result.js","./object/set":"/Users/luke/dev/040715/node_modules/mout/object/set.js","./object/size":"/Users/luke/dev/040715/node_modules/mout/object/size.js","./object/some":"/Users/luke/dev/040715/node_modules/mout/object/some.js","./object/unset":"/Users/luke/dev/040715/node_modules/mout/object/unset.js","./object/values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/object/bindAll.js":[function(require,module,exports){
var functions = require('./functions');
var bind = require('../function/bind');
var forEach = require('../array/forEach');
var slice = require('../array/slice');

    /**
     * Binds methods of the object to be run in it's own context.
     */
    function bindAll(obj, rest_methodNames){
        var keys = arguments.length > 1?
                    slice(arguments, 1) : functions(obj);
        forEach(keys, function(key){
            obj[key] = bind(obj[key], obj);
        });
    }

    module.exports = bindAll;



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","../function/bind":"/Users/luke/dev/040715/node_modules/mout/function/bind.js","./functions":"/Users/luke/dev/040715/node_modules/mout/object/functions.js"}],"/Users/luke/dev/040715/node_modules/mout/object/contains.js":[function(require,module,exports){
var some = require('./some');

    /**
     * Check if object contains value
     */
    function contains(obj, needle) {
        return some(obj, function(val) {
            return (val === needle);
        });
    }
    module.exports = contains;



},{"./some":"/Users/luke/dev/040715/node_modules/mout/object/some.js"}],"/Users/luke/dev/040715/node_modules/mout/object/deepFillIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/deepMatches.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/deepMixIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/equals.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","../lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","./every":"/Users/luke/dev/040715/node_modules/mout/object/every.js","./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/every.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/fillIn.js":[function(require,module,exports){
var forEach = require('../array/forEach');
var slice = require('../array/slice');
var forOwn = require('./forOwn');

    /**
     * Copy missing properties in the obj from the defaults.
     */
    function fillIn(obj, var_defaults){
        forEach(slice(arguments, 1), function(base){
            forOwn(base, function(val, key){
                if (obj[key] == null) {
                    obj[key] = val;
                }
            });
        });
        return obj;
    }

    module.exports = fillIn;



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/filter.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Creates a new object with all the properties where the callback returns
     * true.
     */
    function filterValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(value, key, obj) {
            if (callback(value, key, obj)) {
                output[key] = value;
            }
        });

        return output;
    }
    module.exports = filterValues;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/find.js":[function(require,module,exports){
var some = require('./some');
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns first item that matches criteria
     */
    function find(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result;
        some(obj, function(value, key, obj) {
            if (callback(value, key, obj)) {
                result = value;
                return true; //break
            }
        });
        return result;
    }

    module.exports = find;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./some":"/Users/luke/dev/040715/node_modules/mout/object/some.js"}],"/Users/luke/dev/040715/node_modules/mout/object/forIn.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":"/Users/luke/dev/040715/node_modules/mout/object/forIn.js","./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/functions.js":[function(require,module,exports){
var forIn = require('./forIn');

    /**
     * return a list of all enumerable properties that have function values
     */
    function functions(obj){
        var keys = [];
        forIn(obj, function(val, key){
            if (typeof val === 'function'){
                keys.push(key);
            }
        });
        return keys.sort();
    }

    module.exports = functions;



},{"./forIn":"/Users/luke/dev/040715/node_modules/mout/object/forIn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/get.js":[function(require,module,exports){
var isPrimitive = require('../lang/isPrimitive');

    /**
     * get "nested" object property
     */
    function get(obj, prop){
        var parts = prop.split('.'),
            last = parts.pop();

        while (prop = parts.shift()) {
            obj = obj[prop];
            if (obj == null) return;
        }

        return obj[last];
    }

    module.exports = get;



},{"../lang/isPrimitive":"/Users/luke/dev/040715/node_modules/mout/lang/isPrimitive.js"}],"/Users/luke/dev/040715/node_modules/mout/object/has.js":[function(require,module,exports){
var get = require('./get');

    var UNDEF;

    /**
     * Check if object has nested property.
     */
    function has(obj, prop){
        return get(obj, prop) !== UNDEF;
    }

    module.exports = has;




},{"./get":"/Users/luke/dev/040715/node_modules/mout/object/get.js"}],"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js":[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],"/Users/luke/dev/040715/node_modules/mout/object/keys.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/map.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Creates a new object where all the values are the result of calling
     * `callback`.
     */
    function mapValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(val, key, obj) {
            output[key] = callback(val, key, obj);
        });

        return output;
    }
    module.exports = mapValues;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/matches.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * checks if a object contains all given properties/values
     */
    function matches(target, props){
        // can't use "object/every" because of circular dependency
        var result = true;
        forOwn(props, function(val, key){
            if (target[key] !== val) {
                // break loop at first difference
                return (result = false);
            }
        });
        return result;
    }

    module.exports = matches;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/max.js":[function(require,module,exports){
var arrMax = require('../array/max');
var values = require('./values');

    /**
     * Returns maximum value inside object.
     */
    function max(obj, compareFn) {
        return arrMax(values(obj), compareFn);
    }

    module.exports = max;


},{"../array/max":"/Users/luke/dev/040715/node_modules/mout/array/max.js","./values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/object/merge.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":"/Users/luke/dev/040715/node_modules/mout/lang/deepClone.js","../lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/min.js":[function(require,module,exports){
var arrMin = require('../array/min');
var values = require('./values');

    /**
     * Returns minimum value inside object.
     */
    function min(obj, iterator) {
        return arrMin(values(obj), iterator);
    }

    module.exports = min;


},{"../array/min":"/Users/luke/dev/040715/node_modules/mout/array/min.js","./values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/namespace.js":[function(require,module,exports){
var forEach = require('../array/forEach');

    /**
     * Create nested object if non-existent
     */
    function namespace(obj, path){
        if (!path) return obj;
        forEach(path.split('.'), function(key){
            if (!obj[key]) {
                obj[key] = {};
            }
            obj = obj[key];
        });
        return obj;
    }

    module.exports = namespace;



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js"}],"/Users/luke/dev/040715/node_modules/mout/object/omit.js":[function(require,module,exports){
var slice = require('../array/slice');
var contains = require('../array/contains');

    /**
     * Return a copy of the object, filtered to only contain properties except the blacklisted keys.
     */
    function omit(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {};

        for (var property in obj) {
            if (obj.hasOwnProperty(property) && !contains(keys, property)) {
                out[property] = obj[property];
            }
        }
        return out;
    }

    module.exports = omit;



},{"../array/contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/object/pick.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/object/pluck.js":[function(require,module,exports){
var map = require('./map');
var prop = require('../function/prop');

    /**
     * Extract a list of property values.
     */
    function pluck(obj, propName){
        return map(obj, prop(propName));
    }

    module.exports = pluck;



},{"../function/prop":"/Users/luke/dev/040715/node_modules/mout/function/prop.js","./map":"/Users/luke/dev/040715/node_modules/mout/object/map.js"}],"/Users/luke/dev/040715/node_modules/mout/object/reduce.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var size = require('./size');

    /**
     * Object reduce
     */
    function reduce(obj, callback, memo, thisObj) {
        var initial = arguments.length > 2;

        if (!size(obj) && !initial) {
            throw new Error('reduce of empty object with no initial value');
        }

        forOwn(obj, function(value, key, list) {
            if (!initial) {
                memo = value;
                initial = true;
            }
            else {
                memo = callback.call(thisObj, memo, value, key, list);
            }
        });

        return memo;
    }

    module.exports = reduce;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./size":"/Users/luke/dev/040715/node_modules/mout/object/size.js"}],"/Users/luke/dev/040715/node_modules/mout/object/reject.js":[function(require,module,exports){
var filter = require('./filter');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object reject
     */
    function reject(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        return filter(obj, function(value, index, obj) {
            return !callback(value, index, obj);
        }, thisObj);
    }

    module.exports = reject;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./filter":"/Users/luke/dev/040715/node_modules/mout/object/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/object/result.js":[function(require,module,exports){
var isFunction = require('../lang/isFunction');

    function result(obj, prop) {
        var property = obj[prop];

        if(property === undefined) {
            return;
        }

        return isFunction(property) ? property.call(obj) : property;
    }

    module.exports = result;


},{"../lang/isFunction":"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js"}],"/Users/luke/dev/040715/node_modules/mout/object/set.js":[function(require,module,exports){
var namespace = require('./namespace');

    /**
     * set "nested" object property
     */
    function set(obj, prop, val){
        var parts = (/^(.+)\.(.+)$/).exec(prop);
        if (parts){
            namespace(obj, parts[1])[parts[2]] = val;
        } else {
            obj[prop] = val;
        }
    }

    module.exports = set;



},{"./namespace":"/Users/luke/dev/040715/node_modules/mout/object/namespace.js"}],"/Users/luke/dev/040715/node_modules/mout/object/size.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object size
     */
    function size(obj) {
        var count = 0;
        forOwn(obj, function(){
            count++;
        });
        return count;
    }

    module.exports = size;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/some.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object some
     */
    function some(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        forOwn(obj, function(val, key) {
            if (callback(val, key, obj)) {
                result = true;
                return false; // break
            }
        });
        return result;
    }

    module.exports = some;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/unset.js":[function(require,module,exports){
var has = require('./has');

    /**
     * Unset object property.
     */
    function unset(obj, prop){
        if (has(obj, prop)) {
            var parts = prop.split('.'),
                last = parts.pop();
            while (prop = parts.shift()) {
                obj = obj[prop];
            }
            return (delete obj[last]);

        } else {
            // if property doesn't exist treat as deleted
            return true;
        }
    }

    module.exports = unset;



},{"./has":"/Users/luke/dev/040715/node_modules/mout/object/has.js"}],"/Users/luke/dev/040715/node_modules/mout/object/values.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'contains' : require('./queryString/contains'),
    'decode' : require('./queryString/decode'),
    'encode' : require('./queryString/encode'),
    'getParam' : require('./queryString/getParam'),
    'getQuery' : require('./queryString/getQuery'),
    'parse' : require('./queryString/parse'),
    'setParam' : require('./queryString/setParam')
};



},{"./queryString/contains":"/Users/luke/dev/040715/node_modules/mout/queryString/contains.js","./queryString/decode":"/Users/luke/dev/040715/node_modules/mout/queryString/decode.js","./queryString/encode":"/Users/luke/dev/040715/node_modules/mout/queryString/encode.js","./queryString/getParam":"/Users/luke/dev/040715/node_modules/mout/queryString/getParam.js","./queryString/getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js","./queryString/parse":"/Users/luke/dev/040715/node_modules/mout/queryString/parse.js","./queryString/setParam":"/Users/luke/dev/040715/node_modules/mout/queryString/setParam.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/contains.js":[function(require,module,exports){
var getQuery = require('./getQuery');

    /**
     * Checks if query string contains parameter.
     */
    function contains(url, paramName) {
        var regex = new RegExp('(\\?|&)'+ paramName +'=', 'g'); //matches `?param=` or `&param=`
        return regex.test(getQuery(url));
    }

    module.exports = contains;


},{"./getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/decode.js":[function(require,module,exports){
var typecast = require('../string/typecast');
var isString = require('../lang/isString');
var isArray = require('../lang/isArray');
var hasOwn = require('../object/hasOwn');

    /**
     * Decode query string into an object of keys => vals.
     */
    function decode(queryStr, shouldTypecast) {
        var queryArr = (queryStr || '').replace('?', '').split('&'),
            count = -1,
            length = queryArr.length,
            obj = {},
            item, pValue, pName, toSet;

        while (++count < length) {
            item = queryArr[count].split('=');
            pName = item[0];
            if (!pName || !pName.length){
                continue;
            }
            pValue = shouldTypecast === false ? item[1] : typecast(item[1]);
            toSet = isString(pValue) ? decodeURIComponent(pValue) : pValue;
            if (hasOwn(obj,pName)){
                if(isArray(obj[pName])){
                    obj[pName].push(toSet);
                } else {
                    obj[pName] = [obj[pName],toSet];
                }
            } else {
                obj[pName] = toSet;
           }
        }
        return obj;
    }

    module.exports = decode;


},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","../lang/isString":"/Users/luke/dev/040715/node_modules/mout/lang/isString.js","../object/hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js","../string/typecast":"/Users/luke/dev/040715/node_modules/mout/string/typecast.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/encode.js":[function(require,module,exports){
var forOwn = require('../object/forOwn');
var isArray = require('../lang/isArray');
var forEach = require('../array/forEach');

    /**
     * Encode object into a query string.
     */
    function encode(obj){
        var query = [],
            arrValues, reg;
        forOwn(obj, function (val, key) {
            if (isArray(val)) {
                arrValues = key + '=';
                reg = new RegExp('&'+key+'+=$');
                forEach(val, function (aValue) {
                    arrValues += encodeURIComponent(aValue) + '&' + key + '=';
                });
                query.push(arrValues.replace(reg, ''));
            } else {
               query.push(key + '=' + encodeURIComponent(val));
            }
        });
        return (query.length) ? '?' + query.join('&') : '';
    }

    module.exports = encode;


},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/getParam.js":[function(require,module,exports){
var typecast = require('../string/typecast');
var getQuery = require('./getQuery');

    /**
     * Get query parameter value.
     */
    function getParam(url, param, shouldTypecast){
        var regexp = new RegExp('(\\?|&)'+ param + '=([^&]*)'), //matches `?param=value` or `&param=value`, value = $2
            result = regexp.exec( getQuery(url) ),
            val = (result && result[2])? result[2] : null;
        return shouldTypecast === false? val : typecast(val);
    }

    module.exports = getParam;


},{"../string/typecast":"/Users/luke/dev/040715/node_modules/mout/string/typecast.js","./getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js":[function(require,module,exports){


    /**
     * Gets full query as string with all special chars decoded.
     */
    function getQuery(url) {
        url = url.replace(/#.*/, ''); //removes hash (to avoid getting hash query)
        var queryString = /\?[a-zA-Z0-9\=\&\%\$\-\_\.\+\!\*\'\(\)\,]+/.exec(url); //valid chars according to: http://www.ietf.org/rfc/rfc1738.txt
        return (queryString)? decodeURIComponent(queryString[0]) : '';
    }

    module.exports = getQuery;


},{}],"/Users/luke/dev/040715/node_modules/mout/queryString/parse.js":[function(require,module,exports){
var decode = require('./decode');
var getQuery = require('./getQuery');

    /**
     * Get query string, parses and decodes it.
     */
    function parse(url, shouldTypecast) {
        return decode(getQuery(url), shouldTypecast);
    }

    module.exports = parse;



},{"./decode":"/Users/luke/dev/040715/node_modules/mout/queryString/decode.js","./getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/setParam.js":[function(require,module,exports){


    /**
     * Set query string parameter value
     */
    function setParam(url, paramName, value){
        url = url || '';

        var re = new RegExp('(\\?|&)'+ paramName +'=[^&]*' );
        var param = paramName +'='+ encodeURIComponent( value );

        if ( re.test(url) ) {
            return url.replace(re, '$1'+ param);
        } else {
            if (url.indexOf('?') === -1) {
                url += '?';
            }
            if (url.indexOf('=') !== -1) {
                url += '&';
            }
            return url + param;
        }

    }

    module.exports = setParam;



},{}],"/Users/luke/dev/040715/node_modules/mout/random.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'choice' : require('./random/choice'),
    'guid' : require('./random/guid'),
    'rand' : require('./random/rand'),
    'randBit' : require('./random/randBit'),
    'randBool' : require('./random/randBool'),
    'randHex' : require('./random/randHex'),
    'randInt' : require('./random/randInt'),
    'randSign' : require('./random/randSign'),
    'randString' : require('./random/randString'),
    'random' : require('./random/random')
};



},{"./random/choice":"/Users/luke/dev/040715/node_modules/mout/random/choice.js","./random/guid":"/Users/luke/dev/040715/node_modules/mout/random/guid.js","./random/rand":"/Users/luke/dev/040715/node_modules/mout/random/rand.js","./random/randBit":"/Users/luke/dev/040715/node_modules/mout/random/randBit.js","./random/randBool":"/Users/luke/dev/040715/node_modules/mout/random/randBool.js","./random/randHex":"/Users/luke/dev/040715/node_modules/mout/random/randHex.js","./random/randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js","./random/randSign":"/Users/luke/dev/040715/node_modules/mout/random/randSign.js","./random/randString":"/Users/luke/dev/040715/node_modules/mout/random/randString.js","./random/random":"/Users/luke/dev/040715/node_modules/mout/random/random.js"}],"/Users/luke/dev/040715/node_modules/mout/random/choice.js":[function(require,module,exports){
var randInt = require('./randInt');
var isArray = require('../lang/isArray');

    /**
     * Returns a random element from the supplied arguments
     * or from the array (if single argument is an array).
     */
    function choice(items) {
        var target = (arguments.length === 1 && isArray(items))? items : arguments;
        return target[ randInt(0, target.length - 1) ];
    }

    module.exports = choice;



},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/random/guid.js":[function(require,module,exports){
var randHex = require('./randHex');
var choice = require('./choice');

  /**
   * Returns pseudo-random guid (UUID v4)
   * IMPORTANT: it's not totally "safe" since randHex/choice uses Math.random
   * by default and sequences can be predicted in some cases. See the
   * "random/random" documentation for more info about it and how to replace
   * the default PRNG.
   */
  function guid() {
    return (
        randHex(8)+'-'+
        randHex(4)+'-'+
        // v4 UUID always contain "4" at this position to specify it was
        // randomly generated
        '4' + randHex(3) +'-'+
        // v4 UUID always contain chars [a,b,8,9] at this position
        choice(8, 9, 'a', 'b') + randHex(3)+'-'+
        randHex(12)
    );
  }
  module.exports = guid;


},{"./choice":"/Users/luke/dev/040715/node_modules/mout/random/choice.js","./randHex":"/Users/luke/dev/040715/node_modules/mout/random/randHex.js"}],"/Users/luke/dev/040715/node_modules/mout/random/rand.js":[function(require,module,exports){
var random = require('./random');
var MIN_INT = require('../number/MIN_INT');
var MAX_INT = require('../number/MAX_INT');

    /**
     * Returns random number inside range
     */
    function rand(min, max){
        min = min == null? MIN_INT : min;
        max = max == null? MAX_INT : max;
        return min + (max - min) * random();
    }

    module.exports = rand;


},{"../number/MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js","../number/MIN_INT":"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js","./random":"/Users/luke/dev/040715/node_modules/mout/random/random.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randBit.js":[function(require,module,exports){
var randBool = require('./randBool');

    /**
     * Returns random bit (0 or 1)
     */
    function randomBit() {
        return randBool()? 1 : 0;
    }

    module.exports = randomBit;


},{"./randBool":"/Users/luke/dev/040715/node_modules/mout/random/randBool.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randBool.js":[function(require,module,exports){
var random = require('./random');

    /**
     * returns a random boolean value (true or false)
     */
    function randBool(){
        return random() >= 0.5;
    }

    module.exports = randBool;



},{"./random":"/Users/luke/dev/040715/node_modules/mout/random/random.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randHex.js":[function(require,module,exports){
var choice = require('./choice');

    var _chars = '0123456789abcdef'.split('');

    /**
     * Returns a random hexadecimal string
     */
    function randHex(size){
        size = size && size > 0? size : 6;
        var str = '';
        while (size--) {
            str += choice(_chars);
        }
        return str;
    }

    module.exports = randHex;



},{"./choice":"/Users/luke/dev/040715/node_modules/mout/random/choice.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randInt.js":[function(require,module,exports){
var MIN_INT = require('../number/MIN_INT');
var MAX_INT = require('../number/MAX_INT');
var rand = require('./rand');

    /**
     * Gets random integer inside range or snap to min/max values.
     */
    function randInt(min, max){
        min = min == null? MIN_INT : ~~min;
        max = max == null? MAX_INT : ~~max;
        // can't be max + 0.5 otherwise it will round up if `rand`
        // returns `max` causing it to overflow range.
        // -0.5 and + 0.49 are required to avoid bias caused by rounding
        return Math.round( rand(min - 0.5, max + 0.499999999999) );
    }

    module.exports = randInt;


},{"../number/MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js","../number/MIN_INT":"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js","./rand":"/Users/luke/dev/040715/node_modules/mout/random/rand.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randSign.js":[function(require,module,exports){
var randBool = require('./randBool');

    /**
     * Returns random sign (-1 or 1)
     */
    function randomSign() {
        return randBool()? 1 : -1;
    }

    module.exports = randomSign;


},{"./randBool":"/Users/luke/dev/040715/node_modules/mout/random/randBool.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randString.js":[function(require,module,exports){
var isNumber = require('../lang/isNumber');
var isString = require('../lang/isString');
var randInt = require('./randInt');

    var defaultDictionary = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    function randomString(length, dictionary) {
        if(!isNumber(length) || length <= 0) {
          length = 8;
        }

        if(!isString(dictionary) || dictionary.length < 1) {
          dictionary = defaultDictionary;
        }

        var result = '',
            domain = dictionary.length - 1;

        while(length--) {
          result += dictionary[randInt(0, domain)];
        }
        
        return result;
    }

    module.exports = randomString;


},{"../lang/isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js","../lang/isString":"/Users/luke/dev/040715/node_modules/mout/lang/isString.js","./randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/random/random.js":[function(require,module,exports){


    /**
     * Just a wrapper to Math.random. No methods inside mout/random should call
     * Math.random() directly so we can inject the pseudo-random number
     * generator if needed (ie. in case we need a seeded random or a better
     * algorithm than the native one)
     */
    function random(){
        return random.get();
    }

    // we expose the method so it can be swapped if needed
    random.get = Math.random;

    module.exports = random;



},{}],"/Users/luke/dev/040715/node_modules/mout/string.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'WHITE_SPACES' : require('./string/WHITE_SPACES'),
    'camelCase' : require('./string/camelCase'),
    'contains' : require('./string/contains'),
    'crop' : require('./string/crop'),
    'endsWith' : require('./string/endsWith'),
    'escapeHtml' : require('./string/escapeHtml'),
    'escapeRegExp' : require('./string/escapeRegExp'),
    'escapeUnicode' : require('./string/escapeUnicode'),
    'hyphenate' : require('./string/hyphenate'),
    'insert' : require('./string/insert'),
    'interpolate' : require('./string/interpolate'),
    'lowerCase' : require('./string/lowerCase'),
    'lpad' : require('./string/lpad'),
    'ltrim' : require('./string/ltrim'),
    'makePath' : require('./string/makePath'),
    'normalizeLineBreaks' : require('./string/normalizeLineBreaks'),
    'pascalCase' : require('./string/pascalCase'),
    'properCase' : require('./string/properCase'),
    'removeNonASCII' : require('./string/removeNonASCII'),
    'removeNonWord' : require('./string/removeNonWord'),
    'repeat' : require('./string/repeat'),
    'replace' : require('./string/replace'),
    'replaceAccents' : require('./string/replaceAccents'),
    'rpad' : require('./string/rpad'),
    'rtrim' : require('./string/rtrim'),
    'sentenceCase' : require('./string/sentenceCase'),
    'slugify' : require('./string/slugify'),
    'startsWith' : require('./string/startsWith'),
    'stripHtmlTags' : require('./string/stripHtmlTags'),
    'trim' : require('./string/trim'),
    'truncate' : require('./string/truncate'),
    'typecast' : require('./string/typecast'),
    'unCamelCase' : require('./string/unCamelCase'),
    'underscore' : require('./string/underscore'),
    'unescapeHtml' : require('./string/unescapeHtml'),
    'unescapeUnicode' : require('./string/unescapeUnicode'),
    'unhyphenate' : require('./string/unhyphenate'),
    'upperCase' : require('./string/upperCase')
};



},{"./string/WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js","./string/camelCase":"/Users/luke/dev/040715/node_modules/mout/string/camelCase.js","./string/contains":"/Users/luke/dev/040715/node_modules/mout/string/contains.js","./string/crop":"/Users/luke/dev/040715/node_modules/mout/string/crop.js","./string/endsWith":"/Users/luke/dev/040715/node_modules/mout/string/endsWith.js","./string/escapeHtml":"/Users/luke/dev/040715/node_modules/mout/string/escapeHtml.js","./string/escapeRegExp":"/Users/luke/dev/040715/node_modules/mout/string/escapeRegExp.js","./string/escapeUnicode":"/Users/luke/dev/040715/node_modules/mout/string/escapeUnicode.js","./string/hyphenate":"/Users/luke/dev/040715/node_modules/mout/string/hyphenate.js","./string/insert":"/Users/luke/dev/040715/node_modules/mout/string/insert.js","./string/interpolate":"/Users/luke/dev/040715/node_modules/mout/string/interpolate.js","./string/lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./string/lpad":"/Users/luke/dev/040715/node_modules/mout/string/lpad.js","./string/ltrim":"/Users/luke/dev/040715/node_modules/mout/string/ltrim.js","./string/makePath":"/Users/luke/dev/040715/node_modules/mout/string/makePath.js","./string/normalizeLineBreaks":"/Users/luke/dev/040715/node_modules/mout/string/normalizeLineBreaks.js","./string/pascalCase":"/Users/luke/dev/040715/node_modules/mout/string/pascalCase.js","./string/properCase":"/Users/luke/dev/040715/node_modules/mout/string/properCase.js","./string/removeNonASCII":"/Users/luke/dev/040715/node_modules/mout/string/removeNonASCII.js","./string/removeNonWord":"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js","./string/repeat":"/Users/luke/dev/040715/node_modules/mout/string/repeat.js","./string/replace":"/Users/luke/dev/040715/node_modules/mout/string/replace.js","./string/replaceAccents":"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js","./string/rpad":"/Users/luke/dev/040715/node_modules/mout/string/rpad.js","./string/rtrim":"/Users/luke/dev/040715/node_modules/mout/string/rtrim.js","./string/sentenceCase":"/Users/luke/dev/040715/node_modules/mout/string/sentenceCase.js","./string/slugify":"/Users/luke/dev/040715/node_modules/mout/string/slugify.js","./string/startsWith":"/Users/luke/dev/040715/node_modules/mout/string/startsWith.js","./string/stripHtmlTags":"/Users/luke/dev/040715/node_modules/mout/string/stripHtmlTags.js","./string/trim":"/Users/luke/dev/040715/node_modules/mout/string/trim.js","./string/truncate":"/Users/luke/dev/040715/node_modules/mout/string/truncate.js","./string/typecast":"/Users/luke/dev/040715/node_modules/mout/string/typecast.js","./string/unCamelCase":"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js","./string/underscore":"/Users/luke/dev/040715/node_modules/mout/string/underscore.js","./string/unescapeHtml":"/Users/luke/dev/040715/node_modules/mout/string/unescapeHtml.js","./string/unescapeUnicode":"/Users/luke/dev/040715/node_modules/mout/string/unescapeUnicode.js","./string/unhyphenate":"/Users/luke/dev/040715/node_modules/mout/string/unhyphenate.js","./string/upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js":[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],"/Users/luke/dev/040715/node_modules/mout/string/camelCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var replaceAccents = require('./replaceAccents');
var removeNonWord = require('./removeNonWord');
var upperCase = require('./upperCase');
var lowerCase = require('./lowerCase');
    /**
    * Convert string to camelCase text.
    */
    function camelCase(str){
        str = toString(str);
        str = replaceAccents(str);
        str = removeNonWord(str)
            .replace(/[\-_]/g, ' ') //convert all hyphens and underscores to spaces
            .replace(/\s[a-z]/g, upperCase) //convert first char of each word to UPPERCASE
            .replace(/\s+/g, '') //remove spaces
            .replace(/^[A-Z]/g, lowerCase); //convert first char to lowercase
        return str;
    }
    module.exports = camelCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./removeNonWord":"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js","./replaceAccents":"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/contains.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Searches for a given substring
     */
    function contains(str, substring, fromIndex){
        str = toString(str);
        substring = toString(substring);
        return str.indexOf(substring, fromIndex) !== -1;
    }

    module.exports = contains;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/crop.js":[function(require,module,exports){
var toString = require('../lang/toString');
var truncate = require('./truncate');
    /**
     * Truncate string at full words.
     */
     function crop(str, maxChars, append) {
         str = toString(str);
         return truncate(str, maxChars, append, true);
     }

     module.exports = crop;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./truncate":"/Users/luke/dev/040715/node_modules/mout/string/truncate.js"}],"/Users/luke/dev/040715/node_modules/mout/string/endsWith.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Checks if string ends with specified suffix.
     */
    function endsWith(str, suffix) {
        str = toString(str);
        suffix = toString(suffix);

        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    module.exports = endsWith;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/escapeHtml.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escapes a string for insertion into HTML.
     */
    function escapeHtml(str){
        str = toString(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;');
        return str;
    }

    module.exports = escapeHtml;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/escapeRegExp.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/escapeUnicode.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape string into unicode sequences
     */
    function escapeUnicode(str, shouldEscapePrintable){
        str = toString(str);
        return str.replace(/[\s\S]/g, function(ch){
            // skip printable ASCII chars if we should not escape them
            if (!shouldEscapePrintable && (/[\x20-\x7E]/).test(ch)) {
                return ch;
            }
            // we use "000" and slice(-4) for brevity, need to pad zeros,
            // unicode escape always have 4 chars after "\u"
            return '\\u'+ ('000'+ ch.charCodeAt(0).toString(16)).slice(-4);
        });
    }

    module.exports = escapeUnicode;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/hyphenate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var slugify = require('./slugify');
var unCamelCase = require('./unCamelCase');
    /**
     * Replaces spaces with hyphens, split camelCase text, remove non-word chars, remove accents and convert to lower case.
     */
    function hyphenate(str){
        str = toString(str);
        str = unCamelCase(str);
        return slugify(str, "-");
    }

    module.exports = hyphenate;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./slugify":"/Users/luke/dev/040715/node_modules/mout/string/slugify.js","./unCamelCase":"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/insert.js":[function(require,module,exports){
var clamp = require('../math/clamp');
var toString = require('../lang/toString');

    /**
     * Inserts a string at a given index.
     */
    function insert(string, index, partial){
        string = toString(string);

        if (index < 0) {
            index = string.length + index;
        }

        index = clamp(index, 0, string.length);

        return string.substr(0, index) + partial + string.substr(index);
    }

    module.exports = insert;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","../math/clamp":"/Users/luke/dev/040715/node_modules/mout/math/clamp.js"}],"/Users/luke/dev/040715/node_modules/mout/string/interpolate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var get = require('../object/get');

    var stache = /\{\{([^\}]+)\}\}/g; //mustache-like

    /**
     * String interpolation
     */
    function interpolate(template, replacements, syntax){
        template = toString(template);
        var replaceFn = function(match, prop){
            return toString( get(replacements, prop) );
        };
        return template.replace(syntax || stache, replaceFn);
    }

    module.exports = interpolate;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","../object/get":"/Users/luke/dev/040715/node_modules/mout/object/get.js"}],"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * "Safer" String.toLowerCase()
     */
    function lowerCase(str){
        str = toString(str);
        return str.toLowerCase();
    }

    module.exports = lowerCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/lpad.js":[function(require,module,exports){
var toString = require('../lang/toString');
var repeat = require('./repeat');

    /**
     * Pad string with `char` if its' length is smaller than `minLen`
     */
    function lpad(str, minLen, ch) {
        str = toString(str);
        ch = ch || ' ';

        return (str.length < minLen) ?
            repeat(ch, minLen - str.length) + str : str;
    }

    module.exports = lpad;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./repeat":"/Users/luke/dev/040715/node_modules/mout/string/repeat.js"}],"/Users/luke/dev/040715/node_modules/mout/string/ltrim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js"}],"/Users/luke/dev/040715/node_modules/mout/string/makePath.js":[function(require,module,exports){
var join = require('../array/join');
var slice = require('../array/slice');

    /**
     * Group arguments as path segments, if any of the args is `null` or an
     * empty string it will be ignored from resulting path.
     */
    function makePath(var_args){
        var result = join(slice(arguments), '/');
        // need to disconsider duplicate '/' after protocol (eg: 'http://')
        return result.replace(/([^:\/]|^)\/{2,}/g, '$1/');
    }

    module.exports = makePath;


},{"../array/join":"/Users/luke/dev/040715/node_modules/mout/array/join.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/string/normalizeLineBreaks.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Convert line-breaks from DOS/MAC to a single standard (UNIX by default)
     */
    function normalizeLineBreaks(str, lineEnd) {
        str = toString(str);
        lineEnd = lineEnd || '\n';

        return str
            .replace(/\r\n/g, lineEnd) // DOS
            .replace(/\r/g, lineEnd)   // Mac
            .replace(/\n/g, lineEnd);  // Unix
    }

    module.exports = normalizeLineBreaks;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/pascalCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var camelCase = require('./camelCase');
var upperCase = require('./upperCase');
    /**
     * camelCase + UPPERCASE first char
     */
    function pascalCase(str){
        str = toString(str);
        return camelCase(str).replace(/^[a-z]/, upperCase);
    }

    module.exports = pascalCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./camelCase":"/Users/luke/dev/040715/node_modules/mout/string/camelCase.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/properCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var lowerCase = require('./lowerCase');
var upperCase = require('./upperCase');
    /**
     * UPPERCASE first char of each word.
     */
    function properCase(str){
        str = toString(str);
        return lowerCase(str).replace(/^\w|\s\w/g, upperCase);
    }

    module.exports = properCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/removeNonASCII.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Remove non-printable ASCII chars
     */
    function removeNonASCII(str){
        str = toString(str);

        // Matches non-printable ASCII chars -
        // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
        return str.replace(/[^\x20-\x7E]/g, '');
    }

    module.exports = removeNonASCII;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js":[function(require,module,exports){
var toString = require('../lang/toString');
    // This pattern is generated by the _build/pattern-removeNonWord.js script
    var PATTERN = /[^\x20\x2D0-9A-Z\x5Fa-z\xC0-\xD6\xD8-\xF6\xF8-\xFF]/g;

    /**
     * Remove non-word chars.
     */
    function removeNonWord(str){
        str = toString(str);
        return str.replace(PATTERN, '');
    }

    module.exports = removeNonWord;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/repeat.js":[function(require,module,exports){
var toString = require('../lang/toString');
var toInt = require('../number/toInt');

    /**
     * Repeat string n times
     */
     function repeat(str, n){
         var result = '';
         str = toString(str);
         n = toInt(n);
        if (n < 1) {
            return '';
        }
        while (n > 0) {
            if (n % 2) {
                result += str;
            }
            n = Math.floor(n / 2);
            str += str;
        }
        return result;
     }

     module.exports = repeat;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","../number/toInt":"/Users/luke/dev/040715/node_modules/mout/number/toInt.js"}],"/Users/luke/dev/040715/node_modules/mout/string/replace.js":[function(require,module,exports){
var toString = require('../lang/toString');
var toArray = require('../lang/toArray');

    /**
     * Replace string(s) with the replacement(s) in the source.
     */
    function replace(str, search, replacements) {
        str = toString(str);
        search = toArray(search);
        replacements = toArray(replacements);

        var searchLength = search.length,
            replacementsLength = replacements.length;

        if (replacementsLength !== 1 && searchLength !== replacementsLength) {
            throw new Error('Unequal number of searches and replacements');
        }

        var i = -1;
        while (++i < searchLength) {
            // Use the first replacement for all searches if only one
            // replacement is provided
            str = str.replace(
                search[i],
                replacements[(replacementsLength === 1) ? 0 : i]);
        }

        return str;
    }

    module.exports = replace;



},{"../lang/toArray":"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js","../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
    * Replaces all accented chars with regular ones
    */
    function replaceAccents(str){
        str = toString(str);

        // verifies if the String has accents and replace them
        if (str.search(/[\xC0-\xFF]/g) > -1) {
            str = str
                    .replace(/[\xC0-\xC5]/g, "A")
                    .replace(/[\xC6]/g, "AE")
                    .replace(/[\xC7]/g, "C")
                    .replace(/[\xC8-\xCB]/g, "E")
                    .replace(/[\xCC-\xCF]/g, "I")
                    .replace(/[\xD0]/g, "D")
                    .replace(/[\xD1]/g, "N")
                    .replace(/[\xD2-\xD6\xD8]/g, "O")
                    .replace(/[\xD9-\xDC]/g, "U")
                    .replace(/[\xDD]/g, "Y")
                    .replace(/[\xDE]/g, "P")
                    .replace(/[\xE0-\xE5]/g, "a")
                    .replace(/[\xE6]/g, "ae")
                    .replace(/[\xE7]/g, "c")
                    .replace(/[\xE8-\xEB]/g, "e")
                    .replace(/[\xEC-\xEF]/g, "i")
                    .replace(/[\xF1]/g, "n")
                    .replace(/[\xF2-\xF6\xF8]/g, "o")
                    .replace(/[\xF9-\xFC]/g, "u")
                    .replace(/[\xFE]/g, "p")
                    .replace(/[\xFD\xFF]/g, "y");
        }
        return str;
    }
    module.exports = replaceAccents;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/rpad.js":[function(require,module,exports){
var toString = require('../lang/toString');
var repeat = require('./repeat');

    /**
     * Pad string with `char` if its' length is smaller than `minLen`
     */
    function rpad(str, minLen, ch) {
        str = toString(str);
        ch = ch || ' ';
        return (str.length < minLen)? str + repeat(ch, minLen - str.length) : str;
    }

    module.exports = rpad;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./repeat":"/Users/luke/dev/040715/node_modules/mout/string/repeat.js"}],"/Users/luke/dev/040715/node_modules/mout/string/rtrim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js"}],"/Users/luke/dev/040715/node_modules/mout/string/sentenceCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var lowerCase = require('./lowerCase');
var upperCase = require('./upperCase');
    /**
     * UPPERCASE first char of each sentence and lowercase other chars.
     */
    function sentenceCase(str){
        str = toString(str);

        // Replace first char of each sentence (new line or after '.\s+') to
        // UPPERCASE
        return lowerCase(str).replace(/(^\w)|\.\s+(\w)/gm, upperCase);
    }
    module.exports = sentenceCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/slugify.js":[function(require,module,exports){
var toString = require('../lang/toString');
var replaceAccents = require('./replaceAccents');
var removeNonWord = require('./removeNonWord');
var trim = require('./trim');
    /**
     * Convert to lower case, remove accents, remove non-word chars and
     * replace spaces with the specified delimeter.
     * Does not split camelCase text.
     */
    function slugify(str, delimeter){
        str = toString(str);

        if (delimeter == null) {
            delimeter = "-";
        }
        str = replaceAccents(str);
        str = removeNonWord(str);
        str = trim(str) //should come after removeNonWord
                .replace(/ +/g, delimeter) //replace spaces with delimeter
                .toLowerCase();
        return str;
    }
    module.exports = slugify;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./removeNonWord":"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js","./replaceAccents":"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js","./trim":"/Users/luke/dev/040715/node_modules/mout/string/trim.js"}],"/Users/luke/dev/040715/node_modules/mout/string/startsWith.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Checks if string starts with specified prefix.
     */
    function startsWith(str, prefix) {
        str = toString(str);
        prefix = toString(prefix);

        return str.indexOf(prefix) === 0;
    }

    module.exports = startsWith;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/stripHtmlTags.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Remove HTML tags from string.
     */
    function stripHtmlTags(str){
        str = toString(str);

        return str.replace(/<[^>]*>/g, '');
    }
    module.exports = stripHtmlTags;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/trim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js","./ltrim":"/Users/luke/dev/040715/node_modules/mout/string/ltrim.js","./rtrim":"/Users/luke/dev/040715/node_modules/mout/string/rtrim.js"}],"/Users/luke/dev/040715/node_modules/mout/string/truncate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var trim = require('./trim');
    /**
     * Limit number of chars.
     */
    function truncate(str, maxChars, append, onlyFullWords){
        str = toString(str);
        append = append || '...';
        maxChars = onlyFullWords? maxChars + 1 : maxChars;

        str = trim(str);
        if(str.length <= maxChars){
            return str;
        }
        str = str.substr(0, maxChars - append.length);
        //crop at last space or remove trailing whitespace
        str = onlyFullWords? str.substr(0, str.lastIndexOf(' ')) : trim(str);
        return str + append;
    }
    module.exports = truncate;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./trim":"/Users/luke/dev/040715/node_modules/mout/string/trim.js"}],"/Users/luke/dev/040715/node_modules/mout/string/typecast.js":[function(require,module,exports){


    var UNDEF;

    /**
     * Parses string and convert it into a native value.
     */
    function typecast(val) {
        var r;
        if ( val === null || val === 'null' ) {
            r = null;
        } else if ( val === 'true' ) {
            r = true;
        } else if ( val === 'false' ) {
            r = false;
        } else if ( val === UNDEF || val === 'undefined' ) {
            r = UNDEF;
        } else if ( val === '' || isNaN(val) ) {
            //isNaN('') returns false
            r = val;
        } else {
            //parseFloat(null || '') returns NaN
            r = parseFloat(val);
        }
        return r;
    }

    module.exports = typecast;


},{}],"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js":[function(require,module,exports){
var toString = require('../lang/toString');

    var CAMEL_CASE_BORDER = /([a-z\xE0-\xFF])([A-Z\xC0\xDF])/g;

    /**
     * Add space between camelCase text.
     */
    function unCamelCase(str, delimiter){
        if (delimiter == null) {
            delimiter = ' ';
        }

        function join(str, c1, c2) {
            return c1 + delimiter + c2;
        }

        str = toString(str);
        str = str.replace(CAMEL_CASE_BORDER, join);
        str = str.toLowerCase(); //add space between camelCase text
        return str;
    }
    module.exports = unCamelCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/underscore.js":[function(require,module,exports){
var toString = require('../lang/toString');
var slugify = require('./slugify');
var unCamelCase = require('./unCamelCase');
    /**
     * Replaces spaces with underscores, split camelCase text, remove non-word chars, remove accents and convert to lower case.
     */
    function underscore(str){
        str = toString(str);
        str = unCamelCase(str);
        return slugify(str, "_");
    }
    module.exports = underscore;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./slugify":"/Users/luke/dev/040715/node_modules/mout/string/slugify.js","./unCamelCase":"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/unescapeHtml.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Unescapes HTML special chars
     */
    function unescapeHtml(str){
        str = toString(str)
            .replace(/&amp;/g , '&')
            .replace(/&lt;/g  , '<')
            .replace(/&gt;/g  , '>')
            .replace(/&#0*39;/g , "'")
            .replace(/&quot;/g, '"');
        return str;
    }

    module.exports = unescapeHtml;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/unescapeUnicode.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Unescape unicode char sequences
     */
    function unescapeUnicode(str){
        str = toString(str);
        return str.replace(/\\u[0-9a-f]{4}/g, function(ch){
            var code = parseInt(ch.slice(2), 16);
            return String.fromCharCode(code);
        });
    }

    module.exports = unescapeUnicode;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/unhyphenate.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Replaces hyphens with spaces. (only hyphens between word chars)
     */
    function unhyphenate(str){
        str = toString(str);
        return str.replace(/(\w)(-)(\w)/g, '$1 $3');
    }
    module.exports = unhyphenate;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * "Safer" String.toUpperCase()
     */
    function upperCase(str){
        str = toString(str);
        return str.toUpperCase();
    }
    module.exports = upperCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/time.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'convert' : require('./time/convert'),
    'now' : require('./time/now'),
    'parseMs' : require('./time/parseMs'),
    'toTimeString' : require('./time/toTimeString')
};



},{"./time/convert":"/Users/luke/dev/040715/node_modules/mout/time/convert.js","./time/now":"/Users/luke/dev/040715/node_modules/mout/time/now.js","./time/parseMs":"/Users/luke/dev/040715/node_modules/mout/time/parseMs.js","./time/toTimeString":"/Users/luke/dev/040715/node_modules/mout/time/toTimeString.js"}],"/Users/luke/dev/040715/node_modules/mout/time/convert.js":[function(require,module,exports){


    /**
     * convert time into another unit
     */
    function convert(val, sourceUnitName, destinationUnitName){
        destinationUnitName = destinationUnitName || 'ms';
        return (val * getUnit(sourceUnitName)) / getUnit(destinationUnitName);
    }


    //TODO: maybe extract to a separate module
    function getUnit(unitName){
        switch(unitName){
            case 'ms':
            case 'millisecond':
                return 1;
            case 's':
            case 'second':
                 return 1000;
            case 'm':
            case 'minute':
                 return 60000;
            case 'h':
            case 'hour':
                 return 3600000;
            case 'd':
            case 'day':
                 return 86400000;
            case 'w':
            case 'week':
                 return 604800000;
            default:
                throw new Error('"'+ unitName + '" is not a valid unit');
        }
    }


    module.exports = convert;



},{}],"/Users/luke/dev/040715/node_modules/mout/time/now.js":[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],"/Users/luke/dev/040715/node_modules/mout/time/parseMs.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');

    /**
     * Parse timestamp into an object.
     */
    function parseMs(ms){
        return {
            milliseconds : countSteps(ms, 1, 1000),
            seconds      : countSteps(ms, 1000, 60),
            minutes      : countSteps(ms, 60000, 60),
            hours        : countSteps(ms, 3600000, 24),
            days         : countSteps(ms, 86400000)
        };
    }

    module.exports = parseMs;


},{"../math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js"}],"/Users/luke/dev/040715/node_modules/mout/time/toTimeString.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');
var pad = require('../number/pad');

    var HOUR = 3600000,
        MINUTE = 60000,
        SECOND = 1000;

    /**
     * Format timestamp into a time string.
     */
    function toTimeString(ms){
        var h = ms < HOUR   ? 0 : countSteps(ms, HOUR),
            m = ms < MINUTE ? 0 : countSteps(ms, MINUTE, 60),
            s = ms < SECOND ? 0 : countSteps(ms, SECOND, 60),
            str = '';

        str += h? h + ':' : '';
        str += pad(m, 2) + ':';
        str += pad(s, 2);

        return str;
    }
    module.exports = toTimeString;


},{"../math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js","../number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js"}],"/Users/luke/dev/040715/node_modules/path-to-regexp/index.js":[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys) {
  var index = 0;

  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  return path.replace(PATH_REGEXP, replace);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

},{"isarray":"/Users/luke/dev/040715/node_modules/path-to-regexp/node_modules/isarray/index.js"}],"/Users/luke/dev/040715/node_modules/path-to-regexp/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/luke/dev/040715/source/js/app-debug.coffee":[function(require,module,exports){
var dat, gui, options, page;

dat = require("dat-gui");

page = require("./../../vendor/page/page.js");

gui = window._gui = new dat.GUI();

options = {
  "debug": false,
  "index": function() {
    return page("/");
  },
  "test": function() {
    return page("/test");
  }
};

module.exports = function() {
  var debug, folder;
  debug = gui.add(options, "debug");
  folder = gui.addFolder("navigation");
  folder.add(options, "index").name("/index");
  folder.add(options, "test").name("/test");
  return folder.open();
};



},{"./../../vendor/page/page.js":"/Users/luke/dev/040715/vendor/page/page.js","dat-gui":"/Users/luke/dev/040715/node_modules/dat-gui/index.js"}],"/Users/luke/dev/040715/source/js/config.coffee":[function(require,module,exports){
module.exports = {
  firebase: "aliceluke"
};



},{}],"/Users/luke/dev/040715/source/js/module/abstract-module.coffee":[function(require,module,exports){
var Ractive;

Ractive = require("./../../../vendor/ractive/ractive.js");

module.exports = Ractive.extend({
  isolated: true
});



},{"./../../../vendor/ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee":[function(require,module,exports){

/*
	@module:   abstract-scene
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/abstract-scene.styl
	@html:     ./source/template/module/abstract-scene.html
 */
var Module;

Module = require("./abstract-module");

module.exports = Module.extend({
  template: require("module/abstract-scene.html"),
  partials: {
    stageControls: require("partials/stage-controls.html")
  },
  oninit: function() {
    this.on("goNextScene", function() {
      return this.fire("nextScene");
    });
    return this.on("goPrevScene", function() {
      return this.fire("prevScene");
    });
  }
});



},{"./abstract-module":"/Users/luke/dev/040715/source/js/module/abstract-module.coffee","module/abstract-scene.html":"/Users/luke/dev/040715/source/template/module/abstract-scene.html","partials/stage-controls.html":"/Users/luke/dev/040715/source/template/partials/stage-controls.html"}],"/Users/luke/dev/040715/source/js/module/index.coffee":[function(require,module,exports){

/*
	THIS FILE IS GENERATED AUTOMATICALLY AND IT WILL
	BE REPLACED IF A NEW MODULE IS ADDED OR DELETED.
 */
var Ractive, register;

Ractive = require("./../../../vendor/ractive/ractive.js");

register = function() {
  Ractive.components["ui-abstract-scene"] = require("./abstract-scene");
  Ractive.components["ui-nav"] = require("./nav");
  Ractive.components["ui-scene-day"] = require("./scene-day");
  Ractive.components["ui-scene-digest"] = require("./scene-digest");
  Ractive.components["ui-scene-night"] = require("./scene-night");
  Ractive.components["ui-stage"] = require("./stage");
  return true;
};

module.exports = register();



},{"./../../../vendor/ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js","./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","./nav":"/Users/luke/dev/040715/source/js/module/nav.coffee","./scene-day":"/Users/luke/dev/040715/source/js/module/scene-day.coffee","./scene-digest":"/Users/luke/dev/040715/source/js/module/scene-digest.coffee","./scene-night":"/Users/luke/dev/040715/source/js/module/scene-night.coffee","./stage":"/Users/luke/dev/040715/source/js/module/stage.coffee"}],"/Users/luke/dev/040715/source/js/module/nav.coffee":[function(require,module,exports){

/*
	@module:   nav
	@author:   Luke Hedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/nav.styl
	@html:     ./source/template/module/nav.html
 */
var Module, page;

Module = require("./abstract-module");

page = require("./../../../vendor/page/page.js");

module.exports = Module.extend({
  template: require("module/nav.html"),
  oninit: function() {
    this.on("toIndex", function() {
      return page("/");
    });
    return this.on("toTest", function() {
      return page("/test");
    });
  }
});



},{"./../../../vendor/page/page.js":"/Users/luke/dev/040715/vendor/page/page.js","./abstract-module":"/Users/luke/dev/040715/source/js/module/abstract-module.coffee","module/nav.html":"/Users/luke/dev/040715/source/template/module/nav.html"}],"/Users/luke/dev/040715/source/js/module/scene-day.coffee":[function(require,module,exports){

/*
	@module:   scene-day
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-day.styl
	@html:     ./source/template/module/scene-day.html
 */
var Module;

Module = require("./abstract-scene");

module.exports = Module.extend({
  template: require("module/scene-day.html"),
  oninit: function() {
    return this._super();
  },
  onrender: function() {
    var length, path;
    path = this.find("path");
    length = path.getTotalLength();
    return TweenMax.to(path, 2, {
      delay: 1,
      'stroke-dashoffset': length,
      ease: Bounce.easeOut
    });
  }
});



},{"./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","module/scene-day.html":"/Users/luke/dev/040715/source/template/module/scene-day.html"}],"/Users/luke/dev/040715/source/js/module/scene-digest.coffee":[function(require,module,exports){

/*
	@module:   scene-digest
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-digest.styl
	@html:     ./source/template/module/scene-digest.html
 */
var Module, keys;

Module = require("./abstract-scene");

keys = require("mout").object.keys;

module.exports = Module.extend({
  template: require("module/scene-digest.html"),
  data: {
    current: 1,
    x: ["100%", "-200%"],
    slides: {
      1: {
        title: "slide 1",
        body: "this is slide 1",
        links: ["a", "b"],
        active: true
      },
      2: {
        title: "slide 2",
        body: "this is slide 2",
        active: false
      },
      3: {
        title: "slide 3",
        body: "this is slide 3",
        active: false
      }
    }
  },
  oninit: function() {
    return this._super();
  },
  onrender: function() {
    this.on("goNextSlide", function() {
      return this.nextSlide();
    });
    return this.on("goPrevSlide", function() {
      return this.prevSlide();
    });
  },
  nextSlide: function() {
    var current, next;
    current = this.get("current");
    next = current === keys(this.get("slides")).length ? 1 : current += 1;
    this.set("slides." + (this.get("current")) + ".x", this.get("x[1]"));
    this.set("slides." + next + ".x", this.get("x[0]"));
    return this.setSlide(next);
  },
  prevSlide: function() {
    var current, prev;
    current = this.get("current");
    prev = current === 1 ? keys(this.get("slides")).length : current -= 1;
    this.set("slides." + (this.get("current")) + ".x", this.get("x[0]"));
    this.set("slides." + prev + ".x", this.get("x[1]"));
    return this.setSlide(prev);
  },
  setSlide: function(slide) {
    this.set("slides." + (this.get("current")) + ".active", false);
    this.set("slides." + slide + ".active", true);
    return this.set({
      current: slide
    });
  }
});



},{"./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","module/scene-digest.html":"/Users/luke/dev/040715/source/template/module/scene-digest.html","mout":"/Users/luke/dev/040715/node_modules/mout/index.js"}],"/Users/luke/dev/040715/source/js/module/scene-night.coffee":[function(require,module,exports){

/*
	@module:   scene-night
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-night.styl
	@html:     ./source/template/module/scene-night.html
 */
var Module;

Module = require("./abstract-scene");

module.exports = Module.extend({
  template: require("module/scene-night.html"),
  oninit: function() {
    return this._super();
  },
  onrender: function() {}
});



},{"./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","module/scene-night.html":"/Users/luke/dev/040715/source/template/module/scene-night.html"}],"/Users/luke/dev/040715/source/js/module/stage.coffee":[function(require,module,exports){

/*
	@module:   stage
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/stage.styl
	@html:     ./source/template/module/stage.html
 */
var Module, keys;

Module = require("./abstract-module");

keys = require("mout").object.keys;

module.exports = Module.extend({
  template: require("module/stage.html"),
  data: {
    current: 0,
    scene: null,
    scenes: {
      1: "day",
      2: "digest",
      3: "night"
    }
  },
  oninit: function() {
    this.setScene(1);
    window.onkeydown = (function(_this) {
      return function(e) {
        if (e.keyCode === 38) {
          _this.prevScene();
        }
        if (e.keyCode === 40) {
          return _this.nextScene();
        }
      };
    })(this);
    this.on("*.nextScene", function() {
      return this.nextScene();
    });
    return this.on("*.prevScene", function() {
      return this.prevScene();
    });
  },
  nextScene: function() {
    var current, next;
    current = this.get("current");
    next = current === keys(this.get("scenes")).length ? 1 : current += 1;
    return this.setScene(next);
  },
  prevScene: function() {
    var current, prev;
    current = this.get("current");
    prev = current === 1 ? keys(this.get("scenes")).length : current -= 1;
    return this.setScene(prev);
  },
  setScene: function(scene) {
    return this.set({
      scene: this.get("scenes." + scene),
      current: scene
    });
  }
});



},{"./abstract-module":"/Users/luke/dev/040715/source/js/module/abstract-module.coffee","module/stage.html":"/Users/luke/dev/040715/source/template/module/stage.html","mout":"/Users/luke/dev/040715/node_modules/mout/index.js"}],"/Users/luke/dev/040715/source/js/view/main-view.coffee":[function(require,module,exports){
var Firebase, Ractive, config, page;

Ractive = require("./../../../vendor/ractive/ractive.js");

Firebase = require("firebase");

page = require("./../../../vendor/page/page.js");

config = require("../config");

module.exports = Ractive.extend({
  el: document.body,
  append: true,
  template: require("main-view.html"),
  data: {
    view: null,
    guest: null
  },
  oninit: function() {
    console.log("[main-view] init");
    this.getData();
    return this.set_router();
  },
  getData: function() {
    var db;
    db = new Firebase("https://" + config.firebase + ".firebaseio.com/");
    return db.on("value", (function(_this) {
      return function(snapshot) {
        return console.log("ok:", snapshot.val());
      };
    })(this), function(err) {
      return console.log("err:", err.code);
    });
  },
  set_router: function() {
    var self;
    self = this;
    page("/", function() {
      console.log("[main-view] index");
      return self.set({
        "view": "index"
      });
    });
    return page({
      click: false,
      dispatch: true,
      hashbang: false
    });
  }
});



},{"../config":"/Users/luke/dev/040715/source/js/config.coffee","./../../../vendor/page/page.js":"/Users/luke/dev/040715/vendor/page/page.js","./../../../vendor/ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js","firebase":"/Users/luke/dev/040715/node_modules/firebase/lib/firebase-web.js","main-view.html":"/Users/luke/dev/040715/source/template/main-view.html"}],"/Users/luke/dev/040715/source/template/main-view.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"wrapper"},"f":[{"t":7,"e":"ui-stage"}," ",{"t":7,"e":"div","a":{"class":"farm"},"f":[{"t":7,"e":"div","a":{"class":"field"}}," ",{"t":7,"e":"div","a":{"class":"bunting"},"f":[{"t":7,"e":"div","a":{"class":"pole"}}]}," ",{"t":7,"e":"div","a":{"class":"trees"},"f":[{"t":7,"e":"div","a":{"class":"tree--dark"}}," ",{"t":7,"e":"div","a":{"class":"tree"}}," ",{"t":7,"e":"div","a":{"class":"tree--dark"}}," ",{"t":7,"e":"div","a":{"class":"tree"}}]}," ",{"t":7,"e":"div","a":{"class":"tents"},"f":[{"t":7,"e":"div","a":{"class":"tent"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}," ",{"t":7,"e":"div","a":{"class":"tent--blue"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}," ",{"t":7,"e":"div","a":{"class":"tent--pink"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"fire"},"f":[{"t":7,"e":"div","a":{"class":"logs"}}]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/abstract-scene.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"abstract-scene"},"f":[{"t":7,"e":"h1","f":["abstract-scene :)"]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/nav.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"nav"},"f":[{"t":7,"e":"a","v":{"tap":"toIndex"},"f":["Home"]}," ",{"t":7,"e":"a","v":{"tap":"toTest"},"f":["Test"]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/scene-day.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-day"},"t1":"fade","f":[{"t":8,"r":"stageControls"}," ",{"t":7,"e":"svg","a":{"width":"200px","height":"200px","version":"1.1","xmlns":"http://www.w3.org/2000/svg"},"f":[{"t":7,"e":"path","a":{"d":"M10 10 C 20 20, 40 20, 50 10","stroke":"black","fill":"transparent"}}]}," ",{"t":7,"e":"div","a":{"class":"greeting"},"f":[{"t":7,"e":"h2","f":["Howdy! You're invited to Woodstock 2015"]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/scene-digest.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-digest"},"f":[{"t":8,"r":"stageControls"}," ",{"t":7,"e":"div","a":{"class":"showtime"},"v":{"swiperight":"goPrevSlide","swipeleft":"goNextSlide"},"f":[{"t":7,"e":"div","a":{"class":"showtime__controls"},"f":[{"t":7,"e":"a","a":{"class":"showtime__control--prev"},"v":{"tap":"goPrevSlide"},"f":["←"]}," ",{"t":7,"e":"a","a":{"class":"showtime__control--next"},"v":{"tap":"goNextSlide"},"f":["→"]}]}," ",{"t":4,"r":"slides","i":"slide","f":[{"t":4,"r":"active","f":[{"t":7,"e":"div","a":{"class":["slide--",{"t":2,"r":"slide"}]},"t0":{"n":"fly","d":["{ x:'",{"t":2,"r":"x"},"', y:'0%', opacity:1 }"]},"f":[{"t":7,"e":"h1","f":[{"t":2,"r":"title"}]}," ",{"t":7,"e":"p","f":[{"t":2,"r":"body"}]}," ",{"t":4,"r":"links","f":[{"t":2,"r":"."}]}]}]}]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/scene-night.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-night"},"f":[{"t":8,"r":"stageControls"}," ",{"t":7,"e":"h1","f":["scene-night :)"]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/stage.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":["stage ",{"t":2,"r":"scene"}]},"f":[{"t":7,"e":"ui-scene-day","a":{"active":[{"t":2,"x":{"r":["scene"],"s":"_0==\"day\"?true:false"}}]}}," ",{"t":7,"e":"ui-scene-digest","a":{"active":[{"t":2,"x":{"r":["scene"],"s":"_0==\"digest\"?true:false"}}]}}," ",{"t":7,"e":"ui-scene-night","a":{"active":[{"t":2,"x":{"r":["scene"],"s":"_0==\"night\"?true:false"}}]}}]}]}
},{}],"/Users/luke/dev/040715/source/template/partials/stage-controls.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"a","a":{"class":"stage__control--prev"},"v":{"tap":"goPrevScene"},"f":["↑"]}," ",{"t":7,"e":"a","a":{"class":"stage__control--next"},"v":{"tap":"goNextScene"},"f":["↓"]}]}
},{}],"/Users/luke/dev/040715/vendor/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/Users/luke/dev/040715/vendor/gsap/src/uncompressed/TweenMax.js":[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.16.0
 * DATE: 2015-03-01
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			TweenMax = function(target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
			_blankArray = [];

		TweenMax.version = "1.16.0";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};
		
		p.updateTo = function(vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._time;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else if (this._time > 0 || immediate) {
						this._initted = false;
						this._init();
						var inv = 1 / (1 - curRatio),
							pt = this._firstPT, endValue;
						while (pt) {
							endValue = pt.s + pt.c; 
							pt.c *= inv;
							pt.s = endValue - pt.c;
							pt = pt._next;
						}
					}
				}
			}
			return this;
		};
				
		p.render = function(time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime, 
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, i;
			if (time >= totalDur) {
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time) {
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
				
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but Flash reports it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - (this._cycle * cycleDuration);
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
				
			}
				
			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}
			
			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
			}
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};
		
//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
		
		TweenMax.to = function(target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		};
		
		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = vars.delay || 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || this, onCompleteAllParams || _blankArray);
				},
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				copy.delay = delay;
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};
		
		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
		
		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
				
		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, useFrames:useFrames, overwrite:0});
		};
		
		TweenMax.set = function(target, vars) {
			return new TweenMax(target, 0, vars);
		};
		
		TweenMax.isTweening = function(target) {
			return (TweenLite.getTweensOf(target, true).length > 0);
		};
		
		var _getChildrenOf = function(timeline, includeTimelines) {
				var a = [],
					cnt = 0,
					tween = timeline._first;
				while (tween) {
					if (tween instanceof TweenLite) {
						a[cnt++] = tween;
					} else {
						if (includeTimelines) {
							a[cnt++] = tween;
						}
						a = a.concat(_getChildrenOf(tween, includeTimelines));
						cnt = a.length;
					}
					tween = tween._next;
				}
				return a;
			}, 
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
			};
		
		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens && delayedCalls && timelines),
				isDC, tween, i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};
		
		TweenMax.killChildTweensOf = function(parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function(pause, tweens, delayedCalls, timelines) {
			tweens = (tweens !== false);
			delayedCalls = (delayedCalls !== false);
			timelines = (timelines !== false);
			var a = getAllTweens(timelines),
				allTrue = (tweens && delayedCalls && timelines),
				i = a.length,
				isDC, tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);
				}
			}
		};
		
		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};
		
		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function(value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};
		
	
//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
		
		p.progress = function(value) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), false);
		};
		
		p.totalProgress = function(value) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, false);
		};
		
		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function(value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};
		
		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};
		
		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};
		
		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};
		
		
		return TweenMax;
		
	}, true);








/*
 * ----------------------------------------------------------------
 * TimelineLite
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_blankArray = [],
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_pauseCallback = _internals.pauseCallback = function(tween, callback, params, scope) {
				var tl = tween._timeline,
					time = tl._totalTime,
					startTime = tween._startTime,
					next = tween.ratio ? _tinyNum : 0,
					prev = tween.ratio ? 0 : _tinyNum,
					sibling;
				if (callback || !this._forcingPlayhead) { //if the user calls a method that moves the playhead (like progress() or time()), it should honor that and skip any pauses (although if there's a callback positioned at that pause, it must jump there and make the call to ensure the time is EXACTLY what it is supposed to be, and then proceed to where the playhead is being forced). Otherwise, imagine placing a pause in the middle of a timeline and then doing timeline.progress(0.9) - it would get stuck where the pause is.
					tl.pause(startTime);
					//now find sibling tweens that are EXACTLY at the same spot on the timeline and adjust the _rawPrevTime so that they fire (or don't fire) correctly on the next render. This is primarily to accommodate zero-duration tweens/callbacks that are positioned right on top of a pause. For example, tl.to(...).call(...).addPause(...).call(...) - notice that there's a call() on each side of the pause, so when it's running forward it should call the first one and then pause, and then when resumed, call the other. Zero-duration tweens use _rawPrevTime to sense momentum figure out if events were suppressed when arriving directly on top of that time.
					sibling = tween._prev;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = prev;
						sibling = sibling._prev;
					}
					sibling = tween._next;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = next;
						sibling = sibling._next;
					}
					if (callback) {
						callback.apply(scope || tl, params || _blankArray);
					}
					if (this._forcingPlayhead) {
						tl.seek(time);
					}
				}
			},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.16.0";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, onCompleteScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				if (vars.startAt) {
					vars.startAt = _copy(vars.startAt);
				}
				tl.to(targets[i], duration, _copy(vars), i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				return this._remove(value, false);
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, ["{self}", callback, params, scope], this);
			t.data = "isPause"; // we use this flag in TweenLite's render() method to identify it as a special case that shouldn't be triggered when the virtual playhead is LEAVING the exact position where the pause is, otherwise timeline.addPause(1).play(1) would end up paused on the very next tick.
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce;
			if (time >= totalDur) {
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					if (this._duration === 0) if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			if (this.totalDuration() !== 0) if (value !== 0) {
				this.timeScale(this._totalDuration / value);
			}
			return this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = time; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function() {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);
	







	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * TimelineMax
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {

		var TimelineMax = function(vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			},
			_tinyNum = 0.0000000001,
			_blankArray = [],
			TweenLiteInternals = TweenLite._internals,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_easeNone = new Ease(null, null, 1, 0),
			p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.16.0";

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function(callback, position, params, scope) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function(callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function(position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function(position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false},
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new TweenLite(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale );
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
					vars.onStart.apply(vars.onStartScope || t, vars.onStartParams || _blankArray);
				}
			};
			return t;
		};

		p.tweenFromTo = function(fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], onCompleteScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused,
				prevCycle = this._cycle,
				tween, isComplete, next, callback, internalForce, cycleDuration;
			if (time >= totalDur) {
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					if (this._duration === 0) if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - (this._cycle * cycleDuration);
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}
			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
				*/
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
					recTotalTime = this._totalTime,
					recCycle = this._cycle,
					recRawPrevTime = this._rawPrevTime,
					recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;
				this.render(prevTime, suppressEvents, (dur === 0));
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
					}
				}
				if (wrap) {
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}

					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p.getActive = function(nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
				all = this.getChildren(nested, tweens, timelines),
				cnt = 0,
				l = all.length,
				i, tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};


		p.getLabelAfter = function(time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function(time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function() {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		};


//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};

		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function(value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;

	}, true);
	




	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * BezierPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors. For example, if you set an object's position to 4.945, Flash will make it 4.9
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = a[j+1].da / _r2[j] + a[j].da / _r1[j];
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.4",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._round = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._round[p]) {
								val = Math.round(val);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._roundProps = function(lookup, value) {
			var op = this._overwriteProps,
				i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

	}());






	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * CSSPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function() {
				TweenPlugin.call(this, "css");
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_globals = _gsScope._gsDefine.globals,
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},
			p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.16.0";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


		var _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_opacityExp = /opacity *= *([^)]*)/i,
			_opacityValExp = /opacity:([^;]*)/i,
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
			_rgbhslExp = /^(rgb|hsl)/,
			_capsExp = /([A-Z])/g,
			_camelExp = /-([a-z])/gi,
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },
			_horizExp = /(?:Left|Right|Width)/i,
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
			_DEG2RAD = Math.PI / 180,
			_RAD2DEG = 180 / Math.PI,
			_forcePT = {},
			_doc = document,
			_createElement = function(type) {
				return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_tempImg = _createElement("img"),
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = navigator.userAgent,
			_autoRound,
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

			_isSafari,
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),
					a = _createElement("a");
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i+8, 1)) > 3));
				_isSafariLT6 = (_isSafari && (Number(_agent.substr(_agent.indexOf("Version/")+8, 1)) < 6));
				_isFirefox = (_agent.indexOf("Firefox") !== -1);
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
					_ieVers = parseFloat( RegExp.$1 );
				}
				if (!a) {
					return false;
				}
				a.style.cssText = "top:1px;opacity:.55;";
				return /^0.55/.test(a.style.opacity);
			}()),
			_getIEOpacity = function(v) {
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
				if (window.console) {
					console.log(s);
				}
			},

			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {
				e = e || _tempDiv;
				var s = e.style,
					a, i;
				if (s[p] !== undefined) {
					return p;
				}
				p = p.charAt(0).toUpperCase() + p.substr(1);
				a = ["O","Moz","ms","Ms","Webkit"];
				i = 5;
				while (--i > -1 && s[a[i]+p] === undefined) { }
				if (i >= 0) {
					_prefix = (i === 3) ? "ms" : a[i];
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";
					return _prefix + p;
				}
				return null;
			},

			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},

			/**
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
			 *
			 * @param {!Object} t Target element whose style property you want to query
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
			 * @return {?string} The current property value
			 */
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc && t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
			},

			/**
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
			 * @param {!number} v Value
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels
			 */
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || !sfx) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
					if (sfx === "%" || !node.appendChild) {
						node = t.parentNode || _doc.body;
						cache = node._gsCache;
						time = TweenLite.ticker.frame;
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;
						}
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, cs);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
			},

			// @private returns at object containing ALL of the style properties in camelCase and their associated values.
			_getAllStyles = function(t, cs) {
				var s = {},
					i, tr, p;
				if ((cs = cs || _getComputedStyle(t, null))) {
					if ((i = cs.length)) {
						while (--i > -1) {
							p = cs[i];
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
							}
						}
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
						for (i in cs) {
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];
							}
						}
					}
				} else if ((cs = t.currentStyle || t.style)) {
					for (i in cs) {
						if (typeof(i) === "string" && s[i] === undefined) {
							s[i.replace(_camelExp, _camelFunc)] = cs[i];
						}
					}
				}
				if (!_supportsOpacity) {
					s.opacity = _getIEOpacity(t);
				}
				tr = _getTransform(t, cs, false);
				s.rotation = tr.rotation;
				s.skewX = tr.skewX;
				s.scaleX = tr.scaleX;
				s.scaleY = tr.scaleY;
				s.x = tr.x;
				s.y = tr.y;
				if (_supports3D) {
					s.z = tr.z;
					s.rotationX = tr.rotationX;
					s.rotationY = tr.rotationY;
					s.scaleZ = tr.scaleZ;
				}
				if (s.filters) {
					delete s.filters;
				}
				return s;
			},

			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {
				var difs = {},
					style = t.style,
					val, p, mpt;
				for (p in s2) {
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);
						}
					}
				}
				if (vars) {
					for (p in vars) { //copy properties (except className)
						if (p !== "className") {
							difs[p] = vars[p];
						}
					}
				}
				return {difs:difs, firstMPT:mpt};
			},
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

			/**
			 * @private Gets the width or height of an element
			 * @param {!Object} t Target element
			 * @param {!string} p Property name ("width" or "height")
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
			 * @return {number} Dimension (in pixels)
			 */
			_getDimension = function(t, p, cs) {
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
					a = _dimensions[p],
					i = a.length;
				cs = cs || _getComputedStyle(t, null);
				while (--i > -1) {
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
				}
				return v;
			},

			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {
				if (v == null || v === "" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					v = "0 0";
				}
				var a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];
				if (y == null) {
					y = (x === "center") ? "50%" : "0";
				} else if (y === "center") {
					y = "50%";
				}
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				if (recObj) {
					recObj.oxp = (x.indexOf("%") !== -1);
					recObj.oyp = (y.indexOf("%") !== -1);
					recObj.oxr = (x.charAt(1) === "=");
					recObj.oyr = (y.charAt(1) === "=");
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));
				}
				return x + " " + y + ((a.length > 2) ? " " + a[2] : "");
			},

			/**
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */
			_parseChange = function(e, b) {
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
			},

			/**
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value
			 */
			_parseVal = function(v, d) {
				return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v);
			},

			/**
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians
			 */
			_parseAngle = function(v, d, p, directionalEnd) {
				var min = 0.000001,
					cap, split, dif, result, isRelative;
				if (v == null) {
					result = d;
				} else if (typeof(v) === "number") {
					result = v;
				} else {
					cap = 360;
					split = v.split("_");
					isRelative = (v.charAt(1) === "=");
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {
						if (directionalEnd) {
							directionalEnd[p] = d + dif;
						}
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					result = d + dif;
				}
				if (result < min && result > -min) {
					result = 0;
				}
				return result;
			},

			_colorLookup = {aqua:[0,255,255],
				lime:[0,255,0],
				silver:[192,192,192],
				black:[0,0,0],
				maroon:[128,0,0],
				teal:[0,128,128],
				blue:[0,0,255],
				navy:[0,0,128],
				white:[255,255,255],
				fuchsia:[255,0,255],
				olive:[128,128,0],
				yellow:[255,255,0],
				orange:[255,165,0],
				gray:[128,128,128],
				purple:[128,0,128],
				green:[0,128,0],
				red:[255,0,0],
				pink:[255,192,203],
				cyan:[0,255,255],
				transparent:[255,255,255,0]},

			_hue = function(h, m1, m2) {
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},

			/**
			 * @private Parses a color (like #9F0, #FF9900, or rgb(255,51,153)) into an array with 3 elements for red, green, and blue. Also handles rgba() values (splits into array of 4 elements of course)
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order.
			 */
			_parseColor = CSSPlugin.parseColor = function(v) {
				var c1, c2, c3, h, s, l;
				if (!v || v === "") {
					return _colorLookup.black;
				}
				if (typeof(v) === "number") {
					return [v >> 16, (v >> 8) & 255, v & 255];
				}
				if (v.charAt(v.length - 1) === ",") { //sometimes a trailing commma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					return _colorLookup[v];
				}
				if (v.charAt(0) === "#") {
					if (v.length === 4) { //for shorthand like #9F0
						c1 = v.charAt(1),
						c2 = v.charAt(2),
						c3 = v.charAt(3);
						v = "#" + c1 + c1 + c2 + c2 + c3 + c3;
					}
					v = parseInt(v.substr(1), 16);
					return [v >> 16, (v >> 8) & 255, v & 255];
				}
				if (v.substr(0, 3) === "hsl") {
					v = v.match(_numExp);
					h = (Number(v[0]) % 360) / 360;
					s = Number(v[1]) / 100;
					l = Number(v[2]) / 100;
					c2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
					c1 = l * 2 - c2;
					if (v.length > 3) {
						v[3] = Number(v[3]);
					}
					v[0] = _hue(h + 1 / 3, c1, c2);
					v[1] = _hue(h, c1, c2);
					v[2] = _hue(h - 1 / 3, c1, c2);
					return v;
				}
				v = v.match(_numExp) || _colorLookup.transparent;
				v[0] = Number(v[0]);
				v[1] = Number(v[1]);
				v[2] = Number(v[2]);
				if (v.length > 3) {
					v[3] = Number(v[3]);
				}
				return v;
			},
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp+")", "gi");

		/**
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function
		 */
		var _getFormatter = function(dflt, clr, collapsible, multi) {
				if (dflt == null) {
					return function(v) {return v;};
				}
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
					numVals = dVals.length,
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
					formatter;
				if (!numVals) {
					return function(v) {return v;};
				}
				if (clr) {
					formatter = function(v) {
						var color, vals, i, a;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						color = (v.match(_colorExp) || [dColor])[0];
						vals = v.split(color).join("").match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
					};
					return formatter;

				}
				formatter = function(v) {
					var vals, a, i;
					if (typeof(v) === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					vals = v.match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + sfx;
				};
				return formatter;
			},

			/**
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function
			 */
			_getEdgeParser = function(props) {
				props = props.split(",");
				return function(t, e, p, cssp, pt, plugin, vars) {
					var a = (e + "").split(" "),
						i;
					vars = {};
					for (i = 0; i < 4; i++) {
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
					}
					return cssp.parse(t, vars, pt, plugin);
				};
			},

			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = Math.round(val);
					} else if (val < min && val > -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = proxy.rotation;
				}
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method.
				if (v === 1) {
					mpt = d.firstMPT;
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt.e = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.e = str;
						}
						mpt = mpt._next;
					}
				}
			},

			/**
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
			 * @param {!string} p property name
			 * @param {(number|string|object)} v value
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
			 */
			MiniPropTween = function(t, p, v, next, r) {
				this.t = t;
				this.p = p;
				this.v = v;
				this.r = r;
				if (next) {
					next._prev = this;
					this._next = next;
				}
			},

			/**
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
			 */
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt && pt !== bpt) {
					if (pt.type <= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i > 0) {
								xp = "xn" + i;
								p = pt.p + "_" + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			},



			/**
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
			 * @param {number} s Starting numeric value
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = r; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},

			/**
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *
			 * @param {!Object} t Target whose property will be tweened
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
			 * @param {string} b Beginning value
			 * @param {string} e Ending value
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
				b = b || dflt || "";
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += ""; //ensures it's a string
				var ba = b.split(", ").join(",").split(" "), //beginning array
					ea = e.split(", ").join(",").split(" "), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, rgba, temp, cv, str;
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
					ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
					ba = (dflt || "").split(" ");
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				for (i = 0; i < l; i++) {
					bv = ba[i];
					ev = ea[i];
					bn = parseFloat(bv);

					//if the value begins with a number (most common). It's fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);

					//if the value is a color
					} else if (clrs && (bv.charAt(0) === "#" || _colorLookup[bv] || _rgbhslExp.test(bv))) {
						str = ev.charAt(ev.length - 1) === "," ? ")," : ")"; //if there's a comma at the end, retain it.
						bv = _parseColor(bv);
						ev = _parseColor(ev);
						rgba = (bv.length + ev.length > 6);
						if (rgba && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) { //old versions of IE don't support rgba().
								rgba = false;
							}
							pt.appendXtra((rgba ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)
								.appendXtra("", bv[1], ev[1] - bv[1], ",", true)
								.appendXtra("", bv[2], ev[2] - bv[2], (rgba ? "," : str), true);
							if (rgba) {
								bv = (bv.length < 4) ? 1 : bv[3];
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
							}
						}

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt["xs" + pt.l] += pt.l ? " " + bv : bv;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
								return pt;
							}
							ni = 0;
							for (xi = 0; xi < bnums.length; xi++) {
								cv = bnums[xi];
								temp = bv.indexOf(cv, ni);
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
								ni = temp + cv.length;
							}
							pt["xs" + pt.l] += bv.substr(ni);
						}
					}
				}
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {
					str = pt.xs0 + pt.data.s;
					for (i = 1; i < pt.l; i++) {
						str += pt["xs" + i] + pt.data["xn" + i];
					}
					pt.e = str + pt["xs" + i];
				}
				if (!pt.l) {
					pt.type = -1;
					pt.xs0 = pt.e;
				}
				return pt.xfirst || pt;
			},
			i = 9;


		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


		/**
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
		 * @param {string=} pfx Prefix (if any)
		 * @param {!number} s Starting value
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)
		 * @param {boolean=} r Round (if true).
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
		 */
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt["xs" + l] += (pad && l) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")
		 * @param {Object=} options An object containing any of the following configuration options:
		 *                      - defaultValue: the default value
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */
		var SpecialProp = function(p, options) {
				options = options || {};
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;
				_specialProps[p] = _specialProps[this.p] = this;
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {
					this.parse = options.parser;
				}
				this.clrs = options.color;
				this.multi = options.multi;
				this.keyword = options.keyword;
				this.dflt = options.defaultValue;
				this.pr = options.priority || 0;
			},

			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
				if (typeof(options) !== "object") {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(","),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i < a.length; i++) {
					options.prefix = (i === 0 && options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			},

			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = function(p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			};


		p = SpecialProp.prototype;

		/**
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element
		 * @param {(string|number|object)} b beginning value
		 * @param {(string|number|object)} e ending (destination) value
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list
		 */
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
				i, ba, ea, l, bi, ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = (ea.length > ba.length) ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
		 * @param {Object=} vars Original vars object that contains the data for parsing.
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
		 *      var start = target.style.width;
		 *      return function(ratio) {
		 *              target.style.width = (start + value * ratio) + "px";
		 *              console.log("set width to " + target.style.width);
		 *          }
		 * }, 0);
		 *
		 * Then, when I do this tween, it will trigger my special property:
		 *
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
		 *
		 * In the example, of course, we're just changing the width, but you can do anything you want.
		 *
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		};






		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari; //Safari has some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead.
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",
			_transformOriginProp = _checkPropPrefix("transformOrigin"),
			_supports3D = (_checkPropPrefix("perspective") !== null),
			Transform = _internals.Transform = function() {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
			},
			_SVGElement = window.SVGElement,
			_useSVGTransformAttr,
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

			_createSVG = function(type, container, attributes) {
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
					reg = /([a-z])([A-Z])/g,
					p;
				for (p in attributes) {
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
				}
				container.appendChild(element);
				return element;
			},
			_docElement = _doc.documentElement,
			_forceSVGTransformAttr = (function() {
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !window.chrome),
					svg, rect, width;
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
					svg = _createSVG("svg", _docElement);
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});
					width = rect.getBoundingClientRect().width;
					rect.style[_transformOriginProp] = "50% 50%";
					rect.style[_transformProp] = "scaleX(0.5)";
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);
				}
				return force;
			})(),
			_parseSVGOrigin = function(e, local, decoratee, absolute) {
				var bbox, v;
				if (!absolute || !(v = absolute.split(" ")).length) {
					bbox = e.getBBox();
					local = _parsePosition(local).split(" ");
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * bbox.width : parseFloat(local[0])) + bbox.x,
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * bbox.height : parseFloat(local[1])) + bbox.y];
				}
				decoratee.xOrigin = parseFloat(v[0]);
				decoratee.yOrigin = parseFloat(v[1]);
				e.setAttribute("data-svg-origin", v.join(" "));
			},

			/**
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element
			 * @param {Object=} cs computed style object (optional)
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
			 */
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
				if (t._gsTransform && rec && !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					isDefault, s, m, i, n, dec, scaleX, scaleY, rotation, skewX;
				if (_transformProp) {
					s = _getStyle(t, _transformPropCSS, cs, true);
				} else if (t.currentStyle) {
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = t.currentStyle.filter.match(_ieGetMatrixExp);
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
				tm.svg = !!(_SVGElement && typeof(t.getBBox) === "function" && t.getCTM && (!t.parentNode || (t.parentNode.getBBox && t.parentNode.getCTM))); //don't just rely on "instanceof _SVGElement" because if the SVG is embedded via an object tag, it won't work (SVGElement is mapped to a different object)
				if (tm.svg) {
					if (isDefault && (t.style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = t.style[_transformProp];
						isDefault = false;
					}
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
					m = t.getAttribute("transform");
					if (isDefault && m && m.indexOf("matrix") !== -1) { //just in case there's a "transform" value specified as an attribute instead of CSS style. Only accept a matrix, though.
						s = m;
						isDefault = 0;
					}
				}
				if (!isDefault) {
					//split the matrix values out into an array (m for matrix)
					m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [];
					i = m.length;
					while (--i > -1) {
						n = Number(m[i]);
						m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
					}
					if (m.length === 16) {
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;

						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(a13, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							a11 = a11*cos+a12*sin;
							t2 = a21*cos+a22*sin;
							a22 = a21*-sin+a22*cos;
							a32 = a31*-sin+a32*cos;
							a21 = t2;
						}

						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY += 180;
						}

						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;
						tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;
						tm.skewX = 0;
						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
						tm.x = a14;
						tm.y = a24;
						tm.z = a34;
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
						}

					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY)) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),
							a = k ? m[0] : 1,
							b = m[1] || 0,
							c = m[2] || 0,
							d = k ? m[3] : 1;
						tm.x = m[4] || 0;
						tm.y = m[5] || 0;
						scaleX = Math.sqrt(a * a + b * b);
						scaleY = Math.sqrt(d * d + c * c);
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
						if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
							if (invX) {
								scaleX *= -1;
								skewX += (rotation <= 0) ? 180 : -180;
								rotation += (rotation <= 0) ? 180 : -180;
							} else {
								scaleY *= -1;
								skewX += (skewX <= 0) ? 180 : -180;
							}
						}
						tm.scaleX = scaleX;
						tm.scaleY = scaleY;
						tm.rotation = rotation;
						tm.skewX = skewX;
						if (_supports3D) {
							tm.rotationX = tm.rotationY = tm.z = 0;
							tm.perspective = defaultTransformPerspective;
							tm.scaleZ = 1;
						}
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a - tm.yOrigin * b);
							tm.y -= tm.yOrigin - (tm.yOrigin * d - tm.xOrigin * c);
						}
					}
					tm.zOrigin = zOrigin;
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {
						if (tm[i] < min) if (tm[i] > -min) {
							tm[i] = 0;
						}
					}
				}
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective);
				if (rec) {
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {
							_removeProp(t.style, _transformProp);
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
							t.removeAttribute("transform");
						}
					}
				}
				return tm;
			},

			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					ang = -t.rotation * _DEG2RAD,
					skew = ang + t.skewX * _DEG2RAD,
					rnd = 100000,
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
					style = this.t.style,
					cs = this.t.currentStyle,
					filters, val;
				if (!cs) {
					return;
				}
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;
				c = -val;
				filters = cs.filter;
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
				var w = this.t.offsetWidth,
					h = this.t.offsetHeight,
					clip = (cs.position !== "absolute"),
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
					ox = t.x + (w * t.xPercent / 100),
					oy = t.y + (h * t.yPercent / 100),
					dx, dy;

				//if transformOrigin is being used, adjust the offset x and y
				if (t.ox != null) {
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
					ox += dx - (dx * a + dy * b);
					oy += dy - (dx * c + dy * d);
				}

				if (!clip) {
					m += ", sizingMethod='auto expand')";
				} else {
					dx = (w / 2);
					dy = (h / 2);
					//translate to ensure that transformations occur around the correct origin (default is center).
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
				}
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
					style.filter = filters.replace(_ieSetMatrixExp, m);
				} else {
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}

				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");
				}

				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;
					dx = t.ieOffsetX || 0;
					dy = t.ieOffsetY || 0;
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
					for (i = 0; i < 4; i++) {
						prop = _margins[i];
						marg = cs[prop];
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
					}
				}
			},

			/* translates a super small decimal to a string WITHOUT scientific notation
			_safeDecimal = function(n) {
				var s = (n < 0 ? -n : n) + "",
					a = s.split("e-");
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
			},
			*/

			_set3DTransformRatio = _internals.set3DTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					style = this.t.style,
					angle = t.rotation * _DEG2RAD,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					perspective = t.perspective,
					a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t1, t2, transform, comma, zero;
				if (v === 1 || v === 0 || !t.force3D) if (t.force3D !== true) if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !z && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.
					_set2DTransformRatio.call(this, v);
					return;
				}
				if (_isFirefox) {
					min = 0.0001;
					if (sx < min && sx > -min) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
						sx = sz = 0.00002;
					}
					if (sy < min && sy > -min) {
						sy = sz = 0.00002;
					}
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;
					}
				}
				if (angle || t.skewX) {
					cos = a11 = Math.cos(angle);
					sin = a21 = Math.sin(angle);
					if (t.skewX) {
						angle -= t.skewX * _DEG2RAD;
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(t.skewX * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							cos *= t1;
							sin *= t1;
						}
					}
					a12 = -sin;
					a22 = cos;

				} else if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !t.svg) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;
				} else {
					a11 = a22 = 1;
					a12 = a21 = 0;
				}
				// KEY  INDEX   AFFECTS
				// a11  0       rotation, rotationY, scaleX
				// a21  1       rotation, rotationY, scaleX
				// a31  2       rotationY, scaleX
				// a41  3       rotationY, scaleX
				// a12  4       rotation, skewX, rotationX, scaleY
				// a22  5       rotation, skewX, rotationX, scaleY
				// a32  6       rotationX, scaleY
				// a42  7       rotationX, scaleY
				// a13  8       rotationY, rotationX, scaleZ
				// a23  9       rotationY, rotationX, scaleZ
				// a33  10      rotationY, rotationX, scaleZ
				// a43  11      rotationY, rotationX, perspective, scaleZ
				// a14  12      x, zOrigin, svgOrigin
				// a24  13      y, zOrigin, svgOrigin
				// a34  14      z, zOrigin
				// a44  15
				// rotation: Math.atan2(a21, a11)
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
				// rotationX: Math.atan2(a32, a33)
				a33 = 1;
				a13 = a23 = a31 = a32 = a41 = a42 = 0;
				a43 = (perspective) ? -1 / perspective : 0;
				zOrigin = t.zOrigin;
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.
				comma = ",";
				zero = "0";
				angle = t.rotationY * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					a31 = -sin;
					a41 = a43*-sin;
					a13 = a11*sin;
					a23 = a21*sin;
					a33 = cos;
					a43 *= cos;
					a11 *= cos;
					a21 *= cos;
				}
				angle = t.rotationX * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					a32 = a33*sin;
					a42 = a43*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a33*cos;
					a43 = a43*cos;
					a12 = t1;
					a22 = t2;
				}
				if (sz !== 1) {
					a13*=sz;
					a23*=sz;
					a33*=sz;
					a43*=sz;
				}
				if (sy !== 1) {
					a12*=sy;
					a22*=sy;
					a32*=sy;
					a42*=sy;
				}
				if (sx !== 1) {
					a11*=sx;
					a21*=sx;
					a31*=sx;
					a41*=sx;
				}

				if (zOrigin || t.svg) {
					if (zOrigin) {
						x += a13*-zOrigin;
						y += a23*-zOrigin;
						z += a33*-zOrigin+zOrigin;
					}
					if (t.svg) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12);
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22);
					}
					if (x < min && x > -min) {
						x = zero;
					}
					if (y < min && y > -min) {
						y = zero;
					}
					if (z < min && z > -min) {
						z = 0; //don't use string because we calculate perspective later and need the number.
					}
				}

				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (t.rotationX || t.rotationY) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {
					transform += ",0,0,0,0,1,0,";
				}
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

				style[_transformProp] = transform;
			},

			_set2DTransformRatio = _internals.set2DTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					targ = this.t,
					style = targ.style,
					x = t.x,
					y = t.y,
					ang, skew, rnd, sx, sy, a, b, c, d, matrix, min, t1;
				if ((t.rotationX || t.rotationY || t.z || t.force3D === true || (t.force3D === "auto" && v !== 1 && v !== 0)) && !(t.svg && _useSVGTransformAttr) && _supports3D) { //if a 3D tween begins while a 2D one is running, we need to kick the rendering over to the 3D method. For example, imagine a yoyo-ing, infinitely repeating scale tween running, and then the object gets rotated in 3D space with a different tween.
					this.setRatio = _set3DTransformRatio;
					_set3DTransformRatio.call(this, v);
					return;
				}
				sx = t.scaleX;
				sy = t.scaleY;
				if (t.rotation || t.skewX || t.svg) {
					ang = t.rotation * _DEG2RAD;
					skew = t.skewX * _DEG2RAD;
					rnd = 100000;
					a = Math.cos(ang) * sx;
					b = Math.sin(ang) * sx;
					c = Math.sin(ang - skew) * -sy;
					d = Math.cos(ang - skew) * sy;
					if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(skew);
						t1 = Math.sqrt(1 + t1 * t1);
						c *= t1;
						d *= t1;
					}
					if (t.svg) {
						x += t.xOrigin - (t.xOrigin * a + t.yOrigin * c);
						y += t.yOrigin - (t.xOrigin * b + t.yOrigin * d);
						min = 0.000001;
						if (x < min) if (x > -min) {
							x = 0;
						}
						if (y < min) if (y > -min) {
							y = 0;
						}
					}
					matrix = (((a * rnd) | 0) / rnd) + "," + (((b * rnd) | 0) / rnd) + "," + (((c * rnd) | 0) / rnd) + "," + (((d * rnd) | 0) / rnd) + "," + x + "," + y + ")";
					if (t.svg && _useSVGTransformAttr) {
						targ.setAttribute("transform", "matrix(" + matrix);
					} else {
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + matrix;
					}
				} else {
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
				}
			};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;
			var m1 = cssp._transform = _getTransform(t, _cs, true, vars.parseTransform),
				style = t.style,
				min = 0.000001,
				i = _transformProps.length,
				v = vars,
				endRotations = {},
				m2, skewY, copy, orig, has3D, hasChange, dr;
			if (typeof(v.transform) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = v.transform;
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";
				_doc.body.appendChild(_tempDiv);
				m2 = _getTransform(_tempDiv, null, false);
				_doc.body.removeChild(_tempDiv);
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
					x:_parseVal(v.x, m1.x),
					y:_parseVal(v.y, m1.y),
					z:_parseVal(v.z, m1.z),
					xPercent:_parseVal(v.xPercent, m1.xPercent),
					yPercent:_parseVal(v.yPercent, m1.yPercent),
					perspective:_parseVal(v.transformPerspective, m1.perspective)};
				dr = v.directionalRotation;
				if (dr != null) {
					if (typeof(dr) === "object") {
						for (copy in dr) {
							v[copy] = dr[copy];
						}
					} else {
						v.rotation = dr;
					}
				}
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
					m2.x = 0;
					m2.xPercent = _parseVal(v.x, m1.xPercent);
				}
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
					m2.y = 0;
					m2.yPercent = _parseVal(v.y, m1.yPercent);
				}

				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
				if (_supports3D) {
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}
				m2.skewX = (v.skewX == null) ? m1.skewX : _parseAngle(v.skewX, m1.skewX);

				//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
				m2.skewY = (v.skewY == null) ? m1.skewY : _parseAngle(v.skewY, m1.skewY);
				if ((skewY = m2.skewY - m1.skewY)) {
					m2.skewX += skewY;
					m2.rotation += skewY;
				}
			}
			if (_supports3D && v.force3D != null) {
				m1.force3D = v.force3D;
				hasChange = true;
			}

			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {
				m2.scaleZ = 1; //no need to tween scaleZ.
			}

			while (--i > -1) {
				p = _transformProps[i];
				orig = m2[p] - m1[p];
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
					hasChange = true;
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);
					if (p in endRotations) {
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()
					pt.plugin = plugin;
					cssp._overwriteProps.push(pt.n);
				}
			}

			orig = v.transformOrigin;
			if (m1.svg && (orig || v.svgOrigin)) {
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin);
				pt = new CSSPropTween(m1, "xOrigin", m1.xOrigin, m2.xOrigin - m1.xOrigin, pt, -1, "transformOrigin");
				pt.b = m1.xOrigin;
				pt.e = pt.xs0 = m2.xOrigin;
				pt = new CSSPropTween(m1, "yOrigin", m1.yOrigin, m2.yOrigin - m1.yOrigin, pt, -1, "transformOrigin");
				pt.b = m1.yOrigin;
				pt.e = pt.xs0 = m2.yOrigin;
				orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {
					hasChange = true;
					p = _transformOriginProp;
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin");
					pt.b = style[p];
					pt.plugin = plugin;
					if (_supports3D) {
						copy = m1.zOrigin;
						orig = orig.split(" ");
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;
						pt.xs0 = pt.e = m1.zOrigin;
					} else {
						pt.xs0 = pt.e = orig;
					}

				//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {
					_parsePosition(orig + "", m1);
				}
			}
			if (hasChange) {
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}
			return pt;
		}, prefix:true});

		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});

		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			e = this.format(e);
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
				style = t.style,
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
			w = parseFloat(t.offsetWidth);
			h = parseFloat(t.offsetHeight);
			ea1 = e.split(" ");
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix
					props[i] = _checkPropPrefix(props[i]);
				}
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
				if (bs.indexOf(" ") !== -1) {
					bs2 = bs.split(" ");
					bs = bs2[0];
					bs2 = bs2[1];
				}
				es = es2 = ea1[i];
				bn = parseFloat(bs);
				bsfx = bs.substr((bn + "").length);
				rel = (es.charAt(1) === "=");
				if (rel) {
					en = parseInt(es.charAt(0)+"1", 10);
					es = es.substr(2);
					en *= parseFloat(es);
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
				} else {
					en = parseFloat(es);
					esfx = es.substr((en + "").length);
				}
				if (esfx === "") {
					esfx = _suffixMap[p] || bsfx;
				}
				if (esfx !== bsfx) {
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
					if (esfx === "%") {
						bs = (hn / w * 100) + "%";
						bs2 = (vn / h * 100) + "%";
					} else if (esfx === "em") {
						em = _convertToPixels(t, "borderLeft", 1, "em");
						bs = (hn / em) + "em";
						bs2 = (vn / em) + "em";
					} else {
						bs = hn + "px";
						bs2 = vn + "px";
					}
					if (rel) {
						es = (parseFloat(bs) + en) + esfx;
						es2 = (parseFloat(bs2) + en) + esfx;
					}
				}
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
			}
			return pt;
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
			var bp = "background-position",
				cs = (_cs || _getComputedStyle(t, null)),
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				ba, ea, i, pct, overlap, src;
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1)) {
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
				if (src && src !== "none") {
					ba = bs.split(" ");
					ea = es.split(" ");
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;
					while (--i > -1) {
						bs = ba[i];
						pct = (bs.indexOf("%") !== -1);
						if (pct !== (ea[i].indexOf("%") !== -1)) {
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
						}
					}
					bs = ba.join(" ");
				}
			}
			return this.parseComplex(t.style, bs, es, pt, plugin);
		}, formatter:_parsePosition});
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:_parsePosition});
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
		_registerComplexSpecialProp("transformStyle", {prefix:true});
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
		_registerComplexSpecialProp("userSelect", {prefix:true});
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;
				delim = _ieVers < 8 ? " " : ",";
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
				e = this.format(e).split(",").join(delim);
			} else {
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
				e = this.format(e);
			}
			return this.parseComplex(t.style, b, e, pt, plugin);
		}});
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
				return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
			}, color:true, formatter:function(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			}});
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
			var s = t.style,
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
		}});

		//opacity-related
		var _setIEOpacityRatio = function(v) {
				var t = this.t, //refers to the element's style property
					filters = t.filter || _getStyle(this.data, "filter") || "",
					val = (this.s + this.c * v) | 0,
					skip;
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
						t.removeAttribute("filter");
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
				}
				if (!skip) {
					if (this.xn1) {
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}
					} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
				}
			};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				style = t.style,
				isAutoAlpha = (p === "autoAlpha");
			if (typeof(e) === "string" && e.charAt(1) === "=") {
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
			}
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;
			}
			if (_supportsOpacity) {
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);
			} else {
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.
				pt.type = 2;
				pt.b = "alpha(opacity=" + pt.s + ")";
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
				pt.data = t;
				pt.plugin = plugin;
				pt.setRatio = _setIEOpacityRatio;
			}
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";
				cssp._overwriteProps.push(pt.n);
				cssp._overwriteProps.push(p);
			}
			return pt;
		}});


		var _removeProp = function(s, p) {
				if (p) {
					if (s.removeProperty) {
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;
						}
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				}
			},
			_setClassNameRatio = function(v) {
				this.t._gsClassPT = this;
				if (v === 1 || v === 0) {
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);
					var mpt = this.data, //first MiniPropTween
						s = this.t.style;
					while (mpt) {
						if (!mpt.v) {
							_removeProp(s, mpt.p);
						} else {
							s[mpt.p] = mpt.v;
						}
						mpt = mpt._next;
					}
					if (v === 1 && this.t._gsClassPT === this) {
						this.t._gsClassPT = null;
					}
				} else if (this.t.getAttribute("class") !== this.e) {
					this.t.setAttribute("class", this.e);
				}
			};
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				difData, bs, cnpt, cnptLookup, mpt;
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClassNameRatio;
			pt.pr = -11;
			_hasPriority = true;
			pt.b = b;
			bs = _getAllStyles(t, _cs);
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;
			if (cnpt) {
				cnptLookup = {};
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {
					cnptLookup[mpt.p] = 1;
					mpt = mpt._next;
				}
				cnpt.setRatio(1);
			}
			t._gsClassPT = pt;
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			if (cssp._tween._duration) { //if it's a zero-duration tween, there's no need to tween anything or parse the data. In fact, if we switch classes temporarily (which we must do for proper parsing) and the class has a transition applied, it could cause a quick flash to the end state and back again initially in some browsers.
				t.setAttribute("class", pt.e);
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
				t.setAttribute("class", b);
				pt.data = difData.firstMPT;
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			}
			return pt;
		}});


		var _setClearPropsRatio = function(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
					transformParse = _specialProps.transform.parse,
					a, p, i, clearTransform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					if (this.t._gsTransform) {
						delete this.t._gsTransform;
					}
				}

			}
		};
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClearPropsRatio;
			pt.e = e;
			pt.pr = -10;
			pt.data = cssp._tween;
			_hasPriority = true;
			return pt;
		}});

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}








		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function(target, vars, tween) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = target;
			this._tween = tween;
			this._vars = vars;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof(vars) === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}
			this._firstPT = pt = this.parse(target, vars, null);

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = (threeD && _supports3D) ? _set3DTransformRatio : _transformProp ? _set2DTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};


		p.parse = function(target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);

				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = (typeof(es) === "string");
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

					} else if (isStr && (es.indexOf(" ") !== -1 || es.indexOf(",") !== -1)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = (p !== "opacity") ? 0 : 1;
								bsfx = "";
							}
						}

						rel = (isStr && es.charAt(1) === "=");
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}

							} else if (esfx === "em") {
								bn /= _convertToPixels(target, p, 1, "em");

							//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};


		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.e;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
		 * @private
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you
		 * want and it won't create duplicate CSSPropTweens.
		 *
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */
		p._enableTransforms = function(threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};

		var lazySet = function(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function(t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function(pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};



		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function(e, props, targets) {
				var children, i, child, type;
				if (e.slice) {
					i = e.length;
					while (--i > -1) {
						_getChildStyles(e[i], props, targets);
					}
					return;
				}
				children = e.childNodes;
				i = children.length;
				while (--i > -1) {
					child = children[i];
					type = child.type;
					if (child.style) {
						props.push(_getAllStyles(child));
						if (targets) {
							targets.push(child);
						}
					}
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
						_getChildStyles(child, props, targets);
					}
				}
			};

		/**
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
		 * and it would create other problems. For example:
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *
		 * @param {Object} target object to be tweened
		 * @param {number} Duration in seconds (or frames for frames-based tweens)
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
		 * @return {Array} An array of TweenLite instances
		 */
		CSSPlugin.cascadeTo = function(target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = TweenLite._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;

	}, true);

	
	
	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * RoundPropsPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
				propName: "roundProps",
				priority: -1,
				API: 2,

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {
					this._tween = tween;
					return true;
				}

			}),
			p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function() {
			var tween = this._tween,
				rp = (tween.vars.roundProps instanceof Array) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
				i = rp.length,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				prop, pt, next;
			while (--i > -1) {
				lookup[rp[i]] = 1;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._roundProps(lookup, true);
					} else if (pt.n === prop) {
						this._add(pt.t, prop, pt.s, pt.c);
						//remove from linked list
						if (next) {
							next._prev = pt._prev;
						}
						if (pt._prev) {
							pt._prev._next = next;
						} else if (tween._firstPT === pt) {
							tween._firstPT = next;
						}
						pt._next = pt._prev = null;
						tween._propLookup[prop] = rpt;
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c) {
			this._addTween(target, p, s, s + c, p, true);
			this._overwriteProps.push(p);
		};

	}());










/*
 * ----------------------------------------------------------------
 * AttrPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "attr",
		API: 2,
		version: "0.3.3",

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			var p, start, end;
			if (typeof(target.setAttribute) !== "function") {
				return false;
			}
			this._target = target;
			this._proxy = {};
			this._start = {}; // we record start and end values exactly as they are in case they're strings (not numbers) - we need to be able to revert to them cleanly.
			this._end = {};
			for (p in value) {
				this._start[p] = this._proxy[p] = start = target.getAttribute(p);
				end = this._addTween(this._proxy, p, parseFloat(start), value[p], p);
				this._end[p] = end ? end.s + end.c : value[p];
				this._overwriteProps.push(p);
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			this._super.setRatio.call(this, ratio);
			var props = this._overwriteProps,
				i = props.length,
				lookup = (ratio === 1) ? this._end : ratio ? this._proxy : this._start,
				p;
			while (--i > -1) {
				p = props[i];
				this._target.setAttribute(p, lookup[p] + "");
			}
		}

	});










/*
 * ----------------------------------------------------------------
 * DirectionalRotationPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;







	
	
	
	
/*
 * ----------------------------------------------------------------
 * EasePack
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, RoughEase, _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function(steps) {
			return new SteppedEase(steps);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
		
	}, true);


});

if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function(window, moduleName) {

		"use strict";
		var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							if (typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (ns === moduleName && typeof(module) !== "undefined" && module.exports){ //node
								module.exports = cl;
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			_blankArray = [],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame),
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function() {
				if (_id !== null) {
					_self.sleep();
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF && (!_id || _self.frame < 5)) {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {
					_ticker.wake();
				}
				setTimeout(_checkTimeout, 2000);
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				var pauseTime = this._pauseTime,
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			return this._uncache(false);
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					this.render((tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale), true, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(-this._delay);
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.16.0";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},

			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (_onOverwrite(curTween, tween) && curTween._enabled(false, false)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},

			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null)) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:true, n:p, pg:true, pr:plugin._priority};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}

				} else {
					this._firstPT = propLookup[p] = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === "function"), n:p, pg:false, pr:0};
					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
					pt.c = (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : (Number(v) - pt.s) || 0;
				}
				if (pt) if (pt._next) {
					pt._next._prev = pt;
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration) {
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i])) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if (!_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(-this._delay);
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.10.1";
		TweenPlugin.API = 2;
		p._firstPT = null;

		p._addTween = function(target, prop, start, end, overwriteProp, round) {
			var c, pt;
			if (end != null && (c = (typeof(end) === "number" || end.charAt(1) !== "=") ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
				this._firstPT = pt = {_next:this._firstPT, t:target, p:prop, s:start, c:c, f:(typeof(target[prop]) === "function"), n:overwriteProp || prop, r:round};
				if (pt._next) {
					pt._next._prev = pt;
				}
				return pt;
			}
		};

		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val;
			while (pt) {
				val = pt.c * v + pt.s;
				if (pt.r) {
					val = Math.round(val);
				} else if (val < min) if (val > -min) { //prevents issues with converting very small numbers to strings in the browser
					val = 0;
				}
				if (pt.f) {
					pt.t[pt.p](val);
				} else {
					pt.t[pt.p] = val;
				}
				pt = pt._next;
			}
		};

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._roundProps = function(lookup, value) {
			var pt = this._firstPT;
			while (pt) {
				if (lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ])) { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					pt.r = value;
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_roundProps", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: com.greensock." + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/luke/dev/040715/vendor/hammerjs/hammer.js":[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],"/Users/luke/dev/040715/vendor/page/page.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.page=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /* globals require, module */

/**
   * Module dependencies.
   */

  var pathtoRegexp = require('path-to-regexp');

  /**
   * Module exports.
   */

  module.exports = page;

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var location = window.history.location || window.location;

  /**
   * Perform initial dispatch.
   */

  var dispatch = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
  * HashBang option
  */

  var hashbang = false;

  /**
   * Previous context, for capturing
   * page exit events.
   */

  var prevContext;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
    // show <path> with [state]
    } else if ('string' == typeof path) {
      'string' === typeof fn
        ? page.redirect(path, fn)
        : page.show(path, fn);
    // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];
  page.exits = [];

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path){
    if (0 === arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options){
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) window.addEventListener('click', onclick, false);
    if (true === options.hashbang) hashbang = true;
    if (!dispatch) return;
    var url = (hashbang && ~location.hash.indexOf('#!'))
      ? location.hash.substr(2) + location.search
      : location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function(){
    if (!running) return;
    running = false;
    window.removeEventListener('click', onclick, false);
    window.removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch){
    var ctx = new Context(path, state);
    if (false !== dispatch) page.dispatch(ctx);
    if (false !== ctx.handled) ctx.pushState();
    return ctx;
  };

  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {String} from - if param 'to' is undefined redirects to 'from'
   * @param {String} [to]
   * @api public
   */
  page.redirect = function(from, to) {
    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page(from, function (e) {
        setTimeout(function() {
          page.replace(to);
        },0);
      });
    }

    // Wait for the push state and replace it with another
    if('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
          page.replace(from);
      },0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */

  page.replace = function(path, state, init, dispatch){
    var ctx = new Context(path, state);
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) page.dispatch(ctx);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx){
    var prev = prevContext;
    var i = 0;
    var j = 0;

    prevContext = ctx;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];
      if (!fn) return unhandled(ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;

    if (hashbang) {
      current = base + location.hash.replace('#!','');
    } else {
      current = location.pathname + location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    location.href = ctx.canonicalPath;
  }

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  page.exit = function(path, fn) {
    if (typeof path == 'function') {
      return page.exit('*', path);
    };

    var route = new Route(path);
    for (var i = 1; i < arguments.length; ++i) {
      page.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
  * Remove URL encoding from the given `str`.
  * Accommodates whitespace in both x-www-form-urlencoded
  * and regular percent-encoded form.
  *
  * @param {str} URL component to decode
  */
  function decodeURLEncodedURIComponent(str) {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    path = decodeURLEncodedURIComponent(path);
    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i
      ? path.slice(i + 1)
      : '';
    this.pathname = ~i
      ? path.slice(0, i)
      : path;
    this.params = [];

    // fragment
    this.hash = '';
    if (!~this.path.indexOf('#')) return;
    var parts = this.path.split('#');
    this.path = parts[0];
    this.hash = parts[1] || '';
    this.querystring = this.querystring.split('#')[0];
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function(){
    history.pushState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function(){
    history.replaceState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(this.path,
      this.keys = [],
      options.sensitive,
      options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn){
    var self = this;
    return function(ctx, next){
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Array} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params){
    var keys = this.keys,
        qsIndex = path.indexOf('?'),
        pathname = ~qsIndex
          ? path.slice(0, qsIndex)
          : path,
        m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];

      var val = 'string' === typeof m[i]
        ? decodeURIComponent(m[i])
        : m[i];

      if (key) {
        params[key.name] = undefined !== params[key.name]
          ? params[key.name]
          : val;
      } else {
        params.push(val);
      }
    }

    return true;
  };

  /**
   * Handle "populate" events.
   */

  function onpopstate(e) {
    if (e.state) {
      var path = e.state.path;
      page.replace(path, e.state);
    }
  }

  /**
   * Handle "click" events.
   */

  function onclick(e) {
    if (1 != which(e)) return;
    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    var el = e.target;
    while (el && 'A' != el.nodeName) el = el.parentNode;
    if (!el || 'A' != el.nodeName) return;

    // Ignore if tag has a "download" attribute
    if (el.getAttribute("download")) return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (el.pathname === location.pathname && (el.hash || '#' === link)) return;

    // Check for mailto: in the href
    if (link && link.indexOf("mailto:") > -1) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;

    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // same page
    var orig = path;

    path = path.replace(base, '');

    if (base && orig === path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null === e.which
      ? e.button
      : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return (href && (0 === href.indexOf(origin)));
  }

  page.sameOrigin = sameOrigin;

},{"path-to-regexp":2}],2:[function(require,module,exports){
/**
 * Expose `pathtoRegexp`.
 */
module.exports = pathtoRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match already escaped characters that would otherwise incorrectly appear
  // in future matches. This allows the user to escape special characters that
  // shouldn't be transformed.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that should always be escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
var attachKeys = function (re, keys) {
  re.keys = keys;

  return re;
};

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array should be passed in, which will contain the placeholder key
 * names. For example `/user/:id` will then contain `["id"]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 keys
 * @param  {Object}                options
 * @return {RegExp}
 */
function pathtoRegexp (path, keys, options) {
  if (keys && !Array.isArray(keys)) {
    options = keys;
    keys = null;
  }

  keys = keys || [];
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var index = 0;

  if (path instanceof RegExp) {
    // Match all capturing groups of a regexp.
    var groups = path.source.match(/\((?!\?)/g) || [];

    // Map all the matches to their numeric keys and push into the keys.
    keys.push.apply(keys, groups.map(function (match, index) {
      return {
        name:      index,
        delimiter: null,
        optional:  false,
        repeat:    false
      };
    }));

    // Return the source back to the user.
    return attachKeys(path, keys);
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    // Generate a new regexp instance by joining all the parts together.
    return attachKeys(new RegExp('(?:' + path.join('|') + ')', flags), keys);
  }

  // Alter the path string into a usable regexp.
  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {
    // Avoiding re-escaping escaped characters.
    if (escaped) {
      return escaped;
    }

    // Escape regexp special characters.
    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    // Escape the prefix character.
    prefix = prefix ? '\\' + prefix : '';

    // Match using the custom capturing group, or fallback to capturing
    // everything up to the next slash (or next period if the param was
    // prefixed with a period).
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    // Allow parameters to be repeated more than once.
    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    // Allow a parameter to be optional.
    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  });

  // Check whether the path ends in a slash as it alters some match behaviour.
  var endsWithSlash = path[path.length - 1] === '/';

  // In non-strict mode we allow an optional trailing slash in the match. If
  // the path to match already ended with a slash, we need to remove it for
  // consistency. The slash is only valid at the very end of a path match, not
  // anywhere in the middle. This is important for non-ending mode, otherwise
  // "/test/" will match "/test//route".
  if (!strict) {
    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\/(?=$))?';
  }

  // In non-ending mode, we need prompt the capturing groups to match as much
  // as possible by using a positive lookahead for the end or next path segment.
  if (!end) {
    path += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + path + (end ? '$' : ''), flags), keys);
};

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"path-to-regexp":"/Users/luke/dev/040715/node_modules/path-to-regexp/index.js"}],"/Users/luke/dev/040715/vendor/ractive-events-tap/ractive-events-tap.js":[function(require,module,exports){
/*

	ractive-events-tap
	==================

	Version 0.1.2.

	On mobile devices, using `on-click` isn't good enough. Tapping the
	touchscreen will fire a simulated click event, but only after a 300
	millisecond delay, which makes your app feel sluggish. It also
	causes the tapped area to highlight, which in most cases looks a
	bit messy.

	Instead, use `on-tap`. When you tap an area, the simulated click
	event will be prevented, and the user's action is responded to
	instantly. The `on-tap` event also differs from `on-click` in that
	the click event will (frankly rather bizarrely) fire even if you
	hold the mouse down over a single element for several seconds and
	waggle it about.

	Pointer events are also supported, as is pressing the spacebar when
	the relevant element is focused (which triggers a click event, and
	is good for accessibility).

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-events-tap.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-events-tap' );

	Add a tap event in the normal fashion:

	    <div on-tap='foo'>tap me!</div>

	Then add a handler:

	    ractive.on( 'foo', function ( event ) {
	      alert( 'tapped' );
	    });

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-events-tap plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var tap = function ( node, fire ) {
		var mousedown, touchstart, focusHandler, distanceThreshold, timeThreshold, preventMousedownEvents, preventMousedownTimeout;

		distanceThreshold = 5; // maximum pixels pointer can move before cancel
		timeThreshold = 400;   // maximum milliseconds between down and up before cancel

		mousedown = function ( event ) {
			var currentTarget, x, y, pointerId, up, move, cancel;

			if ( preventMousedownEvents ) {
				return;
			}

			if ( event.which !== undefined && event.which !== 1 ) {
				return;
			}

			x = event.clientX;
			y = event.clientY;
			currentTarget = this;
			// This will be null for mouse events.
			pointerId = event.pointerId;

			up = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				if ( ( Math.abs( event.clientX - x ) >= distanceThreshold ) || ( Math.abs( event.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'MSPointerUp', up, false );
				document.removeEventListener( 'MSPointerMove', move, false );
				document.removeEventListener( 'MSPointerCancel', cancel, false );
				node.removeEventListener( 'pointerup', up, false );
				document.removeEventListener( 'pointermove', move, false );
				document.removeEventListener( 'pointercancel', cancel, false );
				node.removeEventListener( 'click', up, false );
				document.removeEventListener( 'mousemove', move, false );
			};

			if ( window.navigator.pointerEnabled ) {
				node.addEventListener( 'pointerup', up, false );
				document.addEventListener( 'pointermove', move, false );
				document.addEventListener( 'pointercancel', cancel, false );
			} else if ( window.navigator.msPointerEnabled ) {
				node.addEventListener( 'MSPointerUp', up, false );
				document.addEventListener( 'MSPointerMove', move, false );
				document.addEventListener( 'MSPointerCancel', cancel, false );
			} else {
				node.addEventListener( 'click', up, false );
				document.addEventListener( 'mousemove', move, false );
			}

			setTimeout( cancel, timeThreshold );
		};

		if ( window.navigator.pointerEnabled ) {
			node.addEventListener( 'pointerdown', mousedown, false );
		} else if ( window.navigator.msPointerEnabled ) {
			node.addEventListener( 'MSPointerDown', mousedown, false );
		} else {
			node.addEventListener( 'mousedown', mousedown, false );
		}


		touchstart = function ( event ) {
			var currentTarget, x, y, touch, finger, move, up, cancel;

			if ( event.touches.length !== 1 ) {
				return;
			}

			touch = event.touches[0];

			x = touch.clientX;
			y = touch.clientY;
			currentTarget = this;

			finger = touch.identifier;

			up = function ( event ) {
				var touch;

				touch = event.changedTouches[0];
				if ( touch.identifier !== finger ) {
					cancel();
				}

				event.preventDefault();  // prevent compatibility mouse event

				// for the benefit of mobile Firefox and old Android browsers, we need this absurd hack.
				preventMousedownEvents = true;
				clearTimeout( preventMousedownTimeout );

				preventMousedownTimeout = setTimeout( function () {
					preventMousedownEvents = false;
				}, 400 );

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				var touch;

				if ( event.touches.length !== 1 || event.touches[0].identifier !== finger ) {
					cancel();
				}

				touch = event.touches[0];
				if ( ( Math.abs( touch.clientX - x ) >= distanceThreshold ) || ( Math.abs( touch.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'touchend', up, false );
				window.removeEventListener( 'touchmove', move, false );
				window.removeEventListener( 'touchcancel', cancel, false );
			};

			node.addEventListener( 'touchend', up, false );
			window.addEventListener( 'touchmove', move, false );
			window.addEventListener( 'touchcancel', cancel, false );

			setTimeout( cancel, timeThreshold );
		};

		node.addEventListener( 'touchstart', touchstart, false );


		// native buttons, and <input type='button'> elements, should fire a tap event
		// when the space key is pressed
		if ( node.tagName === 'BUTTON' || node.type === 'button' ) {
			focusHandler = function () {
				var blurHandler, keydownHandler;

				keydownHandler = function ( event ) {
					if ( event.which === 32 ) { // space key
						fire({
							node: node,
							original: event
						});
					}
				};

				blurHandler = function () {
					node.removeEventListener( 'keydown', keydownHandler, false );
					node.removeEventListener( 'blur', blurHandler, false );
				};

				node.addEventListener( 'keydown', keydownHandler, false );
				node.addEventListener( 'blur', blurHandler, false );
			};

			node.addEventListener( 'focus', focusHandler, false );
		}


		return {
			teardown: function () {
				node.removeEventListener( 'pointerdown', mousedown, false );
				node.removeEventListener( 'MSPointerDown', mousedown, false );
				node.removeEventListener( 'mousedown', mousedown, false );
				node.removeEventListener( 'touchstart', touchstart, false );
				node.removeEventListener( 'focus', focusHandler, false );
			}
		};
	};

	Ractive.events.tap = tap;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-touch/index.js":[function(require,module,exports){
;(function (root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['ractive', 'hammerjs'], factory);
  }

  else if (typeof module !== 'undefined') {
    factory(require("./../ractive/ractive.js"), require("./../hammerjs/hammer.js"));
  }

  else {
    factory(root.Ractive, root.Hammer);
  }

}(this, function (Ractive, Hammer) {

  // Check the recognizers documentation.
  // http://hammerjs.github.io/recognizer-tap

  var defaults = {
    tap: {
      recognizerClass: Hammer.Tap,
      options: {
        time: 500
      },
      events: [
        'tap' 
      ]
    },
    doubletap: {
      recognizerClass: Hammer.Tap,
      options: {
        taps: 2,
        event: 'doubletap'
      },
      recognizeWith: ['tap'],
      events: [
        'doubletap' 
      ]
    },
    swipe: {
      recognizerClass: Hammer.Swipe,
      options: {},
      events: [
        'swipe',
        'swipeleft',
        'swiperight',
        'swipeup',
        'swipedown' 
      ]
    },
    pan: {
      recognizerClass: Hammer.Pan,
      options: {
        direction: Hammer.DIRECTION_HORIZONTAL
      },
      recognizeWith: ['swipe'],
      events: [
        'pan',
        'panstart',
        'panmove',
        'panend',
        'pancancel',
        'panleft',
        'panright',
        'panup',
        'pandown' 
      ]
    },
    press: {
      recognizerClass: Hammer.Press,
      options: {},
      events: [
        'press' 
      ]
    },
    rotate: {
      recognizerClass: Hammer.Rotate,
      options: {},
      events: [
        'rotate',
        'rotatestart',
        'rotatemove',
        'rotateend',
        'rotatecancel' 
      ]
    },
    pinch: {
      recognizerClass: Hammer.Pinch,
      options: {},
      recognizeWith: ['rotate'],
      events: [
        'pinch',
        'pinchstart',
        'pinchmove',
        'pinchend',
        'pinchcancel',
        'pinchin',
        'pinchout' 
      ]
    }
  };

  var aliases;

  // bind all events using buildEvent
  for (var recognizerName in defaults) {
    if (!defaults.hasOwnProperty(recognizerName)) continue;
    
    var events = defaults[recognizerName].events;
    for (var i = 0; i < events.length; i++) {
      buildEvent(events[i], recognizerName, defaults[recognizerName]);
    }
  }

  /**
   * buildEvent : buildEvent(event, recognizerName, config)
   * (private) registers an event handler for buildEvent.
   *
   *     buildEvent('panstart', 'pan', { ... });
   */

  function buildEvent(eventName, recognizerName, config) {
    Ractive.events[eventName] = buildEventHandler(eventName, recognizerName, config);
  }

  /**
   * buildEventHandler() : buildEventHandler(event, recognizerName, config)
   * (private) Creates the event handler for a given `eventName` that will be
   * registered to `Ractive.events`.
   */

  function buildEventHandler(eventName, recognizerName, config) {
    return function (node, fire) {
      var hammerManager = getHammerManager(node);

      var recognizerExists = (hammerManager.get(recognizerName) !== null);

      if (!recognizerExists) {
        // init with default options
        var recognizer = new config.recognizerClass(config.options);

        // Hammer.Recognizer.set merges it on top of the defaults supplied above
        var options = parseOptions(node, recognizerName);
        if (options)
          recognizer.set(options);

        hammerManager.add(recognizer);
        
        updateRecognizeWith(hammerManager);
      }

      // register the handler
      hammerManager.on(eventName, function (e) {
        fire({
          node: node,
          original: e
        });
      });

      // handle exits
      function teardown() {
        getHammerManager(node).destroy();
        delete node._hammer;
      }

      return { teardown: teardown };
    };
  }

  /**
   * updateRecognizeWith : updateRecognizeWith(hammerManager)
   * (private) Sets recognizeWith if defaults have it
   *
   * Since we add recognizers dynamically and without any strict order,
   *  we need to guard against trying to set a requireWith for a recognizer
   *  that haven't been created yet.
   * 
   */
  function updateRecognizeWith(hammerManager) {
    for (var i = 0; i < hammerManager.recognizers.length; i++) {
      var recognizer = hammerManager.recognizers[i];
      var recognizerName = recognizer.options.event;

      if (!defaults[recognizerName].hasOwnProperty('recognizeWith')) continue;
      
      var recognizeWiths = defaults[recognizerName].recognizeWith;
      for (var k = 0; k < recognizeWiths.length; k++) {
        // Verify that the recgonizer we're trying to depend on is really there
        if (!hammerManager.get(recognizeWiths[k])) continue;

        // It's safe to recognizeWith multiple times for the same recognizer
        recognizer.recognizeWith(recognizeWiths[k]);
      }
    }
  }

  /**
   * parseOptions : parseOptions(node, key)
   * (private) Returns options for a given DOM node.
   *
   *     node = <div data-swipe-direction='left' data-swipe-threshold='2'>
   *
   *     parseOptions(node, 'swipe')
   *     => { direction: 'left', threshold: 2 }
   */

  function parseOptions(node, key) {
    var attrs = node.attributes,
        output,
        re = new RegExp("^(?:data-)?"+key+"-(.*)$");

    for (var i = attrs.length-1; i >= 0; i--) {
      var attr = attrs[i],
          m = attr.name.match(re);

      if (!m) continue;
      if (!output) output = {};
      output[m[1]] = parseHammerValue(attr.value, m[1]);
    }

    return output;
  }

  /**
   * parseHammerValue : parseHammerValue(str, key)
   * (private) Value-izes a given string `str`, converting it to a number as
   * needed. If `key` is given, it can also resolve aliases for that given
   * key.
   *
   * Used by `getData()`. 
   *
   *     parseHammerValue("100")   => 100
   *     parseHammerValue("right") => "right"
   *     parseHammerValue("right", "direction") => Hammer.DIRECTION_RIGHT
   */

  function parseHammerValue(str, key) {
    if (str.match && str.match(/^-?\d+(?:\.\d+)?$/)) return +str;
    return (aliases[key] && aliases[key][str]) ||
      aliases.all[str] || str;
  }

  /*
   * Aliases for `val()`.
   */

  aliases = {
    all: {
      'true': true,
      'false': false,
      'undefined': undefined,
      'null': null
    },
    direction: {
      'none': Hammer.DIRECTION_NONE,
      'all': Hammer.DIRECTION_ALL,
      'up': Hammer.DIRECTION_UP,
      'down': Hammer.DIRECTION_DOWN,
      'left': Hammer.DIRECTION_LEFT,
      'right': Hammer.DIRECTION_RIGHT,
      'horizontal': Hammer.DIRECTION_HORIZONTAL,
      'vertical': Hammer.DIRECTION_VERTICAL
    }
  };

  /**
   * getHammerManager : getHammerManager(node)
   * (private) Returns the `HammerManager` instance for the given node.
   */

  function getHammerManager(node) {
    if (node._hammer) return node._hammer;

    node._hammer = new Hammer.Manager(node, {recognizers: []});
    return node._hammer;
  }


  return {defaults: defaults};

}));

},{"./../hammerjs/hammer.js":"/Users/luke/dev/040715/vendor/hammerjs/hammer.js","./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-transitions-fade/ractive-transitions-fade.js":[function(require,module,exports){
/*

	ractive-transitions-fade
	========================

	Version 0.1.2.

	This plugin does exactly what it says on the tin - it fades elements
	in and out, using CSS transitions. You can control the following
	properties: `duration`, `delay` and `easing` (which must be a valid
	CSS transition timing function, and defaults to `linear`).

	The `duration` property is in milliseconds, and defaults to 300 (you
	can also use `fast` or `slow` instead of a millisecond value, which
	equate to 200 and 600 respectively). As a shorthand, you can use
	`intro='fade:500'` instead of `intro='fade:{"duration":500}'` - this
	applies to many other transition plugins as well.

	If an element has an opacity other than 1 (whether directly, because
	of an inline style, or indirectly because of a CSS rule), it will be
	respected. You can override the target opacity of an intro fade by
	specifying a `to` property between 0 and 1.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'Ractive' )` or `define([ 'Ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-fade.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-fade' );

	Add a fade transition like so:

	    <div intro='fade'>this will fade in</div>

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fade plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var fade, defaults;

	defaults = {
		delay: 0,
		duration: 300,
		easing: 'linear'
	};

	fade = function ( t, params ) {
		var targetOpacity;

		params = t.processParams( params, defaults );

		if ( t.isIntro ) {
			targetOpacity = t.getStyle( 'opacity' );
			t.setStyle( 'opacity', 0 );
		} else {
			targetOpacity = 0;
		}

		t.animateStyle( 'opacity', targetOpacity, params ).then( t.complete );
	};

	Ractive.transitions.fade = fade;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-transitions-fly/ractive-transitions-fly.js":[function(require,module,exports){
/*

	ractive-transitions-fly
	=======================

	Version 0.1.3.

	This transition uses CSS transforms to 'fly' elements to their
	natural location on the page, fading in from transparent as they go.
	By default, they will fly in from left.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-fly.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-fly' );

	You can adjust the following parameters: `x`, `y`, `duration`,
	`delay` and `easing`.

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fly plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var fly, addPx, defaults;

	defaults = {
		duration: 800,
		easing: 'cubic-bezier(0.770, 0.000, 0.175, 1.000)',
		x: -500,
		y: 0
	};

	addPx = function ( num ) {
		if ( num === 0 || typeof num === 'string' ) {
			return num;
		}

		return num + 'px';
	};

	fly = function ( t, params ) {
		var x, y, offscreen, target;

		params = t.processParams( params, defaults );

		x = addPx( params.x );
		y = addPx( params.y );

		offscreen = {
			transform: 'translate(' + x + ',' + y + ')'
		};

		if ( t.isIntro ) {
			// animate to the current style
			target = t.getStyle([ 'transform' ]);

			// set offscreen style
			t.setStyle( offscreen );
		} else {
			target = offscreen;
		}

		t.animateStyle( target, params ).then( t.complete );
	};

	Ractive.transitions.fly = fly;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-transitions-slide/ractive-transitions-slide.js":[function(require,module,exports){
/*

	ractive-transitions-slide
	=========================

	Version 0.1.2.

	This transition slides an element in and out of view,
	using CSS transitions where possible.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-slide.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-slide' );

	You can specify the `delay`, `duration` and `easing` properties
	using the conventional syntax:

	    <div intro='slide:{"delay":500,"easing":"ease-out"}'>content</div>

	Both `delay` and `duration` are in milliseconds. The `easing` value
	must be a valid CSS easing function (see http://cubic-bezier.com/).

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-slide plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var slide, props, collapsed, defaults;

	defaults = {
		duration: 300,
		easing: 'easeInOut'
	};

	props = [
		'height',
		'borderTopWidth',
		'borderBottomWidth',
		'paddingTop',
		'paddingBottom',
		'marginTop',
		'marginBottom'
	];

	collapsed = {
		height: 0,
		borderTopWidth: 0,
		borderBottomWidth: 0,
		paddingTop: 0,
		paddingBottom: 0,
		marginTop: 0,
		marginBottom: 0
	};

	slide = function ( t, params ) {
		var targetStyle;

		params = t.processParams( params, defaults );

		if ( t.isIntro ) {
			targetStyle = t.getStyle( props );
			t.setStyle( collapsed );
		} else {
			// make style explicit, so we're not transitioning to 'auto'
			t.setStyle( t.getStyle( props ) );
			targetStyle = collapsed;
		}

		t.setStyle( 'overflowY', 'hidden' );

		t.animateStyle( targetStyle, params ).then( t.complete );
	};

	Ractive.transitions.slide = slide;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive/ractive.js":[function(require,module,exports){
/*
	ractive.js v0.6.1
	2014-10-25 - commit 3a576eb3 

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

( function( global ) {

	'use strict';

	var noConflict = global.Ractive;

	/* config/defaults/options.js */
	var options = function() {

		var defaultOptions = {
			// render placement:
			el: void 0,
			append: false,
			// template:
			template: {
				v: 1,
				t: []
			},
			yield: null,
			// parse:
			preserveWhitespace: false,
			sanitize: false,
			stripComments: true,
			// data & binding:
			data: {},
			computed: {},
			magic: false,
			modifyArrays: true,
			adapt: [],
			isolated: false,
			twoway: true,
			lazy: false,
			// transitions:
			noIntro: false,
			transitionsEnabled: true,
			complete: void 0,
			// css:
			noCssTransform: false,
			// debug:
			debug: false
		};
		return defaultOptions;
	}();

	/* config/defaults/easing.js */
	var easing = {
		linear: function( pos ) {
			return pos;
		},
		easeIn: function( pos ) {
			return Math.pow( pos, 3 );
		},
		easeOut: function( pos ) {
			return Math.pow( pos - 1, 3 ) + 1;
		},
		easeInOut: function( pos ) {
			if ( ( pos /= 0.5 ) < 1 ) {
				return 0.5 * Math.pow( pos, 3 );
			}
			return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
		}
	};

	/* circular.js */
	var circular = [];

	/* utils/hasOwnProperty.js */
	var hasOwn = Object.prototype.hasOwnProperty;

	/* utils/isArray.js */
	var isArray = function() {

		var toString = Object.prototype.toString;
		// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		return function( thing ) {
			return toString.call( thing ) === '[object Array]';
		};
	}();

	/* utils/isObject.js */
	var isObject = function() {

		var toString = Object.prototype.toString;
		return function( thing ) {
			return thing && toString.call( thing ) === '[object Object]';
		};
	}();

	/* utils/isNumeric.js */
	var isNumeric = function( thing ) {
		return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	};

	/* config/defaults/interpolators.js */
	var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

		var interpolators, interpolate, cssLengthPattern;
		circular.push( function() {
			interpolate = circular.interpolate;
		} );
		cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
		interpolators = {
			number: function( from, to ) {
				var delta;
				if ( !isNumeric( from ) || !isNumeric( to ) ) {
					return null;
				}
				from = +from;
				to = +to;
				delta = to - from;
				if ( !delta ) {
					return function() {
						return from;
					};
				}
				return function( t ) {
					return from + t * delta;
				};
			},
			array: function( from, to ) {
				var intermediate, interpolators, len, i;
				if ( !isArray( from ) || !isArray( to ) ) {
					return null;
				}
				intermediate = [];
				interpolators = [];
				i = len = Math.min( from.length, to.length );
				while ( i-- ) {
					interpolators[ i ] = interpolate( from[ i ], to[ i ] );
				}
				// surplus values - don't interpolate, but don't exclude them either
				for ( i = len; i < from.length; i += 1 ) {
					intermediate[ i ] = from[ i ];
				}
				for ( i = len; i < to.length; i += 1 ) {
					intermediate[ i ] = to[ i ];
				}
				return function( t ) {
					var i = len;
					while ( i-- ) {
						intermediate[ i ] = interpolators[ i ]( t );
					}
					return intermediate;
				};
			},
			object: function( from, to ) {
				var properties, len, interpolators, intermediate, prop;
				if ( !isObject( from ) || !isObject( to ) ) {
					return null;
				}
				properties = [];
				intermediate = {};
				interpolators = {};
				for ( prop in from ) {
					if ( hasOwnProperty.call( from, prop ) ) {
						if ( hasOwnProperty.call( to, prop ) ) {
							properties.push( prop );
							interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
						} else {
							intermediate[ prop ] = from[ prop ];
						}
					}
				}
				for ( prop in to ) {
					if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
						intermediate[ prop ] = to[ prop ];
					}
				}
				len = properties.length;
				return function( t ) {
					var i = len,
						prop;
					while ( i-- ) {
						prop = properties[ i ];
						intermediate[ prop ] = interpolators[ prop ]( t );
					}
					return intermediate;
				};
			}
		};
		return interpolators;
	}( circular, hasOwn, isArray, isObject, isNumeric );

	/* config/svg.js */
	var svg = function() {

		var svg;
		if ( typeof document === 'undefined' ) {
			svg = false;
		} else {
			svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
		}
		return svg;
	}();

	/* utils/warn.js */
	var warn = function() {

		/* global console */
		var warn, warned = {};
		if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
			warn = function( message, allowDuplicates ) {
				if ( !allowDuplicates ) {
					if ( warned[ message ] ) {
						return;
					}
					warned[ message ] = true;
				}
				console.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );
			};
		} else {
			warn = function() {};
		}
		return warn;
	}();

	/* config/errors.js */
	var errors = {
		missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
		mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
		noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
		noTemplateForPartial: 'Could not find template for partial "{name}"',
		noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
		evaluationError: 'Error evaluating "{uniqueString}": {err}',
		badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
		failedComputation: 'Failed to compute "{key}": {err}',
		missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
		badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
		noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned',
		defaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',
		noElementProxyEventWildcards: 'Only component proxy-events may contain "*" wildcards, <{element} on-{event}/> is not valid.',
		methodDeprecated: 'The method "{deprecated}" has been deprecated in favor of "{replacement}" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'
	};

	/* utils/log.js */
	var log = function( consolewarn, errors ) {

		var log = {
			warn: function( options, passthru ) {
				if ( !options.debug && !passthru ) {
					return;
				}
				this.warnAlways( options );
			},
			warnAlways: function( options ) {
				this.logger( getMessage( options ), options.allowDuplicates );
			},
			error: function( options ) {
				this.errorOnly( options );
				if ( !options.debug ) {
					this.warn( options, true );
				}
			},
			errorOnly: function( options ) {
				if ( options.debug ) {
					this.critical( options );
				}
			},
			critical: function( options ) {
				var err = options.err || new Error( getMessage( options ) );
				this.thrower( err );
			},
			logger: consolewarn,
			thrower: function( err ) {
				throw err;
			}
		};

		function getMessage( options ) {
			var message = errors[ options.message ] || options.message || '';
			return interpolate( message, options.args );
		}
		// simple interpolation. probably quicker (and better) out there,
		// but log is not in golden path of execution, only exceptions
		function interpolate( message, args ) {
			return message.replace( /{([^{}]*)}/g, function( a, b ) {
				return args[ b ];
			} );
		}
		return log;
	}( warn, errors );

	/* Ractive/prototype/shared/hooks/Hook.js */
	var Ractive$shared_hooks_Hook = function( log ) {

		var deprecations = {
			construct: {
				deprecated: 'beforeInit',
				replacement: 'onconstruct'
			},
			render: {
				deprecated: 'init',
				message: 'The "init" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the "oninit" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use "onrender" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'
			},
			complete: {
				deprecated: 'complete',
				replacement: 'oncomplete'
			}
		};

		function Hook( event ) {
			this.event = event;
			this.method = 'on' + event;
			this.deprecate = deprecations[ event ];
		}
		Hook.prototype.fire = function( ractive, arg ) {
			function call( method ) {
				if ( ractive[ method ] ) {
					arg ? ractive[ method ]( arg ) : ractive[ method ]();
					return true;
				}
			}
			call( this.method );
			if ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {
				log.warnAlways( {
					debug: ractive.debug,
					message: this.deprecate.message || 'methodDeprecated',
					args: this.deprecate
				} );
			}
			arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
		};
		return Hook;
	}( log );

	/* utils/removeFromArray.js */
	var removeFromArray = function( array, member ) {
		var index = array.indexOf( member );
		if ( index !== -1 ) {
			array.splice( index, 1 );
		}
	};

	/* utils/Promise.js */
	var Promise = function() {

		var __export;
		var _Promise, PENDING = {},
			FULFILLED = {},
			REJECTED = {};
		if ( typeof Promise === 'function' ) {
			// use native Promise
			_Promise = Promise;
		} else {
			_Promise = function( callback ) {
				var fulfilledHandlers = [],
					rejectedHandlers = [],
					state = PENDING,
					result, dispatchHandlers, makeResolver, fulfil, reject, promise;
				makeResolver = function( newState ) {
					return function( value ) {
						if ( state !== PENDING ) {
							return;
						}
						result = value;
						state = newState;
						dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
						// dispatch onFulfilled and onRejected handlers asynchronously
						wait( dispatchHandlers );
					};
				};
				fulfil = makeResolver( FULFILLED );
				reject = makeResolver( REJECTED );
				try {
					callback( fulfil, reject );
				} catch ( err ) {
					reject( err );
				}
				promise = {
					// `then()` returns a Promise - 2.2.7
					then: function( onFulfilled, onRejected ) {
						var promise2 = new _Promise( function( fulfil, reject ) {
							var processResolutionHandler = function( handler, handlers, forward ) {
								// 2.2.1.1
								if ( typeof handler === 'function' ) {
									handlers.push( function( p1result ) {
										var x;
										try {
											x = handler( p1result );
											resolve( promise2, x, fulfil, reject );
										} catch ( err ) {
											reject( err );
										}
									} );
								} else {
									// Forward the result of promise1 to promise2, if resolution handlers
									// are not given
									handlers.push( forward );
								}
							};
							// 2.2
							processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
							processResolutionHandler( onRejected, rejectedHandlers, reject );
							if ( state !== PENDING ) {
								// If the promise has resolved already, dispatch the appropriate handlers asynchronously
								wait( dispatchHandlers );
							}
						} );
						return promise2;
					}
				};
				promise[ 'catch' ] = function( onRejected ) {
					return this.then( null, onRejected );
				};
				return promise;
			};
			_Promise.all = function( promises ) {
				return new _Promise( function( fulfil, reject ) {
					var result = [],
						pending, i, processPromise;
					if ( !promises.length ) {
						fulfil( result );
						return;
					}
					processPromise = function( i ) {
						promises[ i ].then( function( value ) {
							result[ i ] = value;
							if ( !--pending ) {
								fulfil( result );
							}
						}, reject );
					};
					pending = i = promises.length;
					while ( i-- ) {
						processPromise( i );
					}
				} );
			};
			_Promise.resolve = function( value ) {
				return new _Promise( function( fulfil ) {
					fulfil( value );
				} );
			};
			_Promise.reject = function( reason ) {
				return new _Promise( function( fulfil, reject ) {
					reject( reason );
				} );
			};
		}
		__export = _Promise;
		// TODO use MutationObservers or something to simulate setImmediate
		function wait( callback ) {
			setTimeout( callback, 0 );
		}

		function makeDispatcher( handlers, result ) {
			return function() {
				var handler;
				while ( handler = handlers.shift() ) {
					handler( result );
				}
			};
		}

		function resolve( promise, x, fulfil, reject ) {
			// Promise Resolution Procedure
			var then;
			// 2.3.1
			if ( x === promise ) {
				throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
			}
			// 2.3.2
			if ( x instanceof _Promise ) {
				x.then( fulfil, reject );
			} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
				try {
					then = x.then;
				} catch ( e ) {
					reject( e );
					// 2.3.3.2
					return;
				}
				// 2.3.3.3
				if ( typeof then === 'function' ) {
					var called, resolvePromise, rejectPromise;
					resolvePromise = function( y ) {
						if ( called ) {
							return;
						}
						called = true;
						resolve( promise, y, fulfil, reject );
					};
					rejectPromise = function( r ) {
						if ( called ) {
							return;
						}
						called = true;
						reject( r );
					};
					try {
						then.call( x, resolvePromise, rejectPromise );
					} catch ( e ) {
						if ( !called ) {
							// 2.3.3.3.4.1
							reject( e );
							// 2.3.3.3.4.2
							called = true;
							return;
						}
					}
				} else {
					fulfil( x );
				}
			} else {
				fulfil( x );
			}
		}
		return __export;
	}();

	/* utils/normaliseRef.js */
	var normaliseRef = function() {

		var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
		return function normaliseRef( ref ) {
			return ( ref || '' ).replace( regex, '.$1' );
		};
	}();

	/* shared/getInnerContext.js */
	var getInnerContext = function( fragment ) {
		do {
			if ( fragment.context !== undefined ) {
				return fragment.context;
			}
		} while ( fragment = fragment.parent );
		return '';
	};

	/* utils/isEqual.js */
	var isEqual = function( a, b ) {
		if ( a === null && b === null ) {
			return true;
		}
		if ( typeof a === 'object' || typeof b === 'object' ) {
			return false;
		}
		return a === b;
	};

	/* shared/createComponentBinding.js */
	var createComponentBinding = function( circular, isEqual ) {

		var runloop;
		circular.push( function() {
			return runloop = circular.runloop;
		} );
		var Binding = function( ractive, keypath, otherInstance, otherKeypath ) {
			var this$0 = this;
			this.root = ractive;
			this.keypath = keypath;
			this.otherInstance = otherInstance;
			this.otherKeypath = otherKeypath;
			this.lock = function() {
				return this$0.updating = true;
			};
			this.unlock = function() {
				return this$0.updating = false;
			};
			this.bind();
			this.value = this.root.viewmodel.get( this.keypath );
		};
		Binding.prototype = {
			isLocked: function() {
				return this.updating || this.counterpart && this.counterpart.updating;
			},
			shuffle: function( newIndices, value ) {
				this.propagateChange( value, newIndices );
			},
			setValue: function( value ) {
				this.propagateChange( value );
			},
			propagateChange: function( value, newIndices ) {
				var other;
				// Only *you* can prevent infinite loops
				if ( this.isLocked() ) {
					this.value = value;
					return;
				}
				if ( !isEqual( value, this.value ) ) {
					this.lock();
					// TODO maybe the case that `value === this.value` - should that result
					// in an update rather than a set?
					// if the other viewmodel is already locked up, need to do a deferred update
					if ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {
						runloop.scheduleTask( function() {
							return runloop.addViewmodel( other );
						} );
					}
					if ( newIndices ) {
						other.smartUpdate( this.otherKeypath, value, newIndices );
					} else {
						if ( isSettable( other, this.otherKeypath ) ) {
							other.set( this.otherKeypath, value );
						}
					}
					this.value = value;
					// TODO will the counterpart update after this line, during
					// the runloop end cycle? may be a problem...
					runloop.scheduleTask( this.unlock );
				}
			},
			refineValue: function( keypaths ) {
				var this$0 = this;
				var other;
				if ( this.isLocked() ) {
					return;
				}
				this.lock();
				runloop.addViewmodel( other = this.otherInstance.viewmodel );
				keypaths.map( function( keypath ) {
					return this$0.otherKeypath + keypath.substr( this$0.keypath.length );
				} ).forEach( function( keypath ) {
					return other.mark( keypath );
				} );
				runloop.scheduleTask( this.unlock );
			},
			bind: function() {
				this.root.viewmodel.register( this.keypath, this );
			},
			rebind: function( newKeypath ) {
				this.unbind();
				this.keypath = newKeypath;
				this.counterpart.otherKeypath = newKeypath;
				this.bind();
			},
			unbind: function() {
				this.root.viewmodel.unregister( this.keypath, this );
			}
		};

		function isSettable( viewmodel, keypath ) {
			var computed = viewmodel.computations[ keypath ];
			return !computed || computed.setter;
		}
		return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
			var hash, childInstance, bindings, parentToChildBinding, childToParentBinding;
			hash = parentKeypath + '=' + childKeypath;
			bindings = component.bindings;
			if ( bindings[ hash ] ) {
				// TODO does this ever happen?
				return;
			}
			childInstance = component.instance;
			parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );
			bindings.push( parentToChildBinding );
			if ( childInstance.twoway ) {
				childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );
				bindings.push( childToParentBinding );
				parentToChildBinding.counterpart = childToParentBinding;
				childToParentBinding.counterpart = parentToChildBinding;
			}
			bindings[ hash ] = parentToChildBinding;
		};
	}( circular, isEqual );

	/* shared/resolveRef.js */
	var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

		var __export;
		var ancestorErrorMessage, getOptions;
		ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
		getOptions = {
			evaluateWrapped: true
		};
		__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {
			var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
			ref = normaliseRef( ref );
			// If a reference begins '~/', it's a top-level reference
			if ( ref.substr( 0, 2 ) === '~/' ) {
				return ref.substring( 2 );
			}
			// If a reference begins with '.', it's either a restricted reference or
			// an ancestor reference...
			if ( ref.charAt( 0 ) === '.' ) {
				return resolveAncestorReference( getInnerContext( fragment ), ref );
			}
			// ...otherwise we need to find the keypath
			key = ref.split( '.' )[ 0 ];
			// get() in viewmodel creation means no fragment (yet)
			fragment = fragment || {};
			do {
				context = fragment.context;
				if ( !context ) {
					continue;
				}
				hasContextChain = true;
				parentValue = ractive.viewmodel.get( context, getOptions );
				if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
					return context + '.' + ref;
				}
			} while ( fragment = fragment.parent );
			// Root/computed property?
			if ( key in ractive.data || key in ractive.viewmodel.computations ) {
				return ref;
			}
			// If this is an inline component, and it's not isolated, we
			// can try going up the scope chain
			if ( ractive._parent && !ractive.isolated ) {
				hasContextChain = true;
				fragment = ractive.component.parentFragment;
				// Special case - index refs
				if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
					// Create an index ref binding, so that it can be rebound letter if necessary.
					// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
					ractive.component.indexRefBindings[ ref ] = ref;
					ractive.viewmodel.set( ref, index, true );
					return;
				}
				keypath = resolveRef( ractive._parent, ref, fragment, true );
				if ( keypath ) {
					// We need to create an inter-component binding
					// If parent keypath is 'one.foo' and child is 'two.foo', we bind
					// 'one' to 'two' as it's more efficient and avoids edge cases
					parentKeys = keypath.split( '.' );
					childKeys = ref.split( '.' );
					while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
						parentKeys.pop();
						childKeys.pop();
					}
					parentKeypath = parentKeys.join( '.' );
					childKeypath = childKeys.join( '.' );
					ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
					createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
					return ref;
				}
			}
			// If there's no context chain, and the instance is either a) isolated or
			// b) an orphan, then we know that the keypath is identical to the reference
			if ( !isParentLookup && !hasContextChain ) {
				// the data object needs to have a property by this name,
				// to prevent future failed lookups
				ractive.viewmodel.set( ref, undefined );
				return ref;
			}
			if ( ractive.viewmodel.get( ref ) !== undefined ) {
				return ref;
			}
		};

		function resolveAncestorReference( baseContext, ref ) {
			var contextKeys;
			// {{.}} means 'current context'
			if ( ref === '.' )
				return baseContext;
			contextKeys = baseContext ? baseContext.split( '.' ) : [];
			// ancestor references (starting "../") go up the tree
			if ( ref.substr( 0, 3 ) === '../' ) {
				while ( ref.substr( 0, 3 ) === '../' ) {
					if ( !contextKeys.length ) {
						throw new Error( ancestorErrorMessage );
					}
					contextKeys.pop();
					ref = ref.substring( 3 );
				}
				contextKeys.push( ref );
				return contextKeys.join( '.' );
			}
			// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
			if ( !baseContext ) {
				return ref.replace( /^\.\/?/, '' );
			}
			return baseContext + ref.replace( /^\.\//, '.' );
		}
		return __export;
	}( normaliseRef, getInnerContext, createComponentBinding );

	/* global/TransitionManager.js */
	var TransitionManager = function( removeFromArray ) {

		var TransitionManager = function( callback, parent ) {
			this.callback = callback;
			this.parent = parent;
			this.intros = [];
			this.outros = [];
			this.children = [];
			this.totalChildren = this.outroChildren = 0;
			this.detachQueue = [];
			this.outrosComplete = false;
			if ( parent ) {
				parent.addChild( this );
			}
		};
		TransitionManager.prototype = {
			addChild: function( child ) {
				this.children.push( child );
				this.totalChildren += 1;
				this.outroChildren += 1;
			},
			decrementOutros: function() {
				this.outroChildren -= 1;
				check( this );
			},
			decrementTotal: function() {
				this.totalChildren -= 1;
				check( this );
			},
			add: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				list.push( transition );
			},
			remove: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				removeFromArray( list, transition );
				check( this );
			},
			init: function() {
				this.ready = true;
				check( this );
			},
			detachNodes: function() {
				this.detachQueue.forEach( detach );
				this.children.forEach( detachNodes );
			}
		};

		function detach( element ) {
			element.detach();
		}

		function detachNodes( tm ) {
			tm.detachNodes();
		}

		function check( tm ) {
			if ( !tm.ready || tm.outros.length || tm.outroChildren )
				return;
			// If all outros are complete, and we haven't already done this,
			// we notify the parent if there is one, otherwise
			// start detaching nodes
			if ( !tm.outrosComplete ) {
				if ( tm.parent ) {
					tm.parent.decrementOutros( tm );
				} else {
					tm.detachNodes();
				}
				tm.outrosComplete = true;
			}
			// Once everything is done, we can notify parent transition
			// manager and call the callback
			if ( !tm.intros.length && !tm.totalChildren ) {
				if ( typeof tm.callback === 'function' ) {
					tm.callback();
				}
				if ( tm.parent ) {
					tm.parent.decrementTotal();
				}
			}
		}
		return TransitionManager;
	}( removeFromArray );

	/* global/runloop.js */
	var runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {

		var __export;
		var batch, runloop, unresolved = [],
			changeHook = new Hook( 'change' );
		runloop = {
			start: function( instance, returnPromise ) {
				var promise, fulfilPromise;
				if ( returnPromise ) {
					promise = new Promise( function( f ) {
						return fulfilPromise = f;
					} );
				}
				batch = {
					previousBatch: batch,
					transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
					views: [],
					tasks: [],
					viewmodels: [],
					instance: instance
				};
				if ( instance ) {
					batch.viewmodels.push( instance.viewmodel );
				}
				return promise;
			},
			end: function() {
				flushChanges();
				batch.transitionManager.init();
				if ( !batch.previousBatch && !!batch.instance )
					batch.instance.viewmodel.changes = [];
				batch = batch.previousBatch;
			},
			addViewmodel: function( viewmodel ) {
				if ( batch ) {
					if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
						batch.viewmodels.push( viewmodel );
						return true;
					} else {
						return false;
					}
				} else {
					viewmodel.applyChanges();
					return false;
				}
			},
			registerTransition: function( transition ) {
				transition._manager = batch.transitionManager;
				batch.transitionManager.add( transition );
			},
			addView: function( view ) {
				batch.views.push( view );
			},
			addUnresolved: function( thing ) {
				unresolved.push( thing );
			},
			removeUnresolved: function( thing ) {
				removeFromArray( unresolved, thing );
			},
			// synchronise node detachments with transition ends
			detachWhenReady: function( thing ) {
				batch.transitionManager.detachQueue.push( thing );
			},
			scheduleTask: function( task, postRender ) {
				var _batch;
				if ( !batch ) {
					task();
				} else {
					_batch = batch;
					while ( postRender && _batch.previousBatch ) {
						// this can't happen until the DOM has been fully updated
						// otherwise in some situations (with components inside elements)
						// transitions and decorators will initialise prematurely
						_batch = _batch.previousBatch;
					}
					_batch.tasks.push( task );
				}
			}
		};
		circular.runloop = runloop;
		__export = runloop;

		function flushChanges() {
			var i, thing, changeHash;
			for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
				thing = batch.viewmodels[ i ];
				changeHash = thing.applyChanges();
				if ( changeHash ) {
					changeHook.fire( thing.ractive, changeHash );
				}
			}
			batch.viewmodels.length = 0;
			attemptKeypathResolution();
			// Now that changes have been fully propagated, we can update the DOM
			// and complete other tasks
			for ( i = 0; i < batch.views.length; i += 1 ) {
				batch.views[ i ].update();
			}
			batch.views.length = 0;
			for ( i = 0; i < batch.tasks.length; i += 1 ) {
				batch.tasks[ i ]();
			}
			batch.tasks.length = 0;
			// If updating the view caused some model blowback - e.g. a triple
			// containing <option> elements caused the binding on the <select>
			// to update - then we start over
			if ( batch.viewmodels.length )
				return flushChanges();
		}

		function attemptKeypathResolution() {
			var i, item, keypath, resolved;
			i = unresolved.length;
			// see if we can resolve any unresolved references
			while ( i-- ) {
				item = unresolved[ i ];
				if ( item.keypath ) {
					// it resolved some other way. TODO how? two-way binding? Seems
					// weird that we'd still end up here
					unresolved.splice( i, 1 );
				}
				if ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {
					( resolved || ( resolved = [] ) ).push( {
						item: item,
						keypath: keypath
					} );
					unresolved.splice( i, 1 );
				}
			}
			if ( resolved ) {
				resolved.forEach( resolve );
			}
		}

		function resolve( resolved ) {
			resolved.item.resolve( resolved.keypath );
		}
		return __export;
	}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );

	/* utils/createBranch.js */
	var createBranch = function() {

		var numeric = /^\s*[0-9]+\s*$/;
		return function( key ) {
			return numeric.test( key ) ? [] : {};
		};
	}();

	/* viewmodel/prototype/get/magicAdaptor.js */
	var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

		var __export;
		var magicAdaptor, MagicWrapper;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			magicAdaptor = {
				filter: function( object, keypath, ractive ) {
					var keys, key, parentKeypath, parentWrapper, parentValue;
					if ( !keypath ) {
						return false;
					}
					keys = keypath.split( '.' );
					key = keys.pop();
					parentKeypath = keys.join( '.' );
					// If the parent value is a wrapper, other than a magic wrapper,
					// we shouldn't wrap this property
					if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
						return false;
					}
					parentValue = ractive.get( parentKeypath );
					// if parentValue is an array that doesn't include this member,
					// we should return false otherwise lengths will get messed up
					if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
						return false;
					}
					return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
				},
				wrap: function( ractive, property, keypath ) {
					return new MagicWrapper( ractive, property, keypath );
				}
			};
			MagicWrapper = function( ractive, value, keypath ) {
				var keys, objKeypath, template, siblings;
				this.magic = true;
				this.ractive = ractive;
				this.keypath = keypath;
				this.value = value;
				keys = keypath.split( '.' );
				this.prop = keys.pop();
				objKeypath = keys.join( '.' );
				this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
				template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
				// Has this property already been wrapped?
				if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
					// Yes. Register this wrapper to this property, if it hasn't been already
					if ( siblings.indexOf( this ) === -1 ) {
						siblings.push( this );
					}
					return;
				}
				// No, it hasn't been wrapped
				createAccessors( this, value, template );
			};
			MagicWrapper.prototype = {
				get: function() {
					return this.value;
				},
				reset: function( value ) {
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.obj[ this.prop ] = value;
					// trigger set() accessor
					runloop.addViewmodel( this.ractive.viewmodel );
					this.ractive.viewmodel.mark( this.keypath );
					this.updating = false;
				},
				set: function( key, value ) {
					if ( this.updating ) {
						return;
					}
					if ( !this.obj[ this.prop ] ) {
						this.updating = true;
						this.obj[ this.prop ] = createBranch( key );
						this.updating = false;
					}
					this.obj[ this.prop ][ key ] = value;
				},
				teardown: function() {
					var template, set, value, wrappers, index;
					// If this method was called because the cache was being cleared as a
					// result of a set()/update() call made by this wrapper, we return false
					// so that it doesn't get torn down
					if ( this.updating ) {
						return false;
					}
					template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					set = template && template.set;
					if ( !set ) {
						// most likely, this was an array member that was spliced out
						return;
					}
					wrappers = set._ractiveWrappers;
					index = wrappers.indexOf( this );
					if ( index !== -1 ) {
						wrappers.splice( index, 1 );
					}
					// Last one out, turn off the lights
					if ( !wrappers.length ) {
						value = this.obj[ this.prop ];
						Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
							writable: true,
							enumerable: true,
							configurable: true
						} );
						this.obj[ this.prop ] = value;
					}
				}
			};
		} catch ( err ) {
			magicAdaptor = false;
		}
		__export = magicAdaptor;

		function createAccessors( originalWrapper, value, template ) {
			var object, property, oldGet, oldSet, get, set;
			object = originalWrapper.obj;
			property = originalWrapper.prop;
			// Is this template configurable?
			if ( template && !template.configurable ) {
				// Special case - array length
				if ( property === 'length' ) {
					return;
				}
				throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
			}
			// Time to wrap this property
			if ( template ) {
				oldGet = template.get;
				oldSet = template.set;
			}
			get = oldGet || function() {
				return value;
			};
			set = function( v ) {
				if ( oldSet ) {
					oldSet( v );
				}
				value = oldGet ? oldGet() : v;
				set._ractiveWrappers.forEach( updateWrapper );
			};

			function updateWrapper( wrapper ) {
				var keypath, ractive;
				wrapper.value = value;
				if ( wrapper.updating ) {
					return;
				}
				ractive = wrapper.ractive;
				keypath = wrapper.keypath;
				wrapper.updating = true;
				runloop.start( ractive );
				ractive.viewmodel.mark( keypath );
				runloop.end();
				wrapper.updating = false;
			}
			// Create an array of wrappers, in case other keypaths/ractives depend on this property.
			// Handily, we can store them as a property of the set function. Yay JavaScript.
			set._ractiveWrappers = [ originalWrapper ];
			Object.defineProperty( object, property, {
				get: get,
				set: set,
				enumerable: true,
				configurable: true
			} );
		}
		return __export;
	}( runloop, createBranch, isArray );

	/* config/magic.js */
	var magic = function( magicAdaptor ) {

		return !!magicAdaptor;
	}( viewmodel$get_magicAdaptor );

	/* config/namespaces.js */
	var namespaces = {
		html: 'http://www.w3.org/1999/xhtml',
		mathml: 'http://www.w3.org/1998/Math/MathML',
		svg: 'http://www.w3.org/2000/svg',
		xlink: 'http://www.w3.org/1999/xlink',
		xml: 'http://www.w3.org/XML/1998/namespace',
		xmlns: 'http://www.w3.org/2000/xmlns/'
	};

	/* utils/createElement.js */
	var createElement = function( svg, namespaces ) {

		var createElement;
		// Test for SVG support
		if ( !svg ) {
			createElement = function( type, ns ) {
				if ( ns && ns !== namespaces.html ) {
					throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
				}
				return document.createElement( type );
			};
		} else {
			createElement = function( type, ns ) {
				if ( !ns || ns === namespaces.html ) {
					return document.createElement( type );
				}
				return document.createElementNS( ns, type );
			};
		}
		return createElement;
	}( svg, namespaces );

	/* config/isClient.js */
	var isClient = function() {

		var isClient = typeof document === 'object';
		return isClient;
	}();

	/* utils/defineProperty.js */
	var defineProperty = function( isClient ) {

		var defineProperty;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			if ( isClient ) {
				Object.defineProperty( document.createElement( 'div' ), 'test', {
					value: 0
				} );
			}
			defineProperty = Object.defineProperty;
		} catch ( err ) {
			// Object.defineProperty doesn't exist, or we're in IE8 where you can
			// only use it with DOM objects (what the fuck were you smoking, MSFT?)
			defineProperty = function( obj, prop, desc ) {
				obj[ prop ] = desc.value;
			};
		}
		return defineProperty;
	}( isClient );

	/* utils/defineProperties.js */
	var defineProperties = function( createElement, defineProperty, isClient ) {

		var defineProperties;
		try {
			try {
				Object.defineProperties( {}, {
					test: {
						value: 0
					}
				} );
			} catch ( err ) {
				// TODO how do we account for this? noMagic = true;
				throw err;
			}
			if ( isClient ) {
				Object.defineProperties( createElement( 'div' ), {
					test: {
						value: 0
					}
				} );
			}
			defineProperties = Object.defineProperties;
		} catch ( err ) {
			defineProperties = function( obj, props ) {
				var prop;
				for ( prop in props ) {
					if ( props.hasOwnProperty( prop ) ) {
						defineProperty( obj, prop, props[ prop ] );
					}
				}
			};
		}
		return defineProperties;
	}( createElement, defineProperty, isClient );

	/* Ractive/prototype/shared/add.js */
	var Ractive$shared_add = function( isNumeric ) {

		return function add( root, keypath, d ) {
			var value;
			if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
				throw new Error( 'Bad arguments' );
			}
			value = +root.get( keypath ) || 0;
			if ( !isNumeric( value ) ) {
				throw new Error( 'Cannot add to a non-numeric value' );
			}
			return root.set( keypath, value + d );
		};
	}( isNumeric );

	/* Ractive/prototype/add.js */
	var Ractive$add = function( add ) {

		return function Ractive$add( keypath, d ) {
			return add( this, keypath, d === undefined ? 1 : +d );
		};
	}( Ractive$shared_add );

	/* utils/normaliseKeypath.js */
	var normaliseKeypath = function( normaliseRef ) {

		var leadingDot = /^\.+/;
		return function normaliseKeypath( keypath ) {
			return normaliseRef( keypath ).replace( leadingDot, '' );
		};
	}( normaliseRef );

	/* config/vendors.js */
	var vendors = [
		'o',
		'ms',
		'moz',
		'webkit'
	];

	/* utils/requestAnimationFrame.js */
	var requestAnimationFrame = function( vendors ) {

		var requestAnimationFrame;
		// If window doesn't exist, we don't need requestAnimationFrame
		if ( typeof window === 'undefined' ) {
			requestAnimationFrame = null;
		} else {
			// https://gist.github.com/paulirish/1579671
			( function( vendors, lastTime, window ) {
				var x, setTimeout;
				if ( window.requestAnimationFrame ) {
					return;
				}
				for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
					window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
				}
				if ( !window.requestAnimationFrame ) {
					setTimeout = window.setTimeout;
					window.requestAnimationFrame = function( callback ) {
						var currTime, timeToCall, id;
						currTime = Date.now();
						timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
						id = setTimeout( function() {
							callback( currTime + timeToCall );
						}, timeToCall );
						lastTime = currTime + timeToCall;
						return id;
					};
				}
			}( vendors, 0, window ) );
			requestAnimationFrame = window.requestAnimationFrame;
		}
		return requestAnimationFrame;
	}( vendors );

	/* utils/getTime.js */
	var getTime = function() {

		var getTime;
		if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
			getTime = function() {
				return window.performance.now();
			};
		} else {
			getTime = function() {
				return Date.now();
			};
		}
		return getTime;
	}();

	/* shared/animations.js */
	var animations = function( rAF, getTime, runloop ) {

		var queue = [];
		var animations = {
			tick: function() {
				var i, animation, now;
				now = getTime();
				runloop.start();
				for ( i = 0; i < queue.length; i += 1 ) {
					animation = queue[ i ];
					if ( !animation.tick( now ) ) {
						// animation is complete, remove it from the stack, and decrement i so we don't miss one
						queue.splice( i--, 1 );
					}
				}
				runloop.end();
				if ( queue.length ) {
					rAF( animations.tick );
				} else {
					animations.running = false;
				}
			},
			add: function( animation ) {
				queue.push( animation );
				if ( !animations.running ) {
					animations.running = true;
					rAF( animations.tick );
				}
			},
			// TODO optimise this
			abort: function( keypath, root ) {
				var i = queue.length,
					animation;
				while ( i-- ) {
					animation = queue[ i ];
					if ( animation.root === root && animation.keypath === keypath ) {
						animation.stop();
					}
				}
			}
		};
		return animations;
	}( requestAnimationFrame, getTime, runloop );

	/* config/options/css/transform.js */
	var transform = function() {

		var __export;
		var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
			commentsPattern = /\/\*.*?\*\//g,
			selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
			mediaQueryPattern = /^@media/,
			dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
		__export = function transformCss( css, guid ) {
			var transformed, addGuid;
			addGuid = function( selector ) {
				var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
				selectorUnits = [];
				while ( match = selectorUnitPattern.exec( selector ) ) {
					selectorUnits.push( {
						str: match[ 0 ],
						base: match[ 1 ],
						modifiers: match[ 2 ]
					} );
				}
				// For each simple selector within the selector, we need to create a version
				// that a) combines with the guid, and b) is inside the guid
				dataAttr = '[data-rvcguid="' + guid + '"]';
				base = selectorUnits.map( extractString );
				i = selectorUnits.length;
				while ( i-- ) {
					appended = base.slice();
					// Pseudo-selectors should go after the attribute selector
					unit = selectorUnits[ i ];
					appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
					prepended = base.slice();
					prepended[ i ] = dataAttr + ' ' + prepended[ i ];
					transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
				}
				return transformed.join( ', ' );
			};
			if ( dataRvcGuidPattern.test( css ) ) {
				transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
			} else {
				transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
					var selectors, transformed;
					// don't transform media queries!
					if ( mediaQueryPattern.test( $1 ) )
						return match;
					selectors = $1.split( ',' ).map( trim );
					transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
					return match.replace( $1, transformed );
				} );
			}
			return transformed;
		};

		function trim( str ) {
			if ( str.trim ) {
				return str.trim();
			}
			return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
		}

		function extractString( unit ) {
			return unit.str;
		}
		return __export;
	}();

	/* config/options/css/css.js */
	var css = function( transformCss ) {

		var cssConfig = {
			name: 'css',
			extend: extend,
			init: function() {}
		};

		function extend( Parent, proto, options ) {
			var guid = proto.constructor._guid,
				css;
			if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
				proto.constructor.css = css;
			}
		}

		function getCss( css, target, guid ) {
			if ( !css ) {
				return;
			}
			return target.noCssTransform ? css : transformCss( css, guid );
		}
		return cssConfig;
	}( transform );

	/* utils/wrapMethod.js */
	var wrapMethod = function() {

		var __export;
		__export = function( method, superMethod, force ) {
			if ( force || needsSuper( method, superMethod ) ) {
				return function() {
					var hasSuper = '_super' in this,
						_super = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = _super;
					}
					return result;
				};
			} else {
				return method;
			}
		};

		function needsSuper( method, superMethod ) {
			return typeof superMethod === 'function' && /_super/.test( method );
		}
		return __export;
	}();

	/* config/options/data.js */
	var data = function( wrap ) {

		var __export;
		var dataConfig = {
			name: 'data',
			extend: extend,
			init: init,
			reset: reset
		};
		__export = dataConfig;

		function combine( Parent, target, options ) {
			var value = options.data || {},
				parentValue = getAddedKeys( Parent.prototype.data );
			if ( typeof value !== 'object' && typeof value !== 'function' ) {
				throw new TypeError( 'data option must be an object or a function, "' + value + '" is not valid' );
			}
			return dispatch( parentValue, value );
		}

		function extend( Parent, proto, options ) {
			proto.data = combine( Parent, proto, options );
		}

		function init( Parent, ractive, options ) {
			var value = options.data,
				result = combine( Parent, ractive, options );
			if ( typeof result === 'function' ) {
				result = result.call( ractive, value ) || value;
			}
			return ractive.data = result || {};
		}

		function reset( ractive ) {
			var result = this.init( ractive.constructor, ractive, ractive );
			if ( result ) {
				ractive.data = result;
				return true;
			}
		}

		function getAddedKeys( parent ) {
			// only for functions that had keys added
			if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
				return parent;
			}
			// copy the added keys to temp 'object', otherwise
			// parent would be interpreted as 'function' by dispatch
			var temp = {};
			copy( parent, temp );
			// roll in added keys
			return dispatch( parent, temp );
		}

		function dispatch( parent, child ) {
			if ( typeof child === 'function' ) {
				return extendFn( child, parent );
			} else if ( typeof parent === 'function' ) {
				return fromFn( child, parent );
			} else {
				return fromProperties( child, parent );
			}
		}

		function copy( from, to, fillOnly ) {
			for ( var key in from ) {
				if ( fillOnly && key in to ) {
					continue;
				}
				to[ key ] = from[ key ];
			}
		}

		function fromProperties( child, parent ) {
			child = child || {};
			if ( !parent ) {
				return child;
			}
			copy( parent, child, true );
			return child;
		}

		function fromFn( child, parentFn ) {
			return function( data ) {
				var keys;
				if ( child ) {
					// Track the keys that our on the child,
					// but not on the data. We'll need to apply these
					// after the parent function returns.
					keys = [];
					for ( var key in child ) {
						if ( !data || !( key in data ) ) {
							keys.push( key );
						}
					}
				}
				// call the parent fn, use data if no return value
				data = parentFn.call( this, data ) || data;
				// Copy child keys back onto data. The child keys
				// should take precedence over whatever the
				// parent did with the data.
				if ( keys && keys.length ) {
					data = data || {};
					keys.forEach( function( key ) {
						data[ key ] = child[ key ];
					} );
				}
				return data;
			};
		}

		function extendFn( childFn, parent ) {
			var parentFn;
			if ( typeof parent !== 'function' ) {
				// copy props to data
				parentFn = function( data ) {
					fromProperties( data, parent );
				};
			} else {
				parentFn = function( data ) {
					// give parent function it's own this._super context,
					// otherwise this._super is from child and
					// causes infinite loop
					parent = wrap( parent, function() {}, true );
					return parent.call( this, data ) || data;
				};
			}
			return wrap( childFn, parentFn );
		}
		return __export;
	}( wrapMethod );

	/* config/types.js */
	var types = {
		TEXT: 1,
		INTERPOLATOR: 2,
		TRIPLE: 3,
		SECTION: 4,
		INVERTED: 5,
		CLOSING: 6,
		ELEMENT: 7,
		PARTIAL: 8,
		COMMENT: 9,
		DELIMCHANGE: 10,
		MUSTACHE: 11,
		TAG: 12,
		ATTRIBUTE: 13,
		CLOSING_TAG: 14,
		COMPONENT: 15,
		NUMBER_LITERAL: 20,
		STRING_LITERAL: 21,
		ARRAY_LITERAL: 22,
		OBJECT_LITERAL: 23,
		BOOLEAN_LITERAL: 24,
		GLOBAL: 26,
		KEY_VALUE_PAIR: 27,
		REFERENCE: 30,
		REFINEMENT: 31,
		MEMBER: 32,
		PREFIX_OPERATOR: 33,
		BRACKETED: 34,
		CONDITIONAL: 35,
		INFIX_OPERATOR: 36,
		INVOCATION: 40,
		SECTION_IF: 50,
		SECTION_UNLESS: 51,
		SECTION_EACH: 52,
		SECTION_WITH: 53,
		SECTION_IF_WITH: 54
	};

	/* utils/create.js */
	var create = function() {

		var create;
		try {
			Object.create( null );
			create = Object.create;
		} catch ( err ) {
			// sigh
			create = function() {
				var F = function() {};
				return function( proto, props ) {
					var obj;
					if ( proto === null ) {
						return {};
					}
					F.prototype = proto;
					obj = new F();
					if ( props ) {
						Object.defineProperties( obj, props );
					}
					return obj;
				};
			}();
		}
		return create;
	}();

	/* parse/Parser/expressions/shared/errors.js */
	var parse_Parser_expressions_shared_errors = {
		expectedExpression: 'Expected a JavaScript expression',
		expectedParen: 'Expected closing paren'
	};

	/* parse/Parser/expressions/primary/literal/numberLiteral.js */
	var numberLiteral = function( types ) {

		var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		return function( parser ) {
			var result;
			if ( result = parser.matchPattern( numberPattern ) ) {
				return {
					t: types.NUMBER_LITERAL,
					v: result
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
	var booleanLiteral = function( types ) {

		return function( parser ) {
			var remaining = parser.remaining();
			if ( remaining.substr( 0, 4 ) === 'true' ) {
				parser.pos += 4;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'true'
				};
			}
			if ( remaining.substr( 0, 5 ) === 'false' ) {
				parser.pos += 5;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'false'
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
	var makeQuotedStringMatcher = function() {

		var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
		// Match one or more characters until: ", ', \, or EOL/EOF.
		// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
		stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
		// Match one escape sequence, including the backslash.
		escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
		// Match one ES5 line continuation (backslash + line terminator).
		lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
		// Helper for defining getDoubleQuotedString and getSingleQuotedString.
		return function( okQuote ) {
			return function( parser ) {
				var start, literal, done, next;
				start = parser.pos;
				literal = '"';
				done = false;
				while ( !done ) {
					next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
					if ( next ) {
						if ( next === '"' ) {
							literal += '\\"';
						} else if ( next === '\\\'' ) {
							literal += '\'';
						} else {
							literal += next;
						}
					} else {
						next = parser.matchPattern( lineContinuationPattern );
						if ( next ) {
							// convert \(newline-like) into a \u escape, which is allowed in JSON
							literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
						} else {
							done = true;
						}
					}
				}
				literal += '"';
				// use JSON.parse to interpret escapes
				return JSON.parse( literal );
			};
		};
	}();

	/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
	var singleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '"' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
	var doubleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '\'' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
	var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

		return function( parser ) {
			var start, string;
			start = parser.pos;
			if ( parser.matchString( '"' ) ) {
				string = getDoubleQuotedString( parser );
				if ( !parser.matchString( '"' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			if ( parser.matchString( '\'' ) ) {
				string = getSingleQuotedString( parser );
				if ( !parser.matchString( '\'' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			return null;
		};
	}( types, singleQuotedString, doubleQuotedString );

	/* parse/Parser/expressions/shared/patterns.js */
	var patterns = {
		name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
	};

	/* parse/Parser/expressions/shared/key.js */
	var key = function( getStringLiteral, getNumberLiteral, patterns ) {

		var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		// http://mathiasbynens.be/notes/javascript-properties
		// can be any name, string literal, or number literal
		return function( parser ) {
			var token;
			if ( token = getStringLiteral( parser ) ) {
				return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
			}
			if ( token = getNumberLiteral( parser ) ) {
				return token.v;
			}
			if ( token = parser.matchPattern( patterns.name ) ) {
				return token;
			}
		};
	}( stringLiteral, numberLiteral, patterns );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
	var keyValuePair = function( types, getKey ) {

		return function( parser ) {
			var start, key, value;
			start = parser.pos;
			// allow whitespace between '{' and key
			parser.allowWhitespace();
			key = getKey( parser );
			if ( key === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between key and ':'
			parser.allowWhitespace();
			// next character must be ':'
			if ( !parser.matchString( ':' ) ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between ':' and value
			parser.allowWhitespace();
			// next expression must be a, well... expression
			value = parser.readExpression();
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.KEY_VALUE_PAIR,
				k: key,
				v: value
			};
		};
	}( types, key );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
	var keyValuePairs = function( getKeyValuePair ) {

		return function getKeyValuePairs( parser ) {
			var start, pairs, pair, keyValuePairs;
			start = parser.pos;
			pair = getKeyValuePair( parser );
			if ( pair === null ) {
				return null;
			}
			pairs = [ pair ];
			if ( parser.matchString( ',' ) ) {
				keyValuePairs = getKeyValuePairs( parser );
				if ( !keyValuePairs ) {
					parser.pos = start;
					return null;
				}
				return pairs.concat( keyValuePairs );
			}
			return pairs;
		};
	}( keyValuePair );

	/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
	var objectLiteral = function( types, getKeyValuePairs ) {

		return function( parser ) {
			var start, keyValuePairs;
			start = parser.pos;
			// allow whitespace
			parser.allowWhitespace();
			if ( !parser.matchString( '{' ) ) {
				parser.pos = start;
				return null;
			}
			keyValuePairs = getKeyValuePairs( parser );
			// allow whitespace between final value and '}'
			parser.allowWhitespace();
			if ( !parser.matchString( '}' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.OBJECT_LITERAL,
				m: keyValuePairs
			};
		};
	}( types, keyValuePairs );

	/* parse/Parser/expressions/shared/expressionList.js */
	var expressionList = function( errors ) {

		return function getExpressionList( parser ) {
			var start, expressions, expr, next;
			start = parser.pos;
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( expr === null ) {
				return null;
			}
			expressions = [ expr ];
			// allow whitespace between expression and ','
			parser.allowWhitespace();
			if ( parser.matchString( ',' ) ) {
				next = getExpressionList( parser );
				if ( next === null ) {
					parser.error( errors.expectedExpression );
				}
				next.forEach( append );
			}

			function append( expression ) {
				expressions.push( expression );
			}
			return expressions;
		};
	}( parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
	var arrayLiteral = function( types, getExpressionList ) {

		return function( parser ) {
			var start, expressionList;
			start = parser.pos;
			// allow whitespace before '['
			parser.allowWhitespace();
			if ( !parser.matchString( '[' ) ) {
				parser.pos = start;
				return null;
			}
			expressionList = getExpressionList( parser );
			if ( !parser.matchString( ']' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.ARRAY_LITERAL,
				m: expressionList
			};
		};
	}( types, expressionList );

	/* parse/Parser/expressions/primary/literal/_literal.js */
	var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

		return function( parser ) {
			var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
			return literal;
		};
	}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

	/* parse/Parser/expressions/primary/reference.js */
	var reference = function( types, patterns ) {

		var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
		dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
		getArrayRefinement = function( parser ) {
			var num = parser.matchPattern( arrayMemberPattern );
			if ( num ) {
				return '.' + num;
			}
			return null;
		};
		arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
		// if a reference is a browser global, we don't deference it later, so it needs special treatment
		globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
		// keywords are not valid references, with the exception of `this`
		keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
		return function( parser ) {
			var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
			startPos = parser.pos;
			// we might have a root-level reference
			if ( parser.matchString( '~/' ) ) {
				ancestor = '~/';
			} else {
				// we might have ancestor refs...
				ancestor = '';
				while ( parser.matchString( '../' ) ) {
					ancestor += '../';
				}
			}
			if ( !ancestor ) {
				// we might have an implicit iterator or a restricted reference
				dot = parser.matchString( './' ) || parser.matchString( '.' ) || '';
			}
			name = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';
			// bug out if it's a keyword
			if ( keywords.test( name ) ) {
				parser.pos = startPos;
				return null;
			}
			// if this is a browser global, stop here
			if ( !ancestor && !dot && globals.test( name ) ) {
				return {
					t: types.GLOBAL,
					v: name
				};
			}
			combo = ( ancestor || dot ) + name;
			if ( !combo ) {
				return null;
			}
			while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
				combo += refinement;
			}
			if ( parser.matchString( '(' ) ) {
				// if this is a method invocation (as opposed to a function) we need
				// to strip the method name from the reference combo, else the context
				// will be wrong
				lastDotIndex = combo.lastIndexOf( '.' );
				if ( lastDotIndex !== -1 ) {
					combo = combo.substr( 0, lastDotIndex );
					parser.pos = startPos + combo.length;
				} else {
					parser.pos -= 1;
				}
			}
			return {
				t: types.REFERENCE,
				n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
			};
		};
	}( types, patterns );

	/* parse/Parser/expressions/primary/bracketedExpression.js */
	var bracketedExpression = function( types, errors ) {

		return function( parser ) {
			var start, expr;
			start = parser.pos;
			if ( !parser.matchString( '(' ) ) {
				return null;
			}
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( !expr ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ')' ) ) {
				parser.error( errors.expectedParen );
			}
			return {
				t: types.BRACKETED,
				x: expr
			};
		};
	}( types, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/_primary.js */
	var primary = function( getLiteral, getReference, getBracketedExpression ) {

		return function( parser ) {
			return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
		};
	}( literal, reference, bracketedExpression );

	/* parse/Parser/expressions/shared/refinement.js */
	var refinement = function( types, errors, patterns ) {

		return function getRefinement( parser ) {
			var start, name, expr;
			start = parser.pos;
			parser.allowWhitespace();
			// "." name
			if ( parser.matchString( '.' ) ) {
				parser.allowWhitespace();
				if ( name = parser.matchPattern( patterns.name ) ) {
					return {
						t: types.REFINEMENT,
						n: name
					};
				}
				parser.error( 'Expected a property name' );
			}
			// "[" expression "]"
			if ( parser.matchString( '[' ) ) {
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ']' ) ) {
					parser.error( 'Expected \']\'' );
				}
				return {
					t: types.REFINEMENT,
					x: expr
				};
			}
			return null;
		};
	}( types, parse_Parser_expressions_shared_errors, patterns );

	/* parse/Parser/expressions/memberOrInvocation.js */
	var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

		return function( parser ) {
			var current, expression, refinement, expressionList;
			expression = getPrimary( parser );
			if ( !expression ) {
				return null;
			}
			while ( expression ) {
				current = parser.pos;
				if ( refinement = getRefinement( parser ) ) {
					expression = {
						t: types.MEMBER,
						x: expression,
						r: refinement
					};
				} else if ( parser.matchString( '(' ) ) {
					parser.allowWhitespace();
					expressionList = getExpressionList( parser );
					parser.allowWhitespace();
					if ( !parser.matchString( ')' ) ) {
						parser.error( errors.expectedParen );
					}
					expression = {
						t: types.INVOCATION,
						x: expression
					};
					if ( expressionList ) {
						expression.o = expressionList;
					}
				} else {
					break;
				}
			}
			return expression;
		};
	}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/typeof.js */
	var _typeof = function( types, errors, getMemberOrInvocation ) {

		var getTypeof, makePrefixSequenceMatcher;
		makePrefixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var expression;
				if ( expression = fallthrough( parser ) ) {
					return expression;
				}
				if ( !parser.matchString( symbol ) ) {
					return null;
				}
				parser.allowWhitespace();
				expression = parser.readExpression();
				if ( !expression ) {
					parser.error( errors.expectedExpression );
				}
				return {
					s: symbol,
					o: expression,
					t: types.PREFIX_OPERATOR
				};
			};
		};
		// create all prefix sequence matchers, return getTypeof
		( function() {
			var i, len, matcher, prefixOperators, fallthrough;
			prefixOperators = '! ~ + - typeof'.split( ' ' );
			fallthrough = getMemberOrInvocation;
			for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
				matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// typeof operator is higher precedence than multiplication, so provides the
			// fallthrough for the multiplication sequence matcher we're about to create
			// (we're skipping void and delete)
			getTypeof = fallthrough;
		}() );
		return getTypeof;
	}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

	/* parse/Parser/expressions/logicalOr.js */
	var logicalOr = function( types, getTypeof ) {

		var getLogicalOr, makeInfixSequenceMatcher;
		makeInfixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var start, left, right;
				left = fallthrough( parser );
				if ( !left ) {
					return null;
				}
				// Loop to handle left-recursion in a case like `a * b * c` and produce
				// left association, i.e. `(a * b) * c`.  The matcher can't call itself
				// to parse `left` because that would be infinite regress.
				while ( true ) {
					start = parser.pos;
					parser.allowWhitespace();
					if ( !parser.matchString( symbol ) ) {
						parser.pos = start;
						return left;
					}
					// special case - in operator must not be followed by [a-zA-Z_$0-9]
					if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
						parser.pos = start;
						return left;
					}
					parser.allowWhitespace();
					// right operand must also consist of only higher-precedence operators
					right = fallthrough( parser );
					if ( !right ) {
						parser.pos = start;
						return left;
					}
					left = {
						t: types.INFIX_OPERATOR,
						s: symbol,
						o: [
							left,
							right
						]
					};
				}
			};
		};
		// create all infix sequence matchers, and return getLogicalOr
		( function() {
			var i, len, matcher, infixOperators, fallthrough;
			// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
			// Each sequence matcher will initially fall through to its higher precedence
			// neighbour, and only attempt to match if one of the higher precedence operators
			// (or, ultimately, a literal, reference, or bracketed expression) already matched
			infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
			// A typeof operator is higher precedence than multiplication
			fallthrough = getTypeof;
			for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
				matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// Logical OR is the fallthrough for the conditional matcher
			getLogicalOr = fallthrough;
		}() );
		return getLogicalOr;
	}( types, _typeof );

	/* parse/Parser/expressions/conditional.js */
	var conditional = function( types, getLogicalOr, errors ) {

		return function( parser ) {
			var start, expression, ifTrue, ifFalse;
			expression = getLogicalOr( parser );
			if ( !expression ) {
				return null;
			}
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '?' ) ) {
				parser.pos = start;
				return expression;
			}
			parser.allowWhitespace();
			ifTrue = parser.readExpression();
			if ( !ifTrue ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				parser.error( 'Expected ":"' );
			}
			parser.allowWhitespace();
			ifFalse = parser.readExpression();
			if ( !ifFalse ) {
				parser.error( errors.expectedExpression );
			}
			return {
				t: types.CONDITIONAL,
				o: [
					expression,
					ifTrue,
					ifFalse
				]
			};
		};
	}( types, logicalOr, parse_Parser_expressions_shared_errors );

	/* parse/Parser/utils/flattenExpression.js */
	var flattenExpression = function( types, isObject ) {

		var __export;
		__export = function( expression ) {
			var refs = [],
				flattened;
			extractRefs( expression, refs );
			flattened = {
				r: refs,
				s: stringify( this, expression, refs )
			};
			return flattened;
		};

		function quoteStringLiteral( str ) {
			return JSON.stringify( String( str ) );
		}
		// TODO maybe refactor this?
		function extractRefs( node, refs ) {
			var i, list;
			if ( node.t === types.REFERENCE ) {
				if ( refs.indexOf( node.n ) === -1 ) {
					refs.unshift( node.n );
				}
			}
			list = node.o || node.m;
			if ( list ) {
				if ( isObject( list ) ) {
					extractRefs( list, refs );
				} else {
					i = list.length;
					while ( i-- ) {
						extractRefs( list[ i ], refs );
					}
				}
			}
			if ( node.x ) {
				extractRefs( node.x, refs );
			}
			if ( node.r ) {
				extractRefs( node.r, refs );
			}
			if ( node.v ) {
				extractRefs( node.v, refs );
			}
		}

		function stringify( parser, node, refs ) {
			var stringifyAll = function( item ) {
				return stringify( parser, item, refs );
			};
			switch ( node.t ) {
				case types.BOOLEAN_LITERAL:
				case types.GLOBAL:
				case types.NUMBER_LITERAL:
					return node.v;
				case types.STRING_LITERAL:
					return quoteStringLiteral( node.v );
				case types.ARRAY_LITERAL:
					return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
				case types.OBJECT_LITERAL:
					return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
				case types.KEY_VALUE_PAIR:
					return node.k + ':' + stringify( parser, node.v, refs );
				case types.PREFIX_OPERATOR:
					return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
				case types.INFIX_OPERATOR:
					return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
				case types.INVOCATION:
					return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
				case types.BRACKETED:
					return '(' + stringify( parser, node.x, refs ) + ')';
				case types.MEMBER:
					return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
				case types.REFINEMENT:
					return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
				case types.CONDITIONAL:
					return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
				case types.REFERENCE:
					return '_' + refs.indexOf( node.n );
				default:
					parser.error( 'Expected legal JavaScript' );
			}
		}
		return __export;
	}( types, isObject );

	/* parse/Parser/_Parser.js */
	var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

		var Parser, ParseError, leadingWhitespace = /^\s+/;
		ParseError = function( message ) {
			this.name = 'ParseError';
			this.message = message;
			try {
				throw new Error( message );
			} catch ( e ) {
				this.stack = e.stack;
			}
		};
		ParseError.prototype = Error.prototype;
		Parser = function( str, options ) {
			var items, item, lineStart = 0;
			this.str = str;
			this.options = options || {};
			this.pos = 0;
			this.lines = this.str.split( '\n' );
			this.lineEnds = this.lines.map( function( line ) {
				var lineEnd = lineStart + line.length + 1;
				// +1 for the newline
				lineStart = lineEnd;
				return lineEnd;
			}, 0 );
			// Custom init logic
			if ( this.init )
				this.init( str, options );
			items = [];
			while ( this.pos < this.str.length && ( item = this.read() ) ) {
				items.push( item );
			}
			this.leftover = this.remaining();
			this.result = this.postProcess ? this.postProcess( items, options ) : items;
		};
		Parser.prototype = {
			read: function( converters ) {
				var pos, i, len, item;
				if ( !converters )
					converters = this.converters;
				pos = this.pos;
				len = converters.length;
				for ( i = 0; i < len; i += 1 ) {
					this.pos = pos;
					// reset for each attempt
					if ( item = converters[ i ]( this ) ) {
						return item;
					}
				}
				return null;
			},
			readExpression: function() {
				// The conditional operator is the lowest precedence operator (except yield,
				// assignment operators, and commas, none of which are supported), so we
				// start there. If it doesn't match, it 'falls through' to progressively
				// higher precedence operators, until it eventually matches (or fails to
				// match) a 'primary' - a literal or a reference. This way, the abstract syntax
				// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
				return getConditional( this );
			},
			flattenExpression: flattenExpression,
			getLinePos: function( char ) {
				var lineNum = 0,
					lineStart = 0,
					columnNum;
				while ( char >= this.lineEnds[ lineNum ] ) {
					lineStart = this.lineEnds[ lineNum ];
					lineNum += 1;
				}
				columnNum = char - lineStart;
				return [
					lineNum + 1,
					columnNum + 1,
					char
				];
			},
			error: function( message ) {
				var pos, lineNum, columnNum, line, annotation, error;
				pos = this.getLinePos( this.pos );
				lineNum = pos[ 0 ];
				columnNum = pos[ 1 ];
				line = this.lines[ pos[ 0 ] - 1 ];
				annotation = line + '\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';
				error = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\n' + annotation );
				error.line = pos[ 0 ];
				error.character = pos[ 1 ];
				error.shortMessage = message;
				throw error;
			},
			matchString: function( string ) {
				if ( this.str.substr( this.pos, string.length ) === string ) {
					this.pos += string.length;
					return string;
				}
			},
			matchPattern: function( pattern ) {
				var match;
				if ( match = pattern.exec( this.remaining() ) ) {
					this.pos += match[ 0 ].length;
					return match[ 1 ] || match[ 0 ];
				}
			},
			allowWhitespace: function() {
				this.matchPattern( leadingWhitespace );
			},
			remaining: function() {
				return this.str.substring( this.pos );
			},
			nextChar: function() {
				return this.str.charAt( this.pos );
			}
		};
		Parser.extend = function( proto ) {
			var Parent = this,
				Child, key;
			Child = function( str, options ) {
				Parser.call( this, str, options );
			};
			Child.prototype = create( Parent.prototype );
			for ( key in proto ) {
				if ( hasOwnProperty.call( proto, key ) ) {
					Child.prototype[ key ] = proto[ key ];
				}
			}
			Child.extend = Parser.extend;
			return Child;
		};
		circular.Parser = Parser;
		return Parser;
	}( circular, create, hasOwn, conditional, flattenExpression );

	/* parse/converters/mustache/delimiterChange.js */
	var delimiterChange = function() {

		var delimiterChangePattern = /^[^\s=]+/,
			whitespacePattern = /^\s+/;
		return function( parser ) {
			var start, opening, closing;
			if ( !parser.matchString( '=' ) ) {
				return null;
			}
			start = parser.pos;
			// allow whitespace before new opening delimiter
			parser.allowWhitespace();
			opening = parser.matchPattern( delimiterChangePattern );
			if ( !opening ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace (in fact, it's necessary...)
			if ( !parser.matchPattern( whitespacePattern ) ) {
				return null;
			}
			closing = parser.matchPattern( delimiterChangePattern );
			if ( !closing ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing '='
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			return [
				opening,
				closing
			];
		};
	}();

	/* parse/converters/mustache/delimiterTypes.js */
	var delimiterTypes = [ {
		delimiters: 'delimiters',
		isTriple: false,
		isStatic: false
	}, {
		delimiters: 'tripleDelimiters',
		isTriple: true,
		isStatic: false
	}, {
		delimiters: 'staticDelimiters',
		isTriple: false,
		isStatic: true
	}, {
		delimiters: 'staticTripleDelimiters',
		isTriple: true,
		isStatic: true
	} ];

	/* parse/converters/mustache/type.js */
	var type = function( types ) {

		var mustacheTypes = {
			'#': types.SECTION,
			'^': types.INVERTED,
			'/': types.CLOSING,
			'>': types.PARTIAL,
			'!': types.COMMENT,
			'&': types.TRIPLE
		};
		return function( parser ) {
			var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
			if ( !type ) {
				return null;
			}
			parser.pos += 1;
			return type;
		};
	}( types );

	/* parse/converters/mustache/handlebarsBlockCodes.js */
	var handlebarsBlockCodes = function( types ) {

		return {
			'each': types.SECTION_EACH,
			'if': types.SECTION_IF,
			'if-with': types.SECTION_IF_WITH,
			'with': types.SECTION_WITH,
			'unless': types.SECTION_UNLESS
		};
	}( types );

	/* empty/legacy.js */
	var legacy = null;

	/* parse/converters/mustache/content.js */
	var content = function( types, mustacheType, handlebarsBlockCodes ) {

		var __export;
		var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
			arrayMemberPattern = /^[0-9][1-9]*$/,
			handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
			legalReference;
		legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
		__export = function( parser, delimiterType ) {
			var start, pos, mustache, type, block, expression, i, remaining, index, delimiters;
			start = parser.pos;
			mustache = {};
			delimiters = parser[ delimiterType.delimiters ];
			if ( delimiterType.isStatic ) {
				mustache.s = true;
			}
			// Determine mustache type
			if ( delimiterType.isTriple ) {
				mustache.t = types.TRIPLE;
			} else {
				// We need to test for expressions before we test for mustache type, because
				// an expression that begins '!' looks a lot like a comment
				if ( parser.remaining()[ 0 ] === '!' ) {
					try {
						expression = parser.readExpression();
						// Was it actually an expression, or a comment block in disguise?
						parser.allowWhitespace();
						if ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {
							expression = null;
						} else {
							mustache.t = types.INTERPOLATOR;
						}
					} catch ( err ) {}
					if ( !expression ) {
						index = parser.remaining().indexOf( delimiters[ 1 ] );
						if ( ~index ) {
							parser.pos += index;
						} else {
							parser.error( 'Expected closing delimiter (\'' + delimiters[ 1 ] + '\')' );
						}
						return {
							t: types.COMMENT
						};
					}
				}
				if ( !expression ) {
					type = mustacheType( parser );
					mustache.t = type || types.INTERPOLATOR;
					// default
					// See if there's an explicit section type e.g. {{#with}}...{{/with}}
					if ( type === types.SECTION ) {
						if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
							mustache.n = block;
						}
						parser.allowWhitespace();
					} else if ( type === types.COMMENT || type === types.CLOSING ) {
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];
							parser.pos += index;
							return mustache;
						}
					}
				}
			}
			if ( !expression ) {
				// allow whitespace
				parser.allowWhitespace();
				// get expression
				expression = parser.readExpression();
				// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These
				// cases involve a bit of a hack - we want to turn it into the equivalent of
				// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append
				// a 'contextPartialExpression' to the mustache, and process the context instead of
				// the reference
				var temp;
				if ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {
					mustache = {
						contextPartialExpression: expression
					};
					expression = temp;
				}
				// With certain valid references that aren't valid expressions,
				// e.g. {{1.foo}}, we have a problem: it looks like we've got an
				// expression, but the expression didn't consume the entire
				// reference. So we need to check that the mustache delimiters
				// appear next, unless there's an index reference (i.e. a colon)
				remaining = parser.remaining();
				if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
					pos = parser.pos;
					parser.pos = start;
					remaining = parser.remaining();
					index = remaining.indexOf( delimiters[ 1 ] );
					if ( index !== -1 ) {
						mustache.r = remaining.substr( 0, index ).trim();
						// Check it's a legal reference
						if ( !legalReference.test( mustache.r ) ) {
							parser.error( 'Expected a legal Mustache reference' );
						}
						parser.pos += index;
						return mustache;
					}
					parser.pos = pos;
				}
			}
			refineExpression( parser, expression, mustache );
			// if there was context, process the expression now and save it for later
			if ( mustache.contextPartialExpression ) {
				mustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {
					t: types.PARTIAL
				} ) ];
			}
			// optional index reference
			if ( i = parser.matchPattern( indexRefPattern ) ) {
				mustache.i = i;
			}
			return mustache;
		};

		function refineExpression( parser, expression, mustache ) {
			var referenceExpression;
			if ( expression ) {
				while ( expression.t === types.BRACKETED && expression.x ) {
					expression = expression.x;
				}
				// special case - integers should be treated as array members references,
				// rather than as expressions in their own right
				if ( expression.t === types.REFERENCE ) {
					mustache.r = expression.n;
				} else {
					if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
						mustache.r = expression.v;
					} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
						mustache.rx = referenceExpression;
					} else {
						mustache.x = parser.flattenExpression( expression );
					}
				}
				return mustache;
			}
		}
		// TODO refactor this! it's bewildering
		function getReferenceExpression( parser, expression ) {
			var members = [],
				refinement;
			while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
				refinement = expression.r;
				if ( refinement.x ) {
					if ( refinement.x.t === types.REFERENCE ) {
						members.unshift( refinement.x );
					} else {
						members.unshift( parser.flattenExpression( refinement.x ) );
					}
				} else {
					members.unshift( refinement.n );
				}
				expression = expression.x;
			}
			if ( expression.t !== types.REFERENCE ) {
				return null;
			}
			return {
				r: expression.n,
				m: members
			};
		}
		return __export;
	}( types, type, handlebarsBlockCodes, legacy );

	/* parse/converters/mustache.js */
	var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

		var __export;
		var delimiterChangeToken = {
			t: types.DELIMCHANGE,
			exclude: true
		};
		__export = getMustache;

		function getMustache( parser ) {
			var types;
			// If we're inside a <script> or <style> tag, and we're not
			// interpolating, bug out
			if ( parser.interpolate[ parser.inside ] === false ) {
				return null;
			}
			types = delimiterTypes.slice().sort( function compare( a, b ) {
				// Sort in order of descending opening delimiter length (longer first),
				// to protect against opening delimiters being substrings of each other
				return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
			} );
			return function r( type ) {
				if ( !type ) {
					return null;
				} else {
					return getMustacheOfType( parser, type ) || r( types.shift() );
				}
			}( types.shift() );
		}

		function getMustacheOfType( parser, delimiterType ) {
			var start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;
			start = parser.pos;
			delimiters = parser[ delimiterType.delimiters ];
			if ( !parser.matchString( delimiters[ 0 ] ) ) {
				return null;
			}
			// delimiter change?
			if ( mustache = delimiterChange( parser ) ) {
				// find closing delimiter or abort...
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					return null;
				}
				// ...then make the switch
				parser[ delimiterType.delimiters ] = mustache;
				return delimiterChangeToken;
			}
			parser.allowWhitespace();
			mustache = mustacheContent( parser, delimiterType );
			if ( mustache === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing delimiter
			parser.allowWhitespace();
			if ( !parser.matchString( delimiters[ 1 ] ) ) {
				parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
			}
			if ( mustache.t === types.COMMENT ) {
				mustache.exclude = true;
			}
			if ( mustache.t === types.CLOSING ) {
				parser.sectionDepth -= 1;
				if ( parser.sectionDepth < 0 ) {
					parser.pos = start;
					parser.error( 'Attempted to close a section that wasn\'t open' );
				}
			}
			// partials with context
			if ( mustache.contextPartialExpression ) {
				mustache.f = mustache.contextPartialExpression;
				mustache.t = types.SECTION;
				mustache.n = 'with';
				delete mustache.contextPartialExpression;
			} else if ( isSection( mustache ) ) {
				parser.sectionDepth += 1;
				children = [];
				currentChildren = children;
				expectedClose = mustache.n;
				while ( child = parser.read() ) {
					if ( child.t === types.CLOSING ) {
						if ( expectedClose && child.r !== expectedClose ) {
							parser.error( 'Expected {{/' + expectedClose + '}}' );
						}
						break;
					}
					// {{else}} tags require special treatment
					if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
						// no {{else}} allowed in {{#unless}}
						if ( mustache.n === 'unless' ) {
							parser.error( '{{else}} not allowed in {{#unless}}' );
						} else {
							currentChildren = elseChildren = [];
							continue;
						}
					}
					currentChildren.push( child );
				}
				if ( children.length ) {
					mustache.f = children;
				}
				if ( elseChildren && elseChildren.length ) {
					mustache.l = elseChildren;
					if ( mustache.n === 'with' ) {
						mustache.n = 'if-with';
					}
				}
			}
			if ( parser.includeLinePositions ) {
				mustache.p = parser.getLinePos( start );
			}
			// Replace block name with code
			if ( mustache.n ) {
				mustache.n = handlebarsBlockCodes[ mustache.n ];
			} else if ( mustache.t === types.INVERTED ) {
				mustache.t = types.SECTION;
				mustache.n = types.SECTION_UNLESS;
			}
			return mustache;
		}

		function isSection( mustache ) {
			return mustache.t === types.SECTION || mustache.t === types.INVERTED;
		}
		return __export;
	}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

	/* parse/converters/comment.js */
	var comment = function( types ) {

		var OPEN_COMMENT = '<!--',
			CLOSE_COMMENT = '-->';
		return function( parser ) {
			var start, content, remaining, endIndex, comment;
			start = parser.pos;
			if ( !parser.matchString( OPEN_COMMENT ) ) {
				return null;
			}
			remaining = parser.remaining();
			endIndex = remaining.indexOf( CLOSE_COMMENT );
			if ( endIndex === -1 ) {
				parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
			}
			content = remaining.substr( 0, endIndex );
			parser.pos += endIndex + 3;
			comment = {
				t: types.COMMENT,
				c: content
			};
			if ( parser.includeLinePositions ) {
				comment.p = parser.getLinePos( start );
			}
			return comment;
		};
	}( types );

	/* config/voidElementNames.js */
	var voidElementNames = function() {

		var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
		return voidElementNames;
	}();

	/* parse/converters/utils/getLowestIndex.js */
	var getLowestIndex = function( haystack, needles ) {
		var i, index, lowest;
		i = needles.length;
		while ( i-- ) {
			index = haystack.indexOf( needles[ i ] );
			// short circuit
			if ( !index ) {
				return 0;
			}
			if ( index === -1 ) {
				continue;
			}
			if ( !lowest || index < lowest ) {
				lowest = index;
			}
		}
		return lowest || -1;
	};

	/* shared/decodeCharacterReferences.js */
	var decodeCharacterReferences = function() {

		var __export;
		var htmlEntities, controlCharacters, entityPattern;
		htmlEntities = {
			quot: 34,
			amp: 38,
			apos: 39,
			lt: 60,
			gt: 62,
			nbsp: 160,
			iexcl: 161,
			cent: 162,
			pound: 163,
			curren: 164,
			yen: 165,
			brvbar: 166,
			sect: 167,
			uml: 168,
			copy: 169,
			ordf: 170,
			laquo: 171,
			not: 172,
			shy: 173,
			reg: 174,
			macr: 175,
			deg: 176,
			plusmn: 177,
			sup2: 178,
			sup3: 179,
			acute: 180,
			micro: 181,
			para: 182,
			middot: 183,
			cedil: 184,
			sup1: 185,
			ordm: 186,
			raquo: 187,
			frac14: 188,
			frac12: 189,
			frac34: 190,
			iquest: 191,
			Agrave: 192,
			Aacute: 193,
			Acirc: 194,
			Atilde: 195,
			Auml: 196,
			Aring: 197,
			AElig: 198,
			Ccedil: 199,
			Egrave: 200,
			Eacute: 201,
			Ecirc: 202,
			Euml: 203,
			Igrave: 204,
			Iacute: 205,
			Icirc: 206,
			Iuml: 207,
			ETH: 208,
			Ntilde: 209,
			Ograve: 210,
			Oacute: 211,
			Ocirc: 212,
			Otilde: 213,
			Ouml: 214,
			times: 215,
			Oslash: 216,
			Ugrave: 217,
			Uacute: 218,
			Ucirc: 219,
			Uuml: 220,
			Yacute: 221,
			THORN: 222,
			szlig: 223,
			agrave: 224,
			aacute: 225,
			acirc: 226,
			atilde: 227,
			auml: 228,
			aring: 229,
			aelig: 230,
			ccedil: 231,
			egrave: 232,
			eacute: 233,
			ecirc: 234,
			euml: 235,
			igrave: 236,
			iacute: 237,
			icirc: 238,
			iuml: 239,
			eth: 240,
			ntilde: 241,
			ograve: 242,
			oacute: 243,
			ocirc: 244,
			otilde: 245,
			ouml: 246,
			divide: 247,
			oslash: 248,
			ugrave: 249,
			uacute: 250,
			ucirc: 251,
			uuml: 252,
			yacute: 253,
			thorn: 254,
			yuml: 255,
			OElig: 338,
			oelig: 339,
			Scaron: 352,
			scaron: 353,
			Yuml: 376,
			fnof: 402,
			circ: 710,
			tilde: 732,
			Alpha: 913,
			Beta: 914,
			Gamma: 915,
			Delta: 916,
			Epsilon: 917,
			Zeta: 918,
			Eta: 919,
			Theta: 920,
			Iota: 921,
			Kappa: 922,
			Lambda: 923,
			Mu: 924,
			Nu: 925,
			Xi: 926,
			Omicron: 927,
			Pi: 928,
			Rho: 929,
			Sigma: 931,
			Tau: 932,
			Upsilon: 933,
			Phi: 934,
			Chi: 935,
			Psi: 936,
			Omega: 937,
			alpha: 945,
			beta: 946,
			gamma: 947,
			delta: 948,
			epsilon: 949,
			zeta: 950,
			eta: 951,
			theta: 952,
			iota: 953,
			kappa: 954,
			lambda: 955,
			mu: 956,
			nu: 957,
			xi: 958,
			omicron: 959,
			pi: 960,
			rho: 961,
			sigmaf: 962,
			sigma: 963,
			tau: 964,
			upsilon: 965,
			phi: 966,
			chi: 967,
			psi: 968,
			omega: 969,
			thetasym: 977,
			upsih: 978,
			piv: 982,
			ensp: 8194,
			emsp: 8195,
			thinsp: 8201,
			zwnj: 8204,
			zwj: 8205,
			lrm: 8206,
			rlm: 8207,
			ndash: 8211,
			mdash: 8212,
			lsquo: 8216,
			rsquo: 8217,
			sbquo: 8218,
			ldquo: 8220,
			rdquo: 8221,
			bdquo: 8222,
			dagger: 8224,
			Dagger: 8225,
			bull: 8226,
			hellip: 8230,
			permil: 8240,
			prime: 8242,
			Prime: 8243,
			lsaquo: 8249,
			rsaquo: 8250,
			oline: 8254,
			frasl: 8260,
			euro: 8364,
			image: 8465,
			weierp: 8472,
			real: 8476,
			trade: 8482,
			alefsym: 8501,
			larr: 8592,
			uarr: 8593,
			rarr: 8594,
			darr: 8595,
			harr: 8596,
			crarr: 8629,
			lArr: 8656,
			uArr: 8657,
			rArr: 8658,
			dArr: 8659,
			hArr: 8660,
			forall: 8704,
			part: 8706,
			exist: 8707,
			empty: 8709,
			nabla: 8711,
			isin: 8712,
			notin: 8713,
			ni: 8715,
			prod: 8719,
			sum: 8721,
			minus: 8722,
			lowast: 8727,
			radic: 8730,
			prop: 8733,
			infin: 8734,
			ang: 8736,
			and: 8743,
			or: 8744,
			cap: 8745,
			cup: 8746,
			'int': 8747,
			there4: 8756,
			sim: 8764,
			cong: 8773,
			asymp: 8776,
			ne: 8800,
			equiv: 8801,
			le: 8804,
			ge: 8805,
			sub: 8834,
			sup: 8835,
			nsub: 8836,
			sube: 8838,
			supe: 8839,
			oplus: 8853,
			otimes: 8855,
			perp: 8869,
			sdot: 8901,
			lceil: 8968,
			rceil: 8969,
			lfloor: 8970,
			rfloor: 8971,
			lang: 9001,
			rang: 9002,
			loz: 9674,
			spades: 9824,
			clubs: 9827,
			hearts: 9829,
			diams: 9830
		};
		controlCharacters = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
		__export = function decodeCharacterReferences( html ) {
			return html.replace( entityPattern, function( match, entity ) {
				var code;
				// Handle named entities
				if ( entity[ 0 ] !== '#' ) {
					code = htmlEntities[ entity ];
				} else if ( entity[ 1 ] === 'x' ) {
					code = parseInt( entity.substring( 2 ), 16 );
				} else {
					code = parseInt( entity.substring( 1 ), 10 );
				}
				if ( !code ) {
					return match;
				}
				return String.fromCharCode( validateCode( code ) );
			} );
		};
		// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
		// code points with alternatives in some cases - since we're bypassing that mechanism, we need
		// to replace them ourselves
		//
		// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
		function validateCode( code ) {
			if ( !code ) {
				return 65533;
			}
			// line feed becomes generic whitespace
			if ( code === 10 ) {
				return 32;
			}
			// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
			if ( code < 128 ) {
				return code;
			}
			// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
			// to correct the mistake or we'll end up with missing € signs and so on
			if ( code <= 159 ) {
				return controlCharacters[ code - 128 ];
			}
			// basic multilingual plane
			if ( code < 55296 ) {
				return code;
			}
			// UTF-16 surrogate halves
			if ( code <= 57343 ) {
				return 65533;
			}
			// rest of the basic multilingual plane
			if ( code <= 65535 ) {
				return code;
			}
			return 65533;
		}
		return __export;
	}( legacy );

	/* parse/converters/text.js */
	var text = function( getLowestIndex, decodeCharacterReferences ) {

		return function( parser ) {
			var index, remaining, disallowed, barrier;
			remaining = parser.remaining();
			barrier = parser.inside ? '</' + parser.inside : '<';
			if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
				index = remaining.indexOf( barrier );
			} else {
				disallowed = [
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				// http://developers.whatwg.org/syntax.html#syntax-attributes
				if ( parser.inAttribute === true ) {
					// we're inside an unquoted attribute value
					disallowed.push( '"', '\'', '=', '<', '>', '`' );
				} else if ( parser.inAttribute ) {
					// quoted attribute value
					disallowed.push( parser.inAttribute );
				} else {
					disallowed.push( barrier );
				}
				index = getLowestIndex( remaining, disallowed );
			}
			if ( !index ) {
				return null;
			}
			if ( index === -1 ) {
				index = remaining.length;
			}
			parser.pos += index;
			return parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );
		};
	}( getLowestIndex, decodeCharacterReferences );

	/* parse/converters/element/closingTag.js */
	var closingTag = function( types ) {

		var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
		return function( parser ) {
			var tag;
			// are we looking at a closing tag?
			if ( !parser.matchString( '</' ) ) {
				return null;
			}
			if ( tag = parser.matchPattern( closingTagPattern ) ) {
				return {
					t: types.CLOSING_TAG,
					e: tag
				};
			}
			// We have an illegal closing tag, report it
			parser.pos -= 2;
			parser.error( 'Illegal closing tag' );
		};
	}( types );

	/* parse/converters/element/attribute.js */
	var attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {

		var __export;
		var attributeNamePattern = /^[^\s"'>\/=]+/,
			unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
		__export = getAttribute;

		function getAttribute( parser ) {
			var attr, name, value;
			parser.allowWhitespace();
			name = parser.matchPattern( attributeNamePattern );
			if ( !name ) {
				return null;
			}
			attr = {
				name: name
			};
			value = getAttributeValue( parser );
			if ( value ) {
				attr.value = value;
			}
			return attr;
		}

		function getAttributeValue( parser ) {
			var start, valueStart, startDepth, value;
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			parser.allowWhitespace();
			valueStart = parser.pos;
			startDepth = parser.sectionDepth;
			value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
			if ( parser.sectionDepth !== startDepth ) {
				parser.pos = valueStart;
				parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
			}
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			if ( !value.length ) {
				return null;
			}
			if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
				return decodeCharacterReferences( value[ 0 ] );
			}
			return value;
		}

		function getUnquotedAttributeValueToken( parser ) {
			var start, text, haystack, needles, index;
			start = parser.pos;
			text = parser.matchPattern( unquotedAttributeValueTextPattern );
			if ( !text ) {
				return null;
			}
			haystack = text;
			needles = [
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
				text = text.substr( 0, index );
				parser.pos = start + text.length;
			}
			return text;
		}

		function getUnquotedAttributeValue( parser ) {
			var tokens, token;
			parser.inAttribute = true;
			tokens = [];
			token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			}
			if ( !tokens.length ) {
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedAttributeValue( parser, quoteMark ) {
			var start, tokens, token;
			start = parser.pos;
			if ( !parser.matchString( quoteMark ) ) {
				return null;
			}
			parser.inAttribute = quoteMark;
			tokens = [];
			token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			}
			if ( !parser.matchString( quoteMark ) ) {
				parser.pos = start;
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedStringToken( parser, quoteMark ) {
			var start, index, haystack, needles;
			start = parser.pos;
			haystack = parser.remaining();
			needles = [
				quoteMark,
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			index = getLowestIndex( haystack, needles );
			if ( index === -1 ) {
				parser.error( 'Quoted attribute value must have a closing quote' );
			}
			if ( !index ) {
				return null;
			}
			parser.pos += index;
			return haystack.substr( 0, index );
		}
		return __export;
	}( getLowestIndex, mustache, decodeCharacterReferences );

	/* utils/parseJSON.js */
	var parseJSON = function( Parser, getStringLiteral, getKey ) {

		var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
		specials = {
			'true': true,
			'false': false,
			'undefined': undefined,
			'null': null
		};
		specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
		numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		placeholderPattern = /\$\{([^\}]+)\}/g;
		placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
		onlyWhitespace = /^\s*$/;
		JsonParser = Parser.extend( {
			init: function( str, options ) {
				this.values = options.values;
				this.allowWhitespace();
			},
			postProcess: function( result ) {
				if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
					return null;
				}
				return {
					value: result[ 0 ].v
				};
			},
			converters: [

				function getPlaceholder( parser ) {
					var placeholder;
					if ( !parser.values ) {
						return null;
					}
					placeholder = parser.matchPattern( placeholderAtStartPattern );
					if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
						return {
							v: parser.values[ placeholder ]
						};
					}
				},
				function getSpecial( parser ) {
					var special;
					if ( special = parser.matchPattern( specialsPattern ) ) {
						return {
							v: specials[ special ]
						};
					}
				},
				function getNumber( parser ) {
					var number;
					if ( number = parser.matchPattern( numberPattern ) ) {
						return {
							v: +number
						};
					}
				},
				function getString( parser ) {
					var stringLiteral = getStringLiteral( parser ),
						values;
					if ( stringLiteral && ( values = parser.values ) ) {
						return {
							v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
								return $1 in values ? values[ $1 ] : $1;
							} )
						};
					}
					return stringLiteral;
				},
				function getObject( parser ) {
					var result, pair;
					if ( !parser.matchString( '{' ) ) {
						return null;
					}
					result = {};
					parser.allowWhitespace();
					if ( parser.matchString( '}' ) ) {
						return {
							v: result
						};
					}
					while ( pair = getKeyValuePair( parser ) ) {
						result[ pair.key ] = pair.value;
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
					}
					return null;
				},
				function getArray( parser ) {
					var result, valueToken;
					if ( !parser.matchString( '[' ) ) {
						return null;
					}
					result = [];
					parser.allowWhitespace();
					if ( parser.matchString( ']' ) ) {
						return {
							v: result
						};
					}
					while ( valueToken = parser.read() ) {
						result.push( valueToken.v );
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
						parser.allowWhitespace();
					}
					return null;
				}
			]
		} );

		function getKeyValuePair( parser ) {
			var key, valueToken, pair;
			parser.allowWhitespace();
			key = getKey( parser );
			if ( !key ) {
				return null;
			}
			pair = {
				key: key
			};
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				return null;
			}
			parser.allowWhitespace();
			valueToken = parser.read();
			if ( !valueToken ) {
				return null;
			}
			pair.value = valueToken.v;
			return pair;
		}
		return function( str, values ) {
			var parser = new JsonParser( str, {
				values: values
			} );
			return parser.result;
		};
	}( Parser, stringLiteral, key );

	/* parse/converters/element/processDirective.js */
	var processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {

		var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
			ExpressionParser;
		ExpressionParser = Parser.extend( {
			converters: [ conditional ]
		} );
		// TODO clean this up, it's shocking
		return function( tokens ) {
			var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;
			if ( typeof tokens === 'string' ) {
				if ( match = methodCallPattern.exec( tokens ) ) {
					result = {
						m: match[ 1 ]
					};
					args = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';
					parser = new ExpressionParser( args );
					result.a = flattenExpression( parser.result[ 0 ] );
					return result;
				}
				if ( tokens.indexOf( ':' ) === -1 ) {
					return tokens.trim();
				}
				tokens = [ tokens ];
			}
			result = {};
			directiveName = [];
			directiveArgs = [];
			if ( tokens ) {
				while ( tokens.length ) {
					token = tokens.shift();
					if ( typeof token === 'string' ) {
						colonIndex = token.indexOf( ':' );
						if ( colonIndex === -1 ) {
							directiveName.push( token );
						} else {
							// is the colon the first character?
							if ( colonIndex ) {
								// no
								directiveName.push( token.substr( 0, colonIndex ) );
							}
							// if there is anything after the colon in this token, treat
							// it as the first token of the directiveArgs fragment
							if ( token.length > colonIndex + 1 ) {
								directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
							}
							break;
						}
					} else {
						directiveName.push( token );
					}
				}
				directiveArgs = directiveArgs.concat( tokens );
			}
			if ( !directiveName.length ) {
				result = '';
			} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
				result = {
					// TODO is this really necessary? just use the array
					n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
				};
				if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
					parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
					result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
				} else {
					result.d = directiveArgs;
				}
			} else {
				result = directiveName;
			}
			return result;
		};
	}( Parser, conditional, flattenExpression, parseJSON );

	/* parse/converters/element.js */
	var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

		var __export;
		var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
			validTagNameFollower = /^[\s\n\/>]/,
			onPattern = /^on/,
			proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
			reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
			directives = {
				'intro-outro': 't0',
				intro: 't1',
				outro: 't2',
				decorator: 'o'
			},
			exclude = {
				exclude: true
			},
			converters, disallowedContents;
		// Different set of converters, because this time we're looking for closing tags
		converters = [
			getMustache,
			getComment,
			getElement,
			getText,
			getClosingTag
		];
		// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
		disallowedContents = {
			li: [ 'li' ],
			dt: [
				'dt',
				'dd'
			],
			dd: [
				'dt',
				'dd'
			],
			p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
			rt: [
				'rt',
				'rp'
			],
			rp: [
				'rt',
				'rp'
			],
			optgroup: [ 'optgroup' ],
			option: [
				'option',
				'optgroup'
			],
			thead: [
				'tbody',
				'tfoot'
			],
			tbody: [
				'tbody',
				'tfoot'
			],
			tfoot: [ 'tbody' ],
			tr: [
				'tr',
				'tbody'
			],
			td: [
				'td',
				'th',
				'tr'
			],
			th: [
				'td',
				'th',
				'tr'
			]
		};
		__export = getElement;

		function getElement( parser ) {
			var start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
			start = parser.pos;
			if ( parser.inside || parser.inAttribute ) {
				return null;
			}
			if ( !parser.matchString( '<' ) ) {
				return null;
			}
			// if this is a closing tag, abort straight away
			if ( parser.nextChar() === '/' ) {
				return null;
			}
			element = {
				t: types.ELEMENT
			};
			if ( parser.includeLinePositions ) {
				element.p = parser.getLinePos( start );
			}
			if ( parser.matchString( '!' ) ) {
				element.y = 1;
			}
			// element name
			element.e = parser.matchPattern( tagNamePattern );
			if ( !element.e ) {
				return null;
			}
			// next character must be whitespace, closing solidus or '>'
			if ( !validTagNameFollower.test( parser.nextChar() ) ) {
				parser.error( 'Illegal tag name' );
			}
			addProxyEvent = function( name, directive ) {
				var directiveName = directive.n || directive;
				if ( reservedEventNames.test( directiveName ) ) {
					parser.pos -= directiveName.length;
					parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
				}
				element.v[ name ] = directive;
			};
			parser.allowWhitespace();
			// directives and attributes
			while ( attribute = getMustache( parser ) || getAttribute( parser ) ) {
				// regular attributes
				if ( attribute.name ) {
					// intro, outro, decorator
					if ( directiveName = directives[ attribute.name ] ) {
						element[ directiveName ] = processDirective( attribute.value );
					} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
						if ( !element.v )
							element.v = {};
						directive = processDirective( attribute.value );
						addProxyEvent( match[ 1 ], directive );
					} else {
						if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
							if ( !element.a )
								element.a = {};
							element.a[ attribute.name ] = attribute.value || 0;
						}
					}
				} else {
					if ( !element.m )
						element.m = [];
					element.m.push( attribute );
				}
				parser.allowWhitespace();
			}
			// allow whitespace before closing solidus
			parser.allowWhitespace();
			// self-closing solidus?
			if ( parser.matchString( '/' ) ) {
				selfClosing = true;
			}
			// closing angle bracket
			if ( !parser.matchString( '>' ) ) {
				return null;
			}
			lowerCaseName = element.e.toLowerCase();
			if ( !selfClosing && !voidElementNames.test( element.e ) ) {
				// Special case - if we open a script element, further tags should
				// be ignored unless they're a closing script element
				if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
					parser.inside = lowerCaseName;
				}
				children = [];
				while ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {
					// Special case - closing section tag
					if ( child.t === types.CLOSING ) {
						break;
					}
					if ( child.t === types.CLOSING_TAG ) {
						break;
					}
					children.push( child );
				}
				if ( children.length ) {
					element.f = children;
				}
			}
			parser.inside = null;
			if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
				return exclude;
			}
			return element;
		}

		function canContain( name, remaining ) {
			var match, disallowed;
			match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
			disallowed = disallowedContents[ name ];
			if ( !match || !disallowed ) {
				return true;
			}
			return !~disallowed.indexOf( match[ 1 ].toLowerCase() );
		}
		return __export;
	}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

	/* parse/utils/trimWhitespace.js */
	var trimWhitespace = function() {

		var leadingWhitespace = /^[ \t\f\r\n]+/,
			trailingWhitespace = /[ \t\f\r\n]+$/;
		return function( items, leading, trailing ) {
			var item;
			if ( leading ) {
				item = items[ 0 ];
				if ( typeof item === 'string' ) {
					item = item.replace( leadingWhitespace, '' );
					if ( !item ) {
						items.shift();
					} else {
						items[ 0 ] = item;
					}
				}
			}
			if ( trailing ) {
				item = items[ items.length - 1 ];
				if ( typeof item === 'string' ) {
					item = item.replace( trailingWhitespace, '' );
					if ( !item ) {
						items.pop();
					} else {
						items[ items.length - 1 ] = item;
					}
				}
			}
		};
	}();

	/* parse/utils/stripStandalones.js */
	var stripStandalones = function( types ) {

		var __export;
		var leadingLinebreak = /^\s*\r?\n/,
			trailingLinebreak = /\r?\n\s*$/;
		__export = function( items ) {
			var i, current, backOne, backTwo, lastSectionItem;
			for ( i = 1; i < items.length; i += 1 ) {
				current = items[ i ];
				backOne = items[ i - 1 ];
				backTwo = items[ i - 2 ];
				// if we're at the end of a [text][comment][text] sequence...
				if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
					// ... and the comment is a standalone (i.e. line breaks either side)...
					if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
						// ... then we want to remove the whitespace after the first line break
						items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
						// and the leading line break of the second text token
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
				// if the current item is a section, and it is preceded by a linebreak, and
				// its first item is a linebreak...
				if ( isSection( current ) && isString( backOne ) ) {
					if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
						items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
						current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
					}
				}
				// if the last item was a section, and it is followed by a linebreak, and
				// its last item is a linebreak...
				if ( isString( current ) && isSection( backOne ) ) {
					lastSectionItem = backOne.f[ backOne.f.length - 1 ];
					if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
						backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
			}
			return items;
		};

		function isString( item ) {
			return typeof item === 'string';
		}

		function isComment( item ) {
			return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
		}

		function isSection( item ) {
			return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
		}
		return __export;
	}( types );

	/* utils/escapeRegExp.js */
	var escapeRegExp = function() {

		var pattern = /[-/\\^$*+?.()|[\]{}]/g;
		return function escapeRegExp( str ) {
			return str.replace( pattern, '\\$&' );
		};
	}();

	/* parse/_parse.js */
	var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {

		var __export;
		var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
			preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
			leadingWhitespace = /^\s+/,
			trailingWhitespace = /\s+$/;
		StandardParser = Parser.extend( {
			init: function( str, options ) {
				// config
				setDelimiters( options, this );
				this.sectionDepth = 0;
				this.interpolate = {
					script: !options.interpolate || options.interpolate.script !== false,
					style: !options.interpolate || options.interpolate.style !== false
				};
				if ( options.sanitize === true ) {
					options.sanitize = {
						// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
						elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
						eventAttributes: true
					};
				}
				this.sanitizeElements = options.sanitize && options.sanitize.elements;
				this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
				this.includeLinePositions = options.includeLinePositions;
			},
			postProcess: function( items, options ) {
				if ( this.sectionDepth > 0 ) {
					this.error( 'A section was left open' );
				}
				cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
				return items;
			},
			converters: [
				mustache,
				comment,
				element,
				text
			]
		} );
		parse = function( template ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;
			setDelimiters( options );
			inlinePartialStart = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*>\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			inlinePartialEnd = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*\\/\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			result = {
				v: 1
			};
			if ( inlinePartialStart.test( template ) ) {
				remaining = template;
				template = '';
				while ( startMatch = inlinePartialStart.exec( remaining ) ) {
					name = startMatch[ 1 ];
					template += remaining.substr( 0, startMatch.index );
					remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
					endMatch = inlinePartialEnd.exec( remaining );
					if ( !endMatch || endMatch[ 1 ] !== name ) {
						throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for "' + name + '", but ' + ( endMatch ? 'instead found "' + endMatch[ 1 ] + '"' : ' no closing found' ) );
					}
					( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
					remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
				}
				template += remaining;
				result.p = partials;
			}
			result.t = new StandardParser( template, options ).result;
			return result;
		};
		__export = parse;

		function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
			var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
			// First pass - remove standalones and comments etc
			stripStandalones( items );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Remove delimiter changes, unsafe elements etc
				if ( item.exclude ) {
					items.splice( i, 1 );
				} else if ( stripComments && item.t === types.COMMENT ) {
					items.splice( i, 1 );
				}
			}
			// If necessary, remove leading and trailing whitespace
			trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Recurse
				if ( item.f ) {
					preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
					if ( !preserveWhitespaceInsideFragment ) {
						previousItem = items[ i - 1 ];
						nextItem = items[ i + 1 ];
						// if the previous item was a text item with trailing whitespace,
						// remove leading whitespace inside the fragment
						if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
							removeLeadingWhitespaceInsideFragment = true;
						}
						// and vice versa
						if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
							removeTrailingWhitespaceInsideFragment = true;
						}
					}
					cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
				}
				// Split if-else blocks into two (an if, and an unless)
				if ( item.l ) {
					cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					if ( rewriteElse ) {
						unlessBlock = {
							t: 4,
							n: types.SECTION_UNLESS,
							f: item.l
						};
						// copy the conditional based on its type
						if ( item.r ) {
							unlessBlock.r = item.r;
						}
						if ( item.x ) {
							unlessBlock.x = item.x;
						}
						if ( item.rx ) {
							unlessBlock.rx = item.rx;
						}
						items.splice( i + 1, 0, unlessBlock );
						delete item.l;
					}
				}
				// Clean up element attributes
				if ( item.a ) {
					for ( key in item.a ) {
						if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
							cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						}
					}
				}
			}
			// final pass - fuse text nodes together
			i = items.length;
			while ( i-- ) {
				if ( typeof items[ i ] === 'string' ) {
					if ( typeof items[ i + 1 ] === 'string' ) {
						items[ i ] = items[ i ] + items[ i + 1 ];
						items.splice( i + 1, 1 );
					}
					if ( !preserveWhitespace ) {
						items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
					}
					if ( items[ i ] === '' ) {
						items.splice( i, 1 );
					}
				}
			}
		}

		function setDelimiters( source ) {
			var target = arguments[ 1 ];
			if ( target === void 0 )
				target = source;
			target.delimiters = source.delimiters || [
				'{{',
				'}}'
			];
			target.tripleDelimiters = source.tripleDelimiters || [
				'{{{',
				'}}}'
			];
			target.staticDelimiters = source.staticDelimiters || [
				'[[',
				']]'
			];
			target.staticTripleDelimiters = source.staticTripleDelimiters || [
				'[[[',
				']]]'
			];
		}
		return __export;
	}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );

	/* config/options/groups/optionGroup.js */
	var optionGroup = function() {

		return function createOptionGroup( keys, config ) {
			var group = keys.map( config );
			keys.forEach( function( key, i ) {
				group[ key ] = group[ i ];
			} );
			return group;
		};
	}( legacy );

	/* config/options/groups/parseOptions.js */
	var parseOptions = function( optionGroup ) {

		var keys, parseOptions;
		keys = [
			'preserveWhitespace',
			'sanitize',
			'stripComments',
			'delimiters',
			'tripleDelimiters',
			'interpolate'
		];
		parseOptions = optionGroup( keys, function( key ) {
			return key;
		} );
		return parseOptions;
	}( optionGroup );

	/* config/options/template/parser.js */
	var parser = function( errors, isClient, parse, create, parseOptions ) {

		var parser = {
			parse: doParse,
			fromId: fromId,
			isHashedId: isHashedId,
			isParsed: isParsed,
			getParseOptions: getParseOptions,
			createHelper: createHelper
		};

		function createHelper( parseOptions ) {
			var helper = create( parser );
			helper.parse = function( template, options ) {
				return doParse( template, options || parseOptions );
			};
			return helper;
		}

		function doParse( template, parseOptions ) {
			if ( !parse ) {
				throw new Error( errors.missingParser );
			}
			return parse( template, parseOptions || this.options );
		}

		function fromId( id, options ) {
			var template;
			if ( !isClient ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
			}
			if ( isHashedId( id ) ) {
				id = id.substring( 1 );
			}
			if ( !( template = document.getElementById( id ) ) ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Could not find template element with id #' + id );
			}
			if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
			}
			return template.innerHTML;
		}

		function isHashedId( id ) {
			return id && id.charAt( 0 ) === '#';
		}

		function isParsed( template ) {
			return !( typeof template === 'string' );
		}

		function getParseOptions( ractive ) {
			// Could be Ractive or a Component
			if ( ractive.defaults ) {
				ractive = ractive.defaults;
			}
			return parseOptions.reduce( function( val, key ) {
				val[ key ] = ractive[ key ];
				return val;
			}, {} );
		}
		return parser;
	}( errors, isClient, parse, create, parseOptions );

	/* config/options/template/template.js */
	var template = function( parser, parse ) {

		var templateConfig = {
			name: 'template',
			extend: function extend( Parent, proto, options ) {
				var template;
				// only assign if exists
				if ( 'template' in options ) {
					template = options.template;
					if ( typeof template === 'function' ) {
						proto.template = template;
					} else {
						proto.template = parseIfString( template, proto );
					}
				}
			},
			init: function init( Parent, ractive, options ) {
				var template, fn;
				// TODO because of prototypal inheritance, we might just be able to use
				// ractive.template, and not bother passing through the Parent object.
				// At present that breaks the test mocks' expectations
				template = 'template' in options ? options.template : Parent.prototype.template;
				if ( typeof template === 'function' ) {
					fn = template;
					template = getDynamicTemplate( ractive, fn );
					ractive._config.template = {
						fn: fn,
						result: template
					};
				}
				template = parseIfString( template, ractive );
				// TODO the naming of this is confusing - ractive.template refers to [...],
				// but Component.prototype.template refers to {v:1,t:[],p:[]}...
				// it's unnecessary, because the developer never needs to access
				// ractive.template
				ractive.template = template.t;
				if ( template.p ) {
					extendPartials( ractive.partials, template.p );
				}
			},
			reset: function( ractive ) {
				var result = resetValue( ractive ),
					parsed;
				if ( result ) {
					parsed = parseIfString( result, ractive );
					ractive.template = parsed.t;
					extendPartials( ractive.partials, parsed.p, true );
					return true;
				}
			}
		};

		function resetValue( ractive ) {
			var initial = ractive._config.template,
				result;
			// If this isn't a dynamic template, there's nothing to do
			if ( !initial || !initial.fn ) {
				return;
			}
			result = getDynamicTemplate( ractive, initial.fn );
			// TODO deep equality check to prevent unnecessary re-rendering
			// in the case of already-parsed templates
			if ( result !== initial.result ) {
				initial.result = result;
				result = parseIfString( result, ractive );
				return result;
			}
		}

		function getDynamicTemplate( ractive, fn ) {
			var helper = parser.createHelper( parser.getParseOptions( ractive ) );
			return fn.call( ractive, ractive.data, helper );
		}

		function parseIfString( template, ractive ) {
			if ( typeof template === 'string' ) {
				// ID of an element containing the template?
				if ( template[ 0 ] === '#' ) {
					template = parser.fromId( template );
				}
				template = parse( template, parser.getParseOptions( ractive ) );
			} else if ( template.v !== 1 ) {
				throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
			}
			return template;
		}

		function extendPartials( existingPartials, newPartials, overwrite ) {
			if ( !newPartials )
				return;
			// TODO there's an ambiguity here - we need to overwrite in the `reset()`
			// case, but not initially...
			for ( var key in newPartials ) {
				if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
					existingPartials[ key ] = newPartials[ key ];
				}
			}
		}
		return templateConfig;
	}( parser, parse );

	/* config/options/Registry.js */
	var Registry = function( create ) {

		function Registry( name, useDefaults ) {
			this.name = name;
			this.useDefaults = useDefaults;
		}
		Registry.prototype = {
			constructor: Registry,
			extend: function( Parent, proto, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
			},
			init: function( Parent, ractive, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
			},
			configure: function( Parent, target, options ) {
				var name = this.name,
					option = options[ name ],
					registry;
				registry = create( Parent[ name ] );
				for ( var key in option ) {
					registry[ key ] = option[ key ];
				}
				target[ name ] = registry;
			},
			reset: function( ractive ) {
				var registry = ractive[ this.name ];
				var changed = false;
				Object.keys( registry ).forEach( function( key ) {
					var item = registry[ key ];
					if ( item._fn ) {
						if ( item._fn.isOwner ) {
							registry[ key ] = item._fn;
						} else {
							delete registry[ key ];
						}
						changed = true;
					}
				} );
				return changed;
			},
			findOwner: function( ractive, key ) {
				return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
			},
			findConstructor: function( constructor, key ) {
				if ( !constructor ) {
					return;
				}
				return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
			},
			find: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ];
				} );
			},
			findInstance: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ] ? r : void 0;
				} );
			}
		};

		function recurseFind( ractive, fn ) {
			var find, parent;
			if ( find = fn( ractive ) ) {
				return find;
			}
			if ( !ractive.isolated && ( parent = ractive._parent ) ) {
				return recurseFind( parent, fn );
			}
		}
		return Registry;
	}( create, legacy );

	/* config/options/groups/registries.js */
	var registries = function( optionGroup, Registry ) {

		var keys = [
				'adaptors',
				'components',
				'computed',
				'decorators',
				'easing',
				'events',
				'interpolators',
				'partials',
				'transitions'
			],
			registries = optionGroup( keys, function( key ) {
				return new Registry( key, key === 'computed' );
			} );
		return registries;
	}( optionGroup, Registry );

	/* utils/noop.js */
	var noop = function() {};

	/* utils/wrapPrototypeMethod.js */
	var wrapPrototypeMethod = function( noop ) {

		var __export;
		__export = function wrap( parent, name, method ) {
			if ( !/_super/.test( method ) ) {
				return method;
			}
			var wrapper = function wrapSuper() {
				var superMethod = getSuperMethod( wrapper._parent, name ),
					hasSuper = '_super' in this,
					oldSuper = this._super,
					result;
				this._super = superMethod;
				result = method.apply( this, arguments );
				if ( hasSuper ) {
					this._super = oldSuper;
				} else {
					delete this._super;
				}
				return result;
			};
			wrapper._parent = parent;
			wrapper._method = method;
			return wrapper;
		};

		function getSuperMethod( parent, name ) {
			var method;
			if ( name in parent ) {
				var value = parent[ name ];
				if ( typeof value === 'function' ) {
					method = value;
				} else {
					method = function returnValue() {
						return value;
					};
				}
			} else {
				method = noop;
			}
			return method;
		}
		return __export;
	}( noop );

	/* config/deprecate.js */
	var deprecate = function( warn, isArray ) {

		function deprecate( options, deprecated, correct ) {
			if ( deprecated in options ) {
				if ( !( correct in options ) ) {
					warn( getMessage( deprecated, correct ) );
					options[ correct ] = options[ deprecated ];
				} else {
					throw new Error( getMessage( deprecated, correct, true ) );
				}
			}
		}

		function getMessage( deprecated, correct, isError ) {
			return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
		}

		function deprecateEventDefinitions( options ) {
			deprecate( options, 'eventDefinitions', 'events' );
		}

		function deprecateAdaptors( options ) {
			// Using extend with Component instead of options,
			// like Human.extend( Spider ) means adaptors as a registry
			// gets copied to options. So we have to check if actually an array
			if ( isArray( options.adaptors ) ) {
				deprecate( options, 'adaptors', 'adapt' );
			}
		}
		return function deprecateOptions( options ) {
			deprecate( options, 'beforeInit', 'onconstruct' );
			deprecate( options, 'init', 'onrender' );
			deprecate( options, 'complete', 'oncomplete' );
			deprecateEventDefinitions( options );
			deprecateAdaptors( options );
		};
	}( warn, isArray );

	/* config/config.js */
	var config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {

		var custom, options, config, blacklisted;
		// would be nice to not have these here,
		// they get added during initialise, so for now we have
		// to make sure not to try and extend them.
		// Possibly, we could re-order and not add till later
		// in process.
		blacklisted = {
			'_parent': true,
			'_component': true
		};
		custom = {
			data: data,
			template: template,
			css: css
		};
		options = Object.keys( defaults ).filter( function( key ) {
			return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
		} );
		// this defines the order:
		config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
		for ( var key in custom ) {
			config[ key ] = custom[ key ];
		}
		// for iteration
		config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
			return r.name;
		} ) ).concat( [ 'css' ] );
		// add these to blacklisted key's that we don't double extend
		config.keys.forEach( function( key ) {
			return blacklisted[ key ] = true;
		} );
		config.parseOptions = parseOptions;
		config.registries = registries;

		function customConfig( method, key, Parent, instance, options ) {
			custom[ key ][ method ]( Parent, instance, options );
		}
		config.extend = function( Parent, proto, options ) {
			configure( 'extend', Parent, proto, options );
		};
		config.init = function( Parent, ractive, options ) {
			configure( 'init', Parent, ractive, options );
		};

		function isStandardDefaultKey( key ) {
			return key in defaults && !( key in config.parseOptions ) && !( key in custom );
		}

		function configure( method, Parent, instance, options ) {
			deprecate( options );
			customConfig( method, 'data', Parent, instance, options );
			config.parseOptions.forEach( function( key ) {
				if ( key in options ) {
					instance[ key ] = options[ key ];
				}
			} );
			for ( var key in options ) {
				if ( isStandardDefaultKey( key ) ) {
					var value = options[ key ];
					instance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;
				}
			}
			config.registries.forEach( function( registry ) {
				registry[ method ]( Parent, instance, options );
			} );
			customConfig( method, 'template', Parent, instance, options );
			customConfig( method, 'css', Parent, instance, options );
			extendOtherMethods( Parent.prototype, instance, options );
		}

		function extendOtherMethods( parent, instance, options ) {
			for ( var key in options ) {
				if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
					var member = options[ key ];
					// if this is a method that overwrites a method, wrap it:
					if ( typeof member === 'function' ) {
						member = wrapPrototype( parent, key, member );
					}
					instance[ key ] = member;
				}
			}
		}
		config.reset = function( ractive ) {
			return config.filter( function( c ) {
				return c.reset && c.reset( ractive );
			} ).map( function( c ) {
				return c.name;
			} );
		};
		config.getConstructTarget = function( ractive, options ) {
			if ( options.onconstruct ) {
				// pretend this object literal is the ractive instance
				return {
					onconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),
					fire: ractive.fire.bind( ractive )
				};
			} else {
				return ractive;
			}
		};
		return config;
	}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

	/* shared/interpolate.js */
	var interpolate = function( circular, warn, interpolators, config ) {

		var __export;
		var interpolate = function( from, to, ractive, type ) {
			if ( from === to ) {
				return snap( to );
			}
			if ( type ) {
				var interpol = config.registries.interpolators.find( ractive, type );
				if ( interpol ) {
					return interpol( from, to ) || snap( to );
				}
				warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
			}
			return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );
		};
		circular.interpolate = interpolate;
		__export = interpolate;

		function snap( to ) {
			return function() {
				return to;
			};
		}
		return __export;
	}( circular, warn, interpolators, config );

	/* Ractive/prototype/animate/Animation.js */
	var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

		var Animation = function( options ) {
			var key;
			this.startTime = Date.now();
			// from and to
			for ( key in options ) {
				if ( options.hasOwnProperty( key ) ) {
					this[ key ] = options[ key ];
				}
			}
			this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
			this.running = true;
			this.tick();
		};
		Animation.prototype = {
			tick: function() {
				var elapsed, t, value, timeNow, index, keypath;
				keypath = this.keypath;
				if ( this.running ) {
					timeNow = Date.now();
					elapsed = timeNow - this.startTime;
					if ( elapsed >= this.duration ) {
						if ( keypath !== null ) {
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, this.to );
							runloop.end();
						}
						if ( this.step ) {
							this.step( 1, this.to );
						}
						this.complete( this.to );
						index = this.root._animations.indexOf( this );
						// TODO investigate why this happens
						if ( index === -1 ) {
							warn( 'Animation was not found' );
						}
						this.root._animations.splice( index, 1 );
						this.running = false;
						return false;
					}
					t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
					if ( keypath !== null ) {
						value = this.interpolator( t );
						runloop.start( this.root );
						this.root.viewmodel.set( keypath, value );
						runloop.end();
					}
					if ( this.step ) {
						this.step( t, value );
					}
					return true;
				}
				return false;
			},
			stop: function() {
				var index;
				this.running = false;
				index = this.root._animations.indexOf( this );
				// TODO investigate why this happens
				if ( index === -1 ) {
					warn( 'Animation was not found' );
				}
				this.root._animations.splice( index, 1 );
			}
		};
		return Animation;
	}( warn, runloop, interpolate );

	/* Ractive/prototype/animate.js */
	var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

		var __export;
		var noop = function() {},
			noAnimation = {
				stop: noop
			};
		__export = function Ractive$animate( keypath, to, options ) {
			var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
			promise = new Promise( function( fulfil ) {
				fulfilPromise = fulfil;
			} );
			// animate multiple keypaths
			if ( typeof keypath === 'object' ) {
				options = to || {};
				easing = options.easing;
				duration = options.duration;
				animations = [];
				// we don't want to pass the `step` and `complete` handlers, as they will
				// run for each animation! So instead we'll store the handlers and create
				// our own...
				step = options.step;
				complete = options.complete;
				if ( step || complete ) {
					currentValues = {};
					options.step = null;
					options.complete = null;
					makeValueCollector = function( keypath ) {
						return function( t, value ) {
							currentValues[ keypath ] = value;
						};
					};
				}
				for ( k in keypath ) {
					if ( keypath.hasOwnProperty( k ) ) {
						if ( step || complete ) {
							collectValue = makeValueCollector( k );
							options = {
								easing: easing,
								duration: duration
							};
							if ( step ) {
								options.step = collectValue;
							}
						}
						options.complete = complete ? collectValue : noop;
						animations.push( animate( this, k, keypath[ k ], options ) );
					}
				}
				// Create a dummy animation, to facilitate step/complete
				// callbacks, and Promise fulfilment
				dummyOptions = {
					easing: easing,
					duration: duration
				};
				if ( step ) {
					dummyOptions.step = function( t ) {
						step( t, currentValues );
					};
				}
				if ( complete ) {
					promise.then( function( t ) {
						complete( t, currentValues );
					} );
				}
				dummyOptions.complete = fulfilPromise;
				dummy = animate( this, null, null, dummyOptions );
				animations.push( dummy );
				promise.stop = function() {
					var animation;
					while ( animation = animations.pop() ) {
						animation.stop();
					}
					if ( dummy ) {
						dummy.stop();
					}
				};
				return promise;
			}
			// animate a single keypath
			options = options || {};
			if ( options.complete ) {
				promise.then( options.complete );
			}
			options.complete = fulfilPromise;
			animation = animate( this, keypath, to, options );
			promise.stop = function() {
				animation.stop();
			};
			return promise;
		};

		function animate( root, keypath, to, options ) {
			var easing, duration, animation, from;
			if ( keypath ) {
				keypath = normaliseKeypath( keypath );
			}
			if ( keypath !== null ) {
				from = root.viewmodel.get( keypath );
			}
			// cancel any existing animation
			// TODO what about upstream/downstream keypaths?
			animations.abort( keypath, root );
			// don't bother animating values that stay the same
			if ( isEqual( from, to ) ) {
				if ( options.complete ) {
					options.complete( options.to );
				}
				return noAnimation;
			}
			// easing function
			if ( options.easing ) {
				if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = root.easing[ options.easing ];
				}
				if ( typeof easing !== 'function' ) {
					easing = null;
				}
			}
			// duration
			duration = options.duration === undefined ? 400 : options.duration;
			// TODO store keys, use an internal set method
			animation = new Animation( {
				keypath: keypath,
				from: from,
				to: to,
				root: root,
				duration: duration,
				easing: easing,
				interpolator: options.interpolator,
				// TODO wrap callbacks if necessary, to use instance as context
				step: options.step,
				complete: options.complete
			} );
			animations.add( animation );
			root._animations.push( animation );
			return animation;
		}
		return __export;
	}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

	/* Ractive/prototype/detach.js */
	var Ractive$detach = function( Hook, removeFromArray ) {

		var detachHook = new Hook( 'detach' );
		return function Ractive$detach() {
			if ( this.detached ) {
				return this.detached;
			}
			if ( this.el ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.detached = this.fragment.detach();
			detachHook.fire( this );
			return this.detached;
		};
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* Ractive/prototype/find.js */
	var Ractive$find = function Ractive$find( selector ) {
		if ( !this.el ) {
			return null;
		}
		return this.fragment.find( selector );
	};

	/* utils/matches.js */
	var matches = function( isClient, vendors, createElement ) {

		var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
		if ( !isClient ) {
			matches = null;
		} else {
			div = createElement( 'div' );
			methodNames = [
				'matches',
				'matchesSelector'
			];
			makeFunction = function( methodName ) {
				return function( node, selector ) {
					return node[ methodName ]( selector );
				};
			};
			i = methodNames.length;
			while ( i-- && !matches ) {
				unprefixed = methodNames[ i ];
				if ( div[ unprefixed ] ) {
					matches = makeFunction( unprefixed );
				} else {
					j = vendors.length;
					while ( j-- ) {
						prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
						if ( div[ prefixed ] ) {
							matches = makeFunction( prefixed );
							break;
						}
					}
				}
			}
			// IE8...
			if ( !matches ) {
				matches = function( node, selector ) {
					var nodes, parentNode, i;
					parentNode = node.parentNode;
					if ( !parentNode ) {
						// empty dummy <div>
						div.innerHTML = '';
						parentNode = div;
						node = node.cloneNode();
						div.appendChild( node );
					}
					nodes = parentNode.querySelectorAll( selector );
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] === node ) {
							return true;
						}
					}
					return false;
				};
			}
		}
		return matches;
	}( isClient, vendors, createElement );

	/* Ractive/prototype/shared/makeQuery/test.js */
	var Ractive$shared_makeQuery_test = function( matches ) {

		return function( item, noDirty ) {
			var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
			if ( itemMatches ) {
				this.push( item.node || item.instance );
				if ( !noDirty ) {
					this._makeDirty();
				}
				return true;
			}
		};
	}( matches );

	/* Ractive/prototype/shared/makeQuery/cancel.js */
	var Ractive$shared_makeQuery_cancel = function() {
		var liveQueries, selector, index;
		liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
		selector = this.selector;
		index = liveQueries.indexOf( selector );
		if ( index !== -1 ) {
			liveQueries.splice( index, 1 );
			liveQueries[ selector ] = null;
		}
	};

	/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
	var Ractive$shared_makeQuery_sortByItemPosition = function() {

		var __export;
		__export = function( a, b ) {
			var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
			ancestryA = getAncestry( a.component || a._ractive.proxy );
			ancestryB = getAncestry( b.component || b._ractive.proxy );
			oldestA = ancestryA[ ancestryA.length - 1 ];
			oldestB = ancestryB[ ancestryB.length - 1 ];
			// remove items from the end of both ancestries as long as they are identical
			// - the final one removed is the closest mutual ancestor
			while ( oldestA && oldestA === oldestB ) {
				ancestryA.pop();
				ancestryB.pop();
				mutualAncestor = oldestA;
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
			}
			// now that we have the mutual ancestor, we can find which is earliest
			oldestA = oldestA.component || oldestA;
			oldestB = oldestB.component || oldestB;
			fragmentA = oldestA.parentFragment;
			fragmentB = oldestB.parentFragment;
			// if both items share a parent fragment, our job is easy
			if ( fragmentA === fragmentB ) {
				indexA = fragmentA.items.indexOf( oldestA );
				indexB = fragmentB.items.indexOf( oldestB );
				// if it's the same index, it means one contains the other,
				// so we see which has the longest ancestry
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			// if mutual ancestor is a section, we first test to see which section
			// fragment comes first
			if ( fragments = mutualAncestor.fragments ) {
				indexA = fragments.indexOf( fragmentA );
				indexB = fragments.indexOf( fragmentB );
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
		};

		function getParent( item ) {
			var parentFragment;
			if ( parentFragment = item.parentFragment ) {
				return parentFragment.owner;
			}
			if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
				return parentFragment.owner;
			}
		}

		function getAncestry( item ) {
			var ancestry, ancestor;
			ancestry = [ item ];
			ancestor = getParent( item );
			while ( ancestor ) {
				ancestry.push( ancestor );
				ancestor = getParent( ancestor );
			}
			return ancestry;
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
	var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

		return function( node, otherNode ) {
			var bitmask;
			if ( node.compareDocumentPosition ) {
				bitmask = node.compareDocumentPosition( otherNode );
				return bitmask & 2 ? 1 : -1;
			}
			// In old IE, we can piggy back on the mechanism for
			// comparing component positions
			return sortByItemPosition( node, otherNode );
		};
	}( Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/sort.js */
	var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

		return function() {
			this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
			this._dirty = false;
		};
	}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/dirty.js */
	var Ractive$shared_makeQuery_dirty = function( runloop ) {

		return function() {
			var this$0 = this;
			if ( !this._dirty ) {
				this._dirty = true;
				// Once the DOM has been updated, ensure the query
				// is correctly ordered
				runloop.scheduleTask( function() {
					this$0._sort();
				} );
			}
		};
	}( runloop );

	/* Ractive/prototype/shared/makeQuery/remove.js */
	var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
		var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
		if ( index !== -1 ) {
			this.splice( index, 1 );
		}
	};

	/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
	var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

		return function makeQuery( ractive, selector, live, isComponentQuery ) {
			var query = [];
			defineProperties( query, {
				selector: {
					value: selector
				},
				live: {
					value: live
				},
				_isComponentQuery: {
					value: isComponentQuery
				},
				_test: {
					value: test
				}
			} );
			if ( !live ) {
				return query;
			}
			defineProperties( query, {
				cancel: {
					value: cancel
				},
				_root: {
					value: ractive
				},
				_sort: {
					value: sort
				},
				_makeDirty: {
					value: dirty
				},
				_remove: {
					value: remove
				},
				_dirty: {
					value: false,
					writable: true
				}
			} );
			return query;
		};
	}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

	/* Ractive/prototype/findAll.js */
	var Ractive$findAll = function( makeQuery ) {

		return function Ractive$findAll( selector, options ) {
			var liveQueries, query;
			if ( !this.el ) {
				return [];
			}
			options = options || {};
			liveQueries = this._liveQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, false );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAll( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findAllComponents.js */
	var Ractive$findAllComponents = function( makeQuery ) {

		return function Ractive$findAllComponents( selector, options ) {
			var liveQueries, query;
			options = options || {};
			liveQueries = this._liveComponentQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, true );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAllComponents( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findComponent.js */
	var Ractive$findComponent = function Ractive$findComponent( selector ) {
		return this.fragment.findComponent( selector );
	};

	/* utils/getPotentialWildcardMatches.js */
	var getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, i, result, wildcardKeypath;
			keys = keypath.split( '.' );
			if ( !( starMap = starMaps[ keys.length ] ) ) {
				starMap = getStarMap( keys.length );
			}
			result = [];
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			i = starMap.length;
			while ( i-- ) {
				wildcardKeypath = starMap[ i ].map( mapper ).join( '.' );
				if ( !result.hasOwnProperty( wildcardKeypath ) ) {
					result.push( wildcardKeypath );
					result[ wildcardKeypath ] = true;
				}
			}
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( num ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ num ] ) {
				starMap = [];
				while ( ones.length < num ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < num ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ num ] = starMap;
			}
			return starMaps[ num ];
		}
		return __export;
	}();

	/* Ractive/prototype/shared/fireEvent.js */
	var Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {

		var __export;
		__export = function fireEvent( ractive, eventName ) {
			var options = arguments[ 2 ];
			if ( options === void 0 )
				options = {};
			if ( !eventName ) {
				return;
			}
			if ( !options.event ) {
				options.event = {
					name: eventName,
					context: ractive.data,
					keypath: '',
					// until event not included as argument default
					_noArg: true
				};
			} else {
				options.event.name = eventName;
			}
			var eventNames = getPotentialWildcardMatches( eventName );
			fireEventAs( ractive, eventNames, options.event, options.args, true );
		};

		function fireEventAs( ractive, eventNames, event, args ) {
			var initialFire = arguments[ 4 ];
			if ( initialFire === void 0 )
				initialFire = false;
			var subscribers, i, bubble = true;
			if ( event ) {
				ractive.event = event;
			}
			for ( i = eventNames.length; i >= 0; i-- ) {
				subscribers = ractive._subs[ eventNames[ i ] ];
				if ( subscribers ) {
					bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
				}
			}
			if ( event ) {
				delete ractive.event;
			}
			if ( ractive._parent && bubble ) {
				if ( initialFire && ractive.component ) {
					var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];
					eventNames = getPotentialWildcardMatches( fullName );
					if ( event ) {
						event.component = ractive;
					}
				}
				fireEventAs( ractive._parent, eventNames, event, args );
			}
		}

		function notifySubscribers( ractive, subscribers, event, args ) {
			var originalEvent = null,
				stopEvent = false;
			if ( event && !event._noArg ) {
				args = [ event ].concat( args );
			}
			for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
				if ( subscribers[ i ].apply( ractive, args ) === false ) {
					stopEvent = true;
				}
			}
			if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
				originalEvent.preventDefault && originalEvent.preventDefault();
				originalEvent.stopPropagation && originalEvent.stopPropagation();
			}
			return !stopEvent;
		}
		return __export;
	}( getPotentialWildcardMatches );

	/* Ractive/prototype/fire.js */
	var Ractive$fire = function( fireEvent ) {

		return function Ractive$fire( eventName ) {
			var options = {
				args: Array.prototype.slice.call( arguments, 1 )
			};
			fireEvent( this, eventName, options );
		};
	}( Ractive$shared_fireEvent );

	/* Ractive/prototype/get.js */
	var Ractive$get = function( normaliseKeypath, resolveRef ) {

		var options = {
			capture: true
		};
		// top-level calls should be intercepted
		return function Ractive$get( keypath ) {
			var value;
			keypath = normaliseKeypath( keypath );
			value = this.viewmodel.get( keypath, options );
			// Create inter-component binding, if necessary
			if ( value === undefined && this._parent && !this.isolated ) {
				if ( resolveRef( this, keypath, this.fragment ) ) {
					// creates binding as side-effect, if appropriate
					value = this.viewmodel.get( keypath );
				}
			}
			return value;
		};
	}( normaliseKeypath, resolveRef );

	/* utils/getElement.js */
	var getElement = function getElement( input ) {
		var output;
		if ( !input || typeof input === 'boolean' ) {
			return;
		}
		if ( typeof window === 'undefined' || !document || !input ) {
			return null;
		}
		// We already have a DOM node - no work to do. (Duck typing alert!)
		if ( input.nodeType ) {
			return input;
		}
		// Get node from string
		if ( typeof input === 'string' ) {
			// try ID first
			output = document.getElementById( input );
			// then as selector, if possible
			if ( !output && document.querySelector ) {
				output = document.querySelector( input );
			}
			// did it work?
			if ( output && output.nodeType ) {
				return output;
			}
		}
		// If we've been given a collection (jQuery, Zepto etc), extract the first item
		if ( input[ 0 ] && input[ 0 ].nodeType ) {
			return input[ 0 ];
		}
		return null;
	};

	/* Ractive/prototype/insert.js */
	var Ractive$insert = function( Hook, getElement ) {

		var __export;
		var insertHook = new Hook( 'insert' );
		__export = function Ractive$insert( target, anchor ) {
			if ( !this.fragment.rendered ) {
				// TODO create, and link to, documentation explaining this
				throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
			}
			target = getElement( target );
			anchor = getElement( anchor ) || null;
			if ( !target ) {
				throw new Error( 'You must specify a valid target to insert into' );
			}
			target.insertBefore( this.detach(), anchor );
			this.el = target;
			( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
			this.detached = null;
			fireInsertHook( this );
		};

		function fireInsertHook( ractive ) {
			insertHook.fire( ractive );
			ractive.findAllComponents( '*' ).forEach( function( child ) {
				fireInsertHook( child.instance );
			} );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, getElement );

	/* Ractive/prototype/merge.js */
	var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

		return function Ractive$merge( keypath, array, options ) {
			var currentArray, promise;
			keypath = normaliseKeypath( keypath );
			currentArray = this.viewmodel.get( keypath );
			// If either the existing value or the new value isn't an
			// array, just do a regular set
			if ( !isArray( currentArray ) || !isArray( array ) ) {
				return this.set( keypath, array, options && options.complete );
			}
			// Manage transitions
			promise = runloop.start( this, true );
			this.viewmodel.merge( keypath, currentArray, array, options );
			runloop.end();
			// attach callback as fulfilment handler, if specified
			if ( options && options.complete ) {
				promise.then( options.complete );
			}
			return promise;
		};
	}( runloop, isArray, normaliseKeypath );

	/* Ractive/prototype/observe/Observer.js */
	var Ractive$observe_Observer = function( runloop, isEqual ) {

		var Observer = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.keypath = keypath;
			this.callback = callback;
			this.defer = options.defer;
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		Observer.prototype = {
			init: function( immediate ) {
				this.value = this.root.get( this.keypath );
				if ( immediate !== false ) {
					this.update();
				} else {
					this.oldValue = this.value;
				}
			},
			setValue: function( value ) {
				var this$0 = this;
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.update();
						} );
					} else {
						this.update();
					}
				}
			},
			update: function() {
				// Prevent infinite loops
				if ( this.updating ) {
					return;
				}
				this.updating = true;
				this.callback.call( this.context, this.value, this.oldValue, this.keypath );
				this.oldValue = this.value;
				this.updating = false;
			}
		};
		return Observer;
	}( runloop, isEqual );

	/* shared/getMatchingKeypaths.js */
	var getMatchingKeypaths = function( isArray ) {

		return function getMatchingKeypaths( ractive, pattern ) {
			var keys, key, matchingKeypaths;
			keys = pattern.split( '.' );
			matchingKeypaths = [ '' ];
			while ( key = keys.shift() ) {
				if ( key === '*' ) {
					// expand to find all valid child keypaths
					matchingKeypaths = matchingKeypaths.reduce( expand, [] );
				} else {
					if ( matchingKeypaths[ 0 ] === '' ) {
						// first key
						matchingKeypaths[ 0 ] = key;
					} else {
						matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
					}
				}
			}
			return matchingKeypaths;

			function expand( matchingKeypaths, keypath ) {
				var value, key, childKeypath;
				value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
				for ( key in value ) {
					if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
						// for benefit of IE8
						childKeypath = keypath ? keypath + '.' + key : key;
						matchingKeypaths.push( childKeypath );
					}
				}
				return matchingKeypaths;
			}

			function concatenate( key ) {
				return function( keypath ) {
					return keypath ? keypath + '.' + key : key;
				};
			}
		};
	}( isArray );

	/* Ractive/prototype/observe/getPattern.js */
	var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

		return function getPattern( ractive, pattern ) {
			var matchingKeypaths, values;
			matchingKeypaths = getMatchingKeypaths( ractive, pattern );
			values = {};
			matchingKeypaths.forEach( function( keypath ) {
				values[ keypath ] = ractive.get( keypath );
			} );
			return values;
		};
	}( getMatchingKeypaths );

	/* Ractive/prototype/observe/PatternObserver.js */
	var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

		var PatternObserver, wildcard = /\*/,
			slice = Array.prototype.slice;
		PatternObserver = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.callback = callback;
			this.defer = options.defer;
			this.keypath = keypath;
			this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
			this.values = {};
			if ( this.defer ) {
				this.proxies = [];
			}
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		PatternObserver.prototype = {
			init: function( immediate ) {
				var values, keypath;
				values = getPattern( this.root, this.keypath );
				if ( immediate !== false ) {
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
				} else {
					this.values = values;
				}
			},
			update: function( keypath ) {
				var this$0 = this;
				var values;
				if ( wildcard.test( keypath ) ) {
					values = getPattern( this.root, keypath );
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
					return;
				}
				// special case - array mutation should not trigger `array.*`
				// pattern observer with `array.length`
				if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
					return;
				}
				if ( this.defer && this.ready ) {
					runloop.scheduleTask( function() {
						return this$0.getProxy( keypath ).update();
					} );
					return;
				}
				this.reallyUpdate( keypath );
			},
			reallyUpdate: function( keypath ) {
				var value, keys, args;
				value = this.root.viewmodel.get( keypath );
				// Prevent infinite loops
				if ( this.updating ) {
					this.values[ keypath ] = value;
					return;
				}
				this.updating = true;
				if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
					keys = slice.call( this.regex.exec( keypath ), 1 );
					args = [
						value,
						this.values[ keypath ],
						keypath
					].concat( keys );
					this.callback.apply( this.context, args );
					this.values[ keypath ] = value;
				}
				this.updating = false;
			},
			getProxy: function( keypath ) {
				var self = this;
				if ( !this.proxies[ keypath ] ) {
					this.proxies[ keypath ] = {
						update: function() {
							self.reallyUpdate( keypath );
						}
					};
				}
				return this.proxies[ keypath ];
			}
		};
		return PatternObserver;
	}( runloop, isEqual, Ractive$observe_getPattern );

	/* Ractive/prototype/observe/getObserverFacade.js */
	var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

		var wildcard = /\*/,
			emptyObject = {};
		return function getObserverFacade( ractive, keypath, callback, options ) {
			var observer, isPatternObserver, cancelled;
			keypath = normaliseKeypath( keypath );
			options = options || emptyObject;
			// pattern observers are treated differently
			if ( wildcard.test( keypath ) ) {
				observer = new PatternObserver( ractive, keypath, callback, options );
				ractive.viewmodel.patternObservers.push( observer );
				isPatternObserver = true;
			} else {
				observer = new Observer( ractive, keypath, callback, options );
			}
			ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
			observer.init( options.init );
			// This flag allows observers to initialise even with undefined values
			observer.ready = true;
			return {
				cancel: function() {
					var index;
					if ( cancelled ) {
						return;
					}
					if ( isPatternObserver ) {
						index = ractive.viewmodel.patternObservers.indexOf( observer );
						ractive.viewmodel.patternObservers.splice( index, 1 );
						ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
					} else {
						ractive.viewmodel.unregister( keypath, observer, 'observers' );
					}
					cancelled = true;
				}
			};
		};
	}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

	/* Ractive/prototype/observe.js */
	var Ractive$observe = function( isObject, getObserverFacade ) {

		return function Ractive$observe( keypath, callback, options ) {
			var observers, map, keypaths, i;
			// Allow a map of keypaths to handlers
			if ( isObject( keypath ) ) {
				options = callback;
				map = keypath;
				observers = [];
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						callback = map[ keypath ];
						observers.push( this.observe( keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			}
			// Allow `ractive.observe( callback )` - i.e. observe entire model
			if ( typeof keypath === 'function' ) {
				options = callback;
				callback = keypath;
				keypath = '';
				return getObserverFacade( this, keypath, callback, options );
			}
			keypaths = keypath.split( ' ' );
			// Single keypath
			if ( keypaths.length === 1 ) {
				return getObserverFacade( this, keypath, callback, options );
			}
			// Multiple space-separated keypaths
			observers = [];
			i = keypaths.length;
			while ( i-- ) {
				keypath = keypaths[ i ];
				if ( keypath ) {
					observers.push( getObserverFacade( this, keypath, callback, options ) );
				}
			}
			return {
				cancel: function() {
					while ( observers.length ) {
						observers.pop().cancel();
					}
				}
			};
		};
	}( isObject, Ractive$observe_getObserverFacade );

	/* Ractive/prototype/shared/trim.js */
	var Ractive$shared_trim = function( str ) {
		return str.trim();
	};

	/* Ractive/prototype/shared/notEmptyString.js */
	var Ractive$shared_notEmptyString = function( str ) {
		return str !== '';
	};

	/* Ractive/prototype/off.js */
	var Ractive$off = function( trim, notEmptyString ) {

		return function Ractive$off( eventName, callback ) {
			var this$0 = this;
			var eventNames;
			// if no arguments specified, remove all callbacks
			if ( !eventName ) {
				// TODO use this code instead, once the following issue has been resolved
				// in PhantomJS (tests are unpassable otherwise!)
				// https://github.com/ariya/phantomjs/issues/11856
				// defineProperty( this, '_subs', { value: create( null ), configurable: true });
				for ( eventName in this._subs ) {
					delete this._subs[ eventName ];
				}
			} else {
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					var subscribers, index;
					// If we have subscribers for this event...
					if ( subscribers = this$0._subs[ eventName ] ) {
						// ...if a callback was specified, only remove that
						if ( callback ) {
							index = subscribers.indexOf( callback );
							if ( index !== -1 ) {
								subscribers.splice( index, 1 );
							}
						} else {
							this$0._subs[ eventName ] = [];
						}
					}
				} );
			}
			return this;
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* Ractive/prototype/on.js */
	var Ractive$on = function( trim, notEmptyString ) {

		return function Ractive$on( eventName, callback ) {
			var this$0 = this;
			var self = this,
				listeners, n, eventNames;
			// allow mutliple listeners to be bound in one go
			if ( typeof eventName === 'object' ) {
				listeners = [];
				for ( n in eventName ) {
					if ( eventName.hasOwnProperty( n ) ) {
						listeners.push( this.on( n, eventName[ n ] ) );
					}
				}
				return {
					cancel: function() {
						var listener;
						while ( listener = listeners.pop() ) {
							listener.cancel();
						}
					}
				};
			}
			// Handle multiple space-separated event names
			eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
			eventNames.forEach( function( eventName ) {
				( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
			} );
			return {
				cancel: function() {
					self.off( eventName, callback );
				}
			};
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* shared/getNewIndices.js */
	var getNewIndices = function() {

		var __export;
		// This function takes an array, the name of a mutator method, and the
		// arguments to call that mutator method with, and returns an array that
		// maps the old indices to their new indices.
		// So if you had something like this...
		//
		//     array = [ 'a', 'b', 'c', 'd' ];
		//     array.push( 'e' );
		//
		// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
		// have changed. If you then did this...
		//
		//     array.unshift( 'z' );
		//
		// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
		// one higher to make room for the 'z'. If you removed an item, the new index
		// would be -1...
		//
		//     array.splice( 2, 2 );
		//
		// ...this would result in [ 0, 1, -1, -1, 2, 3 ].
		//
		// This information is used to enable fast, non-destructive shuffling of list
		// sections when you do e.g. `ractive.splice( 'items', 2, 2 );
		__export = function getNewIndices( array, methodName, args ) {
			var spliceArguments, len, newIndices = [],
				removeStart, removeEnd, balance, i;
			spliceArguments = getSpliceEquivalent( array, methodName, args );
			if ( !spliceArguments ) {
				return null;
			}
			len = array.length;
			balance = spliceArguments.length - 2 - spliceArguments[ 1 ];
			removeStart = Math.min( len, spliceArguments[ 0 ] );
			removeEnd = removeStart + spliceArguments[ 1 ];
			for ( i = 0; i < removeStart; i += 1 ) {
				newIndices.push( i );
			}
			for ( ; i < removeEnd; i += 1 ) {
				newIndices.push( -1 );
			}
			for ( ; i < len; i += 1 ) {
				newIndices.push( i + balance );
			}
			return newIndices;
		};
		// The pop, push, shift an unshift methods can all be represented
		// as an equivalent splice
		function getSpliceEquivalent( array, methodName, args ) {
			switch ( methodName ) {
				case 'splice':
					if ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {
						args[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );
					}
					while ( args.length < 2 ) {
						args.push( 0 );
					}
					// ensure we only remove elements that exist
					args[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );
					return args;
				case 'sort':
				case 'reverse':
					return null;
				case 'pop':
					if ( array.length ) {
						return [
							array.length - 1,
							1
						];
					}
					return null;
				case 'push':
					return [
						array.length,
						0
					].concat( args );
				case 'shift':
					return [
						0,
						1
					];
				case 'unshift':
					return [
						0,
						0
					].concat( args );
			}
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeArrayMethod.js */
	var Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {

		var arrayProto = Array.prototype;
		return function( methodName ) {
			return function( keypath ) {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 1 );
				var array, newIndices = [],
					len, promise, result;
				array = this.get( keypath );
				len = array.length;
				if ( !isArray( array ) ) {
					throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
				}
				newIndices = getNewIndices( array, methodName, args );
				result = arrayProto[ methodName ].apply( array, args );
				promise = runloop.start( this, true ).then( function() {
					return result;
				} );
				if ( !!newIndices ) {
					this.viewmodel.smartUpdate( keypath, array, newIndices );
				} else {
					this.viewmodel.mark( keypath );
				}
				runloop.end();
				return promise;
			};
		};
	}( isArray, runloop, getNewIndices );

	/* Ractive/prototype/pop.js */
	var Ractive$pop = function( makeArrayMethod ) {

		return makeArrayMethod( 'pop' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/push.js */
	var Ractive$push = function( makeArrayMethod ) {

		return makeArrayMethod( 'push' );
	}( Ractive$shared_makeArrayMethod );

	/* global/css.js */
	var global_css = function( circular, isClient, removeFromArray ) {

		var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
			componentsInPage = {},
			styles = [];
		if ( !isClient ) {
			css = null;
		} else {
			circular.push( function() {
				runloop = circular.runloop;
			} );
			styleElement = document.createElement( 'style' );
			styleElement.type = 'text/css';
			head = document.getElementsByTagName( 'head' )[ 0 ];
			inDom = false;
			// Internet Exploder won't let you use styleSheet.innerHTML - we have to
			// use styleSheet.cssText instead
			styleSheet = styleElement.styleSheet;
			update = function() {
				var css;
				if ( styles.length ) {
					css = prefix + styles.join( ' ' );
					if ( styleSheet ) {
						styleSheet.cssText = css;
					} else {
						styleElement.innerHTML = css;
					}
					if ( !inDom ) {
						head.appendChild( styleElement );
						inDom = true;
					}
				} else if ( inDom ) {
					head.removeChild( styleElement );
					inDom = false;
				}
			};
			css = {
				add: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					if ( !componentsInPage[ Component._guid ] ) {
						// we create this counter so that we can in/decrement it as
						// instances are added and removed. When all components are
						// removed, the style is too
						componentsInPage[ Component._guid ] = 0;
						styles.push( Component.css );
						update();
					}
					componentsInPage[ Component._guid ] += 1;
				},
				remove: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					componentsInPage[ Component._guid ] -= 1;
					if ( !componentsInPage[ Component._guid ] ) {
						removeFromArray( styles, Component.css );
						runloop.scheduleTask( update );
					}
				}
			};
		}
		return css;
	}( circular, isClient, removeFromArray );

	/* Ractive/prototype/render.js */
	var Ractive$render = function( css, Hook, getElement, runloop ) {

		var renderHook = new Hook( 'render' ),
			completeHook = new Hook( 'complete' );
		return function Ractive$render( target, anchor ) {
			var this$0 = this;
			var promise, instances, transitionsEnabled;
			// if `noIntro` is `true`, temporarily disable transitions
			transitionsEnabled = this.transitionsEnabled;
			if ( this.noIntro ) {
				this.transitionsEnabled = false;
			}
			promise = runloop.start( this, true );
			runloop.scheduleTask( function() {
				return renderHook.fire( this$0 );
			}, true );
			if ( this.fragment.rendered ) {
				throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
			}
			target = getElement( target ) || this.el;
			anchor = getElement( anchor ) || this.anchor;
			this.el = target;
			this.anchor = anchor;
			// Add CSS, if applicable
			if ( this.constructor.css ) {
				css.add( this.constructor );
			}
			if ( target ) {
				if ( !( instances = target.__ractive_instances__ ) ) {
					target.__ractive_instances__ = [ this ];
				} else {
					instances.push( this );
				}
				if ( anchor ) {
					target.insertBefore( this.fragment.render(), anchor );
				} else {
					target.appendChild( this.fragment.render() );
				}
			}
			runloop.end();
			this.transitionsEnabled = transitionsEnabled;
			// It is now more problematic to know if the complete hook
			// would fire. Method checking is straight-forward, but would
			// also require preflighting event subscriptions. Which seems
			// like more work then just letting the promise happen.
			// But perhaps I'm wrong about that...
			promise.then( function() {
				return completeHook.fire( this$0 );
			} );
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );

	/* virtualdom/Fragment/prototype/bubble.js */
	var virtualdom_Fragment$bubble = function Fragment$bubble() {
		this.dirtyValue = this.dirtyArgs = true;
		if ( this.bound && typeof this.owner.bubble === 'function' ) {
			this.owner.bubble();
		}
	};

	/* virtualdom/Fragment/prototype/detach.js */
	var virtualdom_Fragment$detach = function Fragment$detach() {
		var docFrag;
		if ( this.items.length === 1 ) {
			return this.items[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.items.forEach( function( item ) {
			var node = item.detach();
			// TODO The if {...} wasn't previously required - it is now, because we're
			// forcibly detaching everything to reorder sections after an update. That's
			// a non-ideal brute force approach, implemented to get all the tests to pass
			// - as soon as it's replaced with something more elegant, this should
			// revert to `docFrag.appendChild( item.detach() )`
			if ( node ) {
				docFrag.appendChild( node );
			}
		} );
		return docFrag;
	};

	/* virtualdom/Fragment/prototype/find.js */
	var virtualdom_Fragment$find = function Fragment$find( selector ) {
		var i, len, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.find && ( queryResult = item.find( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findAll.js */
	var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAll ) {
					item.findAll( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findAllComponents.js */
	var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAllComponents ) {
					item.findAllComponents( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findComponent.js */
	var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
		var len, i, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findNextNode.js */
	var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
		var index = item.index,
			node;
		if ( this.items[ index + 1 ] ) {
			node = this.items[ index + 1 ].firstNode();
		} else if ( this.owner === this.root ) {
			if ( !this.owner.component ) {
				// TODO but something else could have been appended to
				// this.root.el, no?
				node = null;
			} else {
				node = this.owner.component.findNextNode();
			}
		} else {
			node = this.owner.findNextNode( this );
		}
		return node;
	};

	/* virtualdom/Fragment/prototype/firstNode.js */
	var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
		if ( this.items && this.items[ 0 ] ) {
			return this.items[ 0 ].firstNode();
		}
		return null;
	};

	/* virtualdom/Fragment/prototype/getNode.js */
	var virtualdom_Fragment$getNode = function Fragment$getNode() {
		var fragment = this;
		do {
			if ( fragment.pElement ) {
				return fragment.pElement.node;
			}
		} while ( fragment = fragment.parent );
		return this.root.detached || this.root.el;
	};

	/* virtualdom/Fragment/prototype/getValue.js */
	var virtualdom_Fragment$getValue = function( parseJSON ) {

		var __export;
		var empty = {};
		__export = function Fragment$getValue() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = empty;
			var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
			asArgs = options.args;
			cachedResult = asArgs ? 'argsList' : 'value';
			dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
			if ( this[ dirtyFlag ] ) {
				source = processItems( this.items, values = {}, this.root._guid );
				parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
				if ( !parsed ) {
					result = asArgs ? [ this.toString() ] : this.toString();
				} else {
					result = parsed.value;
				}
				this[ cachedResult ] = result;
				this[ dirtyFlag ] = false;
			}
			return this[ cachedResult ];
		};

		function processItems( items, values, guid, counter ) {
			counter = counter || 0;
			return items.map( function( item ) {
				var placeholderId, wrapped, value;
				if ( item.text ) {
					return item.text;
				}
				if ( item.fragments ) {
					return item.fragments.map( function( fragment ) {
						return processItems( fragment.items, values, guid, counter );
					} ).join( '' );
				}
				placeholderId = guid + '-' + counter++;
				if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
					value = wrapped.value;
				} else {
					value = item.getValue();
				}
				values[ placeholderId ] = value;
				return '${' + placeholderId + '}';
			} ).join( '' );
		}
		return __export;
	}( parseJSON );

	/* utils/escapeHtml.js */
	var escapeHtml = function() {

		var lessThan = /</g;
		var greaterThan = />/g;
		var amp = /&/g;
		return function escapeHtml( str ) {
			return str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
		};
	}();

	/* utils/detachNode.js */
	var detachNode = function detachNode( node ) {
		if ( node && node.parentNode ) {
			node.parentNode.removeChild( node );
		}
		return node;
	};

	/* virtualdom/items/shared/detach.js */
	var detach = function( detachNode ) {

		return function() {
			return detachNode( this.node );
		};
	}( detachNode );

	/* virtualdom/items/Text.js */
	var Text = function( types, escapeHtml, detach ) {

		var Text = function( options ) {
			this.type = types.TEXT;
			this.text = options.template;
		};
		Text.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.text );
				}
				return this.node;
			},
			toString: function( escape ) {
				return escape ? escapeHtml( this.text ) : this.text;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					return this.detach();
				}
			}
		};
		return Text;
	}( types, escapeHtml, detach );

	/* virtualdom/items/shared/unbind.js */
	var unbind = function unbind() {
		if ( this.registered ) {
			// this was registered as a dependant
			this.root.viewmodel.unregister( this.keypath, this );
		}
		if ( this.resolver ) {
			this.resolver.unbind();
		}
	};

	/* virtualdom/items/shared/Mustache/getValue.js */
	var getValue = function Mustache$getValue() {
		return this.value;
	};

	/* virtualdom/items/shared/utils/startsWithKeypath.js */
	var startsWithKeypath = function startsWithKeypath( target, keypath ) {
		return target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';
	};

	/* virtualdom/items/shared/utils/getNewKeypath.js */
	var getNewKeypath = function( startsWithKeypath ) {

		return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
			// exact match
			if ( targetKeypath === oldKeypath ) {
				return newKeypath !== undefined ? newKeypath : null;
			}
			// partial match based on leading keypath segments
			if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
				return newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
			}
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */
	var ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {

		var ReferenceResolver = function( owner, ref, callback ) {
			var keypath;
			this.ref = ref;
			this.resolved = false;
			this.root = owner.root;
			this.parentFragment = owner.parentFragment;
			this.callback = callback;
			keypath = resolveRef( owner.root, ref, owner.parentFragment );
			if ( keypath !== undefined ) {
				this.resolve( keypath );
			} else {
				runloop.addUnresolved( this );
			}
		};
		ReferenceResolver.prototype = {
			resolve: function( keypath ) {
				this.resolved = true;
				this.keypath = keypath;
				this.callback( keypath );
			},
			forceResolution: function() {
				this.resolve( this.ref );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var keypath;
				if ( this.keypath !== undefined ) {
					keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );
					// was a new keypath created?
					if ( keypath !== undefined ) {
						// resolve it
						this.resolve( keypath );
					}
				}
			},
			unbind: function() {
				if ( !this.resolved ) {
					runloop.removeUnresolved( this );
				}
			}
		};
		return ReferenceResolver;
	}( runloop, resolveRef, getNewKeypath );

	/* virtualdom/items/shared/Resolvers/SpecialResolver.js */
	var SpecialResolver = function() {

		var SpecialResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		SpecialResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					fragment = this.parentFragment;
				if ( ref === '@keypath' ) {
					while ( fragment ) {
						if ( !!fragment.context ) {
							return this.callback( '@' + fragment.context );
						}
						fragment = fragment.parent;
					}
				}
				if ( ref === '@index' || ref === '@key' ) {
					while ( fragment ) {
						if ( fragment.index !== undefined ) {
							return this.callback( '@' + fragment.index );
						}
						fragment = fragment.parent;
					}
				}
				throw new Error( 'Unknown special reference "' + ref + '" - valid references are @index, @key and @keypath' );
			},
			unbind: function() {}
		};
		return SpecialResolver;
	}();

	/* virtualdom/items/shared/Resolvers/IndexResolver.js */
	var IndexResolver = function() {

		var IndexResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		IndexResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					indexRefs = this.parentFragment.indexRefs,
					index = indexRefs[ ref ];
				if ( index !== undefined ) {
					this.callback( '@' + index );
				}
			},
			unbind: function() {}
		};
		return IndexResolver;
	}();

	/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */
	var createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {

		return function createReferenceResolver( owner, ref, callback ) {
			var indexRefs, index;
			if ( ref.charAt( 0 ) === '@' ) {
				return new SpecialResolver( owner, ref, callback );
			}
			indexRefs = owner.parentFragment.indexRefs;
			if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
				return new IndexResolver( owner, ref, callback );
			}
			return new ReferenceResolver( owner, ref, callback );
		};
	}( ReferenceResolver, SpecialResolver, IndexResolver );

	/* shared/getFunctionFromString.js */
	var getFunctionFromString = function() {

		var cache = {};
		return function getFunctionFromString( str, i ) {
			var fn, args;
			if ( cache[ str ] ) {
				return cache[ str ];
			}
			args = [];
			while ( i-- ) {
				args[ i ] = '_' + i;
			}
			fn = new Function( args.join( ',' ), 'return(' + str + ')' );
			cache[ str ] = fn;
			return fn;
		};
	}();

	/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
	var ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {

		var __export;
		var ExpressionResolver, bind = Function.prototype.bind;
		ExpressionResolver = function( owner, parentFragment, expression, callback ) {
			var resolver = this,
				ractive, indexRefs;
			ractive = owner.root;
			resolver.root = ractive;
			resolver.parentFragment = parentFragment;
			resolver.callback = callback;
			resolver.owner = owner;
			resolver.str = expression.s;
			resolver.keypaths = [];
			indexRefs = parentFragment.indexRefs;
			// Create resolvers for each reference
			resolver.pending = expression.r.length;
			resolver.refResolvers = expression.r.map( function( ref, i ) {
				return createReferenceResolver( resolver, ref, function( keypath ) {
					resolver.resolve( i, keypath );
				} );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ExpressionResolver.prototype = {
			bubble: function() {
				if ( !this.ready ) {
					return;
				}
				this.uniqueString = getUniqueString( this.str, this.keypaths );
				this.keypath = getKeypath( this.uniqueString );
				this.createEvaluator();
				this.callback( this.keypath );
			},
			unbind: function() {
				var resolver;
				while ( resolver = this.refResolvers.pop() ) {
					resolver.unbind();
				}
			},
			resolve: function( index, keypath ) {
				this.keypaths[ index ] = keypath;
				this.bubble();
			},
			createEvaluator: function() {
				var this$0 = this;
				var self = this,
					computation, valueGetters, signature, keypath, fn;
				computation = this.root.viewmodel.computations[ this.keypath ];
				// only if it doesn't exist yet!
				if ( !computation ) {
					fn = getFunctionFromString( this.str, this.refResolvers.length );
					valueGetters = this.keypaths.map( function( keypath ) {
						var value;
						if ( keypath === 'undefined' ) {
							return function() {
								return undefined;
							};
						}
						// 'special' keypaths encode a value
						if ( keypath[ 0 ] === '@' ) {
							value = keypath.slice( 1 );
							return isNumeric( value ) ? function() {
								return +value;
							} : function() {
								return value;
							};
						}
						return function() {
							var value = this$0.root.viewmodel.get( keypath );
							if ( typeof value === 'function' ) {
								value = wrapFunction( value, self.root );
							}
							return value;
						};
					} );
					signature = {
						deps: this.keypaths.filter( isValidDependency ),
						get: function() {
							var args = valueGetters.map( call );
							return fn.apply( null, args );
						}
					};
					computation = this.root.viewmodel.compute( this.keypath, signature );
				} else {
					this.root.viewmodel.mark( this.keypath );
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				// TODO only bubble once, no matter how many references are affected by the rebind
				this.refResolvers.forEach( function( r ) {
					return r.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
		};
		__export = ExpressionResolver;

		function call( value ) {
			return value.call();
		}

		function getUniqueString( str, keypaths ) {
			// get string that is unique to this expression
			return str.replace( /_([0-9]+)/g, function( match, $1 ) {
				var keypath, value;
				keypath = keypaths[ $1 ];
				if ( keypath === undefined ) {
					return 'undefined';
				}
				if ( keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					return isNumeric( value ) ? value : '"' + value + '"';
				}
				return keypath;
			} );
		}

		function getKeypath( uniqueString ) {
			// Sanitize by removing any periods or square brackets. Otherwise
			// we can't split the keypath into keys!
			return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
		}

		function isValidDependency( keypath ) {
			return keypath !== undefined && keypath[ 0 ] !== '@';
		}

		function wrapFunction( fn, ractive ) {
			var wrapped, prop, key;
			if ( fn._noWrap ) {
				return fn;
			}
			prop = '__ractive_' + ractive._guid;
			wrapped = fn[ prop ];
			if ( wrapped ) {
				return wrapped;
			} else if ( /this/.test( fn.toString() ) ) {
				defineProperty( fn, prop, {
					value: bind.call( fn, ractive )
				} );
				// Add properties/methods to wrapped function
				for ( key in fn ) {
					if ( fn.hasOwnProperty( key ) ) {
						fn[ prop ][ key ] = fn[ key ];
					}
				}
				return fn[ prop ];
			}
			defineProperty( fn, '__ractive_nowrap', {
				value: fn
			} );
			return fn.__ractive_nowrap;
		}
		return __export;
	}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
	var MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {

		var MemberResolver = function( template, resolver, parentFragment ) {
			var member = this,
				keypath;
			member.resolver = resolver;
			member.root = resolver.root;
			member.parentFragment = parentFragment;
			member.viewmodel = resolver.root.viewmodel;
			if ( typeof template === 'string' ) {
				member.value = template;
			} else if ( template.t === types.REFERENCE ) {
				member.refResolver = createReferenceResolver( this, template.n, function( keypath ) {
					member.resolve( keypath );
				} );
			} else {
				new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
					member.resolve( keypath );
				} );
			}
		};
		MemberResolver.prototype = {
			resolve: function( keypath ) {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				this.keypath = keypath;
				this.value = this.viewmodel.get( keypath );
				this.bind();
				this.resolver.bubble();
			},
			bind: function() {
				this.viewmodel.register( this.keypath, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.refResolver ) {
					this.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			setValue: function( value ) {
				this.value = value;
				this.resolver.bubble();
			},
			unbind: function() {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				if ( this.unresolved ) {
					this.unresolved.unbind();
				}
			},
			forceResolution: function() {
				if ( this.refResolver ) {
					this.refResolver.forceResolution();
				}
			}
		};
		return MemberResolver;
	}( types, createReferenceResolver, ExpressionResolver );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
	var ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {

		var ReferenceExpressionResolver = function( mustache, template, callback ) {
			var this$0 = this;
			var resolver = this,
				ractive, ref, keypath, parentFragment;
			resolver.parentFragment = parentFragment = mustache.parentFragment;
			resolver.root = ractive = mustache.root;
			resolver.mustache = mustache;
			resolver.ref = ref = template.r;
			resolver.callback = callback;
			resolver.unresolved = [];
			// Find base keypath
			if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
				resolver.base = keypath;
			} else {
				resolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {
					resolver.base = keypath;
					resolver.baseResolver = null;
					resolver.bubble();
				} );
			}
			// Find values for members, or mark them as unresolved
			resolver.members = template.m.map( function( template ) {
				return new MemberResolver( template, this$0, parentFragment );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ReferenceExpressionResolver.prototype = {
			getKeypath: function() {
				var values = this.members.map( getValue );
				if ( !values.every( isDefined ) || this.baseResolver ) {
					return null;
				}
				return this.base + '.' + values.join( '.' );
			},
			bubble: function() {
				if ( !this.ready || this.baseResolver ) {
					return;
				}
				this.callback( this.getKeypath() );
			},
			unbind: function() {
				this.members.forEach( unbind );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.members.forEach( function( members ) {
					if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			},
			forceResolution: function() {
				if ( this.baseResolver ) {
					this.base = this.ref;
					this.baseResolver.unbind();
					this.baseResolver = null;
				}
				this.members.forEach( function( m ) {
					return m.forceResolution();
				} );
				this.bubble();
			}
		};

		function getValue( member ) {
			return member.value;
		}

		function isDefined( value ) {
			return value != undefined;
		}

		function unbind( member ) {
			member.unbind();
		}
		return ReferenceExpressionResolver;
	}( resolveRef, ReferenceResolver, MemberResolver );

	/* virtualdom/items/shared/Mustache/initialise.js */
	var initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {

		return function Mustache$init( mustache, options ) {
			var ref, parentFragment, template;
			parentFragment = options.parentFragment;
			template = options.template;
			mustache.root = parentFragment.root;
			mustache.parentFragment = parentFragment;
			mustache.pElement = parentFragment.pElement;
			mustache.template = options.template;
			mustache.index = options.index || 0;
			mustache.isStatic = options.template.s;
			mustache.type = options.template.t;
			mustache.registered = false;
			// if this is a simple mustache, with a reference, we just need to resolve
			// the reference to a keypath
			if ( ref = template.r ) {
				mustache.resolver = new createReferenceResolver( mustache, ref, resolve );
			}
			// if it's an expression, we have a bit more work to do
			if ( options.template.x ) {
				mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
			}
			if ( options.template.rx ) {
				mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
			}
			// Special case - inverted sections
			if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
				mustache.setValue( undefined );
			}

			function resolve( keypath ) {
				mustache.resolve( keypath );
			}

			function resolveAndRebindChildren( newKeypath ) {
				var oldKeypath = mustache.keypath;
				if ( newKeypath !== oldKeypath ) {
					mustache.resolve( newKeypath );
					if ( oldKeypath !== undefined ) {
						mustache.fragments && mustache.fragments.forEach( function( f ) {
							f.rebind( null, null, oldKeypath, newKeypath );
						} );
					}
				}
			}
		};
	}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );

	/* virtualdom/items/shared/Mustache/resolve.js */
	var resolve = function( isNumeric ) {

		return function Mustache$resolve( keypath ) {
			var wasResolved, value, twowayBinding;
			// 'Special' keypaths, e.g. @foo or @7, encode a value
			if ( keypath && keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				if ( isNumeric( value ) ) {
					value = +value;
				}
				this.keypath = keypath;
				this.setValue( value );
				return;
			}
			// If we resolved previously, we need to unregister
			if ( this.registered ) {
				// undefined or null
				this.root.viewmodel.unregister( this.keypath, this );
				this.registered = false;
				wasResolved = true;
			}
			this.keypath = keypath;
			// If the new keypath exists, we need to register
			// with the viewmodel
			if ( keypath != undefined ) {
				// undefined or null
				value = this.root.viewmodel.get( keypath );
				this.root.viewmodel.register( keypath, this );
				this.registered = true;
			}
			// Either way we need to queue up a render (`value`
			// will be `undefined` if there's no keypath)
			this.setValue( value );
			// Two-way bindings need to point to their new target keypath
			if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
				twowayBinding.rebound();
			}
		};
	}( isNumeric );

	/* virtualdom/items/shared/Mustache/rebind.js */
	var rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		// Children first
		if ( this.fragments ) {
			this.fragments.forEach( function( f ) {
				return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			} );
		}
		// Expression mustache?
		if ( this.resolver ) {
			this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/shared/Mustache/_Mustache.js */
	var Mustache = function( getValue, init, resolve, rebind ) {

		return {
			getValue: getValue,
			init: init,
			resolve: resolve,
			rebind: rebind
		};
	}( getValue, initialise, resolve, rebind );

	/* virtualdom/items/Interpolator.js */
	var Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {

		var Interpolator = function( options ) {
			this.type = types.INTERPOLATOR;
			Mustache.init( this, options );
		};
		Interpolator.prototype = {
			update: function() {
				this.node.data = this.value == undefined ? '' : this.value;
			},
			resolve: Mustache.resolve,
			rebind: Mustache.rebind,
			detach: detach,
			unbind: unbind,
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.value != undefined ? this.value : '' );
				}
				return this.node;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					detachNode( this.node );
				}
			},
			getValue: Mustache.getValue,
			// TEMP
			setValue: function( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.node ) {
						runloop.addView( this );
					}
				}
			},
			firstNode: function() {
				return this.node;
			},
			toString: function( escape ) {
				var string = this.value != undefined ? '' + this.value : '';
				return escape ? escapeHtml( string ) : string;
			}
		};
		return Interpolator;
	}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );

	/* virtualdom/items/Section/prototype/bubble.js */
	var virtualdom_items_Section$bubble = function Section$bubble() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Section/prototype/detach.js */
	var virtualdom_items_Section$detach = function Section$detach() {
		var docFrag;
		if ( this.fragments.length === 1 ) {
			return this.fragments[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.fragments.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/find.js */
	var virtualdom_items_Section$find = function Section$find( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].find( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findAll.js */
	var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAll( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findAllComponents.js */
	var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findComponent.js */
	var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findNextNode.js */
	var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
		if ( this.fragments[ fragment.index + 1 ] ) {
			return this.fragments[ fragment.index + 1 ].firstNode();
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/firstNode.js */
	var virtualdom_items_Section$firstNode = function Section$firstNode() {
		var len, i, node;
		if ( len = this.fragments.length ) {
			for ( i = 0; i < len; i += 1 ) {
				if ( node = this.fragments[ i ].firstNode() ) {
					return node;
				}
			}
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/shuffle.js */
	var virtualdom_items_Section$shuffle = function( types, runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$shuffle( newIndices ) {
			var this$0 = this;
			var section = this,
				parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;
			// short circuit any double-updates, and ensure that this isn't applied to
			// non-list sections
			if ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {
				return;
			}
			this.shuffling = true;
			runloop.scheduleTask( function() {
				return this$0.shuffling = false;
			} );
			parentFragment = this.parentFragment;
			reboundFragments = [];
			// first, rebind existing fragments
			newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
				var fragment, by, oldKeypath, newKeypath;
				if ( newIndex === oldIndex ) {
					reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
					return;
				}
				fragment = section.fragments[ oldIndex ];
				if ( firstChange === undefined ) {
					firstChange = oldIndex;
				}
				// does this fragment need to be torn down?
				if ( newIndex === -1 ) {
					section.fragmentsToUnrender.push( fragment );
					fragment.unbind();
					return;
				}
				// Otherwise, it needs to be rebound to a new index
				by = newIndex - oldIndex;
				oldKeypath = section.keypath + '.' + oldIndex;
				newKeypath = section.keypath + '.' + newIndex;
				fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
				fragment.index = newIndex;
				reboundFragments[ newIndex ] = fragment;
			} );
			newLength = this.root.get( this.keypath ).length;
			// If nothing changed with the existing fragments, then we start adding
			// new fragments at the end...
			if ( firstChange === undefined ) {
				// ...unless there are no new fragments to add
				if ( this.length === newLength ) {
					return;
				}
				firstChange = this.length;
			}
			this.length = this.fragments.length = newLength;
			if ( this.rendered ) {
				runloop.addView( this );
			}
			// Prepare new fragment options
			fragmentOptions = {
				template: this.template.f,
				root: this.root,
				owner: this
			};
			if ( this.template.i ) {
				fragmentOptions.indexRef = this.template.i;
			}
			// Add as many new fragments as we need to, or add back existing
			// (detached) fragments
			for ( i = firstChange; i < newLength; i += 1 ) {
				fragment = reboundFragments[ i ];
				if ( !fragment ) {
					this.fragmentsToCreate.push( i );
				}
				this.fragments[ i ] = fragment;
			}
		};
	}( types, runloop, circular );

	/* virtualdom/items/Section/prototype/render.js */
	var virtualdom_items_Section$render = function Section$render() {
		var docFrag;
		docFrag = this.docFrag = document.createDocumentFragment();
		this.update();
		this.rendered = true;
		return docFrag;
	};

	/* utils/isArrayLike.js */
	var isArrayLike = function() {

		var pattern = /^\[object (?:Array|FileList)\]$/,
			toString = Object.prototype.toString;
		return function isArrayLike( obj ) {
			return pattern.test( toString.call( obj ) );
		};
	}();

	/* virtualdom/items/Section/prototype/setValue.js */
	var virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function Section$setValue( value ) {
			var this$0 = this;
			var wrapper, fragmentOptions;
			if ( this.updating ) {
				// If a child of this section causes a re-evaluation - for example, an
				// expression refers to a function that mutates the array that this
				// section depends on - we'll end up with a double rendering bug (see
				// https://github.com/ractivejs/ractive/issues/748). This prevents it.
				return;
			}
			this.updating = true;
			// with sections, we need to get the fake value if we have a wrapped object
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			// If any fragments are awaiting creation after a splice,
			// this is the place to do it
			if ( this.fragmentsToCreate.length ) {
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					pElement: this.pElement,
					owner: this,
					indexRef: this.template.i
				};
				this.fragmentsToCreate.forEach( function( index ) {
					var fragment;
					fragmentOptions.context = this$0.keypath + '.' + index;
					fragmentOptions.index = index;
					fragment = new Fragment( fragmentOptions );
					this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
				} );
				this.fragmentsToCreate.length = 0;
			} else if ( reevaluateSection( this, value ) ) {
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
			this.value = value;
			this.updating = false;
		};

		function reevaluateSection( section, value ) {
			var fragmentOptions = {
				template: section.template.f,
				root: section.root,
				pElement: section.parentFragment.pElement,
				owner: section
			};
			// If we already know the section type, great
			// TODO can this be optimised? i.e. pick an reevaluateSection function during init
			// and avoid doing this each time?
			if ( section.subtype ) {
				switch ( section.subtype ) {
					case types.SECTION_IF:
						return reevaluateConditionalSection( section, value, false, fragmentOptions );
					case types.SECTION_UNLESS:
						return reevaluateConditionalSection( section, value, true, fragmentOptions );
					case types.SECTION_WITH:
						return reevaluateContextSection( section, fragmentOptions );
					case types.SECTION_IF_WITH:
						return reevaluateConditionalContextSection( section, value, fragmentOptions );
					case types.SECTION_EACH:
						if ( isObject( value ) ) {
							return reevaluateListObjectSection( section, value, fragmentOptions );
						}
				}
			}
			// Otherwise we need to work out what sort of section we're dealing with
			section.ordered = !!isArrayLike( value );
			// Ordered list section
			if ( section.ordered ) {
				return reevaluateListSection( section, value, fragmentOptions );
			}
			// Unordered list, or context
			if ( isObject( value ) || typeof value === 'function' ) {
				// Index reference indicates section should be treated as a list
				if ( section.template.i ) {
					return reevaluateListObjectSection( section, value, fragmentOptions );
				}
				// Otherwise, object provides context for contents
				return reevaluateContextSection( section, fragmentOptions );
			}
			// Conditional section
			return reevaluateConditionalSection( section, value, false, fragmentOptions );
		}

		function reevaluateListSection( section, value, fragmentOptions ) {
			var i, length, fragment;
			length = value.length;
			if ( length === section.length ) {
				// Nothing to do
				return false;
			}
			// if the array is shorter than it was previously, remove items
			if ( length < section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
				section.fragmentsToUnrender.forEach( unbind );
			} else {
				if ( length > section.length ) {
					// add any new ones
					for ( i = section.length; i < length; i += 1 ) {
						// append list item to context stack
						fragmentOptions.context = section.keypath + '.' + i;
						fragmentOptions.index = i;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ i ] = fragment );
					}
				}
			}
			section.length = length;
			return true;
		}

		function reevaluateListObjectSection( section, value, fragmentOptions ) {
			var id, i, hasKey, fragment, changed;
			hasKey = section.hasKey || ( section.hasKey = {} );
			// remove any fragments that should no longer exist
			i = section.fragments.length;
			while ( i-- ) {
				fragment = section.fragments[ i ];
				if ( !( fragment.index in value ) ) {
					changed = true;
					fragment.unbind();
					section.fragmentsToUnrender.push( fragment );
					section.fragments.splice( i, 1 );
					hasKey[ fragment.index ] = false;
				}
			}
			// add any that haven't been created yet
			for ( id in value ) {
				if ( !hasKey[ id ] ) {
					changed = true;
					fragmentOptions.context = section.keypath + '.' + id;
					fragmentOptions.index = id;
					if ( section.template.i ) {
						fragmentOptions.indexRef = section.template.i;
					}
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( fragment );
					section.fragments.push( fragment );
					hasKey[ id ] = true;
				}
			}
			section.length = section.fragments.length;
			return changed;
		}

		function reevaluateConditionalContextSection( section, value, fragmentOptions ) {
			if ( value ) {
				return reevaluateContextSection( section, fragmentOptions );
			} else {
				return removeSectionFragments( section );
			}
		}

		function reevaluateContextSection( section, fragmentOptions ) {
			var fragment;
			// ...then if it isn't rendered, render it, adding section.keypath to the context stack
			// (if it is already rendered, then any children dependent on the context stack
			// will update themselves without any prompting)
			if ( !section.length ) {
				// append this section to the context stack
				fragmentOptions.context = section.keypath;
				fragmentOptions.index = 0;
				fragment = new Fragment( fragmentOptions );
				section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
				section.length = 1;
				return true;
			}
		}

		function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
			var doRender, emptyArray, emptyObject, fragment, name;
			emptyArray = isArrayLike( value ) && value.length === 0;
			emptyObject = false;
			if ( !isArrayLike( value ) && isObject( value ) ) {
				emptyObject = true;
				for ( name in value ) {
					emptyObject = false;
					break;
				}
			}
			if ( inverted ) {
				doRender = emptyArray || emptyObject || !value;
			} else {
				doRender = value && !emptyArray && !emptyObject;
			}
			if ( doRender ) {
				if ( !section.length ) {
					// no change to context stack
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
				if ( section.length > 1 ) {
					section.fragmentsToUnrender = section.fragments.splice( 1 );
					section.fragmentsToUnrender.forEach( unbind );
					return true;
				}
			} else {
				return removeSectionFragments( section );
			}
		}

		function removeSectionFragments( section ) {
			if ( section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );
				section.fragmentsToUnrender.forEach( unbind );
				section.length = section.fragmentsToRender.length = 0;
				return true;
			}
		}

		function unbind( fragment ) {
			fragment.unbind();
		}

		function isRendered( fragment ) {
			return fragment.rendered;
		}
		return __export;
	}( types, isArrayLike, isObject, runloop, circular );

	/* virtualdom/items/Section/prototype/toString.js */
	var virtualdom_items_Section$toString = function Section$toString( escape ) {
		var str, i, len;
		str = '';
		i = 0;
		len = this.length;
		for ( i = 0; i < len; i += 1 ) {
			str += this.fragments[ i ].toString( escape );
		}
		return str;
	};

	/* virtualdom/items/Section/prototype/unbind.js */
	var virtualdom_items_Section$unbind = function( unbind ) {

		var __export;
		__export = function Section$unbind() {
			this.fragments.forEach( unbindFragment );
			unbind.call( this );
			this.length = 0;
			this.unbound = true;
		};

		function unbindFragment( fragment ) {
			fragment.unbind();
		}
		return __export;
	}( unbind );

	/* virtualdom/items/Section/prototype/unrender.js */
	var virtualdom_items_Section$unrender = function() {

		var __export;
		__export = function Section$unrender( shouldDestroy ) {
			this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
		};

		function unrenderAndDestroy( fragment ) {
			fragment.unrender( true );
		}

		function unrender( fragment ) {
			fragment.unrender( false );
		}
		return __export;
	}();

	/* virtualdom/items/Section/prototype/update.js */
	var virtualdom_items_Section$update = function Section$update() {
		var fragment, renderIndex, renderedFragments, anchor, target, i, len;
		// `this.renderedFragments` is in the order of the previous render.
		// If fragments have shuffled about, this allows us to quickly
		// reinsert them in the correct place
		renderedFragments = this.renderedFragments;
		// Remove fragments that have been marked for destruction
		while ( fragment = this.fragmentsToUnrender.pop() ) {
			fragment.unrender( true );
			renderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );
		}
		// Render new fragments (but don't insert them yet)
		while ( fragment = this.fragmentsToRender.shift() ) {
			fragment.render();
		}
		if ( this.rendered ) {
			target = this.parentFragment.getNode();
		}
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			fragment = this.fragments[ i ];
			renderIndex = renderedFragments.indexOf( fragment, i );
			// search from current index - it's guaranteed to be the same or higher
			if ( renderIndex === i ) {
				// already in the right place. insert accumulated nodes (if any) and carry on
				if ( this.docFrag.childNodes.length ) {
					anchor = fragment.firstNode();
					target.insertBefore( this.docFrag, anchor );
				}
				continue;
			}
			this.docFrag.appendChild( fragment.detach() );
			// update renderedFragments
			if ( renderIndex !== -1 ) {
				renderedFragments.splice( renderIndex, 1 );
			}
			renderedFragments.splice( i, 0, fragment );
		}
		if ( this.rendered && this.docFrag.childNodes.length ) {
			anchor = this.parentFragment.findNextNode( this );
			target.insertBefore( this.docFrag, anchor );
		}
		// Save the rendering order for next time
		this.renderedFragments = this.fragments.slice();
	};

	/* virtualdom/items/Section/_Section.js */
	var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {

		var Section = function( options ) {
			this.type = types.SECTION;
			this.subtype = options.template.n;
			this.inverted = this.subtype === types.SECTION_UNLESS;
			this.pElement = options.pElement;
			this.fragments = [];
			this.fragmentsToCreate = [];
			this.fragmentsToRender = [];
			this.fragmentsToUnrender = [];
			this.renderedFragments = [];
			this.length = 0;
			// number of times this section is rendered
			Mustache.init( this, options );
		};
		Section.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			shuffle: shuffle,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Section;
	}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

	/* virtualdom/items/Triple/prototype/detach.js */
	var virtualdom_items_Triple$detach = function Triple$detach() {
		var len, i;
		if ( this.docFrag ) {
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				this.docFrag.appendChild( this.nodes[ i ] );
			}
			return this.docFrag;
		}
	};

	/* virtualdom/items/Triple/prototype/find.js */
	var virtualdom_items_Triple$find = function( matches ) {

		return function Triple$find( selector ) {
			var i, len, node, queryResult;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					return node;
				}
				if ( queryResult = node.querySelector( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/findAll.js */
	var virtualdom_items_Triple$findAll = function( matches ) {

		return function Triple$findAll( selector, queryResult ) {
			var i, len, node, queryAllResult, numNodes, j;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					queryResult.push( node );
				}
				if ( queryAllResult = node.querySelectorAll( selector ) ) {
					numNodes = queryAllResult.length;
					for ( j = 0; j < numNodes; j += 1 ) {
						queryResult.push( queryAllResult[ j ] );
					}
				}
			}
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/firstNode.js */
	var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
		if ( this.rendered && this.nodes[ 0 ] ) {
			return this.nodes[ 0 ];
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Triple/helpers/insertHtml.js */
	var insertHtml = function( namespaces, createElement ) {

		var __export;
		var elementCache = {},
			ieBug, ieBlacklist;
		try {
			createElement( 'table' ).innerHTML = 'foo';
		} catch ( err ) {
			ieBug = true;
			ieBlacklist = {
				TABLE: [
					'<table class="x">',
					'</table>'
				],
				THEAD: [
					'<table><thead class="x">',
					'</thead></table>'
				],
				TBODY: [
					'<table><tbody class="x">',
					'</tbody></table>'
				],
				TR: [
					'<table><tr class="x">',
					'</tr></table>'
				],
				SELECT: [
					'<select class="x">',
					'</select>'
				]
			};
		}
		__export = function( html, node, docFrag ) {
			var container, nodes = [],
				wrapper, selectedOption, child, i;
			// render 0 and false
			if ( html != null && html !== '' ) {
				if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
					container = element( 'DIV' );
					container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
					container = container.querySelector( '.x' );
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				} else if ( node.namespaceURI === namespaces.svg ) {
					container = element( 'DIV' );
					container.innerHTML = '<svg class="x">' + html + '</svg>';
					container = container.querySelector( '.x' );
				} else {
					container = element( node.tagName );
					container.innerHTML = html;
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				}
				while ( child = container.firstChild ) {
					nodes.push( child );
					docFrag.appendChild( child );
				}
				// This is really annoying. Extracting <option> nodes from the
				// temporary container <select> causes the remaining ones to
				// become selected. So now we have to deselect them. IE8, you
				// amaze me. You really do
				// ...and now Chrome too
				if ( node.tagName === 'SELECT' ) {
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] !== selectedOption ) {
							nodes[ i ].selected = false;
						}
					}
				}
			}
			return nodes;
		};

		function element( tagName ) {
			return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
		}
		return __export;
	}( namespaces, createElement );

	/* utils/toArray.js */
	var toArray = function toArray( arrayLike ) {
		var array = [],
			i = arrayLike.length;
		while ( i-- ) {
			array[ i ] = arrayLike[ i ];
		}
		return array;
	};

	/* virtualdom/items/Triple/helpers/updateSelect.js */
	var updateSelect = function( toArray ) {

		var __export;
		__export = function updateSelect( parentElement ) {
			var selectedOptions, option, value;
			if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
				return;
			}
			selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
			// If one of them had a `selected` attribute, we need to sync
			// the model to the view
			if ( parentElement.getAttribute( 'multiple' ) ) {
				value = selectedOptions.map( function( o ) {
					return o.value;
				} );
			} else if ( option = selectedOptions[ 0 ] ) {
				value = option.value;
			}
			if ( value !== undefined ) {
				parentElement.binding.setValue( value );
			}
			parentElement.bubble();
		};

		function isSelected( option ) {
			return option.selected;
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Triple/prototype/render.js */
	var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

		return function Triple$render() {
			if ( this.rendered ) {
				throw new Error( 'Attempted to render an item that was already rendered' );
			}
			this.docFrag = document.createDocumentFragment();
			this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
			this.rendered = true;
			return this.docFrag;
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/prototype/setValue.js */
	var virtualdom_items_Triple$setValue = function( runloop ) {

		return function Triple$setValue( value ) {
			var wrapper;
			// TODO is there a better way to approach this?
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			if ( value !== this.value ) {
				this.value = value;
				this.parentFragment.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Triple/prototype/toString.js */
	var virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {

		return function Triple$toString() {
			return this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';
		};
	}( decodeCharacterReferences );

	/* virtualdom/items/Triple/prototype/unrender.js */
	var virtualdom_items_Triple$unrender = function( detachNode ) {

		return function Triple$unrender( shouldDestroy ) {
			if ( this.rendered && shouldDestroy ) {
				this.nodes.forEach( detachNode );
				this.rendered = false;
			}
		};
	}( detachNode );

	/* virtualdom/items/Triple/prototype/update.js */
	var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

		return function Triple$update() {
			var node, parentNode;
			if ( !this.rendered ) {
				return;
			}
			// Remove existing nodes
			while ( this.nodes && this.nodes.length ) {
				node = this.nodes.pop();
				node.parentNode.removeChild( node );
			}
			// Insert new nodes
			parentNode = this.parentFragment.getNode();
			this.nodes = insertHtml( this.value, parentNode, this.docFrag );
			parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/_Triple.js */
	var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

		var Triple = function( options ) {
			this.type = types.TRIPLE;
			Mustache.init( this, options );
		};
		Triple.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Triple;
	}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

	/* virtualdom/items/Element/prototype/bubble.js */
	var virtualdom_items_Element$bubble = function() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Element/prototype/detach.js */
	var virtualdom_items_Element$detach = function Element$detach() {
		var node = this.node,
			parentNode;
		if ( node ) {
			// need to check for parent node - DOM may have been altered
			// by something other than Ractive! e.g. jQuery UI...
			if ( parentNode = node.parentNode ) {
				parentNode.removeChild( node );
			}
			return node;
		}
	};

	/* virtualdom/items/Element/prototype/find.js */
	var virtualdom_items_Element$find = function( matches ) {

		return function( selector ) {
			if ( matches( this.node, selector ) ) {
				return this.node;
			}
			if ( this.fragment && this.fragment.find ) {
				return this.fragment.find( selector );
			}
		};
	}( matches );

	/* virtualdom/items/Element/prototype/findAll.js */
	var virtualdom_items_Element$findAll = function( selector, query ) {
		// Add this node to the query, if applicable, and register the
		// query on this element
		if ( query._test( this, true ) && query.live ) {
			( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
		}
		if ( this.fragment ) {
			this.fragment.findAll( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findAllComponents.js */
	var virtualdom_items_Element$findAllComponents = function( selector, query ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findComponent.js */
	var virtualdom_items_Element$findComponent = function( selector ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( selector );
		}
	};

	/* virtualdom/items/Element/prototype/findNextNode.js */
	var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
		return null;
	};

	/* virtualdom/items/Element/prototype/firstNode.js */
	var virtualdom_items_Element$firstNode = function Element$firstNode() {
		return this.node;
	};

	/* virtualdom/items/Element/prototype/getAttribute.js */
	var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
		if ( !this.attributes || !this.attributes[ name ] ) {
			return;
		}
		return this.attributes[ name ].value;
	};

	/* virtualdom/items/Element/shared/enforceCase.js */
	var enforceCase = function() {

		var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
		svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
		svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
		createMap = function( items ) {
			var map = {},
				i = items.length;
			while ( i-- ) {
				map[ items[ i ].toLowerCase() ] = items[ i ];
			}
			return map;
		};
		map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
		return function( elementName ) {
			var lowerCaseElementName = elementName.toLowerCase();
			return map[ lowerCaseElementName ] || lowerCaseElementName;
		};
	}();

	/* virtualdom/items/Element/Attribute/prototype/bubble.js */
	var virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {

		return function Attribute$bubble() {
			var value = this.fragment.getValue();
			// TODO this can register the attribute multiple times (see render test
			// 'Attribute with nested mustaches')
			if ( !isEqual( value, this.value ) ) {
				// Need to clear old id from ractive.nodes
				if ( this.name === 'id' && this.value ) {
					delete this.root.nodes[ this.value ];
				}
				this.value = value;
				if ( this.name === 'value' && this.node ) {
					// We need to store the value on the DOM like this so we
					// can retrieve it later without it being coerced to a string
					this.node._ractive.value = value;
				}
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop, isEqual );

	/* config/booleanAttributes.js */
	var booleanAttributes = function() {

		// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
		var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
		return booleanAttributes;
	}();

	/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
	var determineNameAndNamespace = function( namespaces, enforceCase ) {

		return function( attribute, name ) {
			var colonIndex, namespacePrefix;
			// are we dealing with a namespaced attribute, e.g. xlink:href?
			colonIndex = name.indexOf( ':' );
			if ( colonIndex !== -1 ) {
				// looks like we are, yes...
				namespacePrefix = name.substr( 0, colonIndex );
				// ...unless it's a namespace *declaration*, which we ignore (on the assumption
				// that only valid namespaces will be used)
				if ( namespacePrefix !== 'xmlns' ) {
					name = name.substring( colonIndex + 1 );
					attribute.name = enforceCase( name );
					attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
					attribute.namespacePrefix = namespacePrefix;
					if ( !attribute.namespace ) {
						throw 'Unknown namespace ("' + namespacePrefix + '")';
					}
					return;
				}
			}
			// SVG attribute names are case sensitive
			attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
		};
	}( namespaces, enforceCase );

	/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
	var getInterpolator = function( types ) {

		return function getInterpolator( attribute ) {
			var items = attribute.fragment.items;
			if ( items.length !== 1 ) {
				return;
			}
			if ( items[ 0 ].type === types.INTERPOLATOR ) {
				return items[ 0 ];
			}
		};
	}( types );

	/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
	var determinePropertyName = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			accesskey: 'accessKey',
			bgcolor: 'bgColor',
			'class': 'className',
			codebase: 'codeBase',
			colspan: 'colSpan',
			contenteditable: 'contentEditable',
			datetime: 'dateTime',
			dirname: 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			ismap: 'isMap',
			maxlength: 'maxLength',
			novalidate: 'noValidate',
			pubdate: 'pubDate',
			readonly: 'readOnly',
			rowspan: 'rowSpan',
			tabindex: 'tabIndex',
			usemap: 'useMap'
		};
		return function( attribute, options ) {
			var propertyName;
			if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
				propertyName = propertyNames[ attribute.name ] || attribute.name;
				if ( options.pNode[ propertyName ] !== undefined ) {
					attribute.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					attribute.useProperty = true;
				}
			}
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/init.js */
	var virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Attribute$init( options ) {
			this.type = types.ATTRIBUTE;
			this.element = options.element;
			this.root = options.root;
			determineNameAndNamespace( this, options.name );
			// if it's an empty attribute, or just a straight key-value pair, with no
			// mustache shenanigans, set the attribute accordingly and go home
			if ( !options.value || typeof options.value === 'string' ) {
				this.value = booleanAttributes.test( this.name ) ? true : options.value || '';
				return;
			}
			// otherwise we need to do some work
			// share parentFragment with parent element
			this.parentFragment = this.element.parentFragment;
			this.fragment = new Fragment( {
				template: options.value,
				root: this.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
			// Store a reference to this attribute's interpolator, if its fragment
			// takes the form `{{foo}}`. This is necessary for two-way binding and
			// for correctly rendering HTML later
			this.interpolator = getInterpolator( this );
			this.isBindable = !!this.interpolator && !this.interpolator.isStatic;
			// can we establish this attribute's property name equivalent?
			determinePropertyName( this, options );
			// mark as ready
			this.ready = true;
		};
	}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

	/* virtualdom/items/Element/Attribute/prototype/rebind.js */
	var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( this.fragment ) {
			this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/render.js */
	var virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			'accesskey': 'accessKey',
			'bgcolor': 'bgColor',
			'class': 'className',
			'codebase': 'codeBase',
			'colspan': 'colSpan',
			'contenteditable': 'contentEditable',
			'datetime': 'dateTime',
			'dirname': 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			'ismap': 'isMap',
			'maxlength': 'maxLength',
			'novalidate': 'noValidate',
			'pubdate': 'pubDate',
			'readonly': 'readOnly',
			'rowspan': 'rowSpan',
			'tabindex': 'tabIndex',
			'usemap': 'useMap'
		};
		return function Attribute$render( node ) {
			var propertyName;
			this.node = node;
			// should we use direct property access, or setAttribute?
			if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
				propertyName = propertyNames[ this.name ] || this.name;
				if ( node[ propertyName ] !== undefined ) {
					this.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					this.useProperty = true;
				}
				if ( propertyName === 'value' ) {
					this.useProperty = true;
					node._ractive.value = this.value;
				}
			}
			this.rendered = true;
			this.update();
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/toString.js */
	var virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {

		var __export;
		__export = function Attribute$toString() {
			var name = ( fragment = this ).name,
				namespacePrefix = fragment.namespacePrefix,
				value = fragment.value,
				interpolator = fragment.interpolator,
				fragment = fragment.fragment;
			// Special case - select and textarea values (should not be stringified)
			if ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {
				return;
			}
			// Special case - content editable
			if ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {
				return;
			}
			// Special case - radio names
			if ( name === 'name' && this.element.name === 'input' && interpolator ) {
				return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
			}
			// Boolean attributes
			if ( booleanAttributes.test( name ) ) {
				return value ? name : '';
			}
			if ( fragment ) {
				value = fragment.toString();
			}
			if ( namespacePrefix ) {
				name = namespacePrefix + ':' + name;
			}
			return value ? name + '="' + escape( value ) + '"' : name;
		};

		function escape( value ) {
			return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
		}
		return __export;
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/unbind.js */
	var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
		// ignore non-dynamic attributes
		if ( this.fragment ) {
			this.fragment.unbind();
		}
		if ( this.name === 'id' ) {
			delete this.root.nodes[ this.value ];
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
		var value = this.value,
			options, option, optionValue, i;
		if ( !this.locked ) {
			this.node._ractive.value = value;
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				if ( optionValue == value ) {
					// double equals as we may be comparing numbers with strings
					option.selected = true;
					break;
				}
			}
		}
	};

	/* utils/arrayContains.js */
	var arrayContains = function arrayContains( array, value ) {
		for ( var i = 0, c = array.length; i < c; i++ ) {
			if ( array[ i ] == value ) {
				return true;
			}
		}
		return false;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {

		return function Attribute$updateMultipleSelect() {
			var value = this.value,
				options, i, option, optionValue;
			if ( !isArray( value ) ) {
				value = [ value ];
			}
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				option.selected = arrayContains( value, optionValue );
			}
		};
	}( arrayContains, isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
	var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
		var node = ( value = this ).node,
			value = value.value;
		node.checked = value == node._ractive.value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
	var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

		return function Attribute$updateRadioValue() {
			var wasChecked, node = this.node,
				binding, bindings, i;
			wasChecked = node.checked;
			node.value = this.element.getAttribute( 'value' );
			node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
			// This is a special case - if the input was checked, and the value
			// changed so that it's no longer checked, the twoway binding is
			// most likely out of date. To fix it we have to jump through some
			// hoops... this is a little kludgy but it works
			if ( wasChecked && !node.checked && this.element.binding ) {
				bindings = this.element.binding.siblings;
				if ( i = bindings.length ) {
					while ( i-- ) {
						binding = bindings[ i ];
						if ( !binding.element.node ) {
							// this is the initial render, siblings are still rendering!
							// we'll come back later...
							return;
						}
						if ( binding.element.node.checked ) {
							runloop.addViewmodel( binding.root.viewmodel );
							return binding.handleChange();
						}
					}
					runloop.addViewmodel( binding.root.viewmodel );
					this.root.viewmodel.set( binding.keypath, undefined );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
	var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

		return function Attribute$updateCheckboxName() {
			var element = ( value = this ).element,
				node = value.node,
				value = value.value,
				valueAttribute, i;
			valueAttribute = element.getAttribute( 'value' );
			if ( !isArray( value ) ) {
				node.checked = value == valueAttribute;
			} else {
				i = value.length;
				while ( i-- ) {
					if ( valueAttribute == value[ i ] ) {
						node.checked = true;
						return;
					}
				}
				node.checked = false;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
	var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.className = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
		var node = ( value = this ).node,
			value = value.value;
		this.root.nodes[ value ] = node;
		node.id = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.style.setAttribute( 'cssText', value );
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
	var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
		var value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		if ( !this.locked ) {
			this.node.innerHTML = value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
	var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
		var node = ( value = this ).node,
			value = value.value;
		// store actual value, so it doesn't get coerced to a string
		node._ractive.value = value;
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			node.value = value == undefined ? '' : value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
	var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			this.node[ this.propertyName ] = this.value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
	var virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {

		return function Attribute$updateEverythingElse() {
			var node = ( fragment = this ).node,
				namespace = fragment.namespace,
				name = fragment.name,
				value = fragment.value,
				fragment = fragment.fragment;
			if ( namespace ) {
				node.setAttributeNS( namespace, name, ( fragment || value ).toString() );
			} else if ( !booleanAttributes.test( name ) ) {
				node.setAttribute( name, ( fragment || value ).toString() );
			} else {
				if ( value ) {
					node.setAttribute( name, '' );
				} else {
					node.removeAttribute( name );
				}
			}
		};
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/update.js */
	var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

		return function Attribute$update() {
			var name = ( node = this ).name,
				element = node.element,
				node = node.node,
				type, updateMethod;
			if ( name === 'id' ) {
				updateMethod = updateIdAttribute;
			} else if ( name === 'value' ) {
				// special case - selects
				if ( element.name === 'select' && name === 'value' ) {
					updateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
				} else if ( element.name === 'textarea' ) {
					updateMethod = updateValue;
				} else if ( element.getAttribute( 'contenteditable' ) != null ) {
					updateMethod = updateContentEditableValue;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					// type='file' value='{{fileList}}'>
					if ( type === 'file' ) {
						updateMethod = noop;
					} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
						updateMethod = updateRadioValue;
					} else {
						updateMethod = updateValue;
					}
				}
			} else if ( this.twoway && name === 'name' ) {
				if ( node.type === 'radio' ) {
					updateMethod = updateRadioName;
				} else if ( node.type === 'checkbox' ) {
					updateMethod = updateCheckboxName;
				}
			} else if ( name === 'style' && node.style.setAttribute ) {
				updateMethod = updateIEStyleAttribute;
			} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
				updateMethod = updateClassName;
			} else if ( this.useProperty ) {
				updateMethod = updateBoolean;
			}
			if ( !updateMethod ) {
				updateMethod = updateEverythingElse;
			}
			this.update = updateMethod;
			this.update();
		};
	}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

	/* virtualdom/items/Element/Attribute/_Attribute.js */
	var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

		var Attribute = function( options ) {
			this.init( options );
		};
		Attribute.prototype = {
			bubble: bubble,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			update: update
		};
		return Attribute;
	}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

	/* virtualdom/items/Element/prototype/init/createAttributes.js */
	var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

		return function( element, attributes ) {
			var name, attribute, result = [];
			for ( name in attributes ) {
				if ( attributes.hasOwnProperty( name ) ) {
					attribute = new Attribute( {
						element: element,
						name: name,
						value: attributes[ name ],
						root: element.root
					} );
					result.push( result[ name ] = attribute );
				}
			}
			return result;
		};
	}( Attribute );

	/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */
	var ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {

		var __export;
		var Fragment, div;
		if ( typeof document !== 'undefined' ) {
			div = createElement( 'div' );
		}
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var ConditionalAttribute = function( element, template ) {
			this.element = element;
			this.root = element.root;
			this.parentFragment = element.parentFragment;
			this.attributes = [];
			this.fragment = new Fragment( {
				root: element.root,
				owner: this,
				template: [ template ]
			} );
		};
		ConditionalAttribute.prototype = {
			bubble: function() {
				if ( this.node ) {
					this.update();
				}
				this.element.bubble();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function( node ) {
				this.node = node;
				this.isSvg = node.namespaceURI === namespaces.svg;
				this.update();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			update: function() {
				var this$0 = this;
				var str, attrs;
				str = this.fragment.toString();
				attrs = parseAttributes( str, this.isSvg );
				// any attributes that previously existed but no longer do
				// must be removed
				this.attributes.filter( function( a ) {
					return notIn( attrs, a );
				} ).forEach( function( a ) {
					this$0.node.removeAttribute( a.name );
				} );
				attrs.forEach( function( a ) {
					this$0.node.setAttribute( a.name, a.value );
				} );
				this.attributes = attrs;
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		__export = ConditionalAttribute;

		function parseAttributes( str, isSvg ) {
			var tag = isSvg ? 'svg' : 'div';
			div.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';
			return toArray( div.childNodes[ 0 ].attributes );
		}

		function notIn( haystack, needle ) {
			var i = haystack.length;
			while ( i-- ) {
				if ( haystack[ i ].name === needle.name ) {
					return false;
				}
			}
			return true;
		}
		return __export;
	}( circular, namespaces, createElement, toArray );

	/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */
	var virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {

		return function( element, attributes ) {
			if ( !attributes ) {
				return [];
			}
			return attributes.map( function( a ) {
				return new ConditionalAttribute( element, a );
			} );
		};
	}( ConditionalAttribute );

	/* utils/extend.js */
	var extend = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		var prop, source;
		while ( source = sources.shift() ) {
			for ( prop in source ) {
				if ( source.hasOwnProperty( prop ) ) {
					target[ prop ] = source[ prop ];
				}
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Binding/Binding.js */
	var Binding = function( runloop, warn, create, extend, removeFromArray ) {

		var Binding = function( element ) {
			var interpolator, keypath, value;
			this.element = element;
			this.root = element.root;
			this.attribute = element.attributes[ this.name || 'value' ];
			interpolator = this.attribute.interpolator;
			interpolator.twowayBinding = this;
			if ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {
				warn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );
				return false;
			}
			// A mustache may be *ambiguous*. Let's say we were given
			// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
			// *wasn't* `undefined`, the keypath would be `foo.bar`.
			// Then, any user input would result in `foo.bar` being updated.
			//
			// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
			// left with an unresolved partial keypath - so we are forced to make an
			// assumption. That assumption is that the input in question should
			// be forced to resolve to `bar`, and any user input would affect `bar`
			// and not `foo.bar`.
			//
			// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
			// be explicit when using two-way data-binding about what keypath you're
			// updating. Using it in lists is probably a recipe for confusion...
			if ( !interpolator.keypath ) {
				interpolator.resolver.forceResolution();
			}
			this.keypath = keypath = interpolator.keypath;
			// initialise value, if it's undefined
			if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
				value = this.getInitialValue();
				if ( value !== undefined ) {
					this.root.viewmodel.set( keypath, value );
				}
			}
		};
		Binding.prototype = {
			handleChange: function() {
				var this$0 = this;
				runloop.start( this.root );
				this.attribute.locked = true;
				this.root.viewmodel.set( this.keypath, this.getValue() );
				runloop.scheduleTask( function() {
					return this$0.attribute.locked = false;
				} );
				runloop.end();
			},
			rebound: function() {
				var bindings, oldKeypath, newKeypath;
				oldKeypath = this.keypath;
				newKeypath = this.attribute.interpolator.keypath;
				// The attribute this binding is linked to has already done the work
				if ( oldKeypath === newKeypath ) {
					return;
				}
				removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
				this.keypath = newKeypath;
				bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
				bindings.push( this );
			},
			unbind: function() {}
		};
		Binding.extend = function( properties ) {
			var Parent = this,
				SpecialisedBinding;
			SpecialisedBinding = function( element ) {
				Binding.call( this, element );
				if ( this.init ) {
					this.init();
				}
			};
			SpecialisedBinding.prototype = create( Parent.prototype );
			extend( SpecialisedBinding.prototype, properties );
			SpecialisedBinding.extend = Binding.extend;
			return SpecialisedBinding;
		};
		return Binding;
	}( runloop, warn, create, extend, removeFromArray );

	/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
	var handleDomEvent = function handleChange() {
		this._ractive.binding.handleChange();
	};

	/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
	var ContentEditableBinding = function( Binding, handleDomEvent ) {

		var ContentEditableBinding = Binding.extend( {
			getInitialValue: function() {
				return this.element.fragment ? this.element.fragment.toString() : '';
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.innerHTML;
			}
		} );
		return ContentEditableBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/shared/getSiblings.js */
	var getSiblings = function() {

		var sets = {};
		return function getSiblings( id, group, keypath ) {
			var hash = id + group + keypath;
			return sets[ hash ] || ( sets[ hash ] = [] );
		};
	}();

	/* virtualdom/items/Element/Binding/RadioBinding.js */
	var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var RadioBinding = Binding.extend( {
			name: 'checked',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
				this.siblings.push( this );
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			handleChange: function() {
				runloop.start( this.root );
				this.siblings.forEach( function( binding ) {
					binding.root.viewmodel.set( binding.keypath, binding.getValue() );
				} );
				runloop.end();
			},
			getValue: function() {
				return this.element.node.checked;
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioBinding;
	}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/RadioNameBinding.js */
	var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

		var RadioNameBinding = Binding.extend( {
			name: 'name',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
				this.siblings.push( this );
				this.radioName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
			},
			getInitialValue: function() {
				if ( this.element.getAttribute( 'checked' ) ) {
					return this.element.getAttribute( 'value' );
				}
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				var node = this.element.node;
				return node._ractive ? node._ractive.value : node.value;
			},
			handleChange: function() {
				// If this <input> is the one that's checked, then the value of its
				// `name` keypath gets set to its value
				if ( this.element.node.checked ) {
					Binding.prototype.handleChange.call( this );
				}
			},
			rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var node;
				Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				if ( node = this.element.node ) {
					node.name = '{{' + this.keypath + '}}';
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioNameBinding;
	}( removeFromArray, Binding, handleDomEvent, getSiblings );

	/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
	var CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var CheckboxNameBinding = Binding.extend( {
			name: 'name',
			getInitialValue: function() {
				// This only gets called once per group (of inputs that
				// share a name), because it only gets called if there
				// isn't an initial value. By the same token, we can make
				// a note of that fact that there was no initial value,
				// and populate it using any `checked` attributes that
				// exist (which users should avoid, but which we should
				// support anyway to avoid breaking expectations)
				this.noInitialValue = true;
				return [];
			},
			init: function() {
				var existingValue, bindingValue;
				this.checkboxName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
				// we set this property so that the attribute gets the correct update method
				// Each input has a reference to an array containing it and its
				// siblings, as two-way binding depends on being able to ascertain
				// the status of all inputs within the group
				this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
				this.siblings.push( this );
				if ( this.noInitialValue ) {
					this.siblings.noInitialValue = true;
				}
				// If no initial value was set, and this input is checked, we
				// update the model
				if ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {
					existingValue = this.root.viewmodel.get( this.keypath );
					bindingValue = this.element.getAttribute( 'value' );
					existingValue.push( bindingValue );
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			},
			render: function() {
				var node = this.element.node,
					existingValue, bindingValue;
				existingValue = this.root.viewmodel.get( this.keypath );
				bindingValue = this.element.getAttribute( 'value' );
				if ( isArray( existingValue ) ) {
					this.isChecked = arrayContains( existingValue, bindingValue );
				} else {
					this.isChecked = existingValue == bindingValue;
				}
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.isChecked;
				node.addEventListener( 'change', handleDomEvent, false );
				// in case of IE emergency, bind to click event as well
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			changed: function() {
				var wasChecked = !!this.isChecked;
				this.isChecked = this.element.node.checked;
				return this.isChecked === wasChecked;
			},
			handleChange: function() {
				this.isChecked = this.element.node.checked;
				Binding.prototype.handleChange.call( this );
			},
			getValue: function() {
				return this.siblings.filter( isChecked ).map( getValue );
			}
		} );

		function isChecked( binding ) {
			return binding.isChecked;
		}

		function getValue( binding ) {
			return binding.element.getAttribute( 'value' );
		}
		return CheckboxNameBinding;
	}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/CheckboxBinding.js */
	var CheckboxBinding = function( Binding, handleDomEvent ) {

		var CheckboxBinding = Binding.extend( {
			name: 'checked',
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.checked;
			}
		} );
		return CheckboxBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/SelectBinding.js */
	var SelectBinding = function( runloop, Binding, handleDomEvent ) {

		var SelectBinding = Binding.extend( {
			getInitialValue: function() {
				var options = this.element.options,
					len, i, value, optionWasSelected;
				if ( this.element.getAttribute( 'value' ) !== undefined ) {
					return;
				}
				i = len = options.length;
				if ( !len ) {
					return;
				}
				// take the final selected option...
				while ( i-- ) {
					if ( options[ i ].getAttribute( 'selected' ) ) {
						value = options[ i ].getAttribute( 'value' );
						optionWasSelected = true;
						break;
					}
				}
				// or the first non-disabled option, if none are selected
				if ( !optionWasSelected ) {
					while ( ++i < len ) {
						if ( !options[ i ].getAttribute( 'disabled' ) ) {
							value = options[ i ].getAttribute( 'value' );
							break;
						}
					}
				}
				// This is an optimisation (aka hack) that allows us to forgo some
				// other more expensive work
				if ( value !== undefined ) {
					this.element.attributes.value.value = value;
				}
				return value;
			},
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			// TODO this method is an anomaly... is it necessary?
			setValue: function( value ) {
				runloop.addViewmodel( this.root.viewmodel );
				this.root.viewmodel.set( this.keypath, value );
			},
			getValue: function() {
				var options, i, len, option, optionValue;
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( options[ i ].selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						return optionValue;
					}
				}
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			}
		} );
		return SelectBinding;
	}( runloop, Binding, handleDomEvent );

	/* utils/arrayContentsMatch.js */
	var arrayContentsMatch = function( isArray ) {

		return function( a, b ) {
			var i;
			if ( !isArray( a ) || !isArray( b ) ) {
				return false;
			}
			if ( a.length !== b.length ) {
				return false;
			}
			i = a.length;
			while ( i-- ) {
				if ( a[ i ] !== b[ i ] ) {
					return false;
				}
			}
			return true;
		};
	}( isArray );

	/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
	var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

		var MultipleSelectBinding = SelectBinding.extend( {
			getInitialValue: function() {
				return this.element.options.filter( function( option ) {
					return option.getAttribute( 'selected' );
				} ).map( function( option ) {
					return option.getAttribute( 'value' );
				} );
			},
			render: function() {
				var valueFromModel;
				this.element.node.addEventListener( 'change', handleDomEvent, false );
				valueFromModel = this.root.viewmodel.get( this.keypath );
				if ( valueFromModel === undefined ) {
					// get value from DOM, if possible
					this.handleChange();
				}
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			setValue: function() {
				throw new Error( 'TODO not implemented yet' );
			},
			getValue: function() {
				var selectedValues, options, i, len, option, optionValue;
				selectedValues = [];
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( option.selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						selectedValues.push( optionValue );
					}
				}
				return selectedValues;
			},
			handleChange: function() {
				var attribute, previousValue, value;
				attribute = this.attribute;
				previousValue = attribute.value;
				value = this.getValue();
				if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
					SelectBinding.prototype.handleChange.call( this );
				}
				return this;
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			},
			updateModel: function() {
				if ( this.attribute.value === undefined || !this.attribute.value.length ) {
					this.root.viewmodel.set( this.keypath, this.initialValue );
				}
			}
		} );
		return MultipleSelectBinding;
	}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

	/* virtualdom/items/Element/Binding/FileListBinding.js */
	var FileListBinding = function( Binding, handleDomEvent ) {

		var FileListBinding = Binding.extend( {
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.files;
			}
		} );
		return FileListBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/GenericBinding.js */
	var GenericBinding = function( Binding, handleDomEvent ) {

		var __export;
		var GenericBinding, getOptions;
		getOptions = {
			evaluateWrapped: true
		};
		GenericBinding = Binding.extend( {
			getInitialValue: function() {
				return '';
			},
			getValue: function() {
				return this.element.node.value;
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
				node.addEventListener( 'blur', handleBlur, false );
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
				node.removeEventListener( 'blur', handleBlur, false );
			}
		} );
		__export = GenericBinding;

		function handleBlur() {
			var value;
			handleDomEvent.call( this );
			value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
			this.value = value == undefined ? '' : value;
		}
		return __export;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/NumericBinding.js */
	var NumericBinding = function( GenericBinding ) {

		return GenericBinding.extend( {
			getInitialValue: function() {
				return undefined;
			},
			getValue: function() {
				var value = parseFloat( this.element.node.value );
				return isNaN( value ) ? undefined : value;
			}
		} );
	}( GenericBinding );

	/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
	var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

		var __export;
		__export = function createTwowayBinding( element ) {
			var attributes = element.attributes,
				type, Binding, bindName, bindChecked;
			// if this is a late binding, and there's already one, it
			// needs to be torn down
			if ( element.binding ) {
				element.binding.teardown();
				element.binding = null;
			}
			// contenteditable
			if ( // if the contenteditable attribute is true or is bindable and may thus become true
				( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {
				Binding = ContentEditableBinding;
			} else if ( element.name === 'input' ) {
				type = element.getAttribute( 'type' );
				if ( type === 'radio' || type === 'checkbox' ) {
					bindName = isBindable( attributes.name );
					bindChecked = isBindable( attributes.checked );
					// we can either bind the name attribute, or the checked attribute - not both
					if ( bindName && bindChecked ) {
						log.error( {
							message: 'badRadioInputBinding'
						} );
					}
					if ( bindName ) {
						Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
					} else if ( bindChecked ) {
						Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
					}
				} else if ( type === 'file' && isBindable( attributes.value ) ) {
					Binding = FileListBinding;
				} else if ( isBindable( attributes.value ) ) {
					Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
				}
			} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
				Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
			} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
				Binding = GenericBinding;
			}
			if ( Binding ) {
				return new Binding( element );
			}
		};

		function isBindable( attribute ) {
			return attribute && attribute.isBindable;
		}
		return __export;
	}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

	/* virtualdom/items/Element/EventHandler/prototype/bubble.js */
	var virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {
		var hasAction = this.getAction();
		if ( hasAction && !this.hasListener ) {
			this.listen();
		} else if ( !hasAction && this.hasListener ) {
			this.unrender();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/fire.js */
	var virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {

		return function EventHandler$fire( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event
			} );
		};
	}( Ractive$shared_fireEvent );

	/* virtualdom/items/Element/EventHandler/prototype/getAction.js */
	var virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {
		return this.action.toString().trim();
	};

	/* virtualdom/items/Element/EventHandler/prototype/init.js */
	var virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {

		var __export;
		var Fragment, getValueOptions = {
				args: true
			},
			eventPattern = /^event(?:\.(.+))?/;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function EventHandler$init( element, name, template ) {
			var handler = this,
				action, refs, ractive;
			handler.element = element;
			handler.root = element.root;
			handler.name = name;
			if ( name.indexOf( '*' ) !== -1 ) {
				log.error( {
					debug: this.root.debug,
					message: 'noElementProxyEventWildcards',
					args: {
						element: element.tagName,
						event: name
					}
				} );
				this.invalid = true;
			}
			if ( template.m ) {
				refs = template.a.r;
				// This is a method call
				handler.method = template.m;
				handler.keypaths = [];
				handler.fn = getFunctionFromString( template.a.s, refs.length );
				handler.parentFragment = element.parentFragment;
				ractive = handler.root;
				// Create resolvers for each reference
				handler.refResolvers = refs.map( function( ref, i ) {
					var match;
					// special case - the `event` object
					if ( match = eventPattern.exec( ref ) ) {
						handler.keypaths[ i ] = {
							eventObject: true,
							refinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []
						};
						return null;
					}
					return createReferenceResolver( handler, ref, function( keypath ) {
						handler.resolve( i, keypath );
					} );
				} );
				this.fire = fireMethodCall;
			} else {
				// Get action ('foo' in 'on-click='foo')
				action = template.n || template;
				if ( typeof action !== 'string' ) {
					action = new Fragment( {
						template: action,
						root: this.root,
						owner: this
					} );
				}
				this.action = action;
				// Get parameters
				if ( template.d ) {
					this.dynamicParams = new Fragment( {
						template: template.d,
						root: this.root,
						owner: this.element
					} );
					this.fire = fireEventWithDynamicParams;
				} else if ( template.a ) {
					this.params = template.a;
					this.fire = fireEventWithParams;
				}
			}
		};

		function fireMethodCall( event ) {
			var ractive, values, args;
			ractive = this.root;
			if ( typeof ractive[ this.method ] !== 'function' ) {
				throw new Error( 'Attempted to call a non-existent method ("' + this.method + '")' );
			}
			values = this.keypaths.map( function( keypath ) {
				var value, len, i;
				if ( keypath === undefined ) {
					// not yet resolved
					return undefined;
				}
				// TODO the refinements stuff would be better handled at parse time
				if ( keypath.eventObject ) {
					value = event;
					if ( len = keypath.refinements.length ) {
						for ( i = 0; i < len; i += 1 ) {
							value = value[ keypath.refinements[ i ] ];
						}
					}
				} else {
					value = ractive.viewmodel.get( keypath );
				}
				return value;
			} );
			ractive.event = event;
			args = this.fn.apply( null, values );
			ractive[ this.method ].apply( ractive, args );
			delete ractive.event;
		}

		function fireEventWithParams( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: this.params
			} );
		}

		function fireEventWithDynamicParams( event ) {
			var args = this.dynamicParams.getValue( getValueOptions );
			// need to strip [] from ends if a string!
			if ( typeof args === 'string' ) {
				args = args.substr( 1, args.length - 2 );
			}
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: args
			} );
		}
		return __export;
	}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
	var genericHandler = function genericHandler( event ) {
		var storage, handler;
		storage = this._ractive;
		handler = storage.events[ event.type ];
		handler.fire( {
			node: this,
			original: event,
			index: storage.index,
			keypath: storage.keypath,
			context: storage.root.get( storage.keypath )
		} );
	};

	/* virtualdom/items/Element/EventHandler/prototype/listen.js */
	var virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {

		var __export;
		var customHandlers = {},
			touchEvents = {
				touchstart: true,
				touchmove: true,
				touchend: true,
				touchcancel: true,
				//not w3c, but supported in some browsers
				touchleave: true
			};
		__export = function EventHandler$listen() {
			var definition, name = this.name;
			if ( this.invalid ) {
				return;
			}
			if ( definition = config.registries.events.find( this.root, name ) ) {
				this.custom = definition( this.node, getCustomHandler( name ) );
			} else {
				// Looks like we're dealing with a standard DOM event... but let's check
				if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
					// okay to use touch events if this browser doesn't support them
					if ( !touchEvents[ name ] ) {
						log.error( {
							debug: this.root.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'event',
								name: name
							}
						} );
					}
					return;
				}
				this.node.addEventListener( name, genericHandler, false );
			}
			this.hasListener = true;
		};

		function getCustomHandler( name ) {
			if ( !customHandlers[ name ] ) {
				customHandlers[ name ] = function( event ) {
					var storage = event.node._ractive;
					event.index = storage.index;
					event.keypath = storage.keypath;
					event.context = storage.root.get( storage.keypath );
					storage.events[ name ].fire( event );
				};
			}
			return customHandlers[ name ];
		}
		return __export;
	}( config, genericHandler, log );

	/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
	var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		var fragment;
		if ( this.method ) {
			fragment = this.element.parentFragment;
			this.refResolvers.forEach( rebind );
			return;
		}
		if ( typeof this.action !== 'string' ) {
			rebind( this.action );
		}
		if ( this.dynamicParams ) {
			rebind( this.dynamicParams );
		}

		function rebind( thing ) {
			thing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/render.js */
	var virtualdom_items_Element_EventHandler$render = function EventHandler$render() {
		this.node = this.element.node;
		// store this on the node itself, so it can be retrieved by a
		// universal handler
		this.node._ractive.events[ this.name ] = this;
		if ( this.method || this.getAction() ) {
			this.listen();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/resolve.js */
	var virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {
		this.keypaths[ index ] = keypath;
	};

	/* virtualdom/items/Element/EventHandler/prototype/unbind.js */
	var virtualdom_items_Element_EventHandler$unbind = function() {

		var __export;
		__export = function EventHandler$unbind() {
			if ( this.method ) {
				this.refResolvers.forEach( unbind );
				return;
			}
			// Tear down dynamic name
			if ( typeof this.action !== 'string' ) {
				this.action.unbind();
			}
			// Tear down dynamic parameters
			if ( this.dynamicParams ) {
				this.dynamicParams.unbind();
			}
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}();

	/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
	var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

		return function EventHandler$unrender() {
			if ( this.custom ) {
				this.custom.teardown();
			} else {
				this.node.removeEventListener( this.name, genericHandler, false );
			}
			this.hasListener = false;
		};
	}( genericHandler );

	/* virtualdom/items/Element/EventHandler/_EventHandler.js */
	var EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {

		var EventHandler = function( element, name, template ) {
			this.init( element, name, template );
		};
		EventHandler.prototype = {
			bubble: bubble,
			fire: fire,
			getAction: getAction,
			init: init,
			listen: listen,
			rebind: rebind,
			render: render,
			resolve: resolve,
			unbind: unbind,
			unrender: unrender
		};
		return EventHandler;
	}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );

	/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
	var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

		return function( element, template ) {
			var i, name, names, handler, result = [];
			for ( name in template ) {
				if ( template.hasOwnProperty( name ) ) {
					names = name.split( '-' );
					i = names.length;
					while ( i-- ) {
						handler = new EventHandler( element, names[ i ], template[ name ] );
						result.push( handler );
					}
				}
			}
			return result;
		};
	}( EventHandler );

	/* virtualdom/items/Element/Decorator/_Decorator.js */
	var Decorator = function( log, circular, config ) {

		var Fragment, getValueOptions, Decorator;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		getValueOptions = {
			args: true
		};
		Decorator = function( element, template ) {
			var decorator = this,
				ractive, name, fragment;
			decorator.element = element;
			decorator.root = ractive = element.root;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			if ( template.a ) {
				decorator.params = template.a;
			} else if ( template.d ) {
				decorator.fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				decorator.params = decorator.fragment.getValue( getValueOptions );
				decorator.fragment.bubble = function() {
					this.dirtyArgs = this.dirtyValue = true;
					decorator.params = this.getValue( getValueOptions );
					if ( decorator.ready ) {
						decorator.update();
					}
				};
			}
			decorator.fn = config.registries.decorators.find( ractive, name );
			if ( !decorator.fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'decorator',
						name: name
					}
				} );
			}
		};
		Decorator.prototype = {
			init: function() {
				var decorator = this,
					node, result, args;
				node = decorator.element.node;
				if ( decorator.params ) {
					args = [ node ].concat( decorator.params );
					result = decorator.fn.apply( decorator.root, args );
				} else {
					result = decorator.fn.call( decorator.root, node );
				}
				if ( !result || !result.teardown ) {
					throw new Error( 'Decorator definition must return an object with a teardown method' );
				}
				// TODO does this make sense?
				decorator.actual = result;
				decorator.ready = true;
			},
			update: function() {
				if ( this.actual.update ) {
					this.actual.update.apply( this.root, this.params );
				} else {
					this.actual.teardown( true );
					this.init();
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.fragment ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			teardown: function( updating ) {
				this.actual.teardown();
				if ( !updating && this.fragment ) {
					this.fragment.unbind();
				}
			}
		};
		return Decorator;
	}( log, circular, config );

	/* virtualdom/items/Element/special/select/sync.js */
	var sync = function( toArray ) {

		var __export;
		__export = function syncSelect( selectElement ) {
			var selectNode, selectValue, isMultiple, options, optionWasSelected;
			selectNode = selectElement.node;
			if ( !selectNode ) {
				return;
			}
			options = toArray( selectNode.options );
			selectValue = selectElement.getAttribute( 'value' );
			isMultiple = selectElement.getAttribute( 'multiple' );
			// If the <select> has a specified value, that should override
			// these options
			if ( selectValue !== undefined ) {
				options.forEach( function( o ) {
					var optionValue, shouldSelect;
					optionValue = o._ractive ? o._ractive.value : o.value;
					shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
					if ( shouldSelect ) {
						optionWasSelected = true;
					}
					o.selected = shouldSelect;
				} );
				if ( !optionWasSelected ) {
					if ( options[ 0 ] ) {
						options[ 0 ].selected = true;
					}
					if ( selectElement.binding ) {
						selectElement.binding.forceUpdate();
					}
				}
			} else if ( selectElement.binding ) {
				selectElement.binding.forceUpdate();
			}
		};

		function valueContains( selectValue, optionValue ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( selectValue[ i ] == optionValue ) {
					return true;
				}
			}
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Element/special/select/bubble.js */
	var bubble = function( runloop, syncSelect ) {

		return function bubbleSelect() {
			var this$0 = this;
			if ( !this.dirty ) {
				this.dirty = true;
				runloop.scheduleTask( function() {
					syncSelect( this$0 );
					this$0.dirty = false;
				} );
			}
			this.parentFragment.bubble();
		};
	}( runloop, sync );

	/* virtualdom/items/Element/special/option/findParentSelect.js */
	var findParentSelect = function findParentSelect( element ) {
		do {
			if ( element.name === 'select' ) {
				return element;
			}
		} while ( element = element.parent );
	};

	/* virtualdom/items/Element/special/option/init.js */
	var init = function( findParentSelect ) {

		return function initOption( option, template ) {
			option.select = findParentSelect( option.parent );
			// we might be inside a <datalist> element
			if ( !option.select ) {
				return;
			}
			option.select.options.push( option );
			// If the value attribute is missing, use the element's content
			if ( !template.a ) {
				template.a = {};
			}
			// ...as long as it isn't disabled
			if ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {
				template.a.value = template.f;
			}
			// If there is a `selected` attribute, but the <select>
			// already has a value, delete it
			if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
				delete template.a.selected;
			}
		};
	}( findParentSelect );

	/* virtualdom/items/Element/prototype/init.js */
	var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Element$init( options ) {
			var parentFragment, template, ractive, binding, bindings;
			this.type = types.ELEMENT;
			// stuff we'll need later
			parentFragment = this.parentFragment = options.parentFragment;
			template = this.template = options.template;
			this.parent = options.pElement || parentFragment.pElement;
			this.root = ractive = parentFragment.root;
			this.index = options.index;
			this.name = enforceCase( template.e );
			// Special case - <option> elements
			if ( this.name === 'option' ) {
				initOption( this, template );
			}
			// Special case - <select> elements
			if ( this.name === 'select' ) {
				this.options = [];
				this.bubble = bubbleSelect;
			}
			// create attributes
			this.attributes = createAttributes( this, template.a );
			this.conditionalAttributes = createConditionalAttributes( this, template.m );
			// append children, if there are any
			if ( template.f ) {
				this.fragment = new Fragment( {
					template: template.f,
					root: ractive,
					owner: this,
					pElement: this
				} );
			}
			// create twoway binding
			if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
				this.binding = binding;
				// register this with the root, so that we can do ractive.updateModel()
				bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
				bindings.push( binding );
			}
			// create event proxies
			if ( template.v ) {
				this.eventHandlers = createEventHandlers( this, template.v );
			}
			// create decorator
			if ( template.o ) {
				this.decorator = new Decorator( this, template.o );
			}
			// create transitions
			this.intro = template.t0 || template.t1;
			this.outro = template.t0 || template.t2;
		};
	}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

	/* virtualdom/items/shared/utils/startsWith.js */
	var startsWith = function( startsWithKeypath ) {

		return function startsWith( target, keypath ) {
			return target === keypath || startsWithKeypath( target, keypath );
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/utils/assignNewKeypath.js */
	var assignNewKeypath = function( startsWith, getNewKeypath ) {

		return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
			var existingKeypath = target[ property ];
			if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
				return;
			}
			target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
		};
	}( startsWith, getNewKeypath );

	/* virtualdom/items/Element/prototype/rebind.js */
	var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

		return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var i, storage, liveQueries, ractive;
			if ( this.attributes ) {
				this.attributes.forEach( rebind );
			}
			if ( this.conditionalAttributes ) {
				this.conditionalAttributes.forEach( rebind );
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( rebind );
			}
			if ( this.decorator ) {
				rebind( this.decorator );
			}
			// rebind children
			if ( this.fragment ) {
				rebind( this.fragment );
			}
			// Update live queries, if necessary
			if ( liveQueries = this.liveQueries ) {
				ractive = this.root;
				i = liveQueries.length;
				while ( i-- ) {
					liveQueries[ i ]._makeDirty();
				}
			}
			if ( this.node && ( storage = this.node._ractive ) ) {
				// adjust keypath if needed
				assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
				if ( indexRef != undefined ) {
					storage.index[ indexRef ] = newIndex;
				}
			}

			function rebind( thing ) {
				thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( assignNewKeypath );

	/* virtualdom/items/Element/special/img/render.js */
	var render = function renderImage( img ) {
		var loadHandler;
		// if this is an <img>, and we're in a crap browser, we may need to prevent it
		// from overriding width and height when it loads the src
		if ( img.attributes.width || img.attributes.height ) {
			img.node.addEventListener( 'load', loadHandler = function() {
				var width = img.getAttribute( 'width' ),
					height = img.getAttribute( 'height' );
				if ( width !== undefined ) {
					img.node.setAttribute( 'width', width );
				}
				if ( height !== undefined ) {
					img.node.setAttribute( 'height', height );
				}
				img.node.removeEventListener( 'load', loadHandler, false );
			}, false );
		}
	};

	/* virtualdom/items/Element/Transition/prototype/init.js */
	var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

		var Fragment, getValueOptions = {};
		// TODO what are the options?
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Transition$init( element, template, isIntro ) {
			var t = this,
				ractive, name, fragment;
			t.element = element;
			t.root = ractive = element.root;
			t.isIntro = isIntro;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			t.name = name;
			if ( template.a ) {
				t.params = template.a;
			} else if ( template.d ) {
				// TODO is there a way to interpret dynamic arguments without all the
				// 'dependency thrashing'?
				fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				t.params = fragment.getValue( getValueOptions );
				fragment.unbind();
			}
			t._fn = config.registries.transitions.find( ractive, name );
			if ( !t._fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'transition',
						name: name
					}
				} );
				return;
			}
		};
	}( log, config, circular );

	/* utils/camelCase.js */
	var camelCase = function( hyphenatedStr ) {
		return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
			return $1.toUpperCase();
		} );
	};

	/* virtualdom/items/Element/Transition/helpers/prefix.js */
	var prefix = function( isClient, vendors, createElement, camelCase ) {

		var prefix, prefixCache, testStyle;
		if ( !isClient ) {
			prefix = null;
		} else {
			prefixCache = {};
			testStyle = createElement( 'div' ).style;
			prefix = function( prop ) {
				var i, vendor, capped;
				prop = camelCase( prop );
				if ( !prefixCache[ prop ] ) {
					if ( testStyle[ prop ] !== undefined ) {
						prefixCache[ prop ] = prop;
					} else {
						// test vendors...
						capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
						i = vendors.length;
						while ( i-- ) {
							vendor = vendors[ i ];
							if ( testStyle[ vendor + capped ] !== undefined ) {
								prefixCache[ prop ] = vendor + capped;
								break;
							}
						}
					}
				}
				return prefixCache[ prop ];
			};
		}
		return prefix;
	}( isClient, vendors, createElement, camelCase );

	/* virtualdom/items/Element/Transition/prototype/getStyle.js */
	var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

		var getStyle, getComputedStyle;
		if ( !isClient ) {
			getStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			getStyle = function( props ) {
				var computedStyle, styles, i, prop, value;
				computedStyle = getComputedStyle( this.node );
				if ( typeof props === 'string' ) {
					value = computedStyle[ prefix( props ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					return value;
				}
				if ( !isArray( props ) ) {
					throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
				}
				styles = {};
				i = props.length;
				while ( i-- ) {
					prop = props[ i ];
					value = computedStyle[ prefix( prop ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					styles[ prop ] = value;
				}
				return styles;
			};
		}
		return getStyle;
	}( legacy, isClient, isArray, prefix );

	/* virtualdom/items/Element/Transition/prototype/setStyle.js */
	var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

		return function( style, value ) {
			var prop;
			if ( typeof style === 'string' ) {
				this.node.style[ prefix( style ) ] = value;
			} else {
				for ( prop in style ) {
					if ( style.hasOwnProperty( prop ) ) {
						this.node.style[ prefix( prop ) ] = style[ prop ];
					}
				}
			}
			return this;
		};
	}( prefix );

	/* shared/Ticker.js */
	var Ticker = function( warn, getTime, animations ) {

		var __export;
		var Ticker = function( options ) {
			var easing;
			this.duration = options.duration;
			this.step = options.step;
			this.complete = options.complete;
			// easing
			if ( typeof options.easing === 'string' ) {
				easing = options.root.easing[ options.easing ];
				if ( !easing ) {
					warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
					easing = linear;
				}
			} else if ( typeof options.easing === 'function' ) {
				easing = options.easing;
			} else {
				easing = linear;
			}
			this.easing = easing;
			this.start = getTime();
			this.end = this.start + this.duration;
			this.running = true;
			animations.add( this );
		};
		Ticker.prototype = {
			tick: function( now ) {
				var elapsed, eased;
				if ( !this.running ) {
					return false;
				}
				if ( now > this.end ) {
					if ( this.step ) {
						this.step( 1 );
					}
					if ( this.complete ) {
						this.complete( 1 );
					}
					return false;
				}
				elapsed = now - this.start;
				eased = this.easing( elapsed / this.duration );
				if ( this.step ) {
					this.step( eased );
				}
				return true;
			},
			stop: function() {
				if ( this.abort ) {
					this.abort();
				}
				this.running = false;
			}
		};
		__export = Ticker;

		function linear( t ) {
			return t;
		}
		return __export;
	}( warn, getTime, animations );

	/* virtualdom/items/Element/Transition/helpers/unprefix.js */
	var unprefix = function( vendors ) {

		var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
		return function( prop ) {
			return prop.replace( unprefixPattern, '' );
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
	var hyphenate = function( vendors ) {

		var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
		return function( str ) {
			var hyphenated;
			if ( !str ) {
				return '';
			}
			if ( vendorPattern.test( str ) ) {
				str = '-' + str;
			}
			hyphenated = str.replace( /[A-Z]/g, function( match ) {
				return '-' + match.toLowerCase();
			} );
			return hyphenated;
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
	var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

		var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
			cannotUseCssTransitions = {};
		if ( !isClient ) {
			createTransitions = null;
		} else {
			testStyle = createElement( 'div' ).style;
			// determine some facts about our environment
			( function() {
				if ( testStyle.transition !== undefined ) {
					TRANSITION = 'transition';
					TRANSITIONEND = 'transitionend';
					CSS_TRANSITIONS_ENABLED = true;
				} else if ( testStyle.webkitTransition !== undefined ) {
					TRANSITION = 'webkitTransition';
					TRANSITIONEND = 'webkitTransitionEnd';
					CSS_TRANSITIONS_ENABLED = true;
				} else {
					CSS_TRANSITIONS_ENABLED = false;
				}
			}() );
			if ( TRANSITION ) {
				TRANSITION_DURATION = TRANSITION + 'Duration';
				TRANSITION_PROPERTY = TRANSITION + 'Property';
				TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
			}
			createTransitions = function( t, to, options, changedProperties, resolve ) {
				// Wait a beat (otherwise the target styles will be applied immediately)
				// TODO use a fastdom-style mechanism?
				setTimeout( function() {
					var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
					checkComplete = function() {
						if ( jsTransitionsComplete && cssTransitionsComplete ) {
							// will changes to events and fire have an unexpected consequence here?
							t.root.fire( t.name + ':end', t.node, t.isIntro );
							resolve();
						}
					};
					// this is used to keep track of which elements can use CSS to animate
					// which properties
					hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
					t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
					t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
					t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
					transitionEndHandler = function( event ) {
						var index;
						index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
						if ( index !== -1 ) {
							changedProperties.splice( index, 1 );
						}
						if ( changedProperties.length ) {
							// still transitioning...
							return;
						}
						t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
						cssTransitionsComplete = true;
						checkComplete();
					};
					t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
					setTimeout( function() {
						var i = changedProperties.length,
							hash, originalValue, index, propertiesToTransitionInJs = [],
							prop, suffix;
						while ( i-- ) {
							prop = changedProperties[ i ];
							hash = hashPrefix + prop;
							if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
								t.node.style[ prefix( prop ) ] = to[ prop ];
								// If we're not sure if CSS transitions are supported for
								// this tag/property combo, find out now
								if ( !canUseCssTransitions[ hash ] ) {
									originalValue = t.getStyle( prop );
									// if this property is transitionable in this browser,
									// the current style will be different from the target style
									canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
									cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
									// Reset, if we're going to use timers after all
									if ( cannotUseCssTransitions[ hash ] ) {
										t.node.style[ prefix( prop ) ] = originalValue;
									}
								}
							}
							if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
								// we need to fall back to timer-based stuff
								if ( originalValue === undefined ) {
									originalValue = t.getStyle( prop );
								}
								// need to remove this from changedProperties, otherwise transitionEndHandler
								// will get confused
								index = changedProperties.indexOf( prop );
								if ( index === -1 ) {
									warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
								} else {
									changedProperties.splice( index, 1 );
								}
								// TODO Determine whether this property is animatable at all
								suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
								// ...then kick off a timer-based transition
								propertiesToTransitionInJs.push( {
									name: prefix( prop ),
									interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
									suffix: suffix
								} );
							}
						}
						// javascript transitions
						if ( propertiesToTransitionInJs.length ) {
							new Ticker( {
								root: t.root,
								duration: options.duration,
								easing: camelCase( options.easing || '' ),
								step: function( pos ) {
									var prop, i;
									i = propertiesToTransitionInJs.length;
									while ( i-- ) {
										prop = propertiesToTransitionInJs[ i ];
										t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
									}
								},
								complete: function() {
									jsTransitionsComplete = true;
									checkComplete();
								}
							} );
						} else {
							jsTransitionsComplete = true;
						}
						if ( !changedProperties.length ) {
							// We need to cancel the transitionEndHandler, and deal with
							// the fact that it will never fire
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						}
					}, 0 );
				}, options.delay || 0 );
			};
		}
		return createTransitions;
	}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
	var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

		var hidden, vendor, prefix, i, visibility;
		if ( typeof document !== 'undefined' ) {
			hidden = 'hidden';
			visibility = {};
			if ( hidden in document ) {
				prefix = '';
			} else {
				i = vendors.length;
				while ( i-- ) {
					vendor = vendors[ i ];
					hidden = vendor + 'Hidden';
					if ( hidden in document ) {
						prefix = vendor;
					}
				}
			}
			if ( prefix !== undefined ) {
				document.addEventListener( prefix + 'visibilitychange', onChange );
				// initialise
				onChange();
			} else {
				// gah, we're in an old browser
				if ( 'onfocusout' in document ) {
					document.addEventListener( 'focusout', onHide );
					document.addEventListener( 'focusin', onShow );
				} else {
					window.addEventListener( 'pagehide', onHide );
					window.addEventListener( 'blur', onHide );
					window.addEventListener( 'pageshow', onShow );
					window.addEventListener( 'focus', onShow );
				}
				visibility.hidden = false;
			}
		}

		function onChange() {
			visibility.hidden = document[ hidden ];
		}

		function onHide() {
			visibility.hidden = true;
		}

		function onShow() {
			visibility.hidden = false;
		}
		return visibility;
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
	var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

		var animateStyle, getComputedStyle, resolved;
		if ( !isClient ) {
			animateStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			animateStyle = function( style, value, options, complete ) {
				var t = this,
					to;
				// Special case - page isn't visible. Don't animate anything, because
				// that way you'll never get CSS transitionend events
				if ( visibility.hidden ) {
					this.setStyle( style, value );
					return resolved || ( resolved = Promise.resolve() );
				}
				if ( typeof style === 'string' ) {
					to = {};
					to[ style ] = value;
				} else {
					to = style;
					// shuffle arguments
					complete = options;
					options = value;
				}
				// As of 0.3.9, transition authors should supply an `option` object with
				// `duration` and `easing` properties (and optional `delay`), plus a
				// callback function that gets called after the animation completes
				// TODO remove this check in a future version
				if ( !options ) {
					warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
					options = t;
					complete = t.complete;
				}
				var promise = new Promise( function( resolve ) {
					var propertyNames, changedProperties, computedStyle, current, from, i, prop;
					// Edge case - if duration is zero, set style synchronously and complete
					if ( !options.duration ) {
						t.setStyle( to );
						resolve();
						return;
					}
					// Get a list of the properties we're animating
					propertyNames = Object.keys( to );
					changedProperties = [];
					// Store the current styles
					computedStyle = getComputedStyle( t.node );
					from = {};
					i = propertyNames.length;
					while ( i-- ) {
						prop = propertyNames[ i ];
						current = computedStyle[ prefix( prop ) ];
						if ( current === '0px' ) {
							current = 0;
						}
						// we need to know if we're actually changing anything
						if ( current != to[ prop ] ) {
							// use != instead of !==, so we can compare strings with numbers
							changedProperties.push( prop );
							// make the computed style explicit, so we can animate where
							// e.g. height='auto'
							t.node.style[ prefix( prop ) ] = current;
						}
					}
					// If we're not actually changing anything, the transitionend event
					// will never fire! So we complete early
					if ( !changedProperties.length ) {
						resolve();
						return;
					}
					createTransitions( t, to, options, changedProperties, resolve );
				} );
				// If a callback was supplied, do the honours
				// TODO remove this check in future
				if ( complete ) {
					warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
					promise.then( complete );
				}
				return promise;
			};
		}
		return animateStyle;
	}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

	/* utils/fillGaps.js */
	var fillGaps = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		sources.forEach( function( s ) {
			for ( var key in s ) {
				if ( s.hasOwnProperty( key ) && !( key in target ) ) {
					target[ key ] = s[ key ];
				}
			}
		} );
		return target;
	};

	/* virtualdom/items/Element/Transition/prototype/processParams.js */
	var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

		return function( params, defaults ) {
			if ( typeof params === 'number' ) {
				params = {
					duration: params
				};
			} else if ( typeof params === 'string' ) {
				if ( params === 'slow' ) {
					params = {
						duration: 600
					};
				} else if ( params === 'fast' ) {
					params = {
						duration: 200
					};
				} else {
					params = {
						duration: 400
					};
				}
			} else if ( !params ) {
				params = {};
			}
			return fillGaps( {}, params, defaults );
		};
	}( fillGaps );

	/* virtualdom/items/Element/Transition/prototype/start.js */
	var virtualdom_items_Element_Transition$start = function() {

		var __export;
		__export = function Transition$start() {
			var t = this,
				node, originalStyle, completed;
			node = t.node = t.element.node;
			originalStyle = node.getAttribute( 'style' );
			// create t.complete() - we don't want this on the prototype,
			// because we don't want `this` silliness when passing it as
			// an argument
			t.complete = function( noReset ) {
				if ( completed ) {
					return;
				}
				if ( !noReset && t.isIntro ) {
					resetStyle( node, originalStyle );
				}
				node._ractive.transition = null;
				t._manager.remove( t );
				completed = true;
			};
			// If the transition function doesn't exist, abort
			if ( !t._fn ) {
				t.complete();
				return;
			}
			t._fn.apply( t.root, [ t ].concat( t.params ) );
		};

		function resetStyle( node, style ) {
			if ( style ) {
				node.setAttribute( 'style', style );
			} else {
				// Next line is necessary, to remove empty style attribute!
				// See http://stackoverflow.com/a/7167553
				node.getAttribute( 'style' );
				node.removeAttribute( 'style' );
			}
		}
		return __export;
	}();

	/* virtualdom/items/Element/Transition/_Transition.js */
	var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

		var Fragment, Transition;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Transition = function( owner, template, isIntro ) {
			this.init( owner, template, isIntro );
		};
		Transition.prototype = {
			init: init,
			start: start,
			getStyle: getStyle,
			setStyle: setStyle,
			animateStyle: animateStyle,
			processParams: processParams
		};
		return Transition;
	}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

	/* virtualdom/items/Element/prototype/render.js */
	var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

		var __export;
		var updateCss, updateScript;
		updateCss = function() {
			var node = this.node,
				content = this.fragment.toString( false );
			// IE8 has no styleSheet unless there's a type text/css
			if ( window && window.appearsToBeIELessEqual8 ) {
				node.type = 'text/css';
			}
			if ( node.styleSheet ) {
				node.styleSheet.cssText = content;
			} else {
				while ( node.hasChildNodes() ) {
					node.removeChild( node.firstChild );
				}
				node.appendChild( document.createTextNode( content ) );
			}
		};
		updateScript = function() {
			if ( !this.node.type || this.node.type === 'text/javascript' ) {
				warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
			}
			this.node.text = this.fragment.toString( false );
		};
		__export = function Element$render() {
			var this$0 = this;
			var root = this.root,
				namespace, node;
			namespace = getNamespace( this );
			node = this.node = createElement( this.name, namespace );
			// Is this a top-level node of a component? If so, we may need to add
			// a data-rvcguid attribute, for CSS encapsulation
			// NOTE: css no longer copied to instance, so we check constructor.css -
			// we can enhance to handle instance, but this is more "correct" with current
			// functionality
			if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
				this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
			}
			// Add _ractive property to the node - we use this object to store stuff
			// related to proxy events, two-way bindings etc
			defineProperty( this.node, '_ractive', {
				value: {
					proxy: this,
					keypath: getInnerContext( this.parentFragment ),
					index: this.parentFragment.indexRefs,
					events: create( null ),
					root: root
				}
			} );
			// Render attributes
			this.attributes.forEach( function( a ) {
				return a.render( node );
			} );
			this.conditionalAttributes.forEach( function( a ) {
				return a.render( node );
			} );
			// Render children
			if ( this.fragment ) {
				// Special case - <script> element
				if ( this.name === 'script' ) {
					this.bubble = updateScript;
					this.node.text = this.fragment.toString( false );
					// bypass warning initially
					this.fragment.unrender = noop;
				} else if ( this.name === 'style' ) {
					this.bubble = updateCss;
					this.bubble();
					this.fragment.unrender = noop;
				} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
					this.fragment.unrender = noop;
				} else {
					this.node.appendChild( this.fragment.render() );
				}
			}
			// Add proxy event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.render();
				} );
			}
			// deal with two-way bindings
			if ( this.binding ) {
				this.binding.render();
				this.node._ractive.binding = this.binding;
			}
			// Special case: if this is an <img>, and we're in a crap browser, we may
			// need to prevent it from overriding width and height when it loads the src
			if ( this.name === 'img' ) {
				renderImage( this );
			}
			// apply decorator(s)
			if ( this.decorator && this.decorator.fn ) {
				runloop.scheduleTask( function() {
					return this$0.decorator.init();
				}, true );
			}
			// trigger intro transition
			if ( root.transitionsEnabled && this.intro ) {
				var transition = new Transition( this, this.intro, true );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				}, true );
				this.transition = transition;
			}
			if ( this.name === 'option' ) {
				processOption( this );
			}
			if ( this.node.autofocus ) {
				// Special case. Some browsers (*cough* Firefix *cough*) have a problem
				// with dynamically-generated elements having autofocus, and they won't
				// allow you to programmatically focus the element until it's in the DOM
				runloop.scheduleTask( function() {
					return this$0.node.focus();
				}, true );
			}
			updateLiveQueries( this );
			return this.node;
		};

		function getNamespace( element ) {
			var namespace, xmlns, parent;
			// Use specified namespace...
			if ( xmlns = element.getAttribute( 'xmlns' ) ) {
				namespace = xmlns;
			} else if ( element.name === 'svg' ) {
				namespace = namespaces.svg;
			} else if ( parent = element.parent ) {
				// ...or HTML, if the parent is a <foreignObject>
				if ( parent.name === 'foreignObject' ) {
					namespace = namespaces.html;
				} else {
					namespace = parent.node.namespaceURI;
				}
			} else {
				namespace = element.root.el.namespaceURI;
			}
			return namespace;
		}

		function processOption( option ) {
			var optionValue, selectValue, i;
			if ( !option.select ) {
				return;
			}
			selectValue = option.select.getAttribute( 'value' );
			if ( selectValue === undefined ) {
				return;
			}
			optionValue = option.getAttribute( 'value' );
			if ( option.select.node.multiple && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( optionValue == selectValue[ i ] ) {
						option.node.selected = true;
						break;
					}
				}
			} else {
				option.node.selected = optionValue == selectValue;
			}
		}

		function updateLiveQueries( element ) {
			var instance, liveQueries, i, selector, query;
			// Does this need to be added to any live queries?
			instance = element.root;
			do {
				liveQueries = instance._liveQueries;
				i = liveQueries.length;
				while ( i-- ) {
					selector = liveQueries[ i ];
					query = liveQueries[ '_' + selector ];
					if ( query._test( element ) ) {
						// keep register of applicable selectors, for when we teardown
						( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
					}
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

	/* virtualdom/items/Element/prototype/toString.js */
	var virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {

		var __export;
		__export = function() {
			var str, escape;
			str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
			str += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );
			// Special case - selected options
			if ( this.name === 'option' && optionIsSelected( this ) ) {
				str += ' selected';
			}
			// Special case - two-way radio name bindings
			if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
				str += ' checked';
			}
			str += '>';
			// Special case - textarea
			if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
				str += escapeHtml( this.getAttribute( 'value' ) );
			} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
				str += this.getAttribute( 'value' );
			}
			if ( this.fragment ) {
				escape = this.name !== 'script' && this.name !== 'style';
				str += this.fragment.toString( escape );
			}
			// add a closing tag if this isn't a void element
			if ( !voidElementNames.test( this.template.e ) ) {
				str += '</' + this.template.e + '>';
			}
			return str;
		};

		function optionIsSelected( element ) {
			var optionValue, selectValue, i;
			optionValue = element.getAttribute( 'value' );
			if ( optionValue === undefined || !element.select ) {
				return false;
			}
			selectValue = element.select.getAttribute( 'value' );
			if ( selectValue == optionValue ) {
				return true;
			}
			if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
		}

		function inputIsCheckedRadio( element ) {
			var attributes, typeAttribute, valueAttribute, nameAttribute;
			attributes = element.attributes;
			typeAttribute = attributes.type;
			valueAttribute = attributes.value;
			nameAttribute = attributes.name;
			if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
				return;
			}
			if ( valueAttribute.value === nameAttribute.interpolator.value ) {
				return true;
			}
		}

		function stringifyAttribute( attribute ) {
			var str = attribute.toString();
			return str ? ' ' + str : '';
		}
		return __export;
	}( voidElementNames, isArray, escapeHtml );

	/* virtualdom/items/Element/special/option/unbind.js */
	var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

		return function unbindOption( option ) {
			if ( option.select ) {
				removeFromArray( option.select.options, option );
			}
		};
	}( removeFromArray );

	/* virtualdom/items/Element/prototype/unbind.js */
	var virtualdom_items_Element$unbind = function( unbindOption ) {

		var __export;
		__export = function Element$unbind() {
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.binding ) {
				this.binding.unbind();
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( unbind );
			}
			// Special case - <option>
			if ( this.name === 'option' ) {
				unbindOption( this );
			}
			this.attributes.forEach( unbind );
			this.conditionalAttributes.forEach( unbind );
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}( virtualdom_items_Element_special_option_unbind );

	/* virtualdom/items/Element/prototype/unrender.js */
	var virtualdom_items_Element$unrender = function( runloop, Transition ) {

		var __export;
		__export = function Element$unrender( shouldDestroy ) {
			var binding, bindings;
			if ( this.transition ) {
				this.transition.complete();
			}
			// Detach as soon as we can
			if ( this.name === 'option' ) {
				// <option> elements detach immediately, so that
				// their parent <select> element syncs correctly, and
				// since option elements can't have transitions anyway
				this.detach();
			} else if ( shouldDestroy ) {
				runloop.detachWhenReady( this );
			}
			// Children first. that way, any transitions on child elements will be
			// handled by the current transitionManager
			if ( this.fragment ) {
				this.fragment.unrender( false );
			}
			if ( binding = this.binding ) {
				this.binding.unrender();
				this.node._ractive.binding = null;
				bindings = this.root._twowayBindings[ binding.keypath ];
				bindings.splice( bindings.indexOf( binding ), 1 );
			}
			// Remove event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.unrender();
				} );
			}
			if ( this.decorator ) {
				this.decorator.teardown();
			}
			// trigger outro transition if necessary
			if ( this.root.transitionsEnabled && this.outro ) {
				var transition = new Transition( this, this.outro, false );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			// Remove this node from any live queries
			if ( this.liveQueries ) {
				removeFromLiveQueries( this );
			}
		};

		function removeFromLiveQueries( element ) {
			var query, selector, i;
			i = element.liveQueries.length;
			while ( i-- ) {
				query = element.liveQueries[ i ];
				selector = query.selector;
				query._remove( element.node );
			}
		}
		return __export;
	}( runloop, Transition );

	/* virtualdom/items/Element/_Element.js */
	var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

		var Element = function( options ) {
			this.init( options );
		};
		Element.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getAttribute: getAttribute,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Element;
	}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

	/* virtualdom/items/Partial/deIndent.js */
	var deIndent = function() {

		var __export;
		var empty = /^\s*$/,
			leadingWhitespace = /^\s*/;
		__export = function( str ) {
			var lines, firstLine, lastLine, minIndent;
			lines = str.split( '\n' );
			// remove first and last line, if they only contain whitespace
			firstLine = lines[ 0 ];
			if ( firstLine !== undefined && empty.test( firstLine ) ) {
				lines.shift();
			}
			lastLine = lines[ lines.length - 1 ];
			if ( lastLine !== undefined && empty.test( lastLine ) ) {
				lines.pop();
			}
			minIndent = lines.reduce( reducer, null );
			if ( minIndent ) {
				str = lines.map( function( line ) {
					return line.replace( minIndent, '' );
				} ).join( '\n' );
			}
			return str;
		};

		function reducer( previous, line ) {
			var lineIndent = leadingWhitespace.exec( line )[ 0 ];
			if ( previous === null || lineIndent.length < previous.length ) {
				return lineIndent;
			}
			return previous;
		}
		return __export;
	}();

	/* virtualdom/items/Partial/getPartialTemplate.js */
	var getPartialTemplate = function( log, config, parser, deIndent ) {

		var __export;
		__export = function getPartialTemplate( ractive, name ) {
			var partial;
			// If the partial in instance or view heirarchy instances, great
			if ( partial = getPartialFromRegistry( ractive, name ) ) {
				return partial;
			}
			// Does it exist on the page as a script tag?
			partial = parser.fromId( name, {
				noThrow: true
			} );
			if ( partial ) {
				// is this necessary?
				partial = deIndent( partial );
				// parse and register to this ractive instance
				var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
				// register (and return main partial if there are others in the template)
				return ractive.partials[ name ] = parsed.t;
			}
		};

		function getPartialFromRegistry( ractive, name ) {
			var partials = config.registries.partials;
			// find first instance in the ractive or view hierarchy that has this partial
			var instance = partials.findInstance( ractive, name );
			if ( !instance ) {
				return;
			}
			var partial = instance.partials[ name ],
				fn;
			// partial is a function?
			if ( typeof partial === 'function' ) {
				fn = partial.bind( instance );
				fn.isOwner = instance.partials.hasOwnProperty( name );
				partial = fn( instance.data, parser );
			}
			if ( !partial ) {
				log.warn( {
					debug: ractive.debug,
					message: 'noRegistryFunctionReturn',
					args: {
						registry: 'partial',
						name: name
					}
				} );
				return;
			}
			// If this was added manually to the registry,
			// but hasn't been parsed, parse it now
			if ( !parser.isParsed( partial ) ) {
				// use the parseOptions of the ractive instance on which it was found
				var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
				// Partials cannot contain nested partials!
				// TODO add a test for this
				if ( parsed.p ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noNestedPartials',
						args: {
							rname: name
						}
					} );
				}
				// if fn, use instance to store result, otherwise needs to go
				// in the correct point in prototype chain on instance or constructor
				var target = fn ? instance : partials.findOwner( instance, name );
				// may be a template with partials, which need to be registered and main template extracted
				target.partials[ name ] = partial = parsed.t;
			}
			// store for reset
			if ( fn ) {
				partial._fn = fn;
			}
			return partial.v ? partial.t : partial;
		}
		return __export;
	}( log, config, parser, deIndent );

	/* virtualdom/items/Partial/applyIndent.js */
	var applyIndent = function( string, indent ) {
		var indented;
		if ( !indent ) {
			return string;
		}
		indented = string.split( '\n' ).map( function( line, notFirstLine ) {
			return notFirstLine ? indent + line : line;
		} ).join( '\n' );
		return indented;
	};

	/* virtualdom/items/Partial/_Partial.js */
	var Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {

		var Partial, Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Partial = function( options ) {
			var parentFragment, template;
			parentFragment = this.parentFragment = options.parentFragment;
			this.root = parentFragment.root;
			this.type = types.PARTIAL;
			this.index = options.index;
			this.name = options.template.r;
			this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;
			Mustache.init( this, options );
			// If this didn't resolve, it most likely means we have a named partial
			// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
			// whose name is the value of `foo`')
			if ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {
				unbind.call( this );
				// prevent any further changes
				this.isNamed = true;
				this.setTemplate( template );
			}
		};
		Partial.prototype = {
			bubble: function() {
				this.parentFragment.bubble();
			},
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			findNextNode: function() {
				return this.parentFragment.findNextNode( this );
			},
			getValue: function() {
				return this.fragment.getValue();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				rebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function() {
				this.docFrag = document.createDocumentFragment();
				this.update();
				this.rendered = true;
				return this.docFrag;
			},
			resolve: Mustache.resolve,
			setValue: function( value ) {
				var template;
				if ( value !== undefined && value === this.value ) {
					// nothing has changed, so no work to be done
					return;
				}
				template = getPartialTemplate( this.root, '' + value );
				// we may be here if we have a partial like `{{>foo}}` and `foo` is the
				// name of both a data property (whose value ISN'T the name of a partial)
				// and a partial. In those cases, this becomes a named partial
				if ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {
					unbind.call( this );
					this.isNamed = true;
				}
				if ( !template ) {
					log.error( {
						debug: this.root.debug,
						message: 'noTemplateForPartial',
						args: {
							name: this.name
						}
					} );
				}
				this.setTemplate( template || [] );
				this.value = value;
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			},
			setTemplate: function( template ) {
				if ( this.fragment ) {
					this.fragment.unbind();
					this.fragmentToUnrender = this.fragment;
				}
				this.fragment = new Fragment( {
					template: template,
					root: this.root,
					owner: this,
					pElement: this.parentFragment.pElement
				} );
				this.fragmentToRender = this.fragment;
			},
			toString: function( toString ) {
				var string, previousItem, lastLine, match;
				string = this.fragment.toString( toString );
				previousItem = this.parentFragment.items[ this.index - 1 ];
				if ( !previousItem || previousItem.type !== types.TEXT ) {
					return string;
				}
				lastLine = previousItem.text.split( '\n' ).pop();
				if ( match = /^\s+$/.exec( lastLine ) ) {
					return applyIndent( string, match[ 0 ] );
				}
				return string;
			},
			unbind: function() {
				if ( !this.isNamed ) {
					// dynamic partial - need to unbind self
					unbind.call( this );
				}
				if ( this.fragment ) {
					this.fragment.unbind();
				}
			},
			unrender: function( shouldDestroy ) {
				if ( this.rendered ) {
					if ( this.fragment ) {
						this.fragment.unrender( shouldDestroy );
					}
					this.rendered = false;
				}
			},
			update: function() {
				var target, anchor;
				if ( this.fragmentToUnrender ) {
					this.fragmentToUnrender.unrender( true );
					this.fragmentToUnrender = null;
				}
				if ( this.fragmentToRender ) {
					this.docFrag.appendChild( this.fragmentToRender.render() );
					this.fragmentToRender = null;
				}
				if ( this.rendered ) {
					target = this.parentFragment.getNode();
					anchor = this.parentFragment.findNextNode( this );
					target.insertBefore( this.docFrag, anchor );
				}
			}
		};
		return Partial;
	}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );

	/* virtualdom/items/Component/getComponent.js */
	var getComponent = function( config, log, circular ) {

		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		// finds the component constructor in the registry or view hierarchy registries
		return function getComponent( ractive, name ) {
			var component, instance = config.registries.components.findInstance( ractive, name );
			if ( instance ) {
				component = instance.components[ name ];
				// best test we have for not Ractive.extend
				if ( !component._parent ) {
					// function option, execute and store for reset
					var fn = component.bind( instance );
					fn.isOwner = instance.components.hasOwnProperty( name );
					component = fn( instance.data );
					if ( !component ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noRegistryFunctionReturn',
							args: {
								registry: 'component',
								name: name
							}
						} );
						return;
					}
					if ( typeof component === 'string' ) {
						//allow string lookup
						component = getComponent( ractive, component );
					}
					component._fn = fn;
					instance.components[ name ] = component;
				}
			}
			return component;
		};
	}( config, log, circular );

	/* virtualdom/items/Component/prototype/detach.js */
	var virtualdom_items_Component$detach = function( Hook ) {

		var detachHook = new Hook( 'detach' );
		return function Component$detach() {
			var detached = this.instance.fragment.detach();
			detachHook.fire( this.instance );
			return detached;
		};
	}( Ractive$shared_hooks_Hook );

	/* virtualdom/items/Component/prototype/find.js */
	var virtualdom_items_Component$find = function Component$find( selector ) {
		return this.instance.fragment.find( selector );
	};

	/* virtualdom/items/Component/prototype/findAll.js */
	var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
		return this.instance.fragment.findAll( selector, query );
	};

	/* virtualdom/items/Component/prototype/findAllComponents.js */
	var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
		query._test( this, true );
		if ( this.instance.fragment ) {
			this.instance.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Component/prototype/findComponent.js */
	var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
		if ( !selector || selector === this.name ) {
			return this.instance;
		}
		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( selector );
		}
		return null;
	};

	/* virtualdom/items/Component/prototype/findNextNode.js */
	var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Component/prototype/firstNode.js */
	var virtualdom_items_Component$firstNode = function Component$firstNode() {
		if ( this.rendered ) {
			return this.instance.fragment.firstNode();
		}
		return null;
	};

	/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
	var ComponentParameter = function( runloop, circular ) {

		var Fragment, ComponentParameter;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		ComponentParameter = function( component, key, value ) {
			this.parentFragment = component.parentFragment;
			this.component = component;
			this.key = key;
			this.fragment = new Fragment( {
				template: value,
				root: component.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
		};
		ComponentParameter.prototype = {
			bubble: function() {
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.addView( this );
				}
			},
			update: function() {
				var value = this.fragment.getValue();
				this.component.instance.viewmodel.set( this.key, value );
				runloop.addViewmodel( this.component.instance.viewmodel );
				this.value = value;
				this.dirty = false;
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			}
		};
		return ComponentParameter;
	}( runloop, circular );

	/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */
	var ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {

		var ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {
			var this$0 = this;
			this.root = component.root;
			this.parentFragment = component.parentFragment;
			this.ready = false;
			this.hash = null;
			this.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {
				// Are we updating an existing binding?
				if ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {
					component.bindings[ this$0.hash ] = null;
					this$0.binding.rebind( keypath );
					this$0.hash = keypath + '=' + childKeypath;
					component.bindings[ this$0.hash ];
				} else {
					if ( !this$0.ready ) {
						// The child instance isn't created yet, we need to create the binding later
						toBind.push( {
							childKeypath: childKeypath,
							parentKeypath: keypath
						} );
					} else {
						createComponentBinding( component, component.root, keypath, childKeypath );
					}
				}
				this$0.value = component.root.viewmodel.get( keypath );
			} );
		};
		ReferenceExpressionParameter.prototype = {
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.resolver.unbind();
			}
		};
		return ReferenceExpressionParameter;
	}( ReferenceExpressionResolver, createComponentBinding );

	/* virtualdom/items/Component/initialise/createModel/_createModel.js */
	var createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {

		var __export;
		__export = function( component, defaultData, attributes, toBind ) {
			var data = {},
				key, value;
			// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
			// other words, we need to construct a string fragment to watch
			// when they change. We store these so they can be torn down later
			component.complexParameters = [];
			for ( key in attributes ) {
				if ( attributes.hasOwnProperty( key ) ) {
					value = getValue( component, key, attributes[ key ], toBind );
					if ( value !== undefined || defaultData[ key ] === undefined ) {
						data[ key ] = value;
					}
				}
			}
			return data;
		};

		function getValue( component, key, template, toBind ) {
			var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
			parentInstance = component.root;
			parentFragment = component.parentFragment;
			// If this is a static value, great
			if ( typeof template === 'string' ) {
				parsed = parseJSON( template );
				if ( !parsed ) {
					return template;
				}
				return parsed.value;
			}
			// If null, we treat it as a boolean attribute (i.e. true)
			if ( template === null ) {
				return true;
			}
			// Single interpolator?
			if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {
				// If it's a regular interpolator, we bind to it
				if ( template[ 0 ].r ) {
					// Is it an index reference?
					if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
						component.indexRefBindings[ indexRef ] = key;
						return parentFragment.indexRefs[ indexRef ];
					}
					// TODO what about references that resolve late? Should these be considered?
					keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
					// We need to set up bindings between parent and child, but
					// we can't do it yet because the child instance doesn't exist
					// yet - so we make a note instead
					toBind.push( {
						childKeypath: key,
						parentKeypath: keypath
					} );
					return parentInstance.viewmodel.get( keypath );
				}
				// If it's a reference expression (e.g. `{{foo[bar]}}`), we need
				// to watch the keypath and create/destroy bindings
				if ( template[ 0 ].rx ) {
					parameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );
					component.complexParameters.push( parameter );
					parameter.ready = true;
					return parameter.value;
				}
			}
			// We have a 'complex parameter' - we need to create a full-blown string
			// fragment in order to evaluate and observe its value
			parameter = new ComponentParameter( component, key, template );
			component.complexParameters.push( parameter );
			return parameter.value;
		}
		return __export;
	}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );

	/* virtualdom/items/Component/initialise/createInstance.js */
	var createInstance = function( log ) {

		return function( component, Component, data, contentDescriptor ) {
			var instance, parentFragment, partials, ractive;
			parentFragment = component.parentFragment;
			ractive = component.root;
			// Make contents available as a {{>content}} partial
			partials = {
				content: contentDescriptor || []
			};
			if ( Component.defaults.el ) {
				log.warn( {
					debug: ractive.debug,
					message: 'defaultElSpecified',
					args: {
						name: component.name
					}
				} );
			}
			instance = new Component( {
				el: null,
				append: true,
				data: data,
				partials: partials,
				magic: ractive.magic || Component.defaults.magic,
				modifyArrays: ractive.modifyArrays,
				_parent: ractive,
				_component: component,
				// need to inherit runtime parent adaptors
				adapt: ractive.adapt,
				yield: {
					template: contentDescriptor,
					instance: ractive
				}
			} );
			return instance;
		};
	}( log );

	/* virtualdom/items/Component/initialise/createBindings.js */
	var createBindings = function( createComponentBinding ) {

		return function createInitialComponentBindings( component, toBind ) {
			toBind.forEach( function createInitialComponentBinding( pair ) {
				var childValue, parentValue;
				createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
				childValue = component.instance.viewmodel.get( pair.childKeypath );
				parentValue = component.root.viewmodel.get( pair.parentKeypath );
				if ( childValue !== undefined && parentValue === undefined ) {
					component.root.viewmodel.set( pair.parentKeypath, childValue );
				}
			} );
		};
	}( createComponentBinding );

	/* virtualdom/items/Component/initialise/propagateEvents.js */
	var propagateEvents = function( circular, fireEvent, log ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function propagateEvents( component, eventsDescriptor ) {
			var eventName;
			for ( eventName in eventsDescriptor ) {
				if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
					propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
				}
			}
		};

		function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
			if ( typeof proxyEventName !== 'string' ) {
				log.error( {
					debug: parentInstance.debug,
					message: 'noComponentEventArguments'
				} );
			}
			childInstance.on( eventName, function() {
				var event, args;
				// semi-weak test, but what else? tag the event obj ._isEvent ?
				if ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {
					event = Array.prototype.shift.call( arguments );
				}
				args = Array.prototype.slice.call( arguments );
				fireEvent( parentInstance, proxyEventName, {
					event: event,
					args: args
				} );
				// cancel bubbling
				return false;
			} );
		}
		return __export;
	}( circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Component/initialise/updateLiveQueries.js */
	var updateLiveQueries = function( component ) {
		var ancestor, query;
		// If there's a live query for this component type, add it
		ancestor = component.root;
		while ( ancestor ) {
			if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
				query.push( component.instance );
			}
			ancestor = ancestor._parent;
		}
	};

	/* virtualdom/items/Component/prototype/init.js */
	var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

		return function Component$init( options, Component ) {
			var parentFragment, root, data, toBind;
			parentFragment = this.parentFragment = options.parentFragment;
			root = parentFragment.root;
			this.root = root;
			this.type = types.COMPONENT;
			this.name = options.template.e;
			this.index = options.index;
			this.indexRefBindings = {};
			this.bindings = [];
			// even though only one yielder is allowed, we need to have an array of them
			// as it's possible to cause a yielder to be created before the last one
			// was destroyed in the same turn of the runloop
			this.yielders = [];
			if ( !Component ) {
				throw new Error( 'Component "' + this.name + '" not found' );
			}
			// First, we need to create a model for the component - e.g. if we
			// encounter <widget foo='bar'/> then we need to create a widget
			// with `data: { foo: 'bar' }`.
			//
			// This may involve setting up some bindings, but we can't do it
			// yet so we take some notes instead
			toBind = [];
			data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
			createInstance( this, Component, data, options.template.f );
			createBindings( this, toBind );
			propagateEvents( this, options.template.v );
			// intro, outro and decorator directives have no effect
			if ( options.template.t1 || options.template.t2 || options.template.o ) {
				warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
			}
			updateLiveQueries( this );
		};
	}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

	/* virtualdom/items/Component/prototype/rebind.js */
	var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

		return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var childInstance = this.instance,
				parentInstance = childInstance._parent,
				indexRefAlias, query;
			this.bindings.forEach( function( binding ) {
				var updated;
				if ( binding.root !== parentInstance ) {
					return;
				}
				if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
					binding.rebind( updated );
				}
			} );
			this.complexParameters.forEach( rebind );
			if ( this.yielders[ 0 ] ) {
				rebind( this.yielders[ 0 ] );
			}
			if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
				runloop.addViewmodel( childInstance.viewmodel );
				childInstance.viewmodel.set( indexRefAlias, newIndex );
			}
			if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
				query._makeDirty();
			}

			function rebind( x ) {
				x.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( runloop, getNewKeypath );

	/* virtualdom/items/Component/prototype/render.js */
	var virtualdom_items_Component$render = function Component$render() {
		var instance = this.instance;
		instance.render( this.parentFragment.getNode() );
		this.rendered = true;
		return instance.fragment.detach();
	};

	/* virtualdom/items/Component/prototype/toString.js */
	var virtualdom_items_Component$toString = function Component$toString() {
		return this.instance.fragment.toString();
	};

	/* virtualdom/items/Component/prototype/unbind.js */
	var virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {

		var __export;
		var teardownHook = new Hook( 'teardown' );
		__export = function Component$unbind() {
			var instance = this.instance;
			this.complexParameters.forEach( unbind );
			this.bindings.forEach( unbind );
			removeFromLiveComponentQueries( this );
			// teardown the instance
			instance.fragment.unbind();
			instance.viewmodel.teardown();
			if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
				removeFromArray( instance.el.__ractive_instances__, instance );
			}
			teardownHook.fire( instance );
		};

		function unbind( thing ) {
			thing.unbind();
		}

		function removeFromLiveComponentQueries( component ) {
			var instance, query;
			instance = component.root;
			do {
				if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
					query._remove( component );
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* virtualdom/items/Component/prototype/unrender.js */
	var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
		this.shouldDestroy = shouldDestroy;
		this.instance.unrender();
	};

	/* virtualdom/items/Component/_Component.js */
	var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

		var Component = function( options, Constructor ) {
			this.init( options, Constructor );
		};
		Component.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Component;
	}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

	/* virtualdom/items/Comment.js */
	var Comment = function( types, detach ) {

		var Comment = function( options ) {
			this.type = types.COMMENT;
			this.value = options.template.c;
		};
		Comment.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createComment( this.value );
				}
				return this.node;
			},
			toString: function() {
				return '<!--' + this.value + '-->';
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					this.node.parentNode.removeChild( this.node );
				}
			}
		};
		return Comment;
	}( types, detach );

	/* virtualdom/items/Yielder.js */
	var Yielder = function( runloop, removeFromArray, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var Yielder = function( options ) {
			var componentInstance, component;
			componentInstance = options.parentFragment.root;
			this.component = component = componentInstance.component;
			this.surrogateParent = options.parentFragment;
			this.parentFragment = component.parentFragment;
			this.fragment = new Fragment( {
				owner: this,
				root: componentInstance.yield.instance,
				template: componentInstance.yield.template,
				pElement: this.surrogateParent.pElement
			} );
			component.yielders.push( this );
			runloop.scheduleTask( function() {
				if ( component.yielders.length > 1 ) {
					throw new Error( 'A component template can only have one {{yield}} declaration at a time' );
				}
			} );
		};
		Yielder.prototype = {
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			findNextNode: function() {
				return this.surrogateParent.findNextNode( this );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			getValue: function( options ) {
				return this.fragment.getValue( options );
			},
			render: function() {
				return this.fragment.render();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			unrender: function( shouldDestroy ) {
				this.fragment.unrender( shouldDestroy );
				removeFromArray( this.component.yielders, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		return Yielder;
	}( runloop, removeFromArray, circular );

	/* virtualdom/Fragment/prototype/init/createItem.js */
	var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {

		return function createItem( options ) {
			if ( typeof options.template === 'string' ) {
				return new Text( options );
			}
			switch ( options.template.t ) {
				case types.INTERPOLATOR:
					if ( options.template.r === 'yield' ) {
						return new Yielder( options );
					}
					return new Interpolator( options );
				case types.SECTION:
					return new Section( options );
				case types.TRIPLE:
					return new Triple( options );
				case types.ELEMENT:
					var constructor;
					if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
						return new Component( options, constructor );
					}
					return new Element( options );
				case types.PARTIAL:
					return new Partial( options );
				case types.COMMENT:
					return new Comment( options );
				default:
					throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
			}
		};
	}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );

	/* virtualdom/Fragment/prototype/init.js */
	var virtualdom_Fragment$init = function( types, create, createItem ) {

		return function Fragment$init( options ) {
			var this$0 = this;
			var parentFragment, parentRefs, ref;
			// The item that owns this fragment - an element, section, partial, or attribute
			this.owner = options.owner;
			parentFragment = this.parent = this.owner.parentFragment;
			// inherited properties
			this.root = options.root;
			this.pElement = options.pElement;
			this.context = options.context;
			// If parent item is a section, this may not be the only fragment
			// that belongs to it - we need to make a note of the index
			if ( this.owner.type === types.SECTION ) {
				this.index = options.index;
			}
			// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
			// down the tree
			if ( parentFragment ) {
				parentRefs = parentFragment.indexRefs;
				if ( parentRefs ) {
					this.indexRefs = create( null );
					// avoids need for hasOwnProperty
					for ( ref in parentRefs ) {
						this.indexRefs[ ref ] = parentRefs[ ref ];
					}
				}
			}
			if ( options.indexRef ) {
				if ( !this.indexRefs ) {
					this.indexRefs = {};
				}
				this.indexRefs[ options.indexRef ] = options.index;
			}
			// Time to create this fragment's child items
			// TEMP should this be happening?
			if ( typeof options.template === 'string' ) {
				options.template = [ options.template ];
			} else if ( !options.template ) {
				options.template = [];
			}
			this.items = options.template.map( function( template, i ) {
				return createItem( {
					parentFragment: this$0,
					pElement: options.pElement,
					template: template,
					index: i
				} );
			} );
			this.value = this.argsList = null;
			this.dirtyArgs = this.dirtyValue = true;
			this.bound = true;
		};
	}( types, create, virtualdom_Fragment$init_createItem );

	/* virtualdom/Fragment/prototype/rebind.js */
	var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

		return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			this.index = newIndex;
			// assign new context keypath if needed
			assignNewKeypath( this, 'context', oldKeypath, newKeypath );
			if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
				this.indexRefs[ indexRef ] = newIndex;
			}
			this.items.forEach( function( item ) {
				if ( item.rebind ) {
					item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			} );
		};
	}( assignNewKeypath );

	/* virtualdom/Fragment/prototype/render.js */
	var virtualdom_Fragment$render = function Fragment$render() {
		var result;
		if ( this.items.length === 1 ) {
			result = this.items[ 0 ].render();
		} else {
			result = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				result.appendChild( item.render() );
			} );
		}
		this.rendered = true;
		return result;
	};

	/* virtualdom/Fragment/prototype/toString.js */
	var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
		if ( !this.items ) {
			return '';
		}
		return this.items.map( function( item ) {
			return item.toString( escape );
		} ).join( '' );
	};

	/* virtualdom/Fragment/prototype/unbind.js */
	var virtualdom_Fragment$unbind = function() {

		var __export;
		__export = function Fragment$unbind() {
			if ( !this.bound ) {
				return;
			}
			this.items.forEach( unbindItem );
			this.bound = false;
		};

		function unbindItem( item ) {
			if ( item.unbind ) {
				item.unbind();
			}
		}
		return __export;
	}();

	/* virtualdom/Fragment/prototype/unrender.js */
	var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
		if ( !this.rendered ) {
			throw new Error( 'Attempted to unrender a fragment that was not rendered' );
		}
		this.items.forEach( function( i ) {
			return i.unrender( shouldDestroy );
		} );
		this.rendered = false;
	};

	/* virtualdom/Fragment.js */
	var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

		var Fragment = function( options ) {
			this.init( options );
		};
		Fragment.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getNode: getNode,
			getValue: getValue,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		circular.Fragment = Fragment;
		return Fragment;
	}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

	/* Ractive/prototype/reset.js */
	var Ractive$reset = function( Hook, runloop, Fragment, config ) {

		var shouldRerender = [
				'template',
				'partials',
				'components',
				'decorators',
				'events'
			],
			resetHook = new Hook( 'reset' );
		return function Ractive$reset( data, callback ) {
			var promise, wrapper, changes, i, rerender;
			if ( typeof data === 'function' && !callback ) {
				callback = data;
				data = {};
			} else {
				data = data || {};
			}
			if ( typeof data !== 'object' ) {
				throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
			}
			// If the root object is wrapped, try and use the wrapper's reset value
			if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
				if ( wrapper.reset( data ) === false ) {
					// reset was rejected, we need to replace the object
					this.data = data;
				}
			} else {
				this.data = data;
			}
			// reset config items and track if need to rerender
			changes = config.reset( this );
			i = changes.length;
			while ( i-- ) {
				if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
					rerender = true;
					break;
				}
			}
			if ( rerender ) {
				var component;
				this.viewmodel.mark( '' );
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// If the template changed, we need to destroy the parallel DOM
				// TODO if we're here, presumably it did?
				if ( this.fragment.template !== this.template ) {
					this.fragment.unbind();
					this.fragment = new Fragment( {
						template: this.template,
						root: this,
						owner: this
					} );
				}
				promise = this.render( this.el, this.anchor );
			} else {
				promise = runloop.start( this, true );
				this.viewmodel.mark( '' );
				runloop.end();
			}
			resetHook.fire( this, data );
			if ( callback ) {
				promise.then( callback );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop, Fragment, config );

	/* Ractive/prototype/resetTemplate.js */
	var Ractive$resetTemplate = function( config, Fragment ) {

		return function Ractive$resetTemplate( template ) {
			var transitionsEnabled, component;
			config.template.init( null, this, {
				template: template
			} );
			transitionsEnabled = this.transitionsEnabled;
			this.transitionsEnabled = false;
			// Is this is a component, we need to set the `shouldDestroy`
			// flag, otherwise it will assume by default that a parent node
			// will be detached, and therefore it doesn't need to bother
			// detaching its own nodes
			if ( component = this.component ) {
				component.shouldDestroy = true;
			}
			this.unrender();
			if ( component ) {
				component.shouldDestroy = false;
			}
			// remove existing fragment and create new one
			this.fragment.unbind();
			this.fragment = new Fragment( {
				template: this.template,
				root: this,
				owner: this
			} );
			this.render( this.el, this.anchor );
			this.transitionsEnabled = transitionsEnabled;
		};
	}( config, Fragment );

	/* Ractive/prototype/reverse.js */
	var Ractive$reverse = function( makeArrayMethod ) {

		return makeArrayMethod( 'reverse' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/set.js */
	var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

		var wildcard = /\*/;
		return function Ractive$set( keypath, value, callback ) {
			var this$0 = this;
			var map, promise;
			promise = runloop.start( this, true );
			// Set multiple keypaths in one go
			if ( isObject( keypath ) ) {
				map = keypath;
				callback = value;
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						value = map[ keypath ];
						keypath = normaliseKeypath( keypath );
						this.viewmodel.set( keypath, value );
					}
				}
			} else {
				keypath = normaliseKeypath( keypath );
				if ( wildcard.test( keypath ) ) {
					getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
						this$0.viewmodel.set( keypath, value );
					} );
				} else {
					this.viewmodel.set( keypath, value );
				}
			}
			runloop.end();
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

	/* Ractive/prototype/shift.js */
	var Ractive$shift = function( makeArrayMethod ) {

		return makeArrayMethod( 'shift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/sort.js */
	var Ractive$sort = function( makeArrayMethod ) {

		return makeArrayMethod( 'sort' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/splice.js */
	var Ractive$splice = function( makeArrayMethod ) {

		return makeArrayMethod( 'splice' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/subtract.js */
	var Ractive$subtract = function( add ) {

		return function Ractive$subtract( keypath, d ) {
			return add( this, keypath, d === undefined ? -1 : -d );
		};
	}( Ractive$shared_add );

	/* Ractive/prototype/teardown.js */
	var Ractive$teardown = function( Hook, Promise, removeFromArray ) {

		var teardownHook = new Hook( 'teardown' );
		// Teardown. This goes through the root fragment and all its children, removing observers
		// and generally cleaning up after itself
		return function Ractive$teardown( callback ) {
			var promise;
			this.fragment.unbind();
			this.viewmodel.teardown();
			if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.shouldDestroy = true;
			promise = this.fragment.rendered ? this.unrender() : Promise.resolve();
			teardownHook.fire( this );
			if ( callback ) {
				// TODO deprecate this?
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, Promise, removeFromArray );

	/* Ractive/prototype/toggle.js */
	var Ractive$toggle = function( log ) {

		return function Ractive$toggle( keypath, callback ) {
			var value;
			if ( typeof keypath !== 'string' ) {
				log.errorOnly( {
					debug: this.debug,
					messsage: 'badArguments',
					arg: {
						arguments: keypath
					}
				} );
			}
			value = this.get( keypath );
			return this.set( keypath, !value, callback );
		};
	}( log );

	/* Ractive/prototype/toHTML.js */
	var Ractive$toHTML = function Ractive$toHTML() {
		return this.fragment.toString( true );
	};

	/* Ractive/prototype/unrender.js */
	var Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {

		var unrenderHook = new Hook( 'unrender' );
		return function Ractive$unrender() {
			var this$0 = this;
			var promise, shouldDestroy;
			if ( !this.fragment.rendered ) {
				log.warn( {
					debug: this.debug,
					message: 'ractive.unrender() was called on a Ractive instance that was not rendered'
				} );
				return Promise.resolve();
			}
			promise = runloop.start( this, true );
			// If this is a component, and the component isn't marked for destruction,
			// don't detach nodes from the DOM unnecessarily
			shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
			if ( this.constructor.css ) {
				promise.then( function() {
					css.remove( this$0.constructor );
				} );
			}
			// Cancel any animations in progress
			while ( this._animations[ 0 ] ) {
				this._animations[ 0 ].stop();
			}
			this.fragment.unrender( shouldDestroy );
			removeFromArray( this.el.__ractive_instances__, this );
			unrenderHook.fire( this );
			runloop.end();
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );

	/* Ractive/prototype/unshift.js */
	var Ractive$unshift = function( makeArrayMethod ) {

		return makeArrayMethod( 'unshift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/update.js */
	var Ractive$update = function( Hook, runloop ) {

		var updateHook = new Hook( 'update' );
		return function Ractive$update( keypath, callback ) {
			var promise;
			if ( typeof keypath === 'function' ) {
				callback = keypath;
				keypath = '';
			} else {
				keypath = keypath || '';
			}
			promise = runloop.start( this, true );
			this.viewmodel.mark( keypath );
			runloop.end();
			updateHook.fire( this, keypath );
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop );

	/* Ractive/prototype/updateModel.js */
	var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

		var __export;
		__export = function Ractive$updateModel( keypath, cascade ) {
			var values;
			if ( typeof keypath !== 'string' ) {
				keypath = '';
				cascade = true;
			}
			consolidateChangedValues( this, keypath, values = {}, cascade );
			return this.set( values );
		};

		function consolidateChangedValues( ractive, keypath, values, cascade ) {
			var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
			bindings = ractive._twowayBindings[ keypath ];
			if ( bindings && ( i = bindings.length ) ) {
				while ( i-- ) {
					binding = bindings[ i ];
					// special case - radio name bindings
					if ( binding.radioName && !binding.element.node.checked ) {
						continue;
					}
					// special case - checkbox name bindings come in groups, so
					// we want to get the value once at most
					if ( binding.checkboxName ) {
						if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
							checkboxGroups.push( binding.keypath );
							checkboxGroups[ binding.keypath ] = binding;
						}
						continue;
					}
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( arrayContentsMatch( oldValue, newValue ) ) {
						continue;
					}
					if ( !isEqual( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				}
			}
			// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
			if ( checkboxGroups.length ) {
				checkboxGroups.forEach( function( keypath ) {
					var binding, oldValue, newValue;
					binding = checkboxGroups[ keypath ];
					// one to represent the entire group
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( !arrayContentsMatch( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				} );
			}
			if ( !cascade ) {
				return;
			}
			// cascade
			childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
			if ( childDeps ) {
				i = childDeps.length;
				while ( i-- ) {
					consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
				}
			}
		}
		return __export;
	}( arrayContentsMatch, isEqual );

	/* Ractive/prototype.js */
	var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

		return {
			add: add,
			animate: animate,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			fire: fire,
			get: get,
			insert: insert,
			merge: merge,
			observe: observe,
			off: off,
			on: on,
			pop: pop,
			push: push,
			render: render,
			reset: reset,
			resetTemplate: resetTemplate,
			reverse: reverse,
			set: set,
			shift: shift,
			sort: sort,
			splice: splice,
			subtract: subtract,
			teardown: teardown,
			toggle: toggle,
			toHTML: toHTML,
			unrender: unrender,
			unshift: unshift,
			update: update,
			updateModel: updateModel
		};
	}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

	/* utils/getGuid.js */
	var getGuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
			var r, v;
			r = Math.random() * 16 | 0;
			v = c == 'x' ? r : r & 3 | 8;
			return v.toString( 16 );
		} );
	};

	/* utils/getNextNumber.js */
	var getNextNumber = function() {

		var i = 0;
		return function() {
			return 'r-' + i++;
		};
	}();

	/* Ractive/prototype/shared/hooks/HookQueue.js */
	var Ractive$shared_hooks_HookQueue = function( Hook ) {

		function HookQueue( event ) {
			this.hook = new Hook( event );
			this.inProcess = {};
			this.queue = {};
		}
		HookQueue.prototype = {
			constructor: HookQueue,
			begin: function( ractive ) {
				this.inProcess[ ractive._guid ] = true;
			},
			end: function( ractive ) {
				var parent = ractive._parent;
				// If this is *isn't* a child of a component that's in process,
				// it should call methods or fire at this point
				if ( !parent || !this.inProcess[ parent._guid ] ) {
					fire( this, ractive );
				} else {
					getChildQueue( this.queue, parent ).push( ractive );
				}
				delete this.inProcess[ ractive._guid ];
			}
		};

		function getChildQueue( queue, ractive ) {
			return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
		}

		function fire( hookQueue, ractive ) {
			var childQueue = getChildQueue( hookQueue.queue, ractive );
			hookQueue.hook.fire( ractive );
			// queue is "live" because components can end up being
			// added while hooks fire on parents that modify data values.
			while ( childQueue.length ) {
				fire( hookQueue, childQueue.shift() );
			}
			delete hookQueue.queue[ ractive._guid ];
		}
		return HookQueue;
	}( Ractive$shared_hooks_Hook );

	/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
	var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {
		var root = wrapper.root,
			keypath = wrapper.keypath;
		// If this is a sort or reverse, we just do root.set()...
		// TODO use merge logic?
		if ( methodName === 'sort' || methodName === 'reverse' ) {
			root.viewmodel.set( keypath, array );
			return;
		}
		root.viewmodel.smartUpdate( keypath, array, newIndices );
	};

	/* viewmodel/prototype/get/arrayAdaptor/patch.js */
	var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {

		var patchedArrayProto = [],
			mutatorMethods = [
				'pop',
				'push',
				'reverse',
				'shift',
				'sort',
				'splice',
				'unshift'
			],
			testObj, patchArrayMethods, unpatchArrayMethods;
		mutatorMethods.forEach( function( methodName ) {
			var method = function() {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 0 );
				var newIndices, result, wrapper, i;
				newIndices = getNewIndices( this, methodName, args );
				// apply the underlying method
				result = Array.prototype[ methodName ].apply( this, arguments );
				// trigger changes
				runloop.start();
				this._ractive.setting = true;
				i = this._ractive.wrappers.length;
				while ( i-- ) {
					wrapper = this._ractive.wrappers[ i ];
					runloop.addViewmodel( wrapper.root.viewmodel );
					processWrapper( wrapper, this, methodName, newIndices );
				}
				runloop.end();
				this._ractive.setting = false;
				return result;
			};
			defineProperty( patchedArrayProto, methodName, {
				value: method
			} );
		} );
		// can we use prototype chain injection?
		// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
		testObj = {};
		if ( testObj.__proto__ ) {
			// yes, we can
			patchArrayMethods = function( array ) {
				array.__proto__ = patchedArrayProto;
			};
			unpatchArrayMethods = function( array ) {
				array.__proto__ = Array.prototype;
			};
		} else {
			// no, we can't
			patchArrayMethods = function( array ) {
				var i, methodName;
				i = mutatorMethods.length;
				while ( i-- ) {
					methodName = mutatorMethods[ i ];
					defineProperty( array, methodName, {
						value: patchedArrayProto[ methodName ],
						configurable: true
					} );
				}
			};
			unpatchArrayMethods = function( array ) {
				var i;
				i = mutatorMethods.length;
				while ( i-- ) {
					delete array[ mutatorMethods[ i ] ];
				}
			};
		}
		patchArrayMethods.unpatch = unpatchArrayMethods;
		return patchArrayMethods;
	}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );

	/* viewmodel/prototype/get/arrayAdaptor.js */
	var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

		var arrayAdaptor,
			// helpers
			ArrayWrapper, errorMessage;
		arrayAdaptor = {
			filter: function( object ) {
				// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
				// or the array didn't trigger the get() itself
				return isArray( object ) && ( !object._ractive || !object._ractive.setting );
			},
			wrap: function( ractive, array, keypath ) {
				return new ArrayWrapper( ractive, array, keypath );
			}
		};
		ArrayWrapper = function( ractive, array, keypath ) {
			this.root = ractive;
			this.value = array;
			this.keypath = keypath;
			// if this array hasn't already been ractified, ractify it
			if ( !array._ractive ) {
				// define a non-enumerable _ractive property to store the wrappers
				defineProperty( array, '_ractive', {
					value: {
						wrappers: [],
						instances: [],
						setting: false
					},
					configurable: true
				} );
				patch( array );
			}
			// store the ractive instance, so we can handle transitions later
			if ( !array._ractive.instances[ ractive._guid ] ) {
				array._ractive.instances[ ractive._guid ] = 0;
				array._ractive.instances.push( ractive );
			}
			array._ractive.instances[ ractive._guid ] += 1;
			array._ractive.wrappers.push( this );
		};
		ArrayWrapper.prototype = {
			get: function() {
				return this.value;
			},
			teardown: function() {
				var array, storage, wrappers, instances, index;
				array = this.value;
				storage = array._ractive;
				wrappers = storage.wrappers;
				instances = storage.instances;
				// if teardown() was invoked because we're clearing the cache as a result of
				// a change that the array itself triggered, we can save ourselves the teardown
				// and immediate setup
				if ( storage.setting ) {
					return false;
				}
				index = wrappers.indexOf( this );
				if ( index === -1 ) {
					throw new Error( errorMessage );
				}
				wrappers.splice( index, 1 );
				// if nothing else depends on this array, we can revert it to its
				// natural state
				if ( !wrappers.length ) {
					delete array._ractive;
					patch.unpatch( this.value );
				} else {
					// remove ractive instance if possible
					instances[ this.root._guid ] -= 1;
					if ( !instances[ this.root._guid ] ) {
						index = instances.indexOf( this.root );
						if ( index === -1 ) {
							throw new Error( errorMessage );
						}
						instances.splice( index, 1 );
					}
				}
			}
		};
		errorMessage = 'Something went wrong in a rather interesting way';
		return arrayAdaptor;
	}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

	/* viewmodel/prototype/get/magicArrayAdaptor.js */
	var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

		var magicArrayAdaptor, MagicArrayWrapper;
		if ( magicAdaptor ) {
			magicArrayAdaptor = {
				filter: function( object, keypath, ractive ) {
					return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
				},
				wrap: function( ractive, array, keypath ) {
					return new MagicArrayWrapper( ractive, array, keypath );
				}
			};
			MagicArrayWrapper = function( ractive, array, keypath ) {
				this.value = array;
				this.magic = true;
				this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
				this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
			};
			MagicArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					this.arrayWrapper.teardown();
					this.magicWrapper.teardown();
				},
				reset: function( value ) {
					return this.magicWrapper.reset( value );
				}
			};
		}
		return magicArrayAdaptor;
	}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

	/* viewmodel/prototype/adapt.js */
	var viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {

		var __export;
		var prefixers = {};
		__export = function Viewmodel$adapt( keypath, value ) {
			var ractive = this.ractive,
				len, i, adaptor, wrapped;
			// Do we have an adaptor for this value?
			len = ractive.adapt.length;
			for ( i = 0; i < len; i += 1 ) {
				adaptor = ractive.adapt[ i ];
				// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
				// we need to get the actual adaptor if that's the case
				if ( typeof adaptor === 'string' ) {
					var found = config.registries.adaptors.find( ractive, adaptor );
					if ( !found ) {
						// will throw. "return" for safety, if we downgrade :)
						return log.critical( {
							debug: ractive.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'adaptor',
								name: adaptor
							}
						} );
					}
					adaptor = ractive.adapt[ i ] = found;
				}
				if ( adaptor.filter( value, keypath, ractive ) ) {
					wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
					wrapped.value = value;
					return value;
				}
			}
			if ( ractive.magic ) {
				if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
				} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
				}
			} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
				this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
			}
			return value;
		};

		function prefixKeypath( obj, prefix ) {
			var prefixed = {},
				key;
			if ( !prefix ) {
				return obj;
			}
			prefix += '.';
			for ( key in obj ) {
				if ( obj.hasOwnProperty( key ) ) {
					prefixed[ prefix + key ] = obj[ key ];
				}
			}
			return prefixed;
		}

		function getPrefixer( rootKeypath ) {
			var rootDot;
			if ( !prefixers[ rootKeypath ] ) {
				rootDot = rootKeypath ? rootKeypath + '.' : '';
				prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
					var obj;
					if ( typeof relativeKeypath === 'string' ) {
						obj = {};
						obj[ rootDot + relativeKeypath ] = value;
						return obj;
					}
					if ( typeof relativeKeypath === 'object' ) {
						// 'relativeKeypath' is in fact a hash, not a keypath
						return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
					}
				};
			}
			return prefixers[ rootKeypath ];
		}
		return __export;
	}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

	/* viewmodel/helpers/getUpstreamChanges.js */
	var getUpstreamChanges = function getUpstreamChanges( changes ) {
		var upstreamChanges = [ '' ],
			i, keypath, keys, upstreamKeypath;
		i = changes.length;
		while ( i-- ) {
			keypath = changes[ i ];
			keys = keypath.split( '.' );
			while ( keys.length > 1 ) {
				keys.pop();
				upstreamKeypath = keys.join( '.' );
				if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
					upstreamChanges.push( upstreamKeypath );
				}
			}
		}
		return upstreamChanges;
	};

	/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
	var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, result;
			keys = keypath.split( '.' );
			starMap = getStarMap( keys.length );
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			result = starMap.map( function( mask ) {
				return mask.map( mapper ).join( '.' );
			} );
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( length ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ length ] ) {
				starMap = [];
				while ( ones.length < length ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < length ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ length ] = starMap;
			}
			return starMaps[ length ];
		}
		return __export;
	}();

	/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
	var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

		var __export;
		var lastKey = /[^\.]+$/;
		__export = notifyPatternObservers;

		function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
			var potentialWildcardMatches;
			updateMatchingPatternObservers( viewmodel, keypath );
			if ( onlyDirect ) {
				return;
			}
			potentialWildcardMatches = getPotentialWildcardMatches( keypath );
			potentialWildcardMatches.forEach( function( upstreamPattern ) {
				cascade( viewmodel, upstreamPattern, keypath );
			} );
		}

		function cascade( viewmodel, upstreamPattern, keypath ) {
			var group, map, actualChildKeypath;
			group = viewmodel.depsMap.patternObservers;
			map = group[ upstreamPattern ];
			if ( map ) {
				map.forEach( function( childKeypath ) {
					var key = lastKey.exec( childKeypath )[ 0 ];
					// 'baz'
					actualChildKeypath = keypath ? keypath + '.' + key : key;
					// 'foo.bar.baz'
					updateMatchingPatternObservers( viewmodel, actualChildKeypath );
					cascade( viewmodel, childKeypath, actualChildKeypath );
				} );
			}
		}

		function updateMatchingPatternObservers( viewmodel, keypath ) {
			viewmodel.patternObservers.forEach( function( observer ) {
				if ( observer.regex.test( keypath ) ) {
					observer.update( keypath );
				}
			} );
		}
		return __export;
	}( viewmodel$applyChanges_getPotentialWildcardMatches );

	/* viewmodel/prototype/applyChanges.js */
	var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

		var __export;
		__export = function Viewmodel$applyChanges() {
			var this$0 = this;
			var self = this,
				changes, upstreamChanges, hash = {};
			changes = this.changes;
			if ( !changes.length ) {
				// TODO we end up here on initial render. Perhaps we shouldn't?
				return;
			}

			function cascade( keypath ) {
				var map, dependants, keys;
				if ( self.noCascade.hasOwnProperty( keypath ) ) {
					return;
				}
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
				if ( map = self.depsMap.computed[ keypath ] ) {
					map.forEach( cascade );
				}
			}

			function mark( keypath ) {
				self.mark( keypath );
			}
			changes.forEach( cascade );
			upstreamChanges = getUpstreamChanges( changes );
			upstreamChanges.forEach( function( keypath ) {
				var dependants, keys;
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
			} );
			this.changes = [];
			// Pattern observers are a weird special case
			if ( this.patternObservers.length ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath, true );
				} );
				changes.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath );
				} );
			}
			if ( this.deps.observers ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, null, keypath, 'observers' );
				} );
				notifyAllDependants( this, changes, 'observers' );
			}
			if ( this.deps[ 'default' ] ) {
				var bindings = [];
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, bindings, keypath, 'default' );
				} );
				if ( bindings.length ) {
					notifyBindings( this, bindings, changes );
				}
				notifyAllDependants( this, changes, 'default' );
			}
			// Return a hash of keypaths to updated values
			changes.forEach( function( keypath ) {
				hash[ keypath ] = this$0.get( keypath );
			} );
			this.implicitChanges = {};
			this.noCascade = {};
			return hash;
		};

		function invalidate( computation ) {
			computation.invalidate();
		}

		function getKey( computation ) {
			return computation.key;
		}

		function notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {
			var dependants, value;
			if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
				value = viewmodel.get( keypath );
				dependants.forEach( function( d ) {
					// don't "set" the parent value, refine it
					// i.e. not data = value, but data[foo] = fooValue
					if ( bindings && d.refineValue ) {
						bindings.push( d );
					} else {
						d.setValue( value );
					}
				} );
			}
		}

		function notifyBindings( viewmodel, bindings, changes ) {
			bindings.forEach( function( binding ) {
				var useSet = false,
					i = 0,
					length = changes.length,
					refinements = [];
				while ( i < length ) {
					var keypath = changes[ i ];
					if ( keypath === binding.keypath ) {
						useSet = true;
						break;
					}
					if ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {
						refinements.push( keypath );
					}
					i++;
				}
				if ( useSet ) {
					binding.setValue( viewmodel.get( binding.keypath ) );
				}
				if ( refinements.length ) {
					binding.refineValue( refinements );
				}
			} );
		}

		function notifyAllDependants( viewmodel, keypaths, groupName ) {
			var queue = [];
			addKeypaths( keypaths );
			queue.forEach( dispatch );

			function addKeypaths( keypaths ) {
				keypaths.forEach( addKeypath );
				keypaths.forEach( cascade );
			}

			function addKeypath( keypath ) {
				var deps = findDependants( viewmodel, keypath, groupName );
				if ( deps ) {
					queue.push( {
						keypath: keypath,
						deps: deps
					} );
				}
			}

			function cascade( keypath ) {
				var childDeps;
				if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
					addKeypaths( childDeps );
				}
			}

			function dispatch( set ) {
				var value = viewmodel.get( set.keypath );
				set.deps.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function findDependants( viewmodel, keypath, groupName ) {
			var group = viewmodel.deps[ groupName ];
			return group ? group[ keypath ] : null;
		}
		return __export;
	}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

	/* viewmodel/prototype/capture.js */
	var viewmodel$capture = function Viewmodel$capture() {
		this.captureGroups.push( [] );
	};

	/* viewmodel/prototype/clearCache.js */
	var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
		var cacheMap, wrapper;
		if ( !dontTeardownWrapper ) {
			// Is there a wrapped property at this keypath?
			if ( wrapper = this.wrapped[ keypath ] ) {
				// Did we unwrap it?
				if ( wrapper.teardown() !== false ) {
					// Is this right?
					// What's the meaning of returning false from teardown?
					// Could there be a GC ramification if this is a "real" ractive.teardown()?
					this.wrapped[ keypath ] = null;
				}
			}
		}
		this.cache[ keypath ] = undefined;
		if ( cacheMap = this.cacheMap[ keypath ] ) {
			while ( cacheMap.length ) {
				this.clearCache( cacheMap.pop() );
			}
		}
	};

	/* viewmodel/Computation/getComputationSignature.js */
	var getComputationSignature = function() {

		var __export;
		var pattern = /\$\{([^\}]+)\}/g;
		__export = function( signature ) {
			if ( typeof signature === 'function' ) {
				return {
					get: signature
				};
			}
			if ( typeof signature === 'string' ) {
				return {
					get: createFunctionFromString( signature )
				};
			}
			if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
				signature = {
					get: createFunctionFromString( signature.get ),
					set: signature.set
				};
			}
			return signature;
		};

		function createFunctionFromString( signature ) {
			var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
				return '__ractive.get("' + keypath + '")';
			} ) + ')';
			return new Function( functionBody );
		}
		return __export;
	}();

	/* viewmodel/Computation/Computation.js */
	var Computation = function( log, isEqual ) {

		var Computation = function( ractive, key, signature ) {
			var this$0 = this;
			this.ractive = ractive;
			this.viewmodel = ractive.viewmodel;
			this.key = key;
			this.getter = signature.get;
			this.setter = signature.set;
			this.hardDeps = signature.deps || [];
			this.softDeps = [];
			this.depValues = {};
			if ( this.hardDeps ) {
				this.hardDeps.forEach( function( d ) {
					return ractive.viewmodel.register( d, this$0, 'computed' );
				} );
			}
			this._dirty = this._firstRun = true;
		};
		Computation.prototype = {
			constructor: Computation,
			init: function() {
				var initial;
				this.bypass = true;
				initial = this.ractive.viewmodel.get( this.key );
				this.ractive.viewmodel.clearCache( this.key );
				this.bypass = false;
				if ( this.setter && initial !== undefined ) {
					this.set( initial );
				}
			},
			invalidate: function() {
				this._dirty = true;
			},
			get: function() {
				var this$0 = this;
				var ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;
				if ( this.getting ) {
					// prevent double-computation (e.g. caused by array mutation inside computation)
					return;
				}
				this.getting = true;
				if ( this._dirty ) {
					ractive = this.ractive;
					// determine whether the inputs have changed, in case this depends on
					// other computed values
					if ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {
						dependencyValuesChanged = true;
					} else {
						[
							this.hardDeps,
							this.softDeps
						].forEach( function( deps ) {
							var keypath, value, i;
							if ( dependencyValuesChanged ) {
								return;
							}
							i = deps.length;
							while ( i-- ) {
								keypath = deps[ i ];
								value = ractive.viewmodel.get( keypath );
								if ( !isEqual( value, this$0.depValues[ keypath ] ) ) {
									this$0.depValues[ keypath ] = value;
									dependencyValuesChanged = true;
									return;
								}
							}
						} );
					}
					if ( dependencyValuesChanged ) {
						ractive.viewmodel.capture();
						try {
							this.value = this.getter.call( ractive );
						} catch ( err ) {
							log.warn( {
								debug: ractive.debug,
								message: 'failedComputation',
								args: {
									key: this.key,
									err: err.message || err
								}
							} );
							this.value = void 0;
						}
						newDeps = ractive.viewmodel.release();
						dependenciesChanged = this.updateDependencies( newDeps );
						if ( dependenciesChanged ) {
							[
								this.hardDeps,
								this.softDeps
							].forEach( function( deps ) {
								deps.forEach( function( keypath ) {
									this$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );
								} );
							} );
						}
					}
					this._dirty = false;
				}
				this.getting = this._firstRun = false;
				return this.value;
			},
			set: function( value ) {
				if ( this.setting ) {
					this.value = value;
					return;
				}
				if ( !this.setter ) {
					throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
				}
				this.setter.call( this.ractive, value );
			},
			updateDependencies: function( newDeps ) {
				var i, oldDeps, keypath, dependenciesChanged;
				oldDeps = this.softDeps;
				// remove dependencies that are no longer used
				i = oldDeps.length;
				while ( i-- ) {
					keypath = oldDeps[ i ];
					if ( newDeps.indexOf( keypath ) === -1 ) {
						dependenciesChanged = true;
						this.viewmodel.unregister( keypath, this, 'computed' );
					}
				}
				// create references for any new dependencies
				i = newDeps.length;
				while ( i-- ) {
					keypath = newDeps[ i ];
					if ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {
						dependenciesChanged = true;
						this.viewmodel.register( keypath, this, 'computed' );
					}
				}
				if ( dependenciesChanged ) {
					this.softDeps = newDeps.slice();
				}
				return dependenciesChanged;
			}
		};
		return Computation;
	}( log, isEqual );

	/* viewmodel/prototype/compute.js */
	var viewmodel$compute = function( getComputationSignature, Computation ) {

		return function Viewmodel$compute( key, signature ) {
			signature = getComputationSignature( signature );
			return this.computations[ key ] = new Computation( this.ractive, key, signature );
		};
	}( getComputationSignature, Computation );

	/* viewmodel/prototype/get/FAILED_LOOKUP.js */
	var viewmodel$get_FAILED_LOOKUP = {
		FAILED_LOOKUP: true
	};

	/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
	var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

		var empty = {};
		var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
			this.viewmodel = viewmodel;
			this.root = viewmodel.ractive;
			// TODO eliminate this
			this.ref = keypath;
			this.parentFragment = empty;
			viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
			viewmodel.unresolvedImplicitDependencies.push( this );
			runloop.addUnresolved( this );
		};
		UnresolvedImplicitDependency.prototype = {
			resolve: function() {
				this.viewmodel.mark( this.ref );
				this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
				removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
			},
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return UnresolvedImplicitDependency;
	}( removeFromArray, runloop );

	/* viewmodel/prototype/get.js */
	var viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {

		var __export;
		var empty = {};
		__export = function Viewmodel$get( keypath ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = empty;
			var ractive = this.ractive,
				cache = this.cache,
				value, computation, wrapped, captureGroup;
			if ( keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				return isNumeric( value ) ? +value : value;
			}
			if ( cache[ keypath ] === undefined ) {
				// Is this a computed property?
				if ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {
					value = computation.get();
					this.adapt( keypath, value );
				} else if ( wrapped = this.wrapped[ keypath ] ) {
					value = wrapped.value;
				} else if ( !keypath ) {
					this.adapt( '', ractive.data );
					value = ractive.data;
				} else {
					value = retrieve( this, keypath );
				}
				cache[ keypath ] = value;
			} else {
				value = cache[ keypath ];
			}
			if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
				value = wrapped.get();
			}
			// capture the keypath, if we're inside a computation
			if ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {
				if ( !~captureGroup.indexOf( keypath ) ) {
					captureGroup.push( keypath );
					// if we couldn't resolve the keypath, we need to make it as a failed
					// lookup, so that the computation updates correctly once we CAN
					// resolve the keypath
					if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
						new UnresolvedImplicitDependency( this, keypath );
					}
				}
			}
			return value === FAILED_LOOKUP ? void 0 : value;
		};

		function retrieve( viewmodel, keypath ) {
			var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
			keys = keypath.split( '.' );
			key = keys.pop();
			parentKeypath = keys.join( '.' );
			parentValue = viewmodel.get( parentKeypath );
			if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
				parentValue = wrapped.get();
			}
			if ( parentValue === null || parentValue === undefined ) {
				return;
			}
			// update cache map
			if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
				viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
			} else {
				if ( cacheMap.indexOf( keypath ) === -1 ) {
					cacheMap.push( keypath );
				}
			}
			// If this property doesn't exist, we return a sentinel value
			// so that we know to query parent scope (if such there be)
			if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
				return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
			}
			value = parentValue[ key ];
			// Do we have an adaptor for this value?
			viewmodel.adapt( keypath, value, false );
			// Update cache
			viewmodel.cache[ keypath ] = value;
			return value;
		}
		return __export;
	}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

	/* viewmodel/prototype/init.js */
	var viewmodel$init = function() {

		var __export;
		__export = function Viewmodel$init() {
			var key, computation, computations = [];
			for ( key in this.ractive.computed ) {
				computation = this.compute( key, this.ractive.computed[ key ] );
				computations.push( computation );
			}
			computations.forEach( init );
		};

		function init( computation ) {
			computation.init();
		}
		return __export;
	}();

	/* viewmodel/prototype/mark.js */
	var viewmodel$mark = function Viewmodel$mark( keypath, options ) {
		var computation;
		// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
		// should not be picked up by pattern observers
		if ( options ) {
			if ( options.implicit ) {
				this.implicitChanges[ keypath ] = true;
			}
			if ( options.noCascade ) {
				this.noCascade[ keypath ] = true;
			}
		}
		if ( computation = this.computations[ keypath ] ) {
			computation.invalidate();
		}
		if ( this.changes.indexOf( keypath ) === -1 ) {
			this.changes.push( keypath );
		}
		this.clearCache( keypath );
	};

	/* viewmodel/prototype/merge/mapOldToNewIndex.js */
	var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
		var usedIndices, firstUnusedIndex, newIndices, changed;
		usedIndices = {};
		firstUnusedIndex = 0;
		newIndices = oldArray.map( function( item, i ) {
			var index, start, len;
			start = firstUnusedIndex;
			len = newArray.length;
			do {
				index = newArray.indexOf( item, start );
				if ( index === -1 ) {
					changed = true;
					return -1;
				}
				start = index + 1;
			} while ( usedIndices[ index ] && start < len );
			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			if ( index !== i ) {
				changed = true;
			}
			usedIndices[ index ] = true;
			return index;
		} );
		return newIndices;
	};

	/* viewmodel/prototype/merge.js */
	var viewmodel$merge = function( warn, mapOldToNewIndex ) {

		var __export;
		var comparators = {};
		__export = function Viewmodel$merge( keypath, currentArray, array, options ) {
			var oldArray, newArray, comparator, newIndices;
			this.mark( keypath );
			if ( options && options.compare ) {
				comparator = getComparatorFunction( options.compare );
				try {
					oldArray = currentArray.map( comparator );
					newArray = array.map( comparator );
				} catch ( err ) {
					// fallback to an identity check - worst case scenario we have
					// to do more DOM manipulation than we thought...
					// ...unless we're in debug mode of course
					if ( this.debug ) {
						throw err;
					} else {
						warn( 'Merge operation: comparison failed. Falling back to identity checking' );
					}
					oldArray = currentArray;
					newArray = array;
				}
			} else {
				oldArray = currentArray;
				newArray = array;
			}
			// find new indices for members of oldArray
			newIndices = mapOldToNewIndex( oldArray, newArray );
			this.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );
		};

		function stringify( item ) {
			return JSON.stringify( item );
		}

		function getComparatorFunction( comparator ) {
			// If `compare` is `true`, we use JSON.stringify to compare
			// objects that are the same shape, but non-identical - i.e.
			// { foo: 'bar' } !== { foo: 'bar' }
			if ( comparator === true ) {
				return stringify;
			}
			if ( typeof comparator === 'string' ) {
				if ( !comparators[ comparator ] ) {
					comparators[ comparator ] = function( item ) {
						return item[ comparator ];
					};
				}
				return comparators[ comparator ];
			}
			if ( typeof comparator === 'function' ) {
				return comparator;
			}
			throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
		}
		return __export;
	}( warn, viewmodel$merge_mapOldToNewIndex );

	/* viewmodel/prototype/register.js */
	var viewmodel$register = function() {

		var __export;
		__export = function Viewmodel$register( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var depsByKeypath, deps;
			if ( dependant.isStatic ) {
				return;
			}
			depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
			deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
			deps.push( dependant );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
				parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
				if ( parent[ keypath ] === undefined ) {
					parent[ keypath ] = 0;
					parent.push( keypath );
				}
				parent[ keypath ] += 1;
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/prototype/release.js */
	var viewmodel$release = function Viewmodel$release() {
		return this.captureGroups.pop();
	};

	/* viewmodel/prototype/set.js */
	var viewmodel$set = function( isEqual, createBranch ) {

		var __export;
		__export = function Viewmodel$set( keypath, value, silent ) {
			var computation, wrapper, dontTeardownWrapper;
			computation = this.computations[ keypath ];
			if ( computation ) {
				if ( computation.setting ) {
					// let the other computation set() handle things...
					return;
				}
				computation.set( value );
				value = computation.get();
			}
			if ( isEqual( this.cache[ keypath ], value ) ) {
				return;
			}
			wrapper = this.wrapped[ keypath ];
			// If we have a wrapper with a `reset()` method, we try and use it. If the
			// `reset()` method returns false, the wrapper should be torn down, and
			// (most likely) a new one should be created later
			if ( wrapper && wrapper.reset ) {
				dontTeardownWrapper = wrapper.reset( value ) !== false;
				if ( dontTeardownWrapper ) {
					value = wrapper.get();
				}
			}
			if ( !computation && !dontTeardownWrapper ) {
				resolveSet( this, keypath, value );
			}
			if ( !silent ) {
				this.mark( keypath );
			} else {
				// We're setting a parent of the original target keypath (i.e.
				// creating a fresh branch) - we need to clear the cache, but
				// not mark it as a change
				this.clearCache( keypath );
			}
		};

		function resolveSet( viewmodel, keypath, value ) {
			var keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;
			wrapperSet = function() {
				if ( wrapper.set ) {
					wrapper.set( lastKey, value );
				} else {
					parentValue = wrapper.get();
					valueSet();
				}
			};
			valueSet = function() {
				if ( !parentValue ) {
					parentValue = createBranch( lastKey );
					viewmodel.set( parentKeypath, parentValue, true );
				}
				parentValue[ lastKey ] = value;
			};
			keys = keypath.split( '.' );
			lastKey = keys.pop();
			parentKeypath = keys.join( '.' );
			wrapper = viewmodel.wrapped[ parentKeypath ];
			if ( wrapper ) {
				wrapperSet();
			} else {
				parentValue = viewmodel.get( parentKeypath );
				// may have been wrapped via the above .get()
				// call on viewmodel if this is first access via .set()!
				if ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {
					wrapperSet();
				} else {
					valueSet();
				}
			}
		}
		return __export;
	}( isEqual, createBranch );

	/* viewmodel/prototype/smartUpdate.js */
	var viewmodel$smartUpdate = function() {

		var __export;
		var implicitOption = {
				implicit: true
			},
			noCascadeOption = {
				noCascade: true
			};
		__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {
			var this$0 = this;
			var dependants, oldLength;
			oldLength = newIndices.length;
			// Indices that are being removed should be marked as dirty
			newIndices.forEach( function( newIndex, oldIndex ) {
				if ( newIndex === -1 ) {
					this$0.mark( keypath + '.' + oldIndex, noCascadeOption );
				}
			} );
			// Update the model
			// TODO allow existing array to be updated in place, rather than replaced?
			this.set( keypath, array, true );
			if ( dependants = this.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canShuffle ).forEach( function( d ) {
					return d.shuffle( newIndices, array );
				} );
			}
			if ( oldLength !== array.length ) {
				this.mark( keypath + '.length', implicitOption );
				for ( var i = oldLength; i < array.length; i += 1 ) {
					this.mark( keypath + '.' + i );
				}
				// don't allow removed indexes beyond end of new array to trigger recomputations
				for ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {
					this.mark( keypath + '.' + i$0, noCascadeOption );
				}
			}
		};

		function canShuffle( dependant ) {
			return typeof dependant.shuffle === 'function';
		}
		return __export;
	}();

	/* viewmodel/prototype/teardown.js */
	var viewmodel$teardown = function Viewmodel$teardown() {
		var this$0 = this;
		var unresolvedImplicitDependency;
		// Clear entire cache - this has the desired side-effect
		// of unwrapping adapted values (e.g. arrays)
		Object.keys( this.cache ).forEach( function( keypath ) {
			return this$0.clearCache( keypath );
		} );
		// Teardown any failed lookups - we don't need them to resolve any more
		while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
			unresolvedImplicitDependency.teardown();
		}
	};

	/* viewmodel/prototype/unregister.js */
	var viewmodel$unregister = function() {

		var __export;
		__export = function Viewmodel$unregister( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var deps, index;
			if ( dependant.isStatic ) {
				return;
			}
			deps = this.deps[ group ][ keypath ];
			index = deps.indexOf( dependant );
			if ( index === -1 ) {
				throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
			}
			deps.splice( index, 1 );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ];
				parent = map[ parentKeypath ];
				parent[ keypath ] -= 1;
				if ( !parent[ keypath ] ) {
					// remove from parent deps map
					parent.splice( parent.indexOf( keypath ), 1 );
					parent[ keypath ] = undefined;
				}
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/adaptConfig.js */
	var adaptConfig = function() {

		// should this be combined with prototype/adapt.js?
		var configure = {
			lookup: function( target, adaptors ) {
				var i, adapt = target.adapt;
				if ( !adapt || !adapt.length ) {
					return adapt;
				}
				if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
					while ( i-- ) {
						var adaptor = adapt[ i ];
						if ( typeof adaptor === 'string' ) {
							adapt[ i ] = adaptors[ adaptor ] || adaptor;
						}
					}
				}
				return adapt;
			},
			combine: function( parent, adapt ) {
				// normalize 'Foo' to [ 'Foo' ]
				parent = arrayIfString( parent );
				adapt = arrayIfString( adapt );
				// no parent? return adapt
				if ( !parent || !parent.length ) {
					return adapt;
				}
				// no adapt? return 'copy' of parent
				if ( !adapt || !adapt.length ) {
					return parent.slice();
				}
				// add parent adaptors to options
				parent.forEach( function( a ) {
					// don't put in duplicates
					if ( adapt.indexOf( a ) === -1 ) {
						adapt.push( a );
					}
				} );
				return adapt;
			}
		};

		function arrayIfString( adapt ) {
			if ( typeof adapt === 'string' ) {
				adapt = [ adapt ];
			}
			return adapt;
		}
		return configure;
	}();

	/* viewmodel/Viewmodel.js */
	var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {

		var noMagic;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
		} catch ( err ) {
			noMagic = true;
		}
		var Viewmodel = function( ractive ) {
			this.ractive = ractive;
			// TODO eventually, we shouldn't need this reference
			Viewmodel.extend( ractive.constructor, ractive );
			this.cache = {};
			// we need to be able to use hasOwnProperty, so can't inherit from null
			this.cacheMap = create( null );
			this.deps = {
				computed: {},
				'default': {}
			};
			this.depsMap = {
				computed: {},
				'default': {}
			};
			this.patternObservers = [];
			this.wrapped = create( null );
			this.computations = create( null );
			this.captureGroups = [];
			this.unresolvedImplicitDependencies = [];
			this.changes = [];
			this.implicitChanges = {};
			this.noCascade = {};
		};
		Viewmodel.extend = function( Parent, instance ) {
			if ( instance.magic && noMagic ) {
				throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
			}
			instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
			instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
		};
		Viewmodel.prototype = {
			adapt: adapt,
			applyChanges: applyChanges,
			capture: capture,
			clearCache: clearCache,
			compute: compute,
			get: get,
			init: init,
			mark: mark,
			merge: merge,
			register: register,
			release: release,
			set: set,
			smartUpdate: smartUpdate,
			teardown: teardown,
			unregister: unregister
		};
		return Viewmodel;
	}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );

	/* Ractive/initialise.js */
	var Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {

		var __export;
		var constructHook = new Hook( 'construct' ),
			configHook = new Hook( 'config' ),
			initHook = new HookQueue( 'init' );
		__export = function initialiseRactiveInstance( ractive ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var el;
			initialiseProperties( ractive, options );
			// make this option do what would be expected if someone
			// did include it on a new Ractive() or new Component() call.
			// Silly to do so (put a hook on the very options being used),
			// but handle it correctly, consistent with the intent.
			constructHook.fire( config.getConstructTarget( ractive, options ), options );
			// init config from Parent and options
			config.init( ractive.constructor, ractive, options );
			configHook.fire( ractive );
			// Teardown any existing instances *before* trying to set up the new one -
			// avoids certain weird bugs
			if ( el = getElement( ractive.el ) ) {
				if ( !ractive.append ) {
					if ( el.__ractive_instances__ ) {
						try {
							el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
								return r.teardown();
							} );
						} catch ( err ) {}
					}
					el.innerHTML = '';
				}
			}
			initHook.begin( ractive );
			// TEMPORARY. This is so we can implement Viewmodel gradually
			ractive.viewmodel = new Viewmodel( ractive );
			// hacky circular problem until we get this sorted out
			// if viewmodel immediately processes computed properties,
			// they may call ractive.get, which calls ractive.viewmodel,
			// which hasn't been set till line above finishes.
			ractive.viewmodel.init();
			// Render our *root fragment*
			if ( ractive.template ) {
				ractive.fragment = new Fragment( {
					template: ractive.template,
					root: ractive,
					owner: ractive
				} );
			}
			initHook.end( ractive );
			// render automatically ( if `el` is specified )
			if ( el ) {
				ractive.render( el, ractive.append );
			}
		};

		function initialiseProperties( ractive, options ) {
			// Generate a unique identifier, for places where you'd use a weak map if it
			// existed
			ractive._guid = getNextNumber();
			// events
			ractive._subs = create( null );
			// storage for item configuration from instantiation to reset,
			// like dynamic functions or original values
			ractive._config = {};
			// two-way bindings
			ractive._twowayBindings = create( null );
			// animations (so we can stop any in progress at teardown)
			ractive._animations = [];
			// nodes registry
			ractive.nodes = {};
			// live queries
			ractive._liveQueries = [];
			ractive._liveComponentQueries = [];
			// If this is a component, store a reference to the parent
			if ( options._parent && options._component ) {
				ractive._parent = options._parent;
				ractive.component = options._component;
				// And store a reference to the instance on the component
				options._component.instance = ractive;
			}
		}
		return __export;
	}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );

	/* extend/unwrapExtended.js */
	var unwrapExtended = function( wrap, config, circular ) {

		var __export;
		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		__export = function unwrapExtended( Child ) {
			if ( !( Child.prototype instanceof Ractive ) ) {
				return Child;
			}
			var options = {};
			while ( Child ) {
				config.registries.forEach( function( r ) {
					addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
				} );
				Object.keys( Child.prototype ).forEach( function( key ) {
					if ( key === 'computed' ) {
						return;
					}
					var value = Child.prototype[ key ];
					if ( !( key in options ) ) {
						options[ key ] = value._method ? value._method : value;
					} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
						var result, needsSuper = value._method;
						if ( needsSuper ) {
							value = value._method;
						}
						// rewrap bound directly to parent fn
						result = wrap( options[ key ]._method, value );
						if ( needsSuper ) {
							result._method = result;
						}
						options[ key ] = result;
					}
				} );
				if ( Child._parent !== Ractive ) {
					Child = Child._parent;
				} else {
					Child = false;
				}
			}
			return options;
		};

		function addRegistry( target, options, name ) {
			var registry, keys = Object.keys( target[ name ] );
			if ( !keys.length ) {
				return;
			}
			if ( !( registry = options[ name ] ) ) {
				registry = options[ name ] = {};
			}
			keys.filter( function( key ) {
				return !( key in registry );
			} ).forEach( function( key ) {
				return registry[ key ] = target[ name ][ key ];
			} );
		}
		return __export;
	}( wrapMethod, config, circular );

	/* extend/_extend.js */
	var Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {

		return function extend() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = {};
			var Parent = this,
				Child, proto, staticProperties;
			// if we're extending with another Ractive instance, inherit its
			// prototype methods and default options as well
			options = unwrap( options );
			// create Child constructor
			Child = function( options ) {
				initialise( this, options );
			};
			proto = create( Parent.prototype );
			proto.constructor = Child;
			staticProperties = {
				// each component needs a guid, for managing CSS etc
				_guid: {
					value: getGuid()
				},
				// alias prototype as defaults
				defaults: {
					value: proto
				},
				// extendable
				extend: {
					value: extend,
					writable: true,
					configurable: true
				},
				// Parent - for IE8, can't use Object.getPrototypeOf
				_parent: {
					value: Parent
				}
			};
			defineProperties( Child, staticProperties );
			// extend configuration
			config.extend( Parent, proto, options );
			Viewmodel.extend( Parent, proto );
			Child.prototype = proto;
			return Child;
		};
	}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );

	/* Ractive.js */
	var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

		var Ractive, properties;
		// Main Ractive required object
		Ractive = function( options ) {
			initialise( this, options );
		};
		// Ractive properties
		properties = {
			// static methods:
			extend: {
				value: extend
			},
			parse: {
				value: parse
			},
			// Namespaced constructors
			Promise: {
				value: Promise
			},
			// support
			svg: {
				value: svg
			},
			magic: {
				value: magic
			},
			// version
			VERSION: {
				value: '0.6.1'
			},
			// Plugins
			adaptors: {
				writable: true,
				value: {}
			},
			components: {
				writable: true,
				value: {}
			},
			decorators: {
				writable: true,
				value: {}
			},
			easing: {
				writable: true,
				value: easing
			},
			events: {
				writable: true,
				value: {}
			},
			interpolators: {
				writable: true,
				value: interpolators
			},
			partials: {
				writable: true,
				value: {}
			},
			transitions: {
				writable: true,
				value: {}
			}
		};
		// Ractive properties
		defineProperties( Ractive, properties );
		Ractive.prototype = extendObj( proto, defaults );
		Ractive.prototype.constructor = Ractive;
		// alias prototype as defaults
		Ractive.defaults = Ractive.prototype;
		// Certain modules have circular dependencies. If we were bundling a
		// module loader, e.g. almond.js, this wouldn't be a problem, but we're
		// not - we're using amdclean as part of the build process. Because of
		// this, we need to wait until all modules have loaded before those
		// circular dependencies can be required.
		circular.Ractive = Ractive;
		while ( circular.length ) {
			circular.pop()();
		}
		// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
		// older browsers, these are made available via a shim - here, we do a quick
		// pre-flight check to make sure that either a) we're not in a shit browser,
		// or b) we're using a Ractive-legacy.js build
		var FUNCTION = 'function';
		if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
			throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
		}
		return Ractive;
	}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


	// export as Common JS module...
	if ( typeof module !== "undefined" && module.exports ) {
		module.exports = Ractive;
	}

	// ... or as AMD module
	else if ( typeof define === "function" && define.amd ) {
		define( function() {
			return Ractive;
		} );
	}

	// ... or as browser global
	global.Ractive = Ractive;

	Ractive.noConflict = function() {
		global.Ractive = noConflict;
		return Ractive;
	};

}( typeof window !== 'undefined' ? window : this ) );

},{}]},{},["./source/js/app.coffee"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9hcHAuY29mZmVlIiwibm9kZV9tb2R1bGVzL2RhdC1ndWkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0LWd1aS92ZW5kb3IvZGF0LmNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5ndWkuanMiLCJub2RlX21vZHVsZXMvZmlyZWJhc2UvbGliL2ZpcmViYXNlLXdlYi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvYXBwZW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvY29sbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2NvbWJpbmUuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9jb21wYWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9kaWZmZXJlbmNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZXZlcnkuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9maW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmluZExhc3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9maW5kTGFzdEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9ncm91cEJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvaW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2luc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ludGVyc2VjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2pvaW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9sYXN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvbGFzdEluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9tYXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9tYXguanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9taW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9waWNrLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcGx1Y2suanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3JlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3JlZHVjZVJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcmVqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcmVtb3ZlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcmVtb3ZlQWxsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvc2h1ZmZsZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3NsaWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3NvcnQuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9zb3J0QnkuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3Rha2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS90b0xvb2t1cC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3VuaW9uLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvdW5pcXVlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkveG9yLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvemlwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL2V2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL2ZpbmQuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL21ha2VfLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9tYXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL21heC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vbWluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9wbHVjay5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9yZWplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL3NpemUuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL3NvbWUuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9kYXlPZlRoZVllYXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL2RpZmYuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL2kxOG4vZW4tVVMuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL2kxOG5fLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9pc0xlYXBZZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9pc1NhbWUuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL3BhcnNlSXNvLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9xdWFydGVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9zdGFydE9mLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9zdHJmdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvdGltZXpvbmVBYmJyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS90aW1lem9uZU9mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvdG90YWxEYXlzSW5Nb250aC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvdG90YWxEYXlzSW5ZZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS93ZWVrT2ZUaGVZZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9hd2FpdERlbGF5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2NvbXBvc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9jb25zdGFudC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2RlYm91bmNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vZnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL3BhcnRpYWwuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9wcm9wLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vc2VyaWVzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vdGhyb3R0bGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi90aW1lb3V0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vdGltZXMuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi93cmFwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9HTE9CQUwuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9jcmVhdGVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2N0b3JBcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvZGVlcENsb25lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9kZWVwRXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaW5oZXJpdFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXMuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzRGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNFbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNGaW5pdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzSW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNLaW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNOdWxsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzUHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc1JlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNTdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzVW5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc250LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9raW5kT2YuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL3RvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy90b1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGguanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL2NlaWwuanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL2NsYW1wLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9jb3VudFN0ZXBzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9mbG9vci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvaW5SYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvaXNOZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9sZXJwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9sb29wLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9tYXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL25vcm0uanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL3JvdW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL01BWF9JTlQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvTUFYX1NBRkVfSU5URUdFUi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9NQVhfVUlOVC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9NSU5fSU5ULmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL2FiYnJldmlhdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvY3VycmVuY3lGb3JtYXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvZW5mb3JjZVByZWNpc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9pc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9udGguanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvb3JkaW5hbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9wYWQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvcm9sLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL3Jvci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9zaWduLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL3RvSW50LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL3RvVUludC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci90b1VJbnQzMS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9iaW5kQWxsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2RlZXBGaWxsSW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZGVlcE1hdGNoZXMuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZGVlcE1peEluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2VxdWFscy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9ldmVyeS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9maWxsSW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2ZpbmQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZm9ySW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZm9yT3duLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2Z1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9nZXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvaGFzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2hhc093bi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L21hcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9tYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L21heC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9tZXJnZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9taW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbWl4SW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbmFtZXNwYWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L29taXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvcGljay5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9wbHVjay5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvcmVqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3Jlc3VsdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9zZXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3Qvc2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9zb21lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3Vuc2V0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3ZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3F1ZXJ5U3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9nZXRQYXJhbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3F1ZXJ5U3RyaW5nL2dldFF1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9zZXRQYXJhbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9jaG9pY2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vZ3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9yYW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRCaXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZEJvb2wuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZEhleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9yYW5kSW50LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRTaWduLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRTdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL1dISVRFX1NQQUNFUy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9jYW1lbENhc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvY3JvcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9lbmRzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9lc2NhcGVIdG1sLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2VzY2FwZVJlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9lc2NhcGVVbmljb2RlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2h5cGhlbmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9pbnNlcnQuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvaW50ZXJwb2xhdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbG93ZXJDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2xwYWQuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbHRyaW0uanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbWFrZVBhdGguanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbm9ybWFsaXplTGluZUJyZWFrcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9wYXNjYWxDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3Byb3BlckNhc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVtb3ZlTm9uQVNDSUkuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVtb3ZlTm9uV29yZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9yZXBsYWNlQWNjZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9ycGFkLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3J0cmltLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3NlbnRlbmNlQ2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9zbHVnaWZ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3N0YXJ0c1dpdGguanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvc3RyaXBIdG1sVGFncy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy90cmltLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3RydW5jYXRlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3R5cGVjYXN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3VuQ2FtZWxDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3VuZGVyc2NvcmUuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvdW5lc2NhcGVIdG1sLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3VuZXNjYXBlVW5pY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy91bmh5cGhlbmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy91cHBlckNhc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC90aW1lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvdGltZS9jb252ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvdGltZS9ub3cuanMiLCJub2RlX21vZHVsZXMvbW91dC90aW1lL3BhcnNlTXMuanMiLCJub2RlX21vZHVsZXMvbW91dC90aW1lL3RvVGltZVN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL2FwcC1kZWJ1Zy5jb2ZmZWUiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9jb25maWcuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL2Fic3RyYWN0LW1vZHVsZS5jb2ZmZWUiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvYWJzdHJhY3Qtc2NlbmUuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL2luZGV4LmNvZmZlZSIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9uYXYuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL3NjZW5lLWRheS5jb2ZmZWUiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvc2NlbmUtZGlnZXN0LmNvZmZlZSIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9zY2VuZS1uaWdodC5jb2ZmZWUiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvc3RhZ2UuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvdmlldy9tYWluLXZpZXcuY29mZmVlIiwic291cmNlL3RlbXBsYXRlL21haW4tdmlldy5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9hYnN0cmFjdC1zY2VuZS5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9uYXYuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvc2NlbmUtZGF5Lmh0bWwiLCJzb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLWRpZ2VzdC5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9zY2VuZS1uaWdodC5odG1sIiwic291cmNlL3RlbXBsYXRlL21vZHVsZS9zdGFnZS5odG1sIiwic291cmNlL3RlbXBsYXRlL3BhcnRpYWxzL3N0YWdlLWNvbnRyb2xzLmh0bWwiLCJ2ZW5kb3IvZG9tcmVhZHkvcmVhZHkuanMiLCJ2ZW5kb3IvZ3NhcC9zcmMvdW5jb21wcmVzc2VkL1R3ZWVuTWF4LmpzIiwidmVuZG9yL2hhbW1lcmpzL2hhbW1lci5qcyIsInZlbmRvci9wYWdlL3BhZ2UuanMiLCJ2ZW5kb3IvcmFjdGl2ZS1ldmVudHMtdGFwL3JhY3RpdmUtZXZlbnRzLXRhcC5qcyIsInZlbmRvci9yYWN0aXZlLXRvdWNoL2luZGV4LmpzIiwidmVuZG9yL3JhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZS9yYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUuanMiLCJ2ZW5kb3IvcmFjdGl2ZS10cmFuc2l0aW9ucy1mbHkvcmFjdGl2ZS10cmFuc2l0aW9ucy1mbHkuanMiLCJ2ZW5kb3IvcmFjdGl2ZS10cmFuc2l0aW9ucy1zbGlkZS9yYWN0aXZlLXRyYW5zaXRpb25zLXNsaWRlLmpzIiwidmVuZG9yL3JhY3RpdmUvcmFjdGl2ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0NBLE9BQUEsQ0FBUSxnQkFBUixDQUFBLENBQUE7O0FBQUEsT0FHQSxDQUFRLE1BQVIsQ0FIQSxDQUFBOztBQUFBLE9BTUEsQ0FBUSxvQkFBUixDQU5BLENBQUE7O0FBQUEsT0FPQSxDQUFRLGVBQVIsQ0FQQSxDQUFBOztBQUFBLE9BUUEsQ0FBUSwwQkFBUixDQVJBLENBQUE7O0FBQUEsT0FTQSxDQUFRLHlCQUFSLENBVEEsQ0FBQTs7QUFBQSxPQVVBLENBQVEsMkJBQVIsQ0FWQSxDQUFBOztBQUFBLE9BYUEsQ0FBUSxVQUFSLENBQUEsQ0FBb0IsU0FBQSxHQUFBO0FBQ25CLE1BQUEsSUFBQTtBQUFBLEVBQUEsSUFBNEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFaLEtBQXdCLGFBQXBEO0FBQUEsSUFBQSxPQUFBLENBQVEsYUFBUixDQUFBLENBQUEsQ0FBQSxDQUFBO0dBQUE7QUFBQSxFQUVBLElBQUEsR0FBTyxPQUFBLENBQVEsa0JBQVIsQ0FGUCxDQUFBO1NBR0EsTUFBTSxDQUFDLEtBQVAsR0FBbUIsSUFBQSxJQUFBLENBQUEsRUFKQTtBQUFBLENBQXBCLENBYkEsQ0FBQTs7Ozs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2tIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQSxJQUFBLHVCQUFBOztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVEsU0FBUixDQUFOLENBQUE7O0FBQUEsSUFDQSxHQUFPLE9BQUEsQ0FBUSxNQUFSLENBRFAsQ0FBQTs7QUFBQSxHQUlBLEdBQU0sTUFBTSxDQUFDLElBQVAsR0FBa0IsSUFBQSxHQUFHLENBQUMsR0FBSixDQUFBLENBSnhCLENBQUE7O0FBQUEsT0FNQSxHQUNDO0FBQUEsRUFBQSxPQUFBLEVBQVMsS0FBVDtBQUFBLEVBQ0EsT0FBQSxFQUFTLFNBQUEsR0FBQTtXQUFHLElBQUEsQ0FBSyxHQUFMLEVBQUg7RUFBQSxDQURUO0FBQUEsRUFFQSxNQUFBLEVBQVEsU0FBQSxHQUFBO1dBQUcsSUFBQSxDQUFLLE9BQUwsRUFBSDtFQUFBLENBRlI7Q0FQRCxDQUFBOztBQUFBLE1BV00sQ0FBQyxPQUFQLEdBQWlCLFNBQUEsR0FBQTtBQUVoQixNQUFBLGFBQUE7QUFBQSxFQUFBLEtBQUEsR0FBUSxHQUFHLENBQUMsR0FBSixDQUFRLE9BQVIsRUFBaUIsT0FBakIsQ0FBUixDQUFBO0FBQUEsRUFHQSxNQUFBLEdBQVMsR0FBRyxDQUFDLFNBQUosQ0FBYyxZQUFkLENBSFQsQ0FBQTtBQUFBLEVBSUEsTUFBTSxDQUFDLEdBQVAsQ0FBVyxPQUFYLEVBQW9CLE9BQXBCLENBQTRCLENBQUMsSUFBN0IsQ0FBa0MsUUFBbEMsQ0FKQSxDQUFBO0FBQUEsRUFLQSxNQUFNLENBQUMsR0FBUCxDQUFXLE9BQVgsRUFBb0IsTUFBcEIsQ0FBMkIsQ0FBQyxJQUE1QixDQUFpQyxPQUFqQyxDQUxBLENBQUE7U0FNQSxNQUFNLENBQUMsSUFBUCxDQUFBLEVBUmdCO0FBQUEsQ0FYakIsQ0FBQTs7Ozs7QUNBQSxNQUFNLENBQUMsT0FBUCxHQUVJO0FBQUEsRUFBQSxRQUFBLEVBQVUsV0FBVjtDQUZKLENBQUE7Ozs7O0FDQUEsSUFBQSxPQUFBOztBQUFBLE9BQUEsR0FBVSxPQUFBLENBQVEsU0FBUixDQUFWLENBQUE7O0FBQUEsTUFHTSxDQUFDLE9BQVAsR0FBaUIsT0FBTyxDQUFDLE1BQVIsQ0FFaEI7QUFBQSxFQUFBLFFBQUEsRUFBVSxJQUFWO0NBRmdCLENBSGpCLENBQUE7Ozs7O0FDQUE7QUFBQTs7Ozs7R0FBQTtBQUFBLElBQUEsTUFBQTs7QUFBQSxNQVFBLEdBQVMsT0FBQSxDQUFRLG1CQUFSLENBUlQsQ0FBQTs7QUFBQSxNQVVNLENBQUMsT0FBUCxHQUFpQixNQUFNLENBQUMsTUFBUCxDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLE9BQUEsQ0FBUSw0QkFBUixDQUFWO0FBQUEsRUFFQSxRQUFBLEVBQ0M7QUFBQSxJQUFBLGFBQUEsRUFBZSxPQUFBLENBQVEsOEJBQVIsQ0FBZjtHQUhEO0FBQUEsRUFLQSxNQUFBLEVBQVEsU0FBQSxHQUFBO0FBQ1AsSUFBQSxJQUFDLENBQUEsRUFBRCxDQUFJLGFBQUosRUFBbUIsU0FBQSxHQUFBO2FBQUcsSUFBQyxDQUFBLElBQUQsQ0FBTSxXQUFOLEVBQUg7SUFBQSxDQUFuQixDQUFBLENBQUE7V0FDQSxJQUFDLENBQUEsRUFBRCxDQUFJLGFBQUosRUFBbUIsU0FBQSxHQUFBO2FBQUcsSUFBQyxDQUFBLElBQUQsQ0FBTSxXQUFOLEVBQUg7SUFBQSxDQUFuQixFQUZPO0VBQUEsQ0FMUjtDQUZnQixDQVZqQixDQUFBOzs7OztBQ0FBO0FBQUE7OztHQUFBO0FBQUEsSUFBQSxpQkFBQTs7QUFBQSxPQUlBLEdBQVUsT0FBQSxDQUFRLFNBQVIsQ0FKVixDQUFBOztBQUFBLFFBTUEsR0FBVyxTQUFBLEdBQUE7QUFDVixFQUFBLE9BQU8sQ0FBQyxVQUFXLENBQUEsbUJBQUEsQ0FBbkIsR0FBMEMsT0FBQSxDQUFRLGtCQUFSLENBQTFDLENBQUE7QUFBQSxFQUNBLE9BQU8sQ0FBQyxVQUFXLENBQUEsUUFBQSxDQUFuQixHQUErQixPQUFBLENBQVEsT0FBUixDQUQvQixDQUFBO0FBQUEsRUFFQSxPQUFPLENBQUMsVUFBVyxDQUFBLGNBQUEsQ0FBbkIsR0FBcUMsT0FBQSxDQUFRLGFBQVIsQ0FGckMsQ0FBQTtBQUFBLEVBR0EsT0FBTyxDQUFDLFVBQVcsQ0FBQSxpQkFBQSxDQUFuQixHQUF3QyxPQUFBLENBQVEsZ0JBQVIsQ0FIeEMsQ0FBQTtBQUFBLEVBSUEsT0FBTyxDQUFDLFVBQVcsQ0FBQSxnQkFBQSxDQUFuQixHQUF1QyxPQUFBLENBQVEsZUFBUixDQUp2QyxDQUFBO0FBQUEsRUFLQSxPQUFPLENBQUMsVUFBVyxDQUFBLFVBQUEsQ0FBbkIsR0FBaUMsT0FBQSxDQUFRLFNBQVIsQ0FMakMsQ0FBQTtTQU9BLEtBUlU7QUFBQSxDQU5YLENBQUE7O0FBQUEsTUFnQk0sQ0FBQyxPQUFQLEdBQWlCLFFBQUEsQ0FBQSxDQWhCakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxZQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVEsbUJBQVIsQ0FSVCxDQUFBOztBQUFBLElBVUEsR0FBTyxPQUFBLENBQVEsTUFBUixDQVZQLENBQUE7O0FBQUEsTUFZTSxDQUFDLE9BQVAsR0FBaUIsTUFBTSxDQUFDLE1BQVAsQ0FFaEI7QUFBQSxFQUFBLFFBQUEsRUFBVSxPQUFBLENBQVEsaUJBQVIsQ0FBVjtBQUFBLEVBRUEsTUFBQSxFQUFRLFNBQUEsR0FBQTtBQUVQLElBQUEsSUFBQyxDQUFBLEVBQUQsQ0FBSSxTQUFKLEVBQWUsU0FBQSxHQUFBO2FBQUcsSUFBQSxDQUFLLEdBQUwsRUFBSDtJQUFBLENBQWYsQ0FBQSxDQUFBO1dBQ0EsSUFBQyxDQUFBLEVBQUQsQ0FBSSxRQUFKLEVBQWMsU0FBQSxHQUFBO2FBQUcsSUFBQSxDQUFLLE9BQUwsRUFBSDtJQUFBLENBQWQsRUFITztFQUFBLENBRlI7Q0FGZ0IsQ0FaakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxNQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVEsa0JBQVIsQ0FSVCxDQUFBOztBQUFBLE1BV00sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFRLHVCQUFSLENBQVY7QUFBQSxFQUVBLE1BQUEsRUFBUSxTQUFBLEdBQUE7V0FBRyxJQUFDLENBQUEsTUFBRCxDQUFBLEVBQUg7RUFBQSxDQUZSO0FBQUEsRUFJQSxRQUFBLEVBQVUsU0FBQSxHQUFBO0FBQ1QsUUFBQSxZQUFBO0FBQUEsSUFBQSxJQUFBLEdBQU8sSUFBQyxDQUFBLElBQUQsQ0FBTSxNQUFOLENBQVAsQ0FBQTtBQUFBLElBQ0EsTUFBQSxHQUFTLElBQUksQ0FBQyxjQUFMLENBQUEsQ0FEVCxDQUFBO1dBRUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxJQUFaLEVBQWtCLENBQWxCLEVBQXFCO0FBQUEsTUFBRSxLQUFBLEVBQU8sQ0FBVDtBQUFBLE1BQVksbUJBQUEsRUFBcUIsTUFBakM7QUFBQSxNQUF5QyxJQUFBLEVBQUssTUFBTSxDQUFDLE9BQXJEO0tBQXJCLEVBSFM7RUFBQSxDQUpWO0NBRmdCLENBWGpCLENBQUE7Ozs7O0FDQUE7QUFBQTs7Ozs7R0FBQTtBQUFBLElBQUEsWUFBQTs7QUFBQSxNQVFBLEdBQVMsT0FBQSxDQUFRLGtCQUFSLENBUlQsQ0FBQTs7QUFBQSxJQVNBLEdBQU8sT0FBQSxDQUFRLE1BQVIsQ0FBZSxDQUFDLE1BQU0sQ0FBQyxJQVQ5QixDQUFBOztBQUFBLE1BV00sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFRLDBCQUFSLENBQVY7QUFBQSxFQUVBLElBQUEsRUFDQztBQUFBLElBQUEsT0FBQSxFQUFTLENBQVQ7QUFBQSxJQUNBLENBQUEsRUFBRyxDQUFDLE1BQUQsRUFBUyxPQUFULENBREg7QUFBQSxJQUVBLE1BQUEsRUFDQztBQUFBLE1BQUEsQ0FBQSxFQUNDO0FBQUEsUUFBQSxLQUFBLEVBQU8sU0FBUDtBQUFBLFFBQ0EsSUFBQSxFQUFNLGlCQUROO0FBQUEsUUFFQSxLQUFBLEVBQU8sQ0FBQyxHQUFELEVBQUssR0FBTCxDQUZQO0FBQUEsUUFHQSxNQUFBLEVBQVEsSUFIUjtPQUREO0FBQUEsTUFLQSxDQUFBLEVBQ0M7QUFBQSxRQUFBLEtBQUEsRUFBTyxTQUFQO0FBQUEsUUFDQSxJQUFBLEVBQU0saUJBRE47QUFBQSxRQUVBLE1BQUEsRUFBUSxLQUZSO09BTkQ7QUFBQSxNQVNBLENBQUEsRUFDQztBQUFBLFFBQUEsS0FBQSxFQUFPLFNBQVA7QUFBQSxRQUNBLElBQUEsRUFBTSxpQkFETjtBQUFBLFFBRUEsTUFBQSxFQUFRLEtBRlI7T0FWRDtLQUhEO0dBSEQ7QUFBQSxFQW9CQSxNQUFBLEVBQVEsU0FBQSxHQUFBO1dBQUcsSUFBQyxDQUFBLE1BQUQsQ0FBQSxFQUFIO0VBQUEsQ0FwQlI7QUFBQSxFQXNCQSxRQUFBLEVBQVUsU0FBQSxHQUFBO0FBRVQsSUFBQSxJQUFDLENBQUEsRUFBRCxDQUFJLGFBQUosRUFBbUIsU0FBQSxHQUFBO2FBQUcsSUFBQyxDQUFBLFNBQUQsQ0FBQSxFQUFIO0lBQUEsQ0FBbkIsQ0FBQSxDQUFBO1dBQ0EsSUFBQyxDQUFBLEVBQUQsQ0FBSSxhQUFKLEVBQW1CLFNBQUEsR0FBQTthQUFHLElBQUMsQ0FBQSxTQUFELENBQUEsRUFBSDtJQUFBLENBQW5CLEVBSFM7RUFBQSxDQXRCVjtBQUFBLEVBMkJBLFNBQUEsRUFBVyxTQUFBLEdBQUE7QUFDVixRQUFBLGFBQUE7QUFBQSxJQUFBLE9BQUEsR0FBVSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBVixDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQVUsT0FBQSxLQUFXLElBQUEsQ0FBSyxJQUFDLENBQUEsR0FBRCxDQUFLLFFBQUwsQ0FBTCxDQUFvQixDQUFDLE1BQW5DLEdBQStDLENBQS9DLEdBQXNELE9BQUEsSUFBUyxDQUR0RSxDQUFBO0FBQUEsSUFFQSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUEsR0FBUyxDQUFDLElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFELENBQVQsR0FBMEIsSUFBL0IsRUFBb0MsSUFBQyxDQUFBLEdBQUQsQ0FBSyxNQUFMLENBQXBDLENBRkEsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFBLEdBQVUsSUFBVixHQUFlLElBQXBCLEVBQXlCLElBQUMsQ0FBQSxHQUFELENBQUssTUFBTCxDQUF6QixDQUhBLENBQUE7V0FJQSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQVYsRUFMVTtFQUFBLENBM0JYO0FBQUEsRUFrQ0EsU0FBQSxFQUFXLFNBQUEsR0FBQTtBQUNWLFFBQUEsYUFBQTtBQUFBLElBQUEsT0FBQSxHQUFVLElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFWLENBQUE7QUFBQSxJQUNBLElBQUEsR0FBVSxPQUFBLEtBQVcsQ0FBZCxHQUFxQixJQUFBLENBQUssSUFBQyxDQUFBLEdBQUQsQ0FBSyxRQUFMLENBQUwsQ0FBb0IsQ0FBQyxNQUExQyxHQUFzRCxPQUFBLElBQVMsQ0FEdEUsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFBLEdBQVMsQ0FBQyxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBRCxDQUFULEdBQTBCLElBQS9CLEVBQW9DLElBQUMsQ0FBQSxHQUFELENBQUssTUFBTCxDQUFwQyxDQUZBLENBQUE7QUFBQSxJQUdBLElBQUMsQ0FBQSxHQUFELENBQUssU0FBQSxHQUFVLElBQVYsR0FBZSxJQUFwQixFQUF5QixJQUFDLENBQUEsR0FBRCxDQUFLLE1BQUwsQ0FBekIsQ0FIQSxDQUFBO1dBSUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFWLEVBTFU7RUFBQSxDQWxDWDtBQUFBLEVBeUNBLFFBQUEsRUFBVSxTQUFDLEtBQUQsR0FBQTtBQUNULElBQUEsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFBLEdBQVMsQ0FBQyxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBRCxDQUFULEdBQTBCLFNBQS9CLEVBQXlDLEtBQXpDLENBQUEsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFBLEdBQVUsS0FBVixHQUFnQixTQUFyQixFQUErQixJQUEvQixDQURBLENBQUE7V0FFQSxJQUFDLENBQUEsR0FBRCxDQUFLO0FBQUEsTUFBQSxPQUFBLEVBQVMsS0FBVDtLQUFMLEVBSFM7RUFBQSxDQXpDVjtDQUZnQixDQVhqQixDQUFBOzs7OztBQ0FBO0FBQUE7Ozs7O0dBQUE7QUFBQSxJQUFBLE1BQUE7O0FBQUEsTUFRQSxHQUFTLE9BQUEsQ0FBUSxrQkFBUixDQVJULENBQUE7O0FBQUEsTUFXTSxDQUFDLE9BQVAsR0FBaUIsTUFBTSxDQUFDLE1BQVAsQ0FFaEI7QUFBQSxFQUFBLFFBQUEsRUFBVSxPQUFBLENBQVEseUJBQVIsQ0FBVjtBQUFBLEVBRUEsTUFBQSxFQUFRLFNBQUEsR0FBQTtXQUFHLElBQUMsQ0FBQSxNQUFELENBQUEsRUFBSDtFQUFBLENBRlI7QUFBQSxFQUlBLFFBQUEsRUFBVSxTQUFBLEdBQUEsQ0FKVjtDQUZnQixDQVhqQixDQUFBOzs7OztBQ0FBO0FBQUE7Ozs7O0dBQUE7QUFBQSxJQUFBLFlBQUE7O0FBQUEsTUFRQSxHQUFTLE9BQUEsQ0FBUSxtQkFBUixDQVJULENBQUE7O0FBQUEsSUFTQSxHQUFPLE9BQUEsQ0FBUSxNQUFSLENBQWUsQ0FBQyxNQUFNLENBQUMsSUFUOUIsQ0FBQTs7QUFBQSxNQVdNLENBQUMsT0FBUCxHQUFpQixNQUFNLENBQUMsTUFBUCxDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLE9BQUEsQ0FBUSxtQkFBUixDQUFWO0FBQUEsRUFFQSxJQUFBLEVBQ0M7QUFBQSxJQUFBLE9BQUEsRUFBUyxDQUFUO0FBQUEsSUFDQSxLQUFBLEVBQU8sSUFEUDtBQUFBLElBRUEsTUFBQSxFQUNDO0FBQUEsTUFBQSxDQUFBLEVBQUcsS0FBSDtBQUFBLE1BQ0EsQ0FBQSxFQUFHLFFBREg7QUFBQSxNQUVBLENBQUEsRUFBRyxPQUZIO0tBSEQ7R0FIRDtBQUFBLEVBVUEsTUFBQSxFQUFRLFNBQUEsR0FBQTtBQUNQLElBQUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxDQUFWLENBQUEsQ0FBQTtBQUFBLElBRUEsTUFBTSxDQUFDLFNBQVAsR0FBbUIsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsQ0FBRCxHQUFBO0FBQ2xCLFFBQUEsSUFBZ0IsQ0FBQyxDQUFDLE9BQUYsS0FBYSxFQUE3QjtBQUFBLFVBQUEsS0FBQyxDQUFBLFNBQUQsQ0FBQSxDQUFBLENBQUE7U0FBQTtBQUNBLFFBQUEsSUFBZ0IsQ0FBQyxDQUFDLE9BQUYsS0FBYSxFQUE3QjtpQkFBQSxLQUFDLENBQUEsU0FBRCxDQUFBLEVBQUE7U0FGa0I7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUZuQixDQUFBO0FBQUEsSUFNQSxJQUFDLENBQUEsRUFBRCxDQUFJLGFBQUosRUFBbUIsU0FBQSxHQUFBO2FBQUcsSUFBQyxDQUFBLFNBQUQsQ0FBQSxFQUFIO0lBQUEsQ0FBbkIsQ0FOQSxDQUFBO1dBT0EsSUFBQyxDQUFBLEVBQUQsQ0FBSSxhQUFKLEVBQW1CLFNBQUEsR0FBQTthQUFHLElBQUMsQ0FBQSxTQUFELENBQUEsRUFBSDtJQUFBLENBQW5CLEVBUk87RUFBQSxDQVZSO0FBQUEsRUFvQkEsU0FBQSxFQUFXLFNBQUEsR0FBQTtBQUNWLFFBQUEsYUFBQTtBQUFBLElBQUEsT0FBQSxHQUFVLElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFWLENBQUE7QUFBQSxJQUNBLElBQUEsR0FBVSxPQUFBLEtBQVcsSUFBQSxDQUFLLElBQUMsQ0FBQSxHQUFELENBQUssUUFBTCxDQUFMLENBQW9CLENBQUMsTUFBbkMsR0FBK0MsQ0FBL0MsR0FBc0QsT0FBQSxJQUFTLENBRHRFLENBQUE7V0FFQSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQVYsRUFIVTtFQUFBLENBcEJYO0FBQUEsRUF5QkEsU0FBQSxFQUFXLFNBQUEsR0FBQTtBQUNWLFFBQUEsYUFBQTtBQUFBLElBQUEsT0FBQSxHQUFVLElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFWLENBQUE7QUFBQSxJQUNBLElBQUEsR0FBVSxPQUFBLEtBQVcsQ0FBZCxHQUFxQixJQUFBLENBQUssSUFBQyxDQUFBLEdBQUQsQ0FBSyxRQUFMLENBQUwsQ0FBb0IsQ0FBQyxNQUExQyxHQUFzRCxPQUFBLElBQVMsQ0FEdEUsQ0FBQTtXQUVBLElBQUMsQ0FBQSxRQUFELENBQVUsSUFBVixFQUhVO0VBQUEsQ0F6Qlg7QUFBQSxFQThCQSxRQUFBLEVBQVUsU0FBQyxLQUFELEdBQUE7V0FDVCxJQUFDLENBQUEsR0FBRCxDQUNDO0FBQUEsTUFBQSxLQUFBLEVBQU8sSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFBLEdBQVUsS0FBZixDQUFQO0FBQUEsTUFDQSxPQUFBLEVBQVMsS0FEVDtLQURELEVBRFM7RUFBQSxDQTlCVjtDQUZnQixDQVhqQixDQUFBOzs7OztBQ0FBLElBQUEsK0JBQUE7O0FBQUEsT0FBQSxHQUFVLE9BQUEsQ0FBUSxTQUFSLENBQVYsQ0FBQTs7QUFBQSxRQUNBLEdBQVcsT0FBQSxDQUFRLFVBQVIsQ0FEWCxDQUFBOztBQUFBLElBRUEsR0FBTyxPQUFBLENBQVEsTUFBUixDQUZQLENBQUE7O0FBQUEsTUFJQSxHQUFTLE9BQUEsQ0FBUSxXQUFSLENBSlQsQ0FBQTs7QUFBQSxNQU1NLENBQUMsT0FBUCxHQUFpQixPQUFPLENBQUMsTUFBUixDQUVoQjtBQUFBLEVBQUEsRUFBQSxFQUFJLFFBQVEsQ0FBQyxJQUFiO0FBQUEsRUFFQSxNQUFBLEVBQVEsSUFGUjtBQUFBLEVBSUEsUUFBQSxFQUFVLE9BQUEsQ0FBUSxnQkFBUixDQUpWO0FBQUEsRUFNQSxJQUFBLEVBQ0M7QUFBQSxJQUFBLElBQUEsRUFBTSxJQUFOO0FBQUEsSUFDQSxLQUFBLEVBQU8sSUFEUDtHQVBEO0FBQUEsRUFVQSxNQUFBLEVBQVEsU0FBQSxHQUFBO0FBQ1AsSUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLGtCQUFaLENBQUEsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLE9BQUQsQ0FBQSxDQUZBLENBQUE7V0FJQSxJQUFDLENBQUEsVUFBRCxDQUFBLEVBTE87RUFBQSxDQVZSO0FBQUEsRUFpQkEsT0FBQSxFQUFTLFNBQUEsR0FBQTtBQUVSLFFBQUEsRUFBQTtBQUFBLElBQUEsRUFBQSxHQUFTLElBQUEsUUFBQSxDQUFTLFVBQUEsR0FBVyxNQUFNLENBQUMsUUFBbEIsR0FBMkIsa0JBQXBDLENBQVQsQ0FBQTtXQUNBLEVBQUUsQ0FBQyxFQUFILENBQU0sT0FBTixFQUFlLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLFFBQUQsR0FBQTtlQUVkLE9BQU8sQ0FBQyxHQUFSLENBQVksS0FBWixFQUFtQixRQUFRLENBQUMsR0FBVCxDQUFBLENBQW5CLEVBRmM7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFmLEVBR0UsU0FBQyxHQUFELEdBQUE7YUFDRSxPQUFPLENBQUMsR0FBUixDQUFZLE1BQVosRUFBb0IsR0FBRyxDQUFDLElBQXhCLEVBREY7SUFBQSxDQUhGLEVBSFE7RUFBQSxDQWpCVDtBQUFBLEVBMEJBLFVBQUEsRUFBWSxTQUFBLEdBQUE7QUFDWCxRQUFBLElBQUE7QUFBQSxJQUFBLElBQUEsR0FBTyxJQUFQLENBQUE7QUFBQSxJQUVBLElBQUEsQ0FBSyxHQUFMLEVBQVUsU0FBQSxHQUFBO0FBQ1QsTUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLG1CQUFaLENBQUEsQ0FBQTthQUNBLElBQUksQ0FBQyxHQUFMLENBQVM7QUFBQSxRQUFBLE1BQUEsRUFBUSxPQUFSO09BQVQsRUFGUztJQUFBLENBQVYsQ0FGQSxDQUFBO1dBTUEsSUFBQSxDQUFLO0FBQUEsTUFBQSxLQUFBLEVBQU8sS0FBUDtBQUFBLE1BQWMsUUFBQSxFQUFVLElBQXhCO0FBQUEsTUFBOEIsUUFBQSxFQUFVLEtBQXhDO0tBQUwsRUFQVztFQUFBLENBMUJaO0NBRmdCLENBTmpCLENBQUE7Ozs7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIiMgcmVnaXN0ZXIgYWxsIG1vZHVsZXNcbnJlcXVpcmUgXCIuL21vZHVsZS9pbmRleFwiXG5cbiMgcmVxdWlyZSBHU0FQXG5yZXF1aXJlIFwiZ3NhcFwiXG5cbiMgcmVxdWlyZSBSYWN0aXZlIHBsdWdpbnNcbnJlcXVpcmUgXCJyYWN0aXZlLWV2ZW50cy10YXBcIlxucmVxdWlyZSBcInJhY3RpdmUtdG91Y2hcIlxucmVxdWlyZSBcInJhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZVwiXG5yZXF1aXJlIFwicmFjdGl2ZS10cmFuc2l0aW9ucy1mbHlcIlxucmVxdWlyZSBcInJhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGVcIlxuXG4jIHdhaXQgZm9yIHdoZW4gdGhlIGRvbSBpcyByZWFkeSBhbmQgbG9hZCBtYWluIHZpZXdcbnJlcXVpcmUoXCJkb21yZWFkeVwiKSAtPlxuXHRyZXF1aXJlKFwiLi9hcHAtZGVidWdcIikoKSBpZiBwcm9jZXNzLmVudi5OT0RFX0VOViBpcyBcImRldmVsb3BtZW50XCJcblxuXHRWaWV3ID0gcmVxdWlyZSBcIi4vdmlldy9tYWluLXZpZXdcIlxuXHR3aW5kb3cuX3ZpZXcgPSBuZXcgVmlldygpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdmVuZG9yL2RhdC5ndWknKVxubW9kdWxlLmV4cG9ydHMuY29sb3IgPSByZXF1aXJlKCcuL3ZlbmRvci9kYXQuY29sb3InKSIsIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4vKiogQG5hbWVzcGFjZSAqL1xudmFyIGRhdCA9IG1vZHVsZS5leHBvcnRzID0gZGF0IHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbG9yID0gZGF0LmNvbG9yIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LnV0aWxzID0gZGF0LnV0aWxzIHx8IHt9O1xuXG5kYXQudXRpbHMuY29tbW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgXG4gIHZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB2YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBCYW5kLWFpZCBtZXRob2RzIGZvciB0aGluZ3MgdGhhdCBzaG91bGQgYmUgYSBsb3QgZWFzaWVyIGluIEphdmFTY3JpcHQuXG4gICAqIEltcGxlbWVudGF0aW9uIGFuZCBzdHJ1Y3R1cmUgaW5zcGlyZWQgYnkgdW5kZXJzY29yZS5qc1xuICAgKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gICAqL1xuXG4gIHJldHVybiB7IFxuICAgIFxuICAgIEJSRUFLOiB7fSxcbiAgXG4gICAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZmluZWQob2JqW2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICBcbiAgICB9LFxuICAgIFxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZWFjaDogZnVuY3Rpb24ob2JqLCBpdHIsIHNjb3BlKSB7XG5cbiAgICAgIFxuICAgICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkgeyBcbiAgICAgICAgXG4gICAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHsgLy8gSXMgbnVtYmVyIGJ1dCBub3QgTmFOXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgPSAwLCBsID0gb2JqLmxlbmd0aDsga2V5IDwgbDsga2V5KyspXG4gICAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBcbiAgICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmVyOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZm5jLCAwKTtcbiAgICB9LFxuICAgIFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICAgIH0sXG5cbiAgICBpc1VuZGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBcbiAgICBpc051bGw6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9LFxuICAgIFxuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICB9LFxuICAgIFxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKzA7XG4gICAgfSxcbiAgICBcbiAgICBpc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorJyc7XG4gICAgfSxcbiAgICBcbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuICBcbiAgfTtcbiAgICBcbn0pKCk7XG5cblxuZGF0LmNvbG9yLnRvU3RyaW5nID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICByZXR1cm4gZnVuY3Rpb24oY29sb3IpIHtcblxuICAgIGlmIChjb2xvci5hID09IDEgfHwgY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLmEpKSB7XG5cbiAgICAgIHZhciBzID0gY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgIHdoaWxlIChzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5nKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuYikgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuXG4gICAgfVxuXG4gIH1cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LkNvbG9yID0gZGF0LmNvbG9yLkNvbG9yID0gKGZ1bmN0aW9uIChpbnRlcnByZXQsIG1hdGgsIHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93ICdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuXG5cbiAgfTtcblxuICBDb2xvci5DT01QT05FTlRTID0gWydyJywnZycsJ2InLCdoJywncycsJ3YnLCdoZXgnLCdhJ107XG5cbiAgY29tbW9uLmV4dGVuZChDb2xvci5wcm90b3R5cGUsIHtcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9PcmlnaW5hbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5cbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICAgIH1cblxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBtYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJylcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVSR0IoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuXG4gICAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBtYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuXG4gICAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIG1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aHJvdyAnQ29ycnVwdGVkIGNvbG9yIHN0YXRlJztcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVIU1YoY29sb3IpIHtcblxuICAgIHZhciByZXN1bHQgPSBtYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICBzOiByZXN1bHQucyxcbiAgICAgICAgICB2OiByZXN1bHQudlxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGlmICghY29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gICAgfSBlbHNlIGlmIChjb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBDb2xvcjtcblxufSkoZGF0LmNvbG9yLmludGVycHJldCA9IChmdW5jdGlvbiAodG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciByZXN1bHQsIHRvUmV0dXJuO1xuXG4gIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRvUmV0dXJuID0gZmFsc2U7XG5cbiAgICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG5cbiAgICBjb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uKGZhbWlseSkge1xuXG4gICAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcblxuICAgICAgICBjb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuXG4gICAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9O1xuXG4gIHZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG5cbiAgICAvLyBTdHJpbmdzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc1N0cmluZyxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBUSFJFRV9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV0pKFtBLUYwLTldKShbQS1GMC05XSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KFxuICAgICAgICAgICAgICAgICAgJzB4JyArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBTSVhfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0JBOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwsXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gTnVtYmVyc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNOdW1iZXIsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgSEVYOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIEFycmF5c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNBcnJheSxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSAzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JBX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBPYmplY3RzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc09iamVjdCxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICBdO1xuXG4gIHJldHVybiBpbnRlcnByZXQ7XG5cblxufSkoZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29sb3IubWF0aCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRtcENvbXBvbmVudDtcblxuICByZXR1cm4ge1xuXG4gICAgaHN2X3RvX3JnYjogZnVuY3Rpb24oaCwgcywgdikge1xuXG4gICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuXG4gICAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxLjAgLSAoZiAqIHMpKTtcbiAgICAgIHZhciB0ID0gdiAqICgxLjAgLSAoKDEuMCAtIGYpICogcykpO1xuICAgICAgdmFyIGMgPSBbXG4gICAgICAgIFt2LCB0LCBwXSxcbiAgICAgICAgW3EsIHYsIHBdLFxuICAgICAgICBbcCwgdiwgdF0sXG4gICAgICAgIFtwLCBxLCB2XSxcbiAgICAgICAgW3QsIHAsIHZdLFxuICAgICAgICBbdiwgcCwgcV1cbiAgICAgIF1baGldO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdICogMjU1LFxuICAgICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgICBiOiBjWzJdICogMjU1XG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIHJnYl90b19oc3Y6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblxuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgIGgsIHM7XG5cbiAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IE5hTixcbiAgICAgICAgICBzOiAwLFxuICAgICAgICAgIHY6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIgPT0gbWF4KSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBoICogMzYwLFxuICAgICAgICBzOiBzLFxuICAgICAgICB2OiBtYXggLyAyNTVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJnYl90b19oZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgICAgcmV0dXJuIGhleDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgICByZXR1cm4gKGhleCA+PiAoY29tcG9uZW50SW5kZXggKiA4KSkgJiAweEZGO1xuICAgIH0sXG5cbiAgICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCAoaGV4ICYgfiAoMHhGRiA8PCB0bXBDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgfVxuXG59KSgpLFxuZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbik7IiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbi8qKiBAbmFtZXNwYWNlICovXG52YXIgZGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBkYXQgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuZ3VpID0gZGF0Lmd1aSB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC51dGlscyA9IGRhdC51dGlscyB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb250cm9sbGVycyA9IGRhdC5jb250cm9sbGVycyB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5kb20gPSBkYXQuZG9tIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbG9yID0gZGF0LmNvbG9yIHx8IHt9O1xuXG5kYXQudXRpbHMuY3NzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2FkOiBmdW5jdGlvbiAodXJsLCBkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgIHZhciBsaW5rID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgIGxpbmsudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0sXG4gICAgaW5qZWN0OiBmdW5jdGlvbihjc3MsIGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgdmFyIGluamVjdGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIGluamVjdGVkLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzO1xuICAgICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoaW5qZWN0ZWQpO1xuICAgIH1cbiAgfVxufSkoKTtcblxuXG5kYXQudXRpbHMuY29tbW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgXG4gIHZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB2YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBCYW5kLWFpZCBtZXRob2RzIGZvciB0aGluZ3MgdGhhdCBzaG91bGQgYmUgYSBsb3QgZWFzaWVyIGluIEphdmFTY3JpcHQuXG4gICAqIEltcGxlbWVudGF0aW9uIGFuZCBzdHJ1Y3R1cmUgaW5zcGlyZWQgYnkgdW5kZXJzY29yZS5qc1xuICAgKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gICAqL1xuXG4gIHJldHVybiB7IFxuICAgIFxuICAgIEJSRUFLOiB7fSxcbiAgXG4gICAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZmluZWQob2JqW2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICBcbiAgICB9LFxuICAgIFxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZWFjaDogZnVuY3Rpb24ob2JqLCBpdHIsIHNjb3BlKSB7XG5cbiAgICAgIFxuICAgICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkgeyBcbiAgICAgICAgXG4gICAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHsgLy8gSXMgbnVtYmVyIGJ1dCBub3QgTmFOXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgPSAwLCBsID0gb2JqLmxlbmd0aDsga2V5IDwgbDsga2V5KyspXG4gICAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBcbiAgICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmVyOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZm5jLCAwKTtcbiAgICB9LFxuICAgIFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICAgIH0sXG5cbiAgICBpc1VuZGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBcbiAgICBpc051bGw6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9LFxuICAgIFxuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICB9LFxuICAgIFxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKzA7XG4gICAgfSxcbiAgICBcbiAgICBpc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorJyc7XG4gICAgfSxcbiAgICBcbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuICBcbiAgfTtcbiAgICBcbn0pKCk7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQW4gXCJhYnN0cmFjdFwiIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXG4gICAgLyoqXG4gICAgICogVGhvc2Ugd2hvIGV4dGVuZCB0aGlzIGNsYXNzIHdpbGwgcHV0IHRoZWlyIERPTSBlbGVtZW50cyBpbiBoZXJlLlxuICAgICAqIEB0eXBlIHtET01FbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0byBtYW5pcHVsYXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBtYW5pcHVsYXRlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNoYW5nZS5cbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZmluaXNoaW5nIGNoYW5nZS5cbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IHVuZGVmaW5lZDtcblxuICB9O1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLnByb3RvdHlwZSAqL1xuICAgICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoYXQgYSBmdW5jdGlvbiBmaXJlIGV2ZXJ5IHRpbWUgc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZSB3aXRoXG4gICAgICAgICAqIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5jIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlXG4gICAgICAgICAqIGlzIG1vZGlmaWVkIHZpYSB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSB0aGF0IGEgZnVuY3Rpb24gZmlyZSBldmVyeSB0aW1lIHNvbWVvbmUgXCJmaW5pc2hlc1wiIGNoYW5naW5nXG4gICAgICAgICAqIHRoZSB2YWx1ZSB3aWggdGhpcyBDb250cm9sbGVyLiBVc2VmdWwgZm9yIHZhbHVlcyB0aGF0IGNoYW5nZVxuICAgICAgICAgKiBpbmNyZW1lbnRhbGx5IGxpa2UgbnVtYmVycyBvciBzdHJpbmdzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbmMgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlclxuICAgICAgICAgKiBzb21lb25lIFwiZmluaXNoZXNcIiBjaGFuZ2luZyB0aGUgdmFsdWUgdmlhIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBvbkZpbmlzaENoYW5nZTogZnVuY3Rpb24oZm5jKSB7XG4gICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gZm5jO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjdXJyZW50IHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoZXMgdGhlIHZpc3VhbCBkaXNwbGF5IG9mIGEgQ29udHJvbGxlciBpbiBvcmRlciB0byBrZWVwIHN5bmNcbiAgICAgICAgICogd2l0aCB0aGUgb2JqZWN0J3MgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIHZhbHVlIGhhcyBkZXZpYXRlZCBmcm9tIGluaXRpYWxWYWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNNb2RpZmllZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKClcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gQ29udHJvbGxlcjtcblxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuZG9tLmRvbSA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgdmFyIEVWRU5UX01BUCA9IHtcbiAgICAnSFRNTEV2ZW50cyc6IFsnY2hhbmdlJ10sXG4gICAgJ01vdXNlRXZlbnRzJzogWydjbGljaycsJ21vdXNlbW92ZScsJ21vdXNlZG93bicsJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gICAgJ0tleWJvYXJkRXZlbnRzJzogWydrZXlkb3duJ11cbiAgfTtcblxuICB2YXIgRVZFTlRfTUFQX0lOViA9IHt9O1xuICBjb21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICBjb21tb24uZWFjaCh2LCBmdW5jdGlvbihlKSB7XG4gICAgICBFVkVOVF9NQVBfSU5WW2VdID0gaztcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIENTU19WQUxVRV9QSVhFTFMgPSAvKFxcZCsoXFwuXFxkKyk/KXB4LztcblxuICBmdW5jdGlvbiBjc3NWYWx1ZVRvUGl4ZWxzKHZhbCkge1xuXG4gICAgaWYgKHZhbCA9PT0gJzAnIHx8IGNvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSByZXR1cm4gMDtcblxuICAgIHZhciBtYXRjaCA9IHZhbC5tYXRjaChDU1NfVkFMVUVfUElYRUxTKTtcblxuICAgIGlmICghY29tbW9uLmlzTnVsbChtYXRjaCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC4uLmVtcz8gJT9cblxuICAgIHJldHVybiAwO1xuXG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyIGRhdC5kb21cbiAgICovXG4gIHZhciBkb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBzZWxlY3RhYmxlXG4gICAgICovXG4gICAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uKGVsZW0sIHNlbGVjdGFibGUpIHtcblxuICAgICAgaWYgKGVsZW0gPT09IHVuZGVmaW5lZCB8fCBlbGVtLnN0eWxlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgZWxlbS5vbnNlbGVjdHN0YXJ0ID0gc2VsZWN0YWJsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuXG4gICAgICBlbGVtLnN0eWxlLk1velVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgICAgZWxlbS51bnNlbGVjdGFibGUgPSBzZWxlY3RhYmxlID8gJ29uJyA6ICdvZmYnO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gaG9yaXpvbnRhbFxuICAgICAqIEBwYXJhbSB2ZXJ0aWNhbFxuICAgICAqL1xuICAgIG1ha2VGdWxsc2NyZWVuOiBmdW5jdGlvbihlbGVtLCBob3Jpem9udGFsLCB2ZXJ0aWNhbCkge1xuXG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGhvcml6b250YWwpKSBob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB2ZXJ0aWNhbCA9IHRydWU7XG5cbiAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBlbGVtLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBlbGVtLnN0eWxlLnRvcCA9IDA7XG4gICAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBmYWtlRXZlbnQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50VHlwZSwgcGFyYW1zLCBhdXgpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBFVkVOVF9NQVBfSU5WW2V2ZW50VHlwZV07XG4gICAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChjbGFzc05hbWUpO1xuICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSAnTW91c2VFdmVudHMnOlxuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSxcbiAgICAgICAgICAgICAgMCwgLy9zY3JlZW4gWFxuICAgICAgICAgICAgICAwLCAvL3NjcmVlbiBZXG4gICAgICAgICAgICAgIGNsaWVudFgsIC8vY2xpZW50IFhcbiAgICAgICAgICAgICAgY2xpZW50WSwgLy9jbGllbnQgWVxuICAgICAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAgICB2YXIgaW5pdCA9IGV2dC5pbml0S2V5Ym9hcmRFdmVudCB8fCBldnQuaW5pdEtleUV2ZW50OyAvLyB3ZWJraXQgfHwgbW96XG4gICAgICAgICAgY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdyxcbiAgICAgICAgICAgICAgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksXG4gICAgICAgICAgICAgIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksXG4gICAgICAgICAgICAgIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqIEBwYXJhbSBib29sXG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGJvb2wgPSBib29sIHx8IGZhbHNlO1xuICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpXG4gICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqIEBwYXJhbSBib29sXG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xuICAgICAgYm9vbCA9IGJvb2wgfHwgZmFsc2U7XG4gICAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKVxuICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudClcbiAgICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblxuICAgICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItcmlnaHQtd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctbGVmdCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnd2lkdGgnXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblxuICAgICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctdG9wJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWJvdHRvbSddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnaGVpZ2h0J10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0ge2xlZnQ6IDAsIHRvcDowfTtcbiAgICAgIGlmIChlbGVtLm9mZnNldFBhcmVudCkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb2Zmc2V0LmxlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuICAgICAgICAgIG9mZnNldC50b3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIH0gd2hpbGUgKGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcG9zdHMvMjY4NDU2MS9yZXZpc2lvbnNcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgKTtcbiAgICB9XG5cbiAgfTtcblxuICByZXR1cm4gZG9tO1xuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgc2VsZWN0IGlucHV0IHRvIGFsdGVyIHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIHVzaW5nIGFcbiAgICogbGlzdCBvZiBhY2NlcHRlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ1tdfSBvcHRpb25zIEEgbWFwIG9mIGxhYmVscyB0byBhY2NlcHRhYmxlIHZhbHVlcywgb3JcbiAgICogYSBsaXN0IG9mIGFjY2VwdGFibGUgc3RyaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBPcHRpb25Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgb3B0aW9ucykge1xuXG4gICAgT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRyb3AgZG93biBtZW51XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblxuICAgIGlmIChjb21tb24uaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgY29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cblxuICAgIGNvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblxuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcblxuICAgIH0pO1xuXG4gICAgLy8gQWNrbm93bGVkZ2Ugb3JpZ2luYWwgdmFsdWVcbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3NlbGVjdCk7XG5cbiAgfTtcblxuICBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciB0b1JldHVybiA9IE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heF0gTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLnN0ZXBdIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHRoaXMuX19taW4gPSBwYXJhbXMubWluO1xuICAgIHRoaXMuX19tYXggPSBwYXJhbXMubWF4O1xuICAgIHRoaXMuX19zdGVwID0gcGFyYW1zLnN0ZXA7XG5cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19zdGVwKSkge1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgPT0gMCkge1xuICAgICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSAxOyAvLyBXaGF0IGFyZSB3ZSwgcHN5Y2hpY3M/XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIZXkgRG91ZywgY2hlY2sgdGhpcyBvdXQuXG4gICAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHRoaXMuaW5pdGlhbFZhbHVlKS9NYXRoLkxOMTApKS8xMDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHRoaXMuX19zdGVwO1xuXG4gICAgfVxuXG4gICAgdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKHRoaXMuX19pbXBsaWVkU3RlcCk7XG5cblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUgKi9cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiB2IDwgdGhpcy5fX21pbikge1xuICAgICAgICAgICAgdiA9IHRoaXMuX19taW47XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgdiA+IHRoaXMuX19tYXgpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLl9fbWF4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIHYgJSB0aGlzLl9fc3RlcCAhPSAwKSB7XG4gICAgICAgICAgICB2ID0gTWF0aC5yb3VuZCh2IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgbWluaW11bSB2YWx1ZSBmb3IgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5WYWx1ZSBUaGUgbWluaW11bSB2YWx1ZSBmb3JcbiAgICAgICAgICogPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fbWluID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIG1heGltdW0gdmFsdWUgZm9yIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4VmFsdWUgVGhlIG1heGltdW0gdmFsdWUgZm9yXG4gICAgICAgICAqIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX21heCA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBzdGVwIHZhbHVlIHRoYXQgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICAgICAgICogaW5jcmVtZW50cyBieS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBWYWx1ZSBUaGUgc3RlcCB2YWx1ZSBmb3JcbiAgICAgICAgICogZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICAgICAgICogQGRlZmF1bHQgaWYgbWluaW11bSBhbmQgbWF4aW11bSBzcGVjaWZpZWQgaW5jcmVtZW50IGlzIDElIG9mIHRoZVxuICAgICAgICAgKiBkaWZmZXJlbmNlIG90aGVyd2lzZSBzdGVwVmFsdWUgaXMgMVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fc3RlcCA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gbnVtRGVjaW1hbHMoeCkge1xuICAgIHggPSB4LnRvU3RyaW5nKCk7XG4gICAgaWYgKHguaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHJldHVybiB4Lmxlbmd0aCAtIHguaW5kZXhPZignLicpIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3ggPSAoZnVuY3Rpb24gKE51bWJlckNvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIgYW5kXG4gICAqIHByb3ZpZGVzIGFuIGlucHV0IGVsZW1lbnQgd2l0aCB3aGljaCB0byBtYW5pcHVsYXRlIGl0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5taW5dIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5zdGVwXSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcblxuICAgIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcyk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICoge051bWJlcn0gUHJldmlvdXMgbW91c2UgeSBwb3NpdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YXIgcHJldl95O1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcblxuICAgIC8vIE1ha2VzIGl0IHNvIG1hbnVhbGx5IHNwZWNpZmllZCB2YWx1ZXMgYXJlIG5vdCB0cnVuY2F0ZWQuXG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIC8vIFdoZW4gcHJlc3NpbmcgZW50aXJlLCB5b3UgY2FuIGJlIGFzIHByZWNpc2UgYXMgeW91IHdhbnQuXG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgdmFyIGF0dGVtcHRlZCA9IHBhcnNlRmxvYXQoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgICBpZiAoIWNvbW1vbi5pc05hTihhdHRlbXB0ZWQpKSBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldl95ID0gZS5jbGllbnRZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcblxuICAgICAgdmFyIGRpZmYgPSBwcmV2X3kgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuXG4gICAgICBwcmV2X3kgPSBlLmNsaWVudFk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcyA9IE51bWJlckNvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUsXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPyB0aGlzLmdldFZhbHVlKCkgOiByb3VuZFRvRGVjaW1hbCh0aGlzLmdldFZhbHVlKCksIHRoaXMuX19wcmVjaXNpb24pO1xuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiByb3VuZFRvRGVjaW1hbCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICB2YXIgdGVuVG8gPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcblxufSkoZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyID0gKGZ1bmN0aW9uIChOdW1iZXJDb250cm9sbGVyLCBkb20sIGNzcywgY29tbW9uLCBzdHlsZVNoZWV0KSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIsIGNvbnRhaW5zXG4gICAqIGEgbWluaW11bSBhbmQgbWF4aW11bSwgYW5kIHByb3ZpZGVzIGEgc2xpZGVyIGVsZW1lbnQgd2l0aCB3aGljaCB0b1xuICAgKiBtYW5pcHVsYXRlIGl0LiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGUgc2xpZGVyIGVsZW1lbnQgaXMgbWFkZSB1cCBvZlxuICAgKiA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT4gdGFncywgPHN0cm9uZz5ub3Q8L3N0cm9uZz4gdGhlIGh0bWw1XG4gICAqIDxjb2RlPiZsdDtzbGlkZXImZ3Q7PC9jb2RlPiBlbGVtZW50LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblZhbHVlIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4VmFsdWUgTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwVmFsdWUgSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCkge1xuXG4gICAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAgfSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2JhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIFxuXG5cbiAgICBkb20uYmluZCh0aGlzLl9fYmFja2dyb3VuZCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2JhY2tncm91bmQsICdzbGlkZXInKTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2ZvcmVncm91bmQsICdzbGlkZXItZmcnKTtcblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcblxuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gZG9tLmdldE9mZnNldChfdGhpcy5fX2JhY2tncm91bmQpO1xuICAgICAgdmFyIHdpZHRoID0gZG9tLmdldFdpZHRoKF90aGlzLl9fYmFja2dyb3VuZCk7XG4gICAgICBcbiAgICAgIF90aGlzLnNldFZhbHVlKFxuICAgICAgICBtYXAoZS5jbGllbnRYLCBvZmZzZXQubGVmdCwgb2Zmc2V0LmxlZnQgKyB3aWR0aCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuX19iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuX19mb3JlZ3JvdW5kKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2JhY2tncm91bmQpO1xuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzID0gTnVtYmVyQ29udHJvbGxlcjtcblxuICAvKipcbiAgICogSW5qZWN0cyBkZWZhdWx0IHN0eWxlc2hlZXQgZm9yIHNsaWRlciBlbGVtZW50cy5cbiAgICovXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXIudXNlRGVmYXVsdFN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG4gIH07XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUsXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwY3QgPSAodGhpcy5nZXRWYWx1ZSgpIC0gdGhpcy5fX21pbikvKHRoaXMuX19tYXggLSB0aGlzLl9fbWluKTtcbiAgICAgICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCoxMDArJyUnO1xuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cblxuXG4gICk7XG5cbiAgZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gICAgcmV0dXJuIG8xICsgKG8yIC0gbzEpICogKCh2IC0gaTEpIC8gKGkyIC0gaTEpKTtcbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyO1xuICBcbn0pKGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY3NzLFxuZGF0LnV0aWxzLmNvbW1vbixcblwiLnNsaWRlciB7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjE1KTtcXG4gIGhlaWdodDogMWVtO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIHBhZGRpbmc6IDAgMC41ZW07XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uc2xpZGVyLWZnIHtcXG4gIHBhZGRpbmc6IDFweCAwIDJweCAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2FhYTtcXG4gIGhlaWdodDogMWVtO1xcbiAgbWFyZ2luLWxlZnQ6IC0wLjVlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNWVtO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtIDAgMCAxZW07XFxufVxcblxcbi5zbGlkZXItZmc6YWZ0ZXIge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGJvcmRlcjogIDFweCBzb2xpZCAjYWFhO1xcbiAgY29udGVudDogJyc7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tcmlnaHQ6IC0xZW07XFxuICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgaGVpZ2h0OiAwLjllbTtcXG4gIHdpZHRoOiAwLjllbTtcXG59XCIpO1xuXG5cbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIEdVSSBpbnRlcmZhY2UgdG8gZmlyZSBhIHNwZWNpZmllZCBtZXRob2QsIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIEZ1bmN0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHRleHQpIHtcblxuICAgIEZ1bmN0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZCh0aGlzLl9fYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19idXR0b24pO1xuXG5cbiAgfTtcblxuICBGdW5jdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgRnVuY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAge1xuICAgICAgICBcbiAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoKS5jYWxsKHRoaXMub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgY2hlY2tib3ggaW5wdXQgdG8gYWx0ZXIgdGhlIGJvb2xlYW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIEJvb2xlYW5Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICAgIHRoaXMuX19jaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuXG5cbiAgICBkb20uYmluZCh0aGlzLl9fY2hlY2tib3gsICdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jaGVja2JveCk7XG5cbiAgICAvLyBNYXRjaCBvcmlnaW5hbCB2YWx1ZVxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZSghX3RoaXMuX19wcmV2KTtcbiAgICB9XG5cbiAgfTtcblxuICBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IHRydWU7ICAgIFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcblxuICAgICAgICB9XG5cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbG9yLnRvU3RyaW5nID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICByZXR1cm4gZnVuY3Rpb24oY29sb3IpIHtcblxuICAgIGlmIChjb2xvci5hID09IDEgfHwgY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLmEpKSB7XG5cbiAgICAgIHZhciBzID0gY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgIHdoaWxlIChzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5nKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuYikgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuXG4gICAgfVxuXG4gIH1cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbG9yLmludGVycHJldCA9IChmdW5jdGlvbiAodG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciByZXN1bHQsIHRvUmV0dXJuO1xuXG4gIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRvUmV0dXJuID0gZmFsc2U7XG5cbiAgICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG5cbiAgICBjb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uKGZhbWlseSkge1xuXG4gICAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcblxuICAgICAgICBjb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuXG4gICAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9O1xuXG4gIHZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG5cbiAgICAvLyBTdHJpbmdzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc1N0cmluZyxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBUSFJFRV9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV0pKFtBLUYwLTldKShbQS1GMC05XSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KFxuICAgICAgICAgICAgICAgICAgJzB4JyArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBTSVhfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0JBOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwsXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gTnVtYmVyc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNOdW1iZXIsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgSEVYOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIEFycmF5c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNBcnJheSxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSAzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JBX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBPYmplY3RzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc09iamVjdCxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICBdO1xuXG4gIHJldHVybiBpbnRlcnByZXQ7XG5cblxufSkoZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LkdVSSA9IGRhdC5ndWkuR1VJID0gKGZ1bmN0aW9uIChjc3MsIHNhdmVEaWFsb2d1ZUNvbnRlbnRzLCBzdHlsZVNoZWV0LCBjb250cm9sbGVyRmFjdG9yeSwgQ29udHJvbGxlciwgQm9vbGVhbkNvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgTnVtYmVyQ29udHJvbGxlckJveCwgTnVtYmVyQ29udHJvbGxlclNsaWRlciwgT3B0aW9uQ29udHJvbGxlciwgQ29sb3JDb250cm9sbGVyLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIENlbnRlcmVkRGl2LCBkb20sIGNvbW1vbikge1xuXG4gIGNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG5cbiAgLyoqIE91dGVyLW1vc3QgY2xhc3NOYW1lIGZvciBHVUkncyAqL1xuICB2YXIgQ1NTX05BTUVTUEFDRSA9ICdkZyc7XG5cbiAgdmFyIEhJREVfS0VZX0NPREUgPSA3MjtcblxuICAvKiogVGhlIG9ubHkgdmFsdWUgc2hhcmVkIGJldHdlZW4gdGhlIEpTIGFuZCBTQ1NTLiBVc2UgY2F1dGlvbi4gKi9cbiAgdmFyIENMT1NFX0JVVFRPTl9IRUlHSFQgPSAyMDtcblxuICB2YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xuXG4gIHZhciBTVVBQT1JUU19MT0NBTF9TVE9SQUdFID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gJ2xvY2FsU3RvcmFnZScgaW4gd2luZG93ICYmIHdpbmRvd1snbG9jYWxTdG9yYWdlJ10gIT09IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcblxuICB2YXIgU0FWRV9ESUFMT0dVRTtcblxuICAvKiogSGF2ZSB3ZSB5ZXQgdG8gY3JlYXRlIGFuIGF1dG9QbGFjZSBHVUk/ICovXG4gIHZhciBhdXRvX3BsYWNlX3ZpcmdpbiA9IHRydWU7XG5cbiAgLyoqIEZpeGVkIHBvc2l0aW9uIGRpdiB0aGF0IGF1dG8gcGxhY2UgR1VJJ3MgZ28gaW5zaWRlICovXG4gIHZhciBhdXRvX3BsYWNlX2NvbnRhaW5lcjtcblxuICAvKiogQXJlIHdlIGhpZGluZyB0aGUgR1VJJ3MgPyAqL1xuICB2YXIgaGlkZSA9IGZhbHNlO1xuXG4gIC8qKiBHVUkncyB3aGljaCBzaG91bGQgYmUgaGlkZGVuICovXG4gIHZhciBoaWRlYWJsZV9ndWlzID0gW107XG5cbiAgLyoqXG4gICAqIEEgbGlnaHR3ZWlnaHQgY29udHJvbGxlciBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LiBJdCBhbGxvd3MgeW91IHRvIGVhc2lseVxuICAgKiBtYW5pcHVsYXRlIHZhcmlhYmxlcyBhbmQgZmlyZSBmdW5jdGlvbnMgb24gdGhlIGZseS5cbiAgICogQGNsYXNzXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0Lmd1aVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubmFtZV0gVGhlIG5hbWUgb2YgdGhpcyBHVUkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zLmxvYWRdIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2F2ZWQgc3RhdGUgb2ZcbiAgICogdGhpcyBHVUkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5hdXRvPXRydWVdXG4gICAqIEBwYXJhbSB7ZGF0Lmd1aS5HVUl9IFtwYXJhbXMucGFyZW50XSBUaGUgR1VJIEknbSBuZXN0ZWQgaW4uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5jbG9zZWRdIElmIHRydWUsIHN0YXJ0cyBjbG9zZWRcbiAgICovXG4gIHZhciBHVUkgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBPdXRlcm1vc3QgRE9NIEVsZW1lbnRcbiAgICAgKiBAdHlwZSBET01FbGVtZW50XG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3VsKTtcblxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuXG4gICAgLyoqXG4gICAgICogTmVzdGVkIEdVSSdzIGJ5IG5hbWVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX2ZvbGRlcnMgPSB7fTtcblxuICAgIHRoaXMuX19jb250cm9sbGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBvYmplY3RzIEknbSByZW1lbWJlcmluZyBmb3Igc2F2ZSwgb25seSB1c2VkIGluIHRvcCBsZXZlbCBHVUlcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBpbmRleCBvZiByZW1lbWJlcmVkIG9iamVjdHMgdG8gYSBtYXAgb2YgY29udHJvbGxlcnMsIG9ubHkgdXNlZFxuICAgICAqIGluIHRvcCBsZXZlbCBHVUkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW1xuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydHlOYW1lOiBDb250cm9sbGVyLFxuICAgICAqICAgIGFub3RoZXJQcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXJcbiAgICAgKiAgfSxcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuICAgICAqICB9XG4gICAgICogXVxuICAgICAqL1xuICAgIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcblxuICAgIHRoaXMuX19saXN0ZW5pbmcgPSBbXTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIC8vIERlZmF1bHQgcGFyYW1ldGVyc1xuICAgIHBhcmFtcyA9IGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgIGF1dG9QbGFjZTogdHJ1ZSxcbiAgICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICAgIH0pO1xuXG4gICAgcGFyYW1zID0gY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgcmVzaXphYmxlOiBwYXJhbXMuYXV0b1BsYWNlLFxuICAgICAgaGlkZWFibGU6IHBhcmFtcy5hdXRvUGxhY2VcbiAgICB9KTtcblxuXG4gICAgaWYgKCFjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG5cbiAgICAgIC8vIEV4cGxpY2l0IHByZXNldFxuICAgICAgaWYgKHBhcmFtcy5wcmVzZXQpIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBwYXJhbXMubG9hZCA9IHsgcHJlc2V0OiBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgfTtcblxuICAgIH1cblxuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgICBoaWRlYWJsZV9ndWlzLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gT25seSByb290IGxldmVsIEdVSSdzIGFyZSByZXNpemFibGUuXG4gICAgcGFyYW1zLnJlc2l6YWJsZSA9IGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuXG5cbiAgICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgfVxuLy8gICAgcGFyYW1zLnNjcm9sbGFibGUgPSBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnNjcm9sbGFibGUgPT09IHRydWU7XG5cbiAgICAvLyBOb3QgcGFydCBvZiBwYXJhbXMgYmVjYXVzZSBJIGRvbid0IHdhbnQgcGVvcGxlIHBhc3NpbmcgdGhpcyBpbiB2aWFcbiAgICAvLyBjb25zdHJ1Y3Rvci4gU2hvdWxkIGJlIGEgJ3JlbWVtYmVyZWQnIHZhbHVlLlxuICAgIHZhciB1c2VfbG9jYWxfc3RvcmFnZSA9XG4gICAgICAgIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiZcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsXG5cbiAgICAgICAgLyoqIEBsZW5kcyBkYXQuZ3VpLkdVSS5wcm90b3R5cGUgKi9cbiAgICAgICAge1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHBhcmVudCA8Y29kZT5HVUk8L2NvZGU+XG4gICAgICAgICAgICogQHR5cGUgZGF0Lmd1aS5HVUlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzY3JvbGxhYmxlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLnNjcm9sbGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEhhbmRsZXMgPGNvZGU+R1VJPC9jb2RlPidzIGVsZW1lbnQgcGxhY2VtZW50IGZvciB5b3VcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgYXV0b1BsYWNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmF1dG9QbGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGlkZW50aWZpZXIgZm9yIGEgc2V0IG9mIHNhdmVkIHZhbHVlc1xuICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHByZXNldDoge1xuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJvb3QoKS5wcmVzZXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkLnByZXNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRSb290KCkucHJlc2V0ID0gdjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFByZXNldFNlbGVjdEluZGV4KHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpcy5yZXZlcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgd2lkdGggb2YgPGNvZGU+R1VJPC9jb2RlPiBlbGVtZW50XG4gICAgICAgICAgICogQHR5cGUgTnVtYmVyXG4gICAgICAgICAgICovXG4gICAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHBhcmFtcy53aWR0aCA9IHY7XG4gICAgICAgICAgICAgIHNldFdpZHRoKF90aGlzLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG5hbWUgb2YgPGNvZGU+R1VJPC9jb2RlPi4gVXNlZCBmb3IgZm9sZGVycy4gaS5lXG4gICAgICAgICAgICogYSBmb2xkZXIncyBuYW1lXG4gICAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAvLyBUT0RPIENoZWNrIGZvciBjb2xsaXNpb25zIGFtb25nIHNpYmxpbmcgZm9sZGVyc1xuICAgICAgICAgICAgICBwYXJhbXMubmFtZSA9IHY7XG4gICAgICAgICAgICAgIGlmICh0aXRsZV9yb3dfbmFtZSkge1xuICAgICAgICAgICAgICAgIHRpdGxlX3Jvd19uYW1lLmlubmVySFRNTCA9IHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdGhlIDxjb2RlPkdVSTwvY29kZT4gaXMgY29sbGFwc2VkIG9yIG5vdFxuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjbG9zZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEZvciBicm93c2VycyB0aGF0IGFyZW4ndCBnb2luZyB0byByZXNwZWN0IHRoZSBDU1MgdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgLy8gTGV0cyBqdXN0IGNoZWNrIG91ciBoZWlnaHQgYWdhaW5zdCB0aGUgd2luZG93IGhlaWdodCByaWdodCBvZmZcbiAgICAgICAgICAgICAgLy8gdGhlIGJhdC5cbiAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSB2ID8gR1VJLlRFWFRfT1BFTiA6IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDb250YWlucyBhbGwgcHJlc2V0c1xuICAgICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxvYWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byB1c2UgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9TdG9yYWdlI2xvY2FsU3RvcmFnZVwiPmxvY2FsU3RvcmFnZTwvYT4gYXMgdGhlIG1lYW5zIGZvclxuICAgICAgICAgICAqIDxjb2RlPnJlbWVtYmVyPC9jb2RlPmluZ1xuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1c2VMb2NhbFN0b3JhZ2U6IHtcblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVzZV9sb2NhbF9zdG9yYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oYm9vbCkge1xuICAgICAgICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgICAgICAgICAgIHVzZV9sb2NhbF9zdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgLy8gQXJlIHdlIGEgcm9vdCBsZXZlbCBHVUk/XG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuXG4gICAgICBwYXJhbXMuY2xvc2VkID0gZmFsc2U7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19NQUlOKTtcbiAgICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcblxuICAgICAgLy8gQXJlIHdlIHN1cHBvc2VkIHRvIGJlIGxvYWRpbmcgbG9jYWxseT9cbiAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG5cbiAgICAgICAgaWYgKHVzZV9sb2NhbF9zdG9yYWdlKSB7XG5cbiAgICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHNhdmVkX2d1aSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2d1aScpKTtcblxuICAgICAgICAgIGlmIChzYXZlZF9ndWkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZF9ndWkpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTik7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcblxuICAgICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuXG5cbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIE9oLCB5b3UncmUgYSBuZXN0ZWQgR1VJIVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aXRsZV9yb3dfbmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aXRsZV9yb3dfbmFtZSwgJ2NvbnRyb2xsZXItbmFtZScpO1xuXG4gICAgICB2YXIgdGl0bGVfcm93ID0gYWRkUm93KF90aGlzLCB0aXRsZV9yb3dfbmFtZSk7XG5cbiAgICAgIHZhciBvbl9jbGlja190aXRsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRpdGxlX3JvdywgJ3RpdGxlJyk7XG4gICAgICBkb20uYmluZCh0aXRsZV9yb3csICdjbGljaycsIG9uX2NsaWNrX3RpdGxlKTtcblxuICAgICAgaWYgKCFwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmF1dG9QbGFjZSkge1xuXG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG5cbiAgICAgICAgaWYgKGF1dG9fcGxhY2VfdmlyZ2luKSB7XG4gICAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b19wbGFjZV9jb250YWluZXIsIENTU19OQU1FU1BBQ0UpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvX3BsYWNlX2NvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1dG9fcGxhY2VfY29udGFpbmVyKTtcbiAgICAgICAgICBhdXRvX3BsYWNlX3ZpcmdpbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHV0IGl0IGluIHRoZSBkb20gZm9yIHlvdS5cbiAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICAvLyBBcHBseSB0aGUgYXV0byBzdHlsZXNcbiAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuXG4gICAgICB9XG5cblxuICAgICAgLy8gTWFrZSBpdCBub3QgZWxhc3RpYy5cbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHNldFdpZHRoKF90aGlzLCBwYXJhbXMud2lkdGgpO1xuXG4gICAgfVxuXG4gICAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpOyB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAnb1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG5cblxuICAgIGlmIChwYXJhbXMucmVzaXphYmxlKSB7XG4gICAgICBhZGRSZXNpemVIYW5kbGUodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICBmdW5jdGlvbiByZXNldFdpZHRoKCkge1xuICAgICAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICAgICAgcm9vdC53aWR0aCArPSAxO1xuICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcm9vdC53aWR0aCAtPSAxO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMucGFyZW50KSB7XG4gICAgICAgIHJlc2V0V2lkdGgoKTtcbiAgICAgIH1cblxuICB9O1xuXG4gIEdVSS50b2dnbGVIaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICBoaWRlID0gIWhpZGU7XG4gICAgY29tbW9uLmVhY2goaGlkZWFibGVfZ3VpcywgZnVuY3Rpb24oZ3VpKSB7XG4gICAgICBndWkuZG9tRWxlbWVudC5zdHlsZS56SW5kZXggPSBoaWRlID8gLTk5OSA6IDk5OTtcbiAgICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBoaWRlID8gMCA6IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgR1VJLkNMQVNTX0FVVE9fUExBQ0UgPSAnYSc7XG4gIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG4gIEdVSS5DTEFTU19NQUlOID0gJ21haW4nO1xuICBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cgPSAnY3InO1xuICBHVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbiAgR1VJLkNMQVNTX0NMT1NFRCA9ICdjbG9zZWQnO1xuICBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OID0gJ2Nsb3NlLWJ1dHRvbic7XG4gIEdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuXG4gIEdVSS5ERUZBVUxUX1dJRFRIID0gMjQ1O1xuICBHVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuICBHVUkuVEVYVF9PUEVOID0gJ09wZW4gQ29udHJvbHMnO1xuXG4gIGRvbS5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiZcbiAgICAgICAgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09IEhJREVfS0VZX0NPREUpKSB7XG4gICAgICBHVUkudG9nZ2xlSGlkZSgpO1xuICAgIH1cblxuICB9LCBmYWxzZSk7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgR1VJLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuZ3VpLkdVSSAqL1xuICAgICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbG9yQ29udHJvbGxlcn0gVGhlIG5ldyBjb250cm9sbGVyIHRoYXQgd2FzIGFkZGVkLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZENvbG9yOiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGNvbnRyb2xsZXJcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblxuICAgICAgICAgIC8vIFRPRE8gbGlzdGVuaW5nP1xuICAgICAgICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChjb250cm9sbGVyLl9fbGkpO1xuICAgICAgICAgIHRoaXMuX19jb250cm9sbGVycy5zbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuZ3VpLkdVSX0gVGhlIG5ldyBmb2xkZXIuXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGlzIEdVSSBhbHJlYWR5IGhhcyBhIGZvbGRlciBieSB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIG5hbWVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRGb2xkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcHJldmVudCBjb2xsaXNpb25zIG9uIG5hbWVzIGluIG9yZGVyIHRvIGhhdmUgYSBrZXlcbiAgICAgICAgICAvLyBieSB3aGljaCB0byByZW1lbWJlciBzYXZlZCB2YWx1ZXNcbiAgICAgICAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgK1xuICAgICAgICAgICAgICAgICcgbmFtZSBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld19ndWlfcGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcblxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyBkb3duIHRoZSBhdXRvUGxhY2UgdHJhaXQgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIG9wZW4vY2xvc2UgZm9sZGVyIGFjdGlvbnMgdG9cbiAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBhIHNjcm9sbGJhciBhcHBlYXJzIGlmIHRoZSB3aW5kb3cgaXMgdG9vIHNob3J0LlxuICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmF1dG9QbGFjZSA9IHRoaXMuYXV0b1BsYWNlO1xuXG4gICAgICAgICAgLy8gRG8gd2UgaGF2ZSBzYXZlZCBhcHBlYXJhbmNlIGRhdGEgZm9yIHRoaXMgZm9sZGVyP1xuXG4gICAgICAgICAgaWYgKHRoaXMubG9hZCAmJiAvLyBBbnl0aGluZyBsb2FkZWQ/XG4gICAgICAgICAgICAgIHRoaXMubG9hZC5mb2xkZXJzICYmIC8vIFdhcyBteSBwYXJlbnQgYSBkZWFkLWVuZD9cbiAgICAgICAgICAgICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHsgLy8gRGlkIGRhZGR5IHJlbWVtYmVyIG1lP1xuXG4gICAgICAgICAgICAvLyBTdGFydCBtZSBjbG9zZWQgaWYgSSB3YXMgY2xvc2VkXG4gICAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG5cbiAgICAgICAgICAgIC8vIFBhc3MgZG93biB0aGUgbG9hZGVkIGRhdGFcbiAgICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmxvYWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBndWkgPSBuZXcgR1VJKG5ld19ndWlfcGFyYW1zKTtcbiAgICAgICAgICB0aGlzLl9fZm9sZGVyc1tuYW1lXSA9IGd1aTtcblxuICAgICAgICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgICAgICAgcmV0dXJuIGd1aTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuXG4gICAgICAgICAgaWYgKHJvb3Quc2Nyb2xsYWJsZSkge1xuXG4gICAgICAgICAgICB2YXIgdG9wID0gZG9tLmdldE9mZnNldChyb290Ll9fdWwpLnRvcDtcbiAgICAgICAgICAgIHZhciBoID0gMDtcblxuICAgICAgICAgICAgY29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKCEgKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpXG4gICAgICAgICAgICAgICAgaCArPSBkb20uZ2V0SGVpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUIDwgaCkge1xuICAgICAgICAgICAgICBkb20uYWRkQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvb3QuX19yZXNpemVfaGFuZGxlKSB7XG4gICAgICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJvb3QuX19yZXNpemVfaGFuZGxlLnN0eWxlLmhlaWdodCA9IHJvb3QuX191bC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgb2JqZWN0cyBmb3Igc2F2aW5nLiBUaGUgb3JkZXIgb2YgdGhlc2Ugb2JqZWN0cyBjYW5ub3QgY2hhbmdlIGFzXG4gICAgICAgICAqIHRoZSBHVUkgZ3Jvd3MuIFdoZW4gcmVtZW1iZXJpbmcgbmV3IG9iamVjdHMsIGFwcGVuZCB0aGVtIHRvIHRoZSBlbmRcbiAgICAgICAgICogb2YgdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0Li4ufSBvYmplY3RzXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBub3QgY2FsbGVkIG9uIGEgdG9wIGxldmVsIEdVSS5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1lbWJlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKFNBVkVfRElBTE9HVUUpKSB7XG4gICAgICAgICAgICBTQVZFX0RJQUxPR1VFID0gbmV3IENlbnRlcmVkRGl2KCk7XG4gICAgICAgICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gc2F2ZURpYWxvZ3VlQ29udGVudHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21tb24uZWFjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PSAtMSkge1xuICAgICAgICAgICAgICBfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgICAgICAgLy8gU2V0IHNhdmUgcm93IHdpZHRoXG4gICAgICAgICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge2RhdC5ndWkuR1VJfSB0aGUgdG9wbW9zdCBwYXJlbnQgR1VJIG9mIGEgbmVzdGVkIEdVSS5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb290OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZ3VpID0gdGhpcztcbiAgICAgICAgICB3aGlsZSAoZ3VpLnBhcmVudCkge1xuICAgICAgICAgICAgZ3VpID0gZ3VpLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGd1aTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gYSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2ZcbiAgICAgICAgICogdGhpcyBHVUkgYXMgd2VsbCBhcyBpdHMgcmVtZW1iZXJlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuXG4gICAgICAgICAgdG9SZXR1cm4uY2xvc2VkID0gdGhpcy5jbG9zZWQ7XG5cbiAgICAgICAgICAvLyBBbSBJIHJlbWVtYmVyaW5nIGFueSB2YWx1ZXM/XG4gICAgICAgICAgaWYgKHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnByZXNldCA9IHRoaXMucHJlc2V0O1xuXG4gICAgICAgICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uKGVsZW1lbnQsIGtleSkge1xuICAgICAgICAgICAgdG9SZXR1cm4uZm9sZGVyc1trZXldID0gZWxlbWVudC5nZXRTYXZlT2JqZWN0KCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcywgZmFsc2UpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZUFzOiBmdW5jdGlvbihwcmVzZXROYW1lKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgICAgICAgIC8vIFJldGFpbiBkZWZhdWx0IHZhbHVlcyB1cG9uIGZpcnN0IHNhdmVcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzLCB0cnVlKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgICAgICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbihndWkpIHtcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgICAgICAgLy8gTWFrZSByZXZlcnQgd29yayBvbiBEZWZhdWx0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFJvb3QoKS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZShjb250cm9sbGVyLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSB8fCB0aGlzLmdldFJvb3QoKSwgY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24oZm9sZGVyKSB7XG4gICAgICAgICAgICBmb2xkZXIucmV2ZXJ0KGZvbGRlcik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWd1aSkge1xuICAgICAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMuZ2V0Um9vdCgpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW46IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblxuICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5fX2xpc3RlbmluZy5sZW5ndGggPT0gMDtcbiAgICAgICAgICB0aGlzLl9fbGlzdGVuaW5nLnB1c2goY29udHJvbGxlcik7XG4gICAgICAgICAgaWYgKGluaXQpIHVwZGF0ZURpc3BsYXlzKHRoaXMuX19saXN0ZW5pbmcpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gYWRkKGd1aSwgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICBpZiAob2JqZWN0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QgXCIgKyBvYmplY3QgKyBcIiBoYXMgbm8gcHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHkgKyBcIlxcXCJcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRyb2xsZXI7XG5cbiAgICBpZiAocGFyYW1zLmNvbG9yKSB7XG5cbiAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGZhY3RvcnlBcmdzID0gW29iamVjdCxwcm9wZXJ0eV0uY29uY2F0KHBhcmFtcy5mYWN0b3J5QXJncyk7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG5cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmJlZm9yZSBpbnN0YW5jZW9mIENvbnRyb2xsZXIpIHtcbiAgICAgIHBhcmFtcy5iZWZvcmUgPSBwYXJhbXMuYmVmb3JlLl9fbGk7XG4gICAgfVxuXG4gICAgcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpO1xuXG4gICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuZG9tRWxlbWVudCwgJ2MnKTtcblxuICAgIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGRvbS5hZGRDbGFzcyhuYW1lLCAncHJvcGVydHktbmFtZScpO1xuICAgIG5hbWUuaW5uZXJIVE1MID0gY29udHJvbGxlci5wcm9wZXJ0eTtcblxuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmFtZSk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG5cbiAgICB2YXIgbGkgPSBhZGRSb3coZ3VpLCBjb250YWluZXIsIHBhcmFtcy5iZWZvcmUpO1xuXG4gICAgZG9tLmFkZENsYXNzKGxpLCBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cpO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgdHlwZW9mIGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSk7XG5cbiAgICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcblxuICAgIGd1aS5fX2NvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG5cbiAgICByZXR1cm4gY29udHJvbGxlcjtcblxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHJvdyB0byB0aGUgZW5kIG9mIHRoZSBHVUkgb3IgYmVmb3JlIGFub3RoZXIgcm93LlxuICAgKlxuICAgKiBAcGFyYW0gZ3VpXG4gICAqIEBwYXJhbSBbZG9tXSBJZiBzcGVjaWZpZWQsIGluc2VydHMgdGhlIGRvbSBjb250ZW50IGluIHRoZSBuZXcgcm93XG4gICAqIEBwYXJhbSBbbGlCZWZvcmVdIElmIHNwZWNpZmllZCwgcGxhY2VzIHRoZSBuZXcgcm93IGJlZm9yZSBhbm90aGVyIHJvd1xuICAgKi9cbiAgZnVuY3Rpb24gYWRkUm93KGd1aSwgZG9tLCBsaUJlZm9yZSkge1xuICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgaWYgKGRvbSkgbGkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICBpZiAobGlCZWZvcmUpIHtcbiAgICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgcGFyYW1zLmJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGd1aS5fX3VsLmFwcGVuZENoaWxkKGxpKTtcbiAgICB9XG4gICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgcmV0dXJuIGxpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcikge1xuXG4gICAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gICAgY29udHJvbGxlci5fX2d1aSA9IGd1aTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29udHJvbGxlciwge1xuXG4gICAgICBvcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb21tb24udG9BcnJheShhcmd1bWVudHMpXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0FycmF5KG9wdGlvbnMpIHx8IGNvbW1vbi5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbb3B0aW9uc11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9LFxuXG4gICAgICBuYW1lOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPSB2O1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19ndWkubGlzdGVuKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19ndWkucmVtb3ZlKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gQWxsIHNsaWRlcnMgc2hvdWxkIGJlIGFjY29tcGFuaWVkIGJ5IGEgYm94LlxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlclNsaWRlcikge1xuXG4gICAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgeyBtaW46IGNvbnRyb2xsZXIuX19taW4sIG1heDogY29udHJvbGxlci5fX21heCwgc3RlcDogY29udHJvbGxlci5fX3N0ZXAgfSk7XG5cbiAgICAgIGNvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZSddLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgICB2YXIgcGIgPSBib3hbbWV0aG9kXTtcbiAgICAgICAgY29udHJvbGxlclttZXRob2RdID0gYm94W21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIHBiLmFwcGx5KGJveCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkb20uYWRkQ2xhc3MobGksICdoYXMtc2xpZGVyJyk7XG4gICAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG5cbiAgICAgIHZhciByID0gZnVuY3Rpb24ocmV0dXJuZWQpIHtcblxuICAgICAgICAvLyBIYXZlIHdlIGRlZmluZWQgYm90aCBib3VuZGFyaWVzP1xuICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIGNvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuXG4gICAgICAgICAgLy8gV2VsbCwgdGhlbiBsZXRzIGp1c3QgcmVwbGFjZSB0aGlzIHdpdGggYSBzbGlkZXIuXG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29udHJvbGxlci5fX21pbiwgY29udHJvbGxlci5fX21heCwgY29udHJvbGxlci5fX3N0ZXBdXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuZWQ7XG5cbiAgICAgIH07XG5cbiAgICAgIGNvbnRyb2xsZXIubWluID0gY29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5taW4pO1xuICAgICAgY29udHJvbGxlci5tYXggPSBjb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1heCk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEJvb2xlYW5Db250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50cyBkb3VibGUtdG9nZ2xlXG4gICAgICB9KVxuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChsaSwgJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmFkZENsYXNzKGxpLCAnY29sb3InKTtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSA9IGNvbW1vbi5jb21wb3NlKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSwgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KTtcblxuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB9XG5cbiAgICBjb250cm9sbGVyLnNldFZhbHVlID0gY29tbW9uLmNvbXBvc2UoZnVuY3Rpb24ocikge1xuICAgICAgaWYgKGd1aS5nZXRSb290KCkuX19wcmVzZXRfc2VsZWN0ICYmIGNvbnRyb2xsZXIuaXNNb2RpZmllZCgpKSB7XG4gICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIGNvbnRyb2xsZXIuc2V0VmFsdWUpO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuXG4gICAgLy8gRmluZCB0aGUgdG9wbW9zdCBHVUksIHRoYXQncyB3aGVyZSByZW1lbWJlcmVkIG9iamVjdHMgbGl2ZS5cbiAgICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG5cbiAgICAvLyBEb2VzIHRoZSBvYmplY3Qgd2UncmUgY29udHJvbGxpbmcgbWF0Y2ggYW55dGhpbmcgd2UndmUgYmVlbiB0b2xkIHRvXG4gICAgLy8gcmVtZW1iZXI/XG4gICAgdmFyIG1hdGNoZWRfaW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG5cbiAgICAvLyBXaHkgeWVzLCBpdCBkb2VzIVxuICAgIGlmIChtYXRjaGVkX2luZGV4ICE9IC0xKSB7XG5cbiAgICAgIC8vIExldCBtZSBmZXRjaCBhIG1hcCBvZiBjb250cm9sbGVycyBmb3IgdGhjb21tb24uaXNPYmplY3QuXG4gICAgICB2YXIgY29udHJvbGxlcl9tYXAgPVxuICAgICAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZF9pbmRleF07XG5cbiAgICAgIC8vIE9ocCwgSSBiZWxpZXZlIHRoaXMgaXMgdGhlIGZpcnN0IGNvbnRyb2xsZXIgd2UndmUgY3JlYXRlZCBmb3IgdGhpc1xuICAgICAgLy8gb2JqZWN0LiBMZXRzIG1ha2UgdGhlIG1hcCBmcmVzaC5cbiAgICAgIGlmIChjb250cm9sbGVyX21hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRyb2xsZXJfbWFwID0ge307XG4gICAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZF9pbmRleF0gPVxuICAgICAgICAgICAgY29udHJvbGxlcl9tYXA7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBjb250cm9sbGVyXG4gICAgICBjb250cm9sbGVyX21hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG5cbiAgICAgIC8vIE9rYXksIG5vdyBoYXZlIHdlIHNhdmVkIGFueSB2YWx1ZXMgZm9yIHRoaXMgY29udHJvbGxlcj9cbiAgICAgIGlmIChyb290LmxvYWQgJiYgcm9vdC5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgICB2YXIgcHJlc2V0X21hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuXG4gICAgICAgIC8vIFdoaWNoIHByZXNldCBhcmUgd2UgdHJ5aW5nIHRvIGxvYWQ/XG4gICAgICAgIHZhciBwcmVzZXQ7XG5cbiAgICAgICAgaWYgKHByZXNldF9tYXBbZ3VpLnByZXNldF0pIHtcblxuICAgICAgICAgIHByZXNldCA9IHByZXNldF9tYXBbZ3VpLnByZXNldF07XG5cbiAgICAgICAgfSBlbHNlIGlmIChwcmVzZXRfbWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0pIHtcblxuICAgICAgICAgIC8vIFVoaCwgeW91IGNhbiBoYXZlIHRoZSBkZWZhdWx0IGluc3RlYWQ/XG4gICAgICAgICAgcHJlc2V0ID0gcHJlc2V0X21hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBOYWRhLlxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIERpZCB0aGUgbG9hZGVkIG9iamVjdCByZW1lbWJlciB0aGNvbW1vbi5pc09iamVjdD9cbiAgICAgICAgaWYgKHByZXNldFttYXRjaGVkX2luZGV4XSAmJlxuXG4gICAgICAgICAgLy8gRGlkIHdlIHJlbWVtYmVyIHRoaXMgcGFydGljdWxhciBwcm9wZXJ0eT9cbiAgICAgICAgICAgIHByZXNldFttYXRjaGVkX2luZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAvLyBXZSBkaWQgcmVtZW1iZXIgc29tZXRoaW5nIGZvciB0aGlzIGd1eSAuLi5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwcmVzZXRbbWF0Y2hlZF9pbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV07XG5cbiAgICAgICAgICAvLyBBbmQgdGhhdCdzIHdoYXQgaXQgaXMuXG4gICAgICAgICAgY29udHJvbGxlci5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksIGtleSkge1xuICAgIC8vIFRPRE8gaG93IGRvZXMgdGhpcyBkZWFsIHdpdGggbXVsdGlwbGUgR1VJJ3M/XG4gICAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgKyAnLicgKyBrZXk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNhdmVNZW51KGd1aSkge1xuXG4gICAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgIGRvbS5hZGRDbGFzcyhndWkuZG9tRWxlbWVudCwgJ2hhcy1zYXZlJyk7XG5cbiAgICBndWkuX191bC5pbnNlcnRCZWZvcmUoZGl2LCBndWkuX191bC5maXJzdENoaWxkKTtcblxuICAgIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuXG4gICAgdmFyIGdlYXJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgIGRvbS5hZGRDbGFzcyhnZWFycywgJ2J1dHRvbiBnZWFycycpO1xuXG4gICAgLy8gVE9ETyByZXBsYWNlIHdpdGggRnVuY3Rpb25Db250cm9sbGVyXG4gICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24uaW5uZXJIVE1MID0gJ1NhdmUnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24sICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuXG4gICAgdmFyIGJ1dHRvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnc2F2ZS1hcycpO1xuXG4gICAgdmFyIGJ1dHRvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uMy5pbm5lckhUTUwgPSAnUmV2ZXJ0JztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24zLCAncmV2ZXJ0Jyk7XG5cbiAgICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuXG4gICAgaWYgKGd1aS5sb2FkICYmIGd1aS5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgY29tbW9uLmVhY2goZ3VpLmxvYWQucmVtZW1iZXJlZCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PSBndWkucHJlc2V0KTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFByZXNldE9wdGlvbihndWksIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGRvbS5iaW5kKHNlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuXG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS5pbm5lckhUTUwgPSBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgZ3VpLnByZXNldCA9IHRoaXMudmFsdWU7XG5cbiAgICB9KTtcblxuICAgIGRpdi5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcblxuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG5cbiAgICAgIHZhciBzYXZlTG9jYWxseSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1zYXZlLWxvY2FsbHknKTtcbiAgICAgIHZhciBleHBsYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLWV4cGxhaW4nKTtcblxuICAgICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgIHZhciBsb2NhbFN0b3JhZ2VDaGVja0JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1zdG9yYWdlJyk7XG5cbiAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG93SGlkZUV4cGxhaW4oKSB7XG4gICAgICAgIGV4cGxhaW4uc3R5bGUuZGlzcGxheSA9IGd1aS51c2VMb2NhbFN0b3JhZ2UgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICBzaG93SGlkZUV4cGxhaW4oKTtcblxuICAgICAgLy8gVE9ETzogVXNlIGEgYm9vbGVhbiBjb250cm9sbGVyLCBmb29sIVxuICAgICAgZG9tLmJpbmQobG9jYWxTdG9yYWdlQ2hlY2tCb3gsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpLnVzZUxvY2FsU3RvcmFnZSA9ICFndWkudXNlTG9jYWxTdG9yYWdlO1xuICAgICAgICBzaG93SGlkZUV4cGxhaW4oKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgdmFyIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbmV3LWNvbnN0cnVjdG9yJyk7XG5cbiAgICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLm1ldGFLZXkgJiYgKGUud2hpY2ggPT09IDY3IHx8IGUua2V5Q29kZSA9PSA2NykpIHtcbiAgICAgICAgU0FWRV9ESUFMT0dVRS5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChnZWFycywgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGd1aS5nZXRTYXZlT2JqZWN0KCksIHVuZGVmaW5lZCwgMik7XG4gICAgICBTQVZFX0RJQUxPR1VFLnNob3coKTtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuc2VsZWN0KCk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24sICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZ3VpLnNhdmUoKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByZXNldE5hbWUgPSBwcm9tcHQoJ0VudGVyIGEgbmV3IHByZXNldCBuYW1lLicpO1xuICAgICAgaWYgKHByZXNldE5hbWUpIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24zLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIGd1aS5yZXZlcnQoKTtcbiAgICB9KTtcblxuLy8gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG5cbiAgICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUsIHtcblxuICAgICAgd2lkdGg6ICc2cHgnLFxuICAgICAgbWFyZ2luTGVmdDogJy0zcHgnLFxuICAgICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgICAgY3Vyc29yOiAnZXctcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4vLyAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBibHVlJ1xuXG4gICAgfSk7XG5cbiAgICB2YXIgcG1vdXNlWDtcblxuICAgIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICAgIGRvbS5iaW5kKGd1aS5fX2Nsb3NlQnV0dG9uLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcblxuICAgIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmFnKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhZ1N0b3AoKSB7XG5cbiAgICAgIGRvbS5yZW1vdmVDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0V2lkdGgoZ3VpLCB3KSB7XG4gICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAvLyBBdXRvIHBsYWNlZCBzYXZlLXJvd3MgYXJlIHBvc2l0aW9uIGZpeGVkLCBzbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2V0IHRoZSB3aWR0aCBtYW51YWxseSBpZiB3ZSB3YW50IGl0IHRvIGJsZWVkIHRvIHRoZSBlZGdlXG4gICAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICAgIGd1aS5fX3NhdmVfcm93LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgfWlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgICAgZ3VpLl9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50UHJlc2V0KGd1aSwgdXNlSW5pdGlhbFZhbHVlcykge1xuXG4gICAgdmFyIHRvUmV0dXJuID0ge307XG5cbiAgICAvLyBGb3IgZWFjaCBvYmplY3QgSSdtIHJlbWVtYmVyaW5nXG4gICAgY29tbW9uLmVhY2goZ3VpLl9fcmVtZW1iZXJlZE9iamVjdHMsIGZ1bmN0aW9uKHZhbCwgaW5kZXgpIHtcblxuICAgICAgdmFyIHNhdmVkX3ZhbHVlcyA9IHt9O1xuXG4gICAgICAvLyBUaGUgY29udHJvbGxlcnMgSSd2ZSBtYWRlIGZvciB0aGNvbW1vbi5pc09iamVjdCBieSBwcm9wZXJ0eVxuICAgICAgdmFyIGNvbnRyb2xsZXJfbWFwID1cbiAgICAgICAgICBndWkuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbaW5kZXhdO1xuXG4gICAgICAvLyBSZW1lbWJlciBlYWNoIHZhbHVlIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICBjb21tb24uZWFjaChjb250cm9sbGVyX21hcCwgZnVuY3Rpb24oY29udHJvbGxlciwgcHJvcGVydHkpIHtcbiAgICAgICAgc2F2ZWRfdmFsdWVzW3Byb3BlcnR5XSA9IHVzZUluaXRpYWxWYWx1ZXMgPyBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA6IGNvbnRyb2xsZXIuZ2V0VmFsdWUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTYXZlIHRoZSB2YWx1ZXMgZm9yIHRoY29tbW9uLmlzT2JqZWN0XG4gICAgICB0b1JldHVybltpbmRleF0gPSBzYXZlZF92YWx1ZXM7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0LmlubmVySFRNTCA9IG5hbWU7XG4gICAgb3B0LnZhbHVlID0gbmFtZTtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gICAgaWYgKHNldFNlbGVjdGVkKSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJlc2V0U2VsZWN0SW5kZXgoZ3VpKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWUgPT0gZ3VpLnByZXNldCkge1xuICAgICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICAgIHZhciBvcHQgPSBndWkuX19wcmVzZXRfc2VsZWN0W2d1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleF07XG4vLyAgICBjb25zb2xlLmxvZygnbWFyaycsIG1vZGlmaWVkLCBvcHQpO1xuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZSArIFwiKlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuXG5cbiAgICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPSAwKSB7XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgY29tbW9uLmVhY2goY29udHJvbGxlckFycmF5LCBmdW5jdGlvbihjKSB7XG4gICAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcblxuICB9XG5cbiAgcmV0dXJuIEdVSTtcblxufSkoZGF0LnV0aWxzLmNzcyxcblwiPGRpdiBpZD1cXFwiZGctc2F2ZVxcXCIgY2xhc3M9XFxcImRnIGRpYWxvZ3VlXFxcIj5cXG5cXG4gIEhlcmUncyB0aGUgbmV3IGxvYWQgcGFyYW1ldGVyIGZvciB5b3VyIDxjb2RlPkdVSTwvY29kZT4ncyBjb25zdHJ1Y3RvcjpcXG5cXG4gIDx0ZXh0YXJlYSBpZD1cXFwiZGctbmV3LWNvbnN0cnVjdG9yXFxcIj48L3RleHRhcmVhPlxcblxcbiAgPGRpdiBpZD1cXFwiZGctc2F2ZS1sb2NhbGx5XFxcIj5cXG5cXG4gICAgPGlucHV0IGlkPVxcXCJkZy1sb2NhbC1zdG9yYWdlXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIvPiBBdXRvbWF0aWNhbGx5IHNhdmVcXG4gICAgdmFsdWVzIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gb24gZXhpdC5cXG5cXG4gICAgPGRpdiBpZD1cXFwiZGctbG9jYWwtZXhwbGFpblxcXCI+VGhlIHZhbHVlcyBzYXZlZCB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IHdpbGxcXG4gICAgICBvdmVycmlkZSB0aG9zZSBwYXNzZWQgdG8gPGNvZGU+ZGF0LkdVSTwvY29kZT4ncyBjb25zdHJ1Y3Rvci4gVGhpcyBtYWtlcyBpdFxcbiAgICAgIGVhc2llciB0byB3b3JrIGluY3JlbWVudGFsbHksIGJ1dCA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlzIGZyYWdpbGUsXFxuICAgICAgYW5kIHlvdXIgZnJpZW5kcyBtYXkgbm90IHNlZSB0aGUgc2FtZSB2YWx1ZXMgeW91IGRvLlxcbiAgICAgIFxcbiAgICA8L2Rpdj5cXG4gICAgXFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cIixcblwiLmRnIHVse2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7d2lkdGg6MTAwJTtjbGVhcjpib3RofS5kZy5hY3twb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtoZWlnaHQ6MDt6LWluZGV4OjB9LmRnOm5vdCguYWMpIC5tYWlue292ZXJmbG93OmhpZGRlbn0uZGcubWFpbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvd3tvdmVyZmxvdy15OmF1dG99LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93IC5jbG9zZS1idXR0b257b3BhY2l0eToxO21hcmdpbi10b3A6LTFweDtib3JkZXItdG9wOjFweCBzb2xpZCAjMmMyYzJjfS5kZy5tYWluIHVsLmNsb3NlZCAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MSAhaW1wb3J0YW50fS5kZy5tYWluOmhvdmVyIC5jbG9zZS1idXR0b24sLmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5kcmFne29wYWNpdHk6MX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7Ym9yZGVyOjA7cG9zaXRpb246YWJzb2x1dGU7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteDpoaWRkZW59LmRnLmEuaGFzLXNhdmUgdWx7bWFyZ2luLXRvcDoyN3B4fS5kZy5hLmhhcy1zYXZlIHVsLmNsb3NlZHttYXJnaW4tdG9wOjB9LmRnLmEgLnNhdmUtcm93e3Bvc2l0aW9uOmZpeGVkO3RvcDowO3otaW5kZXg6MTAwMn0uZGcgbGl7LXdlYmtpdC10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0Oy1vLXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0O3RyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXR9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgNHB4IDAgNXB4fS5kZyBsaS5mb2xkZXJ7cGFkZGluZzowO2JvcmRlci1sZWZ0OjRweCBzb2xpZCByZ2JhKDAsMCwwLDApfS5kZyBsaS50aXRsZXtjdXJzb3I6cG9pbnRlcjttYXJnaW4tbGVmdDotNHB4fS5kZyAuY2xvc2VkIGxpOm5vdCgudGl0bGUpLC5kZyAuY2xvc2VkIHVsIGxpLC5kZyAuY2xvc2VkIHVsIGxpID4gKntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHh9LmRnIC5wcm9wZXJ0eS1uYW1le2N1cnNvcjpkZWZhdWx0O2Zsb2F0OmxlZnQ7Y2xlYXI6bGVmdDt3aWR0aDo0MCU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmRnIC5je2Zsb2F0OmxlZnQ7d2lkdGg6NjAlfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JvcmRlcjowO21hcmdpbi10b3A6NHB4O3BhZGRpbmc6M3B4O3dpZHRoOjEwMCU7ZmxvYXQ6cmlnaHR9LmRnIC5oYXMtc2xpZGVyIGlucHV0W3R5cGU9dGV4dF17d2lkdGg6MzAlO21hcmdpbi1sZWZ0OjB9LmRnIC5zbGlkZXJ7ZmxvYXQ6bGVmdDt3aWR0aDo2NiU7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tcmlnaHQ6MDtoZWlnaHQ6MTlweDttYXJnaW4tdG9wOjRweH0uZGcgLnNsaWRlci1mZ3toZWlnaHQ6MTAwJX0uZGcgLmMgaW5wdXRbdHlwZT1jaGVja2JveF17bWFyZ2luLXRvcDo5cHh9LmRnIC5jIHNlbGVjdHttYXJnaW4tdG9wOjVweH0uZGcgLmNyLmZ1bmN0aW9uLC5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWUsLmRnIC5jci5mdW5jdGlvbiAqLC5kZyAuY3IuYm9vbGVhbiwuZGcgLmNyLmJvb2xlYW4gKntjdXJzb3I6cG9pbnRlcn0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMmZhMWQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJmYTFkNn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJmYTFkNn0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIsXG5kYXQuY29udHJvbGxlcnMuZmFjdG9yeSA9IChmdW5jdGlvbiAoT3B0aW9uQ29udHJvbGxlciwgTnVtYmVyQ29udHJvbGxlckJveCwgTnVtYmVyQ29udHJvbGxlclNsaWRlciwgU3RyaW5nQ29udHJvbGxlciwgRnVuY3Rpb25Db250cm9sbGVyLCBCb29sZWFuQ29udHJvbGxlciwgY29tbW9uKSB7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gUHJvdmlkaW5nIG9wdGlvbnM/XG4gICAgICAgIGlmIChjb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IGNvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm92aWRpbmcgYSBtYXA/XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG5cbiAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1syXSkgJiYgY29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1szXSkpIHtcblxuICAgICAgICAgICAgLy8gSGFzIG1pbiBhbmQgbWF4LlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSB9KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc1N0cmluZyhpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0Z1bmN0aW9uKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9KShkYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94LFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG5kYXQuY29udHJvbGxlcnMuU3RyaW5nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgdGV4dCBpbnB1dCB0byBhbHRlciB0aGUgc3RyaW5nIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBTdHJpbmdDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleXVwJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcblxuICB9O1xuXG4gIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFN0b3BzIHRoZSBjYXJldCBmcm9tIG1vdmluZyBvbiBhY2NvdW50IG9mOlxuICAgICAgICAgIC8vIGtleXVwIC0+IHNldFZhbHVlIC0+IHVwZGF0ZURpc3BsYXlcbiAgICAgICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gU3RyaW5nQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlcixcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3gsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbmRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkNvbG9yQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBDb2xvciwgaW50ZXJwcmV0LCBjb21tb24pIHtcblxuICB2YXIgQ29sb3JDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgQ29sb3JDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHRoaXMuX19jb2xvciA9IG5ldyBDb2xvcih0aGlzLmdldFZhbHVlKCkpO1xuICAgIHRoaXMuX190ZW1wID0gbmV3IENvbG9yKDApO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuXG4gICAgdGhpcy5fX3NlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG5cbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmNsYXNzTmFtZSA9ICdzYXR1cmF0aW9uLWZpZWxkJztcblxuICAgIHRoaXMuX19maWVsZF9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2ZpZWxkX2tub2IuY2xhc3NOYW1lID0gJ2ZpZWxkLWtub2InO1xuICAgIHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcblxuICAgIHRoaXMuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xuXG4gICAgdGhpcy5fX2h1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19odWVfZmllbGQuY2xhc3NOYW1lID0gJ2h1ZS1maWVsZCc7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ID0gJzAgMXB4IDFweCAnO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7IC8vIG9uIGVudGVyXG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIGRvbVxuICAgICAgICAuYWRkQ2xhc3ModGhpcywgJ2RyYWcnKVxuICAgICAgICAuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgdmFyIHZhbHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19zZWxlY3Rvci5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMjJweCcsXG4gICAgICBoZWlnaHQ6ICcxMDJweCcsXG4gICAgICBwYWRkaW5nOiAnM3B4JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMyMjInLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjMpJ1xuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzEycHgnLFxuICAgICAgaGVpZ2h0OiAnMTJweCcsXG4gICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICh0aGlzLl9fY29sb3IudiA8IC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIFxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2h1ZV9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgI2ZmZicsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwcHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh2YWx1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgYmFja2dyb3VuZDogJ25vbmUnXG4gICAgfSk7XG4gICAgXG4gICAgbGluZWFyR3JhZGllbnQodmFsdWVfZmllbGQsICd0b3AnLCAncmdiYSgwLDAsMCwwKScsICcjMDAwJyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19odWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIGN1cnNvcjogJ25zLXJlc2l6ZSdcbiAgICB9KTtcblxuICAgIGh1ZUdyYWRpZW50KHRoaXMuX19odWVfZmllbGQpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbi8vICAgICAgd2lkdGg6ICcxMjBweCcsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuLy8gICAgICBwYWRkaW5nOiAnNHB4Jyxcbi8vICAgICAgbWFyZ2luQm90dG9tOiAnNnB4JyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKDAsMCwwLDAuNyknXG4gICAgfSk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2ZpZWxkX2tub2IsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNldEgoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRIKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpZWxkRG93bihlKSB7XG4gICAgICBzZXRTVihlKTtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ25vbmUnO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZFNWKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmJpbmRTVigpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kU1YpO1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmJpbmRIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZEgpO1xuICAgIH1cblxuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmFwcGVuZENoaWxkKHZhbHVlX2ZpZWxkKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX2ZpZWxkX2tub2IpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19odWVfZmllbGQpO1xuICAgIHRoaXMuX19odWVfZmllbGQuYXBwZW5kQ2hpbGQodGhpcy5fX2h1ZV9rbm9iKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fc2VsZWN0b3IpO1xuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBmdW5jdGlvbiBzZXRTVihlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIHcgPSBkb20uZ2V0V2lkdGgoX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICAgIHZhciBvID0gZG9tLmdldE9mZnNldChfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgICAgdmFyIHMgPSAoZS5jbGllbnRYIC0gby5sZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSAvIHc7XG4gICAgICB2YXIgdiA9IDEgLSAoZS5jbGllbnRZIC0gby50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgLyB3O1xuXG4gICAgICBpZiAodiA+IDEpIHYgPSAxO1xuICAgICAgZWxzZSBpZiAodiA8IDApIHYgPSAwO1xuXG4gICAgICBpZiAocyA+IDEpIHMgPSAxO1xuICAgICAgZWxzZSBpZiAocyA8IDApIHMgPSAwO1xuXG4gICAgICBfdGhpcy5fX2NvbG9yLnYgPSB2O1xuICAgICAgX3RoaXMuX19jb2xvci5zID0gcztcblxuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEgoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBzID0gZG9tLmdldEhlaWdodChfdGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgICB2YXIgbyA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19odWVfZmllbGQpO1xuICAgICAgdmFyIGggPSAxIC0gKGUuY2xpZW50WSAtIG8udG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC8gcztcblxuICAgICAgaWYgKGggPiAxKSBoID0gMTtcbiAgICAgIGVsc2UgaWYgKGggPCAwKSBoID0gMDtcblxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcblxuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgfTtcblxuICBDb2xvckNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQ29sb3JDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuXG4gICAgICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbWlzbWF0Y2ggb24gdGhlIGludGVycHJldGVkIHZhbHVlLlxuXG4gICAgICAgICAgICBjb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJlxuICAgICAgICAgICAgICAgICAgIWNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSAmJlxuICAgICAgICAgICAgICAgICAgaVtjb21wb25lbnRdICE9PSB0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSB7XG4gICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTsgLy8gYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgZGl2ZXJnZXMsIHdlIGtlZXAgb3VyIHByZXZpb3VzIHZhbHVlc1xuICAgICAgICAgICAgLy8gZm9yIHN0YXRlZnVsbmVzcywgb3RoZXJ3aXNlIHdlIHJlY2FsY3VsYXRlIGZyZXNoXG4gICAgICAgICAgICBpZiAobWlzbWF0Y2gpIHtcbiAgICAgICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fY29sb3IuX19zdGF0ZSwgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcblxuICAgICAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuXG4gICAgICAgICAgdmFyIGZsaXAgPSAodGhpcy5fX2NvbG9yLnYgPCAuNSB8fCB0aGlzLl9fY29sb3IucyA+IC41KSA/IDI1NSA6IDA7XG4gICAgICAgICAgdmFyIF9mbGlwID0gMjU1IC0gZmxpcDtcblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDEwMCAqIHRoaXMuX19jb2xvci5zIC0gNyArICdweCcsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX190ZW1wLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArJyknXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLl9faHVlX2tub2Iuc3R5bGUubWFyZ2luVG9wID0gKDEgLSB0aGlzLl9fY29sb3IuaCAvIDM2MCkgKiAxMDAgKyAncHgnXG5cbiAgICAgICAgICB0aGlzLl9fdGVtcC5zID0gMTtcbiAgICAgICAgICB0aGlzLl9fdGVtcC52ID0gMTtcblxuICAgICAgICAgIGxpbmVhckdyYWRpZW50KHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbGVmdCcsICcjZmZmJywgdGhpcy5fX3RlbXAudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fY29sb3IudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGNvbG9yOiAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKycpJyxcbiAgICAgICAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArJywuNyknXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcbiAgXG4gIHZhciB2ZW5kb3JzID0gWyctbW96LScsJy1vLScsJy13ZWJraXQtJywnLW1zLScsJyddO1xuICBcbiAgZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoZWxlbSwgeCwgYSwgYikge1xuICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICAgIGNvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uKHZlbmRvcikge1xuICAgICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAnICsgdmVuZG9yICsgJ2xpbmVhci1ncmFkaWVudCgnK3grJywgJythKycgMCUsICcgKyBiICsgJyAxMDAlKTsgJztcbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwgI2ZmMDBmZiAxNyUsICMwMDAwZmYgMzQlLCAjMDBmZmZmIDUwJSwgIzAwZmYwMCA2NyUsICNmZmZmMDAgODQlLCAjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICB9XG5cblxuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LmNvbG9yLkNvbG9yID0gKGZ1bmN0aW9uIChpbnRlcnByZXQsIG1hdGgsIHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93ICdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuXG5cbiAgfTtcblxuICBDb2xvci5DT01QT05FTlRTID0gWydyJywnZycsJ2InLCdoJywncycsJ3YnLCdoZXgnLCdhJ107XG5cbiAgY29tbW9uLmV4dGVuZChDb2xvci5wcm90b3R5cGUsIHtcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9PcmlnaW5hbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5cbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICAgIH1cblxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBtYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJylcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVSR0IoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuXG4gICAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBtYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuXG4gICAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIG1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aHJvdyAnQ29ycnVwdGVkIGNvbG9yIHN0YXRlJztcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVIU1YoY29sb3IpIHtcblxuICAgIHZhciByZXN1bHQgPSBtYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICBzOiByZXN1bHQucyxcbiAgICAgICAgICB2OiByZXN1bHQudlxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGlmICghY29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gICAgfSBlbHNlIGlmIChjb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBDb2xvcjtcblxufSkoZGF0LmNvbG9yLmludGVycHJldCxcbmRhdC5jb2xvci5tYXRoID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdG1wQ29tcG9uZW50O1xuXG4gIHJldHVybiB7XG5cbiAgICBoc3ZfdG9fcmdiOiBmdW5jdGlvbihoLCBzLCB2KSB7XG5cbiAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG5cbiAgICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgICAgdmFyIHEgPSB2ICogKDEuMCAtIChmICogcykpO1xuICAgICAgdmFyIHQgPSB2ICogKDEuMCAtICgoMS4wIC0gZikgKiBzKSk7XG4gICAgICB2YXIgYyA9IFtcbiAgICAgICAgW3YsIHQsIHBdLFxuICAgICAgICBbcSwgdiwgcF0sXG4gICAgICAgIFtwLCB2LCB0XSxcbiAgICAgICAgW3AsIHEsIHZdLFxuICAgICAgICBbdCwgcCwgdl0sXG4gICAgICAgIFt2LCBwLCBxXVxuICAgICAgXVtoaV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICAgIGI6IGNbMl0gKiAyNTVcbiAgICAgIH07XG5cbiAgICB9LFxuXG4gICAgcmdiX3RvX2hzdjogZnVuY3Rpb24ociwgZywgYikge1xuXG4gICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgaCwgcztcblxuICAgICAgaWYgKG1heCAhPSAwKSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogTmFOLFxuICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgdjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoZyA9PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cbiAgICAgIGggLz0gNjtcbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGg6IGggKiAzNjAsXG4gICAgICAgIHM6IHMsXG4gICAgICAgIHY6IG1heCAvIDI1NVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmdiX3RvX2hleDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMCwgYik7XG4gICAgICByZXR1cm4gaGV4O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICAgIHJldHVybiAoaGV4ID4+IChjb21wb25lbnRJbmRleCAqIDgpKSAmIDB4RkY7XG4gICAgfSxcblxuICAgIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IChoZXggJiB+ICgweEZGIDw8IHRtcENvbXBvbmVudCkpO1xuICAgIH1cblxuICB9XG5cbn0pKCksXG5kYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb2xvci5pbnRlcnByZXQsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiByZXF1aXJlanMgdmVyc2lvbiBvZiBQYXVsIElyaXNoJ3MgUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqL1xuXG4gIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXG4gICAgICB9O1xufSkoKSxcbmRhdC5kb20uQ2VudGVyZWREaXYgPSAoZnVuY3Rpb24gKGRvbSwgY29tbW9uKSB7XG5cblxuICB2YXIgQ2VudGVyZWREaXYgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG5cbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAxJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnLXdlYmtpdC10cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcblxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGRvbS5iaW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuXG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBcblxuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4vLyAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzUyJSc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblxuICAgIHRoaXMubGF5b3V0KCk7XG5cbiAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgfSk7XG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBoaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG5cbiAgICB9O1xuXG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbi8vICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSAnNDglJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUubGVmdCA9IHdpbmRvdy5pbm5lcldpZHRoLzIgLSBkb20uZ2V0V2lkdGgodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQvMiAtIGRvbS5nZXRIZWlnaHQodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICB9O1xuICBcbiAgZnVuY3Rpb24gbG9ja1Njcm9sbChlKSB7XG4gICAgY29uc29sZS5sb2coZSk7XG4gIH1cblxuICByZXR1cm4gQ2VudGVyZWREaXY7XG5cbn0pKGRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pOyIsIi8qISBAbGljZW5zZSBGaXJlYmFzZSB2Mi4yLjAgLSBMaWNlbnNlOiBodHRwczovL3d3dy5maXJlYmFzZS5jb20vdGVybXMvdGVybXMtb2Ytc2VydmljZS5odG1sICovIChmdW5jdGlvbigpIHt2YXIgaCxhYT10aGlzO2Z1bmN0aW9uIG0oYSl7cmV0dXJuIHZvaWQgMCE9PWF9ZnVuY3Rpb24gYmEoKXt9ZnVuY3Rpb24gY2EoYSl7YS5PYj1mdW5jdGlvbigpe3JldHVybiBhLmtmP2Eua2Y6YS5rZj1uZXcgYX19XG5mdW5jdGlvbiBkYShhKXt2YXIgYj10eXBlb2YgYTtpZihcIm9iamVjdFwiPT1iKWlmKGEpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm5cImFycmF5XCI7aWYoYSBpbnN0YW5jZW9mIE9iamVjdClyZXR1cm4gYjt2YXIgYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7aWYoXCJbb2JqZWN0IFdpbmRvd11cIj09YylyZXR1cm5cIm9iamVjdFwiO2lmKFwiW29iamVjdCBBcnJheV1cIj09Y3x8XCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5zcGxpY2UmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSlyZXR1cm5cImFycmF5XCI7aWYoXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT1jfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5jYWxsJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJjYWxsXCIpKXJldHVyblwiZnVuY3Rpb25cIn1lbHNlIHJldHVyblwibnVsbFwiO1xuZWxzZSBpZihcImZ1bmN0aW9uXCI9PWImJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmNhbGwpcmV0dXJuXCJvYmplY3RcIjtyZXR1cm4gYn1mdW5jdGlvbiBlYShhKXtyZXR1cm5cImFycmF5XCI9PWRhKGEpfWZ1bmN0aW9uIGZhKGEpe3ZhciBiPWRhKGEpO3JldHVyblwiYXJyYXlcIj09Ynx8XCJvYmplY3RcIj09YiYmXCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RofWZ1bmN0aW9uIHAoYSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGF9ZnVuY3Rpb24gZ2EoYSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGF9ZnVuY3Rpb24gaGEoYSl7cmV0dXJuXCJmdW5jdGlvblwiPT1kYShhKX1mdW5jdGlvbiBpYShhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm5cIm9iamVjdFwiPT1iJiZudWxsIT1hfHxcImZ1bmN0aW9uXCI9PWJ9ZnVuY3Rpb24gamEoYSxiLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9XG5mdW5jdGlvbiBrYShhLGIsYyl7aWYoIWEpdGhyb3cgRXJyb3IoKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0FycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsZCk7cmV0dXJuIGEuYXBwbHkoYixjKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBxKGEsYixjKXtxPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/amE6a2E7cmV0dXJuIHEuYXBwbHkobnVsbCxhcmd1bWVudHMpfXZhciBsYT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9O1xuZnVuY3Rpb24gbWEoYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EuS2c9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5HZz1mdW5jdGlvbihhLGMsZil7cmV0dXJuIGIucHJvdG90eXBlW2NdLmFwcGx5KGEsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpKX19O2Z1bmN0aW9uIG5hKGEpe2E9U3RyaW5nKGEpO2lmKC9eXFxzKiQvLnRlc3QoYSk/MDovXltcXF0sOnt9XFxzXFx1MjAyOFxcdTIwMjldKiQvLnRlc3QoYS5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZyxcIkBcIikucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XFx4MDAtXFx4MDhcXHgwYS1cXHgxZl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OltcXHNcXHUyMDI4XFx1MjAyOV0qXFxbKSsvZyxcIlwiKSkpdHJ5e3JldHVybiBldmFsKFwiKFwiK2ErXCIpXCIpfWNhdGNoKGIpe310aHJvdyBFcnJvcihcIkludmFsaWQgSlNPTiBzdHJpbmc6IFwiK2EpO31mdW5jdGlvbiBvYSgpe3RoaXMuTWQ9dm9pZCAwfVxuZnVuY3Rpb24gcGEoYSxiLGMpe3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcInN0cmluZ1wiOnFhKGIsYyk7YnJlYWs7Y2FzZSBcIm51bWJlclwiOmMucHVzaChpc0Zpbml0ZShiKSYmIWlzTmFOKGIpP2I6XCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJib29sZWFuXCI6Yy5wdXNoKGIpO2JyZWFrO2Nhc2UgXCJ1bmRlZmluZWRcIjpjLnB1c2goXCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjppZihudWxsPT1iKXtjLnB1c2goXCJudWxsXCIpO2JyZWFrfWlmKGVhKGIpKXt2YXIgZD1iLmxlbmd0aDtjLnB1c2goXCJbXCIpO2Zvcih2YXIgZT1cIlwiLGY9MDtmPGQ7ZisrKWMucHVzaChlKSxlPWJbZl0scGEoYSxhLk1kP2EuTWQuY2FsbChiLFN0cmluZyhmKSxlKTplLGMpLGU9XCIsXCI7Yy5wdXNoKFwiXVwiKTticmVha31jLnB1c2goXCJ7XCIpO2Q9XCJcIjtmb3IoZiBpbiBiKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLGYpJiYoZT1iW2ZdLFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJihjLnB1c2goZCkscWEoZixjKSxcbmMucHVzaChcIjpcIikscGEoYSxhLk1kP2EuTWQuY2FsbChiLGYsZSk6ZSxjKSxkPVwiLFwiKSk7Yy5wdXNoKFwifVwiKTticmVhaztjYXNlIFwiZnVuY3Rpb25cIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0eXBlb2YgYik7fX12YXIgcmE9eydcIic6J1xcXFxcIicsXCJcXFxcXCI6XCJcXFxcXFxcXFwiLFwiL1wiOlwiXFxcXC9cIixcIlxcYlwiOlwiXFxcXGJcIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcclwiOlwiXFxcXHJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxceDBCXCI6XCJcXFxcdTAwMGJcIn0sc2E9L1xcdWZmZmYvLnRlc3QoXCJcXHVmZmZmXCIpPy9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2c6L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4ZmZdL2c7XG5mdW5jdGlvbiBxYShhLGIpe2IucHVzaCgnXCInLGEucmVwbGFjZShzYSxmdW5jdGlvbihhKXtpZihhIGluIHJhKXJldHVybiByYVthXTt2YXIgYj1hLmNoYXJDb2RlQXQoMCksZT1cIlxcXFx1XCI7MTY+Yj9lKz1cIjAwMFwiOjI1Nj5iP2UrPVwiMDBcIjo0MDk2PmImJihlKz1cIjBcIik7cmV0dXJuIHJhW2FdPWUrYi50b1N0cmluZygxNil9KSwnXCInKX07ZnVuY3Rpb24gdGEoYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBKU09OJiZtKEpTT04ucGFyc2UpP0pTT04ucGFyc2UoYSk6bmEoYSl9ZnVuY3Rpb24gcihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIEpTT04mJm0oSlNPTi5zdHJpbmdpZnkpKWE9SlNPTi5zdHJpbmdpZnkoYSk7ZWxzZXt2YXIgYj1bXTtwYShuZXcgb2EsYSxiKTthPWIuam9pbihcIlwiKX1yZXR1cm4gYX07ZnVuY3Rpb24gcyhhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxiKX1mdW5jdGlvbiB0KGEsYil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYikpcmV0dXJuIGFbYl19ZnVuY3Rpb24gdWEoYSxiKXtmb3IodmFyIGMgaW4gYSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjKSYmYihjLGFbY10pfWZ1bmN0aW9uIHZhKGEpe3ZhciBiPXt9O3VhKGEsZnVuY3Rpb24oYSxkKXtiW2FdPWR9KTtyZXR1cm4gYn07ZnVuY3Rpb24gd2EoYSl7dGhpcy52Yz1hO3RoaXMuSmQ9XCJmaXJlYmFzZTpcIn1oPXdhLnByb3RvdHlwZTtoLnNldD1mdW5jdGlvbihhLGIpe251bGw9PWI/dGhpcy52Yy5yZW1vdmVJdGVtKHRoaXMuSmQrYSk6dGhpcy52Yy5zZXRJdGVtKHRoaXMuSmQrYSxyKGIpKX07aC5nZXQ9ZnVuY3Rpb24oYSl7YT10aGlzLnZjLmdldEl0ZW0odGhpcy5KZCthKTtyZXR1cm4gbnVsbD09YT9udWxsOnRhKGEpfTtoLnJlbW92ZT1mdW5jdGlvbihhKXt0aGlzLnZjLnJlbW92ZUl0ZW0odGhpcy5KZCthKX07aC5sZj0hMTtoLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmMudG9TdHJpbmcoKX07ZnVuY3Rpb24geGEoKXt0aGlzLnBjPXt9fXhhLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtudWxsPT1iP2RlbGV0ZSB0aGlzLnBjW2FdOnRoaXMucGNbYV09Yn07eGEucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gcyh0aGlzLnBjLGEpP3RoaXMucGNbYV06bnVsbH07eGEucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5wY1thXX07eGEucHJvdG90eXBlLmxmPSEwO2Z1bmN0aW9uIHlhKGEpe3RyeXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3dbYV0pe3ZhciBiPXdpbmRvd1thXTtiLnNldEl0ZW0oXCJmaXJlYmFzZTpzZW50aW5lbFwiLFwiY2FjaGVcIik7Yi5yZW1vdmVJdGVtKFwiZmlyZWJhc2U6c2VudGluZWxcIik7cmV0dXJuIG5ldyB3YShiKX19Y2F0Y2goYyl7fXJldHVybiBuZXcgeGF9dmFyIHphPXlhKFwibG9jYWxTdG9yYWdlXCIpLHY9eWEoXCJzZXNzaW9uU3RvcmFnZVwiKTtmdW5jdGlvbiBBYShhLGIsYyxkLGUpe3RoaXMuaG9zdD1hLnRvTG93ZXJDYXNlKCk7dGhpcy5kb21haW49dGhpcy5ob3N0LnN1YnN0cih0aGlzLmhvc3QuaW5kZXhPZihcIi5cIikrMSk7dGhpcy5CYj1iO3RoaXMudWI9Yzt0aGlzLkVnPWQ7dGhpcy5JZD1lfHxcIlwiO3RoaXMuTWE9emEuZ2V0KFwiaG9zdDpcIithKXx8dGhpcy5ob3N0fWZ1bmN0aW9uIEJhKGEsYil7YiE9PWEuTWEmJihhLk1hPWIsXCJzLVwiPT09YS5NYS5zdWJzdHIoMCwyKSYmemEuc2V0KFwiaG9zdDpcIithLmhvc3QsYS5NYSkpfUFhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPSh0aGlzLkJiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrdGhpcy5ob3N0O3RoaXMuSWQmJihhKz1cIjxcIit0aGlzLklkK1wiPlwiKTtyZXR1cm4gYX07ZnVuY3Rpb24gQ2EoKXt0aGlzLlNhPS0xfTtmdW5jdGlvbiBEYSgpe3RoaXMuU2E9LTE7dGhpcy5TYT02NDt0aGlzLlI9W107dGhpcy5nZT1bXTt0aGlzLkVmPVtdO3RoaXMuRmQ9W107dGhpcy5GZFswXT0xMjg7Zm9yKHZhciBhPTE7YTx0aGlzLlNhOysrYSl0aGlzLkZkW2FdPTA7dGhpcy5ZZD10aGlzLlRiPTA7dGhpcy5yZXNldCgpfW1hKERhLENhKTtEYS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLlJbMF09MTczMjU4NDE5Mzt0aGlzLlJbMV09NDAyMzIzMzQxNzt0aGlzLlJbMl09MjU2MjM4MzEwMjt0aGlzLlJbM109MjcxNzMzODc4O3RoaXMuUls0XT0zMjg1Mzc3NTIwO3RoaXMuWWQ9dGhpcy5UYj0wfTtcbmZ1bmN0aW9uIEVhKGEsYixjKXtjfHwoYz0wKTt2YXIgZD1hLkVmO2lmKHAoYikpZm9yKHZhciBlPTA7MTY+ZTtlKyspZFtlXT1iLmNoYXJDb2RlQXQoYyk8PDI0fGIuY2hhckNvZGVBdChjKzEpPDwxNnxiLmNoYXJDb2RlQXQoYysyKTw8OHxiLmNoYXJDb2RlQXQoYyszKSxjKz00O2Vsc2UgZm9yKGU9MDsxNj5lO2UrKylkW2VdPWJbY108PDI0fGJbYysxXTw8MTZ8YltjKzJdPDw4fGJbYyszXSxjKz00O2ZvcihlPTE2OzgwPmU7ZSsrKXt2YXIgZj1kW2UtM11eZFtlLThdXmRbZS0xNF1eZFtlLTE2XTtkW2VdPShmPDwxfGY+Pj4zMSkmNDI5NDk2NzI5NX1iPWEuUlswXTtjPWEuUlsxXTtmb3IodmFyIGc9YS5SWzJdLGs9YS5SWzNdLGw9YS5SWzRdLG4sZT0wOzgwPmU7ZSsrKTQwPmU/MjA+ZT8oZj1rXmMmKGdeayksbj0xNTE4NTAwMjQ5KTooZj1jXmdeayxuPTE4NTk3NzUzOTMpOjYwPmU/KGY9YyZnfGsmKGN8Zyksbj0yNDAwOTU5NzA4KTooZj1jXmdeayxuPTMzOTU0Njk3ODIpLGY9KGI8PFxuNXxiPj4+MjcpK2YrbCtuK2RbZV0mNDI5NDk2NzI5NSxsPWssaz1nLGc9KGM8PDMwfGM+Pj4yKSY0Mjk0OTY3Mjk1LGM9YixiPWY7YS5SWzBdPWEuUlswXStiJjQyOTQ5NjcyOTU7YS5SWzFdPWEuUlsxXStjJjQyOTQ5NjcyOTU7YS5SWzJdPWEuUlsyXStnJjQyOTQ5NjcyOTU7YS5SWzNdPWEuUlszXStrJjQyOTQ5NjcyOTU7YS5SWzRdPWEuUls0XStsJjQyOTQ5NjcyOTV9XG5EYS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7bShiKXx8KGI9YS5sZW5ndGgpO2Zvcih2YXIgYz1iLXRoaXMuU2EsZD0wLGU9dGhpcy5nZSxmPXRoaXMuVGI7ZDxiOyl7aWYoMD09Zilmb3IoO2Q8PWM7KUVhKHRoaXMsYSxkKSxkKz10aGlzLlNhO2lmKHAoYSkpZm9yKDtkPGI7KXtpZihlW2ZdPWEuY2hhckNvZGVBdChkKSwrK2YsKytkLGY9PXRoaXMuU2Epe0VhKHRoaXMsZSk7Zj0wO2JyZWFrfX1lbHNlIGZvcig7ZDxiOylpZihlW2ZdPWFbZF0sKytmLCsrZCxmPT10aGlzLlNhKXtFYSh0aGlzLGUpO2Y9MDticmVha319dGhpcy5UYj1mO3RoaXMuWWQrPWJ9O2Z1bmN0aW9uIEZhKCl7cmV0dXJuIE1hdGguZmxvb3IoMjE0NzQ4MzY0OCpNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNikrTWF0aC5hYnMoTWF0aC5mbG9vcigyMTQ3NDgzNjQ4Kk1hdGgucmFuZG9tKCkpXmxhKCkpLnRvU3RyaW5nKDM2KX07dmFyIHc9QXJyYXkucHJvdG90eXBlLEdhPXcuaW5kZXhPZj9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHcuaW5kZXhPZi5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbD09Yz8wOjA+Yz9NYXRoLm1heCgwLGEubGVuZ3RoK2MpOmM7aWYocChhKSlyZXR1cm4gcChiKSYmMT09Yi5sZW5ndGg/YS5pbmRleE9mKGIsYyk6LTE7Zm9yKDtjPGEubGVuZ3RoO2MrKylpZihjIGluIGEmJmFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSxIYT13LmZvckVhY2g/ZnVuY3Rpb24oYSxiLGMpe3cuZm9yRWFjaC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXAoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpfSxJYT13LmZpbHRlcj9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHcuZmlsdGVyLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9W10sZj0wLGc9cChhKT9cbmEuc3BsaXQoXCJcIik6YSxrPTA7azxkO2srKylpZihrIGluIGcpe3ZhciBsPWdba107Yi5jYWxsKGMsbCxrLGEpJiYoZVtmKytdPWwpfXJldHVybiBlfSxKYT13Lm1hcD9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHcubWFwLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9QXJyYXkoZCksZj1wKGEpP2Euc3BsaXQoXCJcIik6YSxnPTA7ZzxkO2crKylnIGluIGYmJihlW2ddPWIuY2FsbChjLGZbZ10sZyxhKSk7cmV0dXJuIGV9LEthPXcucmVkdWNlP2Z1bmN0aW9uKGEsYixjLGQpe2QmJihiPXEoYixkKSk7cmV0dXJuIHcucmVkdWNlLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1jO0hhKGEsZnVuY3Rpb24oYyxnKXtlPWIuY2FsbChkLGUsYyxnLGEpfSk7cmV0dXJuIGV9LExhPXcuZXZlcnk/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmV2ZXJ5LmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9XG5wKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylpZihmIGluIGUmJiFiLmNhbGwoYyxlW2ZdLGYsYSkpcmV0dXJuITE7cmV0dXJuITB9O2Z1bmN0aW9uIE1hKGEsYil7dmFyIGM9TmEoYSxiLHZvaWQgMCk7cmV0dXJuIDA+Yz9udWxsOnAoYSk/YS5jaGFyQXQoYyk6YVtjXX1mdW5jdGlvbiBOYShhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9cChhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspaWYoZiBpbiBlJiZiLmNhbGwoYyxlW2ZdLGYsYSkpcmV0dXJuIGY7cmV0dXJuLTF9ZnVuY3Rpb24gT2EoYSxiKXt2YXIgYz1HYShhLGIpOzA8PWMmJncuc3BsaWNlLmNhbGwoYSxjLDEpfWZ1bmN0aW9uIFBhKGEsYixjKXtyZXR1cm4gMj49YXJndW1lbnRzLmxlbmd0aD93LnNsaWNlLmNhbGwoYSxiKTp3LnNsaWNlLmNhbGwoYSxiLGMpfWZ1bmN0aW9uIFFhKGEsYil7YS5zb3J0KGJ8fFJhKX1mdW5jdGlvbiBSYShhLGIpe3JldHVybiBhPmI/MTphPGI/LTE6MH07dmFyIFNhO2E6e3ZhciBUYT1hYS5uYXZpZ2F0b3I7aWYoVGEpe3ZhciBVYT1UYS51c2VyQWdlbnQ7aWYoVWEpe1NhPVVhO2JyZWFrIGF9fVNhPVwiXCJ9ZnVuY3Rpb24gVmEoYSl7cmV0dXJuLTEhPVNhLmluZGV4T2YoYSl9O3ZhciBXYT1WYShcIk9wZXJhXCIpfHxWYShcIk9QUlwiKSxYYT1WYShcIlRyaWRlbnRcIil8fFZhKFwiTVNJRVwiKSxZYT1WYShcIkdlY2tvXCIpJiYtMT09U2EudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpJiYhKFZhKFwiVHJpZGVudFwiKXx8VmEoXCJNU0lFXCIpKSxaYT0tMSE9U2EudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpOyhmdW5jdGlvbigpe3ZhciBhPVwiXCIsYjtpZihXYSYmYWEub3BlcmEpcmV0dXJuIGE9YWEub3BlcmEudmVyc2lvbixoYShhKT9hKCk6YTtZYT9iPS9ydlxcOihbXlxcKTtdKykoXFwpfDspLzpYYT9iPS9cXGIoPzpNU0lFfHJ2KVs6IF0oW15cXCk7XSspKFxcKXw7KS86WmEmJihiPS9XZWJLaXRcXC8oXFxTKykvKTtiJiYoYT0oYT1iLmV4ZWMoU2EpKT9hWzFdOlwiXCIpO3JldHVybiBYYSYmKGI9KGI9YWEuZG9jdW1lbnQpP2IuZG9jdW1lbnRNb2RlOnZvaWQgMCxiPnBhcnNlRmxvYXQoYSkpP1N0cmluZyhiKTphfSkoKTt2YXIgJGE9bnVsbCxhYj1udWxsLGJiPW51bGw7ZnVuY3Rpb24gY2IoYSxiKXtpZighZmEoYSkpdGhyb3cgRXJyb3IoXCJlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXJcIik7ZGIoKTtmb3IodmFyIGM9Yj9hYjokYSxkPVtdLGU9MDtlPGEubGVuZ3RoO2UrPTMpe3ZhciBmPWFbZV0sZz1lKzE8YS5sZW5ndGgsaz1nP2FbZSsxXTowLGw9ZSsyPGEubGVuZ3RoLG49bD9hW2UrMl06MCx1PWY+PjIsZj0oZiYzKTw8NHxrPj40LGs9KGsmMTUpPDwyfG4+PjYsbj1uJjYzO2x8fChuPTY0LGd8fChrPTY0KSk7ZC5wdXNoKGNbdV0sY1tmXSxjW2tdLGNbbl0pfXJldHVybiBkLmpvaW4oXCJcIil9XG5mdW5jdGlvbiBkYigpe2lmKCEkYSl7JGE9e307YWI9e307YmI9e307Zm9yKHZhciBhPTA7NjU+YTthKyspJGFbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLmNoYXJBdChhKSxhYlthXT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8uXCIuY2hhckF0KGEpLGJiW2FiW2FdXT1hfX07dmFyIGViPWZ1bmN0aW9uKCl7dmFyIGE9MTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYSsrfX0oKTtmdW5jdGlvbiB5KGEsYil7aWYoIWEpdGhyb3cgZmIoYik7fWZ1bmN0aW9uIGZiKGEpe3JldHVybiBFcnJvcihcIkZpcmViYXNlIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6XCIrYSl9XG5mdW5jdGlvbiBnYihhKXt0cnl7dmFyIGI7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhdG9iKWI9YXRvYihhKTtlbHNle2RiKCk7Zm9yKHZhciBjPWJiLGQ9W10sZT0wO2U8YS5sZW5ndGg7KXt2YXIgZj1jW2EuY2hhckF0KGUrKyldLGc9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTowOysrZTt2YXIgaz1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjY0OysrZTt2YXIgbD1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjY0OysrZTtpZihudWxsPT1mfHxudWxsPT1nfHxudWxsPT1rfHxudWxsPT1sKXRocm93IEVycm9yKCk7ZC5wdXNoKGY8PDJ8Zz4+NCk7NjQhPWsmJihkLnB1c2goZzw8NCYyNDB8az4+MiksNjQhPWwmJmQucHVzaChrPDw2JjE5MnxsKSl9aWYoODE5Mj5kLmxlbmd0aCliPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxkKTtlbHNle2E9XCJcIjtmb3IoYz0wO2M8ZC5sZW5ndGg7Yys9ODE5MilhKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsUGEoZCxjLFxuYys4MTkyKSk7Yj1hfX1yZXR1cm4gYn1jYXRjaChuKXtoYihcImJhc2U2NERlY29kZSBmYWlsZWQ6IFwiLG4pfXJldHVybiBudWxsfWZ1bmN0aW9uIGliKGEpe3ZhciBiPWpiKGEpO2E9bmV3IERhO2EudXBkYXRlKGIpO3ZhciBiPVtdLGM9OCphLllkOzU2PmEuVGI/YS51cGRhdGUoYS5GZCw1Ni1hLlRiKTphLnVwZGF0ZShhLkZkLGEuU2EtKGEuVGItNTYpKTtmb3IodmFyIGQ9YS5TYS0xOzU2PD1kO2QtLSlhLmdlW2RdPWMmMjU1LGMvPTI1NjtFYShhLGEuZ2UpO2ZvcihkPWM9MDs1PmQ7ZCsrKWZvcih2YXIgZT0yNDswPD1lO2UtPTgpYltjXT1hLlJbZF0+PmUmMjU1LCsrYztyZXR1cm4gY2IoYil9XG5mdW5jdGlvbiBrYihhKXtmb3IodmFyIGI9XCJcIixjPTA7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliPWZhKGFyZ3VtZW50c1tjXSk/YitrYi5hcHBseShudWxsLGFyZ3VtZW50c1tjXSk6XCJvYmplY3RcIj09PXR5cGVvZiBhcmd1bWVudHNbY10/YityKGFyZ3VtZW50c1tjXSk6Yithcmd1bWVudHNbY10sYis9XCIgXCI7cmV0dXJuIGJ9dmFyIGxiPW51bGwsbWI9ITA7ZnVuY3Rpb24gaGIoYSl7ITA9PT1tYiYmKG1iPSExLG51bGw9PT1sYiYmITA9PT12LmdldChcImxvZ2dpbmdfZW5hYmxlZFwiKSYmbmIoITApKTtpZihsYil7dmFyIGI9a2IuYXBwbHkobnVsbCxhcmd1bWVudHMpO2xiKGIpfX1mdW5jdGlvbiBvYihhKXtyZXR1cm4gZnVuY3Rpb24oKXtoYihhLGFyZ3VtZW50cyl9fVxuZnVuY3Rpb24gcGIoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXt2YXIgYj1cIkZJUkVCQVNFIElOVEVSTkFMIEVSUk9SOiBcIitrYi5hcHBseShudWxsLGFyZ3VtZW50cyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlLmVycm9yP2NvbnNvbGUuZXJyb3IoYik6Y29uc29sZS5sb2coYil9fWZ1bmN0aW9uIHFiKGEpe3ZhciBiPWtiLmFwcGx5KG51bGwsYXJndW1lbnRzKTt0aHJvdyBFcnJvcihcIkZJUkVCQVNFIEZBVEFMIEVSUk9SOiBcIitiKTt9ZnVuY3Rpb24geihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe3ZhciBiPVwiRklSRUJBU0UgV0FSTklORzogXCIra2IuYXBwbHkobnVsbCxhcmd1bWVudHMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZS53YXJuP2NvbnNvbGUud2FybihiKTpjb25zb2xlLmxvZyhiKX19XG5mdW5jdGlvbiByYihhKXt2YXIgYj1cIlwiLGM9XCJcIixkPVwiXCIsZT1cIlwiLGY9ITAsZz1cImh0dHBzXCIsaz00NDM7aWYocChhKSl7dmFyIGw9YS5pbmRleE9mKFwiLy9cIik7MDw9bCYmKGc9YS5zdWJzdHJpbmcoMCxsLTEpLGE9YS5zdWJzdHJpbmcobCsyKSk7bD1hLmluZGV4T2YoXCIvXCIpOy0xPT09bCYmKGw9YS5sZW5ndGgpO2I9YS5zdWJzdHJpbmcoMCxsKTtlPVwiXCI7YT1hLnN1YnN0cmluZyhsKS5zcGxpdChcIi9cIik7Zm9yKGw9MDtsPGEubGVuZ3RoO2wrKylpZigwPGFbbF0ubGVuZ3RoKXt2YXIgbj1hW2xdO3RyeXtuPWRlY29kZVVSSUNvbXBvbmVudChuLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSl9Y2F0Y2godSl7fWUrPVwiL1wiK259YT1iLnNwbGl0KFwiLlwiKTszPT09YS5sZW5ndGg/KGM9YVsxXSxkPWFbMF0udG9Mb3dlckNhc2UoKSk6Mj09PWEubGVuZ3RoJiYoYz1hWzBdKTtsPWIuaW5kZXhPZihcIjpcIik7MDw9bCYmKGY9XCJodHRwc1wiPT09Z3x8XCJ3c3NcIj09PWcsaz1iLnN1YnN0cmluZyhsKzEpLGlzRmluaXRlKGspJiZcbihrPVN0cmluZyhrKSksaz1wKGspPy9eXFxzKi0/MHgvaS50ZXN0KGspP3BhcnNlSW50KGssMTYpOnBhcnNlSW50KGssMTApOk5hTil9cmV0dXJue2hvc3Q6Yixwb3J0OmssZG9tYWluOmMsQmc6ZCxCYjpmLHNjaGVtZTpnLFBjOmV9fWZ1bmN0aW9uIHNiKGEpe3JldHVybiBnYShhKSYmKGEhPWF8fGE9PU51bWJlci5QT1NJVElWRV9JTkZJTklUWXx8YT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKX1cbmZ1bmN0aW9uIHRiKGEpe2lmKFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUpYSgpO2Vsc2V7dmFyIGI9ITEsYz1mdW5jdGlvbigpe2RvY3VtZW50LmJvZHk/Ynx8KGI9ITAsYSgpKTpzZXRUaW1lb3V0KGMsTWF0aC5mbG9vcigxMCkpfTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyPyhkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGMsITEpKTpkb2N1bWVudC5hdHRhY2hFdmVudCYmKGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZjKCl9KSx3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixjKSl9fVxuZnVuY3Rpb24gdWIoYSxiKXtpZihhPT09YilyZXR1cm4gMDtpZihcIltNSU5fTkFNRV1cIj09PWF8fFwiW01BWF9OQU1FXVwiPT09YilyZXR1cm4tMTtpZihcIltNSU5fTkFNRV1cIj09PWJ8fFwiW01BWF9OQU1FXVwiPT09YSlyZXR1cm4gMTt2YXIgYz12YihhKSxkPXZiKGIpO3JldHVybiBudWxsIT09Yz9udWxsIT09ZD8wPT1jLWQ/YS5sZW5ndGgtYi5sZW5ndGg6Yy1kOi0xOm51bGwhPT1kPzE6YTxiPy0xOjF9ZnVuY3Rpb24gd2IoYSxiKXtpZihiJiZhIGluIGIpcmV0dXJuIGJbYV07dGhyb3cgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIGtleSAoXCIrYStcIikgaW4gb2JqZWN0OiBcIityKGIpKTt9XG5mdW5jdGlvbiB4YihhKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fG51bGw9PT1hKXJldHVybiByKGEpO3ZhciBiPVtdLGM7Zm9yKGMgaW4gYSliLnB1c2goYyk7Yi5zb3J0KCk7Yz1cIntcIjtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKykwIT09ZCYmKGMrPVwiLFwiKSxjKz1yKGJbZF0pLGMrPVwiOlwiLGMrPXhiKGFbYltkXV0pO3JldHVybiBjK1wifVwifWZ1bmN0aW9uIHliKGEsYil7aWYoYS5sZW5ndGg8PWIpcmV0dXJuW2FdO2Zvcih2YXIgYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKz1iKWQrYj5hP2MucHVzaChhLnN1YnN0cmluZyhkLGEubGVuZ3RoKSk6Yy5wdXNoKGEuc3Vic3RyaW5nKGQsZCtiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gemIoYSxiKXtpZihlYShhKSlmb3IodmFyIGM9MDtjPGEubGVuZ3RoOysrYyliKGMsYVtjXSk7ZWxzZSBBKGEsYil9XG5mdW5jdGlvbiBBYihhKXt5KCFzYihhKSxcIkludmFsaWQgSlNPTiBudW1iZXJcIik7dmFyIGIsYyxkLGU7MD09PWE/KGQ9Yz0wLGI9LUluZmluaXR5PT09MS9hPzE6MCk6KGI9MD5hLGE9TWF0aC5hYnMoYSksYT49TWF0aC5wb3coMiwtMTAyMik/KGQ9TWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyhhKS9NYXRoLkxOMiksMTAyMyksYz1kKzEwMjMsZD1NYXRoLnJvdW5kKGEqTWF0aC5wb3coMiw1Mi1kKS1NYXRoLnBvdygyLDUyKSkpOihjPTAsZD1NYXRoLnJvdW5kKGEvTWF0aC5wb3coMiwtMTA3NCkpKSk7ZT1bXTtmb3IoYT01MjthO2EtPTEpZS5wdXNoKGQlMj8xOjApLGQ9TWF0aC5mbG9vcihkLzIpO2ZvcihhPTExO2E7YS09MSllLnB1c2goYyUyPzE6MCksYz1NYXRoLmZsb29yKGMvMik7ZS5wdXNoKGI/MTowKTtlLnJldmVyc2UoKTtiPWUuam9pbihcIlwiKTtjPVwiXCI7Zm9yKGE9MDs2ND5hO2ErPTgpZD1wYXJzZUludChiLnN1YnN0cihhLDgpLDIpLnRvU3RyaW5nKDE2KSwxPT09ZC5sZW5ndGgmJlxuKGQ9XCIwXCIrZCksYys9ZDtyZXR1cm4gYy50b0xvd2VyQ2FzZSgpfXZhciBCYj0vXi0/XFxkezEsMTB9JC87ZnVuY3Rpb24gdmIoYSl7cmV0dXJuIEJiLnRlc3QoYSkmJihhPU51bWJlcihhKSwtMjE0NzQ4MzY0ODw9YSYmMjE0NzQ4MzY0Nz49YSk/YTpudWxsfWZ1bmN0aW9uIENiKGEpe3RyeXthKCl9Y2F0Y2goYil7c2V0VGltZW91dChmdW5jdGlvbigpe3ooXCJFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLlwiLGIuc3RhY2t8fFwiXCIpO3Rocm93IGI7fSxNYXRoLmZsb29yKDApKX19ZnVuY3Rpb24gQihhLGIpe2lmKGhhKGEpKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkuc2xpY2UoKTtDYihmdW5jdGlvbigpe2EuYXBwbHkobnVsbCxjKX0pfX07ZnVuY3Rpb24gRGIoYSxiLGMsZCl7dGhpcy5wZT1iO3RoaXMuU2Q9Yzt0aGlzLktkPWQ7dGhpcy5rZD1hfURiLnByb3RvdHlwZS5SYj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuU2QuZGMoKTtyZXR1cm5cInZhbHVlXCI9PT10aGlzLmtkP2EucGF0aDphLnBhcmVudCgpLnBhdGh9O0RiLnByb3RvdHlwZS50ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmtkfTtEYi5wcm90b3R5cGUuTWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wZS5NYih0aGlzKX07RGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUmIoKS50b1N0cmluZygpK1wiOlwiK3RoaXMua2QrXCI6XCIrcih0aGlzLlNkLmNmKCkpfTtmdW5jdGlvbiBFYihhLGIsYyl7dGhpcy5wZT1hO3RoaXMuZXJyb3I9Yjt0aGlzLnBhdGg9Y31FYi5wcm90b3R5cGUuUmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRofTtFYi5wcm90b3R5cGUudGU9ZnVuY3Rpb24oKXtyZXR1cm5cImNhbmNlbFwifTtcbkViLnByb3RvdHlwZS5NYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBlLk1iKHRoaXMpfTtFYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkrXCI6Y2FuY2VsXCJ9O2Z1bmN0aW9uIEMoYSxiLGMsZCl7dGhpcy50eXBlPWE7dGhpcy5IYT1iO3RoaXMuVWE9Yzt0aGlzLkVlPWQ7dGhpcy5LZD12b2lkIDB9ZnVuY3Rpb24gRmIoYSl7cmV0dXJuIG5ldyBDKEdiLGEpfXZhciBHYj1cInZhbHVlXCI7ZnVuY3Rpb24gSGIoYSxiLGMpe3RoaXMuSGI9YTt0aGlzLmxiPWI7dGhpcy5uYj1jfHxudWxsfWg9SGIucHJvdG90eXBlO2gud2Y9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ2YWx1ZVwiPT09YX07aC5jcmVhdGVFdmVudD1mdW5jdGlvbihhLGIpe3ZhciBjPWIubi5nO3JldHVybiBuZXcgRGIoXCJ2YWx1ZVwiLHRoaXMsbmV3IEQoYS5IYSxiLmRjKCksYykpfTtoLk1iPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubmI7aWYoXCJjYW5jZWxcIj09PWEudGUoKSl7eSh0aGlzLmxiLFwiUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrXCIpO3ZhciBjPXRoaXMubGI7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5jYWxsKGIsYS5lcnJvcil9fXZhciBkPXRoaXMuSGI7cmV0dXJuIGZ1bmN0aW9uKCl7ZC5jYWxsKGIsYS5TZCl9fTtoLlplPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMubGI/bmV3IEViKHRoaXMsYSxiKTpudWxsfTtcbmgubWF0Y2hlcz1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIEhiP2EuSGImJnRoaXMuSGI/YS5IYj09PXRoaXMuSGImJmEubmI9PT10aGlzLm5iOiEwOiExfTtoLmpmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLkhifTtmdW5jdGlvbiBJYihhLGIsYyl7dGhpcy5lYT1hO3RoaXMubGI9Yjt0aGlzLm5iPWN9aD1JYi5wcm90b3R5cGU7aC53Zj1mdW5jdGlvbihhKXthPVwiY2hpbGRyZW5fYWRkZWRcIj09PWE/XCJjaGlsZF9hZGRlZFwiOmE7cmV0dXJuKFwiY2hpbGRyZW5fcmVtb3ZlZFwiPT09YT9cImNoaWxkX3JlbW92ZWRcIjphKWluIHRoaXMuZWF9O2guWmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5sYj9uZXcgRWIodGhpcyxhLGIpOm51bGx9O1xuaC5jcmVhdGVFdmVudD1mdW5jdGlvbihhLGIpe3kobnVsbCE9YS5VYSxcIkNoaWxkIGV2ZW50cyBzaG91bGQgaGF2ZSBhIGNoaWxkTmFtZS5cIik7dmFyIGM9Yi5kYygpLnUoYS5VYSk7cmV0dXJuIG5ldyBEYihhLnR5cGUsdGhpcyxuZXcgRChhLkhhLGMsYi5uLmcpLGEuS2QpfTtoLk1iPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubmI7aWYoXCJjYW5jZWxcIj09PWEudGUoKSl7eSh0aGlzLmxiLFwiUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrXCIpO3ZhciBjPXRoaXMubGI7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5jYWxsKGIsYS5lcnJvcil9fXZhciBkPXRoaXMuZWFbYS5rZF07cmV0dXJuIGZ1bmN0aW9uKCl7ZC5jYWxsKGIsYS5TZCxhLktkKX19O1xuaC5tYXRjaGVzPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBJYil7aWYoIXRoaXMuZWF8fCFhLmVhKXJldHVybiEwO2lmKHRoaXMubmI9PT1hLm5iKXt2YXIgYj1KYihhLmVhKTtpZihiPT09SmIodGhpcy5lYSkpe2lmKDE9PT1iKXt2YXIgYj1LYihhLmVhKSxjPUtiKHRoaXMuZWEpO3JldHVybiBjPT09YiYmKCFhLmVhW2JdfHwhdGhpcy5lYVtjXXx8YS5lYVtiXT09PXRoaXMuZWFbY10pfXJldHVybiBMYih0aGlzLmVhLGZ1bmN0aW9uKGIsYyl7cmV0dXJuIGEuZWFbY109PT1ifSl9fX1yZXR1cm4hMX07aC5qZj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5lYX07ZnVuY3Rpb24gamIoYSl7Zm9yKHZhciBiPVtdLGM9MCxkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBlPWEuY2hhckNvZGVBdChkKTs1NTI5Njw9ZSYmNTYzMTk+PWUmJihlLT01NTI5NixkKysseShkPGEubGVuZ3RoLFwiU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuXCIpLGU9NjU1MzYrKGU8PDEwKSsoYS5jaGFyQ29kZUF0KGQpLTU2MzIwKSk7MTI4PmU/YltjKytdPWU6KDIwNDg+ZT9iW2MrK109ZT4+NnwxOTI6KDY1NTM2PmU/YltjKytdPWU+PjEyfDIyNDooYltjKytdPWU+PjE4fDI0MCxiW2MrK109ZT4+MTImNjN8MTI4KSxiW2MrK109ZT4+NiY2M3wxMjgpLGJbYysrXT1lJjYzfDEyOCl9cmV0dXJuIGJ9O2Z1bmN0aW9uIEUoYSxiLGMsZCl7dmFyIGU7ZDxiP2U9XCJhdCBsZWFzdCBcIitiOmQ+YyYmKGU9MD09PWM/XCJub25lXCI6XCJubyBtb3JlIHRoYW4gXCIrYyk7aWYoZSl0aHJvdyBFcnJvcihhK1wiIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoIFwiK2QrKDE9PT1kP1wiIGFyZ3VtZW50LlwiOlwiIGFyZ3VtZW50cy5cIikrXCIgRXhwZWN0cyBcIitlK1wiLlwiKTt9ZnVuY3Rpb24gRyhhLGIsYyl7dmFyIGQ9XCJcIjtzd2l0Y2goYil7Y2FzZSAxOmQ9Yz9cImZpcnN0XCI6XCJGaXJzdFwiO2JyZWFrO2Nhc2UgMjpkPWM/XCJzZWNvbmRcIjpcIlNlY29uZFwiO2JyZWFrO2Nhc2UgMzpkPWM/XCJ0aGlyZFwiOlwiVGhpcmRcIjticmVhaztjYXNlIDQ6ZD1jP1wiZm91cnRoXCI6XCJGb3VydGhcIjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiZXJyb3JQcmVmaXggY2FsbGVkIHdpdGggYXJndW1lbnROdW1iZXIgPiA0LiAgTmVlZCB0byB1cGRhdGUgaXQ/XCIpO31yZXR1cm4gYT1hK1wiIGZhaWxlZDogXCIrKGQrXCIgYXJndW1lbnQgXCIpfVxuZnVuY3Rpb24gSChhLGIsYyxkKXtpZigoIWR8fG0oYykpJiYhaGEoYykpdGhyb3cgRXJyb3IoRyhhLGIsZCkrXCJtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uXCIpO31mdW5jdGlvbiBNYihhLGIsYyl7aWYobShjKSYmKCFpYShjKXx8bnVsbD09PWMpKXRocm93IEVycm9yKEcoYSxiLCEwKStcIm11c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC5cIik7fTt2YXIgTmI9L1tcXFtcXF0uIyRcXC9cXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS8sT2I9L1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87ZnVuY3Rpb24gUGIoYSl7cmV0dXJuIHAoYSkmJjAhPT1hLmxlbmd0aCYmIU5iLnRlc3QoYSl9ZnVuY3Rpb24gUWIoYSl7cmV0dXJuIG51bGw9PT1hfHxwKGEpfHxnYShhKSYmIXNiKGEpfHxpYShhKSYmcyhhLFwiLnN2XCIpfWZ1bmN0aW9uIFJiKGEsYixjKXtjJiYhbShiKXx8U2IoRyhhLDEsYyksYil9XG5mdW5jdGlvbiBTYihhLGIsYyxkKXtjfHwoYz0wKTt2YXIgZT1kfHxbXTtpZighbShiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgdW5kZWZpbmVkXCIrVGIoZSkpO2lmKGhhKGIpKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIGZ1bmN0aW9uXCIrVGIoZSkrXCIgd2l0aCBjb250ZW50czogXCIrYi50b1N0cmluZygpKTtpZihzYihiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgXCIrYi50b1N0cmluZygpK1RiKGUpKTtpZigxRTM8Yyl0aHJvdyBuZXcgVHlwZUVycm9yKGErXCJjb250YWlucyBhIGN5Y2xpYyBvYmplY3QgdmFsdWUgKFwiK2Uuc2xpY2UoMCwxMDApLmpvaW4oXCIuXCIpK1wiLi4uKVwiKTtpZihwKGIpJiZiLmxlbmd0aD4xMDQ4NTc2MC8zJiYxMDQ4NTc2MDxqYihiKS5sZW5ndGgpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIGEgc3RyaW5nIGdyZWF0ZXIgdGhhbiAxMDQ4NTc2MCB1dGY4IGJ5dGVzXCIrVGIoZSkrXCIgKCdcIitiLnN1YnN0cmluZygwLDUwKStcIi4uLicpXCIpO2lmKGlhKGIpKXt2YXIgZj1cbiExLGc9ITE7dWEoYixmdW5jdGlvbihiLGQpe2lmKFwiLnZhbHVlXCI9PT1iKWY9ITA7ZWxzZSBpZihcIi5wcmlvcml0eVwiIT09YiYmXCIuc3ZcIiE9PWImJihnPSEwLCFQYihiKSkpdGhyb3cgRXJyb3IoYStcIiBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoXCIrYitcIilcIitUYihlKSsnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIicpO2UucHVzaChiKTtTYihhLGQsYysxLGUpO2UucG9wKCl9KTtpZihmJiZnKXRocm93IEVycm9yKGErJyBjb250YWlucyBcIi52YWx1ZVwiIGNoaWxkJytUYihlKStcIiBpbiBhZGRpdGlvbiB0byBhY3R1YWwgY2hpbGRyZW4uXCIpO319ZnVuY3Rpb24gVGIoYSl7cmV0dXJuIDA9PWEubGVuZ3RoP1wiXCI6XCIgaW4gcHJvcGVydHkgJ1wiK2Euam9pbihcIi5cIikrXCInXCJ9XG5mdW5jdGlvbiBVYihhLGIpe2lmKCFpYShiKXx8ZWEoYikpdGhyb3cgRXJyb3IoRyhhLDEsITEpK1wiIG11c3QgYmUgYW4gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIHRvIHJlcGxhY2UuXCIpO2lmKHMoYixcIi52YWx1ZVwiKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJyBtdXN0IG5vdCBjb250YWluIFwiLnZhbHVlXCIuICBUbyBvdmVyd3JpdGUgd2l0aCBhIGxlYWYgdmFsdWUsIGp1c3QgdXNlIC5zZXQoKSBpbnN0ZWFkLicpO1JiKGEsYiwhMSl9XG5mdW5jdGlvbiBWYihhLGIsYyl7aWYoc2IoYykpdGhyb3cgRXJyb3IoRyhhLGIsITEpK1wiaXMgXCIrYy50b1N0cmluZygpK1wiLCBidXQgbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS5cIik7aWYoIVFiKGMpKXRocm93IEVycm9yKEcoYSxiLCExKStcIm11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO31cbmZ1bmN0aW9uIFdiKGEsYixjKXtpZighY3x8bShiKSlzd2l0Y2goYil7Y2FzZSBcInZhbHVlXCI6Y2FzZSBcImNoaWxkX2FkZGVkXCI6Y2FzZSBcImNoaWxkX3JlbW92ZWRcIjpjYXNlIFwiY2hpbGRfY2hhbmdlZFwiOmNhc2UgXCJjaGlsZF9tb3ZlZFwiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoRyhhLDEsYykrJ211c3QgYmUgYSB2YWxpZCBldmVudCB0eXBlOiBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsIFwiY2hpbGRfY2hhbmdlZFwiLCBvciBcImNoaWxkX21vdmVkXCIuJyk7fX1mdW5jdGlvbiBYYihhLGIsYyxkKXtpZigoIWR8fG0oYykpJiYhUGIoYykpdGhyb3cgRXJyb3IoRyhhLGIsZCkrJ3dhcyBhbiBpbnZhbGlkIGtleTogXCInK2MrJ1wiLiAgRmlyZWJhc2Uga2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIikuJyk7fVxuZnVuY3Rpb24gWWIoYSxiKXtpZighcChiKXx8MD09PWIubGVuZ3RofHxPYi50ZXN0KGIpKXRocm93IEVycm9yKEcoYSwxLCExKSsnd2FzIGFuIGludmFsaWQgcGF0aDogXCInK2IrJ1wiLiBQYXRocyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiJyk7fWZ1bmN0aW9uIFpiKGEsYil7aWYoXCIuaW5mb1wiPT09SShiKSl0aHJvdyBFcnJvcihhK1wiIGZhaWxlZDogQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTt9ZnVuY3Rpb24gJGIoYSxiKXtpZighcChiKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgY3JlZGVudGlhbCAoYSBzdHJpbmcpLlwiKTt9ZnVuY3Rpb24gYWMoYSxiLGMpe2lmKCFwKGMpKXRocm93IEVycm9yKEcoYSxiLCExKStcIm11c3QgYmUgYSB2YWxpZCBzdHJpbmcuXCIpO31cbmZ1bmN0aW9uIEooYSxiLGMsZCl7aWYoIWR8fG0oYykpaWYoIWlhKGMpfHxudWxsPT09Yyl0aHJvdyBFcnJvcihHKGEsYixkKStcIm11c3QgYmUgYSB2YWxpZCBvYmplY3QuXCIpO31mdW5jdGlvbiBLKGEsYixjKXtpZighaWEoYil8fG51bGw9PT1ifHwhcyhiLGMpKXRocm93IEVycm9yKEcoYSwxLCExKSsnbXVzdCBjb250YWluIHRoZSBrZXkgXCInK2MrJ1wiJyk7aWYoIXAodChiLGMpKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJ211c3QgY29udGFpbiB0aGUga2V5IFwiJytjKydcIiB3aXRoIHR5cGUgXCJzdHJpbmdcIicpO307ZnVuY3Rpb24gYmMoYSl7dGhpcy5nPWF9aD1iYy5wcm90b3R5cGU7aC5EPWZ1bmN0aW9uKGEsYixjLGQsZSl7eShhLkJjKHRoaXMuZyksXCJBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkXCIpO2Q9YS5LKGIpO2lmKGQuYWEoYykpcmV0dXJuIGE7bnVsbCE9ZSYmKGMuZSgpP2EuRGEoYik/Y2MoZSxuZXcgQyhcImNoaWxkX3JlbW92ZWRcIixkLGIpKTp5KGEuTSgpLFwiQSBjaGlsZCByZW1vdmUgd2l0aG91dCBhbiBvbGQgY2hpbGQgb25seSBtYWtlcyBzZW5zZSBvbiBhIGxlYWYgbm9kZVwiKTpkLmUoKT9jYyhlLG5ldyBDKFwiY2hpbGRfYWRkZWRcIixjLGIpKTpjYyhlLG5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGMsYixkKSkpO3JldHVybiBhLk0oKSYmYy5lKCk/YTphLlAoYixjKS5oYih0aGlzLmcpfTtcbmgub2E9ZnVuY3Rpb24oYSxiLGMpe251bGwhPWMmJihhLk0oKXx8YS5VKEwsZnVuY3Rpb24oYSxlKXtiLkRhKGEpfHxjYyhjLG5ldyBDKFwiY2hpbGRfcmVtb3ZlZFwiLGUsYSkpfSksYi5NKCl8fGIuVShMLGZ1bmN0aW9uKGIsZSl7aWYoYS5EYShiKSl7dmFyIGY9YS5LKGIpO2YuYWEoZSl8fGNjKGMsbmV3IEMoXCJjaGlsZF9jaGFuZ2VkXCIsZSxiLGYpKX1lbHNlIGNjKGMsbmV3IEMoXCJjaGlsZF9hZGRlZFwiLGUsYikpfSkpO3JldHVybiBiLmhiKHRoaXMuZyl9O2guJD1mdW5jdGlvbihhLGIpe3JldHVybiBhLmUoKT9NOmEuJChiKX07aC5DYT1mdW5jdGlvbigpe3JldHVybiExfTtoLk5iPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGRjKGEpe3RoaXMudmU9bmV3IGJjKGEuZyk7dGhpcy5nPWEuZzt2YXIgYjthLmlhPyhiPWVjKGEpLGI9YS5nLnVkKGZjKGEpLGIpKTpiPWEuZy55ZCgpO3RoaXMuVmM9YjthLnFhPyhiPWdjKGEpLGE9YS5nLnVkKGhjKGEpLGIpKTphPWEuZy53ZCgpO3RoaXMueGM9YX1oPWRjLnByb3RvdHlwZTtoLm1hdGNoZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIDA+PXRoaXMuZy5jb21wYXJlKHRoaXMuVmMsYSkmJjA+PXRoaXMuZy5jb21wYXJlKGEsdGhpcy54Yyl9O2guRD1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMubWF0Y2hlcyhuZXcgTihiLGMpKXx8KGM9TSk7cmV0dXJuIHRoaXMudmUuRChhLGIsYyxkLGUpfTtoLm9hPWZ1bmN0aW9uKGEsYixjKXtiLk0oKSYmKGI9TSk7dmFyIGQ9Yi5oYih0aGlzLmcpLGQ9ZC4kKE0pLGU9dGhpcztiLlUoTCxmdW5jdGlvbihhLGIpe2UubWF0Y2hlcyhuZXcgTihhLGIpKXx8KGQ9ZC5QKGEsTSkpfSk7cmV0dXJuIHRoaXMudmUub2EoYSxkLGMpfTtcbmguJD1mdW5jdGlvbihhKXtyZXR1cm4gYX07aC5DYT1mdW5jdGlvbigpe3JldHVybiEwfTtoLk5iPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmV9O2Z1bmN0aW9uIGljKGEsYil7cmV0dXJuIHViKGEubmFtZSxiLm5hbWUpfWZ1bmN0aW9uIGpjKGEsYil7cmV0dXJuIHViKGEsYil9O2Z1bmN0aW9uIGtjKCl7fXZhciBsYz17fTtmdW5jdGlvbiBtYyhhKXtyZXR1cm4gcShhLmNvbXBhcmUsYSl9a2MucHJvdG90eXBlLndlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDAhPT10aGlzLmNvbXBhcmUobmV3IE4oXCJbTUlOX05BTUVdXCIsYSksbmV3IE4oXCJbTUlOX05BTUVdXCIsYikpfTtrYy5wcm90b3R5cGUueWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmN9O2Z1bmN0aW9uIG9jKGEpe3RoaXMuVmI9YX1tYShvYyxrYyk7aD1vYy5wcm90b3R5cGU7aC5zZD1mdW5jdGlvbihhKXtyZXR1cm4hYS5LKHRoaXMuVmIpLmUoKX07aC5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5WLksodGhpcy5WYiksZD1iLlYuSyh0aGlzLlZiKSxjPWMuZGQoZCk7cmV0dXJuIDA9PT1jP3ViKGEubmFtZSxiLm5hbWUpOmN9O2gudWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1PKGEpLGM9TS5QKHRoaXMuVmIsYyk7cmV0dXJuIG5ldyBOKGIsYyl9O1xuaC53ZD1mdW5jdGlvbigpe3ZhciBhPU0uUCh0aGlzLlZiLHBjKTtyZXR1cm4gbmV3IE4oXCJbTUFYX05BTUVdXCIsYSl9O2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5WYn07dmFyIEw9bmV3IG9jKFwiLnByaW9yaXR5XCIpO2Z1bmN0aW9uIHFjKCl7fW1hKHFjLGtjKTtoPXFjLnByb3RvdHlwZTtoLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdWIoYS5uYW1lLGIubmFtZSl9O2guc2Q9ZnVuY3Rpb24oKXt0aHJvdyBmYihcIktleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuXCIpO307aC53ZT1mdW5jdGlvbigpe3JldHVybiExfTtoLnlkPWZ1bmN0aW9uKCl7cmV0dXJuIG5jfTtoLndkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBOKFwiW01BWF9OQU1FXVwiLE0pfTtoLnVkPWZ1bmN0aW9uKGEpe3kocChhKSxcIktleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuXCIpO3JldHVybiBuZXcgTihhLE0pfTtcbmgudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIi5rZXlcIn07dmFyIHJjPW5ldyBxYztmdW5jdGlvbiBzYygpe31tYShzYyxrYyk7aD1zYy5wcm90b3R5cGU7aC5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5WLmRkKGIuVik7cmV0dXJuIDA9PT1jP3ViKGEubmFtZSxiLm5hbWUpOmN9O2guc2Q9ZnVuY3Rpb24oKXtyZXR1cm4hMH07aC53ZT1mdW5jdGlvbihhLGIpe3JldHVybiFhLmFhKGIpfTtoLnlkPWZ1bmN0aW9uKCl7cmV0dXJuIG5jfTtoLndkPWZ1bmN0aW9uKCl7cmV0dXJuIHRjfTtoLnVkPWZ1bmN0aW9uKGEsYil7dmFyIGM9TyhhKTtyZXR1cm4gbmV3IE4oYixjKX07aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLnZhbHVlXCJ9O3ZhciB1Yz1uZXcgc2M7ZnVuY3Rpb24gdmMoKXt9dmMucHJvdG90eXBlLmZmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3ZjLnByb3RvdHlwZS5zZT1mdW5jdGlvbigpe3JldHVybiBudWxsfTt2YXIgd2M9bmV3IHZjO2Z1bmN0aW9uIHhjKGEsYixjKXt0aGlzLkJmPWE7dGhpcy5JYT1iO3RoaXMuRWQ9Y314Yy5wcm90b3R5cGUuZmY9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5JYS5CO2lmKHljKGIsYSkpcmV0dXJuIGIuaigpLksoYSk7Yj1udWxsIT10aGlzLkVkP25ldyB6Yyh0aGlzLkVkLCEwLCExKTp0aGlzLklhLm8oKTtyZXR1cm4gdGhpcy5CZi5UYShhLGIpfTt4Yy5wcm90b3R5cGUuc2U9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW51bGwhPXRoaXMuRWQ/dGhpcy5FZDpBYyh0aGlzLklhKTthPXRoaXMuQmYuaGUoZCxiLDEsYyxhKTtyZXR1cm4gMD09PWEubGVuZ3RoP251bGw6YVswXX07ZnVuY3Rpb24gQmMoKXt0aGlzLlphPXt9fVxuZnVuY3Rpb24gY2MoYSxiKXt2YXIgYz1iLnR5cGUsZD1iLlVhO3koXCJjaGlsZF9hZGRlZFwiPT1jfHxcImNoaWxkX2NoYW5nZWRcIj09Y3x8XCJjaGlsZF9yZW1vdmVkXCI9PWMsXCJPbmx5IGNoaWxkIGNoYW5nZXMgc3VwcG9ydGVkIGZvciB0cmFja2luZ1wiKTt5KFwiLnByaW9yaXR5XCIhPT1kLFwiT25seSBub24tcHJpb3JpdHkgY2hpbGQgY2hhbmdlcyBjYW4gYmUgdHJhY2tlZC5cIik7dmFyIGU9dChhLlphLGQpO2lmKGUpe3ZhciBmPWUudHlwZTtpZihcImNoaWxkX2FkZGVkXCI9PWMmJlwiY2hpbGRfcmVtb3ZlZFwiPT1mKWEuWmFbZF09bmV3IEMoXCJjaGlsZF9jaGFuZ2VkXCIsYi5IYSxkLGUuSGEpO2Vsc2UgaWYoXCJjaGlsZF9yZW1vdmVkXCI9PWMmJlwiY2hpbGRfYWRkZWRcIj09ZilkZWxldGUgYS5aYVtkXTtlbHNlIGlmKFwiY2hpbGRfcmVtb3ZlZFwiPT1jJiZcImNoaWxkX2NoYW5nZWRcIj09ZilhLlphW2RdPW5ldyBDKFwiY2hpbGRfcmVtb3ZlZFwiLGUuRWUsZCk7ZWxzZSBpZihcImNoaWxkX2NoYW5nZWRcIj09YyYmXG5cImNoaWxkX2FkZGVkXCI9PWYpYS5aYVtkXT1uZXcgQyhcImNoaWxkX2FkZGVkXCIsYi5IYSxkKTtlbHNlIGlmKFwiY2hpbGRfY2hhbmdlZFwiPT1jJiZcImNoaWxkX2NoYW5nZWRcIj09ZilhLlphW2RdPW5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGIuSGEsZCxlLkVlKTtlbHNlIHRocm93IGZiKFwiSWxsZWdhbCBjb21iaW5hdGlvbiBvZiBjaGFuZ2VzOiBcIitiK1wiIG9jY3VycmVkIGFmdGVyIFwiK2UpO31lbHNlIGEuWmFbZF09Yn07ZnVuY3Rpb24gTihhLGIpe3RoaXMubmFtZT1hO3RoaXMuVj1ifWZ1bmN0aW9uIENjKGEsYil7cmV0dXJuIG5ldyBOKGEsYil9O2Z1bmN0aW9uIERjKGEpe3RoaXMubWE9bmV3IGRjKGEpO3RoaXMuZz1hLmc7eShhLmthLFwiT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXRcIik7dGhpcy5zYT1hLnNhO3RoaXMuQWI9IShcIlwiPT09YS5GYj9hLmlhOlwibFwiPT09YS5GYil9aD1EYy5wcm90b3R5cGU7aC5EPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5tYS5tYXRjaGVzKG5ldyBOKGIsYykpfHwoYz1NKTtyZXR1cm4gYS5LKGIpLmFhKGMpP2E6YS52YigpPHRoaXMuc2E/dGhpcy5tYS5OYigpLkQoYSxiLGMsZCxlKTpFYyh0aGlzLGEsYixjLGQsZSl9O1xuaC5vYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoYi5NKCl8fGIuZSgpKWQ9TS5oYih0aGlzLmcpO2Vsc2UgaWYoMip0aGlzLnNhPGIudmIoKSYmYi5CYyh0aGlzLmcpKXtkPU0uaGIodGhpcy5nKTtiPXRoaXMuQWI/Yi5TYih0aGlzLm1hLnhjLHRoaXMuZyk6Yi5RYih0aGlzLm1hLlZjLHRoaXMuZyk7Zm9yKHZhciBlPTA7MDxiLk5hLmxlbmd0aCYmZTx0aGlzLnNhOyl7dmFyIGY9UChiKSxnO2lmKGc9dGhpcy5BYj8wPj10aGlzLmcuY29tcGFyZSh0aGlzLm1hLlZjLGYpOjA+PXRoaXMuZy5jb21wYXJlKGYsdGhpcy5tYS54YykpZD1kLlAoZi5uYW1lLGYuViksZSsrO2Vsc2UgYnJlYWt9fWVsc2V7ZD1iLmhiKHRoaXMuZyk7ZD1kLiQoTSk7dmFyIGssbCxuO2lmKHRoaXMuQWIpe2I9ZC5oZih0aGlzLmcpO2s9dGhpcy5tYS54YztsPXRoaXMubWEuVmM7dmFyIHU9bWModGhpcy5nKTtuPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHUoYixhKX19ZWxzZSBiPWQuUGIodGhpcy5nKSxrPXRoaXMubWEuVmMsXG5sPXRoaXMubWEueGMsbj1tYyh0aGlzLmcpO2Zvcih2YXIgZT0wLHg9ITE7MDxiLk5hLmxlbmd0aDspZj1QKGIpLCF4JiYwPj1uKGssZikmJih4PSEwKSwoZz14JiZlPHRoaXMuc2EmJjA+PW4oZixsKSk/ZSsrOmQ9ZC5QKGYubmFtZSxNKX1yZXR1cm4gdGhpcy5tYS5OYigpLm9hKGEsZCxjKX07aC4kPWZ1bmN0aW9uKGEpe3JldHVybiBhfTtoLkNhPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guTmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYS5OYigpfTtcbmZ1bmN0aW9uIEVjKGEsYixjLGQsZSxmKXt2YXIgZztpZihhLkFiKXt2YXIgaz1tYyhhLmcpO2c9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gayhiLGEpfX1lbHNlIGc9bWMoYS5nKTt5KGIudmIoKT09YS5zYSxcIlwiKTt2YXIgbD1uZXcgTihjLGQpLG49YS5BYj9GYyhiLGEuZyk6R2MoYixhLmcpLHU9YS5tYS5tYXRjaGVzKGwpO2lmKGIuRGEoYykpe3ZhciB4PWIuSyhjKSxuPWUuc2UoYS5nLG4sYS5BYik7bnVsbCE9biYmbi5uYW1lPT1jJiYobj1lLnNlKGEuZyxuLGEuQWIpKTtlPW51bGw9PW4/MTpnKG4sbCk7aWYodSYmIWQuZSgpJiYwPD1lKXJldHVybiBudWxsIT1mJiZjYyhmLG5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGQsYyx4KSksYi5QKGMsZCk7bnVsbCE9ZiYmY2MoZixuZXcgQyhcImNoaWxkX3JlbW92ZWRcIix4LGMpKTtiPWIuUChjLE0pO3JldHVybiBudWxsIT1uJiZhLm1hLm1hdGNoZXMobik/KG51bGwhPWYmJmNjKGYsbmV3IEMoXCJjaGlsZF9hZGRlZFwiLG4uVixuLm5hbWUpKSxiLlAobi5uYW1lLFxubi5WKSk6Yn1yZXR1cm4gZC5lKCk/Yjp1JiYwPD1nKG4sbCk/KG51bGwhPWYmJihjYyhmLG5ldyBDKFwiY2hpbGRfcmVtb3ZlZFwiLG4uVixuLm5hbWUpKSxjYyhmLG5ldyBDKFwiY2hpbGRfYWRkZWRcIixkLGMpKSksYi5QKGMsZCkuUChuLm5hbWUsTSkpOmJ9O2Z1bmN0aW9uIEhjKCl7dGhpcy53Yz10aGlzLnFhPXRoaXMubGM9dGhpcy5pYT10aGlzLmthPSExO3RoaXMuc2E9MDt0aGlzLkZiPVwiXCI7dGhpcy5BYz1udWxsO3RoaXMuWGI9XCJcIjt0aGlzLnpjPW51bGw7dGhpcy5VYj1cIlwiO3RoaXMuZz1MfXZhciBJYz1uZXcgSGM7ZnVuY3Rpb24gZmMoYSl7eShhLmlhLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuQWN9ZnVuY3Rpb24gZWMoYSl7eShhLmlhLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEubGM/YS5YYjpcIltNSU5fTkFNRV1cIn1mdW5jdGlvbiBoYyhhKXt5KGEucWEsXCJPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuemN9ZnVuY3Rpb24gZ2MoYSl7eShhLnFhLFwiT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLndjP2EuVWI6XCJbTUFYX05BTUVdXCJ9XG5mdW5jdGlvbiBKYyhhKXt2YXIgYj1uZXcgSGM7Yi5rYT1hLmthO2Iuc2E9YS5zYTtiLmlhPWEuaWE7Yi5BYz1hLkFjO2IubGM9YS5sYztiLlhiPWEuWGI7Yi5xYT1hLnFhO2IuemM9YS56YztiLndjPWEud2M7Yi5VYj1hLlViO2IuZz1hLmc7cmV0dXJuIGJ9aD1IYy5wcm90b3R5cGU7aC5CZT1mdW5jdGlvbihhKXt2YXIgYj1KYyh0aGlzKTtiLmthPSEwO2Iuc2E9YTtiLkZiPVwiXCI7cmV0dXJuIGJ9O2guQ2U9ZnVuY3Rpb24oYSl7dmFyIGI9SmModGhpcyk7Yi5rYT0hMDtiLnNhPWE7Yi5GYj1cImxcIjtyZXR1cm4gYn07aC5EZT1mdW5jdGlvbihhKXt2YXIgYj1KYyh0aGlzKTtiLmthPSEwO2Iuc2E9YTtiLkZiPVwiclwiO3JldHVybiBifTtoLlRkPWZ1bmN0aW9uKGEsYil7dmFyIGM9SmModGhpcyk7Yy5pYT0hMDttKGEpfHwoYT1udWxsKTtjLkFjPWE7bnVsbCE9Yj8oYy5sYz0hMCxjLlhiPWIpOihjLmxjPSExLGMuWGI9XCJcIik7cmV0dXJuIGN9O1xuaC5qZD1mdW5jdGlvbihhLGIpe3ZhciBjPUpjKHRoaXMpO2MucWE9ITA7bShhKXx8KGE9bnVsbCk7Yy56Yz1hO20oYik/KGMud2M9ITAsYy5VYj1iKTooYy5KZz0hMSxjLlViPVwiXCIpO3JldHVybiBjfTtmdW5jdGlvbiBLYyhhLGIpe3ZhciBjPUpjKGEpO2MuZz1iO3JldHVybiBjfWZ1bmN0aW9uIExjKGEpe3ZhciBiPXt9O2EuaWEmJihiLnNwPWEuQWMsYS5sYyYmKGIuc249YS5YYikpO2EucWEmJihiLmVwPWEuemMsYS53YyYmKGIuZW49YS5VYikpO2lmKGEua2Epe2IubD1hLnNhO3ZhciBjPWEuRmI7XCJcIj09PWMmJihjPWEuaWE/XCJsXCI6XCJyXCIpO2IudmY9Y31hLmchPT1MJiYoYi5pPWEuZy50b1N0cmluZygpKTtyZXR1cm4gYn1mdW5jdGlvbiBNYyhhKXtyZXR1cm4hKGEuaWF8fGEucWF8fGEua2EpfWgudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcihMYyh0aGlzKSl9O2Z1bmN0aW9uIFEoYSxiLGMsZCl7dGhpcy5rPWE7dGhpcy5wYXRoPWI7dGhpcy5uPWM7dGhpcy5iYz1kfVxuZnVuY3Rpb24gTmMoYSl7dmFyIGI9bnVsbCxjPW51bGw7YS5pYSYmKGI9ZmMoYSkpO2EucWEmJihjPWhjKGEpKTtpZihhLmc9PT1yYyl7aWYoYS5pYSl7aWYoXCJbTUlOX05BTUVdXCIhPWVjKGEpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuXCIpO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYil0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuXCIpO31pZihhLnFhKXtpZihcIltNQVhfTkFNRV1cIiE9Z2MoYSkpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHlvdSBtYXkgb25seSBwYXNzIG9uZSBhcmd1bWVudCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS5cIik7aWYoXCJzdHJpbmdcIiE9PVxudHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLlwiKTt9fWVsc2UgaWYoYS5nPT09TCl7aWYobnVsbCE9YiYmIVFiKGIpfHxudWxsIT1jJiYhUWIoYykpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBwcmlvcml0eSwgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgdmFsaWQgcHJpb3JpdHkgdmFsdWUgKG51bGwsIGEgbnVtYmVyLCBvciBhIHN0cmluZykuXCIpO31lbHNlIGlmKHkoYS5nIGluc3RhbmNlb2Ygb2N8fGEuZz09PXVjLFwidW5rbm93biBpbmRleCB0eXBlLlwiKSxudWxsIT1iJiZcIm9iamVjdFwiPT09dHlwZW9mIGJ8fG51bGwhPWMmJlwib2JqZWN0XCI9PT10eXBlb2YgYyl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgY2Fubm90IGJlIGFuIG9iamVjdC5cIik7XG59ZnVuY3Rpb24gT2MoYSl7aWYoYS5pYSYmYS5xYSYmYS5rYSYmKCFhLmthfHxcIlwiPT09YS5GYikpdGhyb3cgRXJyb3IoXCJRdWVyeTogQ2FuJ3QgY29tYmluZSBzdGFydEF0KCksIGVuZEF0KCksIGFuZCBsaW1pdCgpLiBVc2UgbGltaXRUb0ZpcnN0KCkgb3IgbGltaXRUb0xhc3QoKSBpbnN0ZWFkLlwiKTt9ZnVuY3Rpb24gUGMoYSxiKXtpZighMD09PWEuYmMpdGhyb3cgRXJyb3IoYitcIjogWW91IGNhbid0IGNvbWJpbmUgbXVsdGlwbGUgb3JkZXJCeSBjYWxscy5cIik7fVEucHJvdG90eXBlLmRjPWZ1bmN0aW9uKCl7RShcIlF1ZXJ5LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gbmV3IFIodGhpcy5rLHRoaXMucGF0aCl9O1EucHJvdG90eXBlLnJlZj1RLnByb3RvdHlwZS5kYztcblEucHJvdG90eXBlLndiPWZ1bmN0aW9uKGEsYixjLGQpe0UoXCJRdWVyeS5vblwiLDIsNCxhcmd1bWVudHMubGVuZ3RoKTtXYihcIlF1ZXJ5Lm9uXCIsYSwhMSk7SChcIlF1ZXJ5Lm9uXCIsMixiLCExKTt2YXIgZT1RYyhcIlF1ZXJ5Lm9uXCIsYyxkKTtpZihcInZhbHVlXCI9PT1hKVJjKHRoaXMuayx0aGlzLG5ldyBIYihiLGUuY2FuY2VsfHxudWxsLGUuS2F8fG51bGwpKTtlbHNle3ZhciBmPXt9O2ZbYV09YjtSYyh0aGlzLmssdGhpcyxuZXcgSWIoZixlLmNhbmNlbCxlLkthKSl9cmV0dXJuIGJ9O1EucHJvdG90eXBlLm9uPVEucHJvdG90eXBlLndiO1xuUS5wcm90b3R5cGUuJGI9ZnVuY3Rpb24oYSxiLGMpe0UoXCJRdWVyeS5vZmZcIiwwLDMsYXJndW1lbnRzLmxlbmd0aCk7V2IoXCJRdWVyeS5vZmZcIixhLCEwKTtIKFwiUXVlcnkub2ZmXCIsMixiLCEwKTtNYihcIlF1ZXJ5Lm9mZlwiLDMsYyk7dmFyIGQ9bnVsbCxlPW51bGw7XCJ2YWx1ZVwiPT09YT9kPW5ldyBIYihifHxudWxsLG51bGwsY3x8bnVsbCk6YSYmKGImJihlPXt9LGVbYV09YiksZD1uZXcgSWIoZSxudWxsLGN8fG51bGwpKTtlPXRoaXMuaztkPVwiLmluZm9cIj09PUkodGhpcy5wYXRoKT9lLnJkLmdiKHRoaXMsZCk6ZS5OLmdiKHRoaXMsZCk7U2MoZS5iYSx0aGlzLnBhdGgsZCl9O1EucHJvdG90eXBlLm9mZj1RLnByb3RvdHlwZS4kYjtcblEucHJvdG90eXBlLmxnPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhnKXtmJiYoZj0hMSxlLiRiKGEsYyksYi5jYWxsKGQuS2EsZykpfUUoXCJRdWVyeS5vbmNlXCIsMiw0LGFyZ3VtZW50cy5sZW5ndGgpO1diKFwiUXVlcnkub25jZVwiLGEsITEpO0goXCJRdWVyeS5vbmNlXCIsMixiLCExKTt2YXIgZD1RYyhcIlF1ZXJ5Lm9uY2VcIixhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSxlPXRoaXMsZj0hMDt0aGlzLndiKGEsYyxmdW5jdGlvbihiKXtlLiRiKGEsYyk7ZC5jYW5jZWwmJmQuY2FuY2VsLmNhbGwoZC5LYSxiKX0pfTtRLnByb3RvdHlwZS5vbmNlPVEucHJvdG90eXBlLmxnO1xuUS5wcm90b3R5cGUuQmU9ZnVuY3Rpb24oYSl7eihcIlF1ZXJ5LmxpbWl0KCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBRdWVyeS5saW1pdFRvRmlyc3QoKSBvciBRdWVyeS5saW1pdFRvTGFzdCgpIGluc3RlYWQuXCIpO0UoXCJRdWVyeS5saW1pdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZ2EoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXQ6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4ua2EpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsIGxpbWl0VG9GaXJzdCwgb3JsaW1pdFRvTGFzdC5cIik7dmFyIGI9dGhpcy5uLkJlKGEpO09jKGIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGIsdGhpcy5iYyl9O1EucHJvdG90eXBlLmxpbWl0PVEucHJvdG90eXBlLkJlO1xuUS5wcm90b3R5cGUuQ2U9ZnVuY3Rpb24oYSl7RShcIlF1ZXJ5LmxpbWl0VG9GaXJzdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZ2EoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmthKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLHRoaXMubi5DZShhKSx0aGlzLmJjKX07US5wcm90b3R5cGUubGltaXRUb0ZpcnN0PVEucHJvdG90eXBlLkNlO1xuUS5wcm90b3R5cGUuRGU9ZnVuY3Rpb24oYSl7RShcIlF1ZXJ5LmxpbWl0VG9MYXN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXCIpO2lmKHRoaXMubi5rYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLHRoaXMubi5EZShhKSx0aGlzLmJjKX07US5wcm90b3R5cGUubGltaXRUb0xhc3Q9US5wcm90b3R5cGUuRGU7XG5RLnByb3RvdHlwZS5tZz1mdW5jdGlvbihhKXtFKFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKFwiJGtleVwiPT09YSl0aHJvdyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBcIiRrZXlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlLZXkoKSBpbnN0ZWFkLicpO2lmKFwiJHByaW9yaXR5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHByaW9yaXR5XCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5UHJpb3JpdHkoKSBpbnN0ZWFkLicpO2lmKFwiJHZhbHVlXCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1hiKFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsMSxhLCExKTtQYyh0aGlzLFwiUXVlcnkub3JkZXJCeUNoaWxkXCIpO3ZhciBiPUtjKHRoaXMubixuZXcgb2MoYSkpO05jKGIpO3JldHVybiBuZXcgUSh0aGlzLmssXG50aGlzLnBhdGgsYiwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlDaGlsZD1RLnByb3RvdHlwZS5tZztRLnByb3RvdHlwZS5uZz1mdW5jdGlvbigpe0UoXCJRdWVyeS5vcmRlckJ5S2V5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1BjKHRoaXMsXCJRdWVyeS5vcmRlckJ5S2V5XCIpO3ZhciBhPUtjKHRoaXMubixyYyk7TmMoYSk7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYSwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlLZXk9US5wcm90b3R5cGUubmc7US5wcm90b3R5cGUub2c9ZnVuY3Rpb24oKXtFKFwiUXVlcnkub3JkZXJCeVByaW9yaXR5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1BjKHRoaXMsXCJRdWVyeS5vcmRlckJ5UHJpb3JpdHlcIik7dmFyIGE9S2ModGhpcy5uLEwpO05jKGEpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGEsITApfTtRLnByb3RvdHlwZS5vcmRlckJ5UHJpb3JpdHk9US5wcm90b3R5cGUub2c7XG5RLnByb3RvdHlwZS5wZz1mdW5jdGlvbigpe0UoXCJRdWVyeS5vcmRlckJ5VmFsdWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7UGModGhpcyxcIlF1ZXJ5Lm9yZGVyQnlWYWx1ZVwiKTt2YXIgYT1LYyh0aGlzLm4sdWMpO05jKGEpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGEsITApfTtRLnByb3RvdHlwZS5vcmRlckJ5VmFsdWU9US5wcm90b3R5cGUucGc7XG5RLnByb3RvdHlwZS5UZD1mdW5jdGlvbihhLGIpe0UoXCJRdWVyeS5zdGFydEF0XCIsMCwyLGFyZ3VtZW50cy5sZW5ndGgpO1JiKFwiUXVlcnkuc3RhcnRBdFwiLGEsITApO1hiKFwiUXVlcnkuc3RhcnRBdFwiLDIsYiwhMCk7dmFyIGM9dGhpcy5uLlRkKGEsYik7T2MoYyk7TmMoYyk7aWYodGhpcy5uLmlhKXRocm93IEVycm9yKFwiUXVlcnkuc3RhcnRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCBvciBlcXVhbFRvKS5cIik7bShhKXx8KGI9YT1udWxsKTtyZXR1cm4gbmV3IFEodGhpcy5rLHRoaXMucGF0aCxjLHRoaXMuYmMpfTtRLnByb3RvdHlwZS5zdGFydEF0PVEucHJvdG90eXBlLlRkO1xuUS5wcm90b3R5cGUuamQ9ZnVuY3Rpb24oYSxiKXtFKFwiUXVlcnkuZW5kQXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7UmIoXCJRdWVyeS5lbmRBdFwiLGEsITApO1hiKFwiUXVlcnkuZW5kQXRcIiwyLGIsITApO3ZhciBjPXRoaXMubi5qZChhLGIpO09jKGMpO05jKGMpO2lmKHRoaXMubi5xYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVuZEF0OiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGMsdGhpcy5iYyl9O1EucHJvdG90eXBlLmVuZEF0PVEucHJvdG90eXBlLmpkO1xuUS5wcm90b3R5cGUuVGY9ZnVuY3Rpb24oYSxiKXtFKFwiUXVlcnkuZXF1YWxUb1wiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtSYihcIlF1ZXJ5LmVxdWFsVG9cIixhLCExKTtYYihcIlF1ZXJ5LmVxdWFsVG9cIiwyLGIsITApO2lmKHRoaXMubi5pYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVxdWFsVG86IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yIGVxdWFsVG8pLlwiKTtpZih0aGlzLm4ucWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5lcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiB0aGlzLlRkKGEsYikuamQoYSxiKX07US5wcm90b3R5cGUuZXF1YWxUbz1RLnByb3RvdHlwZS5UZjtRLnByb3RvdHlwZS5GYT1mdW5jdGlvbigpe3ZhciBhPXhiKExjKHRoaXMubikpO3JldHVyblwie31cIj09PWE/XCJkZWZhdWx0XCI6YX07XG5mdW5jdGlvbiBRYyhhLGIsYyl7dmFyIGQ9e2NhbmNlbDpudWxsLEthOm51bGx9O2lmKGImJmMpZC5jYW5jZWw9YixIKGEsMyxkLmNhbmNlbCwhMCksZC5LYT1jLE1iKGEsNCxkLkthKTtlbHNlIGlmKGIpaWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09YilkLkthPWI7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilkLmNhbmNlbD1iO2Vsc2UgdGhyb3cgRXJyb3IoRyhhLDMsITApK1wiIG11c3QgZWl0aGVyIGJlIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dCBvYmplY3QuXCIpO3JldHVybiBkfTtmdW5jdGlvbiBTKGEsYil7aWYoMT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy53PWEuc3BsaXQoXCIvXCIpO2Zvcih2YXIgYz0wLGQ9MDtkPHRoaXMudy5sZW5ndGg7ZCsrKTA8dGhpcy53W2RdLmxlbmd0aCYmKHRoaXMud1tjXT10aGlzLndbZF0sYysrKTt0aGlzLncubGVuZ3RoPWM7dGhpcy5kYT0wfWVsc2UgdGhpcy53PWEsdGhpcy5kYT1ifWZ1bmN0aW9uIEkoYSl7cmV0dXJuIGEuZGE+PWEudy5sZW5ndGg/bnVsbDphLndbYS5kYV19ZnVuY3Rpb24gVGMoYSl7cmV0dXJuIGEudy5sZW5ndGgtYS5kYX1mdW5jdGlvbiBUKGEpe3ZhciBiPWEuZGE7YjxhLncubGVuZ3RoJiZiKys7cmV0dXJuIG5ldyBTKGEudyxiKX1mdW5jdGlvbiBVYyhhKXtyZXR1cm4gYS5kYTxhLncubGVuZ3RoP2Eud1thLncubGVuZ3RoLTFdOm51bGx9XG5TLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe2Zvcih2YXIgYT1cIlwiLGI9dGhpcy5kYTtiPHRoaXMudy5sZW5ndGg7YisrKVwiXCIhPT10aGlzLndbYl0mJihhKz1cIi9cIit0aGlzLndbYl0pO3JldHVybiBhfHxcIi9cIn07Uy5wcm90b3R5cGUucGFyZW50PWZ1bmN0aW9uKCl7aWYodGhpcy5kYT49dGhpcy53Lmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIGE9W10sYj10aGlzLmRhO2I8dGhpcy53Lmxlbmd0aC0xO2IrKylhLnB1c2godGhpcy53W2JdKTtyZXR1cm4gbmV3IFMoYSwwKX07XG5TLnByb3RvdHlwZS51PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPXRoaXMuZGE7Yzx0aGlzLncubGVuZ3RoO2MrKyliLnB1c2godGhpcy53W2NdKTtpZihhIGluc3RhbmNlb2YgUylmb3IoYz1hLmRhO2M8YS53Lmxlbmd0aDtjKyspYi5wdXNoKGEud1tjXSk7ZWxzZSBmb3IoYT1hLnNwbGl0KFwiL1wiKSxjPTA7YzxhLmxlbmd0aDtjKyspMDxhW2NdLmxlbmd0aCYmYi5wdXNoKGFbY10pO3JldHVybiBuZXcgUyhiLDApfTtTLnByb3RvdHlwZS5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGE+PXRoaXMudy5sZW5ndGh9O3ZhciBVPW5ldyBTKFwiXCIpO2Z1bmN0aW9uIFYoYSxiKXt2YXIgYz1JKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGM9PT1JKGIpKXJldHVybiBWKFQoYSksVChiKSk7dGhyb3cgRXJyb3IoXCJJTlRFUk5BTCBFUlJPUjogaW5uZXJQYXRoIChcIitiK1wiKSBpcyBub3Qgd2l0aGluIG91dGVyUGF0aCAoXCIrYStcIilcIik7fVxuUy5wcm90b3R5cGUuYWE9ZnVuY3Rpb24oYSl7aWYoVGModGhpcykhPT1UYyhhKSlyZXR1cm4hMTtmb3IodmFyIGI9dGhpcy5kYSxjPWEuZGE7Yjw9dGhpcy53Lmxlbmd0aDtiKyssYysrKWlmKHRoaXMud1tiXSE9PWEud1tjXSlyZXR1cm4hMTtyZXR1cm4hMH07Uy5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5kYSxjPWEuZGE7aWYoVGModGhpcyk+VGMoYSkpcmV0dXJuITE7Zm9yKDtiPHRoaXMudy5sZW5ndGg7KXtpZih0aGlzLndbYl0hPT1hLndbY10pcmV0dXJuITE7KytiOysrY31yZXR1cm4hMH07ZnVuY3Rpb24gVmMoKXt0aGlzLmNoaWxkcmVuPXt9O3RoaXMuYmQ9MDt0aGlzLnZhbHVlPW51bGx9ZnVuY3Rpb24gV2MoYSxiLGMpe3RoaXMuemQ9YT9hOlwiXCI7dGhpcy5PYz1iP2I6bnVsbDt0aGlzLkE9Yz9jOm5ldyBWY31mdW5jdGlvbiBYYyhhLGIpe2Zvcih2YXIgYz1iIGluc3RhbmNlb2YgUz9iOm5ldyBTKGIpLGQ9YSxlO251bGwhPT0oZT1JKGMpKTspZD1uZXcgV2MoZSxkLHQoZC5BLmNoaWxkcmVuLGUpfHxuZXcgVmMpLGM9VChjKTtyZXR1cm4gZH1oPVdjLnByb3RvdHlwZTtoLnphPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQS52YWx1ZX07ZnVuY3Rpb24gWWMoYSxiKXt5KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYixcIkNhbm5vdCBzZXQgdmFsdWUgdG8gdW5kZWZpbmVkXCIpO2EuQS52YWx1ZT1iO1pjKGEpfWguY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLkEudmFsdWU9bnVsbDt0aGlzLkEuY2hpbGRyZW49e307dGhpcy5BLmJkPTA7WmModGhpcyl9O1xuaC5tZD1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuQS5iZH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnphKCkmJiF0aGlzLm1kKCl9O2guVT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO0EodGhpcy5BLmNoaWxkcmVuLGZ1bmN0aW9uKGMsZCl7YShuZXcgV2MoZCxiLGMpKX0pfTtmdW5jdGlvbiAkYyhhLGIsYyxkKXtjJiYhZCYmYihhKTthLlUoZnVuY3Rpb24oYSl7JGMoYSxiLCEwLGQpfSk7YyYmZCYmYihhKX1mdW5jdGlvbiBhZChhLGIpe2Zvcih2YXIgYz1hLnBhcmVudCgpO251bGwhPT1jJiYhYihjKTspYz1jLnBhcmVudCgpfWgucGF0aD1mdW5jdGlvbigpe3JldHVybiBuZXcgUyhudWxsPT09dGhpcy5PYz90aGlzLnpkOnRoaXMuT2MucGF0aCgpK1wiL1wiK3RoaXMuemQpfTtoLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy56ZH07aC5wYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5PY307XG5mdW5jdGlvbiBaYyhhKXtpZihudWxsIT09YS5PYyl7dmFyIGI9YS5PYyxjPWEuemQsZD1hLmUoKSxlPXMoYi5BLmNoaWxkcmVuLGMpO2QmJmU/KGRlbGV0ZSBiLkEuY2hpbGRyZW5bY10sYi5BLmJkLS0sWmMoYikpOmR8fGV8fChiLkEuY2hpbGRyZW5bY109YS5BLGIuQS5iZCsrLFpjKGIpKX19O2Z1bmN0aW9uIGJkKGEsYil7dGhpcy5KYT1hO3RoaXMudmE9Yj9iOmNkfWg9YmQucHJvdG90eXBlO2guTGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGJkKHRoaXMuSmEsdGhpcy52YS5MYShhLGIsdGhpcy5KYSkuWShudWxsLG51bGwsITEsbnVsbCxudWxsKSl9O2gucmVtb3ZlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYmQodGhpcy5KYSx0aGlzLnZhLnJlbW92ZShhLHRoaXMuSmEpLlkobnVsbCxudWxsLCExLG51bGwsbnVsbCkpfTtoLmdldD1mdW5jdGlvbihhKXtmb3IodmFyIGIsYz10aGlzLnZhOyFjLmUoKTspe2I9dGhpcy5KYShhLGMua2V5KTtpZigwPT09YilyZXR1cm4gYy52YWx1ZTswPmI/Yz1jLmxlZnQ6MDxiJiYoYz1jLnJpZ2h0KX1yZXR1cm4gbnVsbH07XG5mdW5jdGlvbiBkZChhLGIpe2Zvcih2YXIgYyxkPWEudmEsZT1udWxsOyFkLmUoKTspe2M9YS5KYShiLGQua2V5KTtpZigwPT09Yyl7aWYoZC5sZWZ0LmUoKSlyZXR1cm4gZT9lLmtleTpudWxsO2ZvcihkPWQubGVmdDshZC5yaWdodC5lKCk7KWQ9ZC5yaWdodDtyZXR1cm4gZC5rZXl9MD5jP2Q9ZC5sZWZ0OjA8YyYmKGU9ZCxkPWQucmlnaHQpfXRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/XCIpO31oLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YS5lKCl9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YS5jb3VudCgpfTtoLkljPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmEuSWMoKX07aC5ZYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhLlliKCl9O2guZmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudmEuZmEoYSl9O1xuaC5QYj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGVkKHRoaXMudmEsbnVsbCx0aGlzLkphLCExLGEpfTtoLlFiPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBlZCh0aGlzLnZhLGEsdGhpcy5KYSwhMSxiKX07aC5TYj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgZWQodGhpcy52YSxhLHRoaXMuSmEsITAsYil9O2guaGY9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBlZCh0aGlzLnZhLG51bGwsdGhpcy5KYSwhMCxhKX07ZnVuY3Rpb24gZWQoYSxiLGMsZCxlKXt0aGlzLk5kPWV8fG51bGw7dGhpcy56ZT1kO3RoaXMuTmE9W107Zm9yKGU9MTshYS5lKCk7KWlmKGU9Yj9jKGEua2V5LGIpOjEsZCYmKGUqPS0xKSwwPmUpYT10aGlzLnplP2EubGVmdDphLnJpZ2h0O2Vsc2UgaWYoMD09PWUpe3RoaXMuTmEucHVzaChhKTticmVha31lbHNlIHRoaXMuTmEucHVzaChhKSxhPXRoaXMuemU/YS5yaWdodDphLmxlZnR9XG5mdW5jdGlvbiBQKGEpe2lmKDA9PT1hLk5hLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgYj1hLk5hLnBvcCgpLGM7Yz1hLk5kP2EuTmQoYi5rZXksYi52YWx1ZSk6e2tleTpiLmtleSx2YWx1ZTpiLnZhbHVlfTtpZihhLnplKWZvcihiPWIubGVmdDshYi5lKCk7KWEuTmEucHVzaChiKSxiPWIucmlnaHQ7ZWxzZSBmb3IoYj1iLnJpZ2h0OyFiLmUoKTspYS5OYS5wdXNoKGIpLGI9Yi5sZWZ0O3JldHVybiBjfWZ1bmN0aW9uIGZkKGEpe2lmKDA9PT1hLk5hLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgYjtiPWEuTmE7Yj1iW2IubGVuZ3RoLTFdO3JldHVybiBhLk5kP2EuTmQoYi5rZXksYi52YWx1ZSk6e2tleTpiLmtleSx2YWx1ZTpiLnZhbHVlfX1mdW5jdGlvbiBnZChhLGIsYyxkLGUpe3RoaXMua2V5PWE7dGhpcy52YWx1ZT1iO3RoaXMuY29sb3I9bnVsbCE9Yz9jOiEwO3RoaXMubGVmdD1udWxsIT1kP2Q6Y2Q7dGhpcy5yaWdodD1udWxsIT1lP2U6Y2R9aD1nZC5wcm90b3R5cGU7XG5oLlk9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbmV3IGdkKG51bGwhPWE/YTp0aGlzLmtleSxudWxsIT1iP2I6dGhpcy52YWx1ZSxudWxsIT1jP2M6dGhpcy5jb2xvcixudWxsIT1kP2Q6dGhpcy5sZWZ0LG51bGwhPWU/ZTp0aGlzLnJpZ2h0KX07aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlZnQuY291bnQoKSsxK3RoaXMucmlnaHQuY291bnQoKX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guZmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubGVmdC5mYShhKXx8YSh0aGlzLmtleSx0aGlzLnZhbHVlKXx8dGhpcy5yaWdodC5mYShhKX07ZnVuY3Rpb24gaGQoYSl7cmV0dXJuIGEubGVmdC5lKCk/YTpoZChhLmxlZnQpfWguSWM9ZnVuY3Rpb24oKXtyZXR1cm4gaGQodGhpcykua2V5fTtoLlliPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHQuZSgpP3RoaXMua2V5OnRoaXMucmlnaHQuWWIoKX07XG5oLkxhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlO2U9dGhpcztkPWMoYSxlLmtleSk7ZT0wPmQ/ZS5ZKG51bGwsbnVsbCxudWxsLGUubGVmdC5MYShhLGIsYyksbnVsbCk6MD09PWQ/ZS5ZKG51bGwsYixudWxsLG51bGwsbnVsbCk6ZS5ZKG51bGwsbnVsbCxudWxsLG51bGwsZS5yaWdodC5MYShhLGIsYykpO3JldHVybiBpZChlKX07ZnVuY3Rpb24gamQoYSl7aWYoYS5sZWZ0LmUoKSlyZXR1cm4gY2Q7YS5sZWZ0LmNhKCl8fGEubGVmdC5sZWZ0LmNhKCl8fChhPWtkKGEpKTthPWEuWShudWxsLG51bGwsbnVsbCxqZChhLmxlZnQpLG51bGwpO3JldHVybiBpZChhKX1cbmgucmVtb3ZlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtjPXRoaXM7aWYoMD5iKGEsYy5rZXkpKWMubGVmdC5lKCl8fGMubGVmdC5jYSgpfHxjLmxlZnQubGVmdC5jYSgpfHwoYz1rZChjKSksYz1jLlkobnVsbCxudWxsLG51bGwsYy5sZWZ0LnJlbW92ZShhLGIpLG51bGwpO2Vsc2V7Yy5sZWZ0LmNhKCkmJihjPW1kKGMpKTtjLnJpZ2h0LmUoKXx8Yy5yaWdodC5jYSgpfHxjLnJpZ2h0LmxlZnQuY2EoKXx8KGM9bmQoYyksYy5sZWZ0LmxlZnQuY2EoKSYmKGM9bWQoYyksYz1uZChjKSkpO2lmKDA9PT1iKGEsYy5rZXkpKXtpZihjLnJpZ2h0LmUoKSlyZXR1cm4gY2Q7ZD1oZChjLnJpZ2h0KTtjPWMuWShkLmtleSxkLnZhbHVlLG51bGwsbnVsbCxqZChjLnJpZ2h0KSl9Yz1jLlkobnVsbCxudWxsLG51bGwsbnVsbCxjLnJpZ2h0LnJlbW92ZShhLGIpKX1yZXR1cm4gaWQoYyl9O2guY2E9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb2xvcn07XG5mdW5jdGlvbiBpZChhKXthLnJpZ2h0LmNhKCkmJiFhLmxlZnQuY2EoKSYmKGE9b2QoYSkpO2EubGVmdC5jYSgpJiZhLmxlZnQubGVmdC5jYSgpJiYoYT1tZChhKSk7YS5sZWZ0LmNhKCkmJmEucmlnaHQuY2EoKSYmKGE9bmQoYSkpO3JldHVybiBhfWZ1bmN0aW9uIGtkKGEpe2E9bmQoYSk7YS5yaWdodC5sZWZ0LmNhKCkmJihhPWEuWShudWxsLG51bGwsbnVsbCxudWxsLG1kKGEucmlnaHQpKSxhPW9kKGEpLGE9bmQoYSkpO3JldHVybiBhfWZ1bmN0aW9uIG9kKGEpe3JldHVybiBhLnJpZ2h0LlkobnVsbCxudWxsLGEuY29sb3IsYS5ZKG51bGwsbnVsbCwhMCxudWxsLGEucmlnaHQubGVmdCksbnVsbCl9ZnVuY3Rpb24gbWQoYSl7cmV0dXJuIGEubGVmdC5ZKG51bGwsbnVsbCxhLmNvbG9yLG51bGwsYS5ZKG51bGwsbnVsbCwhMCxhLmxlZnQucmlnaHQsbnVsbCkpfVxuZnVuY3Rpb24gbmQoYSl7cmV0dXJuIGEuWShudWxsLG51bGwsIWEuY29sb3IsYS5sZWZ0LlkobnVsbCxudWxsLCFhLmxlZnQuY29sb3IsbnVsbCxudWxsKSxhLnJpZ2h0LlkobnVsbCxudWxsLCFhLnJpZ2h0LmNvbG9yLG51bGwsbnVsbCkpfWZ1bmN0aW9uIHBkKCl7fWg9cGQucHJvdG90eXBlO2guWT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtoLkxhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBnZChhLGIsbnVsbCl9O2gucmVtb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guZmE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5JYz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtoLlliPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O2guY2E9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIGNkPW5ldyBwZDtmdW5jdGlvbiBxZChhLGIpe3RoaXMuRj1hO3kobSh0aGlzLkYpJiZudWxsIT09dGhpcy5GLFwiTGVhZk5vZGUgc2hvdWxkbid0IGJlIGNyZWF0ZWQgd2l0aCBudWxsL3VuZGVmaW5lZCB2YWx1ZS5cIik7dGhpcy5oYT1ifHxNO3JkKHRoaXMuaGEpO3RoaXMudGI9bnVsbH1oPXFkLnByb3RvdHlwZTtoLk09ZnVuY3Rpb24oKXtyZXR1cm4hMH07aC5MPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGF9O2guJD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IHFkKHRoaXMuRixhKX07aC5LPWZ1bmN0aW9uKGEpe3JldHVyblwiLnByaW9yaXR5XCI9PT1hP3RoaXMuaGE6TX07aC5yYT1mdW5jdGlvbihhKXtyZXR1cm4gYS5lKCk/dGhpczpcIi5wcmlvcml0eVwiPT09SShhKT90aGlzLmhhOk19O2guRGE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5nZj1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcbmguUD1mdW5jdGlvbihhLGIpe3JldHVyblwiLnByaW9yaXR5XCI9PT1hP3RoaXMuJChiKTpiLmUoKSYmXCIucHJpb3JpdHlcIiE9PWE/dGhpczpNLlAoYSxiKS4kKHRoaXMuaGEpfTtoLkQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1JKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGIuZSgpJiZcIi5wcmlvcml0eVwiIT09YylyZXR1cm4gdGhpczt5KFwiLnByaW9yaXR5XCIhPT1jfHwxPT09VGMoYSksXCIucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGhcIik7cmV0dXJuIHRoaXMuUChjLE0uRChUKGEpLGIpKX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2gudmI9ZnVuY3Rpb24oKXtyZXR1cm4gMH07aC5JPWZ1bmN0aW9uKGEpe3JldHVybiBhJiYhdGhpcy5MKCkuZSgpP3tcIi52YWx1ZVwiOnRoaXMuemEoKSxcIi5wcmlvcml0eVwiOnRoaXMuTCgpLkkoKX06dGhpcy56YSgpfTtcbmguaGFzaD1mdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLnRiKXt2YXIgYT1cIlwiO3RoaXMuaGEuZSgpfHwoYSs9XCJwcmlvcml0eTpcIitzZCh0aGlzLmhhLkkoKSkrXCI6XCIpO3ZhciBiPXR5cGVvZiB0aGlzLkYsYT1hKyhiK1wiOlwiKSxhPVwibnVtYmVyXCI9PT1iP2ErQWIodGhpcy5GKTphK3RoaXMuRjt0aGlzLnRiPWliKGEpfXJldHVybiB0aGlzLnRifTtoLnphPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRn07aC5kZD1mdW5jdGlvbihhKXtpZihhPT09TSlyZXR1cm4gMTtpZihhIGluc3RhbmNlb2YgVylyZXR1cm4tMTt5KGEuTSgpLFwiVW5rbm93biBub2RlIHR5cGVcIik7dmFyIGI9dHlwZW9mIGEuRixjPXR5cGVvZiB0aGlzLkYsZD1HYSh0ZCxiKSxlPUdhKHRkLGMpO3koMDw9ZCxcIlVua25vd24gbGVhZiB0eXBlOiBcIitiKTt5KDA8PWUsXCJVbmtub3duIGxlYWYgdHlwZTogXCIrYyk7cmV0dXJuIGQ9PT1lP1wib2JqZWN0XCI9PT1jPzA6dGhpcy5GPGEuRj8tMTp0aGlzLkY9PT1hLkY/MDoxOmUtZH07XG52YXIgdGQ9W1wib2JqZWN0XCIsXCJib29sZWFuXCIsXCJudW1iZXJcIixcInN0cmluZ1wiXTtxZC5wcm90b3R5cGUuaGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307cWQucHJvdG90eXBlLkJjPWZ1bmN0aW9uKCl7cmV0dXJuITB9O3FkLnByb3RvdHlwZS5hYT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/ITA6YS5NKCk/dGhpcy5GPT09YS5GJiZ0aGlzLmhhLmFhKGEuaGEpOiExfTtxZC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLkkoITApKX07ZnVuY3Rpb24gdWQoYSxiKXt0aGlzLnFkPWE7dGhpcy5XYj1ifXVkLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9dCh0aGlzLnFkLGEpO2lmKCFiKXRocm93IEVycm9yKFwiTm8gaW5kZXggZGVmaW5lZCBmb3IgXCIrYSk7cmV0dXJuIGI9PT1sYz9udWxsOmJ9O2Z1bmN0aW9uIHZkKGEsYixjKXt2YXIgZD13ZChhLnFkLGZ1bmN0aW9uKGQsZil7dmFyIGc9dChhLldiLGYpO3koZyxcIk1pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yIFwiK2YpO2lmKGQ9PT1sYyl7aWYoZy5zZChiLlYpKXtmb3IodmFyIGs9W10sbD1jLlBiKENjKSxuPVAobCk7bjspbi5uYW1lIT1iLm5hbWUmJmsucHVzaChuKSxuPVAobCk7ay5wdXNoKGIpO3JldHVybiB4ZChrLG1jKGcpKX1yZXR1cm4gbGN9Zz1jLmdldChiLm5hbWUpO2s9ZDtnJiYoaz1rLnJlbW92ZShuZXcgTihiLm5hbWUsZykpKTtyZXR1cm4gay5MYShiLGIuVil9KTtyZXR1cm4gbmV3IHVkKGQsYS5XYil9XG5mdW5jdGlvbiB5ZChhLGIsYyl7dmFyIGQ9d2QoYS5xZCxmdW5jdGlvbihhKXtpZihhPT09bGMpcmV0dXJuIGE7dmFyIGQ9Yy5nZXQoYi5uYW1lKTtyZXR1cm4gZD9hLnJlbW92ZShuZXcgTihiLm5hbWUsZCkpOmF9KTtyZXR1cm4gbmV3IHVkKGQsYS5XYil9dmFyIHpkPW5ldyB1ZCh7XCIucHJpb3JpdHlcIjpsY30se1wiLnByaW9yaXR5XCI6TH0pO2Z1bmN0aW9uIFcoYSxiLGMpe3RoaXMubT1hOyh0aGlzLmhhPWIpJiZyZCh0aGlzLmhhKTt0aGlzLnBiPWM7dGhpcy50Yj1udWxsfWg9Vy5wcm90b3R5cGU7aC5NPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guTD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhhfHxNfTtoLiQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBXKHRoaXMubSxhLHRoaXMucGIpfTtoLks9ZnVuY3Rpb24oYSl7aWYoXCIucHJpb3JpdHlcIj09PWEpcmV0dXJuIHRoaXMuTCgpO2E9dGhpcy5tLmdldChhKTtyZXR1cm4gbnVsbD09PWE/TTphfTtoLnJhPWZ1bmN0aW9uKGEpe3ZhciBiPUkoYSk7cmV0dXJuIG51bGw9PT1iP3RoaXM6dGhpcy5LKGIpLnJhKFQoYSkpfTtoLkRhPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09dGhpcy5tLmdldChhKX07XG5oLlA9ZnVuY3Rpb24oYSxiKXt5KGIsXCJXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXNcIik7aWYoXCIucHJpb3JpdHlcIj09PWEpcmV0dXJuIHRoaXMuJChiKTt2YXIgYz1uZXcgTihhLGIpLGQ7Yi5lKCk/KGQ9dGhpcy5tLnJlbW92ZShhKSxjPXlkKHRoaXMucGIsYyx0aGlzLm0pKTooZD10aGlzLm0uTGEoYSxiKSxjPXZkKHRoaXMucGIsYyx0aGlzLm0pKTtyZXR1cm4gbmV3IFcoZCx0aGlzLmhhLGMpfTtoLkQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1JKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO3koXCIucHJpb3JpdHlcIiE9PUkoYSl8fDE9PT1UYyhhKSxcIi5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aFwiKTt2YXIgZD10aGlzLksoYykuRChUKGEpLGIpO3JldHVybiB0aGlzLlAoYyxkKX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubS5lKCl9O2gudmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tLmNvdW50KCl9O3ZhciBBZD0vXigwfFsxLTldXFxkKikkLztcbmg9Vy5wcm90b3R5cGU7aC5JPWZ1bmN0aW9uKGEpe2lmKHRoaXMuZSgpKXJldHVybiBudWxsO3ZhciBiPXt9LGM9MCxkPTAsZT0hMDt0aGlzLlUoTCxmdW5jdGlvbihmLGcpe2JbZl09Zy5JKGEpO2MrKztlJiZBZC50ZXN0KGYpP2Q9TWF0aC5tYXgoZCxOdW1iZXIoZikpOmU9ITF9KTtpZighYSYmZSYmZDwyKmMpe3ZhciBmPVtdLGc7Zm9yKGcgaW4gYilmW2ddPWJbZ107cmV0dXJuIGZ9YSYmIXRoaXMuTCgpLmUoKSYmKGJbXCIucHJpb3JpdHlcIl09dGhpcy5MKCkuSSgpKTtyZXR1cm4gYn07aC5oYXNoPWZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMudGIpe3ZhciBhPVwiXCI7dGhpcy5MKCkuZSgpfHwoYSs9XCJwcmlvcml0eTpcIitzZCh0aGlzLkwoKS5JKCkpK1wiOlwiKTt0aGlzLlUoTCxmdW5jdGlvbihiLGMpe3ZhciBkPWMuaGFzaCgpO1wiXCIhPT1kJiYoYSs9XCI6XCIrYitcIjpcIitkKX0pO3RoaXMudGI9XCJcIj09PWE/XCJcIjppYihhKX1yZXR1cm4gdGhpcy50Yn07XG5oLmdmPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4oYz1CZCh0aGlzLGMpKT8oYT1kZChjLG5ldyBOKGEsYikpKT9hLm5hbWU6bnVsbDpkZCh0aGlzLm0sYSl9O2Z1bmN0aW9uIEZjKGEsYil7dmFyIGM7Yz0oYz1CZChhLGIpKT8oYz1jLkljKCkpJiZjLm5hbWU6YS5tLkljKCk7cmV0dXJuIGM/bmV3IE4oYyxhLm0uZ2V0KGMpKTpudWxsfWZ1bmN0aW9uIEdjKGEsYil7dmFyIGM7Yz0oYz1CZChhLGIpKT8oYz1jLlliKCkpJiZjLm5hbWU6YS5tLlliKCk7cmV0dXJuIGM/bmV3IE4oYyxhLm0uZ2V0KGMpKTpudWxsfWguVT1mdW5jdGlvbihhLGIpe3ZhciBjPUJkKHRoaXMsYSk7cmV0dXJuIGM/Yy5mYShmdW5jdGlvbihhKXtyZXR1cm4gYihhLm5hbWUsYS5WKX0pOnRoaXMubS5mYShiKX07aC5QYj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5RYihhLnlkKCksYSl9O1xuaC5RYj1mdW5jdGlvbihhLGIpe3ZhciBjPUJkKHRoaXMsYik7aWYoYylyZXR1cm4gYy5RYihhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk7Zm9yKHZhciBjPXRoaXMubS5RYihhLm5hbWUsQ2MpLGQ9ZmQoYyk7bnVsbCE9ZCYmMD5iLmNvbXBhcmUoZCxhKTspUChjKSxkPWZkKGMpO3JldHVybiBjfTtoLmhmPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlNiKGEud2QoKSxhKX07aC5TYj1mdW5jdGlvbihhLGIpe3ZhciBjPUJkKHRoaXMsYik7aWYoYylyZXR1cm4gYy5TYihhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk7Zm9yKHZhciBjPXRoaXMubS5TYihhLm5hbWUsQ2MpLGQ9ZmQoYyk7bnVsbCE9ZCYmMDxiLmNvbXBhcmUoZCxhKTspUChjKSxkPWZkKGMpO3JldHVybiBjfTtoLmRkPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmUoKT9hLmUoKT8wOi0xOmEuTSgpfHxhLmUoKT8xOmE9PT1wYz8tMTowfTtcbmguaGI9ZnVuY3Rpb24oYSl7aWYoYT09PXJjfHxDZCh0aGlzLnBiLldiLGEudG9TdHJpbmcoKSkpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy5wYixjPXRoaXMubTt5KGEhPT1yYyxcIktleUluZGV4IGFsd2F5cyBleGlzdHMgYW5kIGlzbid0IG1lYW50IHRvIGJlIGFkZGVkIHRvIHRoZSBJbmRleE1hcC5cIik7Zm9yKHZhciBkPVtdLGU9ITEsYz1jLlBiKENjKSxmPVAoYyk7ZjspZT1lfHxhLnNkKGYuViksZC5wdXNoKGYpLGY9UChjKTtkPWU/eGQoZCxtYyhhKSk6bGM7ZT1hLnRvU3RyaW5nKCk7Yz1EZChiLldiKTtjW2VdPWE7YT1EZChiLnFkKTthW2VdPWQ7cmV0dXJuIG5ldyBXKHRoaXMubSx0aGlzLmhhLG5ldyB1ZChhLGMpKX07aC5CYz1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXJjfHxDZCh0aGlzLnBiLldiLGEudG9TdHJpbmcoKSl9O1xuaC5hYT1mdW5jdGlvbihhKXtpZihhPT09dGhpcylyZXR1cm4hMDtpZihhLk0oKSlyZXR1cm4hMTtpZih0aGlzLkwoKS5hYShhLkwoKSkmJnRoaXMubS5jb3VudCgpPT09YS5tLmNvdW50KCkpe3ZhciBiPXRoaXMuUGIoTCk7YT1hLlBiKEwpO2Zvcih2YXIgYz1QKGIpLGQ9UChhKTtjJiZkOyl7aWYoYy5uYW1lIT09ZC5uYW1lfHwhYy5WLmFhKGQuVikpcmV0dXJuITE7Yz1QKGIpO2Q9UChhKX1yZXR1cm4gbnVsbD09PWMmJm51bGw9PT1kfXJldHVybiExfTtmdW5jdGlvbiBCZChhLGIpe3JldHVybiBiPT09cmM/bnVsbDphLnBiLmdldChiLnRvU3RyaW5nKCkpfWgudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLkkoITApKX07ZnVuY3Rpb24gTyhhLGIpe2lmKG51bGw9PT1hKXJldHVybiBNO3ZhciBjPW51bGw7XCJvYmplY3RcIj09PXR5cGVvZiBhJiZcIi5wcmlvcml0eVwiaW4gYT9jPWFbXCIucHJpb3JpdHlcIl06XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiJiYoYz1iKTt5KG51bGw9PT1jfHxcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgY3x8XCJvYmplY3RcIj09PXR5cGVvZiBjJiZcIi5zdlwiaW4gYyxcIkludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogXCIrdHlwZW9mIGMpO1wib2JqZWN0XCI9PT10eXBlb2YgYSYmXCIudmFsdWVcImluIGEmJm51bGwhPT1hW1wiLnZhbHVlXCJdJiYoYT1hW1wiLnZhbHVlXCJdKTtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fFwiLnN2XCJpbiBhKXJldHVybiBuZXcgcWQoYSxPKGMpKTtpZihhIGluc3RhbmNlb2YgQXJyYXkpe3ZhciBkPU0sZT1hO0EoZSxmdW5jdGlvbihhLGIpe2lmKHMoZSxiKSYmXCIuXCIhPT1iLnN1YnN0cmluZygwLDEpKXt2YXIgYz1PKGEpO2lmKGMuTSgpfHwhYy5lKCkpZD1cbmQuUChiLGMpfX0pO3JldHVybiBkLiQoTyhjKSl9dmFyIGY9W10sZz0hMSxrPWE7dWEoayxmdW5jdGlvbihhKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGF8fFwiLlwiIT09YS5zdWJzdHJpbmcoMCwxKSl7dmFyIGI9TyhrW2FdKTtiLmUoKXx8KGc9Z3x8IWIuTCgpLmUoKSxmLnB1c2gobmV3IE4oYSxiKSkpfX0pO3ZhciBsPXhkKGYsaWMsZnVuY3Rpb24oYSl7cmV0dXJuIGEubmFtZX0samMpO2lmKGcpe3ZhciBuPXhkKGYsbWMoTCkpO3JldHVybiBuZXcgVyhsLE8oYyksbmV3IHVkKHtcIi5wcmlvcml0eVwiOm59LHtcIi5wcmlvcml0eVwiOkx9KSl9cmV0dXJuIG5ldyBXKGwsTyhjKSx6ZCl9dmFyIEVkPU1hdGgubG9nKDIpO2Z1bmN0aW9uIEZkKGEpe3RoaXMuY291bnQ9cGFyc2VJbnQoTWF0aC5sb2coYSsxKS9FZCwxMCk7dGhpcy5hZj10aGlzLmNvdW50LTE7dGhpcy5OZj1hKzEmcGFyc2VJbnQoQXJyYXkodGhpcy5jb3VudCsxKS5qb2luKFwiMVwiKSwyKX1cbmZ1bmN0aW9uIEdkKGEpe3ZhciBiPSEoYS5OZiYxPDxhLmFmKTthLmFmLS07cmV0dXJuIGJ9XG5mdW5jdGlvbiB4ZChhLGIsYyxkKXtmdW5jdGlvbiBlKGIsZCl7dmFyIGY9ZC1iO2lmKDA9PWYpcmV0dXJuIG51bGw7aWYoMT09Zil7dmFyIG49YVtiXSx1PWM/YyhuKTpuO3JldHVybiBuZXcgZ2QodSxuLlYsITEsbnVsbCxudWxsKX12YXIgbj1wYXJzZUludChmLzIsMTApK2IsZj1lKGIsbikseD1lKG4rMSxkKSxuPWFbbl0sdT1jP2Mobik6bjtyZXR1cm4gbmV3IGdkKHUsbi5WLCExLGYseCl9YS5zb3J0KGIpO3ZhciBmPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGQoYixnKXt2YXIgaz11LWIseD11O3UtPWI7dmFyIHg9ZShrKzEseCksaz1hW2tdLEY9Yz9jKGspOmsseD1uZXcgZ2QoRixrLlYsZyxudWxsLHgpO2Y/Zi5sZWZ0PXg6bj14O2Y9eH1mb3IodmFyIGY9bnVsbCxuPW51bGwsdT1hLmxlbmd0aCx4PTA7eDxiLmNvdW50OysreCl7dmFyIEY9R2QoYiksbGQ9TWF0aC5wb3coMixiLmNvdW50LSh4KzEpKTtGP2QobGQsITEpOihkKGxkLCExKSxkKGxkLCEwKSl9cmV0dXJuIG59KG5ldyBGZChhLmxlbmd0aCkpO1xucmV0dXJuIG51bGwhPT1mP25ldyBiZChkfHxiLGYpOm5ldyBiZChkfHxiKX1mdW5jdGlvbiBzZChhKXtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGE/XCJudW1iZXI6XCIrQWIoYSk6XCJzdHJpbmc6XCIrYX1mdW5jdGlvbiByZChhKXtpZihhLk0oKSl7dmFyIGI9YS5JKCk7eShcInN0cmluZ1wiPT09dHlwZW9mIGJ8fFwibnVtYmVyXCI9PT10eXBlb2YgYnx8XCJvYmplY3RcIj09PXR5cGVvZiBiJiZzKGIsXCIuc3ZcIiksXCJQcmlvcml0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci5cIil9ZWxzZSB5KGE9PT1wY3x8YS5lKCksXCJwcmlvcml0eSBvZiB1bmV4cGVjdGVkIHR5cGUuXCIpO3koYT09PXBjfHxhLkwoKS5lKCksXCJQcmlvcml0eSBub2RlcyBjYW4ndCBoYXZlIGEgcHJpb3JpdHkgb2YgdGhlaXIgb3duLlwiKX12YXIgTT1uZXcgVyhuZXcgYmQoamMpLG51bGwsemQpO2Z1bmN0aW9uIEhkKCl7Vy5jYWxsKHRoaXMsbmV3IGJkKGpjKSxNLHpkKX1tYShIZCxXKTtoPUhkLnByb3RvdHlwZTtcbmguZGQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT10aGlzPzA6MX07aC5hYT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXN9O2guTD1mdW5jdGlvbigpe3Rocm93IGZiKFwiV2h5IGlzIHRoaXMgY2FsbGVkP1wiKTt9O2guSz1mdW5jdGlvbigpe3JldHVybiBNfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIHBjPW5ldyBIZCxuYz1uZXcgTihcIltNSU5fTkFNRV1cIixNKSx0Yz1uZXcgTihcIltNQVhfTkFNRV1cIixwYyk7ZnVuY3Rpb24gRChhLGIsYyl7dGhpcy5BPWE7dGhpcy5XPWI7dGhpcy5nPWN9RC5wcm90b3R5cGUuST1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QudmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSSgpfTtELnByb3RvdHlwZS52YWw9RC5wcm90b3R5cGUuSTtELnByb3RvdHlwZS5jZj1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhwb3J0VmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSSghMCl9O0QucHJvdG90eXBlLmV4cG9ydFZhbD1ELnByb3RvdHlwZS5jZjtELnByb3RvdHlwZS5XZj1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhpc3RzXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiF0aGlzLkEuZSgpfTtELnByb3RvdHlwZS5leGlzdHM9RC5wcm90b3R5cGUuV2Y7XG5ELnByb3RvdHlwZS51PWZ1bmN0aW9uKGEpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7Z2EoYSkmJihhPVN0cmluZyhhKSk7WWIoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIixhKTt2YXIgYj1uZXcgUyhhKSxjPXRoaXMuVy51KGIpO3JldHVybiBuZXcgRCh0aGlzLkEucmEoYiksYyxMKX07RC5wcm90b3R5cGUuY2hpbGQ9RC5wcm90b3R5cGUudTtELnByb3RvdHlwZS5EYT1mdW5jdGlvbihhKXtFKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO1liKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkXCIsYSk7dmFyIGI9bmV3IFMoYSk7cmV0dXJuIXRoaXMuQS5yYShiKS5lKCl9O0QucHJvdG90eXBlLmhhc0NoaWxkPUQucHJvdG90eXBlLkRhO1xuRC5wcm90b3R5cGUuTD1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZ2V0UHJpb3JpdHlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS5MKCkuSSgpfTtELnByb3RvdHlwZS5nZXRQcmlvcml0eT1ELnByb3RvdHlwZS5MO0QucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5mb3JFYWNoXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZm9yRWFjaFwiLDEsYSwhMSk7aWYodGhpcy5BLk0oKSlyZXR1cm4hMTt2YXIgYj10aGlzO3JldHVybiEhdGhpcy5BLlUodGhpcy5nLGZ1bmN0aW9uKGMsZCl7cmV0dXJuIGEobmV3IEQoZCxiLlcudShjKSxMKSl9KX07RC5wcm90b3R5cGUuZm9yRWFjaD1ELnByb3RvdHlwZS5mb3JFYWNoO1xuRC5wcm90b3R5cGUubWQ9ZnVuY3Rpb24oKXtFKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkcmVuXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuTSgpPyExOiF0aGlzLkEuZSgpfTtELnByb3RvdHlwZS5oYXNDaGlsZHJlbj1ELnByb3RvdHlwZS5tZDtELnByb3RvdHlwZS5uYW1lPWZ1bmN0aW9uKCl7eihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5uYW1lKCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGaXJlYmFzZS5EYXRhU25hcHNob3Qua2V5KCkgaW5zdGVhZC5cIik7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5uYW1lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLmtleSgpfTtELnByb3RvdHlwZS5uYW1lPUQucHJvdG90eXBlLm5hbWU7RC5wcm90b3R5cGUua2V5PWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuVy5rZXkoKX07XG5ELnByb3RvdHlwZS5rZXk9RC5wcm90b3R5cGUua2V5O0QucHJvdG90eXBlLnZiPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5udW1DaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLnZiKCl9O0QucHJvdG90eXBlLm51bUNoaWxkcmVuPUQucHJvdG90eXBlLnZiO0QucHJvdG90eXBlLmRjPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5yZWZcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuV307RC5wcm90b3R5cGUucmVmPUQucHJvdG90eXBlLmRjO2Z1bmN0aW9uIElkKGEpe3koZWEoYSkmJjA8YS5sZW5ndGgsXCJSZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheVwiKTt0aGlzLkZmPWE7dGhpcy5HYz17fX1JZC5wcm90b3R5cGUuJGQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5HY1thXXx8W10sZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ucmMuYXBwbHkoY1tkXS5LYSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpfTtJZC5wcm90b3R5cGUud2I9ZnVuY3Rpb24oYSxiLGMpe0pkKHRoaXMsYSk7dGhpcy5HY1thXT10aGlzLkdjW2FdfHxbXTt0aGlzLkdjW2FdLnB1c2goe3JjOmIsS2E6Y30pOyhhPXRoaXMudWUoYSkpJiZiLmFwcGx5KGMsYSl9O0lkLnByb3RvdHlwZS4kYj1mdW5jdGlvbihhLGIsYyl7SmQodGhpcyxhKTthPXRoaXMuR2NbYV18fFtdO2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWlmKGFbZF0ucmM9PT1iJiYoIWN8fGM9PT1hW2RdLkthKSl7YS5zcGxpY2UoZCwxKTticmVha319O1xuZnVuY3Rpb24gSmQoYSxiKXt5KE1hKGEuRmYsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1ifSksXCJVbmtub3duIGV2ZW50OiBcIitiKX07ZnVuY3Rpb24gS2QoKXtJZC5jYWxsKHRoaXMsW1widmlzaWJsZVwiXSk7dmFyIGEsYjtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXImJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmhpZGRlbj8oYj1cInZpc2liaWxpdHljaGFuZ2VcIixhPVwiaGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhiPVwibW96dmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtb3pIaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbj8oYj1cIm1zdmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtc0hpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiYmKGI9XCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cIndlYmtpdEhpZGRlblwiKSk7dGhpcy5uYz0hMDtpZihiKXt2YXIgYz10aGlzO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYixcbmZ1bmN0aW9uKCl7dmFyIGI9IWRvY3VtZW50W2FdO2IhPT1jLm5jJiYoYy5uYz1iLGMuJGQoXCJ2aXNpYmxlXCIsYikpfSwhMSl9fW1hKEtkLElkKTtjYShLZCk7S2QucHJvdG90eXBlLnVlPWZ1bmN0aW9uKGEpe3koXCJ2aXNpYmxlXCI9PT1hLFwiVW5rbm93biBldmVudCB0eXBlOiBcIithKTtyZXR1cm5bdGhpcy5uY119O2Z1bmN0aW9uIEEoYSxiKXtmb3IodmFyIGMgaW4gYSliLmNhbGwodm9pZCAwLGFbY10sYyxhKX1mdW5jdGlvbiB3ZChhLGIpe3ZhciBjPXt9LGQ7Zm9yKGQgaW4gYSljW2RdPWIuY2FsbCh2b2lkIDAsYVtkXSxkLGEpO3JldHVybiBjfWZ1bmN0aW9uIExiKGEsYil7Zm9yKHZhciBjIGluIGEpaWYoIWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEpiKGEpe3ZhciBiPTAsYztmb3IoYyBpbiBhKWIrKztyZXR1cm4gYn1mdW5jdGlvbiBLYihhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4gYn1mdW5jdGlvbiBMZChhKXt2YXIgYj1bXSxjPTAsZDtmb3IoZCBpbiBhKWJbYysrXT1hW2RdO3JldHVybiBifWZ1bmN0aW9uIE1kKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWQ7cmV0dXJuIGJ9ZnVuY3Rpb24gQ2QoYSxiKXtmb3IodmFyIGMgaW4gYSlpZihhW2NdPT1iKXJldHVybiEwO3JldHVybiExfVxuZnVuY3Rpb24gTmQoYSxiLGMpe2Zvcih2YXIgZCBpbiBhKWlmKGIuY2FsbChjLGFbZF0sZCxhKSlyZXR1cm4gZH1mdW5jdGlvbiBPZChhLGIpe3ZhciBjPU5kKGEsYix2b2lkIDApO3JldHVybiBjJiZhW2NdfWZ1bmN0aW9uIFBkKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIFFkKGEsYil7cmV0dXJuIGIgaW4gYT9hW2JdOnZvaWQgMH1mdW5jdGlvbiBEZChhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYltjXT1hW2NdO3JldHVybiBifXZhciBSZD1cImNvbnN0cnVjdG9yIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGUgdG9Mb2NhbGVTdHJpbmcgdG9TdHJpbmcgdmFsdWVPZlwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIFNkKGEsYil7Zm9yKHZhciBjLGQsZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe2Q9YXJndW1lbnRzW2VdO2ZvcihjIGluIGQpYVtjXT1kW2NdO2Zvcih2YXIgZj0wO2Y8UmQubGVuZ3RoO2YrKyljPVJkW2ZdLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLGMpJiYoYVtjXT1kW2NdKX19O2Z1bmN0aW9uIFRkKCl7dGhpcy51Yz17fX1mdW5jdGlvbiBVZChhLGIsYyl7bShjKXx8KGM9MSk7cyhhLnVjLGIpfHwoYS51Y1tiXT0wKTthLnVjW2JdKz1jfVRkLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gRGQodGhpcy51Yyl9O2Z1bmN0aW9uIFZkKGEpe3RoaXMuUGY9YTt0aGlzLnRkPW51bGx9VmQucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuUGYuZ2V0KCksYj1EZChhKTtpZih0aGlzLnRkKWZvcih2YXIgYyBpbiB0aGlzLnRkKWJbY10tPXRoaXMudGRbY107dGhpcy50ZD1hO3JldHVybiBifTtmdW5jdGlvbiBXZChhLGIpe3RoaXMuemY9e307dGhpcy5VZD1uZXcgVmQoYSk7dGhpcy5TPWI7dmFyIGM9MUU0KzJFNCpNYXRoLnJhbmRvbSgpO3NldFRpbWVvdXQocSh0aGlzLnRmLHRoaXMpLE1hdGguZmxvb3IoYykpfVdkLnByb3RvdHlwZS50Zj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuVWQuZ2V0KCksYj17fSxjPSExLGQ7Zm9yKGQgaW4gYSkwPGFbZF0mJnModGhpcy56ZixkKSYmKGJbZF09YVtkXSxjPSEwKTtjJiYoYT10aGlzLlMsYS5qYSYmKGI9e2M6Yn0sYS5mKFwicmVwb3J0U3RhdHNcIixiKSxhLkJhKFwic1wiLGIpKSk7c2V0VGltZW91dChxKHRoaXMudGYsdGhpcyksTWF0aC5mbG9vcig2RTUqTWF0aC5yYW5kb20oKSkpfTt2YXIgWGQ9e30sWWQ9e307ZnVuY3Rpb24gWmQoYSl7YT1hLnRvU3RyaW5nKCk7WGRbYV18fChYZFthXT1uZXcgVGQpO3JldHVybiBYZFthXX1mdW5jdGlvbiAkZChhLGIpe3ZhciBjPWEudG9TdHJpbmcoKTtZZFtjXXx8KFlkW2NdPWIoKSk7cmV0dXJuIFlkW2NdfTt2YXIgYWU9bnVsbDtcInVuZGVmaW5lZFwiIT09dHlwZW9mIE1veldlYlNvY2tldD9hZT1Nb3pXZWJTb2NrZXQ6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBXZWJTb2NrZXQmJihhZT1XZWJTb2NrZXQpO2Z1bmN0aW9uIGJlKGEsYixjKXt0aGlzLm1lPWE7dGhpcy5mPW9iKHRoaXMubWUpO3RoaXMuZnJhbWVzPXRoaXMuQ2M9bnVsbDt0aGlzLmpiPXRoaXMua2I9dGhpcy5VZT0wO3RoaXMuUmE9WmQoYik7dGhpcy4kYT0oYi5CYj9cIndzczovL1wiOlwid3M6Ly9cIikrYi5NYStcIi8ud3M/dj01XCI7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsb2NhdGlvbiYmbG9jYXRpb24uaHJlZiYmLTEhPT1sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJmaXJlYmFzZWlvLmNvbVwiKSYmKHRoaXMuJGErPVwiJnI9ZlwiKTtiLmhvc3QhPT1iLk1hJiYodGhpcy4kYT10aGlzLiRhK1wiJm5zPVwiK2IudWIpO2MmJih0aGlzLiRhPXRoaXMuJGErXCImcz1cIitjKX12YXIgY2U7XG5iZS5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIpe3RoaXMuZmI9Yjt0aGlzLmhnPWE7dGhpcy5mKFwiV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gXCIrdGhpcy4kYSk7dGhpcy55Yz0hMTt6YS5zZXQoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiLCEwKTt0cnl7dGhpcy51YT1uZXcgYWUodGhpcy4kYSl9Y2F0Y2goYyl7dGhpcy5mKFwiRXJyb3IgaW5zdGFudGlhdGluZyBXZWJTb2NrZXQuXCIpO3ZhciBkPWMubWVzc2FnZXx8Yy5kYXRhO2QmJnRoaXMuZihkKTt0aGlzLmViKCk7cmV0dXJufXZhciBlPXRoaXM7dGhpcy51YS5vbm9wZW49ZnVuY3Rpb24oKXtlLmYoXCJXZWJzb2NrZXQgY29ubmVjdGVkLlwiKTtlLnljPSEwfTt0aGlzLnVhLm9uY2xvc2U9ZnVuY3Rpb24oKXtlLmYoXCJXZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkLlwiKTtlLnVhPW51bGw7ZS5lYigpfTt0aGlzLnVhLm9ubWVzc2FnZT1mdW5jdGlvbihhKXtpZihudWxsIT09ZS51YSlpZihhPWEuZGF0YSxlLmpiKz1cbmEubGVuZ3RoLFVkKGUuUmEsXCJieXRlc19yZWNlaXZlZFwiLGEubGVuZ3RoKSxkZShlKSxudWxsIT09ZS5mcmFtZXMpZWUoZSxhKTtlbHNle2E6e3kobnVsbD09PWUuZnJhbWVzLFwiV2UgYWxyZWFkeSBoYXZlIGEgZnJhbWUgYnVmZmVyXCIpO2lmKDY+PWEubGVuZ3RoKXt2YXIgYj1OdW1iZXIoYSk7aWYoIWlzTmFOKGIpKXtlLlVlPWI7ZS5mcmFtZXM9W107YT1udWxsO2JyZWFrIGF9fWUuVWU9MTtlLmZyYW1lcz1bXX1udWxsIT09YSYmZWUoZSxhKX19O3RoaXMudWEub25lcnJvcj1mdW5jdGlvbihhKXtlLmYoXCJXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uXCIpOyhhPWEubWVzc2FnZXx8YS5kYXRhKSYmZS5mKGEpO2UuZWIoKX19O2JlLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe307XG5iZS5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3ZhciBhPSExO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50KXt2YXIgYj1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLyk7YiYmMTxiLmxlbmd0aCYmNC40PnBhcnNlRmxvYXQoYlsxXSkmJihhPSEwKX1yZXR1cm4hYSYmbnVsbCE9PWFlJiYhY2V9O2JlLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHk9MjtiZS5oZWFsdGh5VGltZW91dD0zRTQ7aD1iZS5wcm90b3R5cGU7aC52ZD1mdW5jdGlvbigpe3phLnJlbW92ZShcInByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlXCIpfTtmdW5jdGlvbiBlZShhLGIpe2EuZnJhbWVzLnB1c2goYik7aWYoYS5mcmFtZXMubGVuZ3RoPT1hLlVlKXt2YXIgYz1hLmZyYW1lcy5qb2luKFwiXCIpO2EuZnJhbWVzPW51bGw7Yz10YShjKTthLmhnKGMpfX1cbmguc2VuZD1mdW5jdGlvbihhKXtkZSh0aGlzKTthPXIoYSk7dGhpcy5rYis9YS5sZW5ndGg7VWQodGhpcy5SYSxcImJ5dGVzX3NlbnRcIixhLmxlbmd0aCk7YT15YihhLDE2Mzg0KTsxPGEubGVuZ3RoJiZ0aGlzLnVhLnNlbmQoU3RyaW5nKGEubGVuZ3RoKSk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy51YS5zZW5kKGFbYl0pfTtoLlVjPWZ1bmN0aW9uKCl7dGhpcy5yYj0hMDt0aGlzLkNjJiYoY2xlYXJJbnRlcnZhbCh0aGlzLkNjKSx0aGlzLkNjPW51bGwpO3RoaXMudWEmJih0aGlzLnVhLmNsb3NlKCksdGhpcy51YT1udWxsKX07aC5lYj1mdW5jdGlvbigpe3RoaXMucmJ8fCh0aGlzLmYoXCJXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGZcIiksdGhpcy5VYygpLHRoaXMuZmImJih0aGlzLmZiKHRoaXMueWMpLHRoaXMuZmI9bnVsbCkpfTtoLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5yYnx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBiZWluZyBjbG9zZWRcIiksdGhpcy5VYygpKX07XG5mdW5jdGlvbiBkZShhKXtjbGVhckludGVydmFsKGEuQ2MpO2EuQ2M9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXthLnVhJiZhLnVhLnNlbmQoXCIwXCIpO2RlKGEpfSxNYXRoLmZsb29yKDQ1RTMpKX07ZnVuY3Rpb24gZmUoYSl7dGhpcy5hYz1hO3RoaXMuSGQ9W107dGhpcy5KYj0wO3RoaXMubGU9LTE7dGhpcy54Yj1udWxsfWZ1bmN0aW9uIGdlKGEsYixjKXthLmxlPWI7YS54Yj1jO2EubGU8YS5KYiYmKGEueGIoKSxhLnhiPW51bGwpfWZ1bmN0aW9uIGhlKGEsYixjKXtmb3IoYS5IZFtiXT1jO2EuSGRbYS5KYl07KXt2YXIgZD1hLkhkW2EuSmJdO2RlbGV0ZSBhLkhkW2EuSmJdO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7KytlKWlmKGRbZV0pe3ZhciBmPWE7Q2IoZnVuY3Rpb24oKXtmLmFjKGRbZV0pfSl9aWYoYS5KYj09PWEubGUpe2EueGImJihjbGVhclRpbWVvdXQoYS54YiksYS54YigpLGEueGI9bnVsbCk7YnJlYWt9YS5KYisrfX07ZnVuY3Rpb24gaWUoKXt0aGlzLnNldD17fX1oPWllLnByb3RvdHlwZTtoLmFkZD1mdW5jdGlvbihhLGIpe3RoaXMuc2V0W2FdPW51bGwhPT1iP2I6ITB9O2guY29udGFpbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIHModGhpcy5zZXQsYSl9O2guZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNvbnRhaW5zKGEpP3RoaXMuc2V0W2FdOnZvaWQgMH07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuc2V0W2FdfTtoLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5zZXQ9e319O2guZT1mdW5jdGlvbigpe3JldHVybiBQZCh0aGlzLnNldCl9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gSmIodGhpcy5zZXQpfTtmdW5jdGlvbiBqZShhLGIpe0EoYS5zZXQsZnVuY3Rpb24oYSxkKXtiKGQsYSl9KX07ZnVuY3Rpb24ga2UoYSxiLGMpe3RoaXMubWU9YTt0aGlzLmY9b2IoYSk7dGhpcy5qYj10aGlzLmtiPTA7dGhpcy5SYT1aZChiKTt0aGlzLlJkPWM7dGhpcy55Yz0hMTt0aGlzLlpjPWZ1bmN0aW9uKGEpe2IuaG9zdCE9PWIuTWEmJihhLm5zPWIudWIpO3ZhciBjPVtdLGY7Zm9yKGYgaW4gYSlhLmhhc093blByb3BlcnR5KGYpJiZjLnB1c2goZitcIj1cIithW2ZdKTtyZXR1cm4oYi5CYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK2IuTWErXCIvLmxwP1wiK2Muam9pbihcIiZcIil9fXZhciBsZSxtZTtcbmtlLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7dGhpcy4kZT0wO3RoaXMuZ2E9Yjt0aGlzLm1mPW5ldyBmZShhKTt0aGlzLnJiPSExO3ZhciBjPXRoaXM7dGhpcy5tYj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5mKFwiVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LlwiKTtjLmViKCk7Yy5tYj1udWxsfSxNYXRoLmZsb29yKDNFNCkpO3RiKGZ1bmN0aW9uKCl7aWYoIWMucmIpe2MuUGE9bmV3IG5lKGZ1bmN0aW9uKGEsYixkLGssbCl7b2UoYyxhcmd1bWVudHMpO2lmKGMuUGEpaWYoYy5tYiYmKGNsZWFyVGltZW91dChjLm1iKSxjLm1iPW51bGwpLGMueWM9ITAsXCJzdGFydFwiPT1hKWMuaWQ9YixjLnJmPWQ7ZWxzZSBpZihcImNsb3NlXCI9PT1hKWI/KGMuUGEuUGQ9ITEsZ2UoYy5tZixiLGZ1bmN0aW9uKCl7Yy5lYigpfSkpOmMuZWIoKTtlbHNlIHRocm93IEVycm9yKFwiVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6IFwiK2EpO30sZnVuY3Rpb24oYSxiKXtvZShjLGFyZ3VtZW50cyk7XG5oZShjLm1mLGEsYil9LGZ1bmN0aW9uKCl7Yy5lYigpfSxjLlpjKTt2YXIgYT17c3RhcnQ6XCJ0XCJ9O2Euc2VyPU1hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO2MuUGEuYWUmJihhLmNiPWMuUGEuYWUpO2Eudj1cIjVcIjtjLlJkJiYoYS5zPWMuUmQpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgbG9jYXRpb24mJmxvY2F0aW9uLmhyZWYmJi0xIT09bG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZmlyZWJhc2Vpby5jb21cIikmJihhLnI9XCJmXCIpO2E9Yy5aYyhhKTtjLmYoXCJDb25uZWN0aW5nIHZpYSBsb25nLXBvbGwgdG8gXCIrYSk7cGUoYy5QYSxhLGZ1bmN0aW9uKCl7fSl9fSl9O1xua2UucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5QYSxiPXRoaXMucmY7YS5jZz10aGlzLmlkO2EuZGc9Yjtmb3IoYS5mZT0hMDtxZShhKTspO2E9dGhpcy5pZDtiPXRoaXMucmY7dGhpcy5aYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO3ZhciBjPXtkZnJhbWU6XCJ0XCJ9O2MuaWQ9YTtjLnB3PWI7dGhpcy5aYi5zcmM9dGhpcy5aYyhjKTt0aGlzLlpiLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLlpiKX07a2UuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hbWUmJiEoXCJvYmplY3RcIj09PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5jaHJvbWUmJndpbmRvdy5jaHJvbWUuZXh0ZW5zaW9uJiYhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKSYmIShcIm9iamVjdFwiPT09dHlwZW9mIFdpbmRvd3MmJlwib2JqZWN0XCI9PT10eXBlb2YgV2luZG93cy5GZykmJihsZXx8ITApfTtoPWtlLnByb3RvdHlwZTtcbmgudmQ9ZnVuY3Rpb24oKXt9O2guVWM9ZnVuY3Rpb24oKXt0aGlzLnJiPSEwO3RoaXMuUGEmJih0aGlzLlBhLmNsb3NlKCksdGhpcy5QYT1udWxsKTt0aGlzLlpiJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLlpiKSx0aGlzLlpiPW51bGwpO3RoaXMubWImJihjbGVhclRpbWVvdXQodGhpcy5tYiksdGhpcy5tYj1udWxsKX07aC5lYj1mdW5jdGlvbigpe3RoaXMucmJ8fCh0aGlzLmYoXCJMb25ncG9sbCBpcyBjbG9zaW5nIGl0c2VsZlwiKSx0aGlzLlVjKCksdGhpcy5nYSYmKHRoaXMuZ2EodGhpcy55YyksdGhpcy5nYT1udWxsKSl9O2guY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnJifHwodGhpcy5mKFwiTG9uZ3BvbGwgaXMgYmVpbmcgY2xvc2VkLlwiKSx0aGlzLlVjKCkpfTtcbmguc2VuZD1mdW5jdGlvbihhKXthPXIoYSk7dGhpcy5rYis9YS5sZW5ndGg7VWQodGhpcy5SYSxcImJ5dGVzX3NlbnRcIixhLmxlbmd0aCk7YT1qYihhKTthPWNiKGEsITApO2E9eWIoYSwxODQwKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5QYTtjLlFjLnB1c2goe3VnOnRoaXMuJGUsQ2c6YS5sZW5ndGgsYmY6YVtiXX0pO2MuZmUmJnFlKGMpO3RoaXMuJGUrK319O2Z1bmN0aW9uIG9lKGEsYil7dmFyIGM9cihiKS5sZW5ndGg7YS5qYis9YztVZChhLlJhLFwiYnl0ZXNfcmVjZWl2ZWRcIixjKX1cbmZ1bmN0aW9uIG5lKGEsYixjLGQpe3RoaXMuWmM9ZDt0aGlzLmZiPWM7dGhpcy5KZT1uZXcgaWU7dGhpcy5RYz1bXTt0aGlzLm9lPU1hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO3RoaXMuUGQ9ITA7dGhpcy5hZT1lYigpO3dpbmRvd1tcInBMUENvbW1hbmRcIit0aGlzLmFlXT1hO3dpbmRvd1tcInBSVExQQ0JcIit0aGlzLmFlXT1iO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTthLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7aWYoZG9jdW1lbnQuYm9keSl7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTt0cnl7YS5jb250ZW50V2luZG93LmRvY3VtZW50fHxoYihcIk5vIElFIGRvbWFpbiBzZXR0aW5nIHJlcXVpcmVkXCIpfWNhdGNoKGUpe2Euc3JjPVwiamF2YXNjcmlwdDp2b2lkKChmdW5jdGlvbigpe2RvY3VtZW50Lm9wZW4oKTtkb2N1bWVudC5kb21haW49J1wiK2RvY3VtZW50LmRvbWFpbitcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwifX1lbHNlIHRocm93XCJEb2N1bWVudCBib2R5IGhhcyBub3QgaW5pdGlhbGl6ZWQuIFdhaXQgdG8gaW5pdGlhbGl6ZSBGaXJlYmFzZSB1bnRpbCBhZnRlciB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuXCI7XG5hLmNvbnRlbnREb2N1bWVudD9hLmFiPWEuY29udGVudERvY3VtZW50OmEuY29udGVudFdpbmRvdz9hLmFiPWEuY29udGVudFdpbmRvdy5kb2N1bWVudDphLmRvY3VtZW50JiYoYS5hYj1hLmRvY3VtZW50KTt0aGlzLkFhPWE7YT1cIlwiO3RoaXMuQWEuc3JjJiZcImphdmFzY3JpcHQ6XCI9PT10aGlzLkFhLnNyYy5zdWJzdHIoMCwxMSkmJihhPSc8c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cIicrZG9jdW1lbnQuZG9tYWluKydcIjtcXHgzYy9zY3JpcHQ+Jyk7YT1cIjxodG1sPjxib2R5PlwiK2ErXCI8L2JvZHk+PC9odG1sPlwiO3RyeXt0aGlzLkFhLmFiLm9wZW4oKSx0aGlzLkFhLmFiLndyaXRlKGEpLHRoaXMuQWEuYWIuY2xvc2UoKX1jYXRjaChmKXtoYihcImZyYW1lIHdyaXRpbmcgZXhjZXB0aW9uXCIpLGYuc3RhY2smJmhiKGYuc3RhY2spLGhiKGYpfX1cbm5lLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe3RoaXMuZmU9ITE7aWYodGhpcy5BYSl7dGhpcy5BYS5hYi5ib2R5LmlubmVySFRNTD1cIlwiO3ZhciBhPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe251bGwhPT1hLkFhJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhLkFhKSxhLkFhPW51bGwpfSxNYXRoLmZsb29yKDApKX12YXIgYj10aGlzLmZiO2ImJih0aGlzLmZiPW51bGwsYigpKX07XG5mdW5jdGlvbiBxZShhKXtpZihhLmZlJiZhLlBkJiZhLkplLmNvdW50KCk8KDA8YS5RYy5sZW5ndGg/MjoxKSl7YS5vZSsrO3ZhciBiPXt9O2IuaWQ9YS5jZztiLnB3PWEuZGc7Yi5zZXI9YS5vZTtmb3IodmFyIGI9YS5aYyhiKSxjPVwiXCIsZD0wOzA8YS5RYy5sZW5ndGg7KWlmKDE4NzA+PWEuUWNbMF0uYmYubGVuZ3RoKzMwK2MubGVuZ3RoKXt2YXIgZT1hLlFjLnNoaWZ0KCksYz1jK1wiJnNlZ1wiK2QrXCI9XCIrZS51ZytcIiZ0c1wiK2QrXCI9XCIrZS5DZytcIiZkXCIrZCtcIj1cIitlLmJmO2QrK31lbHNlIGJyZWFrO3JlKGEsYitjLGEub2UpO3JldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHJlKGEsYixjKXtmdW5jdGlvbiBkKCl7YS5KZS5yZW1vdmUoYyk7cWUoYSl9YS5KZS5hZGQoYyk7dmFyIGU9c2V0VGltZW91dChkLE1hdGguZmxvb3IoMjVFMykpO3BlKGEsYixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlKTtkKCl9KX1cbmZ1bmN0aW9uIHBlKGEsYixjKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dHJ5e2lmKGEuUGQpe3ZhciBkPWEuQWEuYWIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmFzeW5jPSEwO2Quc3JjPWI7ZC5vbmxvYWQ9ZC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT1kLnJlYWR5U3RhdGU7YSYmXCJsb2FkZWRcIiE9PWEmJlwiY29tcGxldGVcIiE9PWF8fChkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGQucGFyZW50Tm9kZSYmZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLGMoKSl9O2Qub25lcnJvcj1mdW5jdGlvbigpe2hiKFwiTG9uZy1wb2xsIHNjcmlwdCBmYWlsZWQgdG8gbG9hZDogXCIrYik7YS5QZD0hMTthLmNsb3NlKCl9O2EuQWEuYWIuYm9keS5hcHBlbmRDaGlsZChkKX19Y2F0Y2goZSl7fX0sTWF0aC5mbG9vcigxKSl9O2Z1bmN0aW9uIHNlKGEpe3RlKHRoaXMsYSl9dmFyIHVlPVtrZSxiZV07ZnVuY3Rpb24gdGUoYSxiKXt2YXIgYz1iZSYmYmUuaXNBdmFpbGFibGUoKSxkPWMmJiEoemEubGZ8fCEwPT09emEuZ2V0KFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIikpO2IuRWcmJihjfHx6KFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKSxkPSEwKTtpZihkKWEuWGM9W2JlXTtlbHNle3ZhciBlPWEuWGM9W107emIodWUsZnVuY3Rpb24oYSxiKXtiJiZiLmlzQXZhaWxhYmxlKCkmJmUucHVzaChiKX0pfX1mdW5jdGlvbiB2ZShhKXtpZigwPGEuWGMubGVuZ3RoKXJldHVybiBhLlhjWzBdO3Rocm93IEVycm9yKFwiTm8gdHJhbnNwb3J0cyBhdmFpbGFibGVcIik7fTtmdW5jdGlvbiB3ZShhLGIsYyxkLGUsZil7dGhpcy5pZD1hO3RoaXMuZj1vYihcImM6XCIrdGhpcy5pZCtcIjpcIik7dGhpcy5hYz1jO3RoaXMuS2M9ZDt0aGlzLmdhPWU7dGhpcy5IZT1mO3RoaXMuTz1iO3RoaXMuR2Q9W107dGhpcy5ZZT0wO3RoaXMuQWY9bmV3IHNlKGIpO3RoaXMuUWE9MDt0aGlzLmYoXCJDb25uZWN0aW9uIGNyZWF0ZWRcIik7eGUodGhpcyl9XG5mdW5jdGlvbiB4ZShhKXt2YXIgYj12ZShhLkFmKTthLko9bmV3IGIoXCJjOlwiK2EuaWQrXCI6XCIrYS5ZZSsrLGEuTyk7YS5MZT1iLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHl8fDA7dmFyIGM9eWUoYSxhLkopLGQ9emUoYSxhLkopO2EuWWM9YS5KO2EuVGM9YS5KO2EuQz1udWxsO2Euc2I9ITE7c2V0VGltZW91dChmdW5jdGlvbigpe2EuSiYmYS5KLm9wZW4oYyxkKX0sTWF0aC5mbG9vcigwKSk7Yj1iLmhlYWx0aHlUaW1lb3V0fHwwOzA8YiYmKGEub2Q9c2V0VGltZW91dChmdW5jdGlvbigpe2Eub2Q9bnVsbDthLnNifHwoYS5KJiYxMDI0MDA8YS5KLmpiPyhhLmYoXCJDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHJlY2VpdmVkIFwiK2EuSi5qYitcIiBieXRlcy4gIE1hcmtpbmcgY29ubmVjdGlvbiBoZWFsdGh5LlwiKSxhLnNiPSEwLGEuSi52ZCgpKTphLkomJjEwMjQwPGEuSi5rYj9hLmYoXCJDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHNlbnQgXCIrXG5hLkoua2IrXCIgYnl0ZXMuICBMZWF2aW5nIGNvbm5lY3Rpb24gYWxpdmUuXCIpOihhLmYoXCJDbG9zaW5nIHVuaGVhbHRoeSBjb25uZWN0aW9uIGFmdGVyIHRpbWVvdXQuXCIpLGEuY2xvc2UoKSkpfSxNYXRoLmZsb29yKGIpKSl9ZnVuY3Rpb24gemUoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7Yj09PWEuSj8oYS5KPW51bGwsY3x8MCE9PWEuUWE/MT09PWEuUWEmJmEuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gbG9zdC5cIik6KGEuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gZmFpbGVkLlwiKSxcInMtXCI9PT1hLk8uTWEuc3Vic3RyKDAsMikmJih6YS5yZW1vdmUoXCJob3N0OlwiK2EuTy5ob3N0KSxhLk8uTWE9YS5PLmhvc3QpKSxhLmNsb3NlKCkpOmI9PT1hLkM/KGEuZihcIlNlY29uZGFyeSBjb25uZWN0aW9uIGxvc3QuXCIpLGM9YS5DLGEuQz1udWxsLGEuWWMhPT1jJiZhLlRjIT09Y3x8YS5jbG9zZSgpKTphLmYoXCJjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uXCIpfX1cbmZ1bmN0aW9uIHllKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKDIhPWEuUWEpaWYoYj09PWEuVGMpe3ZhciBkPXdiKFwidFwiLGMpO2M9d2IoXCJkXCIsYyk7aWYoXCJjXCI9PWQpe2lmKGQ9d2IoXCJ0XCIsYyksXCJkXCJpbiBjKWlmKGM9Yy5kLFwiaFwiPT09ZCl7dmFyIGQ9Yy50cyxlPWMudixmPWMuaDthLlJkPWMucztCYShhLk8sZik7MD09YS5RYSYmKGEuSi5zdGFydCgpLEFlKGEsYS5KLGQpLFwiNVwiIT09ZSYmeihcIlByb3RvY29sIHZlcnNpb24gbWlzbWF0Y2ggZGV0ZWN0ZWRcIiksYz1hLkFmLChjPTE8Yy5YYy5sZW5ndGg/Yy5YY1sxXTpudWxsKSYmQmUoYSxjKSl9ZWxzZSBpZihcIm5cIj09PWQpe2EuZihcInJlY3ZkIGVuZCB0cmFuc21pc3Npb24gb24gcHJpbWFyeVwiKTthLlRjPWEuQztmb3IoYz0wO2M8YS5HZC5sZW5ndGg7KytjKWEuQ2QoYS5HZFtjXSk7YS5HZD1bXTtDZShhKX1lbHNlXCJzXCI9PT1kPyhhLmYoXCJDb25uZWN0aW9uIHNodXRkb3duIGNvbW1hbmQgcmVjZWl2ZWQuIFNodXR0aW5nIGRvd24uLi5cIiksXG5hLkhlJiYoYS5IZShjKSxhLkhlPW51bGwpLGEuZ2E9bnVsbCxhLmNsb3NlKCkpOlwiclwiPT09ZD8oYS5mKFwiUmVzZXQgcGFja2V0IHJlY2VpdmVkLiAgTmV3IGhvc3Q6IFwiK2MpLEJhKGEuTyxjKSwxPT09YS5RYT9hLmNsb3NlKCk6KERlKGEpLHhlKGEpKSk6XCJlXCI9PT1kP3BiKFwiU2VydmVyIEVycm9yOiBcIitjKTpcIm9cIj09PWQ/KGEuZihcImdvdCBwb25nIG9uIHByaW1hcnkuXCIpLEVlKGEpLEZlKGEpKTpwYihcIlVua25vd24gY29udHJvbCBwYWNrZXQgY29tbWFuZDogXCIrZCl9ZWxzZVwiZFwiPT1kJiZhLkNkKGMpfWVsc2UgaWYoYj09PWEuQylpZihkPXdiKFwidFwiLGMpLGM9d2IoXCJkXCIsYyksXCJjXCI9PWQpXCJ0XCJpbiBjJiYoYz1jLnQsXCJhXCI9PT1jP0dlKGEpOlwiclwiPT09Yz8oYS5mKFwiR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0XCIpLGEuQy5jbG9zZSgpLGEuWWMhPT1hLkMmJmEuVGMhPT1hLkN8fGEuY2xvc2UoKSk6XCJvXCI9PT1jJiYoYS5mKFwiZ290IHBvbmcgb24gc2Vjb25kYXJ5LlwiKSxcbmEueWYtLSxHZShhKSkpO2Vsc2UgaWYoXCJkXCI9PWQpYS5HZC5wdXNoKGMpO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbmtub3duIHByb3RvY29sIGxheWVyOiBcIitkKTtlbHNlIGEuZihcIm1lc3NhZ2Ugb24gb2xkIGNvbm5lY3Rpb25cIil9fXdlLnByb3RvdHlwZS5CYT1mdW5jdGlvbihhKXtIZSh0aGlzLHt0OlwiZFwiLGQ6YX0pfTtmdW5jdGlvbiBDZShhKXthLlljPT09YS5DJiZhLlRjPT09YS5DJiYoYS5mKFwiY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246IFwiK2EuQy5tZSksYS5KPWEuQyxhLkM9bnVsbCl9XG5mdW5jdGlvbiBHZShhKXswPj1hLnlmPyhhLmYoXCJTZWNvbmRhcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLnNiPSEwLGEuQy52ZCgpLGEuQy5zdGFydCgpLGEuZihcInNlbmRpbmcgY2xpZW50IGFjayBvbiBzZWNvbmRhcnlcIiksYS5DLnNlbmQoe3Q6XCJjXCIsZDp7dDpcImFcIixkOnt9fX0pLGEuZihcIkVuZGluZyB0cmFuc21pc3Npb24gb24gcHJpbWFyeVwiKSxhLkouc2VuZCh7dDpcImNcIixkOnt0OlwiblwiLGQ6e319fSksYS5ZYz1hLkMsQ2UoYSkpOihhLmYoXCJzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LlwiKSxhLkMuc2VuZCh7dDpcImNcIixkOnt0OlwicFwiLGQ6e319fSkpfXdlLnByb3RvdHlwZS5DZD1mdW5jdGlvbihhKXtFZSh0aGlzKTt0aGlzLmFjKGEpfTtmdW5jdGlvbiBFZShhKXthLnNifHwoYS5MZS0tLDA+PWEuTGUmJihhLmYoXCJQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5zYj0hMCxhLkoudmQoKSkpfVxuZnVuY3Rpb24gQmUoYSxiKXthLkM9bmV3IGIoXCJjOlwiK2EuaWQrXCI6XCIrYS5ZZSsrLGEuTyxhLlJkKTthLnlmPWIucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeXx8MDthLkMub3Blbih5ZShhLGEuQyksemUoYSxhLkMpKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5DJiYoYS5mKFwiVGltZWQgb3V0IHRyeWluZyB0byB1cGdyYWRlLlwiKSxhLkMuY2xvc2UoKSl9LE1hdGguZmxvb3IoNkU0KSl9ZnVuY3Rpb24gQWUoYSxiLGMpe2EuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuXCIpO2EuSj1iO2EuUWE9MTthLktjJiYoYS5LYyhjKSxhLktjPW51bGwpOzA9PT1hLkxlPyhhLmYoXCJQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5zYj0hMCk6c2V0VGltZW91dChmdW5jdGlvbigpe0ZlKGEpfSxNYXRoLmZsb29yKDVFMykpfVxuZnVuY3Rpb24gRmUoYSl7YS5zYnx8MSE9PWEuUWF8fChhLmYoXCJzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS5cIiksSGUoYSx7dDpcImNcIixkOnt0OlwicFwiLGQ6e319fSkpfWZ1bmN0aW9uIEhlKGEsYil7aWYoMSE9PWEuUWEpdGhyb3dcIkNvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZFwiO2EuWWMuc2VuZChiKX13ZS5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXsyIT09dGhpcy5RYSYmKHRoaXMuZihcIkNsb3NpbmcgcmVhbHRpbWUgY29ubmVjdGlvbi5cIiksdGhpcy5RYT0yLERlKHRoaXMpLHRoaXMuZ2EmJih0aGlzLmdhKCksdGhpcy5nYT1udWxsKSl9O2Z1bmN0aW9uIERlKGEpe2EuZihcIlNodXR0aW5nIGRvd24gYWxsIGNvbm5lY3Rpb25zXCIpO2EuSiYmKGEuSi5jbG9zZSgpLGEuSj1udWxsKTthLkMmJihhLkMuY2xvc2UoKSxhLkM9bnVsbCk7YS5vZCYmKGNsZWFyVGltZW91dChhLm9kKSxhLm9kPW51bGwpfTtmdW5jdGlvbiBJZSgpe0lkLmNhbGwodGhpcyxbXCJvbmxpbmVcIl0pO3RoaXMuTGM9ITA7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBhPXRoaXM7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIixmdW5jdGlvbigpe2EuTGN8fGEuJGQoXCJvbmxpbmVcIiwhMCk7YS5MYz0hMH0sITEpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLGZ1bmN0aW9uKCl7YS5MYyYmYS4kZChcIm9ubGluZVwiLCExKTthLkxjPSExfSwhMSl9fW1hKEllLElkKTtjYShJZSk7SWUucHJvdG90eXBlLnVlPWZ1bmN0aW9uKGEpe3koXCJvbmxpbmVcIj09PWEsXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiK2EpO3JldHVyblt0aGlzLkxjXX07ZnVuY3Rpb24gSmUoYSl7dmFyIGI9e30sYz17fSxkPXt9LGU9XCJcIjt0cnl7dmFyIGY9YS5zcGxpdChcIi5cIiksYj10YShnYihmWzBdKXx8XCJcIiksYz10YShnYihmWzFdKXx8XCJcIiksZT1mWzJdLGQ9Yy5kfHx7fTtkZWxldGUgYy5kfWNhdGNoKGcpe31yZXR1cm57SGc6YixrZTpjLGRhdGE6ZCx5ZzplfX1mdW5jdGlvbiBLZShhKXthPUplKGEpLmtlO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmYS5oYXNPd25Qcm9wZXJ0eShcImlhdFwiKT90KGEsXCJpYXRcIik6bnVsbH1mdW5jdGlvbiBMZShhKXthPUplKGEpO3ZhciBiPWEua2U7cmV0dXJuISFhLnlnJiYhIWImJlwib2JqZWN0XCI9PT10eXBlb2YgYiYmYi5oYXNPd25Qcm9wZXJ0eShcImlhdFwiKX07ZnVuY3Rpb24gTWUoYSxiLGMsZCl7dGhpcy5pZD1OZSsrO3RoaXMuZj1vYihcInA6XCIrdGhpcy5pZCtcIjpcIik7dGhpcy5EYj0hMDt0aGlzLnRhPXt9O3RoaXMubGE9W107dGhpcy5OYz0wO3RoaXMuSmM9W107dGhpcy5qYT0hMTt0aGlzLldhPTFFMzt0aGlzLnhkPTNFNTt0aGlzLkRkPWI7dGhpcy5CZD1jO3RoaXMuSWU9ZDt0aGlzLk89YTt0aGlzLlBlPW51bGw7dGhpcy5TYz17fTt0aGlzLnRnPTA7dGhpcy5EYz10aGlzLkFlPW51bGw7T2UodGhpcywwKTtLZC5PYigpLndiKFwidmlzaWJsZVwiLHRoaXMua2csdGhpcyk7LTE9PT1hLmhvc3QuaW5kZXhPZihcImZibG9jYWxcIikmJkllLk9iKCkud2IoXCJvbmxpbmVcIix0aGlzLmlnLHRoaXMpfXZhciBOZT0wLFBlPTA7aD1NZS5wcm90b3R5cGU7XG5oLkJhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD0rK3RoaXMudGc7YT17cjpkLGE6YSxiOmJ9O3RoaXMuZihyKGEpKTt5KHRoaXMuamEsXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7dGhpcy5PYS5CYShhKTtjJiYodGhpcy5TY1tkXT1jKX07ZnVuY3Rpb24gUWUoYSxiLGMsZCxlKXt2YXIgZj1iLkZhKCksZz1iLnBhdGgudG9TdHJpbmcoKTthLmYoXCJMaXN0ZW4gY2FsbGVkIGZvciBcIitnK1wiIFwiK2YpO2EudGFbZ109YS50YVtnXXx8e307eSghYS50YVtnXVtmXSxcImxpc3RlbigpIGNhbGxlZCB0d2ljZSBmb3Igc2FtZSBwYXRoL3F1ZXJ5SWQuXCIpO2I9e0g6ZSxuZDpjLHFnOkxjKGIubiksdGFnOmR9O2EudGFbZ11bZl09YjthLmphJiZSZShhLGcsZixiKX1cbmZ1bmN0aW9uIFJlKGEsYixjLGQpe2EuZihcIkxpc3RlbiBvbiBcIitiK1wiIGZvciBcIitjKTt2YXIgZT17cDpifTtkLnRhZyYmKGUucT1kLnFnLGUudD1kLnRhZyk7ZS5oPWQubmQoKTthLkJhKFwicVwiLGUsZnVuY3Rpb24oZSl7aWYoKGEudGFbYl0mJmEudGFbYl1bY10pPT09ZCl7YS5mKFwibGlzdGVuIHJlc3BvbnNlXCIsZSk7dmFyIGc9ZS5zO1wib2tcIiE9PWcmJlNlKGEsYixjKTtlPWUuZDtkLkgmJmQuSChnLGUpfX0pfWguUT1mdW5jdGlvbihhLGIsYyl7dGhpcy5JYj17UmY6YSxkZjohMSxyYzpiLGFkOmN9O3RoaXMuZihcIkF1dGhlbnRpY2F0aW5nIHVzaW5nIGNyZWRlbnRpYWw6IFwiK2EpO1RlKHRoaXMpOyhiPTQwPT1hLmxlbmd0aCl8fChhPUplKGEpLmtlLGI9XCJvYmplY3RcIj09PXR5cGVvZiBhJiYhMD09PXQoYSxcImFkbWluXCIpKTtiJiYodGhpcy5mKFwiQWRtaW4gYXV0aCBjcmVkZW50aWFsIGRldGVjdGVkLiAgUmVkdWNpbmcgbWF4IHJlY29ubmVjdCB0aW1lLlwiKSx0aGlzLnhkPTNFNCl9O1xuaC5WZT1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5JYjt0aGlzLmphJiZ0aGlzLkJhKFwidW5hdXRoXCIse30sZnVuY3Rpb24oYil7YShiLnMsYi5kKX0pfTtmdW5jdGlvbiBUZShhKXt2YXIgYj1hLkliO2EuamEmJmImJmEuQmEoXCJhdXRoXCIse2NyZWQ6Yi5SZn0sZnVuY3Rpb24oYyl7dmFyIGQ9Yy5zO2M9Yy5kfHxcImVycm9yXCI7XCJva1wiIT09ZCYmYS5JYj09PWImJmRlbGV0ZSBhLkliO2IuZGY/XCJva1wiIT09ZCYmYi5hZCYmYi5hZChkLGMpOihiLmRmPSEwLGIucmMmJmIucmMoZCxjKSl9KX1mdW5jdGlvbiBVZShhLGIsYyxkKXthLmphP1ZlKGEsXCJvXCIsYixjLGQpOmEuSmMucHVzaCh7UGM6YixhY3Rpb246XCJvXCIsZGF0YTpjLEg6ZH0pfWZ1bmN0aW9uIFdlKGEsYixjLGQpe2EuamE/VmUoYSxcIm9tXCIsYixjLGQpOmEuSmMucHVzaCh7UGM6YixhY3Rpb246XCJvbVwiLGRhdGE6YyxIOmR9KX1cbmguR2U9ZnVuY3Rpb24oYSxiKXt0aGlzLmphP1ZlKHRoaXMsXCJvY1wiLGEsbnVsbCxiKTp0aGlzLkpjLnB1c2goe1BjOmEsYWN0aW9uOlwib2NcIixkYXRhOm51bGwsSDpifSl9O2Z1bmN0aW9uIFZlKGEsYixjLGQsZSl7Yz17cDpjLGQ6ZH07YS5mKFwib25EaXNjb25uZWN0IFwiK2IsYyk7YS5CYShiLGMsZnVuY3Rpb24oYSl7ZSYmc2V0VGltZW91dChmdW5jdGlvbigpe2UoYS5zLGEuZCl9LE1hdGguZmxvb3IoMCkpfSl9aC5wdXQ9ZnVuY3Rpb24oYSxiLGMsZCl7WGUodGhpcyxcInBcIixhLGIsYyxkKX07ZnVuY3Rpb24gWWUoYSxiLGMsZCl7WGUoYSxcIm1cIixiLGMsZCx2b2lkIDApfWZ1bmN0aW9uIFhlKGEsYixjLGQsZSxmKXtkPXtwOmMsZDpkfTttKGYpJiYoZC5oPWYpO2EubGEucHVzaCh7YWN0aW9uOmIsdWY6ZCxIOmV9KTthLk5jKys7Yj1hLmxhLmxlbmd0aC0xO2EuamE/WmUoYSxiKTphLmYoXCJCdWZmZXJpbmcgcHV0OiBcIitjKX1cbmZ1bmN0aW9uIFplKGEsYil7dmFyIGM9YS5sYVtiXS5hY3Rpb24sZD1hLmxhW2JdLnVmLGU9YS5sYVtiXS5IO2EubGFbYl0ucmc9YS5qYTthLkJhKGMsZCxmdW5jdGlvbihkKXthLmYoYytcIiByZXNwb25zZVwiLGQpO2RlbGV0ZSBhLmxhW2JdO2EuTmMtLTswPT09YS5OYyYmKGEubGE9W10pO2UmJmUoZC5zLGQuZCl9KX1cbmguQ2Q9ZnVuY3Rpb24oYSl7aWYoXCJyXCJpbiBhKXt0aGlzLmYoXCJmcm9tIHNlcnZlcjogXCIrcihhKSk7dmFyIGI9YS5yLGM9dGhpcy5TY1tiXTtjJiYoZGVsZXRlIHRoaXMuU2NbYl0sYyhhLmIpKX1lbHNle2lmKFwiZXJyb3JcImluIGEpdGhyb3dcIkEgc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiBcIithLmVycm9yO1wiYVwiaW4gYSYmKGI9YS5hLGM9YS5iLHRoaXMuZihcImhhbmRsZVNlcnZlck1lc3NhZ2VcIixiLGMpLFwiZFwiPT09Yj90aGlzLkRkKGMucCxjLmQsITEsYy50KTpcIm1cIj09PWI/dGhpcy5EZChjLnAsYy5kLCEwLGMudCk6XCJjXCI9PT1iPyRlKHRoaXMsYy5wLGMucSk6XCJhY1wiPT09Yj8oYT1jLnMsYj1jLmQsYz10aGlzLkliLGRlbGV0ZSB0aGlzLkliLGMmJmMuYWQmJmMuYWQoYSxiKSk6XCJzZFwiPT09Yj90aGlzLlBlP3RoaXMuUGUoYyk6XCJtc2dcImluIGMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmY29uc29sZS5sb2coXCJGSVJFQkFTRTogXCIrYy5tc2cucmVwbGFjZShcIlxcblwiLFxuXCJcXG5GSVJFQkFTRTogXCIpKTpwYihcIlVucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiK3IoYikrXCJcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50P1wiKSl9fTtoLktjPWZ1bmN0aW9uKGEpe3RoaXMuZihcImNvbm5lY3Rpb24gcmVhZHlcIik7dGhpcy5qYT0hMDt0aGlzLkRjPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMuSWUoe3NlcnZlclRpbWVPZmZzZXQ6YS0obmV3IERhdGUpLmdldFRpbWUoKX0pO2FmKHRoaXMpO3RoaXMuQmQoITApfTtmdW5jdGlvbiBPZShhLGIpe3koIWEuT2EsXCJTY2hlZHVsaW5nIGEgY29ubmVjdCB3aGVuIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkL2luZz9cIik7YS5LYiYmY2xlYXJUaW1lb3V0KGEuS2IpO2EuS2I9c2V0VGltZW91dChmdW5jdGlvbigpe2EuS2I9bnVsbDtiZihhKX0sTWF0aC5mbG9vcihiKSl9XG5oLmtnPWZ1bmN0aW9uKGEpe2EmJiF0aGlzLm5jJiZ0aGlzLldhPT09dGhpcy54ZCYmKHRoaXMuZihcIldpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LlwiKSx0aGlzLldhPTFFMyx0aGlzLk9hfHxPZSh0aGlzLDApKTt0aGlzLm5jPWF9O2guaWc9ZnVuY3Rpb24oYSl7YT8odGhpcy5mKFwiQnJvd3NlciB3ZW50IG9ubGluZS4gIFJlY29ubmVjdGluZy5cIiksdGhpcy5XYT0xRTMsdGhpcy5EYj0hMCx0aGlzLk9hfHxPZSh0aGlzLDApKToodGhpcy5mKFwiQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb247IGRvbid0IHJlY29ubmVjdC5cIiksdGhpcy5EYj0hMSx0aGlzLk9hJiZ0aGlzLk9hLmNsb3NlKCkpfTtcbmgub2Y9ZnVuY3Rpb24oKXt0aGlzLmYoXCJkYXRhIGNsaWVudCBkaXNjb25uZWN0ZWRcIik7dGhpcy5qYT0hMTt0aGlzLk9hPW51bGw7Zm9yKHZhciBhPTA7YTx0aGlzLmxhLmxlbmd0aDthKyspe3ZhciBiPXRoaXMubGFbYV07YiYmXCJoXCJpbiBiLnVmJiZiLnJnJiYoYi5IJiZiLkgoXCJkaXNjb25uZWN0XCIpLGRlbGV0ZSB0aGlzLmxhW2FdLHRoaXMuTmMtLSl9MD09PXRoaXMuTmMmJih0aGlzLmxhPVtdKTtpZih0aGlzLkRiKXRoaXMubmM/dGhpcy5EYyYmKDNFNDwobmV3IERhdGUpLmdldFRpbWUoKS10aGlzLkRjJiYodGhpcy5XYT0xRTMpLHRoaXMuRGM9bnVsbCk6KHRoaXMuZihcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKSx0aGlzLldhPXRoaXMueGQsdGhpcy5BZT0obmV3IERhdGUpLmdldFRpbWUoKSksYT1NYXRoLm1heCgwLHRoaXMuV2EtKChuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMuQWUpKSxhKj1NYXRoLnJhbmRvbSgpLHRoaXMuZihcIlRyeWluZyB0byByZWNvbm5lY3QgaW4gXCIrXG5hK1wibXNcIiksT2UodGhpcyxhKSx0aGlzLldhPU1hdGgubWluKHRoaXMueGQsMS4zKnRoaXMuV2EpO2Vsc2UgZm9yKHZhciBjIGluIHRoaXMuU2MpZGVsZXRlIHRoaXMuU2NbY107dGhpcy5CZCghMSl9O2Z1bmN0aW9uIGJmKGEpe2lmKGEuRGIpe2EuZihcIk1ha2luZyBhIGNvbm5lY3Rpb24gYXR0ZW1wdFwiKTthLkFlPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2EuRGM9bnVsbDt2YXIgYj1xKGEuQ2QsYSksYz1xKGEuS2MsYSksZD1xKGEub2YsYSksZT1hLmlkK1wiOlwiK1BlKys7YS5PYT1uZXcgd2UoZSxhLk8sYixjLGQsZnVuY3Rpb24oYil7eihiK1wiIChcIithLk8udG9TdHJpbmcoKStcIilcIik7YS5EYj0hMX0pfX1oLnFiPWZ1bmN0aW9uKCl7dGhpcy5EYj0hMTt0aGlzLk9hP3RoaXMuT2EuY2xvc2UoKToodGhpcy5LYiYmKGNsZWFyVGltZW91dCh0aGlzLktiKSx0aGlzLktiPW51bGwpLHRoaXMuamEmJnRoaXMub2YoKSl9O1xuaC5pYz1mdW5jdGlvbigpe3RoaXMuRGI9ITA7dGhpcy5XYT0xRTM7dGhpcy5PYXx8T2UodGhpcywwKX07ZnVuY3Rpb24gJGUoYSxiLGMpe2M9Yz9KYShjLGZ1bmN0aW9uKGEpe3JldHVybiB4YihhKX0pLmpvaW4oXCIkXCIpOlwiZGVmYXVsdFwiOyhhPVNlKGEsYixjKSkmJmEuSCYmYS5IKFwicGVybWlzc2lvbl9kZW5pZWRcIil9ZnVuY3Rpb24gU2UoYSxiLGMpe2I9KG5ldyBTKGIpKS50b1N0cmluZygpO3ZhciBkO20oYS50YVtiXSk/KGQ9YS50YVtiXVtjXSxkZWxldGUgYS50YVtiXVtjXSwwPT09SmIoYS50YVtiXSkmJmRlbGV0ZSBhLnRhW2JdKTpkPXZvaWQgMDtyZXR1cm4gZH1cbmZ1bmN0aW9uIGFmKGEpe1RlKGEpO0EoYS50YSxmdW5jdGlvbihiLGQpe0EoYixmdW5jdGlvbihiLGMpe1JlKGEsZCxjLGIpfSl9KTtmb3IodmFyIGI9MDtiPGEubGEubGVuZ3RoO2IrKylhLmxhW2JdJiZaZShhLGIpO2Zvcig7YS5KYy5sZW5ndGg7KWI9YS5KYy5zaGlmdCgpLFZlKGEsYi5hY3Rpb24sYi5QYyxiLmRhdGEsYi5IKX07ZnVuY3Rpb24gY2YoKXt0aGlzLm09dGhpcy5GPW51bGx9Y2YucHJvdG90eXBlLmVjPWZ1bmN0aW9uKGEsYil7aWYoYS5lKCkpdGhpcy5GPWIsdGhpcy5tPW51bGw7ZWxzZSBpZihudWxsIT09dGhpcy5GKXRoaXMuRj10aGlzLkYuRChhLGIpO2Vsc2V7bnVsbD09dGhpcy5tJiYodGhpcy5tPW5ldyBpZSk7dmFyIGM9SShhKTt0aGlzLm0uY29udGFpbnMoYyl8fHRoaXMubS5hZGQoYyxuZXcgY2YpO2M9dGhpcy5tLmdldChjKTthPVQoYSk7Yy5lYyhhLGIpfX07XG5mdW5jdGlvbiBkZihhLGIpe2lmKGIuZSgpKXJldHVybiBhLkY9bnVsbCxhLm09bnVsbCwhMDtpZihudWxsIT09YS5GKXtpZihhLkYuTSgpKXJldHVybiExO3ZhciBjPWEuRjthLkY9bnVsbDtjLlUoTCxmdW5jdGlvbihiLGMpe2EuZWMobmV3IFMoYiksYyl9KTtyZXR1cm4gZGYoYSxiKX1yZXR1cm4gbnVsbCE9PWEubT8oYz1JKGIpLGI9VChiKSxhLm0uY29udGFpbnMoYykmJmRmKGEubS5nZXQoYyksYikmJmEubS5yZW1vdmUoYyksYS5tLmUoKT8oYS5tPW51bGwsITApOiExKTohMH1mdW5jdGlvbiBlZihhLGIsYyl7bnVsbCE9PWEuRj9jKGIsYS5GKTphLlUoZnVuY3Rpb24oYSxlKXt2YXIgZj1uZXcgUyhiLnRvU3RyaW5nKCkrXCIvXCIrYSk7ZWYoZSxmLGMpfSl9Y2YucHJvdG90eXBlLlU9ZnVuY3Rpb24oYSl7bnVsbCE9PXRoaXMubSYmamUodGhpcy5tLGZ1bmN0aW9uKGIsYyl7YShiLGMpfSl9O2Z1bmN0aW9uIGZmKCl7dGhpcy5PZD1NfWZmLnByb3RvdHlwZS5qPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLk9kLnJhKGEpfTtmZi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5PZC50b1N0cmluZygpfTtmdW5jdGlvbiBnZigpe3RoaXMub2I9W119ZnVuY3Rpb24gaGYoYSxiKXtmb3IodmFyIGM9bnVsbCxkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF0sZj1lLlJiKCk7bnVsbD09PWN8fGYuYWEoYy5SYigpKXx8KGEub2IucHVzaChjKSxjPW51bGwpO251bGw9PT1jJiYoYz1uZXcgamYoZikpO2MuYWRkKGUpfWMmJmEub2IucHVzaChjKX1mdW5jdGlvbiBTYyhhLGIsYyl7aGYoYSxjKTtrZihhLGZ1bmN0aW9uKGEpe3JldHVybiBhLmFhKGIpfSl9ZnVuY3Rpb24gbGYoYSxiLGMpe2hmKGEsYyk7a2YoYSxmdW5jdGlvbihhKXtyZXR1cm4gYS5jb250YWlucyhiKXx8Yi5jb250YWlucyhhKX0pfVxuZnVuY3Rpb24ga2YoYSxiKXtmb3IodmFyIGM9ITAsZD0wO2Q8YS5vYi5sZW5ndGg7ZCsrKXt2YXIgZT1hLm9iW2RdO2lmKGUpaWYoZT1lLlJiKCksYihlKSl7Zm9yKHZhciBlPWEub2JbZF0sZj0wO2Y8ZS5sZC5sZW5ndGg7ZisrKXt2YXIgZz1lLmxkW2ZdO2lmKG51bGwhPT1nKXtlLmxkW2ZdPW51bGw7dmFyIGs9Zy5NYigpO2xiJiZoYihcImV2ZW50OiBcIitnLnRvU3RyaW5nKCkpO0NiKGspfX1hLm9iW2RdPW51bGx9ZWxzZSBjPSExfWMmJihhLm9iPVtdKX1mdW5jdGlvbiBqZihhKXt0aGlzLkVhPWE7dGhpcy5sZD1bXX1qZi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3RoaXMubGQucHVzaChhKX07amYucHJvdG90eXBlLlJiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRWF9O3ZhciBtZj1cImF1dGguZmlyZWJhc2UuY29tXCI7ZnVuY3Rpb24gbmYoYSxiLGMpe3RoaXMuY2Q9YXx8e307dGhpcy5aZD1ifHx7fTt0aGlzLlhhPWN8fHt9O3RoaXMuY2QucmVtZW1iZXJ8fCh0aGlzLmNkLnJlbWVtYmVyPVwiZGVmYXVsdFwiKX12YXIgb2Y9W1wicmVtZW1iZXJcIixcInJlZGlyZWN0VG9cIl07ZnVuY3Rpb24gcGYoYSl7dmFyIGI9e30sYz17fTt1YShhfHx7fSxmdW5jdGlvbihhLGUpezA8PUdhKG9mLGEpP2JbYV09ZTpjW2FdPWV9KTtyZXR1cm4gbmV3IG5mKGIse30sYyl9O3ZhciBxZj17TkVUV09SS19FUlJPUjpcIlVuYWJsZSB0byBjb250YWN0IHRoZSBGaXJlYmFzZSBzZXJ2ZXIuXCIsU0VSVkVSX0VSUk9SOlwiQW4gdW5rbm93biBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuXCIsVFJBTlNQT1JUX1VOQVZBSUxBQkxFOlwiVGhlcmUgYXJlIG5vIGxvZ2luIHRyYW5zcG9ydHMgYXZhaWxhYmxlIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZC5cIixSRVFVRVNUX0lOVEVSUlVQVEVEOlwiVGhlIGJyb3dzZXIgcmVkaXJlY3RlZCB0aGUgcGFnZSBiZWZvcmUgdGhlIGxvZ2luIHJlcXVlc3QgY291bGQgY29tcGxldGUuXCIsVVNFUl9DQU5DRUxMRUQ6XCJUaGUgdXNlciBjYW5jZWxsZWQgYXV0aGVudGljYXRpb24uXCJ9O2Z1bmN0aW9uIFgoYSl7dmFyIGI9RXJyb3IodChxZixhKSxhKTtiLmNvZGU9YTtyZXR1cm4gYn07ZnVuY3Rpb24gcmYoKXt2YXIgYT13aW5kb3cub3BlbmVyLmZyYW1lcyxiO2ZvcihiPWEubGVuZ3RoLTE7MDw9YjtiLS0pdHJ5e2lmKGFbYl0ubG9jYXRpb24ucHJvdG9jb2w9PT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wmJmFbYl0ubG9jYXRpb24uaG9zdD09PXdpbmRvdy5sb2NhdGlvbi5ob3N0JiZcIl9fd2luY2hhbl9yZWxheV9mcmFtZVwiPT09YVtiXS5uYW1lKXJldHVybiBhW2JdfWNhdGNoKGMpe31yZXR1cm4gbnVsbH1mdW5jdGlvbiBzZihhLGIsYyl7YS5hdHRhY2hFdmVudD9hLmF0dGFjaEV2ZW50KFwib25cIitiLGMpOmEuYWRkRXZlbnRMaXN0ZW5lciYmYS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9ZnVuY3Rpb24gdGYoYSxiLGMpe2EuZGV0YWNoRXZlbnQ/YS5kZXRhY2hFdmVudChcIm9uXCIrYixjKTphLnJlbW92ZUV2ZW50TGlzdGVuZXImJmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMsITEpfVxuZnVuY3Rpb24gdWYoYSl7L15odHRwcz86XFwvXFwvLy50ZXN0KGEpfHwoYT13aW5kb3cubG9jYXRpb24uaHJlZik7dmFyIGI9L14oaHR0cHM/OlxcL1xcL1tcXC1fYS16QS1aXFwuMC05Ol0rKS8uZXhlYyhhKTtyZXR1cm4gYj9iWzFdOmF9ZnVuY3Rpb24gdmYoYSl7dmFyIGI9XCJcIjt0cnl7YT1hLnJlcGxhY2UoXCIjXCIsXCJcIik7dmFyIGM9e30sZD1hLnJlcGxhY2UoL15cXD8vLFwiXCIpLnNwbGl0KFwiJlwiKTtmb3IoYT0wO2E8ZC5sZW5ndGg7YSsrKWlmKGRbYV0pe3ZhciBlPWRbYV0uc3BsaXQoXCI9XCIpO2NbZVswXV09ZVsxXX1jJiZzKGMsXCJfX2ZpcmViYXNlX3JlcXVlc3Rfa2V5XCIpJiYoYj10KGMsXCJfX2ZpcmViYXNlX3JlcXVlc3Rfa2V5XCIpKX1jYXRjaChmKXt9cmV0dXJuIGJ9XG5mdW5jdGlvbiB3ZihhKXt2YXIgYj1bXSxjO2ZvcihjIGluIGEpaWYocyhhLGMpKXt2YXIgZD10KGEsYyk7aWYoZWEoZCkpZm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspYi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZFtlXSkpO2Vsc2UgYi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQodChhLGMpKSl9cmV0dXJuIGI/XCImXCIrYi5qb2luKFwiJlwiKTpcIlwifWZ1bmN0aW9uIHhmKCl7dmFyIGE9cmIobWYpO3JldHVybiBhLnNjaGVtZStcIjovL1wiK2EuaG9zdCtcIi92MlwifWZ1bmN0aW9uIHlmKGEpe3JldHVybiB4ZigpK1wiL1wiK2ErXCIvYXV0aC9jaGFubmVsXCJ9O2Z1bmN0aW9uIHpmKCl7cmV0dXJuISEod2luZG93LmNvcmRvdmF8fHdpbmRvdy5waG9uZWdhcHx8d2luZG93LlBob25lR2FwKSYmL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9ZnVuY3Rpb24gQWYoKXt2YXIgYT1uYXZpZ2F0b3IudXNlckFnZW50O2lmKFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCI9PT1uYXZpZ2F0b3IuYXBwTmFtZSl7aWYoKGE9YS5tYXRjaCgvTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pKSYmMTxhLmxlbmd0aClyZXR1cm4gODw9cGFyc2VGbG9hdChhWzFdKX1lbHNlIGlmKC0xPGEuaW5kZXhPZihcIlRyaWRlbnRcIikmJihhPWEubWF0Y2goL3J2OihbMC05XXsyLDJ9W1xcLjAtOV17MCx9KS8pKSYmMTxhLmxlbmd0aClyZXR1cm4gODw9cGFyc2VGbG9hdChhWzFdKTtyZXR1cm4hMX07ZnVuY3Rpb24gQmYoYSl7YS5tZXRob2R8fChhLm1ldGhvZD1cIkdFVFwiKTthLmhlYWRlcnN8fChhLmhlYWRlcnM9e30pO2EuaGVhZGVycy5jb250ZW50X3R5cGV8fChhLmhlYWRlcnMuY29udGVudF90eXBlPVwiYXBwbGljYXRpb24vanNvblwiKTthLmhlYWRlcnMuY29udGVudF90eXBlPWEuaGVhZGVycy5jb250ZW50X3R5cGUudG9Mb3dlckNhc2UoKTt0aGlzLm9wdGlvbnM9YX1cbkJmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoWChcIlJFUVVFU1RfSU5URVJSVVBURURcIikpLGM9bnVsbCl9dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0LGY9dGhpcy5vcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpLGc7c2Yod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCk7ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZihjJiY0PT09ZS5yZWFkeVN0YXRlKXt2YXIgYTtpZigyMDA8PWUuc3RhdHVzJiYzMDA+ZS5zdGF0dXMpe3RyeXthPXRhKGUucmVzcG9uc2VUZXh0KX1jYXRjaChiKXt9YyhudWxsLGEpfWVsc2UgNTAwPD1lLnN0YXR1cyYmNjAwPmUuc3RhdHVzP2MoWChcIlNFUlZFUl9FUlJPUlwiKSk6YyhYKFwiTkVUV09SS19FUlJPUlwiKSk7Yz1udWxsO3RmKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpfX07aWYoXCJHRVRcIj09PWYpYSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikrd2YoYiksZz1udWxsO2Vsc2V7dmFyIGs9dGhpcy5vcHRpb25zLmhlYWRlcnMuY29udGVudF90eXBlO1xuXCJhcHBsaWNhdGlvbi9qc29uXCI9PT1rJiYoZz1yKGIpKTtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiPT09ayYmKGc9d2YoYikpfWUub3BlbihmLGEsITApO2E9e1wiWC1SZXF1ZXN0ZWQtV2l0aFwiOlwiWE1MSHR0cFJlcXVlc3RcIixBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uO3RleHQvcGxhaW5cIn07U2QoYSx0aGlzLm9wdGlvbnMuaGVhZGVycyk7Zm9yKHZhciBsIGluIGEpZS5zZXRSZXF1ZXN0SGVhZGVyKGwsYVtsXSk7ZS5zZW5kKGcpfTtCZi5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVybiEhd2luZG93LlhNTEh0dHBSZXF1ZXN0JiZcInN0cmluZ1wiPT09dHlwZW9mKG5ldyBYTUxIdHRwUmVxdWVzdCkucmVzcG9uc2VUeXBlJiYoIShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9NU0lFLyl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKSl8fEFmKCkpfTtCZi5wcm90b3R5cGUudGM9ZnVuY3Rpb24oKXtyZXR1cm5cImpzb25cIn07ZnVuY3Rpb24gQ2YoYSl7dGhpcy5nYz1GYSgpK0ZhKCkrRmEoKTt0aGlzLnBmPWF9XG5DZi5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZCgpe2MmJihjKFgoXCJVU0VSX0NBTkNFTExFRFwiKSksYz1udWxsKX12YXIgZT10aGlzLGY9cmIobWYpLGc7Yi5yZXF1ZXN0SWQ9dGhpcy5nYztiLnJlZGlyZWN0VG89Zi5zY2hlbWUrXCI6Ly9cIitmLmhvc3QrXCIvYmxhbmsvcGFnZS5odG1sXCI7YSs9L1xcPy8udGVzdChhKT9cIlwiOlwiP1wiO2ErPXdmKGIpOyhnPXdpbmRvdy5vcGVuKGEsXCJfYmxhbmtcIixcImxvY2F0aW9uPW5vXCIpKSYmaGEoZy5hZGRFdmVudExpc3RlbmVyKT8oZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsZnVuY3Rpb24oYSl7dmFyIGI7aWYoYj1hJiZhLnVybClhOnt2YXIgbj1hLnVybDt0cnl7dmFyIHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7dS5ocmVmPW47Yj11Lmhvc3Q9PT1mLmhvc3QmJlwiL2JsYW5rL3BhZ2UuaHRtbFwiPT09dS5wYXRobmFtZTticmVhayBhfWNhdGNoKHgpe31iPSExfWImJihhPXZmKGEudXJsKSxnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJleGl0XCIsXG5kKSxnLmNsb3NlKCksYT1uZXcgbmYobnVsbCxudWxsLHtyZXF1ZXN0SWQ6ZS5nYyxyZXF1ZXN0S2V5OmF9KSxlLnBmLnJlcXVlc3RXaXRoQ3JlZGVudGlhbChcIi9hdXRoL3Nlc3Npb25cIixhLGMpLGM9bnVsbCl9KSxnLmFkZEV2ZW50TGlzdGVuZXIoXCJleGl0XCIsZCkpOmMoWChcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9O0NmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHpmKCl9O0NmLnByb3RvdHlwZS50Yz1mdW5jdGlvbigpe3JldHVyblwicmVkaXJlY3RcIn07ZnVuY3Rpb24gRGYoYSl7aWYoIWEud2luZG93X2ZlYXR1cmVzfHwtMSE9PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZlbm5lYy9cIil8fC0xIT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveC9cIikmJi0xIT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSlhLndpbmRvd19mZWF0dXJlcz12b2lkIDA7YS53aW5kb3dfbmFtZXx8KGEud2luZG93X25hbWU9XCJfYmxhbmtcIik7dGhpcy5vcHRpb25zPWF9XG5EZi5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtnJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChnKSxnPXZvaWQgMCk7dSYmKHU9Y2xlYXJJbnRlcnZhbCh1KSk7dGYod2luZG93LFwibWVzc2FnZVwiLGUpO3RmKHdpbmRvdyxcInVubG9hZFwiLGQpO2lmKG4mJiFhKXRyeXtuLmNsb3NlKCl9Y2F0Y2goYil7ay5wb3N0TWVzc2FnZShcImRpZVwiLGwpfW49az12b2lkIDB9ZnVuY3Rpb24gZShhKXtpZihhLm9yaWdpbj09PWwpdHJ5e3ZhciBiPXRhKGEuZGF0YSk7XCJyZWFkeVwiPT09Yi5hP2sucG9zdE1lc3NhZ2UoeCxsKTpcImVycm9yXCI9PT1iLmE/KGQoITEpLGMmJihjKGIuZCksYz1udWxsKSk6XCJyZXNwb25zZVwiPT09Yi5hJiYoZChiLmZvcmNlS2VlcFdpbmRvd09wZW4pLGMmJihjKG51bGwsYi5kKSxjPW51bGwpKX1jYXRjaChlKXt9fXZhciBmPUFmKCksZyxrO2lmKCF0aGlzLm9wdGlvbnMucmVsYXlfdXJsKXJldHVybiBjKEVycm9yKFwiaW52YWxpZCBhcmd1bWVudHM6IG9yaWdpbiBvZiB1cmwgYW5kIHJlbGF5X3VybCBtdXN0IG1hdGNoXCIpKTtcbnZhciBsPXVmKGEpO2lmKGwhPT11Zih0aGlzLm9wdGlvbnMucmVsYXlfdXJsKSljJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YyhFcnJvcihcImludmFsaWQgYXJndW1lbnRzOiBvcmlnaW4gb2YgdXJsIGFuZCByZWxheV91cmwgbXVzdCBtYXRjaFwiKSl9LDApO2Vsc2V7ZiYmKGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKSxnLnNldEF0dHJpYnV0ZShcInNyY1wiLHRoaXMub3B0aW9ucy5yZWxheV91cmwpLGcuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixnLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcIl9fd2luY2hhbl9yZWxheV9mcmFtZVwiKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGcpLGs9Zy5jb250ZW50V2luZG93KTthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt3ZihiKTt2YXIgbj13aW5kb3cub3BlbihhLHRoaXMub3B0aW9ucy53aW5kb3dfbmFtZSx0aGlzLm9wdGlvbnMud2luZG93X2ZlYXR1cmVzKTtrfHwoaz1uKTt2YXIgdT1zZXRJbnRlcnZhbChmdW5jdGlvbigpe24mJm4uY2xvc2VkJiZcbihkKCExKSxjJiYoYyhYKFwiVVNFUl9DQU5DRUxMRURcIikpLGM9bnVsbCkpfSw1MDApLHg9cih7YTpcInJlcXVlc3RcIixkOmJ9KTtzZih3aW5kb3csXCJ1bmxvYWRcIixkKTtzZih3aW5kb3csXCJtZXNzYWdlXCIsZSl9fTtcbkRmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuXCJwb3N0TWVzc2FnZVwiaW4gd2luZG93JiYhL15maWxlOlxcLy8udGVzdChsb2NhdGlvbi5ocmVmKSYmISh6ZigpfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9XaW5kb3dzIFBob25lLyl8fHdpbmRvdy5XaW5kb3dzJiYvXm1zLWFwcHg6Ly50ZXN0KGxvY2F0aW9uLmhyZWYpfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kpfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DcmlPUy8pfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9Ud2l0dGVyIGZvciBpUGhvbmUvKXx8bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRkJBTlxcL0ZCSU9TLyl8fHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkmJiFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9QaGFudG9tSlMvKX07RGYucHJvdG90eXBlLnRjPWZ1bmN0aW9uKCl7cmV0dXJuXCJwb3B1cFwifTtmdW5jdGlvbiBFZihhKXthLmNhbGxiYWNrX3BhcmFtZXRlcnx8KGEuY2FsbGJhY2tfcGFyYW1ldGVyPVwiY2FsbGJhY2tcIik7dGhpcy5vcHRpb25zPWE7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucD13aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wfHx7fX1cbkVmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoWChcIlJFUVVFU1RfSU5URVJSVVBURURcIikpLGM9bnVsbCl9ZnVuY3Rpb24gZSgpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wW2ZdPXZvaWQgMDtQZCh3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wKSYmKHdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnA9dm9pZCAwKTt0cnl7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZik7YSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfWNhdGNoKGIpe319LDEpO3RmKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpfXZhciBmPVwiZm5cIisobmV3IERhdGUpLmdldFRpbWUoKStNYXRoLmZsb29yKDk5OTk5Kk1hdGgucmFuZG9tKCkpO2JbdGhpcy5vcHRpb25zLmNhbGxiYWNrX3BhcmFtZXRlcl09XCJfX2ZpcmViYXNlX2F1dGhfanNvbnAuXCIrZjthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt3ZihiKTtcbnNmKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpO3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnBbZl09ZnVuY3Rpb24oYSl7YyYmKGMobnVsbCxhKSxjPW51bGwpO2UoKX07RmYoZixhLGMpfTtcbmZ1bmN0aW9uIEZmKGEsYixjKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dHJ5e3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZC50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI7ZC5pZD1hO2QuYXN5bmM9ITA7ZC5zcmM9YjtkLm9uZXJyb3I9ZnVuY3Rpb24oKXt2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtudWxsIT09YiYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO2MmJmMoWChcIk5FVFdPUktfRVJST1JcIikpfTt2YXIgZT1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIik7KGUmJjAhPWUubGVuZ3RoP2VbMF06ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChkKX1jYXRjaChmKXtjJiZjKFgoXCJORVRXT1JLX0VSUk9SXCIpKX19LDApfUVmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIXpmKCl9O0VmLnByb3RvdHlwZS50Yz1mdW5jdGlvbigpe3JldHVyblwianNvblwifTtmdW5jdGlvbiBHZihhLGIpe3RoaXMuS2U9W1wic2Vzc2lvblwiLGEuSWQsYS51Yl0uam9pbihcIjpcIik7dGhpcy5XZD1ifUdmLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtpZighYilpZih0aGlzLldkLmxlbmd0aCliPXRoaXMuV2RbMF07ZWxzZSB0aHJvdyBFcnJvcihcImZiLmxvZ2luLlNlc3Npb25NYW5hZ2VyIDogTm8gc3RvcmFnZSBvcHRpb25zIGF2YWlsYWJsZSFcIik7Yi5zZXQodGhpcy5LZSxhKX07R2YucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhPUphKHRoaXMuV2QscSh0aGlzLlpmLHRoaXMpKSxhPUlhKGEsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT1hfSk7UWEoYSxmdW5jdGlvbihhLGMpe3JldHVybiBLZShjLnRva2VuKS1LZShhLnRva2VuKX0pO3JldHVybiAwPGEubGVuZ3RoP2Euc2hpZnQoKTpudWxsfTtHZi5wcm90b3R5cGUuWmY9ZnVuY3Rpb24oYSl7dHJ5e3ZhciBiPWEuZ2V0KHRoaXMuS2UpO2lmKGImJmIudG9rZW4pcmV0dXJuIGJ9Y2F0Y2goYyl7fXJldHVybiBudWxsfTtcbkdmLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7SGEodGhpcy5XZCxmdW5jdGlvbihiKXtiLnJlbW92ZShhLktlKX0pfTtmdW5jdGlvbiBIZihhKXt0aGlzLmdjPUZhKCkrRmEoKStGYSgpO3RoaXMucGY9YX1IZi5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIpe3Yuc2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiLHRoaXMuZ2MpO3Yuc2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiLHRoaXMuZ2MpO2IucmVxdWVzdElkPXRoaXMuZ2M7Yi5yZWRpcmVjdFRvPWIucmVkaXJlY3RUb3x8d2luZG93LmxvY2F0aW9uLmhyZWY7YSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikrd2YoYik7d2luZG93LmxvY2F0aW9uPWF9O0hmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIS9eZmlsZTpcXC8vLnRlc3QobG9jYXRpb24uaHJlZikmJiF6ZigpfTtIZi5wcm90b3R5cGUudGM9ZnVuY3Rpb24oKXtyZXR1cm5cInJlZGlyZWN0XCJ9O2Z1bmN0aW9uIElmKGEsYixjLGQpe0lkLmNhbGwodGhpcyxbXCJhdXRoX3N0YXR1c1wiXSk7dGhpcy5PPWE7dGhpcy5YZT1iO3RoaXMuRGc9Yzt0aGlzLkZlPWQ7dGhpcy5qYz1uZXcgR2YoYSxbemEsdl0pO3RoaXMuaWI9bnVsbDtKZih0aGlzKX1tYShJZixJZCk7aD1JZi5wcm90b3R5cGU7aC5yZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlifHxudWxsfTtmdW5jdGlvbiBKZihhKXt2LmdldChcInJlZGlyZWN0X3JlcXVlc3RfaWRcIikmJktmKGEpO3ZhciBiPWEuamMuZ2V0KCk7YiYmYi50b2tlbj8oTGYoYSxiKSxhLlhlKGIudG9rZW4sZnVuY3Rpb24oYyxkKXtNZihhLGMsZCwhMSxiLnRva2VuLGIpfSxmdW5jdGlvbihiLGQpe05mKGEsXCJyZXN1bWVTZXNzaW9uKClcIixiLGQpfSkpOkxmKGEsbnVsbCl9XG5mdW5jdGlvbiBPZihhLGIsYyxkLGUsZil7XCJmaXJlYmFzZWlvLWRlbW8uY29tXCI9PT1hLk8uZG9tYWluJiZ6KFwiRmlyZWJhc2UgYXV0aGVudGljYXRpb24gaXMgbm90IHN1cHBvcnRlZCBvbiBkZW1vIEZpcmViYXNlcyAoKi5maXJlYmFzZWlvLWRlbW8uY29tKS4gVG8gc2VjdXJlIHlvdXIgRmlyZWJhc2UsIGNyZWF0ZSBhIHByb2R1Y3Rpb24gRmlyZWJhc2UgYXQgaHR0cHM6Ly93d3cuZmlyZWJhc2UuY29tLlwiKTthLlhlKGIsZnVuY3Rpb24oZixrKXtNZihhLGYsaywhMCxiLGMsZHx8e30sZSl9LGZ1bmN0aW9uKGIsYyl7TmYoYSxcImF1dGgoKVwiLGIsYyxmKX0pfWZ1bmN0aW9uIFBmKGEsYil7YS5qYy5jbGVhcigpO0xmKGEsbnVsbCk7YS5EZyhmdW5jdGlvbihhLGQpe2lmKFwib2tcIj09PWEpQihiLG51bGwpO2Vsc2V7dmFyIGU9KGF8fFwiZXJyb3JcIikudG9VcHBlckNhc2UoKSxmPWU7ZCYmKGYrPVwiOiBcIitkKTtmPUVycm9yKGYpO2YuY29kZT1lO0IoYixmKX19KX1cbmZ1bmN0aW9uIE1mKGEsYixjLGQsZSxmLGcsayl7XCJva1wiPT09Yj8oZCYmKGI9Yy5hdXRoLGYuYXV0aD1iLGYuZXhwaXJlcz1jLmV4cGlyZXMsZi50b2tlbj1MZShlKT9lOlwiXCIsYz1udWxsLGImJnMoYixcInVpZFwiKT9jPXQoYixcInVpZFwiKTpzKGYsXCJ1aWRcIikmJihjPXQoZixcInVpZFwiKSksZi51aWQ9YyxjPVwiY3VzdG9tXCIsYiYmcyhiLFwicHJvdmlkZXJcIik/Yz10KGIsXCJwcm92aWRlclwiKTpzKGYsXCJwcm92aWRlclwiKSYmKGM9dChmLFwicHJvdmlkZXJcIikpLGYucHJvdmlkZXI9YyxhLmpjLmNsZWFyKCksTGUoZSkmJihnPWd8fHt9LGM9emEsXCJzZXNzaW9uT25seVwiPT09Zy5yZW1lbWJlciYmKGM9diksXCJub25lXCIhPT1nLnJlbWVtYmVyJiZhLmpjLnNldChmLGMpKSxMZihhLGYpKSxCKGssbnVsbCxmKSk6KGEuamMuY2xlYXIoKSxMZihhLG51bGwpLGY9YT0oYnx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGMmJihmKz1cIjogXCIrYyksZj1FcnJvcihmKSxmLmNvZGU9YSxCKGssZikpfVxuZnVuY3Rpb24gTmYoYSxiLGMsZCxlKXt6KGIrXCIgd2FzIGNhbmNlbGVkOiBcIitkKTthLmpjLmNsZWFyKCk7TGYoYSxudWxsKTthPUVycm9yKGQpO2EuY29kZT1jLnRvVXBwZXJDYXNlKCk7QihlLGEpfWZ1bmN0aW9uIFFmKGEsYixjLGQsZSl7UmYoYSk7Yz1uZXcgbmYoZHx8e30se30sY3x8e30pO1NmKGEsW0JmLEVmXSxcIi9hdXRoL1wiK2IsYyxlKX1cbmZ1bmN0aW9uIFRmKGEsYixjLGQpe1JmKGEpO3ZhciBlPVtEZixDZl07Yz1wZihjKTtcImFub255bW91c1wiPT09Ynx8XCJwYXNzd29yZFwiPT09Yj9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7QihkLFgoXCJUUkFOU1BPUlRfVU5BVkFJTEFCTEVcIikpfSwwKTooYy5aZC53aW5kb3dfZmVhdHVyZXM9XCJtZW51YmFyPXllcyxtb2RhbD15ZXMsYWx3YXlzUmFpc2VkPXllc2xvY2F0aW9uPXllcyxyZXNpemFibGU9eWVzLHNjcm9sbGJhcnM9eWVzLHN0YXR1cz15ZXMsaGVpZ2h0PTYyNSx3aWR0aD02MjUsdG9wPVwiKyhcIm9iamVjdFwiPT09dHlwZW9mIHNjcmVlbj8uNSooc2NyZWVuLmhlaWdodC02MjUpOjApK1wiLGxlZnQ9XCIrKFwib2JqZWN0XCI9PT10eXBlb2Ygc2NyZWVuPy41KihzY3JlZW4ud2lkdGgtNjI1KTowKSxjLlpkLnJlbGF5X3VybD15ZihhLk8udWIpLGMuWmQucmVxdWVzdFdpdGhDcmVkZW50aWFsPXEoYS5oYyxhKSxTZihhLGUsXCIvYXV0aC9cIitiLGMsZCkpfVxuZnVuY3Rpb24gS2YoYSl7dmFyIGI9di5nZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpO2lmKGIpe3ZhciBjPXYuZ2V0KFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIik7di5yZW1vdmUoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpO3YucmVtb3ZlKFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIik7dmFyIGQ9W0JmLEVmXSxiPXtyZXF1ZXN0SWQ6YixyZXF1ZXN0S2V5OnZmKGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpfSxjPW5ldyBuZihjLHt9LGIpO3RyeXtkb2N1bWVudC5sb2NhdGlvbi5oYXNoPWRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgvJl9fZmlyZWJhc2VfcmVxdWVzdF9rZXk9KFthLXpBLXowLTldKikvLFwiXCIpfWNhdGNoKGUpe31TZihhLGQsXCIvYXV0aC9zZXNzaW9uXCIsYyl9fWgubmU9ZnVuY3Rpb24oYSxiKXtSZih0aGlzKTt2YXIgYz1wZihhKTtjLlhhLl9tZXRob2Q9XCJQT1NUXCI7dGhpcy5oYyhcIi91c2Vyc1wiLGMsZnVuY3Rpb24oYSxjKXthP0IoYixhKTpCKGIsYSxjKX0pfTtcbmguTWU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO1JmKHRoaXMpO3ZhciBkPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLmVtYWlsKSxlPXBmKGEpO2UuWGEuX21ldGhvZD1cIkRFTEVURVwiO3RoaXMuaGMoZCxlLGZ1bmN0aW9uKGEsZCl7IWEmJmQmJmQudWlkJiZjLmliJiZjLmliLnVpZCYmYy5pYi51aWQ9PT1kLnVpZCYmUGYoYyk7QihiLGEpfSl9O2guamU9ZnVuY3Rpb24oYSxiKXtSZih0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5lbWFpbCkrXCIvcGFzc3dvcmRcIixkPXBmKGEpO2QuWGEuX21ldGhvZD1cIlBVVFwiO2QuWGEucGFzc3dvcmQ9YS5uZXdQYXNzd29yZDt0aGlzLmhjKGMsZCxmdW5jdGlvbihhKXtCKGIsYSl9KX07XG5oLmllPWZ1bmN0aW9uKGEsYil7UmYodGhpcyk7dmFyIGM9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEub2xkRW1haWwpK1wiL2VtYWlsXCIsZD1wZihhKTtkLlhhLl9tZXRob2Q9XCJQVVRcIjtkLlhhLmVtYWlsPWEubmV3RW1haWw7ZC5YYS5wYXNzd29yZD1hLnBhc3N3b3JkO3RoaXMuaGMoYyxkLGZ1bmN0aW9uKGEpe0IoYixhKX0pfTtoLk5lPWZ1bmN0aW9uKGEsYil7UmYodGhpcyk7dmFyIGM9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZW1haWwpK1wiL3Bhc3N3b3JkXCIsZD1wZihhKTtkLlhhLl9tZXRob2Q9XCJQT1NUXCI7dGhpcy5oYyhjLGQsZnVuY3Rpb24oYSl7QihiLGEpfSl9O2guaGM9ZnVuY3Rpb24oYSxiLGMpe1VmKHRoaXMsW0JmLEVmXSxhLGIsYyl9O1xuZnVuY3Rpb24gU2YoYSxiLGMsZCxlKXtVZihhLGIsYyxkLGZ1bmN0aW9uKGIsYyl7IWImJmMmJmMudG9rZW4mJmMudWlkP09mKGEsYy50b2tlbixjLGQuY2QsZnVuY3Rpb24oYSxiKXthP0IoZSxhKTpCKGUsbnVsbCxiKX0pOkIoZSxifHxYKFwiVU5LTk9XTl9FUlJPUlwiKSl9KX1cbmZ1bmN0aW9uIFVmKGEsYixjLGQsZSl7Yj1JYShiLGZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLmlzQXZhaWxhYmxlJiZhLmlzQXZhaWxhYmxlKCl9KTswPT09Yi5sZW5ndGg/c2V0VGltZW91dChmdW5jdGlvbigpe0IoZSxYKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKX0sMCk6KGI9bmV3IChiLnNoaWZ0KCkpKGQuWmQpLGQ9dmEoZC5YYSksZC52PVwianMtMi4yLjBcIixkLnRyYW5zcG9ydD1iLnRjKCksZC5zdXBwcmVzc19zdGF0dXNfY29kZXM9ITAsYT14ZigpK1wiL1wiK2EuTy51YitjLGIub3BlbihhLGQsZnVuY3Rpb24oYSxiKXtpZihhKUIoZSxhKTtlbHNlIGlmKGImJmIuZXJyb3Ipe3ZhciBjPUVycm9yKGIuZXJyb3IubWVzc2FnZSk7Yy5jb2RlPWIuZXJyb3IuY29kZTtjLmRldGFpbHM9Yi5lcnJvci5kZXRhaWxzO0IoZSxjKX1lbHNlIEIoZSxudWxsLGIpfSkpfVxuZnVuY3Rpb24gTGYoYSxiKXt2YXIgYz1udWxsIT09YS5pYnx8bnVsbCE9PWI7YS5pYj1iO2MmJmEuJGQoXCJhdXRoX3N0YXR1c1wiLGIpO2EuRmUobnVsbCE9PWIpfWgudWU9ZnVuY3Rpb24oYSl7eShcImF1dGhfc3RhdHVzXCI9PT1hLCdpbml0aWFsIGV2ZW50IG11c3QgYmUgb2YgdHlwZSBcImF1dGhfc3RhdHVzXCInKTtyZXR1cm5bdGhpcy5pYl19O2Z1bmN0aW9uIFJmKGEpe3ZhciBiPWEuTztpZihcImZpcmViYXNlaW8uY29tXCIhPT1iLmRvbWFpbiYmXCJmaXJlYmFzZWlvLWRlbW8uY29tXCIhPT1iLmRvbWFpbiYmXCJhdXRoLmZpcmViYXNlLmNvbVwiPT09bWYpdGhyb3cgRXJyb3IoXCJUaGlzIGN1c3RvbSBGaXJlYmFzZSBzZXJ2ZXIgKCdcIithLk8uZG9tYWluK1wiJykgZG9lcyBub3Qgc3VwcG9ydCBkZWxlZ2F0ZWQgbG9naW4uXCIpO307ZnVuY3Rpb24gVmYoYSxiKXtyZXR1cm4gYSYmXCJvYmplY3RcIj09PXR5cGVvZiBhPyh5KFwiLnN2XCJpbiBhLFwiVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHNcIiksYlthW1wiLnN2XCJdXSk6YX1mdW5jdGlvbiBXZihhLGIpe3ZhciBjPW5ldyBjZjtlZihhLG5ldyBTKFwiXCIpLGZ1bmN0aW9uKGEsZSl7Yy5lYyhhLFhmKGUsYikpfSk7cmV0dXJuIGN9ZnVuY3Rpb24gWGYoYSxiKXt2YXIgYz1hLkwoKS5JKCksYz1WZihjLGIpLGQ7aWYoYS5NKCkpe3ZhciBlPVZmKGEuemEoKSxiKTtyZXR1cm4gZSE9PWEuemEoKXx8YyE9PWEuTCgpLkkoKT9uZXcgcWQoZSxPKGMpKTphfWQ9YTtjIT09YS5MKCkuSSgpJiYoZD1kLiQobmV3IHFkKGMpKSk7YS5VKEwsZnVuY3Rpb24oYSxjKXt2YXIgZT1YZihjLGIpO2UhPT1jJiYoZD1kLlAoYSxlKSl9KTtyZXR1cm4gZH07ZnVuY3Rpb24gWWYoYSxiKXt0aGlzLnZhbHVlPWE7dGhpcy5jaGlsZHJlbj1ifHxaZn12YXIgWmY9bmV3IGJkKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9PT1iPzA6YTxiPy0xOjF9KSwkZj1uZXcgWWYobnVsbCk7ZnVuY3Rpb24gYWcoYSl7dmFyIGI9JGY7QShhLGZ1bmN0aW9uKGEsZCl7Yj1iLnNldChuZXcgUyhkKSxhKX0pO3JldHVybiBifWg9WWYucHJvdG90eXBlO2guZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZSYmdGhpcy5jaGlsZHJlbi5lKCl9O2Z1bmN0aW9uIGJnKGEsYixjKXtpZihudWxsIT1hLnZhbHVlJiZjKGEudmFsdWUpKXJldHVybntwYXRoOlUsdmFsdWU6YS52YWx1ZX07aWYoYi5lKCkpcmV0dXJuIG51bGw7dmFyIGQ9SShiKTthPWEuY2hpbGRyZW4uZ2V0KGQpO3JldHVybiBudWxsIT09YT8oYj1iZyhhLFQoYiksYyksbnVsbCE9Yj97cGF0aDoobmV3IFMoZCkpLnUoYi5wYXRoKSx2YWx1ZTpiLnZhbHVlfTpudWxsKTpudWxsfVxuZnVuY3Rpb24gY2coYSxiKXtyZXR1cm4gYmcoYSxiLGZ1bmN0aW9uKCl7cmV0dXJuITB9KX1oLnN1YnRyZWU9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy5jaGlsZHJlbi5nZXQoSShhKSk7cmV0dXJuIG51bGwhPT1iP2Iuc3VidHJlZShUKGEpKTokZn07aC5zZXQ9ZnVuY3Rpb24oYSxiKXtpZihhLmUoKSlyZXR1cm4gbmV3IFlmKGIsdGhpcy5jaGlsZHJlbik7dmFyIGM9SShhKSxkPSh0aGlzLmNoaWxkcmVuLmdldChjKXx8JGYpLnNldChUKGEpLGIpLGM9dGhpcy5jaGlsZHJlbi5MYShjLGQpO3JldHVybiBuZXcgWWYodGhpcy52YWx1ZSxjKX07XG5oLnJlbW92ZT1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpcy5jaGlsZHJlbi5lKCk/JGY6bmV3IFlmKG51bGwsdGhpcy5jaGlsZHJlbik7dmFyIGI9SShhKSxjPXRoaXMuY2hpbGRyZW4uZ2V0KGIpO3JldHVybiBjPyhhPWMucmVtb3ZlKFQoYSkpLGI9YS5lKCk/dGhpcy5jaGlsZHJlbi5yZW1vdmUoYik6dGhpcy5jaGlsZHJlbi5MYShiLGEpLG51bGw9PT10aGlzLnZhbHVlJiZiLmUoKT8kZjpuZXcgWWYodGhpcy52YWx1ZSxiKSk6dGhpc307aC5nZXQ9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXMudmFsdWU7dmFyIGI9dGhpcy5jaGlsZHJlbi5nZXQoSShhKSk7cmV0dXJuIGI/Yi5nZXQoVChhKSk6bnVsbH07XG5mdW5jdGlvbiBkZyhhLGIsYyl7aWYoYi5lKCkpcmV0dXJuIGM7dmFyIGQ9SShiKTtiPWRnKGEuY2hpbGRyZW4uZ2V0KGQpfHwkZixUKGIpLGMpO2Q9Yi5lKCk/YS5jaGlsZHJlbi5yZW1vdmUoZCk6YS5jaGlsZHJlbi5MYShkLGIpO3JldHVybiBuZXcgWWYoYS52YWx1ZSxkKX1mdW5jdGlvbiBlZyhhLGIpe3JldHVybiBmZyhhLFUsYil9ZnVuY3Rpb24gZmcoYSxiLGMpe3ZhciBkPXt9O2EuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYSxmKXtkW2FdPWZnKGYsYi51KGEpLGMpfSk7cmV0dXJuIGMoYixhLnZhbHVlLGQpfWZ1bmN0aW9uIGdnKGEsYixjKXtyZXR1cm4gaGcoYSxiLFUsYyl9ZnVuY3Rpb24gaGcoYSxiLGMsZCl7dmFyIGU9YS52YWx1ZT9kKGMsYS52YWx1ZSk6ITE7aWYoZSlyZXR1cm4gZTtpZihiLmUoKSlyZXR1cm4gbnVsbDtlPUkoYik7cmV0dXJuKGE9YS5jaGlsZHJlbi5nZXQoZSkpP2hnKGEsVChiKSxjLnUoZSksZCk6bnVsbH1cbmZ1bmN0aW9uIGlnKGEsYixjKXtpZighYi5lKCkpe3ZhciBkPSEwO2EudmFsdWUmJihkPWMoVSxhLnZhbHVlKSk7ITA9PT1kJiYoZD1JKGIpLChhPWEuY2hpbGRyZW4uZ2V0KGQpKSYmamcoYSxUKGIpLFUudShkKSxjKSl9fWZ1bmN0aW9uIGpnKGEsYixjLGQpe2lmKGIuZSgpKXJldHVybiBhO2EudmFsdWUmJmQoYyxhLnZhbHVlKTt2YXIgZT1JKGIpO3JldHVybihhPWEuY2hpbGRyZW4uZ2V0KGUpKT9qZyhhLFQoYiksYy51KGUpLGQpOiRmfWZ1bmN0aW9uIGtnKGEsYil7bGcoYSxVLGIpfWZ1bmN0aW9uIGxnKGEsYixjKXthLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsZSl7bGcoZSxiLnUoYSksYyl9KTthLnZhbHVlJiZjKGIsYS52YWx1ZSl9ZnVuY3Rpb24gbWcoYSxiKXthLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsZCl7ZC52YWx1ZSYmYihhLGQudmFsdWUpfSl9XG5oLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9e307a2codGhpcyxmdW5jdGlvbihiLGMpe2FbYi50b1N0cmluZygpXT1jLnRvU3RyaW5nKCl9KTtyZXR1cm4gcihhKX07ZnVuY3Rpb24gbmcoYSxiKXt0aGlzLmNlPWE7dGhpcy5PZj1ifWZ1bmN0aW9uIG9nKGEpe3RoaXMuRz1hfVxub2cucHJvdG90eXBlLllhPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBCYyxmO2lmKGIudHlwZT09PXBnKWIuc291cmNlLnFlP2M9cWcodGhpcyxhLGIucGF0aCxiLkdhLGMsZCxlKTooeShiLnNvdXJjZS5lZixcIlVua25vd24gc291cmNlLlwiKSxmPWIuc291cmNlLlRlLGM9cmcodGhpcyxhLGIucGF0aCxiLkdhLGMsZCxmLGUpKTtlbHNlIGlmKGIudHlwZT09PXNnKWIuc291cmNlLnFlP2M9dGcodGhpcyxhLGIucGF0aCxiLmNoaWxkcmVuLGMsZCxlKTooeShiLnNvdXJjZS5lZixcIlVua25vd24gc291cmNlLlwiKSxmPWIuc291cmNlLlRlLGM9dWcodGhpcyxhLGIucGF0aCxiLmNoaWxkcmVuLGMsZCxmLGUpKTtlbHNlIGlmKGIudHlwZT09PXZnKWlmKGIuT2UpaWYoZj1iLnBhdGgsbnVsbCE9Yy5rYyhmKSljPWE7ZWxzZXtiPW5ldyB4YyhjLGEsZCk7ZD1hLkIuaigpO2lmKGYuZSgpfHxcIi5wcmlvcml0eVwiPT09SShmKSl3ZyhhLm8oKSk/Yj1jLnBhKEFjKGEpKTooYj1hLm8oKS5qKCksXG55KGIgaW5zdGFuY2VvZiBXLFwic2VydmVyQ2hpbGRyZW4gd291bGQgYmUgY29tcGxldGUgaWYgbGVhZiBub2RlXCIpLGI9Yy5xYyhiKSksYj10aGlzLkcub2EoZCxiLGUpO2Vsc2V7Zj1JKGYpO3ZhciBnPWMuVGEoZixhLm8oKSk7bnVsbD09ZyYmeWMoYS5vKCksZikmJihnPWQuSyhmKSk7Yj1udWxsIT1nP3RoaXMuRy5EKGQsZixnLGIsZSk6YS5CLmooKS5EYShmKT90aGlzLkcuRChkLGYsTSxiLGUpOmQ7Yi5lKCkmJndnKGEubygpKSYmKGQ9Yy5wYShBYyhhKSksZC5NKCkmJihiPXRoaXMuRy5vYShiLGQsZSkpKX1kPXdnKGEubygpKXx8bnVsbCE9Yy5rYyhVKTtjPXhnKGEsYixkLHRoaXMuRy5DYSgpKX1lbHNlIGM9eWcodGhpcyxhLGIucGF0aCxjLGQsZSk7ZWxzZSBpZihiLnR5cGU9PT16ZylkPWIucGF0aCxiPWEubygpLGY9Yi5qKCksZz1iLlp8fGQuZSgpLGM9QWcodGhpcyxuZXcgQmcoYS5CLG5ldyB6YyhmLGcsYi5MYikpLGQsYyx3YyxlKTtlbHNlIHRocm93IGZiKFwiVW5rbm93biBvcGVyYXRpb24gdHlwZTogXCIrXG5iLnR5cGUpO2U9TGQoZS5aYSk7ZD1jO2I9ZC5CO2IuWiYmKGY9Yi5qKCkuTSgpfHxiLmooKS5lKCksZz1DZyhhKSwoMDxlLmxlbmd0aHx8IWEuQi5afHxmJiYhYi5qKCkuYWEoZyl8fCFiLmooKS5MKCkuYWEoZy5MKCkpKSYmZS5wdXNoKEZiKENnKGQpKSkpO3JldHVybiBuZXcgbmcoYyxlKX07XG5mdW5jdGlvbiBBZyhhLGIsYyxkLGUsZil7dmFyIGc9Yi5CO2lmKG51bGwhPWQua2MoYykpcmV0dXJuIGI7dmFyIGs7aWYoYy5lKCkpeSh3ZyhiLm8oKSksXCJJZiBjaGFuZ2UgcGF0aCBpcyBlbXB0eSwgd2UgbXVzdCBoYXZlIGNvbXBsZXRlIHNlcnZlciBkYXRhXCIpLGIubygpLkxiPyhlPUFjKGIpLGQ9ZC5xYyhlIGluc3RhbmNlb2YgVz9lOk0pKTpkPWQucGEoQWMoYikpLGY9YS5HLm9hKGIuQi5qKCksZCxmKTtlbHNle3ZhciBsPUkoYyk7aWYoXCIucHJpb3JpdHlcIj09bCl5KDE9PVRjKGMpLFwiQ2FuJ3QgaGF2ZSBhIHByaW9yaXR5IHdpdGggYWRkaXRpb25hbCBwYXRoIGNvbXBvbmVudHNcIiksZj1nLmooKSxrPWIubygpLmooKSxkPWQuJGMoYyxmLGspLGY9bnVsbCE9ZD9hLkcuJChmLGQpOmcuaigpO2Vsc2V7dmFyIG49VChjKTt5YyhnLGwpPyhrPWIubygpLmooKSxkPWQuJGMoYyxnLmooKSxrKSxkPW51bGwhPWQ/Zy5qKCkuSyhsKS5EKG4sZCk6Zy5qKCkuSyhsKSk6ZD1kLlRhKGwsYi5vKCkpO1xuZj1udWxsIT1kP2EuRy5EKGcuaigpLGwsZCxlLGYpOmcuaigpfX1yZXR1cm4geGcoYixmLGcuWnx8Yy5lKCksYS5HLkNhKCkpfWZ1bmN0aW9uIHJnKGEsYixjLGQsZSxmLGcsayl7dmFyIGw9Yi5vKCk7Zz1nP2EuRzphLkcuTmIoKTtpZihjLmUoKSlkPWcub2EobC5qKCksZCxudWxsKTtlbHNlIGlmKGcuQ2EoKSYmIWwuTGIpZD1sLmooKS5EKGMsZCksZD1nLm9hKGwuaigpLGQsbnVsbCk7ZWxzZXt2YXIgbj1JKGMpO2lmKChjLmUoKT8hbC5afHxsLkxiOiF5YyhsLEkoYykpKSYmMTxUYyhjKSlyZXR1cm4gYjtkPWwuaigpLksobikuRChUKGMpLGQpO2Q9XCIucHJpb3JpdHlcIj09bj9nLiQobC5qKCksZCk6Zy5EKGwuaigpLG4sZCx3YyxudWxsKX1sPWwuWnx8Yy5lKCk7Yj1uZXcgQmcoYi5CLG5ldyB6YyhkLGwsZy5DYSgpKSk7cmV0dXJuIEFnKGEsYixjLGUsbmV3IHhjKGUsYixmKSxrKX1cbmZ1bmN0aW9uIHFnKGEsYixjLGQsZSxmLGcpe3ZhciBrPWIuQjtlPW5ldyB4YyhlLGIsZik7aWYoYy5lKCkpZz1hLkcub2EoYi5CLmooKSxkLGcpLGE9eGcoYixnLCEwLGEuRy5DYSgpKTtlbHNlIGlmKGY9SShjKSxcIi5wcmlvcml0eVwiPT09ZilnPWEuRy4kKGIuQi5qKCksZCksYT14ZyhiLGcsay5aLGsuTGIpO2Vsc2V7dmFyIGw9VChjKTtjPWsuaigpLksoZik7aWYoIWwuZSgpKXt2YXIgbj1lLmZmKGYpO2Q9bnVsbCE9bj9cIi5wcmlvcml0eVwiPT09VWMobCkmJm4ucmEobC5wYXJlbnQoKSkuZSgpP246bi5EKGwsZCk6TX1jLmFhKGQpP2E9YjooZz1hLkcuRChrLmooKSxmLGQsZSxnKSxhPXhnKGIsZyxrLlosYS5HLkNhKCkpKX1yZXR1cm4gYX1cbmZ1bmN0aW9uIHRnKGEsYixjLGQsZSxmLGcpe3ZhciBrPWI7a2coZCxmdW5jdGlvbihkLG4pe3ZhciB1PWMudShkKTt5YyhiLkIsSSh1KSkmJihrPXFnKGEsayx1LG4sZSxmLGcpKX0pO2tnKGQsZnVuY3Rpb24oZCxuKXt2YXIgdT1jLnUoZCk7eWMoYi5CLEkodSkpfHwoaz1xZyhhLGssdSxuLGUsZixnKSl9KTtyZXR1cm4ga31mdW5jdGlvbiBEZyhhLGIpe2tnKGIsZnVuY3Rpb24oYixkKXthPWEuRChiLGQpfSk7cmV0dXJuIGF9XG5mdW5jdGlvbiB1ZyhhLGIsYyxkLGUsZixnLGspe2lmKGIubygpLmooKS5lKCkmJiF3ZyhiLm8oKSkpcmV0dXJuIGI7dmFyIGw9YjtjPWMuZSgpP2Q6ZGcoJGYsYyxkKTt2YXIgbj1iLm8oKS5qKCk7Yy5jaGlsZHJlbi5mYShmdW5jdGlvbihjLGQpe2lmKG4uRGEoYykpe3ZhciBGPWIubygpLmooKS5LKGMpLEY9RGcoRixkKTtsPXJnKGEsbCxuZXcgUyhjKSxGLGUsZixnLGspfX0pO2MuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYyxkKXt2YXIgRj0hd2coYi5vKCkpJiZudWxsPT1kLnZhbHVlO24uRGEoYyl8fEZ8fChGPWIubygpLmooKS5LKGMpLEY9RGcoRixkKSxsPXJnKGEsbCxuZXcgUyhjKSxGLGUsZixnLGspKX0pO3JldHVybiBsfVxuZnVuY3Rpb24geWcoYSxiLGMsZCxlLGYpe2lmKG51bGwhPWQua2MoYykpcmV0dXJuIGI7dmFyIGc9bmV3IHhjKGQsYixlKSxrPWU9Yi5CLmooKTtpZih3ZyhiLm8oKSkpe2lmKGMuZSgpKWU9ZC5wYShBYyhiKSksaz1hLkcub2EoYi5CLmooKSxlLGYpO2Vsc2UgaWYoXCIucHJpb3JpdHlcIj09PUkoYykpe3ZhciBsPWQuVGEoSShjKSxiLm8oKSk7bnVsbD09bHx8ZS5lKCl8fGUuTCgpLmFhKGwpfHwoaz1hLkcuJChlLGwpKX1lbHNlIGw9SShjKSxlPWQuVGEobCxiLm8oKSksbnVsbCE9ZSYmKGs9YS5HLkQoYi5CLmooKSxsLGUsZyxmKSk7ZT0hMH1lbHNlIGlmKGIuQi5afHxjLmUoKSlrPWUsZT1iLkIuaigpLGUuTSgpfHxlLlUoTCxmdW5jdGlvbihjKXt2YXIgZT1kLlRhKGMsYi5vKCkpO251bGwhPWUmJihrPWEuRy5EKGssYyxlLGcsZikpfSksZT1iLkIuWjtlbHNle2w9SShjKTtpZigxPT1UYyhjKXx8eWMoYi5CLGwpKWM9ZC5UYShsLGIubygpKSxudWxsIT1jJiYoaz1hLkcuRChlLGwsYyxcbmcsZikpO2U9ITF9cmV0dXJuIHhnKGIsayxlLGEuRy5DYSgpKX07ZnVuY3Rpb24gRWcoYSl7dGhpcy5XPWE7dGhpcy5nPWEubi5nfWZ1bmN0aW9uIEZnKGEsYixjLGQpe3ZhciBlPVtdLGY9W107SGEoYixmdW5jdGlvbihiKXtcImNoaWxkX2NoYW5nZWRcIj09PWIudHlwZSYmYS5nLndlKGIuRWUsYi5IYSkmJmYucHVzaChuZXcgQyhcImNoaWxkX21vdmVkXCIsYi5IYSxiLlVhKSl9KTtHZyhhLGUsXCJjaGlsZF9yZW1vdmVkXCIsYixkLGMpO0dnKGEsZSxcImNoaWxkX2FkZGVkXCIsYixkLGMpO0dnKGEsZSxcImNoaWxkX21vdmVkXCIsZixkLGMpO0dnKGEsZSxcImNoaWxkX2NoYW5nZWRcIixiLGQsYyk7R2coYSxlLEdiLGIsZCxjKTtyZXR1cm4gZX1mdW5jdGlvbiBHZyhhLGIsYyxkLGUsZil7ZD1JYShkLGZ1bmN0aW9uKGEpe3JldHVybiBhLnR5cGU9PT1jfSk7UWEoZCxxKGEuUWYsYSkpO0hhKGQsZnVuY3Rpb24oYyl7dmFyIGQ9SGcoYSxjLGYpO0hhKGUsZnVuY3Rpb24oZSl7ZS53ZihjLnR5cGUpJiZiLnB1c2goZS5jcmVhdGVFdmVudChkLGEuVykpfSl9KX1cbmZ1bmN0aW9uIEhnKGEsYixjKXtcInZhbHVlXCIhPT1iLnR5cGUmJlwiY2hpbGRfcmVtb3ZlZFwiIT09Yi50eXBlJiYoYi5LZD1jLmdmKGIuVWEsYi5IYSxhLmcpKTtyZXR1cm4gYn1FZy5wcm90b3R5cGUuUWY9ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1hLlVhfHxudWxsPT1iLlVhKXRocm93IGZiKFwiU2hvdWxkIG9ubHkgY29tcGFyZSBjaGlsZF8gZXZlbnRzLlwiKTtyZXR1cm4gdGhpcy5nLmNvbXBhcmUobmV3IE4oYS5VYSxhLkhhKSxuZXcgTihiLlVhLGIuSGEpKX07ZnVuY3Rpb24gemMoYSxiLGMpe3RoaXMuQT1hO3RoaXMuWj1iO3RoaXMuTGI9Y31mdW5jdGlvbiB3ZyhhKXtyZXR1cm4gYS5afWZ1bmN0aW9uIHljKGEsYil7cmV0dXJuIGEuWiYmIWEuTGJ8fGEuQS5EYShiKX16Yy5wcm90b3R5cGUuaj1mdW5jdGlvbigpe3JldHVybiB0aGlzLkF9O2Z1bmN0aW9uIEJnKGEsYil7dGhpcy5CPWE7dGhpcy5RZD1ifWZ1bmN0aW9uIHhnKGEsYixjLGQpe3JldHVybiBuZXcgQmcobmV3IHpjKGIsYyxkKSxhLlFkKX1mdW5jdGlvbiBDZyhhKXtyZXR1cm4gYS5CLlo/YS5CLmooKTpudWxsfUJnLnByb3RvdHlwZS5vPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUWR9O2Z1bmN0aW9uIEFjKGEpe3JldHVybiBhLlFkLlo/YS5RZC5qKCk6bnVsbH07ZnVuY3Rpb24gSWcoYSxiKXt0aGlzLlc9YTt2YXIgYz1hLm4sZD1uZXcgYmMoYy5nKSxjPU1jKGMpP25ldyBiYyhjLmcpOmMua2E/bmV3IERjKGMpOm5ldyBkYyhjKTt0aGlzLnNmPW5ldyBvZyhjKTt2YXIgZT1iLm8oKSxmPWIuQixnPWQub2EoTSxlLmooKSxudWxsKSxrPWMub2EoTSxmLmooKSxudWxsKTt0aGlzLklhPW5ldyBCZyhuZXcgemMoayxmLlosYy5DYSgpKSxuZXcgemMoZyxlLlosZC5DYSgpKSk7dGhpcy5WYT1bXTt0aGlzLlVmPW5ldyBFZyhhKX1mdW5jdGlvbiBKZyhhKXtyZXR1cm4gYS5XfWg9SWcucHJvdG90eXBlO2gubz1mdW5jdGlvbigpe3JldHVybiB0aGlzLklhLm8oKS5qKCl9O2guYmI9ZnVuY3Rpb24oYSl7dmFyIGI9QWModGhpcy5JYSk7cmV0dXJuIGImJihNYyh0aGlzLlcubil8fCFhLmUoKSYmIWIuSyhJKGEpKS5lKCkpP2IucmEoYSk6bnVsbH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLlZhLmxlbmd0aH07aC5HYj1mdW5jdGlvbihhKXt0aGlzLlZhLnB1c2goYSl9O1xuaC5nYj1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO2lmKGIpe3kobnVsbD09YSxcIkEgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXCIpO3ZhciBkPXRoaXMuVy5wYXRoO0hhKHRoaXMuVmEsZnVuY3Rpb24oYSl7KGE9YS5aZShiLGQpKSYmYy5wdXNoKGEpfSl9aWYoYSl7Zm9yKHZhciBlPVtdLGY9MDtmPHRoaXMuVmEubGVuZ3RoOysrZil7dmFyIGc9dGhpcy5WYVtmXTtpZighZy5tYXRjaGVzKGEpKWUucHVzaChnKTtlbHNlIGlmKGEuamYoKSl7ZT1lLmNvbmNhdCh0aGlzLlZhLnNsaWNlKGYrMSkpO2JyZWFrfX10aGlzLlZhPWV9ZWxzZSB0aGlzLlZhPVtdO3JldHVybiBjfTtcbmguWWE9ZnVuY3Rpb24oYSxiLGMpe2EudHlwZT09PXNnJiZudWxsIT09YS5zb3VyY2UuemImJih5KEFjKHRoaXMuSWEpLFwiV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzXCIpLHkoQ2codGhpcy5JYSksXCJNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlXCIpKTt2YXIgZD10aGlzLklhO2E9dGhpcy5zZi5ZYShkLGEsYixjKTtiPXRoaXMuc2Y7Yz1hLmNlO3koYy5CLmooKS5CYyhiLkcuZyksXCJFdmVudCBzbmFwIG5vdCBpbmRleGVkXCIpO3koYy5vKCkuaigpLkJjKGIuRy5nKSxcIlNlcnZlciBzbmFwIG5vdCBpbmRleGVkXCIpO3kod2coYS5jZS5vKCkpfHwhd2coZC5vKCkpLFwiT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFja1wiKTt0aGlzLklhPWEuY2U7cmV0dXJuIEtnKHRoaXMsYS5PZixhLmNlLkIuaigpLG51bGwpfTtcbmZ1bmN0aW9uIExnKGEsYil7dmFyIGM9YS5JYS5CLGQ9W107Yy5qKCkuTSgpfHxjLmooKS5VKEwsZnVuY3Rpb24oYSxiKXtkLnB1c2gobmV3IEMoXCJjaGlsZF9hZGRlZFwiLGIsYSkpfSk7Yy5aJiZkLnB1c2goRmIoYy5qKCkpKTtyZXR1cm4gS2coYSxkLGMuaigpLGIpfWZ1bmN0aW9uIEtnKGEsYixjLGQpe3JldHVybiBGZyhhLlVmLGIsYyxkP1tkXTphLlZhKX07ZnVuY3Rpb24gTWcoKXt0aGlzLndhPXt9fWg9TWcucHJvdG90eXBlO2guZT1mdW5jdGlvbigpe3JldHVybiBQZCh0aGlzLndhKX07aC5ZYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5zb3VyY2UuemI7aWYobnVsbCE9PWQpcmV0dXJuIGQ9dCh0aGlzLndhLGQpLHkobnVsbCE9ZCxcIlN5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuXCIpLGQuWWEoYSxiLGMpO3ZhciBlPVtdO0EodGhpcy53YSxmdW5jdGlvbihkKXtlPWUuY29uY2F0KGQuWWEoYSxiLGMpKX0pO3JldHVybiBlfTtoLkdiPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS5GYSgpLGc9dCh0aGlzLndhLGYpO2lmKCFnKXt2YXIgZz1jLnBhKGU/ZDpudWxsKSxrPSExO2c/az0hMDooZz1kIGluc3RhbmNlb2YgVz9jLnFjKGQpOk0saz0hMSk7Zz1uZXcgSWcoYSxuZXcgQmcobmV3IHpjKGcsaywhMSksbmV3IHpjKGQsZSwhMSkpKTt0aGlzLndhW2ZdPWd9Zy5HYihiKTtyZXR1cm4gTGcoZyxiKX07XG5oLmdiPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLkZhKCksZT1bXSxmPVtdLGc9bnVsbCE9TmcodGhpcyk7aWYoXCJkZWZhdWx0XCI9PT1kKXt2YXIgaz10aGlzO0EodGhpcy53YSxmdW5jdGlvbihhLGQpe2Y9Zi5jb25jYXQoYS5nYihiLGMpKTthLmUoKSYmKGRlbGV0ZSBrLndhW2RdLE1jKGEuVy5uKXx8ZS5wdXNoKGEuVykpfSl9ZWxzZXt2YXIgbD10KHRoaXMud2EsZCk7bCYmKGY9Zi5jb25jYXQobC5nYihiLGMpKSxsLmUoKSYmKGRlbGV0ZSB0aGlzLndhW2RdLE1jKGwuVy5uKXx8ZS5wdXNoKGwuVykpKX1nJiZudWxsPT1OZyh0aGlzKSYmZS5wdXNoKG5ldyBSKGEuayxhLnBhdGgpKTtyZXR1cm57c2c6ZSxWZjpmfX07ZnVuY3Rpb24gT2coYSl7cmV0dXJuIElhKExkKGEud2EpLGZ1bmN0aW9uKGEpe3JldHVybiFNYyhhLlcubil9KX1oLmJiPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7QSh0aGlzLndhLGZ1bmN0aW9uKGMpe2I9Ynx8Yy5iYihhKX0pO3JldHVybiBifTtcbmZ1bmN0aW9uIFBnKGEsYil7aWYoTWMoYi5uKSlyZXR1cm4gTmcoYSk7dmFyIGM9Yi5GYSgpO3JldHVybiB0KGEud2EsYyl9ZnVuY3Rpb24gTmcoYSl7cmV0dXJuIE9kKGEud2EsZnVuY3Rpb24oYSl7cmV0dXJuIE1jKGEuVy5uKX0pfHxudWxsfTtmdW5jdGlvbiBRZyhhKXt0aGlzLlg9YX12YXIgUmc9bmV3IFFnKG5ldyBZZihudWxsKSk7ZnVuY3Rpb24gU2coYSxiLGMpe2lmKGIuZSgpKXJldHVybiBuZXcgUWcobmV3IFlmKGMpKTt2YXIgZD1jZyhhLlgsYik7aWYobnVsbCE9ZCl7dmFyIGU9ZC5wYXRoLGQ9ZC52YWx1ZTtiPVYoZSxiKTtkPWQuRChiLGMpO3JldHVybiBuZXcgUWcoYS5YLnNldChlLGQpKX1hPWRnKGEuWCxiLG5ldyBZZihjKSk7cmV0dXJuIG5ldyBRZyhhKX1mdW5jdGlvbiBUZyhhLGIsYyl7dmFyIGQ9YTt1YShjLGZ1bmN0aW9uKGEsYyl7ZD1TZyhkLGIudShhKSxjKX0pO3JldHVybiBkfVFnLnByb3RvdHlwZS5MZD1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gUmc7YT1kZyh0aGlzLlgsYSwkZik7cmV0dXJuIG5ldyBRZyhhKX07ZnVuY3Rpb24gVWcoYSxiKXt2YXIgYz1jZyhhLlgsYik7cmV0dXJuIG51bGwhPWM/YS5YLmdldChjLnBhdGgpLnJhKFYoYy5wYXRoLGIpKTpudWxsfVxuZnVuY3Rpb24gVmcoYSl7dmFyIGI9W10sYz1hLlgudmFsdWU7bnVsbCE9Yz9jLk0oKXx8Yy5VKEwsZnVuY3Rpb24oYSxjKXtiLnB1c2gobmV3IE4oYSxjKSl9KTphLlguY2hpbGRyZW4uZmEoZnVuY3Rpb24oYSxjKXtudWxsIT1jLnZhbHVlJiZiLnB1c2gobmV3IE4oYSxjLnZhbHVlKSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBXZyhhLGIpe2lmKGIuZSgpKXJldHVybiBhO3ZhciBjPVVnKGEsYik7cmV0dXJuIG51bGwhPWM/bmV3IFFnKG5ldyBZZihjKSk6bmV3IFFnKGEuWC5zdWJ0cmVlKGIpKX1RZy5wcm90b3R5cGUuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLlguZSgpfTtRZy5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7cmV0dXJuIFhnKFUsdGhpcy5YLGEpfTtcbmZ1bmN0aW9uIFhnKGEsYixjKXtpZihudWxsIT1iLnZhbHVlKXJldHVybiBjLkQoYSxiLnZhbHVlKTt2YXIgZD1udWxsO2IuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYixmKXtcIi5wcmlvcml0eVwiPT09Yj8oeShudWxsIT09Zi52YWx1ZSxcIlByaW9yaXR5IHdyaXRlcyBtdXN0IGFsd2F5cyBiZSBsZWFmIG5vZGVzXCIpLGQ9Zi52YWx1ZSk6Yz1YZyhhLnUoYiksZixjKX0pO2MucmEoYSkuZSgpfHxudWxsPT09ZHx8KGM9Yy5EKGEudShcIi5wcmlvcml0eVwiKSxkKSk7cmV0dXJuIGN9O2Z1bmN0aW9uIFlnKCl7dGhpcy5UPVJnO3RoaXMueGE9W107dGhpcy5FYz0tMX1oPVlnLnByb3RvdHlwZTtcbmguTGQ9ZnVuY3Rpb24oYSl7dmFyIGI9TmEodGhpcy54YSxmdW5jdGlvbihiKXtyZXR1cm4gYi5kZT09PWF9KTt5KDA8PWIsXCJyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLlwiKTt2YXIgYz10aGlzLnhhW2JdO3RoaXMueGEuc3BsaWNlKGIsMSk7Zm9yKHZhciBkPWMudmlzaWJsZSxlPSExLGY9dGhpcy54YS5sZW5ndGgtMTtkJiYwPD1mOyl7dmFyIGc9dGhpcy54YVtmXTtnLnZpc2libGUmJihmPj1iJiZaZyhnLGMucGF0aCk/ZD0hMTpjLnBhdGguY29udGFpbnMoZy5wYXRoKSYmKGU9ITApKTtmLS19aWYoZCl7aWYoZSl0aGlzLlQ9JGcodGhpcy54YSxhaCxVKSx0aGlzLkVjPTA8dGhpcy54YS5sZW5ndGg/dGhpcy54YVt0aGlzLnhhLmxlbmd0aC0xXS5kZTotMTtlbHNlIGlmKGMuR2EpdGhpcy5UPXRoaXMuVC5MZChjLnBhdGgpO2Vsc2V7dmFyIGs9dGhpcztBKGMuY2hpbGRyZW4sZnVuY3Rpb24oYSxiKXtrLlQ9ay5ULkxkKGMucGF0aC51KGIpKX0pfXJldHVybiBjLnBhdGh9cmV0dXJuIG51bGx9O1xuaC5wYT1mdW5jdGlvbihhLGIsYyxkKXtpZihjfHxkKXt2YXIgZT1XZyh0aGlzLlQsYSk7cmV0dXJuIWQmJmUuZSgpP2I6ZHx8bnVsbCE9Ynx8bnVsbCE9VWcoZSxVKT8oZT0kZyh0aGlzLnhhLGZ1bmN0aW9uKGIpe3JldHVybihiLnZpc2libGV8fGQpJiYoIWN8fCEoMDw9R2EoYyxiLmRlKSkpJiYoYi5wYXRoLmNvbnRhaW5zKGEpfHxhLmNvbnRhaW5zKGIucGF0aCkpfSxhKSxiPWJ8fE0sZS5hcHBseShiKSk6bnVsbH1lPVVnKHRoaXMuVCxhKTtpZihudWxsIT1lKXJldHVybiBlO2U9V2codGhpcy5ULGEpO3JldHVybiBlLmUoKT9iOm51bGwhPWJ8fG51bGwhPVVnKGUsVSk/KGI9Ynx8TSxlLmFwcGx5KGIpKTpudWxsfTtcbmgucWM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1NLGQ9VWcodGhpcy5ULGEpO2lmKGQpZC5NKCl8fGQuVShMLGZ1bmN0aW9uKGEsYil7Yz1jLlAoYSxiKX0pO2Vsc2UgaWYoYil7dmFyIGU9V2codGhpcy5ULGEpO2IuVShMLGZ1bmN0aW9uKGEsYil7dmFyIGQ9V2coZSxuZXcgUyhhKSkuYXBwbHkoYik7Yz1jLlAoYSxkKX0pO0hhKFZnKGUpLGZ1bmN0aW9uKGEpe2M9Yy5QKGEubmFtZSxhLlYpfSl9ZWxzZSBlPVdnKHRoaXMuVCxhKSxIYShWZyhlKSxmdW5jdGlvbihhKXtjPWMuUChhLm5hbWUsYS5WKX0pO3JldHVybiBjfTtoLiRjPWZ1bmN0aW9uKGEsYixjLGQpe3koY3x8ZCxcIkVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdFwiKTthPWEudShiKTtpZihudWxsIT1VZyh0aGlzLlQsYSkpcmV0dXJuIG51bGw7YT1XZyh0aGlzLlQsYSk7cmV0dXJuIGEuZSgpP2QucmEoYik6YS5hcHBseShkLnJhKGIpKX07XG5oLlRhPWZ1bmN0aW9uKGEsYixjKXthPWEudShiKTt2YXIgZD1VZyh0aGlzLlQsYSk7cmV0dXJuIG51bGwhPWQ/ZDp5YyhjLGIpP1dnKHRoaXMuVCxhKS5hcHBseShjLmooKS5LKGIpKTpudWxsfTtoLmtjPWZ1bmN0aW9uKGEpe3JldHVybiBVZyh0aGlzLlQsYSl9O2guaGU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnO2E9V2codGhpcy5ULGEpO2c9VWcoYSxVKTtpZihudWxsPT1nKWlmKG51bGwhPWIpZz1hLmFwcGx5KGIpO2Vsc2UgcmV0dXJuW107Zz1nLmhiKGYpO2lmKGcuZSgpfHxnLk0oKSlyZXR1cm5bXTtiPVtdO2E9bWMoZik7ZT1lP2cuU2IoYyxmKTpnLlFiKGMsZik7Zm9yKGY9UChlKTtmJiZiLmxlbmd0aDxkOykwIT09YShmLGMpJiZiLnB1c2goZiksZj1QKGUpO3JldHVybiBifTtcbmZ1bmN0aW9uIFpnKGEsYil7cmV0dXJuIGEuR2E/YS5wYXRoLmNvbnRhaW5zKGIpOiEhTmQoYS5jaGlsZHJlbixmdW5jdGlvbihjLGQpe3JldHVybiBhLnBhdGgudShkKS5jb250YWlucyhiKX0pfWZ1bmN0aW9uIGFoKGEpe3JldHVybiBhLnZpc2libGV9XG5mdW5jdGlvbiAkZyhhLGIsYyl7Zm9yKHZhciBkPVJnLGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXTtpZihiKGYpKXt2YXIgZz1mLnBhdGg7aWYoZi5HYSljLmNvbnRhaW5zKGcpPyhnPVYoYyxnKSxkPVNnKGQsZyxmLkdhKSk6Zy5jb250YWlucyhjKSYmKGc9VihnLGMpLGQ9U2coZCxVLGYuR2EucmEoZykpKTtlbHNlIGlmKGYuY2hpbGRyZW4paWYoYy5jb250YWlucyhnKSlnPVYoYyxnKSxkPVRnKGQsZyxmLmNoaWxkcmVuKTtlbHNle2lmKGcuY29udGFpbnMoYykpaWYoZz1WKGcsYyksZy5lKCkpZD1UZyhkLFUsZi5jaGlsZHJlbik7ZWxzZSBpZihmPXQoZi5jaGlsZHJlbixJKGcpKSlmPWYucmEoVChnKSksZD1TZyhkLFUsZil9ZWxzZSB0aHJvdyBmYihcIldyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlblwiKTt9fXJldHVybiBkfWZ1bmN0aW9uIGJoKGEsYil7dGhpcy5FYj1hO3RoaXMuWD1ifWg9YmgucHJvdG90eXBlO1xuaC5wYT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuWC5wYSh0aGlzLkViLGEsYixjKX07aC5xYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5YLnFjKHRoaXMuRWIsYSl9O2guJGM9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLlguJGModGhpcy5FYixhLGIsYyl9O2gua2M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWC5rYyh0aGlzLkViLnUoYSkpfTtoLmhlPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuWC5oZSh0aGlzLkViLGEsYixjLGQsZSl9O2guVGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5YLlRhKHRoaXMuRWIsYSxiKX07aC51PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYmgodGhpcy5FYi51KGEpLHRoaXMuWCl9O2Z1bmN0aW9uIGNoKGEsYixjKXt0aGlzLnR5cGU9cGc7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLkdhPWN9Y2gucHJvdG90eXBlLk1jPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBjaCh0aGlzLnNvdXJjZSxVLHRoaXMuR2EuSyhhKSk6bmV3IGNoKHRoaXMuc291cmNlLFQodGhpcy5wYXRoKSx0aGlzLkdhKX07Y2gucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG92ZXJ3cml0ZTogXCIrdGhpcy5HYS50b1N0cmluZygpK1wiKVwifTtmdW5jdGlvbiBkaChhLGIpe3RoaXMudHlwZT12Zzt0aGlzLnNvdXJjZT1laDt0aGlzLnBhdGg9YTt0aGlzLk9lPWJ9ZGgucHJvdG90eXBlLk1jPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aC5lKCk/dGhpczpuZXcgZGgoVCh0aGlzLnBhdGgpLHRoaXMuT2UpfTtkaC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk9wZXJhdGlvbihcIit0aGlzLnBhdGgrXCI6IFwiK3RoaXMuc291cmNlLnRvU3RyaW5nKCkrXCIgYWNrIHdyaXRlIHJldmVydD1cIit0aGlzLk9lK1wiKVwifTtmdW5jdGlvbiBmaChhLGIpe3RoaXMudHlwZT16Zzt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1ifWZoLnByb3RvdHlwZS5NYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBmaCh0aGlzLnNvdXJjZSxVKTpuZXcgZmgodGhpcy5zb3VyY2UsVCh0aGlzLnBhdGgpKX07ZmgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIGxpc3Rlbl9jb21wbGV0ZSlcIn07ZnVuY3Rpb24gZ2goYSxiLGMpe3RoaXMudHlwZT1zZzt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1iO3RoaXMuY2hpbGRyZW49Y31naC5wcm90b3R5cGUuTWM9ZnVuY3Rpb24oYSl7aWYodGhpcy5wYXRoLmUoKSlyZXR1cm4gYT10aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFMoYSkpLGEuZSgpP251bGw6YS52YWx1ZT9uZXcgY2godGhpcy5zb3VyY2UsVSxhLnZhbHVlKTpuZXcgZ2godGhpcy5zb3VyY2UsVSxhKTt5KEkodGhpcy5wYXRoKT09PWEsXCJDYW4ndCBnZXQgYSBtZXJnZSBmb3IgYSBjaGlsZCBub3Qgb24gdGhlIHBhdGggb2YgdGhlIG9wZXJhdGlvblwiKTtyZXR1cm4gbmV3IGdoKHRoaXMuc291cmNlLFQodGhpcy5wYXRoKSx0aGlzLmNoaWxkcmVuKX07Z2gucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG1lcmdlOiBcIit0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkrXCIpXCJ9O3ZhciBwZz0wLHNnPTEsdmc9Mix6Zz0zO2Z1bmN0aW9uIGhoKGEsYixjLGQpe3RoaXMucWU9YTt0aGlzLmVmPWI7dGhpcy56Yj1jO3RoaXMuVGU9ZDt5KCFkfHxiLFwiVGFnZ2VkIHF1ZXJpZXMgbXVzdCBiZSBmcm9tIHNlcnZlci5cIil9dmFyIGVoPW5ldyBoaCghMCwhMSxudWxsLCExKSxpaD1uZXcgaGgoITEsITAsbnVsbCwhMSk7aGgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucWU/XCJ1c2VyXCI6dGhpcy5UZT9cInNlcnZlcihxdWVyeUlEPVwiK3RoaXMuemIrXCIpXCI6XCJzZXJ2ZXJcIn07ZnVuY3Rpb24gamgoYSl7dGhpcy5uYT0kZjt0aGlzLnliPW5ldyBZZzt0aGlzLldjPXt9O3RoaXMuY2M9e307dGhpcy5GYz1hfWZ1bmN0aW9uIGtoKGEsYixjLGQsZSl7dmFyIGY9YS55YixnPWU7eShkPmYuRWMsXCJTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lc1wiKTttKGcpfHwoZz0hMCk7Zi54YS5wdXNoKHtwYXRoOmIsR2E6YyxkZTpkLHZpc2libGU6Z30pO2cmJihmLlQ9U2coZi5ULGIsYykpO2YuRWM9ZDtyZXR1cm4gZT9saChhLG5ldyBjaChlaCxiLGMpKTpbXX1mdW5jdGlvbiBtaChhLGIsYyxkKXt2YXIgZT1hLnliO3koZD5lLkVjLFwiU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXNcIik7ZS54YS5wdXNoKHtwYXRoOmIsY2hpbGRyZW46YyxkZTpkLHZpc2libGU6ITB9KTtlLlQ9VGcoZS5ULGIsYyk7ZS5FYz1kO2M9YWcoYyk7cmV0dXJuIGxoKGEsbmV3IGdoKGVoLGIsYykpfVxuZnVuY3Rpb24gbmgoYSxiLGMpe2M9Y3x8ITE7Yj1hLnliLkxkKGIpO3JldHVybiBudWxsPT1iP1tdOmxoKGEsbmV3IGRoKGIsYykpfWZ1bmN0aW9uIG9oKGEsYixjKXtjPWFnKGMpO3JldHVybiBsaChhLG5ldyBnaChpaCxiLGMpKX1mdW5jdGlvbiBwaChhLGIsYyxkKXtkPVFkKGEuV2MsXCJfXCIrZCk7aWYobnVsbCE9ZCl7dmFyIGU9cWgoZCk7ZD1lLnBhdGg7ZT1lLnpiO2I9VihkLGIpO2M9bmV3IGNoKG5ldyBoaCghMSwhMCxlLCEwKSxiLGMpO3JldHVybiByaChhLGQsYyl9cmV0dXJuW119ZnVuY3Rpb24gc2goYSxiLGMsZCl7aWYoZD1RZChhLldjLFwiX1wiK2QpKXt2YXIgZT1xaChkKTtkPWUucGF0aDtlPWUuemI7Yj1WKGQsYik7Yz1hZyhjKTtjPW5ldyBnaChuZXcgaGgoITEsITAsZSwhMCksYixjKTtyZXR1cm4gcmgoYSxkLGMpfXJldHVybltdfVxuamgucHJvdG90eXBlLkdiPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wYXRoLGQ9bnVsbCxlPSExO2lnKHRoaXMubmEsYyxmdW5jdGlvbihhLGIpe3ZhciBmPVYoYSxjKTtkPWIuYmIoZik7ZT1lfHxudWxsIT1OZyhiKTtyZXR1cm4hZH0pO3ZhciBmPXRoaXMubmEuZ2V0KGMpO2Y/KGU9ZXx8bnVsbCE9TmcoZiksZD1kfHxmLmJiKFUpKTooZj1uZXcgTWcsdGhpcy5uYT10aGlzLm5hLnNldChjLGYpKTt2YXIgZztudWxsIT1kP2c9ITA6KGc9ITEsZD1NLG1nKHRoaXMubmEuc3VidHJlZShjKSxmdW5jdGlvbihhLGIpe3ZhciBjPWIuYmIoVSk7YyYmKGQ9ZC5QKGEsYykpfSkpO3ZhciBrPW51bGwhPVBnKGYsYSk7aWYoIWsmJiFNYyhhLm4pKXt2YXIgbD10aChhKTt5KCEobCBpbiB0aGlzLmNjKSxcIlZpZXcgZG9lcyBub3QgZXhpc3QsIGJ1dCB3ZSBoYXZlIGEgdGFnXCIpO3ZhciBuPXVoKys7dGhpcy5jY1tsXT1uO3RoaXMuV2NbXCJfXCIrbl09bH1nPWYuR2IoYSxiLG5ldyBiaChjLHRoaXMueWIpLFxuZCxnKTtrfHxlfHwoZj1QZyhmLGEpLGc9Zy5jb25jYXQodmgodGhpcyxhLGYpKSk7cmV0dXJuIGd9O1xuamgucHJvdG90eXBlLmdiPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLnBhdGgsZT10aGlzLm5hLmdldChkKSxmPVtdO2lmKGUmJihcImRlZmF1bHRcIj09PWEuRmEoKXx8bnVsbCE9UGcoZSxhKSkpe2Y9ZS5nYihhLGIsYyk7ZS5lKCkmJih0aGlzLm5hPXRoaXMubmEucmVtb3ZlKGQpKTtlPWYuc2c7Zj1mLlZmO2I9LTEhPT1OYShlLGZ1bmN0aW9uKGEpe3JldHVybiBNYyhhLm4pfSk7dmFyIGc9Z2codGhpcy5uYSxkLGZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPU5nKGIpfSk7aWYoYiYmIWcmJihkPXRoaXMubmEuc3VidHJlZShkKSwhZC5lKCkpKWZvcih2YXIgZD13aChkKSxrPTA7azxkLmxlbmd0aDsrK2spe3ZhciBsPWRba10sbj1sLlcsbD14aCh0aGlzLGwpO3RoaXMuRmMuUWUobix5aCh0aGlzLG4pLGwubmQsbC5IKX1pZighZyYmMDxlLmxlbmd0aCYmIWMpaWYoYil0aGlzLkZjLlZkKGEsbnVsbCk7ZWxzZXt2YXIgdT10aGlzO0hhKGUsZnVuY3Rpb24oYSl7YS5GYSgpO3ZhciBiPXUuY2NbdGgoYSldO1xudS5GYy5WZChhLGIpfSl9emgodGhpcyxlKX1yZXR1cm4gZn07amgucHJvdG90eXBlLnBhPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy55YixkPWdnKHRoaXMubmEsYSxmdW5jdGlvbihiLGMpe3ZhciBkPVYoYixhKTtpZihkPWMuYmIoZCkpcmV0dXJuIGR9KTtyZXR1cm4gYy5wYShhLGQsYiwhMCl9O2Z1bmN0aW9uIHdoKGEpe3JldHVybiBlZyhhLGZ1bmN0aW9uKGEsYyxkKXtpZihjJiZudWxsIT1OZyhjKSlyZXR1cm5bTmcoYyldO3ZhciBlPVtdO2MmJihlPU9nKGMpKTtBKGQsZnVuY3Rpb24oYSl7ZT1lLmNvbmNhdChhKX0pO3JldHVybiBlfSl9ZnVuY3Rpb24gemgoYSxiKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoOysrYyl7dmFyIGQ9YltjXTtpZighTWMoZC5uKSl7dmFyIGQ9dGgoZCksZT1hLmNjW2RdO2RlbGV0ZSBhLmNjW2RdO2RlbGV0ZSBhLldjW1wiX1wiK2VdfX19XG5mdW5jdGlvbiB2aChhLGIsYyl7dmFyIGQ9Yi5wYXRoLGU9eWgoYSxiKTtjPXhoKGEsYyk7Yj1hLkZjLlFlKGIsZSxjLm5kLGMuSCk7ZD1hLm5hLnN1YnRyZWUoZCk7aWYoZSl5KG51bGw9PU5nKGQudmFsdWUpLFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtlbHNlIGZvcihlPWVnKGQsZnVuY3Rpb24oYSxiLGMpe2lmKCFhLmUoKSYmYiYmbnVsbCE9TmcoYikpcmV0dXJuW0pnKE5nKGIpKV07dmFyIGQ9W107YiYmKGQ9ZC5jb25jYXQoSmEoT2coYiksZnVuY3Rpb24oYSl7cmV0dXJuIGEuV30pKSk7QShjLGZ1bmN0aW9uKGEpe2Q9ZC5jb25jYXQoYSl9KTtyZXR1cm4gZH0pLGQ9MDtkPGUubGVuZ3RoOysrZCljPWVbZF0sYS5GYy5WZChjLHloKGEsYykpO3JldHVybiBifVxuZnVuY3Rpb24geGgoYSxiKXt2YXIgYz1iLlcsZD15aChhLGMpO3JldHVybntuZDpmdW5jdGlvbigpe3JldHVybihiLm8oKXx8TSkuaGFzaCgpfSxIOmZ1bmN0aW9uKGIsZil7aWYoXCJva1wiPT09Yil7aWYoZiYmXCJvYmplY3RcIj09PXR5cGVvZiBmJiZzKGYsXCJ3XCIpKXt2YXIgZz10KGYsXCJ3XCIpO2VhKGcpJiYwPD1HYShnLFwibm9faW5kZXhcIikmJnooXCJVc2luZyBhbiB1bnNwZWNpZmllZCBpbmRleC4gQ29uc2lkZXIgYWRkaW5nIFwiKygnXCIuaW5kZXhPblwiOiBcIicrYy5uLmcudG9TdHJpbmcoKSsnXCInKStcIiBhdCBcIitjLnBhdGgudG9TdHJpbmcoKStcIiB0byB5b3VyIHNlY3VyaXR5IHJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcIil9aWYoZCl7dmFyIGs9Yy5wYXRoO2lmKGc9UWQoYS5XYyxcIl9cIitkKSl2YXIgbD1xaChnKSxnPWwucGF0aCxsPWwuemIsaz1WKGcsayksaz1uZXcgZmgobmV3IGhoKCExLCEwLGwsITApLGspLGc9cmgoYSxnLGspO2Vsc2UgZz1bXX1lbHNlIGc9bGgoYSxuZXcgZmgoaWgsXG5jLnBhdGgpKTtyZXR1cm4gZ31nPVwiVW5rbm93biBFcnJvclwiO1widG9vX2JpZ1wiPT09Yj9nPVwiVGhlIGRhdGEgcmVxdWVzdGVkIGV4Y2VlZHMgdGhlIG1heGltdW0gc2l6ZSB0aGF0IGNhbiBiZSBhY2Nlc3NlZCB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuXCI6XCJwZXJtaXNzaW9uX2RlbmllZFwiPT1iP2c9XCJDbGllbnQgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBkZXNpcmVkIGRhdGEuXCI6XCJ1bmF2YWlsYWJsZVwiPT1iJiYoZz1cIlRoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlXCIpO2c9RXJyb3IoYitcIjogXCIrZyk7Zy5jb2RlPWIudG9VcHBlckNhc2UoKTtyZXR1cm4gYS5nYihjLG51bGwsZyl9fX1mdW5jdGlvbiB0aChhKXtyZXR1cm4gYS5wYXRoLnRvU3RyaW5nKCkrXCIkXCIrYS5GYSgpfVxuZnVuY3Rpb24gcWgoYSl7dmFyIGI9YS5pbmRleE9mKFwiJFwiKTt5KC0xIT09YiYmYjxhLmxlbmd0aC0xLFwiQmFkIHF1ZXJ5S2V5LlwiKTtyZXR1cm57emI6YS5zdWJzdHIoYisxKSxwYXRoOm5ldyBTKGEuc3Vic3RyKDAsYikpfX1mdW5jdGlvbiB5aChhLGIpe3ZhciBjPXRoKGIpO3JldHVybiB0KGEuY2MsYyl9dmFyIHVoPTE7ZnVuY3Rpb24gcmgoYSxiLGMpe3ZhciBkPWEubmEuZ2V0KGIpO3koZCxcIk1pc3Npbmcgc3luYyBwb2ludCBmb3IgcXVlcnkgdGFnIHRoYXQgd2UncmUgdHJhY2tpbmdcIik7cmV0dXJuIGQuWWEoYyxuZXcgYmgoYixhLnliKSxudWxsKX1mdW5jdGlvbiBsaChhLGIpe3JldHVybiBBaChhLGIsYS5uYSxudWxsLG5ldyBiaChVLGEueWIpKX1cbmZ1bmN0aW9uIEFoKGEsYixjLGQsZSl7aWYoYi5wYXRoLmUoKSlyZXR1cm4gQmgoYSxiLGMsZCxlKTt2YXIgZj1jLmdldChVKTtudWxsPT1kJiZudWxsIT1mJiYoZD1mLmJiKFUpKTt2YXIgZz1bXSxrPUkoYi5wYXRoKSxsPWIuTWMoayk7aWYoKGM9Yy5jaGlsZHJlbi5nZXQoaykpJiZsKXZhciBuPWQ/ZC5LKGspOm51bGwsaz1lLnUoayksZz1nLmNvbmNhdChBaChhLGwsYyxuLGspKTtmJiYoZz1nLmNvbmNhdChmLllhKGIsZSxkKSkpO3JldHVybiBnfWZ1bmN0aW9uIEJoKGEsYixjLGQsZSl7dmFyIGY9Yy5nZXQoVSk7bnVsbD09ZCYmbnVsbCE9ZiYmKGQ9Zi5iYihVKSk7dmFyIGc9W107Yy5jaGlsZHJlbi5mYShmdW5jdGlvbihjLGYpe3ZhciBuPWQ/ZC5LKGMpOm51bGwsdT1lLnUoYykseD1iLk1jKGMpO3gmJihnPWcuY29uY2F0KEJoKGEseCxmLG4sdSkpKX0pO2YmJihnPWcuY29uY2F0KGYuWWEoYixlLGQpKSk7cmV0dXJuIGd9O2Z1bmN0aW9uIENoKGEpe3RoaXMuTz1hO3RoaXMuUmE9WmQoYSk7dGhpcy5iYT1uZXcgZ2Y7dGhpcy5BZD0xO3RoaXMuUz1uZXcgTWUodGhpcy5PLHEodGhpcy5EZCx0aGlzKSxxKHRoaXMuQmQsdGhpcykscSh0aGlzLkllLHRoaXMpKTt0aGlzLkFnPSRkKGEscShmdW5jdGlvbigpe3JldHVybiBuZXcgV2QodGhpcy5SYSx0aGlzLlMpfSx0aGlzKSk7dGhpcy5tYz1uZXcgV2M7dGhpcy54ZT1uZXcgZmY7dmFyIGI9dGhpczt0aGlzLnJkPW5ldyBqaCh7UWU6ZnVuY3Rpb24oYSxkLGUsZil7ZD1bXTtlPWIueGUuaihhLnBhdGgpO2UuZSgpfHwoZD1saChiLnJkLG5ldyBjaChpaCxhLnBhdGgsZSkpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmKFwib2tcIil9LDApKTtyZXR1cm4gZH0sVmQ6YmF9KTtEaCh0aGlzLFwiY29ubmVjdGVkXCIsITEpO3RoaXMuZ2E9bmV3IGNmO3RoaXMuUT1uZXcgSWYoYSxxKHRoaXMuUy5RLHRoaXMuUykscSh0aGlzLlMuVmUsdGhpcy5TKSxxKHRoaXMuRmUsdGhpcykpO3RoaXMuaGQ9XG4wO3RoaXMueWU9bnVsbDt0aGlzLk49bmV3IGpoKHtRZTpmdW5jdGlvbihhLGQsZSxmKXtRZShiLlMsYSxlLGQsZnVuY3Rpb24oZCxlKXt2YXIgbD1mKGQsZSk7bGYoYi5iYSxhLnBhdGgsbCl9KTtyZXR1cm5bXX0sVmQ6ZnVuY3Rpb24oYSxkKXt2YXIgZT1iLlMsZj1hLnBhdGgudG9TdHJpbmcoKSxnPWEuRmEoKTtlLmYoXCJVbmxpc3RlbiBjYWxsZWQgZm9yIFwiK2YrXCIgXCIrZyk7aWYoU2UoZSxmLGcpJiZlLmphKXt2YXIgaz1MYyhhLm4pO2UuZihcIlVubGlzdGVuIG9uIFwiK2YrXCIgZm9yIFwiK2cpO2Y9e3A6Zn07ZCYmKGYucT1rLGYudD1kKTtlLkJhKFwiblwiLGYpfX19KX1oPUNoLnByb3RvdHlwZTtoLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuTy5CYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuTy5ob3N0fTtoLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5PLnVifTtcbmZ1bmN0aW9uIEVoKGEpe2E9YS54ZS5qKG5ldyBTKFwiLmluZm8vc2VydmVyVGltZU9mZnNldFwiKSkuSSgpfHwwO3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpK2F9ZnVuY3Rpb24gRmgoYSl7YT1hPXt0aW1lc3RhbXA6RWgoYSl9O2EudGltZXN0YW1wPWEudGltZXN0YW1wfHwobmV3IERhdGUpLmdldFRpbWUoKTtyZXR1cm4gYX1oLkRkPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuaGQrKzt2YXIgZT1uZXcgUyhhKTtiPXRoaXMueWU/dGhpcy55ZShhLGIpOmI7YT1bXTtkP2M/KGI9d2QoYixmdW5jdGlvbihhKXtyZXR1cm4gTyhhKX0pLGE9c2godGhpcy5OLGUsYixkKSk6KGI9TyhiKSxhPXBoKHRoaXMuTixlLGIsZCkpOmM/KGQ9d2QoYixmdW5jdGlvbihhKXtyZXR1cm4gTyhhKX0pLGE9b2godGhpcy5OLGUsZCkpOihkPU8oYiksYT1saCh0aGlzLk4sbmV3IGNoKGloLGUsZCkpKTtkPWU7MDxhLmxlbmd0aCYmKGQ9R2godGhpcyxlKSk7bGYodGhpcy5iYSxkLGEpfTtcbmguQmQ9ZnVuY3Rpb24oYSl7RGgodGhpcyxcImNvbm5lY3RlZFwiLGEpOyExPT09YSYmSGgodGhpcyl9O2guSWU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt6YihhLGZ1bmN0aW9uKGEsZCl7RGgoYixkLGEpfSl9O2guRmU9ZnVuY3Rpb24oYSl7RGgodGhpcyxcImF1dGhlbnRpY2F0ZWRcIixhKX07ZnVuY3Rpb24gRGgoYSxiLGMpe2I9bmV3IFMoXCIvLmluZm8vXCIrYik7Yz1PKGMpO3ZhciBkPWEueGU7ZC5PZD1kLk9kLkQoYixjKTtjPWxoKGEucmQsbmV3IGNoKGloLGIsYykpO2xmKGEuYmEsYixjKX1cbmguQ2I9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5mKFwic2V0XCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmIsSWc6Y30pO3ZhciBlPUZoKHRoaXMpO2I9TyhiLGMpO3ZhciBlPVhmKGIsZSksZj10aGlzLkFkKyssZT1raCh0aGlzLk4sYSxlLGYsITApO2hmKHRoaXMuYmEsZSk7dmFyIGc9dGhpczt0aGlzLlMucHV0KGEudG9TdHJpbmcoKSxiLkkoITApLGZ1bmN0aW9uKGIsYyl7dmFyIGU9XCJva1wiPT09YjtlfHx6KFwic2V0IGF0IFwiK2ErXCIgZmFpbGVkOiBcIitiKTtlPW5oKGcuTixmLCFlKTtsZihnLmJhLGEsZSk7SWgoZCxiLGMpfSk7ZT1KaCh0aGlzLGEpO0doKHRoaXMsZSk7bGYodGhpcy5iYSxlLFtdKX07XG5oLnVwZGF0ZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5mKFwidXBkYXRlXCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmJ9KTt2YXIgZD0hMCxlPUZoKHRoaXMpLGY9e307QShiLGZ1bmN0aW9uKGEsYil7ZD0hMTt2YXIgYz1PKGEpO2ZbYl09WGYoYyxlKX0pO2lmKGQpaGIoXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpLEloKGMsXCJva1wiKTtlbHNle3ZhciBnPXRoaXMuQWQrKyxrPW1oKHRoaXMuTixhLGYsZyk7aGYodGhpcy5iYSxrKTt2YXIgbD10aGlzO1llKHRoaXMuUyxhLnRvU3RyaW5nKCksYixmdW5jdGlvbihiLGQpe3koXCJva1wiPT09Ynx8XCJwZXJtaXNzaW9uX2RlbmllZFwiPT09YixcIm1lcmdlIGF0IFwiK2ErXCIgZmFpbGVkLlwiKTt2YXIgZT1cIm9rXCI9PT1iO2V8fHooXCJ1cGRhdGUgYXQgXCIrYStcIiBmYWlsZWQ6IFwiK2IpO3ZhciBlPW5oKGwuTixnLCFlKSxmPWE7MDxlLmxlbmd0aCYmKGY9R2gobCxhKSk7bGYobC5iYSxmLGUpO0loKGMsYixcbmQpfSk7Yj1KaCh0aGlzLGEpO0doKHRoaXMsYik7bGYodGhpcy5iYSxhLFtdKX19O2Z1bmN0aW9uIEhoKGEpe2EuZihcIm9uRGlzY29ubmVjdEV2ZW50c1wiKTt2YXIgYj1GaChhKSxjPVtdO2VmKFdmKGEuZ2EsYiksVSxmdW5jdGlvbihiLGUpe2M9Yy5jb25jYXQobGgoYS5OLG5ldyBjaChpaCxiLGUpKSk7dmFyIGY9SmgoYSxiKTtHaChhLGYpfSk7YS5nYT1uZXcgY2Y7bGYoYS5iYSxVLGMpfWguR2U9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3RoaXMuUy5HZShhLnRvU3RyaW5nKCksZnVuY3Rpb24oZCxlKXtcIm9rXCI9PT1kJiZkZihjLmdhLGEpO0loKGIsZCxlKX0pfTtmdW5jdGlvbiBLaChhLGIsYyxkKXt2YXIgZT1PKGMpO1VlKGEuUyxiLnRvU3RyaW5nKCksZS5JKCEwKSxmdW5jdGlvbihjLGcpe1wib2tcIj09PWMmJmEuZ2EuZWMoYixlKTtJaChkLGMsZyl9KX1cbmZ1bmN0aW9uIExoKGEsYixjLGQsZSl7dmFyIGY9TyhjLGQpO1VlKGEuUyxiLnRvU3RyaW5nKCksZi5JKCEwKSxmdW5jdGlvbihjLGQpe1wib2tcIj09PWMmJmEuZ2EuZWMoYixmKTtJaChlLGMsZCl9KX1mdW5jdGlvbiBNaChhLGIsYyxkKXt2YXIgZT0hMCxmO2ZvcihmIGluIGMpZT0hMTtlPyhoYihcIm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIiksSWgoZCxcIm9rXCIpKTpXZShhLlMsYi50b1N0cmluZygpLGMsZnVuY3Rpb24oZSxmKXtpZihcIm9rXCI9PT1lKWZvcih2YXIgbCBpbiBjKXt2YXIgbj1PKGNbbF0pO2EuZ2EuZWMoYi51KGwpLG4pfUloKGQsZSxmKX0pfWZ1bmN0aW9uIFJjKGEsYixjKXtjPVwiLmluZm9cIj09PUkoYi5wYXRoKT9hLnJkLkdiKGIsYyk6YS5OLkdiKGIsYyk7U2MoYS5iYSxiLnBhdGgsYyl9aC5xYj1mdW5jdGlvbigpe3RoaXMuUy5xYigpfTtoLmljPWZ1bmN0aW9uKCl7dGhpcy5TLmljKCl9O1xuaC5SZT1mdW5jdGlvbihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe2E/KHRoaXMuVWR8fCh0aGlzLlVkPW5ldyBWZCh0aGlzLlJhKSksYT10aGlzLlVkLmdldCgpKTphPXRoaXMuUmEuZ2V0KCk7dmFyIGI9S2EoTWQoYSksZnVuY3Rpb24oYSxiKXtyZXR1cm4gTWF0aC5tYXgoYi5sZW5ndGgsYSl9LDApLGM7Zm9yKGMgaW4gYSl7Zm9yKHZhciBkPWFbY10sZT1jLmxlbmd0aDtlPGIrMjtlKyspYys9XCIgXCI7Y29uc29sZS5sb2coYytkKX19fTtoLlNlPWZ1bmN0aW9uKGEpe1VkKHRoaXMuUmEsYSk7dGhpcy5BZy56ZlthXT0hMH07aC5mPWZ1bmN0aW9uKGEpe2hiKFwicjpcIit0aGlzLlMuaWQrXCI6XCIsYXJndW1lbnRzKX07ZnVuY3Rpb24gSWgoYSxiLGMpe2EmJkNiKGZ1bmN0aW9uKCl7aWYoXCJva1wiPT1iKWEobnVsbCk7ZWxzZXt2YXIgZD0oYnx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGU9ZDtjJiYoZSs9XCI6IFwiK2MpO2U9RXJyb3IoZSk7ZS5jb2RlPWQ7YShlKX19KX07ZnVuY3Rpb24gTmgoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKCl7fWEuZihcInRyYW5zYWN0aW9uIG9uIFwiK2IpO3ZhciBnPW5ldyBSKGEsYik7Zy53YihcInZhbHVlXCIsZik7Yz17cGF0aDpiLHVwZGF0ZTpjLEg6ZCxzdGF0dXM6bnVsbCxxZjplYigpLFdlOmUseGY6MCxiZTpmdW5jdGlvbigpe2cuJGIoXCJ2YWx1ZVwiLGYpfSxlZTpudWxsLHlhOm51bGwsZWQ6bnVsbCxmZDpudWxsLGdkOm51bGx9O2Q9YS5OLnBhKGIsdm9pZCAwKXx8TTtjLmVkPWQ7ZD1jLnVwZGF0ZShkLkkoKSk7aWYobShkKSl7U2IoXCJ0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgXCIsZCk7Yy5zdGF0dXM9MTtlPVhjKGEubWMsYik7dmFyIGs9ZS56YSgpfHxbXTtrLnB1c2goYyk7WWMoZSxrKTtcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kJiZzKGQsXCIucHJpb3JpdHlcIik/KGs9dChkLFwiLnByaW9yaXR5XCIpLHkoUWIoayksXCJJbnZhbGlkIHByaW9yaXR5IHJldHVybmVkIGJ5IHRyYW5zYWN0aW9uLiBQcmlvcml0eSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwuXCIpKTpcbms9KGEuTi5wYShiKXx8TSkuTCgpLkkoKTtlPUZoKGEpO2Q9TyhkLGspO2U9WGYoZCxlKTtjLmZkPWQ7Yy5nZD1lO2MueWE9YS5BZCsrO2M9a2goYS5OLGIsZSxjLnlhLGMuV2UpO2xmKGEuYmEsYixjKTtPaChhKX1lbHNlIGMuYmUoKSxjLmZkPW51bGwsYy5nZD1udWxsLGMuSCYmKGE9bmV3IEQoYy5lZCxuZXcgUihhLGMucGF0aCksTCksYy5IKG51bGwsITEsYSkpfWZ1bmN0aW9uIE9oKGEsYil7dmFyIGM9Ynx8YS5tYztifHxQaChhLGMpO2lmKG51bGwhPT1jLnphKCkpe3ZhciBkPVFoKGEsYyk7eSgwPGQubGVuZ3RoLFwiU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZVwiKTtMYShkLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5zdGF0dXN9KSYmUmgoYSxjLnBhdGgoKSxkKX1lbHNlIGMubWQoKSYmYy5VKGZ1bmN0aW9uKGIpe09oKGEsYil9KX1cbmZ1bmN0aW9uIFJoKGEsYixjKXtmb3IodmFyIGQ9SmEoYyxmdW5jdGlvbihhKXtyZXR1cm4gYS55YX0pLGU9YS5OLnBhKGIsZCl8fE0sZD1lLGU9ZS5oYXNoKCksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1jW2ZdO3koMT09PWcuc3RhdHVzLFwidHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLlwiKTtnLnN0YXR1cz0yO2cueGYrKzt2YXIgaz1WKGIsZy5wYXRoKSxkPWQuRChrLGcuZmQpfWQ9ZC5JKCEwKTthLlMucHV0KGIudG9TdHJpbmcoKSxkLGZ1bmN0aW9uKGQpe2EuZihcInRyYW5zYWN0aW9uIHB1dCByZXNwb25zZVwiLHtwYXRoOmIudG9TdHJpbmcoKSxzdGF0dXM6ZH0pO3ZhciBlPVtdO2lmKFwib2tcIj09PWQpe2Q9W107Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKyl7Y1tmXS5zdGF0dXM9MztlPWUuY29uY2F0KG5oKGEuTixjW2ZdLnlhKSk7aWYoY1tmXS5IKXt2YXIgZz1jW2ZdLmdkLGs9bmV3IFIoYSxjW2ZdLnBhdGgpO2QucHVzaChxKGNbZl0uSCxcbm51bGwsbnVsbCwhMCxuZXcgRChnLGssTCkpKX1jW2ZdLmJlKCl9UGgoYSxYYyhhLm1jLGIpKTtPaChhKTtsZihhLmJhLGIsZSk7Zm9yKGY9MDtmPGQubGVuZ3RoO2YrKylDYihkW2ZdKX1lbHNle2lmKFwiZGF0YXN0YWxlXCI9PT1kKWZvcihmPTA7ZjxjLmxlbmd0aDtmKyspY1tmXS5zdGF0dXM9ND09PWNbZl0uc3RhdHVzPzU6MTtlbHNlIGZvcih6KFwidHJhbnNhY3Rpb24gYXQgXCIrYi50b1N0cmluZygpK1wiIGZhaWxlZDogXCIrZCksZj0wO2Y8Yy5sZW5ndGg7ZisrKWNbZl0uc3RhdHVzPTUsY1tmXS5lZT1kO0doKGEsYil9fSxlKX1mdW5jdGlvbiBHaChhLGIpe3ZhciBjPVNoKGEsYiksZD1jLnBhdGgoKSxjPVFoKGEsYyk7VGgoYSxjLGQpO3JldHVybiBkfVxuZnVuY3Rpb24gVGgoYSxiLGMpe2lmKDAhPT1iLmxlbmd0aCl7Zm9yKHZhciBkPVtdLGU9W10sZj1KYShiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnlhfSksZz0wO2c8Yi5sZW5ndGg7ZysrKXt2YXIgaz1iW2ddLGw9VihjLGsucGF0aCksbj0hMSx1O3kobnVsbCE9PWwsXCJyZXJ1blRyYW5zYWN0aW9uc1VuZGVyTm9kZV86IHJlbGF0aXZlUGF0aCBzaG91bGQgbm90IGJlIG51bGwuXCIpO2lmKDU9PT1rLnN0YXR1cyluPSEwLHU9ay5lZSxlPWUuY29uY2F0KG5oKGEuTixrLnlhLCEwKSk7ZWxzZSBpZigxPT09ay5zdGF0dXMpaWYoMjU8PWsueGYpbj0hMCx1PVwibWF4cmV0cnlcIixlPWUuY29uY2F0KG5oKGEuTixrLnlhLCEwKSk7ZWxzZXt2YXIgeD1hLk4ucGEoay5wYXRoLGYpfHxNO2suZWQ9eDt2YXIgRj1iW2ddLnVwZGF0ZSh4LkkoKSk7bShGKT8oU2IoXCJ0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgXCIsRiksbD1PKEYpLFwib2JqZWN0XCI9PT10eXBlb2YgRiYmbnVsbCE9RiYmcyhGLFxuXCIucHJpb3JpdHlcIil8fChsPWwuJCh4LkwoKSkpLHg9ay55YSxGPUZoKGEpLEY9WGYobCxGKSxrLmZkPWwsay5nZD1GLGsueWE9YS5BZCsrLE9hKGYseCksZT1lLmNvbmNhdChraChhLk4say5wYXRoLEYsay55YSxrLldlKSksZT1lLmNvbmNhdChuaChhLk4seCwhMCkpKToobj0hMCx1PVwibm9kYXRhXCIsZT1lLmNvbmNhdChuaChhLk4say55YSwhMCkpKX1sZihhLmJhLGMsZSk7ZT1bXTtuJiYoYltnXS5zdGF0dXM9MyxzZXRUaW1lb3V0KGJbZ10uYmUsTWF0aC5mbG9vcigwKSksYltnXS5IJiYoXCJub2RhdGFcIj09PXU/KGs9bmV3IFIoYSxiW2ddLnBhdGgpLGQucHVzaChxKGJbZ10uSCxudWxsLG51bGwsITEsbmV3IEQoYltnXS5lZCxrLEwpKSkpOmQucHVzaChxKGJbZ10uSCxudWxsLEVycm9yKHUpLCExLG51bGwpKSkpfVBoKGEsYS5tYyk7Zm9yKGc9MDtnPGQubGVuZ3RoO2crKylDYihkW2ddKTtPaChhKX19XG5mdW5jdGlvbiBTaChhLGIpe2Zvcih2YXIgYyxkPWEubWM7bnVsbCE9PShjPUkoYikpJiZudWxsPT09ZC56YSgpOylkPVhjKGQsYyksYj1UKGIpO3JldHVybiBkfWZ1bmN0aW9uIFFoKGEsYil7dmFyIGM9W107VWgoYSxiLGMpO2Muc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLnFmLWIucWZ9KTtyZXR1cm4gY31mdW5jdGlvbiBVaChhLGIsYyl7dmFyIGQ9Yi56YSgpO2lmKG51bGwhPT1kKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWMucHVzaChkW2VdKTtiLlUoZnVuY3Rpb24oYil7VWgoYSxiLGMpfSl9ZnVuY3Rpb24gUGgoYSxiKXt2YXIgYz1iLnphKCk7aWYoYyl7Zm9yKHZhciBkPTAsZT0wO2U8Yy5sZW5ndGg7ZSsrKTMhPT1jW2VdLnN0YXR1cyYmKGNbZF09Y1tlXSxkKyspO2MubGVuZ3RoPWQ7WWMoYiwwPGMubGVuZ3RoP2M6bnVsbCl9Yi5VKGZ1bmN0aW9uKGIpe1BoKGEsYil9KX1cbmZ1bmN0aW9uIEpoKGEsYil7dmFyIGM9U2goYSxiKS5wYXRoKCksZD1YYyhhLm1jLGIpO2FkKGQsZnVuY3Rpb24oYil7VmgoYSxiKX0pO1ZoKGEsZCk7JGMoZCxmdW5jdGlvbihiKXtWaChhLGIpfSk7cmV0dXJuIGN9XG5mdW5jdGlvbiBWaChhLGIpe3ZhciBjPWIuemEoKTtpZihudWxsIT09Yyl7Zm9yKHZhciBkPVtdLGU9W10sZj0tMSxnPTA7ZzxjLmxlbmd0aDtnKyspNCE9PWNbZ10uc3RhdHVzJiYoMj09PWNbZ10uc3RhdHVzPyh5KGY9PT1nLTEsXCJBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLlwiKSxmPWcsY1tnXS5zdGF0dXM9NCxjW2ddLmVlPVwic2V0XCIpOih5KDE9PT1jW2ddLnN0YXR1cyxcIlVuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0XCIpLGNbZ10uYmUoKSxlPWUuY29uY2F0KG5oKGEuTixjW2ddLnlhLCEwKSksY1tnXS5IJiZkLnB1c2gocShjW2ddLkgsbnVsbCxFcnJvcihcInNldFwiKSwhMSxudWxsKSkpKTstMT09PWY/WWMoYixudWxsKTpjLmxlbmd0aD1mKzE7bGYoYS5iYSxiLnBhdGgoKSxlKTtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKUNiKGRbZ10pfX07ZnVuY3Rpb24gV2goKXt0aGlzLmZjPXt9fWNhKFdoKTtXaC5wcm90b3R5cGUucWI9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5mYyl0aGlzLmZjW2FdLnFiKCl9O1doLnByb3RvdHlwZS5pbnRlcnJ1cHQ9V2gucHJvdG90eXBlLnFiO1doLnByb3RvdHlwZS5pYz1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLmZjKXRoaXMuZmNbYV0uaWMoKX07V2gucHJvdG90eXBlLnJlc3VtZT1XaC5wcm90b3R5cGUuaWM7ZnVuY3Rpb24gWGgoYSl7dmFyIGI9dGhpczt0aGlzLnNjPWE7dGhpcy5YZD1cIipcIjtBZigpP3RoaXMuSGM9dGhpcy5wZD1yZigpOih0aGlzLkhjPXdpbmRvdy5vcGVuZXIsdGhpcy5wZD13aW5kb3cpO2lmKCFiLkhjKXRocm93XCJVbmFibGUgdG8gZmluZCByZWxheSBmcmFtZVwiO3NmKHRoaXMucGQsXCJtZXNzYWdlXCIscSh0aGlzLmFjLHRoaXMpKTtzZih0aGlzLnBkLFwibWVzc2FnZVwiLHEodGhpcy5uZix0aGlzKSk7dHJ5e1loKHRoaXMse2E6XCJyZWFkeVwifSl9Y2F0Y2goYyl7c2YodGhpcy5IYyxcImxvYWRcIixmdW5jdGlvbigpe1loKGIse2E6XCJyZWFkeVwifSl9KX1zZih3aW5kb3csXCJ1bmxvYWRcIixxKHRoaXMuamcsdGhpcykpfWZ1bmN0aW9uIFloKGEsYil7Yj1yKGIpO0FmKCk/YS5IYy5kb1Bvc3QoYixhLlhkKTphLkhjLnBvc3RNZXNzYWdlKGIsYS5YZCl9XG5YaC5wcm90b3R5cGUuYWM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjO3RyeXtjPXRhKGEuZGF0YSl9Y2F0Y2goZCl7fWMmJlwicmVxdWVzdFwiPT09Yy5hJiYodGYod2luZG93LFwibWVzc2FnZVwiLHRoaXMuYWMpLHRoaXMuWGQ9YS5vcmlnaW4sdGhpcy5zYyYmc2V0VGltZW91dChmdW5jdGlvbigpe2Iuc2MoYi5YZCxjLmQsZnVuY3Rpb24oYSxjKXtiLk1mPSFjO2Iuc2M9dm9pZCAwO1loKGIse2E6XCJyZXNwb25zZVwiLGQ6YSxmb3JjZUtlZXBXaW5kb3dPcGVuOmN9KX0pfSwwKSl9O1hoLnByb3RvdHlwZS5qZz1mdW5jdGlvbigpe3RyeXt0Zih0aGlzLnBkLFwibWVzc2FnZVwiLHRoaXMubmYpfWNhdGNoKGEpe310aGlzLnNjJiYoWWgodGhpcyx7YTpcImVycm9yXCIsZDpcInVua25vd24gY2xvc2VkIHdpbmRvd1wifSksdGhpcy5zYz12b2lkIDApO3RyeXt3aW5kb3cuY2xvc2UoKX1jYXRjaChiKXt9fTtYaC5wcm90b3R5cGUubmY9ZnVuY3Rpb24oYSl7aWYodGhpcy5NZiYmXCJkaWVcIj09PWEuZGF0YSl0cnl7d2luZG93LmNsb3NlKCl9Y2F0Y2goYil7fX07dmFyIFk9e1hmOmZ1bmN0aW9uKCl7bGU9Y2U9ITB9fTtZLmZvcmNlTG9uZ1BvbGxpbmc9WS5YZjtZLllmPWZ1bmN0aW9uKCl7bWU9ITB9O1kuZm9yY2VXZWJTb2NrZXRzPVkuWWY7WS54Zz1mdW5jdGlvbihhLGIpe2Euay5TLlBlPWJ9O1kuc2V0U2VjdXJpdHlEZWJ1Z0NhbGxiYWNrPVkueGc7WS5SZT1mdW5jdGlvbihhLGIpe2Euay5SZShiKX07WS5zdGF0cz1ZLlJlO1kuU2U9ZnVuY3Rpb24oYSxiKXthLmsuU2UoYil9O1kuc3RhdHNJbmNyZW1lbnRDb3VudGVyPVkuU2U7WS5oZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLmhkfTtZLmRhdGFVcGRhdGVDb3VudD1ZLmhkO1kuYWc9ZnVuY3Rpb24oYSxiKXthLmsueWU9Yn07WS5pbnRlcmNlcHRTZXJ2ZXJEYXRhPVkuYWc7WS5nZz1mdW5jdGlvbihhKXtuZXcgWGgoYSl9O1kub25Qb3B1cE9wZW49WS5nZztZLnZnPWZ1bmN0aW9uKGEpe21mPWF9O1kuc2V0QXV0aGVudGljYXRpb25TZXJ2ZXI9WS52ZztmdW5jdGlvbiBaKGEsYil7dGhpcy5SYz1hO3RoaXMuRWE9Yn1aLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuY2FuY2VsXCIsMSxhLCEwKTt0aGlzLlJjLkdlKHRoaXMuRWEsYXx8bnVsbCl9O1oucHJvdG90eXBlLmNhbmNlbD1aLnByb3RvdHlwZS5jYW5jZWw7Wi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe0UoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIix0aGlzLkVhKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsMSxhLCEwKTtLaCh0aGlzLlJjLHRoaXMuRWEsbnVsbCxhKX07Wi5wcm90b3R5cGUucmVtb3ZlPVoucHJvdG90eXBlLnJlbW92ZTtcbloucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwyLGIsITApO0toKHRoaXMuUmMsdGhpcy5FYSxhLGIpfTtaLnByb3RvdHlwZS5zZXQ9Wi5wcm90b3R5cGUuc2V0O1xuWi5wcm90b3R5cGUuQ2I9ZnVuY3Rpb24oYSxiLGMpe0UoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLGEsITEpO1ZiKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMixiKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMyxjLCEwKTtMaCh0aGlzLlJjLHRoaXMuRWEsYSxiLGMpfTtaLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9Wi5wcm90b3R5cGUuQ2I7XG5aLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsdGhpcy5FYSk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLDIsYiwhMCk7TWgodGhpcy5SYyxcbnRoaXMuRWEsYSxiKX07Wi5wcm90b3R5cGUudXBkYXRlPVoucHJvdG90eXBlLnVwZGF0ZTt2YXIgJD17fTskLm9jPU1lOyQuRGF0YUNvbm5lY3Rpb249JC5vYztNZS5wcm90b3R5cGUuemc9ZnVuY3Rpb24oYSxiKXt0aGlzLkJhKFwicVwiLHtwOmF9LGIpfTskLm9jLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW49JC5vYy5wcm90b3R5cGUuemc7TWUucHJvdG90eXBlLlNmPWZ1bmN0aW9uKGEsYil7dGhpcy5CYShcImVjaG9cIix7ZDphfSxiKX07JC5vYy5wcm90b3R5cGUuZWNobz0kLm9jLnByb3RvdHlwZS5TZjtNZS5wcm90b3R5cGUuaW50ZXJydXB0PU1lLnByb3RvdHlwZS5xYjskLkRmPXdlOyQuUmVhbFRpbWVDb25uZWN0aW9uPSQuRGY7d2UucHJvdG90eXBlLnNlbmRSZXF1ZXN0PXdlLnByb3RvdHlwZS5CYTt3ZS5wcm90b3R5cGUuY2xvc2U9d2UucHJvdG90eXBlLmNsb3NlO1xuJC4kZj1mdW5jdGlvbihhKXt2YXIgYj1NZS5wcm90b3R5cGUucHV0O01lLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYyxkLGUsZil7bShmKSYmKGY9YSgpKTtiLmNhbGwodGhpcyxjLGQsZSxmKX07cmV0dXJuIGZ1bmN0aW9uKCl7TWUucHJvdG90eXBlLnB1dD1ifX07JC5oaWphY2tIYXNoPSQuJGY7JC5DZj1BYTskLkNvbm5lY3Rpb25UYXJnZXQ9JC5DZjskLkZhPWZ1bmN0aW9uKGEpe3JldHVybiBhLkZhKCl9OyQucXVlcnlJZGVudGlmaWVyPSQuRmE7JC5iZz1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLlMudGF9OyQubGlzdGVucz0kLmJnO3ZhciBaaD1mdW5jdGlvbigpe3ZhciBhPTAsYj1bXTtyZXR1cm4gZnVuY3Rpb24oYyl7dmFyIGQ9Yz09PWE7YT1jO2Zvcih2YXIgZT1BcnJheSg4KSxmPTc7MDw9ZjtmLS0pZVtmXT1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYyU2NCksYz1NYXRoLmZsb29yKGMvNjQpO3koMD09PWMsXCJDYW5ub3QgcHVzaCBhdCB0aW1lID09IDBcIik7Yz1lLmpvaW4oXCJcIik7aWYoZCl7Zm9yKGY9MTE7MDw9ZiYmNjM9PT1iW2ZdO2YtLSliW2ZdPTA7YltmXSsrfWVsc2UgZm9yKGY9MDsxMj5mO2YrKyliW2ZdPU1hdGguZmxvb3IoNjQqTWF0aC5yYW5kb20oKSk7Zm9yKGY9MDsxMj5mO2YrKyljKz1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYltmXSk7eSgyMD09PWMubGVuZ3RoLFwiTmV4dFB1c2hJZDogTGVuZ3RoIHNob3VsZCBiZSAyMC5cIik7XG5yZXR1cm4gY319KCk7ZnVuY3Rpb24gUihhLGIpe3ZhciBjLGQsZTtpZihhIGluc3RhbmNlb2YgQ2gpYz1hLGQ9YjtlbHNle0UoXCJuZXcgRmlyZWJhc2VcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7ZD1yYihhcmd1bWVudHNbMF0pO2M9ZC5CZztcImZpcmViYXNlXCI9PT1kLmRvbWFpbiYmcWIoZC5ob3N0K1wiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWRcIik7Y3x8cWIoXCJDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tXCIpO2QuQmJ8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24mJndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmLTEhPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSYmeihcIkluc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuIFBsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuXCIpO1xuYz1uZXcgQWEoZC5ob3N0LGQuQmIsYyxcIndzXCI9PT1kLnNjaGVtZXx8XCJ3c3NcIj09PWQuc2NoZW1lKTtkPW5ldyBTKGQuUGMpO2U9ZC50b1N0cmluZygpO3ZhciBmOyEoZj0hcChjLmhvc3QpfHwwPT09Yy5ob3N0Lmxlbmd0aHx8IVBiKGMudWIpKSYmKGY9MCE9PWUubGVuZ3RoKSYmKGUmJihlPWUucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sXCIvXCIpKSxmPSEocChlKSYmMCE9PWUubGVuZ3RoJiYhT2IudGVzdChlKSkpO2lmKGYpdGhyb3cgRXJyb3IoRyhcIm5ldyBGaXJlYmFzZVwiLDEsITEpKydtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCB0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO2lmKGIpaWYoYiBpbnN0YW5jZW9mIFdoKWU9YjtlbHNlIGlmKHAoYikpZT1XaC5PYigpLGMuSWQ9YjtlbHNlIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgYSB2YWxpZCBGaXJlYmFzZS5Db250ZXh0IGZvciBzZWNvbmQgYXJndW1lbnQgdG8gbmV3IEZpcmViYXNlKClcIik7XG5lbHNlIGU9V2guT2IoKTtmPWMudG9TdHJpbmcoKTt2YXIgZz10KGUuZmMsZik7Z3x8KGc9bmV3IENoKGMpLGUuZmNbZl09Zyk7Yz1nfVEuY2FsbCh0aGlzLGMsZCxJYywhMSl9bWEoUixRKTt2YXIgJGg9UixhaT1bXCJGaXJlYmFzZVwiXSxiaT1hYTthaVswXWluIGJpfHwhYmkuZXhlY1NjcmlwdHx8YmkuZXhlY1NjcmlwdChcInZhciBcIithaVswXSk7Zm9yKHZhciBjaTthaS5sZW5ndGgmJihjaT1haS5zaGlmdCgpKTspIWFpLmxlbmd0aCYmbSgkaCk/YmlbY2ldPSRoOmJpPWJpW2NpXT9iaVtjaV06YmlbY2ldPXt9O1IucHJvdG90eXBlLm5hbWU9ZnVuY3Rpb24oKXt6KFwiRmlyZWJhc2UubmFtZSgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2Uua2V5KCkgaW5zdGVhZC5cIik7RShcIkZpcmViYXNlLm5hbWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMua2V5KCl9O1IucHJvdG90eXBlLm5hbWU9Ui5wcm90b3R5cGUubmFtZTtcblIucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMucGF0aC5lKCk/bnVsbDpVYyh0aGlzLnBhdGgpfTtSLnByb3RvdHlwZS5rZXk9Ui5wcm90b3R5cGUua2V5O1IucHJvdG90eXBlLnU9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLmNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKGdhKGEpKWE9U3RyaW5nKGEpO2Vsc2UgaWYoIShhIGluc3RhbmNlb2YgUykpaWYobnVsbD09PUkodGhpcy5wYXRoKSl7dmFyIGI9YTtiJiYoYj1iLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLFwiL1wiKSk7WWIoXCJGaXJlYmFzZS5jaGlsZFwiLGIpfWVsc2UgWWIoXCJGaXJlYmFzZS5jaGlsZFwiLGEpO3JldHVybiBuZXcgUih0aGlzLmssdGhpcy5wYXRoLnUoYSkpfTtSLnByb3RvdHlwZS5jaGlsZD1SLnByb3RvdHlwZS51O1xuUi5wcm90b3R5cGUucGFyZW50PWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLnBhcmVudFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt2YXIgYT10aGlzLnBhdGgucGFyZW50KCk7cmV0dXJuIG51bGw9PT1hP251bGw6bmV3IFIodGhpcy5rLGEpfTtSLnByb3RvdHlwZS5wYXJlbnQ9Ui5wcm90b3R5cGUucGFyZW50O1IucHJvdG90eXBlLnJvb3Q9ZnVuY3Rpb24oKXtFKFwiRmlyZWJhc2UucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzO251bGwhPT1hLnBhcmVudCgpOylhPWEucGFyZW50KCk7cmV0dXJuIGF9O1IucHJvdG90eXBlLnJvb3Q9Ui5wcm90b3R5cGUucm9vdDtcblIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLnRvU3RyaW5nXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3ZhciBhO2lmKG51bGw9PT10aGlzLnBhcmVudCgpKWE9dGhpcy5rLnRvU3RyaW5nKCk7ZWxzZXthPXRoaXMucGFyZW50KCkudG9TdHJpbmcoKStcIi9cIjt2YXIgYj10aGlzLmtleSgpO2ErPWVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYikpfXJldHVybiBhfTtSLnByb3RvdHlwZS50b1N0cmluZz1SLnByb3RvdHlwZS50b1N0cmluZztSLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uuc2V0XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uuc2V0XCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5zZXRcIiwyLGIsITApO3RoaXMuay5DYih0aGlzLnBhdGgsYSxudWxsLGJ8fG51bGwpfTtSLnByb3RvdHlwZS5zZXQ9Ui5wcm90b3R5cGUuc2V0O1xuUi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLnVwZGF0ZVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnVwZGF0ZVwiLHRoaXMucGF0aCk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2UudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLnVwZGF0ZVwiLDIsYiwhMCk7dGhpcy5rLnVwZGF0ZSh0aGlzLnBhdGgsYSxifHxudWxsKX07Ui5wcm90b3R5cGUudXBkYXRlPVIucHJvdG90eXBlLnVwZGF0ZTtcblIucHJvdG90eXBlLkNiPWZ1bmN0aW9uKGEsYixjKXtFKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMiwzLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLGEsITEpO1ZiKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMixiKTtIKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMyxjLCEwKTtpZihcIi5sZW5ndGhcIj09PXRoaXMua2V5KCl8fFwiLmtleXNcIj09PXRoaXMua2V5KCkpdGhyb3dcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eSBmYWlsZWQ6IFwiK3RoaXMua2V5KCkrXCIgaXMgYSByZWFkLW9ubHkgb2JqZWN0LlwiO3RoaXMuay5DYih0aGlzLnBhdGgsYSxiLGN8fG51bGwpfTtSLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9Ui5wcm90b3R5cGUuQ2I7XG5SLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLnJlbW92ZVwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnJlbW92ZVwiLHRoaXMucGF0aCk7SChcIkZpcmViYXNlLnJlbW92ZVwiLDEsYSwhMCk7dGhpcy5zZXQobnVsbCxhKX07Ui5wcm90b3R5cGUucmVtb3ZlPVIucHJvdG90eXBlLnJlbW92ZTtcblIucHJvdG90eXBlLnRyYW5zYWN0aW9uPWZ1bmN0aW9uKGEsYixjKXtFKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwxLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLHRoaXMucGF0aCk7SChcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMSxhLCExKTtIKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwyLGIsITApO2lmKG0oYykmJlwiYm9vbGVhblwiIT10eXBlb2YgYyl0aHJvdyBFcnJvcihHKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwzLCEwKStcIm11c3QgYmUgYSBib29sZWFuLlwiKTtpZihcIi5sZW5ndGhcIj09PXRoaXMua2V5KCl8fFwiLmtleXNcIj09PXRoaXMua2V5KCkpdGhyb3dcIkZpcmViYXNlLnRyYW5zYWN0aW9uIGZhaWxlZDogXCIrdGhpcy5rZXkoKStcIiBpcyBhIHJlYWQtb25seSBvYmplY3QuXCI7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjJiYoYz0hMCk7TmgodGhpcy5rLHRoaXMucGF0aCxhLGJ8fG51bGwsYyl9O1IucHJvdG90eXBlLnRyYW5zYWN0aW9uPVIucHJvdG90eXBlLnRyYW5zYWN0aW9uO1xuUi5wcm90b3R5cGUud2c9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLHRoaXMucGF0aCk7VmIoXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDEsYSk7SChcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMixiLCEwKTt0aGlzLmsuQ2IodGhpcy5wYXRoLnUoXCIucHJpb3JpdHlcIiksYSxudWxsLGIpfTtSLnByb3RvdHlwZS5zZXRQcmlvcml0eT1SLnByb3RvdHlwZS53ZztSLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLnB1c2hcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5wdXNoXCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnB1c2hcIixhLCEwKTtIKFwiRmlyZWJhc2UucHVzaFwiLDIsYiwhMCk7dmFyIGM9RWgodGhpcy5rKSxjPVpoKGMpLGM9dGhpcy51KGMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmbnVsbCE9PWEmJmMuc2V0KGEsYik7cmV0dXJuIGN9O1xuUi5wcm90b3R5cGUucHVzaD1SLnByb3RvdHlwZS5wdXNoO1IucHJvdG90eXBlLmZiPWZ1bmN0aW9uKCl7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3RcIix0aGlzLnBhdGgpO3JldHVybiBuZXcgWih0aGlzLmssdGhpcy5wYXRoKX07Ui5wcm90b3R5cGUub25EaXNjb25uZWN0PVIucHJvdG90eXBlLmZiO1IucHJvdG90eXBlLlE9ZnVuY3Rpb24oYSxiLGMpe3ooXCJGaXJlYmFzZVJlZi5hdXRoKCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGaXJlYmFzZVJlZi5hdXRoV2l0aEN1c3RvbVRva2VuKCkgaW5zdGVhZC5cIik7RShcIkZpcmViYXNlLmF1dGhcIiwxLDMsYXJndW1lbnRzLmxlbmd0aCk7JGIoXCJGaXJlYmFzZS5hdXRoXCIsYSk7SChcIkZpcmViYXNlLmF1dGhcIiwyLGIsITApO0goXCJGaXJlYmFzZS5hdXRoXCIsMyxiLCEwKTtPZih0aGlzLmsuUSxhLHt9LHtyZW1lbWJlcjpcIm5vbmVcIn0sYixjKX07Ui5wcm90b3R5cGUuYXV0aD1SLnByb3RvdHlwZS5RO1xuUi5wcm90b3R5cGUuVmU9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLnVuYXV0aFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2UudW5hdXRoXCIsMSxhLCEwKTtQZih0aGlzLmsuUSxhKX07Ui5wcm90b3R5cGUudW5hdXRoPVIucHJvdG90eXBlLlZlO1IucHJvdG90eXBlLnJlPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLmdldEF1dGhcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuay5RLnJlKCl9O1IucHJvdG90eXBlLmdldEF1dGg9Ui5wcm90b3R5cGUucmU7Ui5wcm90b3R5cGUuZmc9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uub25BdXRoXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS5vbkF1dGhcIiwxLGEsITEpO01iKFwiRmlyZWJhc2Uub25BdXRoXCIsMixiKTt0aGlzLmsuUS53YihcImF1dGhfc3RhdHVzXCIsYSxiKX07Ui5wcm90b3R5cGUub25BdXRoPVIucHJvdG90eXBlLmZnO1xuUi5wcm90b3R5cGUuZWc9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uub2ZmQXV0aFwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2Uub2ZmQXV0aFwiLDEsYSwhMSk7TWIoXCJGaXJlYmFzZS5vZmZBdXRoXCIsMixiKTt0aGlzLmsuUS4kYihcImF1dGhfc3RhdHVzXCIsYSxiKX07Ui5wcm90b3R5cGUub2ZmQXV0aD1SLnByb3RvdHlwZS5lZztSLnByb3RvdHlwZS5IZj1mdW5jdGlvbihhLGIsYyl7RShcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7JGIoXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsYSk7SChcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsMyxjLCEwKTtPZih0aGlzLmsuUSxhLHt9LGN8fHt9LGIpfTtSLnByb3RvdHlwZS5hdXRoV2l0aEN1c3RvbVRva2VuPVIucHJvdG90eXBlLkhmO1xuUi5wcm90b3R5cGUuSWY9ZnVuY3Rpb24oYSxiLGMpe0UoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7YWMoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwxLGEpO0goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwzLGMsITApO1RmKHRoaXMuay5RLGEsYyxiKX07Ui5wcm90b3R5cGUuYXV0aFdpdGhPQXV0aFBvcHVwPVIucHJvdG90eXBlLklmO1xuUi5wcm90b3R5cGUuSmY9ZnVuY3Rpb24oYSxiLGMpe0UoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7YWMoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwxLGEpO0goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwzLGMsITApO3ZhciBkPXRoaXMuay5RO1JmKGQpO3ZhciBlPVtIZl0sZj1wZihjKTtcImFub255bW91c1wiPT09YXx8XCJmaXJlYmFzZVwiPT09YT9CKGIsWChcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSk6KHYuc2V0KFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIixmLmNkKSxTZihkLGUsXCIvYXV0aC9cIithLGYsYikpfTtSLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3Q9Ui5wcm90b3R5cGUuSmY7XG5SLnByb3RvdHlwZS5LZj1mdW5jdGlvbihhLGIsYyxkKXtFKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMyw0LGFyZ3VtZW50cy5sZW5ndGgpO2FjKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMSxhKTtIKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMyxjLCExKTtKKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsNCxkLCEwKTtwKGIpPyhhYyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDIsYiksUWYodGhpcy5rLlEsYStcIi90b2tlblwiLHthY2Nlc3NfdG9rZW46Yn0sZCxjKSk6KEooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwyLGIsITEpLFFmKHRoaXMuay5RLGErXCIvdG9rZW5cIixiLGQsYykpfTtSLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoVG9rZW49Ui5wcm90b3R5cGUuS2Y7XG5SLnByb3RvdHlwZS5HZj1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7SChcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDEsYSwhMSk7SihcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDIsYiwhMCk7UWYodGhpcy5rLlEsXCJhbm9ueW1vdXNcIix7fSxiLGEpfTtSLnByb3RvdHlwZS5hdXRoQW5vbnltb3VzbHk9Ui5wcm90b3R5cGUuR2Y7XG5SLnByb3RvdHlwZS5MZj1mdW5jdGlvbihhLGIsYyl7RShcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsYSxcInBhc3N3b3JkXCIpO0goXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwzLGMsITApO1FmKHRoaXMuay5RLFwicGFzc3dvcmRcIixhLGMsYil9O1IucHJvdG90eXBlLmF1dGhXaXRoUGFzc3dvcmQ9Ui5wcm90b3R5cGUuTGY7XG5SLnByb3RvdHlwZS5uZT1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLGEsXCJlbWFpbFwiKTtLKFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLGEsXCJwYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLDIsYiwhMSk7dGhpcy5rLlEubmUoYSxiKX07Ui5wcm90b3R5cGUuY3JlYXRlVXNlcj1SLnByb3RvdHlwZS5uZTtSLnByb3RvdHlwZS5NZT1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLGEsXCJlbWFpbFwiKTtLKFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLGEsXCJwYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLDIsYiwhMSk7dGhpcy5rLlEuTWUoYSxiKX07XG5SLnByb3RvdHlwZS5yZW1vdmVVc2VyPVIucHJvdG90eXBlLk1lO1IucHJvdG90eXBlLmplPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLGEsXCJvbGRQYXNzd29yZFwiKTtLKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIixhLFwibmV3UGFzc3dvcmRcIik7SChcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMixiLCExKTt0aGlzLmsuUS5qZShhLGIpfTtSLnByb3RvdHlwZS5jaGFuZ2VQYXNzd29yZD1SLnByb3RvdHlwZS5qZTtcblIucHJvdG90eXBlLmllPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsYSxcIm9sZEVtYWlsXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLGEsXCJuZXdFbWFpbFwiKTtLKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIixhLFwicGFzc3dvcmRcIik7SChcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMixiLCExKTt0aGlzLmsuUS5pZShhLGIpfTtSLnByb3RvdHlwZS5jaGFuZ2VFbWFpbD1SLnByb3RvdHlwZS5pZTtcblIucHJvdG90eXBlLk5lPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0goXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsMixiLCExKTt0aGlzLmsuUS5OZShhLGIpfTtSLnByb3RvdHlwZS5yZXNldFBhc3N3b3JkPVIucHJvdG90eXBlLk5lO1IuZ29PZmZsaW5lPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLmdvT2ZmbGluZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtXaC5PYigpLnFiKCl9O1IuZ29PbmxpbmU9ZnVuY3Rpb24oKXtFKFwiRmlyZWJhc2UuZ29PbmxpbmVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7V2guT2IoKS5pYygpfTtcbmZ1bmN0aW9uIG5iKGEsYil7eSghYnx8ITA9PT1hfHwhMT09PWEsXCJDYW4ndCB0dXJuIG9uIGN1c3RvbSBsb2dnZXJzIHBlcnNpc3RlbnRseS5cIik7ITA9PT1hPyhcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJihcImZ1bmN0aW9uXCI9PT10eXBlb2YgY29uc29sZS5sb2c/bGI9cShjb25zb2xlLmxvZyxjb25zb2xlKTpcIm9iamVjdFwiPT09dHlwZW9mIGNvbnNvbGUubG9nJiYobGI9ZnVuY3Rpb24oYSl7Y29uc29sZS5sb2coYSl9KSksYiYmdi5zZXQoXCJsb2dnaW5nX2VuYWJsZWRcIiwhMCkpOmE/bGI9YToobGI9bnVsbCx2LnJlbW92ZShcImxvZ2dpbmdfZW5hYmxlZFwiKSl9Ui5lbmFibGVMb2dnaW5nPW5iO1IuU2VydmVyVmFsdWU9e1RJTUVTVEFNUDp7XCIuc3ZcIjpcInRpbWVzdGFtcFwifX07Ui5TREtfVkVSU0lPTj1cIjIuMi4wXCI7Ui5JTlRFUk5BTD1ZO1IuQ29udGV4dD1XaDtSLlRFU1RfQUNDRVNTPSQ7fSkoKTtcbm1vZHVsZS5leHBvcnRzID0gRmlyZWJhc2U7XG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2FwcGVuZCcgOiByZXF1aXJlKCcuL2FycmF5L2FwcGVuZCcpLFxuICAgICdjb2xsZWN0JyA6IHJlcXVpcmUoJy4vYXJyYXkvY29sbGVjdCcpLFxuICAgICdjb21iaW5lJyA6IHJlcXVpcmUoJy4vYXJyYXkvY29tYmluZScpLFxuICAgICdjb21wYWN0JyA6IHJlcXVpcmUoJy4vYXJyYXkvY29tcGFjdCcpLFxuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL2FycmF5L2NvbnRhaW5zJyksXG4gICAgJ2RpZmZlcmVuY2UnIDogcmVxdWlyZSgnLi9hcnJheS9kaWZmZXJlbmNlJyksXG4gICAgJ2VxdWFscycgOiByZXF1aXJlKCcuL2FycmF5L2VxdWFscycpLFxuICAgICdldmVyeScgOiByZXF1aXJlKCcuL2FycmF5L2V2ZXJ5JyksXG4gICAgJ2ZpbHRlcicgOiByZXF1aXJlKCcuL2FycmF5L2ZpbHRlcicpLFxuICAgICdmaW5kJyA6IHJlcXVpcmUoJy4vYXJyYXkvZmluZCcpLFxuICAgICdmaW5kSW5kZXgnIDogcmVxdWlyZSgnLi9hcnJheS9maW5kSW5kZXgnKSxcbiAgICAnZmluZExhc3QnIDogcmVxdWlyZSgnLi9hcnJheS9maW5kTGFzdCcpLFxuICAgICdmaW5kTGFzdEluZGV4JyA6IHJlcXVpcmUoJy4vYXJyYXkvZmluZExhc3RJbmRleCcpLFxuICAgICdmbGF0dGVuJyA6IHJlcXVpcmUoJy4vYXJyYXkvZmxhdHRlbicpLFxuICAgICdmb3JFYWNoJyA6IHJlcXVpcmUoJy4vYXJyYXkvZm9yRWFjaCcpLFxuICAgICdncm91cEJ5JyA6IHJlcXVpcmUoJy4vYXJyYXkvZ3JvdXBCeScpLFxuICAgICdpbmRleE9mJyA6IHJlcXVpcmUoJy4vYXJyYXkvaW5kZXhPZicpLFxuICAgICdpbnNlcnQnIDogcmVxdWlyZSgnLi9hcnJheS9pbnNlcnQnKSxcbiAgICAnaW50ZXJzZWN0aW9uJyA6IHJlcXVpcmUoJy4vYXJyYXkvaW50ZXJzZWN0aW9uJyksXG4gICAgJ2ludm9rZScgOiByZXF1aXJlKCcuL2FycmF5L2ludm9rZScpLFxuICAgICdqb2luJyA6IHJlcXVpcmUoJy4vYXJyYXkvam9pbicpLFxuICAgICdsYXN0JyA6IHJlcXVpcmUoJy4vYXJyYXkvbGFzdCcpLFxuICAgICdsYXN0SW5kZXhPZicgOiByZXF1aXJlKCcuL2FycmF5L2xhc3RJbmRleE9mJyksXG4gICAgJ21hcCcgOiByZXF1aXJlKCcuL2FycmF5L21hcCcpLFxuICAgICdtYXgnIDogcmVxdWlyZSgnLi9hcnJheS9tYXgnKSxcbiAgICAnbWluJyA6IHJlcXVpcmUoJy4vYXJyYXkvbWluJyksXG4gICAgJ3BpY2snIDogcmVxdWlyZSgnLi9hcnJheS9waWNrJyksXG4gICAgJ3BsdWNrJyA6IHJlcXVpcmUoJy4vYXJyYXkvcGx1Y2snKSxcbiAgICAncmFuZ2UnIDogcmVxdWlyZSgnLi9hcnJheS9yYW5nZScpLFxuICAgICdyZWR1Y2UnIDogcmVxdWlyZSgnLi9hcnJheS9yZWR1Y2UnKSxcbiAgICAncmVkdWNlUmlnaHQnIDogcmVxdWlyZSgnLi9hcnJheS9yZWR1Y2VSaWdodCcpLFxuICAgICdyZWplY3QnIDogcmVxdWlyZSgnLi9hcnJheS9yZWplY3QnKSxcbiAgICAncmVtb3ZlJyA6IHJlcXVpcmUoJy4vYXJyYXkvcmVtb3ZlJyksXG4gICAgJ3JlbW92ZUFsbCcgOiByZXF1aXJlKCcuL2FycmF5L3JlbW92ZUFsbCcpLFxuICAgICdzaHVmZmxlJyA6IHJlcXVpcmUoJy4vYXJyYXkvc2h1ZmZsZScpLFxuICAgICdzbGljZScgOiByZXF1aXJlKCcuL2FycmF5L3NsaWNlJyksXG4gICAgJ3NvbWUnIDogcmVxdWlyZSgnLi9hcnJheS9zb21lJyksXG4gICAgJ3NvcnQnIDogcmVxdWlyZSgnLi9hcnJheS9zb3J0JyksXG4gICAgJ3NvcnRCeScgOiByZXF1aXJlKCcuL2FycmF5L3NvcnRCeScpLFxuICAgICdzcGxpdCcgOiByZXF1aXJlKCcuL2FycmF5L3NwbGl0JyksXG4gICAgJ3Rha2UnIDogcmVxdWlyZSgnLi9hcnJheS90YWtlJyksXG4gICAgJ3RvTG9va3VwJyA6IHJlcXVpcmUoJy4vYXJyYXkvdG9Mb29rdXAnKSxcbiAgICAndW5pb24nIDogcmVxdWlyZSgnLi9hcnJheS91bmlvbicpLFxuICAgICd1bmlxdWUnIDogcmVxdWlyZSgnLi9hcnJheS91bmlxdWUnKSxcbiAgICAneG9yJyA6IHJlcXVpcmUoJy4vYXJyYXkveG9yJyksXG4gICAgJ3ppcCcgOiByZXF1aXJlKCcuL2FycmF5L3ppcCcpXG59O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhbiBhcnJheSB0byB0aGUgZW5kIG9mIGFub3RoZXIuXG4gICAgICogVGhlIGZpcnN0IGFycmF5IHdpbGwgYmUgbW9kaWZpZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwZW5kKGFycjEsIGFycjIpIHtcbiAgICAgICAgaWYgKGFycjIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFkID0gYXJyMS5sZW5ndGgsXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW4gPSBhcnIyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgYXJyMVtwYWQgKyBpXSA9IGFycjJbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjE7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gYXBwZW5kO1xuXG4iLCJ2YXIgYXBwZW5kID0gcmVxdWlyZSgnLi9hcHBlbmQnKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXkgYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0IGFycmF5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb2xsZWN0KGFyciwgY2FsbGJhY2ssIHRoaXNPYmope1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjYWxsYmFjayhhcnJbaV0sIGksIGFycik7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFwcGVuZChyZXN1bHRzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3Q7XG5cblxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCcuL2luZGV4T2YnKTtcblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIGFuIGFycmF5IHdpdGggYWxsIHRoZSBpdGVtcyBvZiBhbm90aGVyLlxuICAgICAqIERvZXMgbm90IGFsbG93IGR1cGxpY2F0ZXMgYW5kIGlzIGNhc2UgYW5kIHR5cGUgc2Vuc2l0aXZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbWJpbmUoYXJyMSwgYXJyMikge1xuICAgICAgICBpZiAoYXJyMiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFycjIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZihhcnIxLCBhcnIyW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhcnIxLnB1c2goYXJyMltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyMTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb21iaW5lO1xuXG4iLCJ2YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgbnVsbC91bmRlZmluZWQgaXRlbXMgZnJvbSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycikge1xuICAgICAgICByZXR1cm4gZmlsdGVyKGFyciwgZnVuY3Rpb24odmFsKXtcbiAgICAgICAgICAgIHJldHVybiAodmFsICE9IG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbXBhY3Q7XG5cbiIsInZhciBpbmRleE9mID0gcmVxdWlyZSgnLi9pbmRleE9mJyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiBhcnJheSBjb250YWlucyB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoYXJyLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YoYXJyLCB2YWwpICE9PSAtMTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb250YWlucztcblxuIiwidmFyIHVuaXF1ZSA9IHJlcXVpcmUoJy4vdW5pcXVlJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBzb21lID0gcmVxdWlyZSgnLi9zb21lJyk7XG52YXIgY29udGFpbnMgPSByZXF1aXJlKCcuL2NvbnRhaW5zJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuL3NsaWNlJyk7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBBcnJheSB3aXRoIGVsZW1lbnRzIHRoYXQgYXJlbid0IHByZXNlbnQgaW4gdGhlIG90aGVyIEFycmF5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycikge1xuICAgICAgICB2YXIgYXJycyA9IHNsaWNlKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXIodW5pcXVlKGFyciksIGZ1bmN0aW9uKG5lZWRsZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzb21lKGFycnMsIGZ1bmN0aW9uKGhheXN0YWNrKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGhheXN0YWNrLCBuZWVkbGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkaWZmZXJlbmNlO1xuXG5cbiIsInZhciBpcyA9IHJlcXVpcmUoJy4uL2xhbmcvaXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG52YXIgZXZlcnkgPSByZXF1aXJlKCcuL2V2ZXJ5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBpZiBib3RoIGFycmF5cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIsIGNhbGxiYWNrKXtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkoYSkgfHwgIWlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVyeShhLCBtYWtlQ29tcGFyZShjYWxsYmFjayksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VDb21wYXJlKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgaW4gdGhpcyAmJiBjYWxsYmFjayh2YWx1ZSwgdGhpc1tpXSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlcXVhbHM7XG5cblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IGV2ZXJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoYXJyLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgc3BhcnNlIGl0ZW1zIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyB3b3JrIHByb3Blcmx5IG9uIElFIDctOC4gc2VlICM2NFxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjayhhcnJbaV0sIGksIGFycikgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZXZlcnk7XG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBmaWx0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoYXJyLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoLCB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG5cblxuIiwidmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJy4vZmluZEluZGV4Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIGNyaXRlcmlhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGlkeCA9IGZpbmRJbmRleChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwPyBhcnJbaWR4XSA6IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuXG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgY3JpdGVyaWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBpdGVyYXRvciwgdGhpc09iail7XG4gICAgICAgIGl0ZXJhdG9yID0gbWFrZUl0ZXJhdG9yKGl0ZXJhdG9yLCB0aGlzT2JqKTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG5cbiIsInZhciBmaW5kTGFzdEluZGV4ID0gcmVxdWlyZSgnLi9maW5kTGFzdEluZGV4Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxhc3QgaXRlbSB0aGF0IG1hdGNoZXMgY3JpdGVyaWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGlkeCA9IGZpbmRMYXN0SW5kZXgoYXJyLCBpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMD8gYXJyW2lkeF0gOiB2b2lkKDApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZmluZExhc3Q7XG5cblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gdGhhdCBtYXRjaGVzIGNyaXRlcmlhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKXtcbiAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IoYXJyW25dLCBuLCBhcnIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kTGFzdEluZGV4O1xuXG5cbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG52YXIgYXBwZW5kID0gcmVxdWlyZSgnLi9hcHBlbmQnKTtcblxuICAgIC8qXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGZsYXR0ZW4gdG8gYSBkZXN0aW5hdGlvbiBhcnJheS5cbiAgICAgKiBVc2VkIHRvIHJlbW92ZSB0aGUgbmVlZCB0byBjcmVhdGUgaW50ZXJtZWRpYXRlIGFycmF5cyB3aGlsZSBmbGF0dGVuaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5UbyhhcnIsIHJlc3VsdCwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBhcHBlbmQocmVzdWx0LCBhcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlblRvKHZhbHVlLCByZXN1bHQsIGxldmVsIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGFuIGFycmF5LlxuICAgICAqIEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBlbGVtZW50cyBpcyByZXR1cm5lZC5cbiAgICAgKiBJZiBgc2hhbGxvd2AgaXMgdHJ1ZSwgaXQgd2lsbCBvbmx5IGZsYXR0ZW4gb25lIGxldmVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBsZXZlbCkge1xuICAgICAgICBsZXZlbCA9IGxldmVsID09IG51bGw/IC0xIDogbGV2ZWw7XG4gICAgICAgIHJldHVybiBmbGF0dGVuVG8oYXJyLCBbXSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcblxuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgZm9yRWFjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goYXJyLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHNwYXJzZSBpdGVtcyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gbWFrZSBpdFxuICAgICAgICAgICAgLy8gd29yayBwcm9wZXJseSBvbiBJRSA3LTguIHNlZSAjNjRcbiAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCh0aGlzT2JqLCBhcnJbaV0sIGksIGFycikgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cbiIsInZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vaWRlbnRpdHknKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBCdWNrZXQgdGhlIGFycmF5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cEJ5KGFyciwgY2F0ZWdvcml6ZSwgdGhpc09iaikge1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZSkge1xuICAgICAgICAgICAgY2F0ZWdvcml6ZSA9IG1ha2VJdGVyYXRvcihjYXRlZ29yaXplLCB0aGlzT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gaWRlbnRpdHkgZnVuY3Rpb24uXG4gICAgICAgICAgICBjYXRlZ29yaXplID0gaWRlbnRpdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVja2V0cyA9IHt9O1xuICAgICAgICBmb3JFYWNoKGFyciwgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IGNhdGVnb3JpemUoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIShidWNrZXQgaW4gYnVja2V0cykpIHtcbiAgICAgICAgICAgICAgICBidWNrZXRzW2J1Y2tldF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVja2V0c1tidWNrZXRdLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBidWNrZXRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JvdXBCeTtcblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBBcnJheS5pbmRleE9mXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnIsIGl0ZW0sIGZyb21JbmRleCkge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggfHwgMDtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSBmcm9tSW5kZXggPCAwID8gbGVuICsgZnJvbUluZGV4IDogZnJvbUluZGV4O1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHNwYXJzZSBpdGVtcyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gbWFrZSBpdFxuICAgICAgICAgICAgLy8gd29yayBwcm9wZXJseSBvbiBJRSA3LTguIHNlZSAjNjRcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW5kZXhPZjtcblxuIiwidmFyIGRpZmZlcmVuY2UgPSByZXF1aXJlKCcuL2RpZmZlcmVuY2UnKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBpdGVtIGludG8gYXJyYXkgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQoYXJyLCByZXN0X2l0ZW1zKSB7XG4gICAgICAgIHZhciBkaWZmID0gZGlmZmVyZW5jZShzbGljZShhcmd1bWVudHMsIDEpLCBhcnIpO1xuICAgICAgICBpZiAoZGlmZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyciwgZGlmZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaW5zZXJ0O1xuXG4iLCJ2YXIgdW5pcXVlID0gcmVxdWlyZSgnLi91bmlxdWUnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIGV2ZXJ5ID0gcmVxdWlyZSgnLi9ldmVyeScpO1xudmFyIGNvbnRhaW5zID0gcmVxdWlyZSgnLi9jb250YWlucycpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQXJyYXkgd2l0aCBlbGVtZW50cyBjb21tb24gdG8gYWxsIEFycmF5cy5cbiAgICAgKiAtIGJhc2VkIG9uIHVuZGVyc2NvcmUuanMgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciBhcnJzID0gc2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcih1bmlxdWUoYXJyKSwgZnVuY3Rpb24obmVlZGxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlcnkoYXJycywgZnVuY3Rpb24oaGF5c3RhY2spe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdGlvbjtcblxuXG4iLCJ2YXIgc2xpY2UgPSByZXF1aXJlKCcuL3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBtZXRob2ROYW1lYCBvbiBlYWNoIGl0ZW0gb2YgdGhlIGFycmF5IHBhc3NpbmcgY3VzdG9tIGFyZ3VtZW50cyBpZlxuICAgICAqIG5lZWRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoYXJyLCBtZXRob2ROYW1lLCB2YXJfYXJncyl7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aCwgdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgdmFsdWVbbWV0aG9kTmFtZV0uYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGludm9rZTtcblxuIiwidmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkU3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEpvaW5zIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWVkIHNlcGFyYXRvciBpbnNlcnRlZCBiZXR3ZWVuIGVhY2ggdmFsdWUuXG4gICAgICogTnVsbCB2YWx1ZXMgYW5kIGVtcHR5IHN0cmluZ3Mgd2lsbCBiZSBleGNsdWRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGl0ZW1zLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcnO1xuICAgICAgICByZXR1cm4gZmlsdGVyKGl0ZW1zLCBpc1ZhbGlkU3RyaW5nKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqb2luO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGFzdCBlbGVtZW50IG9mIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyKXtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsIHx8IGFyci5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgbGFzdEluZGV4T2ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnIsIGl0ZW0sIGZyb21JbmRleCkge1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ID09IG51bGwgfHwgZnJvbUluZGV4ID49IGxlbik/IGxlbiAtIDEgOiBmcm9tSW5kZXg7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwKT8gbGVuICsgZnJvbUluZGV4IDogZnJvbUluZGV4O1xuXG4gICAgICAgIHdoaWxlIChmcm9tSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHNwYXJzZSBpdGVtcyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gbWFrZSBpdFxuICAgICAgICAgICAgLy8gd29yayBwcm9wZXJseSBvbiBJRSA3LTguIHNlZSAjNjRcbiAgICAgICAgICAgIGlmIChhcnJbZnJvbUluZGV4XSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tSW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxhc3RJbmRleE9mO1xuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgbWFwXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gY2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgIG1vZHVsZS5leHBvcnRzID0gbWFwO1xuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1heGltdW0gdmFsdWUgaW5zaWRlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFyciwgaXRlcmF0b3IsIHRoaXNPYmope1xuICAgICAgICBpZiAoYXJyID09IG51bGwgfHwgIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoICYmICFpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IG1ha2VJdGVyYXRvcihpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdGVtcDtcblxuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gaXRlcmF0b3IodmFsdWUsIGksIGFycik7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPiBjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1pbmltdW0gdmFsdWUgaW5zaWRlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFyciwgaXRlcmF0b3IsIHRoaXNPYmope1xuICAgICAgICBpZiAoYXJyID09IG51bGwgfHwgIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCAmJiAhaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gSW5maW5pdHksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdGVtcDtcblxuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gaXRlcmF0b3IodmFsdWUsIGksIGFycik7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPCBjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1pbjtcblxuXG4iLCJ2YXIgcmFuZEludCA9IHJlcXVpcmUoJy4uL3JhbmRvbS9yYW5kSW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcmFuZG9tIGl0ZW0ocykgZnJvbSB0aGUgQXJyYXkgYW5kIHJldHVybiBpdC5cbiAgICAgKiBSZXR1cm5zIGFuIEFycmF5IG9mIGl0ZW1zIGlmIFtuSXRlbXNdIGlzIHByb3ZpZGVkIG9yIGEgc2luZ2xlIGl0ZW0gaWZcbiAgICAgKiBpdCBpc24ndCBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhhcnIsIG5JdGVtcyl7XG4gICAgICAgIGlmIChuSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKG5JdGVtcyA+IDAgJiYgYXJyICYmIGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuSXRlbXMgPSBuSXRlbXMgPiBhcnIubGVuZ3RoPyBhcnIubGVuZ3RoIDogbkl0ZW1zO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuSXRlbXMtLSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCggcGlja09uZShhcnIpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGFyciAmJiBhcnIubGVuZ3RoKT8gcGlja09uZShhcnIpIDogdm9pZCgwKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBpY2tPbmUoYXJyKXtcbiAgICAgICAgdmFyIGlkeCA9IHJhbmRJbnQoMCwgYXJyLmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpZHgsIDEpWzBdO1xuICAgIH1cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuXG5cbiIsInZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBhIGxpc3Qgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGFyciwgcHJvcE5hbWUpe1xuICAgICAgICByZXR1cm4gbWFwKGFyciwgcHJvcE5hbWUpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGx1Y2s7XG5cblxuIiwidmFyIGNvdW50U3RlcHMgPSByZXF1aXJlKCcuLi9tYXRoL2NvdW50U3RlcHMnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgb2YgbnVtYmVycyBpbnNpZGUgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgblN0ZXBzID0gY291bnRTdGVwcyhzdG9wIC0gc3RhcnQsIHN0ZXApLFxuICAgICAgICAgICAgaSA9IHN0YXJ0O1xuXG4gICAgICAgIHdoaWxlIChpIDw9IHN0b3ApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgaSArPSBzdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgcmVkdWNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGFyciwgZm4sIGluaXRWYWwpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFyZ3MubGVuZ3RoIHNpbmNlIGluaXRWYWwgbWlnaHQgYmUgXCJ1bmRlZmluZWRcIiBzZWUgI2doLTU3XG4gICAgICAgIHZhciBoYXNJbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIsXG4gICAgICAgICAgICByZXN1bHQgPSBpbml0VmFsO1xuXG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFoYXNJbml0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKCFoYXNJbml0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJyW2ldO1xuICAgICAgICAgICAgICAgIGhhc0luaXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihyZXN1bHQsIGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgcmVkdWNlUmlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChhcnIsIGZuLCBpbml0VmFsKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBhcmdzLmxlbmd0aCBzaW5jZSBpbml0VmFsIG1pZ2h0IGJlIFwidW5kZWZpbmVkXCIgc2VlICNnaC01N1xuICAgICAgICB2YXIgaGFzSW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuXG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc0luaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IGFyci5sZW5ndGgsIHJlc3VsdCA9IGluaXRWYWwsIHZhbHVlO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIC8vIHdlIGl0ZXJhdGUgb3ZlciBzcGFyc2UgaXRlbXMgc2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIG1ha2UgaXRcbiAgICAgICAgICAgIC8vIHdvcmsgcHJvcGVybHkgb24gSUUgNy04LiBzZWUgIzY0XG4gICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmICghaGFzSW5pdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGhhc0luaXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihyZXN1bHQsIHZhbHVlLCBpLCBhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWR1Y2VSaWdodDtcblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHJlamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChhcnIsIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGgsIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGksIGFycikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWplY3Q7XG5cbiIsInZhciBpbmRleE9mID0gcmVxdWlyZSgnLi9pbmRleE9mJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzaW5nbGUgaXRlbSBmcm9tIHRoZSBhcnJheS5cbiAgICAgKiAoaXQgd29uJ3QgcmVtb3ZlIGR1cGxpY2F0ZXMsIGp1c3QgYSBzaW5nbGUgaXRlbSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyLCBpdGVtKXtcbiAgICAgICAgdmFyIGlkeCA9IGluZGV4T2YoYXJyLCBpdGVtKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZTtcblxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCcuL2luZGV4T2YnKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgaW5zdGFuY2VzIG9mIGFuIGl0ZW0gZnJvbSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVBbGwoYXJyLCBpdGVtKXtcbiAgICAgICAgdmFyIGlkeCA9IGluZGV4T2YoYXJyLCBpdGVtKTtcbiAgICAgICAgd2hpbGUgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGlkeCA9IGluZGV4T2YoYXJyLCBpdGVtLCBpZHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZW1vdmVBbGw7XG5cbiIsInZhciByYW5kSW50ID0gcmVxdWlyZSgnLi4vcmFuZG9tL3JhbmRJbnQnKTtcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGUgYXJyYXkgaXRlbXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShhcnIpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIHJuZDtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGgsIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzWzBdID0gYXJyWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBybmQgPSByYW5kSW50KDAsIGkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHRzW3JuZF07XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tybmRdID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaHVmZmxlO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzbGljZSBvZiBzb3VyY2UgYXJyYXkgb3IgYXJyYXktbGlrZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBlbmQpe1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heChsZW4gKyBzdGFydCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBsZW47XG4gICAgICAgIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kID0gTWF0aC5tYXgobGVuICsgZW5kLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgbGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJbc3RhcnQrK10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNsaWNlO1xuXG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzb21lXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShhcnIsIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgc3BhcnNlIGl0ZW1zIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyB3b3JrIHByb3Blcmx5IG9uIElFIDctOC4gc2VlICM2NFxuICAgICAgICAgICAgaWYgKCBjYWxsYmFjayhhcnJbaV0sIGksIGFycikgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb21lO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIE1lcmdlIHNvcnQgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVyZ2Vfc29ydClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQoYXJyLCBjb21wYXJlRm4pIHtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZUZuID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBhcmVGbiA9IGRlZmF1bHRDb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pZCwgbGVmdCwgcmlnaHQ7XG5cbiAgICAgICAgbWlkICAgPSB+fihhcnIubGVuZ3RoIC8gMik7XG4gICAgICAgIGxlZnQgID0gbWVyZ2VTb3J0KCBhcnIuc2xpY2UoMCwgbWlkKSwgY29tcGFyZUZuICk7XG4gICAgICAgIHJpZ2h0ID0gbWVyZ2VTb3J0KCBhcnIuc2xpY2UobWlkLCBhcnIubGVuZ3RoKSwgY29tcGFyZUZuICk7XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJlRm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAoYSA+IGI/IDEgOiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZShsZWZ0LCByaWdodCwgY29tcGFyZUZuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICB3aGlsZSAobGVmdC5sZW5ndGggJiYgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZUZuKGxlZnRbMF0sIHJpZ2h0WzBdKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgMCBpdCBzaG91bGQgcHJlc2VydmUgc2FtZSBvcmRlciAoc3RhYmxlKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGxlZnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWVyZ2VTb3J0O1xuXG5cbiIsInZhciBzb3J0ID0gcmVxdWlyZSgnLi9zb3J0Jyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLypcbiAgICAgKiBTb3J0IGFycmF5IGJ5IHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGFyciwgY2FsbGJhY2ssIGNvbnRleHQpe1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgY29udGV4dCk7XG5cbiAgICAgICAgcmV0dXJuIHNvcnQoYXJyLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBhID0gY2FsbGJhY2soYSk7XG4gICAgICAgICAgICBiID0gY2FsbGJhY2soYik7XG4gICAgICAgICAgICByZXR1cm4gKGEgPCBiKSA/IC0xIDogKChhID4gYikgPyAxIDogMCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYXJyYXkgaW50byBhIGZpeGVkIG51bWJlciBvZiBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChhcnJheSwgc2VnbWVudHMpIHtcbiAgICAgICAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCAyO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluTGVuZ3RoID0gTWF0aC5mbG9vcihhcnJheS5sZW5ndGggLyBzZWdtZW50cyksXG4gICAgICAgICAgICByZW1haW5kZXIgPSBhcnJheS5sZW5ndGggJSBzZWdtZW50cyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgc2VnbWVudEluZGV4ID0gMCxcbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBtaW5MZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgcmVtYWluZGVyKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIHNlZ21lbnRMZW5ndGgpKTtcblxuICAgICAgICAgICAgc2VnbWVudEluZGV4Kys7XG4gICAgICAgICAgICBpICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzcGxpdDtcblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgY2FsbGJhY2sgYSBzZXQgYW1vdW50IG9mIHRpbWVzXG4gICAgICogcmV0dXJuaW5nIHRoZSByZXN1bHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShuLCBjYWxsYmFjaywgdGhpc09iail7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgaWYoICF0aGlzT2JqICl7XG4gICAgICAgICAgICB3aGlsZSgrK2kgPCBuKXtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBjYWxsYmFjayhpLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlKCsraSA8IG4pe1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGNhbGxiYWNrLmNhbGwodGhpc09iaiwgaSwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRha2U7XG5cblxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9sYW5nL2lzRnVuY3Rpb24nKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaG9sZHMgYSBsb29rdXAgZm9yIHRoZSBvYmplY3RzIGluIHRoZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvb2t1cChhcnIsIGtleSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGgsIHZhbHVlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleSh2YWx1ZSldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0W3ZhbHVlW2tleV1dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvTG9va3VwO1xuXG4iLCJ2YXIgdW5pcXVlID0gcmVxdWlyZSgnLi91bmlxdWUnKTtcbnZhciBhcHBlbmQgPSByZXF1aXJlKCcuL2FwcGVuZCcpO1xuXG4gICAgLyoqXG4gICAgICogQ29uY2F0IG11bHRpcGxlIGFycmF5cyBhbmQgcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbihhcnJzKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGFwcGVuZChyZXN1bHRzLCBhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuaXF1ZShyZXN1bHRzKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuaW9uO1xuXG5cbiIsInZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHVuaXF1ZSBpdGVtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZShhcnIsIGNvbXBhcmUpe1xuICAgICAgICBjb21wYXJlID0gY29tcGFyZSB8fCBpc0VxdWFsO1xuICAgICAgICByZXR1cm4gZmlsdGVyKGFyciwgZnVuY3Rpb24oaXRlbSwgaSwgYXJyKXtcbiAgICAgICAgICAgIHZhciBuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb21wYXJlKGl0ZW0sIGFycltpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbChhLCBiKXtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1bmlxdWU7XG5cblxuIiwidmFyIHVuaXF1ZSA9IHJlcXVpcmUoJy4vdW5pcXVlJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBjb250YWlucyA9IHJlcXVpcmUoJy4vY29udGFpbnMnKTtcblxuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIE9SLiBSZXR1cm5zIGl0ZW1zIHRoYXQgYXJlIHByZXNlbnQgaW4gYSBzaW5nbGUgYXJyYXkuXG4gICAgICogLSBsaWtlIHB0eWhvbidzIGBzeW1tZXRyaWNfZGlmZmVyZW5jZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4b3IoYXJyMSwgYXJyMikge1xuICAgICAgICBhcnIxID0gdW5pcXVlKGFycjEpO1xuICAgICAgICBhcnIyID0gdW5pcXVlKGFycjIpO1xuXG4gICAgICAgIHZhciBhMSA9IGZpbHRlcihhcnIxLCBmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWNvbnRhaW5zKGFycjIsIGl0ZW0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhMiA9IGZpbHRlcihhcnIyLCBmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWNvbnRhaW5zKGFycjEsIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGExLmNvbmNhdChhMik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB4b3I7XG5cblxuIiwidmFyIG1heCA9IHJlcXVpcmUoJy4vbWF4Jyk7XG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcblxuICAgIGZ1bmN0aW9uIGdldExlbmd0aChhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyciA9PSBudWxsID8gMCA6IGFyci5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRvZ2V0aGVyIHRoZSB2YWx1ZXMgb2YgZWFjaCBvZiB0aGUgYXJyYXlzIHdpdGggdGhlIHZhbHVlcyBhdCB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcChhcnIpe1xuICAgICAgICB2YXIgbGVuID0gYXJyID8gbWF4KG1hcChhcmd1bWVudHMsIGdldExlbmd0aCkpIDogMCxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgLy8ganNoaW50IGxvb3BmdW5jOiB0cnVlXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID09IG51bGwgPyB1bmRlZmluZWQgOiBpdGVtW2ldO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB6aXA7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vY29udGFpbnMnKSxcbiAgICAnZXZlcnknIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL2V2ZXJ5JyksXG4gICAgJ2ZpbHRlcicgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vZmlsdGVyJyksXG4gICAgJ2ZpbmQnIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL2ZpbmQnKSxcbiAgICAnZm9yRWFjaCcgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vZm9yRWFjaCcpLFxuICAgICdtYWtlXycgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vbWFrZV8nKSxcbiAgICAnbWFwJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9tYXAnKSxcbiAgICAnbWF4JyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9tYXgnKSxcbiAgICAnbWluJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9taW4nKSxcbiAgICAncGx1Y2snIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL3BsdWNrJyksXG4gICAgJ3JlZHVjZScgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vcmVkdWNlJyksXG4gICAgJ3JlamVjdCcgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vcmVqZWN0JyksXG4gICAgJ3NpemUnIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL3NpemUnKSxcbiAgICAnc29tZScgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vc29tZScpXG59O1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyckNvbnRhaW5zID0gcmVxdWlyZSgnLi4vYXJyYXkvY29udGFpbnMnKTtcbnZhciBvYmpDb250YWlucyA9IHJlcXVpcmUoJy4uL29iamVjdC9jb250YWlucycpO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlKGFyckNvbnRhaW5zLCBvYmpDb250YWlucyk7XG5cblxuIiwidmFyIG1ha2UgPSByZXF1aXJlKCcuL21ha2VfJyk7XG52YXIgYXJyRXZlcnkgPSByZXF1aXJlKCcuLi9hcnJheS9ldmVyeScpO1xudmFyIG9iakV2ZXJ5ID0gcmVxdWlyZSgnLi4vb2JqZWN0L2V2ZXJ5Jyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyRXZlcnksIG9iakV2ZXJ5KTtcblxuXG4iLCJ2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIGZpbHRlciBjb2xsZWN0aW9uIHZhbHVlcywgcmV0dXJucyBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIobGlzdCwgaXRlcmF0b3IsIHRoaXNPYmopIHtcbiAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGZvckVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IodmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJGaW5kID0gcmVxdWlyZSgnLi4vYXJyYXkvZmluZCcpO1xudmFyIG9iakZpbmQgPSByZXF1aXJlKCcuLi9vYmplY3QvZmluZCcpO1xuXG4gICAgLyoqXG4gICAgICogRmluZCB2YWx1ZSB0aGF0IHJldHVybnMgdHJ1ZSBvbiBpdGVyYXRvciBjaGVjay5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyRmluZCwgb2JqRmluZCk7XG5cblxuIiwidmFyIG1ha2UgPSByZXF1aXJlKCcuL21ha2VfJyk7XG52YXIgYXJyRm9yRWFjaCA9IHJlcXVpcmUoJy4uL2FycmF5L2ZvckVhY2gnKTtcbnZhciBvYmpGb3JFYWNoID0gcmVxdWlyZSgnLi4vb2JqZWN0L2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlKGFyckZvckVhY2gsIG9iakZvckVhY2gpO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBtZXRob2QgdXNlZCB0byBjcmVhdGUgb3RoZXIgY29sbGVjdGlvbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VDb2xsZWN0aW9uTWV0aG9kKGFyck1ldGhvZCwgb2JqTWV0aG9kLCBkZWZhdWx0UmV0dXJuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0UmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXJyYXktbGlrZSBpcyB0cmVhdGVkIGFzIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBhcmdzWzBdLmxlbmd0aCA9PT0gJ251bWJlcicpPyBhcnJNZXRob2QuYXBwbHkobnVsbCwgYXJncykgOiBvYmpNZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQ29sbGVjdGlvbk1ldGhvZDtcblxuXG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG52YXIgdmFsdWVzID0gcmVxdWlyZSgnLi4vb2JqZWN0L3ZhbHVlcycpO1xudmFyIGFyck1hcCA9IHJlcXVpcmUoJy4uL2FycmF5L21hcCcpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBjb2xsZWN0aW9uIHZhbHVlcywgcmV0dXJucyBBcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAobGlzdCwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICAvLyBsaXN0Lmxlbmd0aCB0byBjaGVjayBhcnJheS1saWtlIG9iamVjdCwgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgLy8gd2Ugc2ltcGx5IG1hcCBhbGwgdGhlIG9iamVjdCB2YWx1ZXNcbiAgICAgICAgaWYoIGlzT2JqZWN0KGxpc3QpICYmIGxpc3QubGVuZ3RoID09IG51bGwgKXtcbiAgICAgICAgICAgIGxpc3QgPSB2YWx1ZXMobGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyck1hcChsaXN0LCBmdW5jdGlvbiAodmFsLCBrZXksIGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh2YWwsIGtleSwgbGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWFwO1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyck1heCA9IHJlcXVpcmUoJy4uL2FycmF5L21heCcpO1xudmFyIG9iak1heCA9IHJlcXVpcmUoJy4uL29iamVjdC9tYXgnKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBtYXhpbXVtIHZhbHVlIGluc2lkZSBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlKGFyck1heCwgb2JqTWF4KTtcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJNaW4gPSByZXF1aXJlKCcuLi9hcnJheS9taW4nKTtcbnZhciBvYmpNaW4gPSByZXF1aXJlKCcuLi9vYmplY3QvbWluJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWluaW11bSB2YWx1ZSBpbnNpZGUgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyTWluLCBvYmpNaW4pO1xuXG5cbiIsInZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBhIGxpc3Qgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGxpc3QsIGtleSkge1xuICAgICAgICByZXR1cm4gbWFwKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwbHVjaztcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJSZWR1Y2UgPSByZXF1aXJlKCcuLi9hcnJheS9yZWR1Y2UnKTtcbnZhciBvYmpSZWR1Y2UgPSByZXF1aXJlKCcuLi9vYmplY3QvcmVkdWNlJyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyUmVkdWNlLCBvYmpSZWR1Y2UpO1xuXG5cbiIsInZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3IgY29sbGVjdGlvbi9maWx0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QobGlzdCwgaXRlcmF0b3IsIHRoaXNPYmopIHtcbiAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICByZXR1cm4gZmlsdGVyKGxpc3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuICFpdGVyYXRvcih2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICB9LCB0aGlzT2JqKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlamVjdDtcblxuXG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xudmFyIG9ialNpemUgPSByZXF1aXJlKCcuLi9vYmplY3Qvc2l6ZScpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbGxlY3Rpb24gc2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUobGlzdCkge1xuICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ialNpemUobGlzdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaXplO1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyclNvbWUgPSByZXF1aXJlKCcuLi9hcnJheS9zb21lJyk7XG52YXIgb2JqU29tZSA9IHJlcXVpcmUoJy4uL29iamVjdC9zb21lJyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyU29tZSwgb2JqU29tZSk7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkYXlPZlRoZVllYXInIDogcmVxdWlyZSgnLi9kYXRlL2RheU9mVGhlWWVhcicpLFxuICAgICdkaWZmJyA6IHJlcXVpcmUoJy4vZGF0ZS9kaWZmJyksXG4gICAgJ2kxOG5fJyA6IHJlcXVpcmUoJy4vZGF0ZS9pMThuXycpLFxuICAgICdpc0xlYXBZZWFyJyA6IHJlcXVpcmUoJy4vZGF0ZS9pc0xlYXBZZWFyJyksXG4gICAgJ2lzU2FtZScgOiByZXF1aXJlKCcuL2RhdGUvaXNTYW1lJyksXG4gICAgJ3BhcnNlSXNvJyA6IHJlcXVpcmUoJy4vZGF0ZS9wYXJzZUlzbycpLFxuICAgICdxdWFydGVyJyA6IHJlcXVpcmUoJy4vZGF0ZS9xdWFydGVyJyksXG4gICAgJ3N0YXJ0T2YnIDogcmVxdWlyZSgnLi9kYXRlL3N0YXJ0T2YnKSxcbiAgICAnc3RyZnRpbWUnIDogcmVxdWlyZSgnLi9kYXRlL3N0cmZ0aW1lJyksXG4gICAgJ3RpbWV6b25lQWJicicgOiByZXF1aXJlKCcuL2RhdGUvdGltZXpvbmVBYmJyJyksXG4gICAgJ3RpbWV6b25lT2Zmc2V0JyA6IHJlcXVpcmUoJy4vZGF0ZS90aW1lem9uZU9mZnNldCcpLFxuICAgICd0b3RhbERheXNJbk1vbnRoJyA6IHJlcXVpcmUoJy4vZGF0ZS90b3RhbERheXNJbk1vbnRoJyksXG4gICAgJ3RvdGFsRGF5c0luWWVhcicgOiByZXF1aXJlKCcuL2RhdGUvdG90YWxEYXlzSW5ZZWFyJyksXG4gICAgJ3dlZWtPZlRoZVllYXInIDogcmVxdWlyZSgnLi9kYXRlL3dlZWtPZlRoZVllYXInKVxufTtcblxuXG4iLCJ2YXIgaXNEYXRlID0gcmVxdWlyZSgnLi4vbGFuZy9pc0RhdGUnKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgZGF5IG9mIHRoZSB5ZWFyICgxLi4zNjYpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGF5T2ZUaGVZZWFyKGRhdGUpe1xuICAgICAgICByZXR1cm4gKERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkgLVxuICAgICAgICAgICAgICAgIERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSkpIC8gODY0MDAwMDAgKyAxO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGF5T2ZUaGVZZWFyO1xuXG5cbiIsInZhciB0b3RhbERheXNJbk1vbnRoID0gcmVxdWlyZSgnLi90b3RhbERheXNJbk1vbnRoJyk7XG52YXIgdG90YWxEYXlzSW5ZZWFyID0gcmVxdWlyZSgnLi90b3RhbERheXNJblllYXInKTtcbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnLi4vdGltZS9jb252ZXJ0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBkYXRlcyAocmFuZ2UpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZihzdGFydCwgZW5kLCB1bml0TmFtZSl7XG4gICAgICAgIC8vIHNvcnQgdGhlIGRhdGVzIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHByb2Nlc3MgKHNwZWNpYWxseSB5ZWFyL21vbnRoKVxuICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgIHZhciBzd2FwID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIGVuZCA9IHN3YXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0O1xuXG4gICAgICAgIGlmICh1bml0TmFtZSA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gZ2V0TW9udGhzRGlmZihzdGFydCwgZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0TmFtZSA9PT0gJ3llYXInKXtcbiAgICAgICAgICAgIG91dHB1dCA9IGdldFllYXJzRGlmZihzdGFydCwgZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0TmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodW5pdE5hbWUgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHRpbWV6b25lIGRpZmZlcmVuY2UgYmVjYXVzZSBvZiBkYXlsaWdodCBzYXZpbmdzIHRpbWVcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRvVXRjKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBlbmQgPSB0b1V0YyhlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0ID0gY29udmVydChlbmQgLSBzdGFydCwgJ21zJywgdW5pdE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9VdGMoZCl7XG4gICAgICAgIC8vIHdlIGlnbm9yZSB0aW1lem9uZSBkaWZmZXJlbmNlcyBvbiBwdXJwb3NlIGJlY2F1c2Ugb2YgZGF5bGlnaHRcbiAgICAgICAgLy8gc2F2aW5ncyB0aW1lLCBvdGhlcndpc2UgaXQgd291bGQgcmV0dXJuIGZyYWN0aW9uYWwgZGF5cy93ZWVrcyBldmVuXG4gICAgICAgIC8vIGlmIGEgZnVsbCBkYXkgZWxhcHNlZC4gZWc6XG4gICAgICAgIC8vIFdlZCBGZWIgMTIgMjAxNCAwMDowMDowMCBHTVQtMDIwMCAoQlJTVClcbiAgICAgICAgLy8gU3VuIEZlYiAxNiAyMDE0IDAwOjAwOjAwIEdNVC0wMzAwIChCUlQpXG4gICAgICAgIC8vIGRpZmYgc2hvdWxkIGJlIDQgZGF5cyBhbmQgbm90IDQuMDQxNjY2NjY2NjY2NjY3XG4gICAgICAgIHJldHVybiBEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkLmdldEhvdXJzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldFNlY29uZHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0TW9udGhzRGlmZihzdGFydCwgZW5kKXtcbiAgICAgICAgcmV0dXJuIGdldEVsYXBzZWRNb250aHMoc3RhcnQsIGVuZCkgK1xuICAgICAgICAgICAgICAgZ2V0RWxhcHNlZFllYXJzKHN0YXJ0LCBlbmQpICogMTIgK1xuICAgICAgICAgICAgICAgZ2V0RnJhY3Rpb25hbE1vbnRoKHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0WWVhcnNEaWZmKHN0YXJ0LCBlbmQpe1xuICAgICAgICB2YXIgZWxhcHNlZFllYXJzID0gZ2V0RWxhcHNlZFllYXJzKHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gZWxhcHNlZFllYXJzICsgZ2V0RnJhY3Rpb25hbFllYXIoc3RhcnQsIGVuZCwgZWxhcHNlZFllYXJzKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEVsYXBzZWRNb250aHMoc3RhcnQsIGVuZCl7XG4gICAgICAgIHZhciBtb250aERpZmYgPSBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCk7XG4gICAgICAgIGlmIChtb250aERpZmYgPCAwKSB7XG4gICAgICAgICAgICBtb250aERpZmYgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGVzcyB0aGFuIGEgZnVsbCBtb250aFxuICAgICAgICBpZiAoc3RhcnQuZ2V0RGF0ZSgpID4gZW5kLmdldERhdGUoKSkge1xuICAgICAgICAgICAgbW9udGhEaWZmIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbnRoRGlmZjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEVsYXBzZWRZZWFycyhzdGFydCwgZW5kKXtcbiAgICAgICAgdmFyIHllYXJEaWZmID0gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xuICAgICAgICAvLyBsZXNzIHRoYW4gYSBmdWxsIHllYXJcbiAgICAgICAgaWYgKHN0YXJ0LmdldE1vbnRoKCkgPiBlbmQuZ2V0TW9udGgoKSkge1xuICAgICAgICAgICAgeWVhckRpZmYgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhckRpZmY7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsTW9udGgoc3RhcnQsIGVuZCl7XG4gICAgICAgIHZhciBmcmFjdGlvbmFsRGlmZiA9IDA7XG4gICAgICAgIHZhciBzdGFydERheSA9IHN0YXJ0LmdldERhdGUoKTtcbiAgICAgICAgdmFyIGVuZERheSA9IGVuZC5nZXREYXRlKCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0RGF5ICE9PSBlbmREYXkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRvdGFsRGF5cyA9IHRvdGFsRGF5c0luTW9udGgoc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGVuZFRvdGFsRGF5cyA9IHRvdGFsRGF5c0luTW9udGgoZW5kKTtcbiAgICAgICAgICAgIHZhciB0b3RhbERheXM7XG4gICAgICAgICAgICB2YXIgZGF5c0VsYXBzZWQ7XG5cbiAgICAgICAgICAgIGlmIChzdGFydERheSA+IGVuZERheSkge1xuICAgICAgICAgICAgICAgIC8vIGVnOiBKYW4gMjkgLSBGZWIgMjcgKDI5IGRheXMgZWxhcHNlZCBidXQgbm90IGEgZnVsbCBtb250aClcbiAgICAgICAgICAgICAgICB2YXIgYmFzZURheSA9IHN0YXJ0VG90YWxEYXlzIC0gc3RhcnREYXk7XG4gICAgICAgICAgICAgICAgZGF5c0VsYXBzZWQgPSBlbmREYXkgKyBiYXNlRGF5O1xuICAgICAgICAgICAgICAgIC8vIHRvdGFsIGRheXMgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIDFzdCBkYXkgb2YgbmV4dCBtb250aCBpZlxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0RGF5ID4gZW5kVG90YWxEYXlzXG4gICAgICAgICAgICAgICAgdG90YWxEYXlzID0gKHN0YXJ0RGF5ID4gZW5kVG90YWxEYXlzKT9cbiAgICAgICAgICAgICAgICAgICAgZW5kVG90YWxEYXlzICsgYmFzZURheSArIDEgOiBzdGFydERheSArIGJhc2VEYXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZyYWN0aW9uYWwgaXMgb25seSBiYXNlZCBvbiBlbmRNb250aCBlZzogSmFuIDEyIC0gRmViIDE4XG4gICAgICAgICAgICAgICAgLy8gKDYgZnJhY3Rpb25hbCBkYXlzLCAyOCBkYXlzIHVudGlsIG5leHQgZnVsbCBtb250aClcbiAgICAgICAgICAgICAgICBkYXlzRWxhcHNlZCA9IGVuZERheSAtIHN0YXJ0RGF5O1xuICAgICAgICAgICAgICAgIHRvdGFsRGF5cyA9IGVuZFRvdGFsRGF5cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhY3Rpb25hbERpZmYgPSBkYXlzRWxhcHNlZCAvIHRvdGFsRGF5cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcmFjdGlvbmFsRGlmZjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxZZWFyKHN0YXJ0LCBlbmQsIGVsYXBzZWRZZWFycyl7XG4gICAgICAgIHZhciBiYXNlID0gZWxhcHNlZFllYXJzP1xuICAgICAgICAgICAgbmV3IERhdGUoZW5kLmdldEZ1bGxZZWFyKCksIHN0YXJ0LmdldE1vbnRoKCksIHN0YXJ0LmdldERhdGUoKSkgOlxuICAgICAgICAgICAgc3RhcnQ7XG4gICAgICAgIHZhciBlbGFwc2VkRGF5cyA9IGRpZmYoYmFzZSwgZW5kLCAnZGF5Jyk7XG4gICAgICAgIHJldHVybiBlbGFwc2VkRGF5cyAvIHRvdGFsRGF5c0luWWVhcihlbmQpO1xuICAgIH1cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkaWZmO1xuXG5cbiIsIlxuICAgIC8vIGVuLVVTIChFbmdsaXNoLCBVbml0ZWQgU3RhdGVzKVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBcImFtXCIgOiBcIkFNXCIsXG4gICAgICAgIFwicG1cIiA6IFwiUE1cIixcblxuICAgICAgICBcInhcIjogXCIlbS8lZC8leVwiLFxuICAgICAgICBcIlhcIjogXCIlSDolTTolU1wiLFxuICAgICAgICBcImNcIjogXCIlYSAlZCAlYiAlWSAlSTolTTolUyAlcCAlWlwiLFxuXG4gICAgICAgIFwibW9udGhzXCIgOiBbXG4gICAgICAgICAgICBcIkphbnVhcnlcIixcbiAgICAgICAgICAgIFwiRmVicnVhcnlcIixcbiAgICAgICAgICAgIFwiTWFyY2hcIixcbiAgICAgICAgICAgIFwiQXByaWxcIixcbiAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICBcIkp1bmVcIixcbiAgICAgICAgICAgIFwiSnVseVwiLFxuICAgICAgICAgICAgXCJBdWd1c3RcIixcbiAgICAgICAgICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgICAgICAgICBcIk9jdG9iZXJcIixcbiAgICAgICAgICAgIFwiTm92ZW1iZXJcIixcbiAgICAgICAgICAgIFwiRGVjZW1iZXJcIlxuICAgICAgICBdLFxuXG4gICAgICAgIFwibW9udGhzX2FiYnJcIiA6IFtcbiAgICAgICAgICAgIFwiSmFuXCIsXG4gICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgXCJNYXJcIixcbiAgICAgICAgICAgIFwiQXByXCIsXG4gICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgXCJKdW5cIixcbiAgICAgICAgICAgIFwiSnVsXCIsXG4gICAgICAgICAgICBcIkF1Z1wiLFxuICAgICAgICAgICAgXCJTZXBcIixcbiAgICAgICAgICAgIFwiT2N0XCIsXG4gICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgXCJEZWNcIlxuICAgICAgICBdLFxuXG4gICAgICAgIFwiZGF5c1wiIDogW1xuICAgICAgICAgICAgXCJTdW5kYXlcIixcbiAgICAgICAgICAgIFwiTW9uZGF5XCIsXG4gICAgICAgICAgICBcIlR1ZXNkYXlcIixcbiAgICAgICAgICAgIFwiV2VkbmVzZGF5XCIsXG4gICAgICAgICAgICBcIlRodXJzZGF5XCIsXG4gICAgICAgICAgICBcIkZyaWRheVwiLFxuICAgICAgICAgICAgXCJTYXR1cmRheVwiXG4gICAgICAgIF0sXG5cbiAgICAgICAgXCJkYXlzX2FiYnJcIiA6IFtcbiAgICAgICAgICAgIFwiU3VuXCIsXG4gICAgICAgICAgICBcIk1vblwiLFxuICAgICAgICAgICAgXCJUdWVcIixcbiAgICAgICAgICAgIFwiV2VkXCIsXG4gICAgICAgICAgICBcIlRodVwiLFxuICAgICAgICAgICAgXCJGcmlcIixcbiAgICAgICAgICAgIFwiU2F0XCJcbiAgICAgICAgXVxuICAgIH07XG5cbiIsInZhciBtaXhJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9taXhJbicpO1xudmFyIGVuVVMgPSByZXF1aXJlKCcuL2kxOG4vZW4tVVMnKTtcblxuICAgIC8vIHdlIGFsc28gdXNlIG1peEluIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBhZmZlY3QgdGhlIG9yaWdpbmFsIGxvY2FsZVxuICAgIHZhciBhY3RpdmVMb2NhbGUgPSBtaXhJbih7fSwgZW5VUywge1xuICAgICAgICAvLyB3ZSBleHBvc2UgYSBcInNldFwiIG1ldGhvZCB0byBhbGxvdyBvdmVycmlkaW5nIHRoZSBnbG9iYWwgbG9jYWxlXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGxvY2FsZURhdGEpe1xuICAgICAgICAgICAgbWl4SW4oYWN0aXZlTG9jYWxlLCBsb2NhbGVEYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhY3RpdmVMb2NhbGU7XG5cblxuIiwidmFyIGlzRGF0ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNEYXRlJyk7XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgaXQncyBhIGxlYXAgeWVhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoZnVsbFllYXIpe1xuICAgICAgICBpZiAoaXNEYXRlKGZ1bGxZZWFyKSkge1xuICAgICAgICAgICAgZnVsbFllYXIgPSBmdWxsWWVhci5nZXRGdWxsWWVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsWWVhciAlIDQwMCA9PT0gMCB8fCAoZnVsbFllYXIgJSAxMDAgIT09IDAgJiYgZnVsbFllYXIgJSA0ID09PSAwKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzTGVhcFllYXI7XG5cblxuIiwidmFyIHN0YXJ0T2YgPSByZXF1aXJlKCcuL3N0YXJ0T2YnKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGRhdGUgaXMgXCJzYW1lXCIgd2l0aCBvcHRpb25hbCBwZXJpb2RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhbWUoZGF0ZTEsIGRhdGUyLCBwZXJpb2Qpe1xuICAgICAgICBpZiAocGVyaW9kKSB7XG4gICAgICAgICAgICBkYXRlMSA9IHN0YXJ0T2YoZGF0ZTEsIHBlcmlvZCk7XG4gICAgICAgICAgICBkYXRlMiA9IHN0YXJ0T2YoZGF0ZTIsIHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihkYXRlMSkgPT09IE51bWJlcihkYXRlMik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1NhbWU7XG5cblxuIiwidmFyIHNvbWUgPSByZXF1aXJlKCcuLi9hcnJheS9zb21lJyk7XG5cbiAgICB2YXIgZGF0ZVBhdHRlcm5zID0gW1xuICAgICAgICAvXihbMC05XXs0fSkkLywgICAgICAgICAgICAgICAgICAgICAgICAvLyBZWVlZXG4gICAgICAgIC9eKFswLTldezR9KS0oWzAtOV17Mn0pJC8sICAgICAgICAgICAgIC8vIFlZWVktTU0gKFlZWVlNTSBub3QgYWxsb3dlZClcbiAgICAgICAgL14oWzAtOV17NH0pLT8oWzAtOV17Mn0pLT8oWzAtOV17Mn0pJC8gLy8gWVlZWS1NTS1ERCBvciBZWVlZTU1ERFxuICAgIF07XG4gICAgdmFyIE9SRF9EQVRFID0gL14oWzAtOV17NH0pLT8oWzAtOV17M30pJC87IC8vIFlZWVktREREXG5cbiAgICB2YXIgdGltZVBhdHRlcm5zID0gW1xuICAgICAgICAvXihbMC05XXsyfSg/OlxcLlswLTldKik/KSQvLCAgICAgICAgICAgICAgICAgICAgICAvLyBISC5oaFxuICAgICAgICAvXihbMC05XXsyfSk6PyhbMC05XXsyfSg/OlxcLlswLTldKik/KSQvLCAgICAgICAgICAvLyBISDpNTS5tbVxuICAgICAgICAvXihbMC05XXsyfSk6PyhbMC05XXsyfSk6PyhbMC05XXsyfShcXC5bMC05XSopPykkLyAvLyBISDpNTTpTUy5zc1xuICAgIF07XG5cbiAgICB2YXIgREFURV9USU1FID0gL14oLispVCguKykkLztcbiAgICB2YXIgVElNRV9aT05FID0gL14oLispKFsrXFwtXSkoWzAtOV17Mn0pOj8oWzAtOV17Mn0pJC87XG5cbiAgICBmdW5jdGlvbiBtYXRjaEFsbChzdHIsIHBhdHRlcm5zKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIGZvdW5kID0gc29tZShwYXR0ZXJucywgZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuICEhKG1hdGNoID0gcGF0dGVybi5leGVjKHN0cikpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmQgPyBtYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHllYXIgdG8gYXZvaWQgRGF0ZS5VVEMgbWFraW5nIGRhdGVzIDwgMTAwIHJlbGF0aXZlIHRvXG4gICAgICAgIC8vIDE5MDBcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyKTtcblxuICAgICAgICB2YXIgdmFsaWQgPVxuICAgICAgICAgICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpID09PSB5ZWFyICYmXG4gICAgICAgICAgICBkYXRlLmdldFVUQ01vbnRoKCkgPT09IG1vbnRoICYmXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSA9PT0gZGF5O1xuICAgICAgICByZXR1cm4gdmFsaWQgPyArZGF0ZSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9yZGluYWxEYXRlKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBPUkRfREFURS5leGVjKHN0cik7XG4gICAgICAgIGlmIChtYXRjaCApIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gK21hdGNoWzFdLFxuICAgICAgICAgICAgICAgIGRheSA9ICttYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgMCwgZGF5KSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gK2RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZShzdHIpIHtcbiAgICAgICAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5O1xuXG4gICAgICAgIG1hdGNoID0gbWF0Y2hBbGwoc3RyLCBkYXRlUGF0dGVybnMpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE9yZGluYWwgZGF0ZXMgYXJlIHZlcmlmaWVkIGRpZmZlcmVudGx5LlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlT3JkaW5hbERhdGUoc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHllYXIgPSAobWF0Y2hbMV0gPT09IHZvaWQgMCkgPyAwIDogK21hdGNoWzFdO1xuICAgICAgICBtb250aCA9IChtYXRjaFsyXSA9PT0gdm9pZCAwKSA/IDAgOiArbWF0Y2hbMl0gLSAxO1xuICAgICAgICBkYXkgPSAobWF0Y2hbM10gPT09IHZvaWQgMCkgPyAxIDogK21hdGNoWzNdO1xuXG4gICAgICAgIHJldHVybiBnZXREYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRpbWUoaHIsIG1pbiwgc2VjKSB7XG4gICAgICAgIHZhciB2YWxpZCA9XG4gICAgICAgICAgICAoaHIgPCAyNCAmJiBociA+PSAwICYmXG4gICAgICAgICAgICAgbWluIDwgNjAgJiYgbWluID49IDAgJiZcbiAgICAgICAgICAgICBzZWMgPCA2MCAmJiBtaW4gPj0gMCkgfHxcbiAgICAgICAgICAgIChociA9PT0gMjQgJiYgbWluID09PSAwICYmIHNlYyA9PT0gMCk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKChociAqIDYwICsgbWluKSAqIDYwICsgc2VjKSAqIDEwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPZmZzZXQoc3RyKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnWicpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBUSU1FX1pPTkUuZXhlYyhzdHIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvdXJzID0gK21hdGNoWzNdLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gKG1hdGNoWzRdID09PSB2b2lkIDApID8gMCA6ICttYXRjaFs0XSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZ2V0VGltZShob3VycywgbWludXRlcywgMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMl0gPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2Zmc2V0OiBvZmZzZXQsIHRpbWU6IG1hdGNoWzFdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyB0aW1lIHpvbmUgc3BlY2lmaWVkLCBhc3N1bWUgVVRDXG4gICAgICAgIHJldHVybiB7IG9mZnNldDogMCwgdGltZTogc3RyIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZU9mZnNldChzdHIpO1xuXG4gICAgICAgIHN0ciA9IG9mZnNldC50aW1lO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQub2Zmc2V0O1xuICAgICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoID0gbWF0Y2hBbGwoc3RyLCB0aW1lUGF0dGVybnMpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaG91cnMgPSAobWF0Y2hbMV0gPT09IHZvaWQgMCkgPyAwIDogK21hdGNoWzFdLFxuICAgICAgICAgICAgbWludXRlcyA9IChtYXRjaFsyXSA9PT0gdm9pZCAwKSA/IDAgOiArbWF0Y2hbMl0sXG4gICAgICAgICAgICBzZWNvbmRzID0gKG1hdGNoWzNdID09PSB2b2lkIDApID8gMCA6ICttYXRjaFszXTtcblxuICAgICAgICByZXR1cm4gZ2V0VGltZShob3VycywgbWludXRlcywgc2Vjb25kcykgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYW4gSVNPODYwMSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcsIGFuZCByZXR1cm4gYSBEYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUlTTzg2MDEoc3RyKXtcbiAgICAgICAgdmFyIG1hdGNoID0gREFURV9USU1FLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgLy8gTm8gdGltZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURhdGUoc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZURhdGUobWF0Y2hbMV0pICsgcGFyc2VUaW1lKG1hdGNoWzJdKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlSVNPODYwMTtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIGdldHMgZGF0ZSBxdWFydGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhcnRlcihkYXRlKXtcbiAgICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgICBpZiAobW9udGggPCAzKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKG1vbnRoIDwgNikgcmV0dXJuIDI7XG4gICAgICAgIGlmIChtb250aCA8IDkpIHJldHVybiAzO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHF1YXJ0ZXI7XG5cblxuIiwidmFyIGNsb25lID0gcmVxdWlyZSgnLi4vbGFuZy9jbG9uZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgbmV3IERhdGUgb2JqZWN0IHJlcHJlc2VudGluZyBzdGFydCBvZiBwZXJpb2RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydE9mKGRhdGUsIHBlcmlvZCl7XG4gICAgICAgIGRhdGUgPSBjbG9uZShkYXRlKTtcblxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IHJlbW92ZWQgXCJicmVha1wiIGZyb20gc3dpdGNoIHNpbmNlIHN0YXJ0IG9mXG4gICAgICAgIC8vIG1vbnRoL3llYXIvZXRjIHNob3VsZCBhbHNvIHJlc2V0IHRoZSBmb2xsb3dpbmcgcGVyaW9kc1xuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRNb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRIb3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicrIHBlcmlvZCArJ1wiIGlzIG5vdCBhIHZhbGlkIHBlcmlvZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2VlayBpcyB0aGUgb25seSBjYXNlIHRoYXQgc2hvdWxkIHJlc2V0IHRoZSB3ZWVrRGF5IGFuZCBtYXliZSBldmVuXG4gICAgICAgIC8vIG92ZXJmbG93IHRvIHByZXZpb3VzIG1vbnRoXG4gICAgICAgIGlmIChwZXJpb2QgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdmFyIHdlZWtEYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgdmFyIGJhc2VEYXRlID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgICBpZiAod2Vla0RheSkge1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrRGF5ID49IGJhc2VEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3RhcnQgb2YgdGhlIHdlZWsgaXMgb24gcHJldmlvdXMgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXREYXRlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc3RhcnRPZjtcblxuXG4iLCJ2YXIgcGFkID0gcmVxdWlyZSgnLi4vbnVtYmVyL3BhZCcpO1xudmFyIGxwYWQgPSByZXF1aXJlKCcuLi9zdHJpbmcvbHBhZCcpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2kxOG5fJyk7XG52YXIgZGF5T2ZUaGVZZWFyID0gcmVxdWlyZSgnLi9kYXlPZlRoZVllYXInKTtcbnZhciB0aW1lem9uZU9mZnNldCA9IHJlcXVpcmUoJy4vdGltZXpvbmVPZmZzZXQnKTtcbnZhciB0aW1lem9uZUFiYnIgPSByZXF1aXJlKCcuL3RpbWV6b25lQWJicicpO1xudmFyIHdlZWtPZlRoZVllYXIgPSByZXF1aXJlKCcuL3dlZWtPZlRoZVllYXInKTtcblxuICAgIHZhciBfY29tYmluYXRpb25zID0ge1xuICAgICAgICAnRCc6ICclbS8lZC8leScsXG4gICAgICAgICdGJzogJyVZLSVtLSVkJyxcbiAgICAgICAgJ3InOiAnJUk6JU06JVMgJXAnLFxuICAgICAgICAnUic6ICclSDolTScsXG4gICAgICAgICdUJzogJyVIOiVNOiVTJyxcbiAgICAgICAgJ3gnOiAnbG9jYWxlJyxcbiAgICAgICAgJ1gnOiAnbG9jYWxlJyxcbiAgICAgICAgJ2MnOiAnbG9jYWxlJ1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIGZvcm1hdCBkYXRlIGJhc2VkIG9uIHN0cmZ0aW1lIGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmZ0aW1lKGRhdGUsIGZvcm1hdCwgbG9jYWxlRGF0YSl7XG4gICAgICAgIGxvY2FsZURhdGEgPSBsb2NhbGVEYXRhICB8fCBpMThuO1xuICAgICAgICB2YXIgcmVUb2tlbiA9IC8lKFthLXolXSkvZ2k7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZUl0ZXJhdG9yKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2gsIHRva2VuKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZGF0ZSwgdG9rZW4sIGxvY2FsZURhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXRcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlVG9rZW4sIG1ha2VJdGVyYXRvcihleHBhbmRDb21iaW5hdGlvbnMpKVxuICAgICAgICAgICAgLnJlcGxhY2UocmVUb2tlbiwgbWFrZUl0ZXJhdG9yKGNvbnZlcnRUb2tlbikpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZXhwYW5kQ29tYmluYXRpb25zKGRhdGUsIHRva2VuLCBsMTBuKXtcbiAgICAgICAgaWYgKHRva2VuIGluIF9jb21iaW5hdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBleHBhbmRlZCA9IF9jb21iaW5hdGlvbnNbdG9rZW5dO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSAnbG9jYWxlJz8gbDEwblt0b2tlbl0gOiBleHBhbmRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJScrIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9rZW4oZGF0ZSwgdG9rZW4sIGwxMG4pe1xuICAgICAgICBzd2l0Y2ggKHRva2VuKXtcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIHJldHVybiBsMTBuLmRheXNfYWJicltkYXRlLmdldERheSgpXTtcbiAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgIHJldHVybiBsMTBuLmRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgIHJldHVybiBsMTBuLm1vbnRoc19hYmJyW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbDEwbi5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDApLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXREYXRlKCksIDIpO1xuICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSwgMiwgJyAnKTtcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRIb3VycygpICUgMTIsIDIpO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXlPZlRoZVllYXIoZGF0ZSksIDMpO1xuICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxwYWQoZGF0ZS5nZXRIb3VycygpICUgMTIsIDIpO1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKGRhdGUuZ2V0TWludXRlcygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFxuJztcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCkgPj0gMTI/IGwxMG4ucG0gOiBsMTBuLmFtO1xuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb2tlbihkYXRlLCAncCcsIGwxMG4pLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldFNlY29uZHMoKSwgMik7XG4gICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcdCc7XG4gICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5ID09PSAwPyA3IDogZGF5O1xuICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZCh3ZWVrT2ZUaGVZZWFyKGRhdGUpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZCh3ZWVrT2ZUaGVZZWFyKGRhdGUsIDEpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTtcbiAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lem9uZU9mZnNldChkYXRlKTtcbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lem9uZUFiYnIoZGF0ZSk7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHVucmVjb2duaXplZCB0b2tlbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gJyUnKyB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzdHJmdGltZTtcblxuXG4iLCJ2YXIgdGltZXpvbmVPZmZzZXQgPSByZXF1aXJlKCcuL3RpbWV6b25lT2Zmc2V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBBYmJyZXZpYXRlZCB0aW1lIHpvbmUgbmFtZSBvciBzaW1pbGFyIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWV6b25lQWJicihkYXRlKXtcbiAgICAgICAgLy8gRGF0ZS50b1N0cmluZyBnaXZlcyBkaWZmZXJlbnQgcmVzdWx0cyBkZXBlbmRpbmcgb24gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIvc3lzdGVtIHNvIHdlIGZhbGxiYWNrIHRvIHRpbWV6b25lIG9mZnNldFxuICAgICAgICAvLyBjaHJvbWU6ICdNb24gQXByIDA4IDIwMTMgMDk6MDI6MDQgR01ULTAzMDAgKEJSVCknXG4gICAgICAgIC8vIElFOiAnTW9uIEFwciA4IDA5OjAyOjA0IFVUQy0wMzAwIDIwMTMnXG4gICAgICAgIHZhciB0eiA9IC9cXCgoW0EtWl17Myw0fSlcXCkvLmV4ZWMoZGF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHR6PyB0elsxXSA6IHRpbWV6b25lT2Zmc2V0KGRhdGUpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdGltZXpvbmVBYmJyO1xuXG5cbiIsInZhciBwYWQgPSByZXF1aXJlKCcuLi9udW1iZXIvcGFkJyk7XG5cbiAgICAvKipcbiAgICAgKiB0aW1lIHpvbmUgYXMgaG91ciBhbmQgbWludXRlIG9mZnNldCBmcm9tIFVUQyAoZS5nLiArMDkwMClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lem9uZU9mZnNldChkYXRlKXtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgICAgIHZhciBoID0gcGFkKE1hdGguZmxvb3IoYWJzIC8gNjApLCAyKTtcbiAgICAgICAgdmFyIG0gPSBwYWQoYWJzICUgNjAsIDIpO1xuICAgICAgICByZXR1cm4gKG9mZnNldCA+IDA/ICctJyA6ICcrJykgKyBoICsgbTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRpbWV6b25lT2Zmc2V0O1xuXG5cbiIsInZhciBpc0RhdGUgPSByZXF1aXJlKCcuLi9sYW5nL2lzRGF0ZScpO1xudmFyIGlzTGVhcFllYXIgPSByZXF1aXJlKCcuL2lzTGVhcFllYXInKTtcblxuICAgIHZhciBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgdG90YWwgYW1vdW50IG9mIGRheXMgaW4gdGhlIG1vbnRoIChjb25zaWRlcmluZyBsZWFwIHllYXJzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvdGFsRGF5c0luTW9udGgoZnVsbFllYXIsIG1vbnRoSW5kZXgpe1xuICAgICAgICBpZiAoaXNEYXRlKGZ1bGxZZWFyKSkge1xuICAgICAgICAgICAgbW9udGhJbmRleCA9IGZ1bGxZZWFyLmdldE1vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9udGhJbmRleCA9PT0gMSAmJiBpc0xlYXBZZWFyKGZ1bGxZZWFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIDI5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERBWVNfSU5fTU9OVEhbbW9udGhJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvdGFsRGF5c0luTW9udGg7XG5cblxuIiwidmFyIGlzTGVhcFllYXIgPSByZXF1aXJlKCcuL2lzTGVhcFllYXInKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgYW1vdW50IG9mIGRheXMgaW4gdGhlIHllYXIgZm9sbG93aW5nIHRoZSBncmVnb3JpYW4gY2FsZW5kYXJcbiAgICAgKiBhbmQgbGVhcCB5ZWFyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvdGFsRGF5c0luWWVhcihmdWxsWWVhcil7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKGZ1bGxZZWFyKT8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdG90YWxEYXlzSW5ZZWFyO1xuXG5cbiIsInZhciBkYXlPZlRoZVllYXIgPSByZXF1aXJlKCcuL2RheU9mVGhlWWVhcicpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGJhc2VkIG9uIGdpdmVuIGZpcnN0RGF5T2ZXZWVrXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2Vla09mVGhlWWVhcihkYXRlLCBmaXJzdERheU9mV2Vlayl7XG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrID0gZmlyc3REYXlPZldlZWsgPT0gbnVsbD8gMCA6IGZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICB2YXIgZG95ID0gZGF5T2ZUaGVZZWFyKGRhdGUpO1xuICAgICAgICB2YXIgZG93ID0gKDcgKyBkYXRlLmdldERheSgpIC0gZmlyc3REYXlPZldlZWspICUgNztcbiAgICAgICAgdmFyIHJlbGF0aXZlV2Vla0RheSA9IDYgLSBmaXJzdERheU9mV2VlayAtIGRvdztcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGRveSArIHJlbGF0aXZlV2Vla0RheSkgLyA3KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdlZWtPZlRoZVllYXI7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdhd2FpdERlbGF5JyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXdhaXREZWxheScpLFxuICAgICdiaW5kJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vYmluZCcpLFxuICAgICdjb21wb3NlJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tcG9zZScpLFxuICAgICdjb25zdGFudCcgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0YW50JyksXG4gICAgJ2RlYm91bmNlJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vZGVib3VuY2UnKSxcbiAgICAnZnVuYycgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL2Z1bmMnKSxcbiAgICAnaWRlbnRpdHknIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9pZGVudGl0eScpLFxuICAgICdtYWtlSXRlcmF0b3JfJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpLFxuICAgICdwYXJ0aWFsJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vcGFydGlhbCcpLFxuICAgICdwcm9wJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvcCcpLFxuICAgICdzZXJpZXMnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9zZXJpZXMnKSxcbiAgICAndGhyb3R0bGUnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi90aHJvdHRsZScpLFxuICAgICd0aW1lb3V0JyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vdGltZW91dCcpLFxuICAgICd0aW1lcycgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL3RpbWVzJyksXG4gICAgJ3dyYXAnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi93cmFwJylcbn07XG5cblxuIiwidmFyIG5vdyA9IHJlcXVpcmUoJy4uL3RpbWUvbm93Jyk7XG52YXIgdGltZW91dCA9IHJlcXVpcmUoJy4vdGltZW91dCcpO1xudmFyIGFwcGVuZCA9IHJlcXVpcmUoJy4uL2FycmF5L2FwcGVuZCcpO1xuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIGEgbWluaW11bSBkZWxheSBmb3IgY2FsbGJhY2tzXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXdhaXREZWxheSggY2FsbGJhY2ssIGRlbGF5ICl7XG4gICAgICAgIHZhciBiYXNlVGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBhbGwgYnJvd3NlcnMgd2lsbCBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5IChhdm9pZCBoYXJkXG4gICAgICAgICAgICAvLyB0byBjYXRjaCBlcnJvcnMpIG5vdCB1c2luZyBcIjBcIiBiZWNhdXNlIG9mIG9sZCBicm93c2VycyBhbmQgYWxzb1xuICAgICAgICAgICAgLy8gc2luY2UgbmV3IGJyb3dzZXJzIGluY3JlYXNlIHRoZSB2YWx1ZSB0byBiZSBhdCBsZWFzdCBcIjRcIlxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGltZXJzLmh0bWwjZG9tLXdpbmRvd3RpbWVycy1zZXR0aW1lb3V0XG4gICAgICAgICAgICB2YXIgbXMgPSBNYXRoLm1heChiYXNlVGltZSAtIG5vdygpLCA0KTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lb3V0LmFwcGx5KHRoaXMsIGFwcGVuZChbY2FsbGJhY2ssIG1zLCB0aGlzXSwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhd2FpdERlbGF5O1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgZ2l2ZW4gY29udGV4dCwgb3B0aW9uYWxseSBhZGRpbmcgYW55IGFkZGl0aW9uYWwgc3VwcGxpZWQgcGFyYW1ldGVycyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmd1bWVudHMgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgRnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgICBFeGVjdXRpb24gY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge3Jlc3R9IGFyZ3MgICAgQXJndW1lbnRzICgwLi4ubiBhcmd1bWVudHMpLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBXcmFwcGVkIEZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZm4sIGNvbnRleHQsIGFyZ3Mpe1xuICAgICAgICB2YXIgYXJnc0FyciA9IHNsaWNlKGFyZ3VtZW50cywgMik7IC8vY3VycmllZCBhcmdzXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3NBcnIuY29uY2F0KHNsaWNlKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpbmQ7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyBtdWx0aXBsZSBmdW5jdGlvbnMsIHBhc3NpbmcgcmVzdWx0cyB0b1xuICAgICAqIGVhY2ggb3RoZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgICAgICAvLyBvbmx5IGNhcmVzIGFib3V0IHRoZSBmaXJzdCBhcmd1bWVudCBzaW5jZSB0aGUgY2hhaW4gY2FuIG9ubHlcbiAgICAgICAgICAgIC8vIGRlYWwgd2l0aCBhIHNpbmdsZSByZXR1cm4gdmFsdWUgYW55d2F5LiBJdCBzaG91bGQgc3RhcnQgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgZm4uXG4gICAgICAgICAgICB2YXIgbiA9IGZucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gZm5zW25dLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICB9O1xuICAgICB9XG5cbiAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb21wb3NlO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBEZWJvdW5jZSBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmbiwgdGhyZXNob2xkLCBpc0FzYXApe1xuICAgICAgICB2YXIgdGltZW91dCwgcmVzdWx0O1xuICAgICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKXtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLCBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKXtcbiAgICAgICAgICAgICAgICBpZiAoISBpc0FzYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXNhcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZGVsYXllZCwgdGhyZXNob2xkKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbGwgYSBtZXRob2Qgb24gdGhlIHBhc3NlZCBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jKG5hbWUpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgICAgIHJldHVybiBvYmpbbmFtZV0oKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmM7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWwpe1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xudmFyIHByb3AgPSByZXF1aXJlKCcuL3Byb3AnKTtcbnZhciBkZWVwTWF0Y2hlcyA9IHJlcXVpcmUoJy4uL29iamVjdC9kZWVwTWF0Y2hlcycpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYXJndW1lbnQgaW50byBhIHZhbGlkIGl0ZXJhdG9yLlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSBvbiBtb3N0IGFycmF5L29iamVjdC9jb2xsZWN0aW9uIG1ldGhvZHMgdGhhdCByZWNlaXZlcyBhXG4gICAgICogY2FsbGJhY2svaXRlcmF0b3IgcHJvdmlkaW5nIGEgc2hvcnRjdXQgc3ludGF4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VJdGVyYXRvcihzcmMsIHRoaXNPYmope1xuICAgICAgICBpZiAoc3JjID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2godHlwZW9mIHNyYykge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCB0byBpbXByb3ZlIHBlcmYgKG1vc3QgY29tbW9uIGNhc2UpXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBhdm9pZCB1c2luZyBgRnVuY3Rpb24jY2FsbGAgaWYgbm90IG5lZWRlZCwgd2hpY2ggYm9vc3RzXG4gICAgICAgICAgICAgICAgLy8gcGVyZiBhIGxvdCBpbiBzb21lIGNhc2VzXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpc09iaiAhPT0gJ3VuZGVmaW5lZCcpPyBmdW5jdGlvbih2YWwsIGksIGFycil7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcmMuY2FsbCh0aGlzT2JqLCB2YWwsIGksIGFycik7XG4gICAgICAgICAgICAgICAgfSA6IHNyYztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWVwTWF0Y2hlcyh2YWwsIHNyYyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wKHNyYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VJdGVyYXRvcjtcblxuXG4iLCJ2YXIgc2xpY2UgPSByZXF1aXJlKCcuLi9hcnJheS9zbGljZScpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZikge1xuICAgICAgICB2YXIgYXMgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFzLmNvbmNhdChzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzW2ldID09PSBwYXJ0aWFsLl8pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3Muc3BsaWNlKC0xKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJ0aWFsLl8gPSB7fTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGFydGlhbDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGdldHMgYSBwcm9wZXJ0eSBvZiB0aGUgcGFzc2VkIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3AobmFtZSl7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmope1xuICAgICAgICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHByb3A7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYSBsaXN0IG9mIGZ1bmN0aW9ucyBpbiBzZXF1ZW5jZVxuICAgICAqIHBhc3NpbmcgdGhlIHNhbWUgYXJndW1lbnRzIHRvIGVhY2ggb25lLiAodXNlZnVsIGZvciBiYXRjaCBwcm9jZXNzaW5nXG4gICAgICogaXRlbXMgZHVyaW5nIGEgZm9yRWFjaCBsb29wKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcmllcygpe1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICBuID0gZm5zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIGZuc1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlcmllcztcblxuXG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgnLi4vdGltZS9ub3cnKTtcblxuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZuLCBkZWxheSl7XG4gICAgICAgIHZhciBjb250ZXh0LCB0aW1lb3V0LCByZXN1bHQsIGFyZ3MsXG4gICAgICAgICAgICBkaWZmLCBwcmV2Q2FsbCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKXtcbiAgICAgICAgICAgIHByZXZDYWxsID0gbm93KCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocm90dGxlZCgpe1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgZGlmZiA9IGRlbGF5IC0gKG5vdygpIC0gcHJldkNhbGwpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBkZWxheWVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEgdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRocm90dGxlZDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWxheXMgdGhlIGNhbGwgb2YgYSBmdW5jdGlvbiB3aXRoaW4gYSBnaXZlbiBjb250ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVvdXQoZm4sIG1pbGxpcywgY29udGV4dCl7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDMpO1xuXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH0sIG1pbGxpcyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW1lb3V0O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIGNhbGxiYWNrIGEgc2V0IGFtb3VudCBvZiB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGNhbGxiYWNrLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCh0aGlzT2JqLCBpKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRpbWVzO1xuXG5cbiIsInZhciBwYXJ0aWFsID0gcmVxdWlyZSgnLi9wYXJ0aWFsJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgICAgKiBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gICAgICogY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKGZuLCB3cmFwcGVyKXtcbiAgICAgICAgcmV0dXJuIHBhcnRpYWwod3JhcHBlciwgZm4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gd3JhcDtcblxuXG4iLCIvKipAbGljZW5zZVxuICogbW91dCB2MC4xMS4wIHwgaHR0cDovL21vdXRqcy5jb20gfCBNSVQgbGljZW5zZVxuICovXG5cblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ1ZFUlNJT04nIDogJzAuMTEuMCcsXG4gICAgJ2FycmF5JyA6IHJlcXVpcmUoJy4vYXJyYXknKSxcbiAgICAnY29sbGVjdGlvbicgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKSxcbiAgICAnZGF0ZScgOiByZXF1aXJlKCcuL2RhdGUnKSxcbiAgICAnZnVuY3Rpb24nIDogcmVxdWlyZSgnLi9mdW5jdGlvbicpLFxuICAgICdsYW5nJyA6IHJlcXVpcmUoJy4vbGFuZycpLFxuICAgICdtYXRoJyA6IHJlcXVpcmUoJy4vbWF0aCcpLFxuICAgICdudW1iZXInIDogcmVxdWlyZSgnLi9udW1iZXInKSxcbiAgICAnb2JqZWN0JyA6IHJlcXVpcmUoJy4vb2JqZWN0JyksXG4gICAgJ3F1ZXJ5U3RyaW5nJyA6IHJlcXVpcmUoJy4vcXVlcnlTdHJpbmcnKSxcbiAgICAncmFuZG9tJyA6IHJlcXVpcmUoJy4vcmFuZG9tJyksXG4gICAgJ3N0cmluZycgOiByZXF1aXJlKCcuL3N0cmluZycpLFxuICAgICd0aW1lJyA6IHJlcXVpcmUoJy4vdGltZScpLFxuICAgICdmbicgOiByZXF1aXJlKCcuL2Z1bmN0aW9uJylcbn07XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdHTE9CQUwnIDogcmVxdWlyZSgnLi9sYW5nL0dMT0JBTCcpLFxuICAgICdjbG9uZScgOiByZXF1aXJlKCcuL2xhbmcvY2xvbmUnKSxcbiAgICAnY3JlYXRlT2JqZWN0JyA6IHJlcXVpcmUoJy4vbGFuZy9jcmVhdGVPYmplY3QnKSxcbiAgICAnY3RvckFwcGx5JyA6IHJlcXVpcmUoJy4vbGFuZy9jdG9yQXBwbHknKSxcbiAgICAnZGVlcENsb25lJyA6IHJlcXVpcmUoJy4vbGFuZy9kZWVwQ2xvbmUnKSxcbiAgICAnZGVlcEVxdWFscycgOiByZXF1aXJlKCcuL2xhbmcvZGVlcEVxdWFscycpLFxuICAgICdkZWZhdWx0cycgOiByZXF1aXJlKCcuL2xhbmcvZGVmYXVsdHMnKSxcbiAgICAnaW5oZXJpdFByb3RvdHlwZScgOiByZXF1aXJlKCcuL2xhbmcvaW5oZXJpdFByb3RvdHlwZScpLFxuICAgICdpcycgOiByZXF1aXJlKCcuL2xhbmcvaXMnKSxcbiAgICAnaXNBcmd1bWVudHMnIDogcmVxdWlyZSgnLi9sYW5nL2lzQXJndW1lbnRzJyksXG4gICAgJ2lzQXJyYXknIDogcmVxdWlyZSgnLi9sYW5nL2lzQXJyYXknKSxcbiAgICAnaXNCb29sZWFuJyA6IHJlcXVpcmUoJy4vbGFuZy9pc0Jvb2xlYW4nKSxcbiAgICAnaXNEYXRlJyA6IHJlcXVpcmUoJy4vbGFuZy9pc0RhdGUnKSxcbiAgICAnaXNFbXB0eScgOiByZXF1aXJlKCcuL2xhbmcvaXNFbXB0eScpLFxuICAgICdpc0Zpbml0ZScgOiByZXF1aXJlKCcuL2xhbmcvaXNGaW5pdGUnKSxcbiAgICAnaXNGdW5jdGlvbicgOiByZXF1aXJlKCcuL2xhbmcvaXNGdW5jdGlvbicpLFxuICAgICdpc0ludGVnZXInIDogcmVxdWlyZSgnLi9sYW5nL2lzSW50ZWdlcicpLFxuICAgICdpc0tpbmQnIDogcmVxdWlyZSgnLi9sYW5nL2lzS2luZCcpLFxuICAgICdpc05hTicgOiByZXF1aXJlKCcuL2xhbmcvaXNOYU4nKSxcbiAgICAnaXNOdWxsJyA6IHJlcXVpcmUoJy4vbGFuZy9pc051bGwnKSxcbiAgICAnaXNOdW1iZXInIDogcmVxdWlyZSgnLi9sYW5nL2lzTnVtYmVyJyksXG4gICAgJ2lzT2JqZWN0JyA6IHJlcXVpcmUoJy4vbGFuZy9pc09iamVjdCcpLFxuICAgICdpc1BsYWluT2JqZWN0JyA6IHJlcXVpcmUoJy4vbGFuZy9pc1BsYWluT2JqZWN0JyksXG4gICAgJ2lzUHJpbWl0aXZlJyA6IHJlcXVpcmUoJy4vbGFuZy9pc1ByaW1pdGl2ZScpLFxuICAgICdpc1JlZ0V4cCcgOiByZXF1aXJlKCcuL2xhbmcvaXNSZWdFeHAnKSxcbiAgICAnaXNTdHJpbmcnIDogcmVxdWlyZSgnLi9sYW5nL2lzU3RyaW5nJyksXG4gICAgJ2lzVW5kZWZpbmVkJyA6IHJlcXVpcmUoJy4vbGFuZy9pc1VuZGVmaW5lZCcpLFxuICAgICdpc250JyA6IHJlcXVpcmUoJy4vbGFuZy9pc250JyksXG4gICAgJ2tpbmRPZicgOiByZXF1aXJlKCcuL2xhbmcva2luZE9mJyksXG4gICAgJ3RvQXJyYXknIDogcmVxdWlyZSgnLi9sYW5nL3RvQXJyYXknKSxcbiAgICAndG9OdW1iZXInIDogcmVxdWlyZSgnLi9sYW5nL3RvTnVtYmVyJyksXG4gICAgJ3RvU3RyaW5nJyA6IHJlcXVpcmUoJy4vbGFuZy90b1N0cmluZycpXG59O1xuXG5cbiIsIlxuXG4gICAgLy8gUmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgY29udGV4dCAod29ya3Mgb24gRVMzIGFuZCBFUzUtc3RyaWN0IG1vZGUpXG4gICAgLy9qc2hpbnQgLVcwNjEsIC1XMDY0XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cbiIsInZhciBraW5kT2YgPSByZXF1aXJlKCcuL2tpbmRPZicpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcbnZhciBtaXhJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9taXhJbicpO1xuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgbmF0aXZlIHR5cGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbCl7XG4gICAgICAgIHN3aXRjaCAoa2luZE9mKHZhbCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lT2JqZWN0KHZhbCk7XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXkodmFsKTtcbiAgICAgICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKHZhbCk7XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKHZhbCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZU9iamVjdChzb3VyY2UpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1peEluKHt9LCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHIpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gJyc7XG4gICAgICAgIGZsYWdzICs9IHIubXVsdGlsaW5lID8gJ20nIDogJyc7XG4gICAgICAgIGZsYWdzICs9IHIuZ2xvYmFsID8gJ2cnIDogJyc7XG4gICAgICAgIGZsYWdzICs9IHIuaWdub3JlQ2FzZSA/ICdpJyA6ICcnO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyLnNvdXJjZSwgZmxhZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lRGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgrZGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheShhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZSgpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cblxuIiwidmFyIG1peEluID0gcmVxdWlyZSgnLi4vb2JqZWN0L21peEluJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgT2JqZWN0IHVzaW5nIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIHNldHRpbmcgY3VzdG9tIHByb3BlcnRpZXMuXG4gICAgICogLSBNaXggYmV0d2VlbiBEb3VnbGFzIENyb2NrZm9yZCBQcm90b3R5cGFsIEluaGVyaXRhbmNlIDxodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL3Byb3RvdHlwYWwuaHRtbD4gYW5kIHRoZSBFY21hU2NyaXB0IDUgYE9iamVjdC5jcmVhdGUoKWAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnQgICAgUGFyZW50IE9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXSBPYmplY3QgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENyZWF0ZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdChwYXJlbnQsIHByb3BzKXtcbiAgICAgICAgZnVuY3Rpb24gRigpe31cbiAgICAgICAgRi5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBtaXhJbihuZXcgRigpLCBwcm9wcyk7XG5cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVPYmplY3Q7XG5cblxuIiwiXG5cbiAgICBmdW5jdGlvbiBGKCl7fVxuXG4gICAgLyoqXG4gICAgICogRG8gZm4uYXBwbHkgb24gYSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdG9yQXBwbHkoY3RvciwgYXJncykge1xuICAgICAgICBGLnByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgRigpO1xuICAgICAgICBjdG9yLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY3RvckFwcGx5O1xuXG5cbiIsInZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbnZhciBmb3JPd24gPSByZXF1aXJlKCcuLi9vYmplY3QvZm9yT3duJyk7XG52YXIga2luZE9mID0gcmVxdWlyZSgnLi9raW5kT2YnKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjbG9uZSBuYXRpdmUgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVlcENsb25lKHZhbCwgaW5zdGFuY2VDbG9uZSkge1xuICAgICAgICBzd2l0Y2ggKCBraW5kT2YodmFsKSApIHtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lT2JqZWN0KHZhbCwgaW5zdGFuY2VDbG9uZSk7XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXkodmFsLCBpbnN0YW5jZUNsb25lKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZU9iamVjdChzb3VyY2UsIGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yT3duKHNvdXJjZSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBkZWVwQ2xvbmUodmFsLCBpbnN0YW5jZUNsb25lKTtcbiAgICAgICAgICAgIH0sIG91dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZUNsb25lKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheShhcnIsIGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbiA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICB2YWw7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBkZWVwQ2xvbmUoYXJyW2ldLCBpbnN0YW5jZUNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVlcENsb25lO1xuXG5cblxuIiwidmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcbnZhciBvYmpFcXVhbHMgPSByZXF1aXJlKCcuLi9vYmplY3QvZXF1YWxzJyk7XG52YXIgYXJyRXF1YWxzID0gcmVxdWlyZSgnLi4vYXJyYXkvZXF1YWxzJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjaGVja3MgZm9yIHNhbWUgcHJvcGVydGllcyBhbmQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBFcXVhbHMoYSwgYiwgY2FsbGJhY2spe1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGlzO1xuXG4gICAgICAgIHZhciBib3RoT2JqZWN0cyA9IGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpO1xuICAgICAgICB2YXIgYm90aEFycmF5cyA9ICFib3RoT2JqZWN0cyAmJiBpc0FycmF5KGEpICYmIGlzQXJyYXkoYik7XG5cbiAgICAgICAgaWYgKCFib3RoT2JqZWN0cyAmJiAhYm90aEFycmF5cykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKXtcbiAgICAgICAgICAgIHJldHVybiBkZWVwRXF1YWxzKGEsIGIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2QgPSBib3RoT2JqZWN0cyA/IG9iakVxdWFscyA6IGFyckVxdWFscztcbiAgICAgICAgcmV0dXJuIG1ldGhvZChhLCBiLCBjb21wYXJlKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbHM7XG5cblxuIiwidmFyIHRvQXJyYXkgPSByZXF1aXJlKCcuL3RvQXJyYXknKTtcbnZhciBmaW5kID0gcmVxdWlyZSgnLi4vYXJyYXkvZmluZCcpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZpcnN0IG5vbiB2b2lkIGFyZ3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdHModmFyX2FyZ3Mpe1xuICAgICAgICByZXR1cm4gZmluZCh0b0FycmF5KGFyZ3VtZW50cyksIG5vblZvaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vblZvaWQodmFsKXtcbiAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuIiwidmFyIGNyZWF0ZU9iamVjdCA9IHJlcXVpcmUoJy4vY3JlYXRlT2JqZWN0Jyk7XG5cbiAgICAvKipcbiAgICAqIEluaGVyaXQgcHJvdG90eXBlIGZyb20gYW5vdGhlciBPYmplY3QuXG4gICAgKiAtIGluc3BpcmVkIGJ5IE5pY2hvbGFzIFphY2thcyA8aHR0cDovL25jem9ubGluZS5uZXQ+IFNvbHV0aW9uXG4gICAgKiBAcGFyYW0ge29iamVjdH0gY2hpbGQgQ2hpbGQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50ICAgIFBhcmVudCBPYmplY3RcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRQcm90b3R5cGUoY2hpbGQsIHBhcmVudCl7XG4gICAgICAgIHZhciBwID0gY3JlYXRlT2JqZWN0KHBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICBwLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IHA7XG4gICAgICAgIGNoaWxkLnN1cGVyXyA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbmhlcml0UHJvdG90eXBlO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGJvdGggYXJndW1lbnRzIGFyZSBlZ2FsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHgsIHkpe1xuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBib3Jyb3dlZCBmcm9tIGhhcm1vbnk6ZWdhbCBzcGVjXG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgLy8gMCA9PT0gLTAsIGJ1dCB0aGV5IGFyZSBub3QgaWRlbnRpY2FsXG4gICAgICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmFOICE9PSBOYU4sIGJ1dCB0aGV5IGFyZSBpZGVudGljYWwuXG4gICAgICAgIC8vIE5hTnMgYXJlIHRoZSBvbmx5IG5vbi1yZWZsZXhpdmUgdmFsdWUsIGkuZS4sIGlmIHggIT09IHgsXG4gICAgICAgIC8vIHRoZW4geCBpcyBhIE5hTi5cbiAgICAgICAgLy8gaXNOYU4gaXMgYnJva2VuOiBpdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gbnVtYmVyLCBzb1xuICAgICAgICAvLyBpc05hTihcImZvb1wiKSA9PiB0cnVlXG4gICAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpcztcblxuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcblxuICAgIC8qKlxuICAgICAqL1xuICAgIHZhciBpc0FyZ3MgPSBpc0tpbmQoYXJndW1lbnRzLCAnQXJndW1lbnRzJyk/XG4gICAgICAgICAgICBmdW5jdGlvbih2YWwpe1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnQXJndW1lbnRzJyk7XG4gICAgICAgICAgICB9IDpcbiAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgICAgICAgICAgLy8gQXJndW1lbnRzIGlzIGFuIE9iamVjdCBvbiBJRTdcbiAgICAgICAgICAgICAgICByZXR1cm4gISEodmFsICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsICdjYWxsZWUnKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3M7XG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnQXJyYXknKTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuIiwidmFyIGlzS2luZCA9IHJlcXVpcmUoJy4vaXNLaW5kJyk7XG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ0Jvb2xlYW4nKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0Jvb2xlYW47XG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdEYXRlJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNEYXRlO1xuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi4vb2JqZWN0L2Zvck93bicpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsKXtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCA9PSAnb2JqZWN0JyBzbyB3ZSBjaGVjayBpdCBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQXJyYXkodmFsKSApIHtcbiAgICAgICAgICAgIHJldHVybiAhdmFsLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvck93bih2YWwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVhayBsb29wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcblxuXG4iLCJ2YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2lzTnVtYmVyJyk7XG52YXIgR0xPQkFMID0gcmVxdWlyZSgnLi9HTE9CQUwnKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHZhbHVlIGlzIGZpbml0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbCl7XG4gICAgICAgIHZhciBpcyA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsICE9PSAnJykge1xuICAgICAgICAgICAgaXMgPSBHTE9CQUwuaXNGaW5pdGUoIHBhcnNlRmxvYXQodmFsKSApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbCkpe1xuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgaXNOdW1iZXIgYmVjYXVzZSBvZiBOdW1iZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIGlzID0gR0xPQkFMLmlzRmluaXRlKCB2YWwgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0Zpbml0ZTtcblxuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ0Z1bmN0aW9uJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuIiwidmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi9pc051bWJlcicpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgYW4gaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWwpe1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsKSAmJiAodmFsICUgMSA9PT0gMCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG5cblxuIiwidmFyIGtpbmRPZiA9IHJlcXVpcmUoJy4va2luZE9mJyk7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgZnJvbSBhIHNwZWNpZmljIFwia2luZFwiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2luZCh2YWwsIGtpbmQpe1xuICAgICAgICByZXR1cm4ga2luZE9mKHZhbCkgPT09IGtpbmQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNLaW5kO1xuXG4iLCJ2YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2lzTnVtYmVyJyk7XG52YXIgJGlzTmFOID0gcmVxdWlyZSgnLi4vbnVtYmVyL2lzTmFOJyk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB2YWx1ZSBpcyBOYU4gZm9yIHJlYWx6XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsKXtcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIGZhY3QgdGhhdCBOYU4gIT09IE5hTlxuICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgYSBudW1iZXIgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaG9zdCBvYmplY3RzXG4gICAgICAgIC8vIGFsc28gbmVlZCB0byBjb2VyY2UgVG9OdW1iZXIgdG8gYXZvaWQgZWRnZSBjYXNlIGBuZXcgTnVtYmVyKE5hTilgXG4gICAgICAgIHJldHVybiAhaXNOdW1iZXIodmFsKSB8fCAkaXNOYU4oTnVtYmVyKHZhbCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOYU47XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbCl7XG4gICAgICAgIHJldHVybiB2YWwgPT09IG51bGw7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuXG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ051bWJlcicpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdPYmplY3QnKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICghIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGlzIGEgcHJpbWl0aXZlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICAgICAgLy8gVXNpbmcgc3dpdGNoIGZhbGx0aHJvdWdoIGJlY2F1c2UgaXQncyBzaW1wbGUgdG8gcmVhZCBhbmQgaXNcbiAgICAgICAgLy8gZ2VuZXJhbGx5IGZhc3Q6IGh0dHA6Ly9qc3BlcmYuY29tL3Rlc3RpbmctdmFsdWUtaXMtcHJpbWl0aXZlLzVcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzUHJpbWl0aXZlO1xuXG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ1JlZ0V4cCcpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzUmVnRXhwO1xuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdTdHJpbmcnKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcblxuIiwiXG4gICAgdmFyIFVOREVGO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZih2YWwpe1xuICAgICAgICByZXR1cm4gdmFsID09PSBVTkRFRjtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmO1xuXG4iLCJ2YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBib3RoIHZhbHVlcyBhcmUgbm90IGlkZW50aWNhbC9lZ2FsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNudCh4LCB5KXtcbiAgICAgICAgcmV0dXJuICFpcyh4LCB5KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzbnQ7XG5cblxuIiwiXG5cbiAgICB2YXIgX3JLaW5kID0gL15cXFtvYmplY3QgKC4qKVxcXSQvLFxuICAgICAgICBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBVTkRFRjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFwia2luZFwiIG9mIHZhbHVlLiAoZS5nLiBcIlN0cmluZ1wiLCBcIk51bWJlclwiLCBldGMpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ051bGwnO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gVU5ERUYpIHtcbiAgICAgICAgICAgIHJldHVybiAnVW5kZWZpbmVkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfcktpbmQuZXhlYyggX3RvU3RyaW5nLmNhbGwodmFsKSApWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0ga2luZE9mO1xuXG4iLCJ2YXIga2luZE9mID0gcmVxdWlyZSgnLi9raW5kT2YnKTtcbnZhciBHTE9CQUwgPSByZXF1aXJlKCcuL0dMT0JBTCcpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdCBpbnRvIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWwpe1xuICAgICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgICBraW5kID0ga2luZE9mKHZhbCksXG4gICAgICAgICAgICBuO1xuXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCB2YWwubGVuZ3RoID09IG51bGwgfHwga2luZCA9PT0gJ1N0cmluZycgfHwga2luZCA9PT0gJ0Z1bmN0aW9uJyB8fCBraW5kID09PSAnUmVnRXhwJyB8fCB2YWwgPT09IEdMT0JBTCApIHtcbiAgICAgICAgICAgICAgICAvL3N0cmluZywgcmVnZXhwLCBmdW5jdGlvbiBoYXZlIC5sZW5ndGggYnV0IHVzZXIgcHJvYmFibHkganVzdCB3YW50XG4gICAgICAgICAgICAgICAgLy90byB3cmFwIHZhbHVlIGludG8gYW4gYXJyYXkuLlxuICAgICAgICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy93aW5kb3cgcmV0dXJucyB0cnVlIG9uIGlzT2JqZWN0IGluIElFNyBhbmQgbWF5IGhhdmUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgLy9wcm9wZXJ0eS4gYHR5cGVvZiBOb2RlTGlzdGAgcmV0dXJucyBgZnVuY3Rpb25gIG9uIFNhZmFyaSBzb1xuICAgICAgICAgICAgICAgIC8vd2UgY2FuJ3QgdXNlIGl0ICgjNTgpXG4gICAgICAgICAgICAgICAgbiA9IHZhbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgICAgICByZXRbbl0gPSB2YWxbbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9BcnJheTtcblxuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuICAgIC8qKlxuICAgICAqIGNvdmVydCB2YWx1ZSBpbnRvIG51bWJlciBpZiBudW1lcmljXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsKXtcbiAgICAgICAgLy8gbnVtYmVyaWMgdmFsdWVzIHNob3VsZCBjb21lIGZpcnN0IGJlY2F1c2Ugb2YgLTBcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSByZXR1cm4gdmFsO1xuICAgICAgICAvLyB3ZSB3YW50IGFsbCBmYWxzeSB2YWx1ZXMgKGJlc2lkZXMgLTApIHRvIHJldHVybiB6ZXJvIHRvIGF2b2lkXG4gICAgICAgIC8vIGhlYWRhY2hlc1xuICAgICAgICBpZiAoIXZhbCkgcmV0dXJuIDA7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgLy8gYXJyYXlzIGFyZSBlZGdlIGNhc2VzLiBgTnVtYmVyKFs0XSkgPT09IDRgXG4gICAgICAgIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiBOYU47XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogVHlwZWNhc3QgYSB2YWx1ZSB0byBhIFN0cmluZywgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHZhbHVlIGZvciBudWxsIG9yXG4gICAgICogdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbCl7XG4gICAgICAgIHJldHVybiB2YWwgPT0gbnVsbCA/ICcnIDogdmFsLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2NlaWwnIDogcmVxdWlyZSgnLi9tYXRoL2NlaWwnKSxcbiAgICAnY2xhbXAnIDogcmVxdWlyZSgnLi9tYXRoL2NsYW1wJyksXG4gICAgJ2NvdW50U3RlcHMnIDogcmVxdWlyZSgnLi9tYXRoL2NvdW50U3RlcHMnKSxcbiAgICAnZmxvb3InIDogcmVxdWlyZSgnLi9tYXRoL2Zsb29yJyksXG4gICAgJ2luUmFuZ2UnIDogcmVxdWlyZSgnLi9tYXRoL2luUmFuZ2UnKSxcbiAgICAnaXNOZWFyJyA6IHJlcXVpcmUoJy4vbWF0aC9pc05lYXInKSxcbiAgICAnbGVycCcgOiByZXF1aXJlKCcuL21hdGgvbGVycCcpLFxuICAgICdsb29wJyA6IHJlcXVpcmUoJy4vbWF0aC9sb29wJyksXG4gICAgJ21hcCcgOiByZXF1aXJlKCcuL21hdGgvbWFwJyksXG4gICAgJ25vcm0nIDogcmVxdWlyZSgnLi9tYXRoL25vcm0nKSxcbiAgICAncm91bmQnIDogcmVxdWlyZSgnLi9tYXRoL3JvdW5kJylcbn07XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICogUm91bmQgdmFsdWUgdXAgd2l0aCBhIGN1c3RvbSByYWRpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjZWlsKHZhbCwgc3RlcCl7XG4gICAgICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwIHx8IDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHZhbCAvIHN0ZXApICogc3RlcDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNlaWw7XG5cbiIsIlxuICAgIC8qKlxuICAgICAqIENsYW1wcyB2YWx1ZSBpbnNpZGUgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCl7XG4gICAgICAgIHJldHVybiB2YWwgPCBtaW4/IG1pbiA6ICh2YWwgPiBtYXg/IG1heCA6IHZhbCk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xhbXA7XG5cbiIsIlxuICAgIC8qKlxuICAgICogQ291bnQgbnVtYmVyIG9mIGZ1bGwgc3RlcHMuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBjb3VudFN0ZXBzKHZhbCwgc3RlcCwgb3ZlcmZsb3cpe1xuICAgICAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCAvIHN0ZXApO1xuXG4gICAgICAgIGlmIChvdmVyZmxvdykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAlIG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvdW50U3RlcHM7XG5cbiIsIlxuICAgIC8qKlxuICAgICogRmxvb3IgdmFsdWUgdG8gZnVsbCBzdGVwcy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGZsb29yKHZhbCwgc3RlcCl7XG4gICAgICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwIHx8IDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWwgLyBzdGVwKSAqIHN0ZXA7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZmxvb3I7XG5cbiIsIlxuICAgIC8qKlxuICAgICogQ2hlY2tzIGlmIHZhbHVlIGlzIGluc2lkZSB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKHZhbCwgbWluLCBtYXgsIHRocmVzaG9sZCl7XG4gICAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAwO1xuICAgICAgICByZXR1cm4gKHZhbCArIHRocmVzaG9sZCA+PSBtaW4gJiYgdmFsIC0gdGhyZXNob2xkIDw9IG1heCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpblJhbmdlO1xuXG4iLCJcbiAgICAvKipcbiAgICAqIENoZWNrIGlmIHZhbHVlIGlzIGNsb3NlIHRvIHRhcmdldC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmVhcih2YWwsIHRhcmdldCwgdGhyZXNob2xkKXtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyh2YWwgLSB0YXJnZXQpIDw9IHRocmVzaG9sZCk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOZWFyO1xuXG4iLCJcbiAgICAvKipcbiAgICAqIExpbmVhciBpbnRlcnBvbGF0aW9uLlxuICAgICogSU1QT1JUQU5UOndpbGwgcmV0dXJuIGBJbmZpbml0eWAgaWYgbnVtYmVycyBvdmVyZmxvdyBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsZXJwKHJhdGlvLCBzdGFydCwgZW5kKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHJhdGlvO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbGVycDtcblxuIiwiXG4gICAgLyoqXG4gICAgKiBMb29wcyB2YWx1ZSBpbnNpZGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsb29wKHZhbCwgbWluLCBtYXgpe1xuICAgICAgICByZXR1cm4gdmFsIDwgbWluPyBtYXggOiAodmFsID4gbWF4PyBtaW4gOiB2YWwpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbG9vcDtcblxuIiwidmFyIGxlcnAgPSByZXF1aXJlKCcuL2xlcnAnKTtcbnZhciBub3JtID0gcmVxdWlyZSgnLi9ub3JtJyk7XG4gICAgLyoqXG4gICAgKiBNYXBzIGEgbnVtYmVyIGZyb20gb25lIHNjYWxlIHRvIGFub3RoZXIuXG4gICAgKiBAZXhhbXBsZSBtYXAoMywgMCwgNCwgLTEsIDEpIC0+IDAuNVxuICAgICovXG4gICAgZnVuY3Rpb24gbWFwKHZhbCwgbWluMSwgbWF4MSwgbWluMiwgbWF4Mil7XG4gICAgICAgIHJldHVybiBsZXJwKCBub3JtKHZhbCwgbWluMSwgbWF4MSksIG1pbjIsIG1heDIgKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXA7XG5cbiIsIlxuICAgIC8qKlxuICAgICogR2V0cyBub3JtYWxpemVkIHJhdGlvIG9mIHZhbHVlIGluc2lkZSByYW5nZS5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm0odmFsLCBtaW4sIG1heCl7XG4gICAgICAgIGlmICh2YWwgPCBtaW4gfHwgdmFsID4gbWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgKCcgKyB2YWwgKyAnKSBtdXN0IGJlIGJldHdlZW4gJyArIG1pbiArICcgYW5kICcgKyBtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbWF4ID8gMSA6ICh2YWwgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gbm9ybTtcblxuIiwiXG4gICAgLyoqXG4gICAgICogUm91bmQgbnVtYmVyIHRvIGEgc3BlY2lmaWMgcmFkaXhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZCh2YWx1ZSwgcmFkaXgpe1xuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDE7IC8vIGRlZmF1bHQgcm91bmQgMVxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHJhZGl4KSAqIHJhZGl4O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcm91bmQ7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdNQVhfSU5UJyA6IHJlcXVpcmUoJy4vbnVtYmVyL01BWF9JTlQnKSxcbiAgICAnTUFYX1NBRkVfSU5URUdFUicgOiByZXF1aXJlKCcuL251bWJlci9NQVhfU0FGRV9JTlRFR0VSJyksXG4gICAgJ01BWF9VSU5UJyA6IHJlcXVpcmUoJy4vbnVtYmVyL01BWF9VSU5UJyksXG4gICAgJ01JTl9JTlQnIDogcmVxdWlyZSgnLi9udW1iZXIvTUlOX0lOVCcpLFxuICAgICdhYmJyZXZpYXRlJyA6IHJlcXVpcmUoJy4vbnVtYmVyL2FiYnJldmlhdGUnKSxcbiAgICAnY3VycmVuY3lGb3JtYXQnIDogcmVxdWlyZSgnLi9udW1iZXIvY3VycmVuY3lGb3JtYXQnKSxcbiAgICAnZW5mb3JjZVByZWNpc2lvbicgOiByZXF1aXJlKCcuL251bWJlci9lbmZvcmNlUHJlY2lzaW9uJyksXG4gICAgJ2lzTmFOJyA6IHJlcXVpcmUoJy4vbnVtYmVyL2lzTmFOJyksXG4gICAgJ250aCcgOiByZXF1aXJlKCcuL251bWJlci9udGgnKSxcbiAgICAnb3JkaW5hbCcgOiByZXF1aXJlKCcuL251bWJlci9vcmRpbmFsJyksXG4gICAgJ3BhZCcgOiByZXF1aXJlKCcuL251bWJlci9wYWQnKSxcbiAgICAncm9sJyA6IHJlcXVpcmUoJy4vbnVtYmVyL3JvbCcpLFxuICAgICdyb3InIDogcmVxdWlyZSgnLi9udW1iZXIvcm9yJyksXG4gICAgJ3NpZ24nIDogcmVxdWlyZSgnLi9udW1iZXIvc2lnbicpLFxuICAgICd0b0ludCcgOiByZXF1aXJlKCcuL251bWJlci90b0ludCcpLFxuICAgICd0b1VJbnQnIDogcmVxdWlyZSgnLi9udW1iZXIvdG9VSW50JyksXG4gICAgJ3RvVUludDMxJyA6IHJlcXVpcmUoJy4vbnVtYmVyL3RvVUludDMxJylcbn07XG5cblxuIiwiLyoqXG4gKiBAY29uc3RhbnQgTWF4aW11bSAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWUuICgyXjMxIC0gMSlcbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAyMTQ3NDgzNjQ3O1xuXG4iLCJcblxuICAgIC8vIG1heGltdW0gc2FmZSBpbnRlZ2VyIChNYXRoLnBvdygyLCA1MykgLSAxKVxuICAgIC8vIHNlZTogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cblxuIiwiLyoqXG4gKiBAY29uc3RhbnQgTWF4aW11bSAzMi1iaXQgdW5zaWduZWQgaW50ZWdldCB2YWx1ZSAoMl4zMiAtIDEpXG4gKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gNDI5NDk2NzI5NTtcblxuIiwiLyoqXG4gKiBAY29uc3RhbnQgTWluaW11bSAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWUgKC0yXjMxKS5cbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAtMjE0NzQ4MzY0ODtcblxuIiwidmFyIGVuZm9yY2VQcmVjaXNpb24gPSByZXF1aXJlKCcuL2VuZm9yY2VQcmVjaXNpb24nKTtcblxuICAgIHZhciBfZGVmYXVsdERpY3QgPSB7XG4gICAgICAgIHRob3VzYW5kIDogJ0snLFxuICAgICAgICBtaWxsaW9uIDogJ00nLFxuICAgICAgICBiaWxsaW9uIDogJ0InXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFiYnJldmlhdGUgbnVtYmVyIGlmIGJpZ2dlciB0aGFuIDEwMDAuIChlZzogMi41SywgMTcuNU0sIDMuNEIsIC4uLilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYmJyZXZpYXRlTnVtYmVyKHZhbCwgbkRlY2ltYWxzLCBkaWN0KXtcbiAgICAgICAgbkRlY2ltYWxzID0gbkRlY2ltYWxzICE9IG51bGw/IG5EZWNpbWFscyA6IDE7XG4gICAgICAgIGRpY3QgPSBkaWN0IHx8IF9kZWZhdWx0RGljdDtcbiAgICAgICAgdmFsID0gZW5mb3JjZVByZWNpc2lvbih2YWwsIG5EZWNpbWFscyk7XG5cbiAgICAgICAgdmFyIHN0ciwgbW9kO1xuXG4gICAgICAgIGlmICh2YWwgPCAxMDAwMDAwKSB7XG4gICAgICAgICAgICBtb2QgPSBlbmZvcmNlUHJlY2lzaW9uKHZhbCAvIDEwMDAsIG5EZWNpbWFscyk7XG4gICAgICAgICAgICAvLyBtaWdodCBvdmVyZmxvdyB0byBuZXh0IHNjYWxlIGR1cmluZyByb3VuZGluZ1xuICAgICAgICAgICAgc3RyID0gbW9kIDwgMTAwMD8gbW9kICsgZGljdC50aG91c2FuZCA6IDEgKyBkaWN0Lm1pbGxpb247XG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDwgMTAwMDAwMDAwMCkge1xuICAgICAgICAgICAgbW9kID0gZW5mb3JjZVByZWNpc2lvbih2YWwgLyAxMDAwMDAwLCBuRGVjaW1hbHMpO1xuICAgICAgICAgICAgc3RyID0gbW9kIDwgMTAwMD8gbW9kICsgZGljdC5taWxsaW9uIDogMSArIGRpY3QuYmlsbGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGVuZm9yY2VQcmVjaXNpb24odmFsIC8gMTAwMDAwMDAwMCwgbkRlY2ltYWxzKSArIGRpY3QuYmlsbGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhYmJyZXZpYXRlTnVtYmVyO1xuXG5cbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvdG9OdW1iZXInKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIG51bWJlciBpbnRvIGN1cnJlbmN5IGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJlbmN5Rm9ybWF0KHZhbCwgbkRlY2ltYWxEaWdpdHMsIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kc1NlcGFyYXRvcikge1xuICAgICAgICB2YWwgPSB0b051bWJlcih2YWwpO1xuICAgICAgICBuRGVjaW1hbERpZ2l0cyA9IG5EZWNpbWFsRGlnaXRzID09IG51bGw/IDIgOiBuRGVjaW1hbERpZ2l0cztcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3IgPT0gbnVsbD8gJy4nIDogZGVjaW1hbFNlcGFyYXRvcjtcbiAgICAgICAgdGhvdXNhbmRzU2VwYXJhdG9yID0gdGhvdXNhbmRzU2VwYXJhdG9yID09IG51bGw/ICcsJyA6IHRob3VzYW5kc1NlcGFyYXRvcjtcblxuICAgICAgICAvL2Nhbid0IHVzZSBlbmZvcmNlIHByZWNpc2lvbiBzaW5jZSBpdCByZXR1cm5zIGEgbnVtYmVyIGFuZCB3ZSBhcmVcbiAgICAgICAgLy9kb2luZyBhIFJlZ0V4cCBvdmVyIHRoZSBzdHJpbmdcbiAgICAgICAgdmFyIGZpeGVkID0gdmFsLnRvRml4ZWQobkRlY2ltYWxEaWdpdHMpLFxuICAgICAgICAgICAgLy9zZXBhcmF0ZSBiZWdpbiBbJDFdLCBtaWRkbGUgWyQyXSBhbmQgZGVjaW1hbCBkaWdpdHMgWyQ0XVxuICAgICAgICAgICAgcGFydHMgPSBuZXcgUmVnRXhwKCdeKC0/XFxcXGR7MSwzfSkoKD86XFxcXGR7M30pKykoXFxcXC4oXFxcXGR7JysgbkRlY2ltYWxEaWdpdHMgKyd9KSk/JCcpLmV4ZWMoIGZpeGVkICk7XG5cbiAgICAgICAgaWYocGFydHMpeyAvL3ZhbCA+PSAxMDAwIHx8IHZhbCA8PSAtMTAwMFxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzFdICsgcGFydHNbMl0ucmVwbGFjZSgvXFxkezN9L2csIHRob3VzYW5kc1NlcGFyYXRvciArICckJicpICsgKHBhcnRzWzRdID8gZGVjaW1hbFNlcGFyYXRvciArIHBhcnRzWzRdIDogJycpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBmaXhlZC5yZXBsYWNlKCcuJywgZGVjaW1hbFNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGN1cnJlbmN5Rm9ybWF0O1xuXG5cbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvdG9OdW1iZXInKTtcbiAgICAvKipcbiAgICAgKiBFbmZvcmNlIGEgc3BlY2lmaWMgYW1vdW50IG9mIGRlY2ltYWwgZGlnaXRzIGFuZCBhbHNvIGZpeCBmbG9hdGluZ1xuICAgICAqIHBvaW50IHJvdW5kaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmZvcmNlUHJlY2lzaW9uKHZhbCwgbkRlY2ltYWxEaWdpdHMpe1xuICAgICAgICB2YWwgPSB0b051bWJlcih2YWwpO1xuICAgICAgICB2YXIgcG93ID0gTWF0aC5wb3coMTAsIG5EZWNpbWFsRGlnaXRzKTtcbiAgICAgICAgcmV0dXJuICsoTWF0aC5yb3VuZCh2YWwgKiBwb3cpIC8gcG93KS50b0ZpeGVkKG5EZWNpbWFsRGlnaXRzKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbmZvcmNlUHJlY2lzaW9uO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEVTNiBOdW1iZXIuaXNOYU5cbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNOYU5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWwpe1xuICAgICAgICAvLyBqc2hpbnQgZXFlcWVxOmZhbHNlXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgIT0gdmFsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOYU47XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFwibnRoXCIgb2YgbnVtYmVyICgxID0gXCJzdFwiLCAyID0gXCJuZFwiLCAzID0gXCJyZFwiLCA0Li4xMCA9IFwidGhcIiwgLi4uKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChpKSB7XG4gICAgICAgIHZhciB0ID0gKGkgJSAxMDApO1xuICAgICAgICBpZiAodCA+PSAxMCAmJiB0IDw9IDIwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goaSAlIDEwKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzdCc7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZCc7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAndGgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBudGg7XG5cblxuIiwidmFyIHRvSW50ID0gcmVxdWlyZSgnLi90b0ludCcpO1xudmFyIG50aCA9IHJlcXVpcmUoJy4vbnRoJyk7XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBudW1iZXIgaW50byBvcmRpbmFsIGZvcm0gKDFzdCwgMm5kLCAzcmQsIDR0aCwgLi4uKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGluYWwobil7XG4gICAgICAgbiA9IHRvSW50KG4pO1xuICAgICAgIHJldHVybiBuICsgbnRoKG4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gb3JkaW5hbDtcblxuXG4iLCJ2YXIgbHBhZCA9IHJlcXVpcmUoJy4uL3N0cmluZy9scGFkJyk7XG52YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuLi9sYW5nL3RvTnVtYmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgcGFkZGluZyB6ZXJvcyBpZiBuLmxlbmd0aCA8IG1pbkxlbmd0aC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQobiwgbWluTGVuZ3RoLCBjaGFyKXtcbiAgICAgICAgbiA9IHRvTnVtYmVyKG4pO1xuICAgICAgICByZXR1cm4gbHBhZCgnJysgbiwgbWluTGVuZ3RoLCBjaGFyIHx8ICcwJyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYWQ7XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICogQml0d2lzZSBjaXJjdWxhciBzaGlmdCBsZWZ0XG4gICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaXJjdWxhcl9zaGlmdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvbCh2YWwsIHNoaWZ0KXtcbiAgICAgICAgcmV0dXJuICh2YWwgPDwgc2hpZnQpIHwgKHZhbCA+PiAoMzIgLSBzaGlmdCkpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJvbDtcblxuIiwiXG4gICAgLyoqXG4gICAgICogQml0d2lzZSBjaXJjdWxhciBzaGlmdCByaWdodFxuICAgICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2lyY3VsYXJfc2hpZnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3IodmFsLCBzaGlmdCl7XG4gICAgICAgIHJldHVybiAodmFsID4+IHNoaWZ0KSB8ICh2YWwgPDwgKDMyIC0gc2hpZnQpKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByb3I7XG5cbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvdG9OdW1iZXInKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKHZhbCkge1xuICAgICAgICB2YXIgbnVtID0gdG9OdW1iZXIodmFsKTtcbiAgICAgICAgaWYgKG51bSA9PT0gMCkgcmV0dXJuIG51bTsgLy8gKzAgYW5kICswID09PSAwXG4gICAgICAgIGlmIChpc05hTihudW0pKSByZXR1cm4gbnVtOyAvLyBOYU5cbiAgICAgICAgcmV0dXJuIG51bSA8IDA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpZ247XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBcIkNvbnZlcnRcIiB2YWx1ZSBpbnRvIGFuIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqIFdvcmtzIGxpa2UgYE1hdGguZmxvb3JgIGlmIHZhbCA+IDAgYW5kIGBNYXRoLmNlaWxgIGlmIHZhbCA8IDAuXG4gICAgICogSU1QT1JUQU5UOiB2YWwgd2lsbCB3cmFwIGF0IDJeMzEgYW5kIC0yXjMxLlxuICAgICAqIFBlcmYgdGVzdHM6IGh0dHA6Ly9qc3BlcmYuY29tL3ZzLXZzLXBhcnNlaW50LWJpdHdpc2Utb3BlcmF0b3JzLzdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludCh2YWwpe1xuICAgICAgICAvLyB3ZSBkbyBub3QgdXNlIGxhbmcvdG9OdW1iZXIgYmVjYXVzZSBvZiBwZXJmIGFuZCBhbHNvIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gZG9lc24ndCBicmVhayB0aGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICByZXR1cm4gfn52YWw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b0ludDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFwiQ29udmVydFwiIHZhbHVlIGludG8gYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKiBJTVBPUlRBTlQ6IFZhbHVlIHdpbGwgd3JhcCBhdCAyXjMyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVUludCh2YWwpe1xuICAgICAgICAvLyB3ZSBkbyBub3QgdXNlIGxhbmcvdG9OdW1iZXIgYmVjYXVzZSBvZiBwZXJmIGFuZCBhbHNvIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gZG9lc24ndCBicmVhayB0aGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICByZXR1cm4gdmFsID4+PiAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9VSW50O1xuXG5cbiIsInZhciBNQVhfSU5UID0gcmVxdWlyZSgnLi9NQVhfSU5UJyk7XG5cbiAgICAvKipcbiAgICAgKiBcIkNvbnZlcnRcIiB2YWx1ZSBpbnRvIGFuIDMxLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIChzaW5jZSAxIGJpdCBpcyB1c2VkIGZvciBzaWduKS5cbiAgICAgKiBJTVBPUlRBTlQ6IHZhbHVlIHdpbCB3cmFwIGF0IDJeMzEsIGlmIG5lZ2F0aXZlIHdpbGwgcmV0dXJuIDAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VSW50MzEodmFsKXtcbiAgICAgICAgLy8gd2UgZG8gbm90IHVzZSBsYW5nL3RvTnVtYmVyIGJlY2F1c2Ugb2YgcGVyZiBhbmQgYWxzbyBiZWNhdXNlIGl0XG4gICAgICAgIC8vIGRvZXNuJ3QgYnJlYWsgdGhlIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgcmV0dXJuICh2YWwgPD0gMCk/IDAgOiAodmFsID4gTUFYX0lOVD8gfn4odmFsICUgKE1BWF9JTlQgKyAxKSkgOiB+fnZhbCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b1VJbnQzMTtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2JpbmRBbGwnIDogcmVxdWlyZSgnLi9vYmplY3QvYmluZEFsbCcpLFxuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL29iamVjdC9jb250YWlucycpLFxuICAgICdkZWVwRmlsbEluJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2RlZXBGaWxsSW4nKSxcbiAgICAnZGVlcE1hdGNoZXMnIDogcmVxdWlyZSgnLi9vYmplY3QvZGVlcE1hdGNoZXMnKSxcbiAgICAnZGVlcE1peEluJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2RlZXBNaXhJbicpLFxuICAgICdlcXVhbHMnIDogcmVxdWlyZSgnLi9vYmplY3QvZXF1YWxzJyksXG4gICAgJ2V2ZXJ5JyA6IHJlcXVpcmUoJy4vb2JqZWN0L2V2ZXJ5JyksXG4gICAgJ2ZpbGxJbicgOiByZXF1aXJlKCcuL29iamVjdC9maWxsSW4nKSxcbiAgICAnZmlsdGVyJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2ZpbHRlcicpLFxuICAgICdmaW5kJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2ZpbmQnKSxcbiAgICAnZm9ySW4nIDogcmVxdWlyZSgnLi9vYmplY3QvZm9ySW4nKSxcbiAgICAnZm9yT3duJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2Zvck93bicpLFxuICAgICdmdW5jdGlvbnMnIDogcmVxdWlyZSgnLi9vYmplY3QvZnVuY3Rpb25zJyksXG4gICAgJ2dldCcgOiByZXF1aXJlKCcuL29iamVjdC9nZXQnKSxcbiAgICAnaGFzJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2hhcycpLFxuICAgICdoYXNPd24nIDogcmVxdWlyZSgnLi9vYmplY3QvaGFzT3duJyksXG4gICAgJ2tleXMnIDogcmVxdWlyZSgnLi9vYmplY3Qva2V5cycpLFxuICAgICdtYXAnIDogcmVxdWlyZSgnLi9vYmplY3QvbWFwJyksXG4gICAgJ21hdGNoZXMnIDogcmVxdWlyZSgnLi9vYmplY3QvbWF0Y2hlcycpLFxuICAgICdtYXgnIDogcmVxdWlyZSgnLi9vYmplY3QvbWF4JyksXG4gICAgJ21lcmdlJyA6IHJlcXVpcmUoJy4vb2JqZWN0L21lcmdlJyksXG4gICAgJ21pbicgOiByZXF1aXJlKCcuL29iamVjdC9taW4nKSxcbiAgICAnbWl4SW4nIDogcmVxdWlyZSgnLi9vYmplY3QvbWl4SW4nKSxcbiAgICAnbmFtZXNwYWNlJyA6IHJlcXVpcmUoJy4vb2JqZWN0L25hbWVzcGFjZScpLFxuICAgICdvbWl0JyA6IHJlcXVpcmUoJy4vb2JqZWN0L29taXQnKSxcbiAgICAncGljaycgOiByZXF1aXJlKCcuL29iamVjdC9waWNrJyksXG4gICAgJ3BsdWNrJyA6IHJlcXVpcmUoJy4vb2JqZWN0L3BsdWNrJyksXG4gICAgJ3JlZHVjZScgOiByZXF1aXJlKCcuL29iamVjdC9yZWR1Y2UnKSxcbiAgICAncmVqZWN0JyA6IHJlcXVpcmUoJy4vb2JqZWN0L3JlamVjdCcpLFxuICAgICdyZXN1bHQnIDogcmVxdWlyZSgnLi9vYmplY3QvcmVzdWx0JyksXG4gICAgJ3NldCcgOiByZXF1aXJlKCcuL29iamVjdC9zZXQnKSxcbiAgICAnc2l6ZScgOiByZXF1aXJlKCcuL29iamVjdC9zaXplJyksXG4gICAgJ3NvbWUnIDogcmVxdWlyZSgnLi9vYmplY3Qvc29tZScpLFxuICAgICd1bnNldCcgOiByZXF1aXJlKCcuL29iamVjdC91bnNldCcpLFxuICAgICd2YWx1ZXMnIDogcmVxdWlyZSgnLi9vYmplY3QvdmFsdWVzJylcbn07XG5cblxuIiwidmFyIGZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL2JpbmQnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgdGhlIG9iamVjdCB0byBiZSBydW4gaW4gaXQncyBvd24gY29udGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iaiwgcmVzdF9tZXRob2ROYW1lcyl7XG4gICAgICAgIHZhciBrZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDE/XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlKGFyZ3VtZW50cywgMSkgOiBmdW5jdGlvbnMob2JqKTtcbiAgICAgICAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbihrZXkpe1xuICAgICAgICAgICAgb2JqW2tleV0gPSBiaW5kKG9ialtrZXldLCBvYmopO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpbmRBbGw7XG5cblxuIiwidmFyIHNvbWUgPSByZXF1aXJlKCcuL3NvbWUnKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG9iamVjdCBjb250YWlucyB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwgbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiBzb21lKG9iaiwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbCA9PT0gbmVlZGxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gY29udGFpbnM7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNQbGFpbk9iamVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogRGVlcGx5IGNvcHkgbWlzc2luZyBwcm9wZXJ0aWVzIGluIHRoZSB0YXJnZXQgZnJvbSB0aGUgZGVmYXVsdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVlcEZpbGxJbih0YXJnZXQsIGRlZmF1bHRzKXtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBvYmo7XG5cbiAgICAgICAgd2hpbGUoKytpIDwgbikge1xuICAgICAgICAgICAgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgIC8vIGpzaGludCBsb29wZnVuYzogdHJ1ZVxuICAgICAgICAgICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKG5ld1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1clZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoY3VyVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBGaWxsSW4oY3VyVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZXBGaWxsSW47XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xuXG4gICAgZnVuY3Rpb24gY29udGFpbnNNYXRjaChhcnJheSwgcGF0dGVybikge1xuICAgICAgICB2YXIgaSA9IC0xLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkZWVwTWF0Y2hlcyhhcnJheVtpXSwgcGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEFycmF5KHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICB2YXIgaSA9IC0xLCBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBwYXR0ZXJuTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zTWF0Y2godGFyZ2V0LCBwYXR0ZXJuW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoT2JqZWN0KHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgZm9yT3duKHBhdHRlcm4sIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBNYXRjaGVzKHRhcmdldFtrZXldLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGJyZWFrIG91dCBvZiBmb3JPd24gZWFybHlcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjaGVjayBpZiB0aGUgb2JqZWN0cyBtYXRjaC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwTWF0Y2hlcyh0YXJnZXQsIHBhdHRlcm4pe1xuICAgICAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hBcnJheSh0YXJnZXQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hPYmplY3QodGFyZ2V0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IHBhdHRlcm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZXBNYXRjaGVzO1xuXG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzUGxhaW5PYmplY3QnKTtcblxuICAgIC8qKlxuICAgICAqIE1peGVzIG9iamVjdHMgaW50byB0aGUgdGFyZ2V0IG9iamVjdCwgcmVjdXJzaXZlbHkgbWl4aW5nIGV4aXN0aW5nIGNoaWxkXG4gICAgICogb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwTWl4SW4odGFyZ2V0LCBvYmplY3RzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgb2JqO1xuXG4gICAgICAgIHdoaWxlKCsraSA8IG4pe1xuICAgICAgICAgICAgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgIGZvck93bihvYmosIGNvcHlQcm9wLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3B5UHJvcCh2YWwsIGtleSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzW2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbCkgJiYgaXNQbGFpbk9iamVjdChleGlzdGluZykpIHtcbiAgICAgICAgICAgIGRlZXBNaXhJbihleGlzdGluZywgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVlcE1peEluO1xuXG5cbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuL2hhc093bicpO1xudmFyIGV2ZXJ5ID0gcmVxdWlyZSgnLi9ldmVyeScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vbGFuZy9pcycpO1xuXG4gICAgLy8gTWFrZXMgYSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBvYmplY3QgdmFsdWVzIGZyb20gdGhlIHNwZWNpZmllZCBjb21wYXJlXG4gICAgLy8gb3BlcmF0aW9uIGNhbGxiYWNrLlxuICAgIGZ1bmN0aW9uIG1ha2VDb21wYXJlKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3duKHRoaXMsIGtleSkgJiYgY2FsbGJhY2sodmFsdWUsIHRoaXNba2V5XSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQcm9wZXJ0aWVzKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGhhc093bih0aGlzLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0d28gb2JqZWN0cyBoYXZlIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYiwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBpcztcblxuICAgICAgICBpZiAoIWlzT2JqZWN0KGEpIHx8ICFpc09iamVjdChiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChldmVyeShhLCBtYWtlQ29tcGFyZShjYWxsYmFjayksIGIpICYmXG4gICAgICAgICAgICAgICAgZXZlcnkoYiwgY2hlY2tQcm9wZXJ0aWVzLCBhKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlcXVhbHM7XG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBldmVyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KG9iaiwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIC8vIHdlIGNvbnNpZGVyIGFueSBmYWxzeSB2YWx1ZXMgYXMgXCJmYWxzZVwiIG9uIHB1cnBvc2Ugc28gc2hvcnRoYW5kXG4gICAgICAgICAgICAvLyBzeW50YXggY2FuIGJlIHVzZWQgdG8gY2hlY2sgcHJvcGVydHkgZXhpc3RlbmNlXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbCwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGV2ZXJ5O1xuXG5cbiIsInZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcbnZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICogQ29weSBtaXNzaW5nIHByb3BlcnRpZXMgaW4gdGhlIG9iaiBmcm9tIHRoZSBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsSW4ob2JqLCB2YXJfZGVmYXVsdHMpe1xuICAgICAgICBmb3JFYWNoKHNsaWNlKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKGJhc2Upe1xuICAgICAgICAgICAgZm9yT3duKGJhc2UsIGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaWxsSW47XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgd2hlcmUgdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICAgKiB0cnVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlclZhbHVlcyhvYmosIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXJWYWx1ZXM7XG5cbiIsInZhciBzb21lID0gcmVxdWlyZSgnLi9zb21lJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyBjcml0ZXJpYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQob2JqLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHNvbWUob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuXG5cbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuL2hhc093bicpO1xuXG4gICAgdmFyIF9oYXNEb250RW51bUJ1ZyxcbiAgICAgICAgX2RvbnRFbnVtcztcblxuICAgIGZ1bmN0aW9uIGNoZWNrRG9udEVudW0oKXtcbiAgICAgICAgX2RvbnRFbnVtcyA9IFtcbiAgICAgICAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICAgICAgXTtcblxuICAgICAgICBfaGFzRG9udEVudW1CdWcgPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB7J3RvU3RyaW5nJzogbnVsbH0pIHtcbiAgICAgICAgICAgIF9oYXNEb250RW51bUJ1ZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBBcnJheS9mb3JFYWNoIGJ1dCB3b3JrcyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGFuZCBmaXhlcyBEb24ndFxuICAgICAqIEVudW0gYnVnIG9uIElFLlxuICAgICAqIGJhc2VkIG9uOiBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iaiwgZm4sIHRoaXNPYmope1xuICAgICAgICB2YXIga2V5LCBpID0gMDtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBjaGVjayBpZiBhcmd1bWVudCBpcyBhIHJlYWwgb2JqZWN0IHRoYXQgd2F5IHdlIGNhbiB1c2VcbiAgICAgICAgLy8gaXQgZm9yIGFycmF5cywgZnVuY3Rpb25zLCBkYXRlLCBldGMuXG5cbiAgICAgICAgLy9wb3N0LXBvbmUgY2hlY2sgdGlsbCBuZWVkZWRcbiAgICAgICAgaWYgKF9oYXNEb250RW51bUJ1ZyA9PSBudWxsKSBjaGVja0RvbnRFbnVtKCk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoZXhlYyhmbiwgb2JqLCBrZXksIHRoaXNPYmopID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoX2hhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICBpc1Byb3RvID0gISFjdG9yICYmIG9iaiA9PT0gY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgIHdoaWxlIChrZXkgPSBfZG9udEVudW1zW2krK10pIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgY29uc3RydWN0b3IsIGlmIGl0IGlzIGEgcHJvdG90eXBlIG9iamVjdCB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAvLyBpcyBhbHdheXMgbm9uLWVudW1lcmFibGUgdW5sZXNzIGRlZmluZWQgb3RoZXJ3aXNlIChhbmRcbiAgICAgICAgICAgICAgICAvLyBlbnVtZXJhdGVkIGFib3ZlKS4gIEZvciBub24tcHJvdG90eXBlIG9iamVjdHMsIGl0IHdpbGwgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGRlZmluZWQgb24gdGhpcyBvYmplY3QsIHNpbmNlIGl0IGNhbm5vdCBiZSBkZWZpbmVkIG9uXG4gICAgICAgICAgICAgICAgLy8gYW55IHByb3RvdHlwZSBvYmplY3RzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRm9yIG90aGVyIFtbRG9udEVudW1dXSBwcm9wZXJ0aWVzLCBjaGVjayBpZiB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgdGhhbiBPYmplY3QgcHJvdG90eXBlIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGtleSAhPT0gJ2NvbnN0cnVjdG9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCFpc1Byb3RvICYmIGhhc093bihvYmosIGtleSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSAhPT0gT2JqZWN0LnByb3RvdHlwZVtrZXldXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGVjKGZuLCBvYmosIGtleSwgdGhpc09iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWMoZm4sIG9iaiwga2V5LCB0aGlzT2JqKXtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpc09iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZvckluO1xuXG5cbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuL2hhc093bicpO1xudmFyIGZvckluID0gcmVxdWlyZSgnLi9mb3JJbicpO1xuXG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBBcnJheS9mb3JFYWNoIGJ1dCB3b3JrcyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGFuZCBmaXhlcyBEb24ndFxuICAgICAqIEVudW0gYnVnIG9uIElFLlxuICAgICAqIGJhc2VkIG9uOiBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmosIGZuLCB0aGlzT2JqKXtcbiAgICAgICAgZm9ySW4ob2JqLCBmdW5jdGlvbih2YWwsIGtleSl7XG4gICAgICAgICAgICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXNPYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZm9yT3duO1xuXG5cbiIsInZhciBmb3JJbiA9IHJlcXVpcmUoJy4vZm9ySW4nKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIGxpc3Qgb2YgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iail7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvckluKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXMuc29ydCgpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb25zO1xuXG5cbiIsInZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNQcmltaXRpdmUnKTtcblxuICAgIC8qKlxuICAgICAqIGdldCBcIm5lc3RlZFwiIG9iamVjdCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmosIHByb3Ape1xuICAgICAgICB2YXIgcGFydHMgPSBwcm9wLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBsYXN0ID0gcGFydHMucG9wKCk7XG5cbiAgICAgICAgd2hpbGUgKHByb3AgPSBwYXJ0cy5zaGlmdCgpKSB7XG4gICAgICAgICAgICBvYmogPSBvYmpbcHJvcF07XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmpbbGFzdF07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG5cblxuIiwidmFyIGdldCA9IHJlcXVpcmUoJy4vZ2V0Jyk7XG5cbiAgICB2YXIgVU5ERUY7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBvYmplY3QgaGFzIG5lc3RlZCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqLCBwcm9wKXtcbiAgICAgICAgcmV0dXJuIGdldChvYmosIHByb3ApICE9PSBVTkRFRjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhhcztcblxuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogU2FmZXIgT2JqZWN0Lmhhc093blByb3BlcnR5XG4gICAgICovXG4gICAgIGZ1bmN0aW9uIGhhc093bihvYmosIHByb3Ape1xuICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICAgICB9XG5cbiAgICAgbW9kdWxlLmV4cG9ydHMgPSBoYXNPd247XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb2JqZWN0IGtleXNcbiAgICAgKi9cbiAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aGVyZSBhbGwgdGhlIHZhbHVlcyBhcmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gICAgICogYGNhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBjYWxsYmFjayh2YWwsIGtleSwgb2JqKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXBWYWx1ZXM7XG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIGEgb2JqZWN0IGNvbnRhaW5zIGFsbCBnaXZlbiBwcm9wZXJ0aWVzL3ZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXModGFyZ2V0LCBwcm9wcyl7XG4gICAgICAgIC8vIGNhbid0IHVzZSBcIm9iamVjdC9ldmVyeVwiIGJlY2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgZm9yT3duKHByb3BzLCBmdW5jdGlvbih2YWwsIGtleSl7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gIT09IHZhbCkge1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrIGxvb3AgYXQgZmlyc3QgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXM7XG5cblxuIiwidmFyIGFyck1heCA9IHJlcXVpcmUoJy4uL2FycmF5L21heCcpO1xudmFyIHZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG1heGltdW0gdmFsdWUgaW5zaWRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgob2JqLCBjb21wYXJlRm4pIHtcbiAgICAgICAgcmV0dXJuIGFyck1heCh2YWx1ZXMob2JqKSwgY29tcGFyZUZuKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4vaGFzT3duJyk7XG52YXIgZGVlcENsb25lID0gcmVxdWlyZSgnLi4vbGFuZy9kZWVwQ2xvbmUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuICAgIC8qKlxuICAgICAqIERlZXAgbWVyZ2Ugb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICAgICAgdmFyIGkgPSAxLFxuICAgICAgICAgICAga2V5LCB2YWwsIG9iaiwgdGFyZ2V0O1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBtb2RpZnkgc291cmNlIGVsZW1lbnQgYW5kIGl0J3MgcHJvcGVydGllc1xuICAgICAgICAvLyBvYmplY3RzIGFyZSBwYXNzZWQgYnkgcmVmZXJlbmNlXG4gICAgICAgIHRhcmdldCA9IGRlZXBDbG9uZSggYXJndW1lbnRzWzBdICk7XG5cbiAgICAgICAgd2hpbGUgKG9iaiA9IGFyZ3VtZW50c1tpKytdKSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgaGFzT3duKG9iaiwga2V5KSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsID0gb2JqW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzT2JqZWN0KHZhbCkgJiYgaXNPYmplY3QodGFyZ2V0W2tleV0pICl7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2VwdGlvbiwgZGVlcCBtZXJnZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFycmF5cywgcmVnZXhwLCBkYXRlLCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBkZWVwQ2xvbmUodmFsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxuXG4iLCJ2YXIgYXJyTWluID0gcmVxdWlyZSgnLi4vYXJyYXkvbWluJyk7XG52YXIgdmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWluaW11bSB2YWx1ZSBpbnNpZGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihvYmosIGl0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBhcnJNaW4odmFsdWVzKG9iaiksIGl0ZXJhdG9yKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1pbjtcblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAqIENvbWJpbmUgcHJvcGVydGllcyBmcm9tIGFsbCB0aGUgb2JqZWN0cyBpbnRvIGZpcnN0IG9uZS5cbiAgICAqIC0gVGhpcyBtZXRob2QgYWZmZWN0cyB0YXJnZXQgb2JqZWN0IGluIHBsYWNlLCBpZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBuZXcgT2JqZWN0IHBhc3MgYW4gZW1wdHkgb2JqZWN0IGFzIGZpcnN0IHBhcmFtLlxuICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAgICBUYXJnZXQgT2JqZWN0XG4gICAgKiBAcGFyYW0gey4uLm9iamVjdH0gb2JqZWN0cyAgICBPYmplY3RzIHRvIGJlIGNvbWJpbmVkICgwLi4ubiBvYmplY3RzKS5cbiAgICAqIEByZXR1cm4ge29iamVjdH0gVGFyZ2V0IE9iamVjdC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG1peEluKHRhcmdldCwgb2JqZWN0cyl7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgb2JqO1xuICAgICAgICB3aGlsZSgrK2kgPCBuKXtcbiAgICAgICAgICAgIG9iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvck93bihvYmosIGNvcHlQcm9wLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weVByb3AodmFsLCBrZXkpe1xuICAgICAgICB0aGlzW2tleV0gPSB2YWw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtaXhJbjtcblxuIiwidmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9hcnJheS9mb3JFYWNoJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmVzdGVkIG9iamVjdCBpZiBub24tZXhpc3RlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYW1lc3BhY2Uob2JqLCBwYXRoKXtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gb2JqO1xuICAgICAgICBmb3JFYWNoKHBhdGguc3BsaXQoJy4nKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbmFtZXNwYWNlO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG52YXIgY29udGFpbnMgPSByZXF1aXJlKCcuLi9hcnJheS9jb250YWlucycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0LCBmaWx0ZXJlZCB0byBvbmx5IGNvbnRhaW4gcHJvcGVydGllcyBleGNlcHQgdGhlIGJsYWNrbGlzdGVkIGtleXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmosIHZhcl9rZXlzKXtcbiAgICAgICAgdmFyIGtleXMgPSB0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAnc3RyaW5nJz8gYXJndW1lbnRzWzFdIDogc2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIG91dCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgIWNvbnRhaW5zKGtleXMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIG91dFtwcm9wZXJ0eV0gPSBvYmpbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3QsIGZpbHRlcmVkIHRvIG9ubHkgaGF2ZSB2YWx1ZXMgZm9yIHRoZSB3aGl0ZWxpc3RlZCBrZXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqLCB2YXJfa2V5cyl7XG4gICAgICAgIHZhciBrZXlzID0gdHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ3N0cmluZyc/IGFyZ3VtZW50c1sxXSA6IHNsaWNlKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBvdXQgPSB7fSxcbiAgICAgICAgICAgIGkgPSAwLCBrZXk7XG4gICAgICAgIHdoaWxlIChrZXkgPSBrZXlzW2krK10pIHtcbiAgICAgICAgICAgIG91dFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG5cblxuIiwidmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgcHJvcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL3Byb3AnKTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYSBsaXN0IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwbHVjayhvYmosIHByb3BOYW1lKXtcbiAgICAgICAgcmV0dXJuIG1hcChvYmosIHByb3AocHJvcE5hbWUpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBsdWNrO1xuXG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xudmFyIHNpemUgPSByZXF1aXJlKCcuL3NpemUnKTtcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCByZWR1Y2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2Uob2JqLCBjYWxsYmFjaywgbWVtbywgdGhpc09iaikge1xuICAgICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuXG4gICAgICAgIGlmICghc2l6ZShvYmopICYmICFpbml0aWFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBvYmplY3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gY2FsbGJhY2suY2FsbCh0aGlzT2JqLCBtZW1vLCB2YWx1ZSwga2V5LCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG5cblxuIiwidmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHJlamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChvYmosIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgfSwgdGhpc09iaik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWplY3Q7XG5cblxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9sYW5nL2lzRnVuY3Rpb24nKTtcblxuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmosIHByb3ApIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gb2JqW3Byb3BdO1xuXG4gICAgICAgIGlmKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHByb3BlcnR5KSA/IHByb3BlcnR5LmNhbGwob2JqKSA6IHByb3BlcnR5O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuXG4iLCJ2YXIgbmFtZXNwYWNlID0gcmVxdWlyZSgnLi9uYW1lc3BhY2UnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBcIm5lc3RlZFwiIG9iamVjdCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmosIHByb3AsIHZhbCl7XG4gICAgICAgIHZhciBwYXJ0cyA9ICgvXiguKylcXC4oLispJC8pLmV4ZWMocHJvcCk7XG4gICAgICAgIGlmIChwYXJ0cyl7XG4gICAgICAgICAgICBuYW1lc3BhY2Uob2JqLCBwYXJ0c1sxXSlbcGFydHNbMl1dID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb2JqZWN0IHNpemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKG9iaikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpemU7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNvbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKG9iaiwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsLCBrZXksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb21lO1xuXG5cbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL2hhcycpO1xuXG4gICAgLyoqXG4gICAgICogVW5zZXQgb2JqZWN0IHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iaiwgcHJvcCl7XG4gICAgICAgIGlmIChoYXMob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcHJvcC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGxhc3QgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm9wID0gcGFydHMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoZGVsZXRlIG9ialtsYXN0XSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgdHJlYXQgYXMgZGVsZXRlZFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuc2V0O1xuXG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IG9iamVjdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgICAgICAgIHZhbHMucHVzaCh2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2NvbnRhaW5zJyksXG4gICAgJ2RlY29kZScgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2RlY29kZScpLFxuICAgICdlbmNvZGUnIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZy9lbmNvZGUnKSxcbiAgICAnZ2V0UGFyYW0nIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZy9nZXRQYXJhbScpLFxuICAgICdnZXRRdWVyeScgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2dldFF1ZXJ5JyksXG4gICAgJ3BhcnNlJyA6IHJlcXVpcmUoJy4vcXVlcnlTdHJpbmcvcGFyc2UnKSxcbiAgICAnc2V0UGFyYW0nIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZy9zZXRQYXJhbScpXG59O1xuXG5cbiIsInZhciBnZXRRdWVyeSA9IHJlcXVpcmUoJy4vZ2V0UXVlcnknKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBxdWVyeSBzdHJpbmcgY29udGFpbnMgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHVybCwgcGFyYW1OYW1lKSB7XG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcP3wmKScrIHBhcmFtTmFtZSArJz0nLCAnZycpOyAvL21hdGNoZXMgYD9wYXJhbT1gIG9yIGAmcGFyYW09YFxuICAgICAgICByZXR1cm4gcmVnZXgudGVzdChnZXRRdWVyeSh1cmwpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zO1xuXG4iLCJ2YXIgdHlwZWNhc3QgPSByZXF1aXJlKCcuLi9zdHJpbmcvdHlwZWNhc3QnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNTdHJpbmcnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vb2JqZWN0L2hhc093bicpO1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHF1ZXJ5IHN0cmluZyBpbnRvIGFuIG9iamVjdCBvZiBrZXlzID0+IHZhbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlKHF1ZXJ5U3RyLCBzaG91bGRUeXBlY2FzdCkge1xuICAgICAgICB2YXIgcXVlcnlBcnIgPSAocXVlcnlTdHIgfHwgJycpLnJlcGxhY2UoJz8nLCAnJykuc3BsaXQoJyYnKSxcbiAgICAgICAgICAgIGNvdW50ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWVyeUFyci5sZW5ndGgsXG4gICAgICAgICAgICBvYmogPSB7fSxcbiAgICAgICAgICAgIGl0ZW0sIHBWYWx1ZSwgcE5hbWUsIHRvU2V0O1xuXG4gICAgICAgIHdoaWxlICgrK2NvdW50IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gcXVlcnlBcnJbY291bnRdLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBwTmFtZSA9IGl0ZW1bMF07XG4gICAgICAgICAgICBpZiAoIXBOYW1lIHx8ICFwTmFtZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcFZhbHVlID0gc2hvdWxkVHlwZWNhc3QgPT09IGZhbHNlID8gaXRlbVsxXSA6IHR5cGVjYXN0KGl0ZW1bMV0pO1xuICAgICAgICAgICAgdG9TZXQgPSBpc1N0cmluZyhwVmFsdWUpID8gZGVjb2RlVVJJQ29tcG9uZW50KHBWYWx1ZSkgOiBwVmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFzT3duKG9iaixwTmFtZSkpe1xuICAgICAgICAgICAgICAgIGlmKGlzQXJyYXkob2JqW3BOYW1lXSkpe1xuICAgICAgICAgICAgICAgICAgICBvYmpbcE5hbWVdLnB1c2godG9TZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwTmFtZV0gPSBbb2JqW3BOYW1lXSx0b1NldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbcE5hbWVdID0gdG9TZXQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi4vb2JqZWN0L2Zvck93bicpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlIG9iamVjdCBpbnRvIGEgcXVlcnkgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZShvYmope1xuICAgICAgICB2YXIgcXVlcnkgPSBbXSxcbiAgICAgICAgICAgIGFyclZhbHVlcywgcmVnO1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBhcnJWYWx1ZXMgPSBrZXkgKyAnPSc7XG4gICAgICAgICAgICAgICAgcmVnID0gbmV3IFJlZ0V4cCgnJicra2V5KycrPSQnKTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHZhbCwgZnVuY3Rpb24gKGFWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJWYWx1ZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGFWYWx1ZSkgKyAnJicgKyBrZXkgKyAnPSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcXVlcnkucHVzaChhcnJWYWx1ZXMucmVwbGFjZShyZWcsICcnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcXVlcnkucHVzaChrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHF1ZXJ5Lmxlbmd0aCkgPyAnPycgKyBxdWVyeS5qb2luKCcmJykgOiAnJztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuIiwidmFyIHR5cGVjYXN0ID0gcmVxdWlyZSgnLi4vc3RyaW5nL3R5cGVjYXN0Jyk7XG52YXIgZ2V0UXVlcnkgPSByZXF1aXJlKCcuL2dldFF1ZXJ5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcXVlcnkgcGFyYW1ldGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBhcmFtKHVybCwgcGFyYW0sIHNob3VsZFR5cGVjYXN0KXtcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcP3wmKScrIHBhcmFtICsgJz0oW14mXSopJyksIC8vbWF0Y2hlcyBgP3BhcmFtPXZhbHVlYCBvciBgJnBhcmFtPXZhbHVlYCwgdmFsdWUgPSAkMlxuICAgICAgICAgICAgcmVzdWx0ID0gcmVnZXhwLmV4ZWMoIGdldFF1ZXJ5KHVybCkgKSxcbiAgICAgICAgICAgIHZhbCA9IChyZXN1bHQgJiYgcmVzdWx0WzJdKT8gcmVzdWx0WzJdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHNob3VsZFR5cGVjYXN0ID09PSBmYWxzZT8gdmFsIDogdHlwZWNhc3QodmFsKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdldFBhcmFtO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEdldHMgZnVsbCBxdWVyeSBhcyBzdHJpbmcgd2l0aCBhbGwgc3BlY2lhbCBjaGFycyBkZWNvZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFF1ZXJ5KHVybCkge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvIy4qLywgJycpOyAvL3JlbW92ZXMgaGFzaCAodG8gYXZvaWQgZ2V0dGluZyBoYXNoIHF1ZXJ5KVxuICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSAvXFw/W2EtekEtWjAtOVxcPVxcJlxcJVxcJFxcLVxcX1xcLlxcK1xcIVxcKlxcJ1xcKFxcKVxcLF0rLy5leGVjKHVybCk7IC8vdmFsaWQgY2hhcnMgYWNjb3JkaW5nIHRvOiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMxNzM4LnR4dFxuICAgICAgICByZXR1cm4gKHF1ZXJ5U3RyaW5nKT8gZGVjb2RlVVJJQ29tcG9uZW50KHF1ZXJ5U3RyaW5nWzBdKSA6ICcnO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0UXVlcnk7XG5cbiIsInZhciBkZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xudmFyIGdldFF1ZXJ5ID0gcmVxdWlyZSgnLi9nZXRRdWVyeScpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXJ5IHN0cmluZywgcGFyc2VzIGFuZCBkZWNvZGVzIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlKHVybCwgc2hvdWxkVHlwZWNhc3QpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZShnZXRRdWVyeSh1cmwpLCBzaG91bGRUeXBlY2FzdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFNldCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UGFyYW0odXJsLCBwYXJhbU5hbWUsIHZhbHVlKXtcbiAgICAgICAgdXJsID0gdXJsIHx8ICcnO1xuXG4gICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJyhcXFxcP3wmKScrIHBhcmFtTmFtZSArJz1bXiZdKicgKTtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1OYW1lICsnPScrIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblxuICAgICAgICBpZiAoIHJlLnRlc3QodXJsKSApIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwucmVwbGFjZShyZSwgJyQxJysgcGFyYW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignPScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHVybCArPSAnJic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsICsgcGFyYW07XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc2V0UGFyYW07XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdjaG9pY2UnIDogcmVxdWlyZSgnLi9yYW5kb20vY2hvaWNlJyksXG4gICAgJ2d1aWQnIDogcmVxdWlyZSgnLi9yYW5kb20vZ3VpZCcpLFxuICAgICdyYW5kJyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmQnKSxcbiAgICAncmFuZEJpdCcgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kQml0JyksXG4gICAgJ3JhbmRCb29sJyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRCb29sJyksXG4gICAgJ3JhbmRIZXgnIDogcmVxdWlyZSgnLi9yYW5kb20vcmFuZEhleCcpLFxuICAgICdyYW5kSW50JyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRJbnQnKSxcbiAgICAncmFuZFNpZ24nIDogcmVxdWlyZSgnLi9yYW5kb20vcmFuZFNpZ24nKSxcbiAgICAncmFuZFN0cmluZycgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kU3RyaW5nJyksXG4gICAgJ3JhbmRvbScgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kb20nKVxufTtcblxuXG4iLCJ2YXIgcmFuZEludCA9IHJlcXVpcmUoJy4vcmFuZEludCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gZWxlbWVudCBmcm9tIHRoZSBzdXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBvciBmcm9tIHRoZSBhcnJheSAoaWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGFycmF5KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaG9pY2UoaXRlbXMpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkoaXRlbXMpKT8gaXRlbXMgOiBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0YXJnZXRbIHJhbmRJbnQoMCwgdGFyZ2V0Lmxlbmd0aCAtIDEpIF07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjaG9pY2U7XG5cblxuIiwidmFyIHJhbmRIZXggPSByZXF1aXJlKCcuL3JhbmRIZXgnKTtcbnZhciBjaG9pY2UgPSByZXF1aXJlKCcuL2Nob2ljZScpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBzZXVkby1yYW5kb20gZ3VpZCAoVVVJRCB2NClcbiAgICogSU1QT1JUQU5UOiBpdCdzIG5vdCB0b3RhbGx5IFwic2FmZVwiIHNpbmNlIHJhbmRIZXgvY2hvaWNlIHVzZXMgTWF0aC5yYW5kb21cbiAgICogYnkgZGVmYXVsdCBhbmQgc2VxdWVuY2VzIGNhbiBiZSBwcmVkaWN0ZWQgaW4gc29tZSBjYXNlcy4gU2VlIHRoZVxuICAgKiBcInJhbmRvbS9yYW5kb21cIiBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm8gYWJvdXQgaXQgYW5kIGhvdyB0byByZXBsYWNlXG4gICAqIHRoZSBkZWZhdWx0IFBSTkcuXG4gICAqL1xuICBmdW5jdGlvbiBndWlkKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHJhbmRIZXgoOCkrJy0nK1xuICAgICAgICByYW5kSGV4KDQpKyctJytcbiAgICAgICAgLy8gdjQgVVVJRCBhbHdheXMgY29udGFpbiBcIjRcIiBhdCB0aGlzIHBvc2l0aW9uIHRvIHNwZWNpZnkgaXQgd2FzXG4gICAgICAgIC8vIHJhbmRvbWx5IGdlbmVyYXRlZFxuICAgICAgICAnNCcgKyByYW5kSGV4KDMpICsnLScrXG4gICAgICAgIC8vIHY0IFVVSUQgYWx3YXlzIGNvbnRhaW4gY2hhcnMgW2EsYiw4LDldIGF0IHRoaXMgcG9zaXRpb25cbiAgICAgICAgY2hvaWNlKDgsIDksICdhJywgJ2InKSArIHJhbmRIZXgoMykrJy0nK1xuICAgICAgICByYW5kSGV4KDEyKVxuICAgICk7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBndWlkO1xuXG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcbnZhciBNSU5fSU5UID0gcmVxdWlyZSgnLi4vbnVtYmVyL01JTl9JTlQnKTtcbnZhciBNQVhfSU5UID0gcmVxdWlyZSgnLi4vbnVtYmVyL01BWF9JTlQnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBpbnNpZGUgcmFuZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kKG1pbiwgbWF4KXtcbiAgICAgICAgbWluID0gbWluID09IG51bGw/IE1JTl9JTlQgOiBtaW47XG4gICAgICAgIG1heCA9IG1heCA9PSBudWxsPyBNQVhfSU5UIDogbWF4O1xuICAgICAgICByZXR1cm4gbWluICsgKG1heCAtIG1pbikgKiByYW5kb20oKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmQ7XG5cbiIsInZhciByYW5kQm9vbCA9IHJlcXVpcmUoJy4vcmFuZEJvb2wnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIGJpdCAoMCBvciAxKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbUJpdCgpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRCb29sKCk/IDEgOiAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQml0O1xuXG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSByYW5kb20gYm9vbGVhbiB2YWx1ZSAodHJ1ZSBvciBmYWxzZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kQm9vbCgpe1xuICAgICAgICByZXR1cm4gcmFuZG9tKCkgPj0gMC41O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZEJvb2w7XG5cblxuIiwidmFyIGNob2ljZSA9IHJlcXVpcmUoJy4vY2hvaWNlJyk7XG5cbiAgICB2YXIgX2NoYXJzID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gaGV4YWRlY2ltYWwgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZEhleChzaXplKXtcbiAgICAgICAgc2l6ZSA9IHNpemUgJiYgc2l6ZSA+IDA/IHNpemUgOiA2O1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAgIHN0ciArPSBjaG9pY2UoX2NoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZEhleDtcblxuXG4iLCJ2YXIgTUlOX0lOVCA9IHJlcXVpcmUoJy4uL251bWJlci9NSU5fSU5UJyk7XG52YXIgTUFYX0lOVCA9IHJlcXVpcmUoJy4uL251bWJlci9NQVhfSU5UJyk7XG52YXIgcmFuZCA9IHJlcXVpcmUoJy4vcmFuZCcpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyByYW5kb20gaW50ZWdlciBpbnNpZGUgcmFuZ2Ugb3Igc25hcCB0byBtaW4vbWF4IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kSW50KG1pbiwgbWF4KXtcbiAgICAgICAgbWluID0gbWluID09IG51bGw/IE1JTl9JTlQgOiB+fm1pbjtcbiAgICAgICAgbWF4ID0gbWF4ID09IG51bGw/IE1BWF9JTlQgOiB+fm1heDtcbiAgICAgICAgLy8gY2FuJ3QgYmUgbWF4ICsgMC41IG90aGVyd2lzZSBpdCB3aWxsIHJvdW5kIHVwIGlmIGByYW5kYFxuICAgICAgICAvLyByZXR1cm5zIGBtYXhgIGNhdXNpbmcgaXQgdG8gb3ZlcmZsb3cgcmFuZ2UuXG4gICAgICAgIC8vIC0wLjUgYW5kICsgMC40OSBhcmUgcmVxdWlyZWQgdG8gYXZvaWQgYmlhcyBjYXVzZWQgYnkgcm91bmRpbmdcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoIHJhbmQobWluIC0gMC41LCBtYXggKyAwLjQ5OTk5OTk5OTk5OSkgKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRJbnQ7XG5cbiIsInZhciByYW5kQm9vbCA9IHJlcXVpcmUoJy4vcmFuZEJvb2wnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIHNpZ24gKC0xIG9yIDEpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tU2lnbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRCb29sKCk/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbVNpZ247XG5cbiIsInZhciBpc051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOdW1iZXInKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNTdHJpbmcnKTtcbnZhciByYW5kSW50ID0gcmVxdWlyZSgnLi9yYW5kSW50Jyk7XG5cbiAgICB2YXIgZGVmYXVsdERpY3Rpb25hcnkgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5cbiAgICBmdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgIGlmKCFpc051bWJlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgbGVuZ3RoID0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFpc1N0cmluZyhkaWN0aW9uYXJ5KSB8fCBkaWN0aW9uYXJ5Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICBkaWN0aW9uYXJ5ID0gZGVmYXVsdERpY3Rpb25hcnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBkb21haW4gPSBkaWN0aW9uYXJ5Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgICByZXN1bHQgKz0gZGljdGlvbmFyeVtyYW5kSW50KDAsIGRvbWFpbildO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tU3RyaW5nO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEp1c3QgYSB3cmFwcGVyIHRvIE1hdGgucmFuZG9tLiBObyBtZXRob2RzIGluc2lkZSBtb3V0L3JhbmRvbSBzaG91bGQgY2FsbFxuICAgICAqIE1hdGgucmFuZG9tKCkgZGlyZWN0bHkgc28gd2UgY2FuIGluamVjdCB0aGUgcHNldWRvLXJhbmRvbSBudW1iZXJcbiAgICAgKiBnZW5lcmF0b3IgaWYgbmVlZGVkIChpZS4gaW4gY2FzZSB3ZSBuZWVkIGEgc2VlZGVkIHJhbmRvbSBvciBhIGJldHRlclxuICAgICAqIGFsZ29yaXRobSB0aGFuIHRoZSBuYXRpdmUgb25lKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbSgpe1xuICAgICAgICByZXR1cm4gcmFuZG9tLmdldCgpO1xuICAgIH1cblxuICAgIC8vIHdlIGV4cG9zZSB0aGUgbWV0aG9kIHNvIGl0IGNhbiBiZSBzd2FwcGVkIGlmIG5lZWRlZFxuICAgIHJhbmRvbS5nZXQgPSBNYXRoLnJhbmRvbTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG5cbiIsIlxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnV0hJVEVfU1BBQ0VTJyA6IHJlcXVpcmUoJy4vc3RyaW5nL1dISVRFX1NQQUNFUycpLFxuICAgICdjYW1lbENhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvY2FtZWxDYXNlJyksXG4gICAgJ2NvbnRhaW5zJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2NvbnRhaW5zJyksXG4gICAgJ2Nyb3AnIDogcmVxdWlyZSgnLi9zdHJpbmcvY3JvcCcpLFxuICAgICdlbmRzV2l0aCcgOiByZXF1aXJlKCcuL3N0cmluZy9lbmRzV2l0aCcpLFxuICAgICdlc2NhcGVIdG1sJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2VzY2FwZUh0bWwnKSxcbiAgICAnZXNjYXBlUmVnRXhwJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2VzY2FwZVJlZ0V4cCcpLFxuICAgICdlc2NhcGVVbmljb2RlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2VzY2FwZVVuaWNvZGUnKSxcbiAgICAnaHlwaGVuYXRlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2h5cGhlbmF0ZScpLFxuICAgICdpbnNlcnQnIDogcmVxdWlyZSgnLi9zdHJpbmcvaW5zZXJ0JyksXG4gICAgJ2ludGVycG9sYXRlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2ludGVycG9sYXRlJyksXG4gICAgJ2xvd2VyQ2FzZScgOiByZXF1aXJlKCcuL3N0cmluZy9sb3dlckNhc2UnKSxcbiAgICAnbHBhZCcgOiByZXF1aXJlKCcuL3N0cmluZy9scGFkJyksXG4gICAgJ2x0cmltJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2x0cmltJyksXG4gICAgJ21ha2VQYXRoJyA6IHJlcXVpcmUoJy4vc3RyaW5nL21ha2VQYXRoJyksXG4gICAgJ25vcm1hbGl6ZUxpbmVCcmVha3MnIDogcmVxdWlyZSgnLi9zdHJpbmcvbm9ybWFsaXplTGluZUJyZWFrcycpLFxuICAgICdwYXNjYWxDYXNlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3Bhc2NhbENhc2UnKSxcbiAgICAncHJvcGVyQ2FzZScgOiByZXF1aXJlKCcuL3N0cmluZy9wcm9wZXJDYXNlJyksXG4gICAgJ3JlbW92ZU5vbkFTQ0lJJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3JlbW92ZU5vbkFTQ0lJJyksXG4gICAgJ3JlbW92ZU5vbldvcmQnIDogcmVxdWlyZSgnLi9zdHJpbmcvcmVtb3ZlTm9uV29yZCcpLFxuICAgICdyZXBlYXQnIDogcmVxdWlyZSgnLi9zdHJpbmcvcmVwZWF0JyksXG4gICAgJ3JlcGxhY2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvcmVwbGFjZScpLFxuICAgICdyZXBsYWNlQWNjZW50cycgOiByZXF1aXJlKCcuL3N0cmluZy9yZXBsYWNlQWNjZW50cycpLFxuICAgICdycGFkJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3JwYWQnKSxcbiAgICAncnRyaW0nIDogcmVxdWlyZSgnLi9zdHJpbmcvcnRyaW0nKSxcbiAgICAnc2VudGVuY2VDYXNlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3NlbnRlbmNlQ2FzZScpLFxuICAgICdzbHVnaWZ5JyA6IHJlcXVpcmUoJy4vc3RyaW5nL3NsdWdpZnknKSxcbiAgICAnc3RhcnRzV2l0aCcgOiByZXF1aXJlKCcuL3N0cmluZy9zdGFydHNXaXRoJyksXG4gICAgJ3N0cmlwSHRtbFRhZ3MnIDogcmVxdWlyZSgnLi9zdHJpbmcvc3RyaXBIdG1sVGFncycpLFxuICAgICd0cmltJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3RyaW0nKSxcbiAgICAndHJ1bmNhdGUnIDogcmVxdWlyZSgnLi9zdHJpbmcvdHJ1bmNhdGUnKSxcbiAgICAndHlwZWNhc3QnIDogcmVxdWlyZSgnLi9zdHJpbmcvdHlwZWNhc3QnKSxcbiAgICAndW5DYW1lbENhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvdW5DYW1lbENhc2UnKSxcbiAgICAndW5kZXJzY29yZScgOiByZXF1aXJlKCcuL3N0cmluZy91bmRlcnNjb3JlJyksXG4gICAgJ3VuZXNjYXBlSHRtbCcgOiByZXF1aXJlKCcuL3N0cmluZy91bmVzY2FwZUh0bWwnKSxcbiAgICAndW5lc2NhcGVVbmljb2RlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3VuZXNjYXBlVW5pY29kZScpLFxuICAgICd1bmh5cGhlbmF0ZScgOiByZXF1aXJlKCcuL3N0cmluZy91bmh5cGhlbmF0ZScpLFxuICAgICd1cHBlckNhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvdXBwZXJDYXNlJylcbn07XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgYWxsIFVuaWNvZGUgd2hpdGUtc3BhY2VzLiBUYWtlbiBmcm9tXG4gICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaGl0ZXNwYWNlX2NoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFtcbiAgICAgICAgJyAnLCAnXFxuJywgJ1xccicsICdcXHQnLCAnXFxmJywgJ1xcdicsICdcXHUwMEEwJywgJ1xcdTE2ODAnLCAnXFx1MTgwRScsXG4gICAgICAgICdcXHUyMDAwJywgJ1xcdTIwMDEnLCAnXFx1MjAwMicsICdcXHUyMDAzJywgJ1xcdTIwMDQnLCAnXFx1MjAwNScsICdcXHUyMDA2JyxcbiAgICAgICAgJ1xcdTIwMDcnLCAnXFx1MjAwOCcsICdcXHUyMDA5JywgJ1xcdTIwMEEnLCAnXFx1MjAyOCcsICdcXHUyMDI5JywgJ1xcdTIwMkYnLFxuICAgICAgICAnXFx1MjA1RicsICdcXHUzMDAwJ1xuICAgIF07XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciByZXBsYWNlQWNjZW50cyA9IHJlcXVpcmUoJy4vcmVwbGFjZUFjY2VudHMnKTtcbnZhciByZW1vdmVOb25Xb3JkID0gcmVxdWlyZSgnLi9yZW1vdmVOb25Xb3JkJyk7XG52YXIgdXBwZXJDYXNlID0gcmVxdWlyZSgnLi91cHBlckNhc2UnKTtcbnZhciBsb3dlckNhc2UgPSByZXF1aXJlKCcuL2xvd2VyQ2FzZScpO1xuICAgIC8qKlxuICAgICogQ29udmVydCBzdHJpbmcgdG8gY2FtZWxDYXNlIHRleHQuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3RyID0gcmVwbGFjZUFjY2VudHMoc3RyKTtcbiAgICAgICAgc3RyID0gcmVtb3ZlTm9uV29yZChzdHIpXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcLV9dL2csICcgJykgLy9jb252ZXJ0IGFsbCBoeXBoZW5zIGFuZCB1bmRlcnNjb3JlcyB0byBzcGFjZXNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNbYS16XS9nLCB1cHBlckNhc2UpIC8vY29udmVydCBmaXJzdCBjaGFyIG9mIGVhY2ggd29yZCB0byBVUFBFUkNBU0VcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcnKSAvL3JlbW92ZSBzcGFjZXNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eW0EtWl0vZywgbG93ZXJDYXNlKTsgLy9jb252ZXJ0IGZpcnN0IGNoYXIgdG8gbG93ZXJjYXNlXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gY2FtZWxDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgYSBnaXZlbiBzdWJzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhzdHIsIHN1YnN0cmluZywgZnJvbUluZGV4KXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3Vic3RyaW5nID0gdG9TdHJpbmcoc3Vic3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1YnN0cmluZywgZnJvbUluZGV4KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb250YWlucztcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgdHJ1bmNhdGUgPSByZXF1aXJlKCcuL3RydW5jYXRlJyk7XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGUgc3RyaW5nIGF0IGZ1bGwgd29yZHMuXG4gICAgICovXG4gICAgIGZ1bmN0aW9uIGNyb3Aoc3RyLCBtYXhDaGFycywgYXBwZW5kKSB7XG4gICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICAgcmV0dXJuIHRydW5jYXRlKHN0ciwgbWF4Q2hhcnMsIGFwcGVuZCwgdHJ1ZSk7XG4gICAgIH1cblxuICAgICBtb2R1bGUuZXhwb3J0cyA9IGNyb3A7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3RyaW5nIGVuZHMgd2l0aCBzcGVjaWZpZWQgc3VmZml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc3VmZml4KSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHN1ZmZpeCA9IHRvU3RyaW5nKHN1ZmZpeCk7XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVuZHNXaXRoO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIGEgc3RyaW5nIGZvciBpbnNlcnRpb24gaW50byBIVE1MLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZXNjYXBlSHRtbDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgUmVnRXhwIHN0cmluZyBjaGFycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyhzdHIpLnJlcGxhY2UoL1xcVy9nLCdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVJlZ0V4cDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgc3RyaW5nIGludG8gdW5pY29kZSBzZXF1ZW5jZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVVbmljb2RlKHN0ciwgc2hvdWxkRXNjYXBlUHJpbnRhYmxlKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxzXFxTXS9nLCBmdW5jdGlvbihjaCl7XG4gICAgICAgICAgICAvLyBza2lwIHByaW50YWJsZSBBU0NJSSBjaGFycyBpZiB3ZSBzaG91bGQgbm90IGVzY2FwZSB0aGVtXG4gICAgICAgICAgICBpZiAoIXNob3VsZEVzY2FwZVByaW50YWJsZSAmJiAoL1tcXHgyMC1cXHg3RV0vKS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIHVzZSBcIjAwMFwiIGFuZCBzbGljZSgtNCkgZm9yIGJyZXZpdHksIG5lZWQgdG8gcGFkIHplcm9zLFxuICAgICAgICAgICAgLy8gdW5pY29kZSBlc2NhcGUgYWx3YXlzIGhhdmUgNCBjaGFycyBhZnRlciBcIlxcdVwiXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1JysgKCcwMDAnKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVVuaWNvZGU7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHNsdWdpZnkgPSByZXF1aXJlKCcuL3NsdWdpZnknKTtcbnZhciB1bkNhbWVsQ2FzZSA9IHJlcXVpcmUoJy4vdW5DYW1lbENhc2UnKTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBzcGFjZXMgd2l0aCBoeXBoZW5zLCBzcGxpdCBjYW1lbENhc2UgdGV4dCwgcmVtb3ZlIG5vbi13b3JkIGNoYXJzLCByZW1vdmUgYWNjZW50cyBhbmQgY29udmVydCB0byBsb3dlciBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBzdHIgPSB1bkNhbWVsQ2FzZShzdHIpO1xuICAgICAgICByZXR1cm4gc2x1Z2lmeShzdHIsIFwiLVwiKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuIiwidmFyIGNsYW1wID0gcmVxdWlyZSgnLi4vbWF0aC9jbGFtcCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIHN0cmluZyBhdCBhIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChzdHJpbmcsIGluZGV4LCBwYXJ0aWFsKXtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IHN0cmluZy5sZW5ndGggKyBpbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gY2xhbXAoaW5kZXgsIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIGluZGV4KSArIHBhcnRpYWwgKyBzdHJpbmcuc3Vic3RyKGluZGV4KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGluc2VydDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnLi4vb2JqZWN0L2dldCcpO1xuXG4gICAgdmFyIHN0YWNoZSA9IC9cXHtcXHsoW15cXH1dKylcXH1cXH0vZzsgLy9tdXN0YWNoZS1saWtlXG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgaW50ZXJwb2xhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHRlbXBsYXRlLCByZXBsYWNlbWVudHMsIHN5bnRheCl7XG4gICAgICAgIHRlbXBsYXRlID0gdG9TdHJpbmcodGVtcGxhdGUpO1xuICAgICAgICB2YXIgcmVwbGFjZUZuID0gZnVuY3Rpb24obWF0Y2gsIHByb3Ape1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKCBnZXQocmVwbGFjZW1lbnRzLCBwcm9wKSApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShzeW50YXggfHwgc3RhY2hlLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW50ZXJwb2xhdGU7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuICAgIC8qKlxuICAgICAqIFwiU2FmZXJcIiBTdHJpbmcudG9Mb3dlckNhc2UoKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvd2VyQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsb3dlckNhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL3JlcGVhdCcpO1xuXG4gICAgLyoqXG4gICAgICogUGFkIHN0cmluZyB3aXRoIGBjaGFyYCBpZiBpdHMnIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gYG1pbkxlbmBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBscGFkKHN0ciwgbWluTGVuLCBjaCkge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBjaCA9IGNoIHx8ICcgJztcblxuICAgICAgICByZXR1cm4gKHN0ci5sZW5ndGggPCBtaW5MZW4pID9cbiAgICAgICAgICAgIHJlcGVhdChjaCwgbWluTGVuIC0gc3RyLmxlbmd0aCkgKyBzdHIgOiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBscGFkO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBXSElURV9TUEFDRVMgPSByZXF1aXJlKCcuL1dISVRFX1NQQUNFUycpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjaGFycyBmcm9tIGJlZ2lubmluZyBvZiBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHRyaW0oc3RyLCBjaGFycykge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBjaGFycyA9IGNoYXJzIHx8IFdISVRFX1NQQUNFUztcblxuICAgICAgICB2YXIgc3RhcnQgPSAwLFxuICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGNoYXJMZW4gPSBjaGFycy5sZW5ndGgsXG4gICAgICAgICAgICBmb3VuZCA9IHRydWUsXG4gICAgICAgICAgICBpLCBjO1xuXG4gICAgICAgIHdoaWxlIChmb3VuZCAmJiBzdGFydCA8IGxlbikge1xuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckF0KHN0YXJ0KTtcblxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGNoYXJMZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gY2hhcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHN0YXJ0ID49IGxlbikgPyAnJyA6IHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsdHJpbTtcblxuIiwidmFyIGpvaW4gPSByZXF1aXJlKCcuLi9hcnJheS9qb2luJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuLi9hcnJheS9zbGljZScpO1xuXG4gICAgLyoqXG4gICAgICogR3JvdXAgYXJndW1lbnRzIGFzIHBhdGggc2VnbWVudHMsIGlmIGFueSBvZiB0aGUgYXJncyBpcyBgbnVsbGAgb3IgYW5cbiAgICAgKiBlbXB0eSBzdHJpbmcgaXQgd2lsbCBiZSBpZ25vcmVkIGZyb20gcmVzdWx0aW5nIHBhdGguXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVBhdGgodmFyX2FyZ3Mpe1xuICAgICAgICB2YXIgcmVzdWx0ID0gam9pbihzbGljZShhcmd1bWVudHMpLCAnLycpO1xuICAgICAgICAvLyBuZWVkIHRvIGRpc2NvbnNpZGVyIGR1cGxpY2F0ZSAnLycgYWZ0ZXIgcHJvdG9jb2wgKGVnOiAnaHR0cDovLycpXG4gICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvKFteOlxcL118XilcXC97Mix9L2csICckMS8nKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VQYXRoO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGxpbmUtYnJlYWtzIGZyb20gRE9TL01BQyB0byBhIHNpbmdsZSBzdGFuZGFyZCAoVU5JWCBieSBkZWZhdWx0KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmVCcmVha3Moc3RyLCBsaW5lRW5kKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGxpbmVFbmQgPSBsaW5lRW5kIHx8ICdcXG4nO1xuXG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgbGluZUVuZCkgLy8gRE9TXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csIGxpbmVFbmQpICAgLy8gTWFjXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIGxpbmVFbmQpOyAgLy8gVW5peFxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplTGluZUJyZWFrcztcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgY2FtZWxDYXNlID0gcmVxdWlyZSgnLi9jYW1lbENhc2UnKTtcbnZhciB1cHBlckNhc2UgPSByZXF1aXJlKCcuL3VwcGVyQ2FzZScpO1xuICAgIC8qKlxuICAgICAqIGNhbWVsQ2FzZSArIFVQUEVSQ0FTRSBmaXJzdCBjaGFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFzY2FsQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gY2FtZWxDYXNlKHN0cikucmVwbGFjZSgvXlthLXpdLywgdXBwZXJDYXNlKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhc2NhbENhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBsb3dlckNhc2UgPSByZXF1aXJlKCcuL2xvd2VyQ2FzZScpO1xudmFyIHVwcGVyQ2FzZSA9IHJlcXVpcmUoJy4vdXBwZXJDYXNlJyk7XG4gICAgLyoqXG4gICAgICogVVBQRVJDQVNFIGZpcnN0IGNoYXIgb2YgZWFjaCB3b3JkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlckNhc2Uoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyQ2FzZShzdHIpLnJlcGxhY2UoL15cXHd8XFxzXFx3L2csIHVwcGVyQ2FzZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG5vbi1wcmludGFibGUgQVNDSUkgY2hhcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVOb25BU0NJSShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuXG4gICAgICAgIC8vIE1hdGNoZXMgbm9uLXByaW50YWJsZSBBU0NJSSBjaGFycyAtXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQVNDSUkjQVNDSUlfcHJpbnRhYmxlX2NoYXJhY3RlcnNcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXlxceDIwLVxceDdFXS9nLCAnJyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZW1vdmVOb25BU0NJSTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuICAgIC8vIFRoaXMgcGF0dGVybiBpcyBnZW5lcmF0ZWQgYnkgdGhlIF9idWlsZC9wYXR0ZXJuLXJlbW92ZU5vbldvcmQuanMgc2NyaXB0XG4gICAgdmFyIFBBVFRFUk4gPSAvW15cXHgyMFxceDJEMC05QS1aXFx4NUZhLXpcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx4RkZdL2c7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbm9uLXdvcmQgY2hhcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9uV29yZChzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoUEFUVEVSTiwgJycpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVtb3ZlTm9uV29yZDtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHRvSW50ID0gcmVxdWlyZSgnLi4vbnVtYmVyL3RvSW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXQgc3RyaW5nIG4gdGltZXNcbiAgICAgKi9cbiAgICAgZnVuY3Rpb24gcmVwZWF0KHN0ciwgbil7XG4gICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICAgbiA9IHRvSW50KG4pO1xuICAgICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gTWF0aC5mbG9vcihuIC8gMik7XG4gICAgICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgIH1cblxuICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcGVhdDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvdG9BcnJheScpO1xuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzdHJpbmcocykgd2l0aCB0aGUgcmVwbGFjZW1lbnQocykgaW4gdGhlIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHN0ciwgc2VhcmNoLCByZXBsYWNlbWVudHMpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc2VhcmNoID0gdG9BcnJheShzZWFyY2gpO1xuICAgICAgICByZXBsYWNlbWVudHMgPSB0b0FycmF5KHJlcGxhY2VtZW50cyk7XG5cbiAgICAgICAgdmFyIHNlYXJjaExlbmd0aCA9IHNlYXJjaC5sZW5ndGgsXG4gICAgICAgICAgICByZXBsYWNlbWVudHNMZW5ndGggPSByZXBsYWNlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudHNMZW5ndGggIT09IDEgJiYgc2VhcmNoTGVuZ3RoICE9PSByZXBsYWNlbWVudHNMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5lcXVhbCBudW1iZXIgb2Ygc2VhcmNoZXMgYW5kIHJlcGxhY2VtZW50cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IHNlYXJjaExlbmd0aCkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCByZXBsYWNlbWVudCBmb3IgYWxsIHNlYXJjaGVzIGlmIG9ubHkgb25lXG4gICAgICAgICAgICAvLyByZXBsYWNlbWVudCBpcyBwcm92aWRlZFxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgc2VhcmNoW2ldLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50c1socmVwbGFjZW1lbnRzTGVuZ3RoID09PSAxKSA/IDAgOiBpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVwbGFjZTtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgKiBSZXBsYWNlcyBhbGwgYWNjZW50ZWQgY2hhcnMgd2l0aCByZWd1bGFyIG9uZXNcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VBY2NlbnRzKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG5cbiAgICAgICAgLy8gdmVyaWZpZXMgaWYgdGhlIFN0cmluZyBoYXMgYWNjZW50cyBhbmQgcmVwbGFjZSB0aGVtXG4gICAgICAgIGlmIChzdHIuc2VhcmNoKC9bXFx4QzAtXFx4RkZdL2cpID4gLTEpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0clxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEMwLVxceEM1XS9nLCBcIkFcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhDNl0vZywgXCJBRVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEM3XS9nLCBcIkNcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhDOC1cXHhDQl0vZywgXCJFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4Q0MtXFx4Q0ZdL2csIFwiSVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEQwXS9nLCBcIkRcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhEMV0vZywgXCJOXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RDItXFx4RDZcXHhEOF0vZywgXCJPXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RDktXFx4RENdL2csIFwiVVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEREXS9nLCBcIllcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhERV0vZywgXCJQXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RTAtXFx4RTVdL2csIFwiYVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEU2XS9nLCBcImFlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RTddL2csIFwiY1wiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEU4LVxceEVCXS9nLCBcImVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhFQy1cXHhFRl0vZywgXCJpXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RjFdL2csIFwiblwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEYyLVxceEY2XFx4RjhdL2csIFwib1wiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEY5LVxceEZDXS9nLCBcInVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhGRV0vZywgXCJwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RkRcXHhGRl0vZywgXCJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVwbGFjZUFjY2VudHM7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL3JlcGVhdCcpO1xuXG4gICAgLyoqXG4gICAgICogUGFkIHN0cmluZyB3aXRoIGBjaGFyYCBpZiBpdHMnIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gYG1pbkxlbmBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBycGFkKHN0ciwgbWluTGVuLCBjaCkge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBjaCA9IGNoIHx8ICcgJztcbiAgICAgICAgcmV0dXJuIChzdHIubGVuZ3RoIDwgbWluTGVuKT8gc3RyICsgcmVwZWF0KGNoLCBtaW5MZW4gLSBzdHIubGVuZ3RoKSA6IHN0cjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJwYWQ7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIFdISVRFX1NQQUNFUyA9IHJlcXVpcmUoJy4vV0hJVEVfU1BBQ0VTJyk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNoYXJzIGZyb20gZW5kIG9mIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBydHJpbShzdHIsIGNoYXJzKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGNoYXJzID0gY2hhcnMgfHwgV0hJVEVfU1BBQ0VTO1xuXG4gICAgICAgIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIGNoYXJMZW4gPSBjaGFycy5sZW5ndGgsXG4gICAgICAgICAgICBmb3VuZCA9IHRydWUsXG4gICAgICAgICAgICBpLCBjO1xuXG4gICAgICAgIHdoaWxlIChmb3VuZCAmJiBlbmQgPj0gMCkge1xuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckF0KGVuZCk7XG5cbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBjaGFyTGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IGNoYXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW5kLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZW5kID49IDApID8gc3RyLnN1YnN0cmluZygwLCBlbmQgKyAxKSA6ICcnO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcnRyaW07XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBsb3dlckNhc2UgPSByZXF1aXJlKCcuL2xvd2VyQ2FzZScpO1xudmFyIHVwcGVyQ2FzZSA9IHJlcXVpcmUoJy4vdXBwZXJDYXNlJyk7XG4gICAgLyoqXG4gICAgICogVVBQRVJDQVNFIGZpcnN0IGNoYXIgb2YgZWFjaCBzZW50ZW5jZSBhbmQgbG93ZXJjYXNlIG90aGVyIGNoYXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbnRlbmNlQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZmlyc3QgY2hhciBvZiBlYWNoIHNlbnRlbmNlIChuZXcgbGluZSBvciBhZnRlciAnLlxccysnKSB0b1xuICAgICAgICAvLyBVUFBFUkNBU0VcbiAgICAgICAgcmV0dXJuIGxvd2VyQ2FzZShzdHIpLnJlcGxhY2UoLyheXFx3KXxcXC5cXHMrKFxcdykvZ20sIHVwcGVyQ2FzZSk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gc2VudGVuY2VDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgcmVwbGFjZUFjY2VudHMgPSByZXF1aXJlKCcuL3JlcGxhY2VBY2NlbnRzJyk7XG52YXIgcmVtb3ZlTm9uV29yZCA9IHJlcXVpcmUoJy4vcmVtb3ZlTm9uV29yZCcpO1xudmFyIHRyaW0gPSByZXF1aXJlKCcuL3RyaW0nKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIGxvd2VyIGNhc2UsIHJlbW92ZSBhY2NlbnRzLCByZW1vdmUgbm9uLXdvcmQgY2hhcnMgYW5kXG4gICAgICogcmVwbGFjZSBzcGFjZXMgd2l0aCB0aGUgc3BlY2lmaWVkIGRlbGltZXRlci5cbiAgICAgKiBEb2VzIG5vdCBzcGxpdCBjYW1lbENhc2UgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbHVnaWZ5KHN0ciwgZGVsaW1ldGVyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcblxuICAgICAgICBpZiAoZGVsaW1ldGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGltZXRlciA9IFwiLVwiO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHJlcGxhY2VBY2NlbnRzKHN0cik7XG4gICAgICAgIHN0ciA9IHJlbW92ZU5vbldvcmQoc3RyKTtcbiAgICAgICAgc3RyID0gdHJpbShzdHIpIC8vc2hvdWxkIGNvbWUgYWZ0ZXIgcmVtb3ZlTm9uV29yZFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8gKy9nLCBkZWxpbWV0ZXIpIC8vcmVwbGFjZSBzcGFjZXMgd2l0aCBkZWxpbWV0ZXJcbiAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzbHVnaWZ5O1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHN0cmluZyBzdGFydHMgd2l0aCBzcGVjaWZpZWQgcHJlZml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcHJlZml4ID0gdG9TdHJpbmcocHJlZml4KTtcblxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0YXJ0c1dpdGg7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgSFRNTCB0YWdzIGZyb20gc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwSHRtbFRhZ3Moc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcblxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzxbXj5dKj4vZywgJycpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0cmlwSHRtbFRhZ3M7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBXSElURV9TUEFDRVMgPSByZXF1aXJlKCcuL1dISVRFX1NQQUNFUycpO1xudmFyIGx0cmltID0gcmVxdWlyZSgnLi9sdHJpbScpO1xudmFyIHJ0cmltID0gcmVxdWlyZSgnLi9ydHJpbScpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB3aGl0ZS1zcGFjZXMgZnJvbSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHIsIGNoYXJzKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGNoYXJzID0gY2hhcnMgfHwgV0hJVEVfU1BBQ0VTO1xuICAgICAgICByZXR1cm4gbHRyaW0ocnRyaW0oc3RyLCBjaGFycyksIGNoYXJzKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi90cmltJyk7XG4gICAgLyoqXG4gICAgICogTGltaXQgbnVtYmVyIG9mIGNoYXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0ciwgbWF4Q2hhcnMsIGFwcGVuZCwgb25seUZ1bGxXb3Jkcyl7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGFwcGVuZCA9IGFwcGVuZCB8fCAnLi4uJztcbiAgICAgICAgbWF4Q2hhcnMgPSBvbmx5RnVsbFdvcmRzPyBtYXhDaGFycyArIDEgOiBtYXhDaGFycztcblxuICAgICAgICBzdHIgPSB0cmltKHN0cik7XG4gICAgICAgIGlmKHN0ci5sZW5ndGggPD0gbWF4Q2hhcnMpe1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIG1heENoYXJzIC0gYXBwZW5kLmxlbmd0aCk7XG4gICAgICAgIC8vY3JvcCBhdCBsYXN0IHNwYWNlIG9yIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIHN0ciA9IG9ubHlGdWxsV29yZHM/IHN0ci5zdWJzdHIoMCwgc3RyLmxhc3RJbmRleE9mKCcgJykpIDogdHJpbShzdHIpO1xuICAgICAgICByZXR1cm4gc3RyICsgYXBwZW5kO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRydW5jYXRlO1xuXG4iLCJcblxuICAgIHZhciBVTkRFRjtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBzdHJpbmcgYW5kIGNvbnZlcnQgaXQgaW50byBhIG5hdGl2ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0eXBlY2FzdCh2YWwpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGlmICggdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJ251bGwnICkge1xuICAgICAgICAgICAgciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbCA9PT0gJ3RydWUnICkge1xuICAgICAgICAgICAgciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbCA9PT0gJ2ZhbHNlJyApIHtcbiAgICAgICAgICAgIHIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICggdmFsID09PSBVTkRFRiB8fCB2YWwgPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgciA9IFVOREVGO1xuICAgICAgICB9IGVsc2UgaWYgKCB2YWwgPT09ICcnIHx8IGlzTmFOKHZhbCkgKSB7XG4gICAgICAgICAgICAvL2lzTmFOKCcnKSByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICByID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9wYXJzZUZsb2F0KG51bGwgfHwgJycpIHJldHVybnMgTmFOXG4gICAgICAgICAgICByID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdHlwZWNhc3Q7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIHZhciBDQU1FTF9DQVNFX0JPUkRFUiA9IC8oW2EtelxceEUwLVxceEZGXSkoW0EtWlxceEMwXFx4REZdKS9nO1xuXG4gICAgLyoqXG4gICAgICogQWRkIHNwYWNlIGJldHdlZW4gY2FtZWxDYXNlIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5DYW1lbENhc2Uoc3RyLCBkZWxpbWl0ZXIpe1xuICAgICAgICBpZiAoZGVsaW1pdGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGltaXRlciA9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGpvaW4oc3RyLCBjMSwgYzIpIHtcbiAgICAgICAgICAgIHJldHVybiBjMSArIGRlbGltaXRlciArIGMyO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoQ0FNRUxfQ0FTRV9CT1JERVIsIGpvaW4pO1xuICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTsgLy9hZGQgc3BhY2UgYmV0d2VlbiBjYW1lbENhc2UgdGV4dFxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuQ2FtZWxDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgc2x1Z2lmeSA9IHJlcXVpcmUoJy4vc2x1Z2lmeScpO1xudmFyIHVuQ2FtZWxDYXNlID0gcmVxdWlyZSgnLi91bkNhbWVsQ2FzZScpO1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzLCBzcGxpdCBjYW1lbENhc2UgdGV4dCwgcmVtb3ZlIG5vbi13b3JkIGNoYXJzLCByZW1vdmUgYWNjZW50cyBhbmQgY29udmVydCB0byBsb3dlciBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZGVyc2NvcmUoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3RyID0gdW5DYW1lbENhc2Uoc3RyKTtcbiAgICAgICAgcmV0dXJuIHNsdWdpZnkoc3RyLCBcIl9cIik7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5kZXJzY29yZTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGVzIEhUTUwgc3BlY2lhbCBjaGFyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbChzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJmFtcDsvZyAsICcmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mbHQ7L2cgICwgJzwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyZndDsvZyAgLCAnPicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJiMwKjM5Oy9nICwgXCInXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5lc2NhcGVIdG1sO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIC8qKlxuICAgICAqIFVuZXNjYXBlIHVuaWNvZGUgY2hhciBzZXF1ZW5jZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZVVuaWNvZGUoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcdVswLTlhLWZdezR9L2csIGZ1bmN0aW9uKGNoKXtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoY2guc2xpY2UoMiksIDE2KTtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuZXNjYXBlVW5pY29kZTtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgaHlwaGVucyB3aXRoIHNwYWNlcy4gKG9ubHkgaHlwaGVucyBiZXR3ZWVuIHdvcmQgY2hhcnMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5oeXBoZW5hdGUoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXFx3KSgtKShcXHcpL2csICckMSAkMycpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuaHlwaGVuYXRlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogXCJTYWZlclwiIFN0cmluZy50b1VwcGVyQ2FzZSgpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBwZXJDYXNlKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1cHBlckNhc2U7XG5cbiIsIlxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnY29udmVydCcgOiByZXF1aXJlKCcuL3RpbWUvY29udmVydCcpLFxuICAgICdub3cnIDogcmVxdWlyZSgnLi90aW1lL25vdycpLFxuICAgICdwYXJzZU1zJyA6IHJlcXVpcmUoJy4vdGltZS9wYXJzZU1zJyksXG4gICAgJ3RvVGltZVN0cmluZycgOiByZXF1aXJlKCcuL3RpbWUvdG9UaW1lU3RyaW5nJylcbn07XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IHRpbWUgaW50byBhbm90aGVyIHVuaXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgc291cmNlVW5pdE5hbWUsIGRlc3RpbmF0aW9uVW5pdE5hbWUpe1xuICAgICAgICBkZXN0aW5hdGlvblVuaXROYW1lID0gZGVzdGluYXRpb25Vbml0TmFtZSB8fCAnbXMnO1xuICAgICAgICByZXR1cm4gKHZhbCAqIGdldFVuaXQoc291cmNlVW5pdE5hbWUpKSAvIGdldFVuaXQoZGVzdGluYXRpb25Vbml0TmFtZSk7XG4gICAgfVxuXG5cbiAgICAvL1RPRE86IG1heWJlIGV4dHJhY3QgdG8gYSBzZXBhcmF0ZSBtb2R1bGVcbiAgICBmdW5jdGlvbiBnZXRVbml0KHVuaXROYW1lKXtcbiAgICAgICAgc3dpdGNoKHVuaXROYW1lKXtcbiAgICAgICAgICAgIGNhc2UgJ21zJzpcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDA7XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgIHJldHVybiA2MDAwMDtcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgIHJldHVybiAzNjAwMDAwO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICByZXR1cm4gODY0MDAwMDA7XG4gICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICByZXR1cm4gNjA0ODAwMDAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJysgdW5pdE5hbWUgKyAnXCIgaXMgbm90IGEgdmFsaWQgdW5pdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCB0aW1lIGluIG1pbGlzZWNvbmRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm93KCl7XG4gICAgICAgIC8vIHllcywgd2UgZGVmZXIgdGhlIHdvcmsgdG8gYW5vdGhlciBmdW5jdGlvbiB0byBhbGxvdyBtb2NraW5nIGl0XG4gICAgICAgIC8vIGR1cmluZyB0aGUgdGVzdHNcbiAgICAgICAgcmV0dXJuIG5vdy5nZXQoKTtcbiAgICB9XG5cbiAgICBub3cuZ2V0ID0gKHR5cGVvZiBEYXRlLm5vdyA9PT0gJ2Z1bmN0aW9uJyk/IERhdGUubm93IDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbm93O1xuXG5cbiIsInZhciBjb3VudFN0ZXBzID0gcmVxdWlyZSgnLi4vbWF0aC9jb3VudFN0ZXBzJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aW1lc3RhbXAgaW50byBhbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhtcyl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgOiBjb3VudFN0ZXBzKG1zLCAxLCAxMDAwKSxcbiAgICAgICAgICAgIHNlY29uZHMgICAgICA6IGNvdW50U3RlcHMobXMsIDEwMDAsIDYwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgICAgICA6IGNvdW50U3RlcHMobXMsIDYwMDAwLCA2MCksXG4gICAgICAgICAgICBob3VycyAgICAgICAgOiBjb3VudFN0ZXBzKG1zLCAzNjAwMDAwLCAyNCksXG4gICAgICAgICAgICBkYXlzICAgICAgICAgOiBjb3VudFN0ZXBzKG1zLCA4NjQwMDAwMClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlTXM7XG5cbiIsInZhciBjb3VudFN0ZXBzID0gcmVxdWlyZSgnLi4vbWF0aC9jb3VudFN0ZXBzJyk7XG52YXIgcGFkID0gcmVxdWlyZSgnLi4vbnVtYmVyL3BhZCcpO1xuXG4gICAgdmFyIEhPVVIgPSAzNjAwMDAwLFxuICAgICAgICBNSU5VVEUgPSA2MDAwMCxcbiAgICAgICAgU0VDT05EID0gMTAwMDtcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0aW1lc3RhbXAgaW50byBhIHRpbWUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVGltZVN0cmluZyhtcyl7XG4gICAgICAgIHZhciBoID0gbXMgPCBIT1VSICAgPyAwIDogY291bnRTdGVwcyhtcywgSE9VUiksXG4gICAgICAgICAgICBtID0gbXMgPCBNSU5VVEUgPyAwIDogY291bnRTdGVwcyhtcywgTUlOVVRFLCA2MCksXG4gICAgICAgICAgICBzID0gbXMgPCBTRUNPTkQgPyAwIDogY291bnRTdGVwcyhtcywgU0VDT05ELCA2MCksXG4gICAgICAgICAgICBzdHIgPSAnJztcblxuICAgICAgICBzdHIgKz0gaD8gaCArICc6JyA6ICcnO1xuICAgICAgICBzdHIgKz0gcGFkKG0sIDIpICsgJzonO1xuICAgICAgICBzdHIgKz0gcGFkKHMsIDIpO1xuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9UaW1lU3RyaW5nO1xuXG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCJdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZF1cbiAgJyhbXFxcXC8uXSk/KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKShbKyo/XSk/JyxcbiAgLy8gTWF0Y2ggcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IGFyZSBhbHdheXMgZXNjYXBlZC5cbiAgJyhbLisqPz1eIToke30oKVtcXFxcXXxcXFxcL10pJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knO1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiAgICAgIGksXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6ICBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiAgICBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cyk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHNwZWNpZmljIHRhZ3Mgd2l0aCByZWdleHAgc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXBsYWNlUGF0aCAocGF0aCwga2V5cykge1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2UgKF8sIGVzY2FwZWQsIHByZWZpeCwga2V5LCBjYXB0dXJlLCBncm91cCwgc3VmZml4LCBlc2NhcGUpIHtcbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuXG4gICAgaWYgKGVzY2FwZSkge1xuICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVwZWF0ICAgPSBzdWZmaXggPT09ICcrJyB8fCBzdWZmaXggPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBzdWZmaXggPT09ICc/JyB8fCBzdWZmaXggPT09ICcqJztcblxuICAgIGtleXMucHVzaCh7XG4gICAgICBuYW1lOiAgICAgIGtleSB8fCBpbmRleCsrLFxuICAgICAgZGVsaW1pdGVyOiBwcmVmaXggfHwgJy8nLFxuICAgICAgb3B0aW9uYWw6ICBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogICAgcmVwZWF0XG4gICAgfSk7XG5cbiAgICBwcmVmaXggPSBwcmVmaXggPyAoJ1xcXFwnICsgcHJlZml4KSA6ICcnO1xuICAgIGNhcHR1cmUgPSBlc2NhcGVHcm91cChjYXB0dXJlIHx8IGdyb3VwIHx8ICdbXicgKyAocHJlZml4IHx8ICdcXFxcLycpICsgJ10rPycpO1xuXG4gICAgaWYgKHJlcGVhdCkge1xuICAgICAgY2FwdHVyZSA9IGNhcHR1cmUgKyAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgcmV0dXJuICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgIH1cblxuICAgIC8vIEJhc2ljIHBhcmFtZXRlciBzdXBwb3J0LlxuICAgIHJldHVybiBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICB9XG5cbiAgcmV0dXJuIHBhdGgucmVwbGFjZShQQVRIX1JFR0VYUCwgcmVwbGFjZSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoU3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICAgICAgICAgW2tleXNdXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgIFtvcHRpb25zXVxuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAga2V5cyA9IGtleXMgfHwgW107XG5cbiAgaWYgKCFpc0FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IGtleXM7XG4gICAga2V5cyA9IFtdO1xuICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSByZXBsYWNlUGF0aChwYXRoLCBrZXlzKTtcbiAgdmFyIGVuZHNXaXRoU2xhc2ggPSBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLyc7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoU2xhc2ggPyByb3V0ZS5zbGljZSgwLCAtMikgOiByb3V0ZSkgKyAnKD86XFxcXC8oPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aFNsYXNoID8gJycgOiAnKD89XFxcXC98JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsImRhdCA9IHJlcXVpcmUgXCJkYXQtZ3VpXCJcbnBhZ2UgPSByZXF1aXJlIFwicGFnZVwiXG5cblxuZ3VpID0gd2luZG93Ll9ndWkgPSBuZXcgZGF0LkdVSSgpXG5cbm9wdGlvbnMgPVxuXHRcImRlYnVnXCI6IGZhbHNlXG5cdFwiaW5kZXhcIjogLT4gcGFnZSBcIi9cIlxuXHRcInRlc3RcIjogLT4gcGFnZSBcIi90ZXN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSAtPlxuXHQjIGRlYnVnXG5cdGRlYnVnID0gZ3VpLmFkZChvcHRpb25zLCBcImRlYnVnXCIpXG5cblx0IyBuYXZpZ2F0aW9uXG5cdGZvbGRlciA9IGd1aS5hZGRGb2xkZXIoXCJuYXZpZ2F0aW9uXCIpXG5cdGZvbGRlci5hZGQob3B0aW9ucywgXCJpbmRleFwiKS5uYW1lKFwiL2luZGV4XCIpXG5cdGZvbGRlci5hZGQob3B0aW9ucywgXCJ0ZXN0XCIpLm5hbWUoXCIvdGVzdFwiKVxuXHRmb2xkZXIub3BlbigpXG4iLCJtb2R1bGUuZXhwb3J0cyA9XG5cbiAgICBmaXJlYmFzZTogXCJhbGljZWx1a2VcIlxuIiwiUmFjdGl2ZSA9IHJlcXVpcmUgXCJyYWN0aXZlXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmUuZXh0ZW5kXG5cblx0aXNvbGF0ZWQ6IHRydWVcbiIsIiMjI1xuXHRAbW9kdWxlOiAgIGFic3RyYWN0LXNjZW5lXG5cdEBhdXRob3I6ICAgbHVrZWhlZGdlciA8bHVrZS5oZWRnZXJAZ21haWwuY29tPlxuXHRAY3NzOiAgICAgIC4vc291cmNlL2Nzcy9tb2R1bGUvYWJzdHJhY3Qtc2NlbmUuc3R5bFxuXHRAaHRtbDogICAgIC4vc291cmNlL3RlbXBsYXRlL21vZHVsZS9hYnN0cmFjdC1zY2VuZS5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1tb2R1bGVcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9hYnN0cmFjdC1zY2VuZS5odG1sXCJcblxuXHRwYXJ0aWFsczpcblx0XHRzdGFnZUNvbnRyb2xzOiByZXF1aXJlIFwicGFydGlhbHMvc3RhZ2UtY29udHJvbHMuaHRtbFwiXG5cblx0b25pbml0OiAtPlxuXHRcdEBvbiBcImdvTmV4dFNjZW5lXCIsIC0+IEBmaXJlKFwibmV4dFNjZW5lXCIpXG5cdFx0QG9uIFwiZ29QcmV2U2NlbmVcIiwgLT4gQGZpcmUoXCJwcmV2U2NlbmVcIilcbiIsIiMjI1xuXHRUSElTIEZJTEUgSVMgR0VORVJBVEVEIEFVVE9NQVRJQ0FMTFkgQU5EIElUIFdJTExcblx0QkUgUkVQTEFDRUQgSUYgQSBORVcgTU9EVUxFIElTIEFEREVEIE9SIERFTEVURUQuXG4jIyNcblJhY3RpdmUgPSByZXF1aXJlIFwicmFjdGl2ZVwiXG5cbnJlZ2lzdGVyID0gLT5cblx0UmFjdGl2ZS5jb21wb25lbnRzW1widWktYWJzdHJhY3Qtc2NlbmVcIl0gPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1zY2VuZVwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLW5hdlwiXSA9IHJlcXVpcmUgXCIuL25hdlwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLXNjZW5lLWRheVwiXSA9IHJlcXVpcmUgXCIuL3NjZW5lLWRheVwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLXNjZW5lLWRpZ2VzdFwiXSA9IHJlcXVpcmUgXCIuL3NjZW5lLWRpZ2VzdFwiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLXNjZW5lLW5pZ2h0XCJdID0gcmVxdWlyZSBcIi4vc2NlbmUtbmlnaHRcIlxuXHRSYWN0aXZlLmNvbXBvbmVudHNbXCJ1aS1zdGFnZVwiXSA9IHJlcXVpcmUgXCIuL3N0YWdlXCJcblx0XG5cdHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcigpIiwiIyMjXG5cdEBtb2R1bGU6ICAgbmF2XG5cdEBhdXRob3I6ICAgTHVrZSBIZWRnZXIgPGx1a2UuaGVkZ2VyQGdtYWlsLmNvbT5cblx0QGNzczogICAgICAuL3NvdXJjZS9jc3MvbW9kdWxlL25hdi5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL25hdi5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1tb2R1bGVcIlxuXG5wYWdlID0gcmVxdWlyZSBcInBhZ2VcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9uYXYuaHRtbFwiXG5cblx0b25pbml0OiAtPlxuXG5cdFx0QG9uIFwidG9JbmRleFwiLCAtPiBwYWdlIFwiL1wiXG5cdFx0QG9uIFwidG9UZXN0XCIsIC0+IHBhZ2UgXCIvdGVzdFwiXG4iLCIjIyNcblx0QG1vZHVsZTogICBzY2VuZS1kYXlcblx0QGF1dGhvcjogICBsdWtlaGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9zY2VuZS1kYXkuc3R5bFxuXHRAaHRtbDogICAgIC4vc291cmNlL3RlbXBsYXRlL21vZHVsZS9zY2VuZS1kYXkuaHRtbFxuIyMjXG5cblxuTW9kdWxlID0gcmVxdWlyZSBcIi4vYWJzdHJhY3Qtc2NlbmVcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlLmV4dGVuZFxuXG5cdHRlbXBsYXRlOiByZXF1aXJlIFwibW9kdWxlL3NjZW5lLWRheS5odG1sXCJcblxuXHRvbmluaXQ6IC0+IEBfc3VwZXIoKVxuXG5cdG9ucmVuZGVyOiAtPlxuXHRcdHBhdGggPSBAZmluZChcInBhdGhcIilcblx0XHRsZW5ndGggPSBwYXRoLmdldFRvdGFsTGVuZ3RoKClcblx0XHRUd2Vlbk1heC50byhwYXRoLCAyLCB7IGRlbGF5OiAxLCAnc3Ryb2tlLWRhc2hvZmZzZXQnOiBsZW5ndGgsIGVhc2U6Qm91bmNlLmVhc2VPdXQgfSlcbiIsIiMjI1xuXHRAbW9kdWxlOiAgIHNjZW5lLWRpZ2VzdFxuXHRAYXV0aG9yOiAgIGx1a2VoZWRnZXIgPGx1a2UuaGVkZ2VyQGdtYWlsLmNvbT5cblx0QGNzczogICAgICAuL3NvdXJjZS9jc3MvbW9kdWxlL3NjZW5lLWRpZ2VzdC5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLWRpZ2VzdC5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1zY2VuZVwiXG5rZXlzID0gcmVxdWlyZShcIm1vdXRcIikub2JqZWN0LmtleXNcblxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGUuZXh0ZW5kXG5cblx0dGVtcGxhdGU6IHJlcXVpcmUgXCJtb2R1bGUvc2NlbmUtZGlnZXN0Lmh0bWxcIlxuXG5cdGRhdGE6XG5cdFx0Y3VycmVudDogMVxuXHRcdHg6IFtcIjEwMCVcIiwgXCItMjAwJVwiXVxuXHRcdHNsaWRlczpcblx0XHRcdDE6XG5cdFx0XHRcdHRpdGxlOiBcInNsaWRlIDFcIlxuXHRcdFx0XHRib2R5OiBcInRoaXMgaXMgc2xpZGUgMVwiXG5cdFx0XHRcdGxpbmtzOiBbXCJhXCIsXCJiXCJdXG5cdFx0XHRcdGFjdGl2ZTogdHJ1ZVxuXHRcdFx0Mjpcblx0XHRcdFx0dGl0bGU6IFwic2xpZGUgMlwiXG5cdFx0XHRcdGJvZHk6IFwidGhpcyBpcyBzbGlkZSAyXCJcblx0XHRcdFx0YWN0aXZlOiBmYWxzZVxuXHRcdFx0Mzpcblx0XHRcdFx0dGl0bGU6IFwic2xpZGUgM1wiXG5cdFx0XHRcdGJvZHk6IFwidGhpcyBpcyBzbGlkZSAzXCJcblx0XHRcdFx0YWN0aXZlOiBmYWxzZVxuXG5cdG9uaW5pdDogLT4gQF9zdXBlcigpXG5cblx0b25yZW5kZXI6IC0+XG5cdFx0IyBUT0RPIC0gYWRkIHN3aXBlIGNvbnRyb2xzIChyYWN0aXZlKVxuXHRcdEBvbiBcImdvTmV4dFNsaWRlXCIsIC0+IEBuZXh0U2xpZGUoKVxuXHRcdEBvbiBcImdvUHJldlNsaWRlXCIsIC0+IEBwcmV2U2xpZGUoKVxuXG5cdG5leHRTbGlkZTogLT5cblx0XHRjdXJyZW50ID0gQGdldChcImN1cnJlbnRcIilcblx0XHRuZXh0ID0gaWYgY3VycmVudCBpcyBrZXlzKEBnZXQoXCJzbGlkZXNcIikpLmxlbmd0aCB0aGVuIDEgZWxzZSBjdXJyZW50Kz0xXG5cdFx0QHNldCBcInNsaWRlcy4je0BnZXQoXCJjdXJyZW50XCIpfS54XCIsIEBnZXQoXCJ4WzFdXCIpXG5cdFx0QHNldCBcInNsaWRlcy4je25leHR9LnhcIiwgQGdldChcInhbMF1cIilcblx0XHRAc2V0U2xpZGUgbmV4dFxuXG5cdHByZXZTbGlkZTogLT5cblx0XHRjdXJyZW50ID0gQGdldChcImN1cnJlbnRcIilcblx0XHRwcmV2ID0gaWYgY3VycmVudCBpcyAxIHRoZW4ga2V5cyhAZ2V0KFwic2xpZGVzXCIpKS5sZW5ndGggZWxzZSBjdXJyZW50LT0xXG5cdFx0QHNldCBcInNsaWRlcy4je0BnZXQoXCJjdXJyZW50XCIpfS54XCIsIEBnZXQoXCJ4WzBdXCIpXG5cdFx0QHNldCBcInNsaWRlcy4je3ByZXZ9LnhcIiwgQGdldChcInhbMV1cIilcblx0XHRAc2V0U2xpZGUgcHJldlxuXG5cdHNldFNsaWRlOiAoc2xpZGUpIC0+XG5cdFx0QHNldCBcInNsaWRlcy4je0BnZXQoXCJjdXJyZW50XCIpfS5hY3RpdmVcIiwgZmFsc2Vcblx0XHRAc2V0IFwic2xpZGVzLiN7c2xpZGV9LmFjdGl2ZVwiLCB0cnVlXG5cdFx0QHNldCBjdXJyZW50OiBzbGlkZVxuIiwiIyMjXG5cdEBtb2R1bGU6ICAgc2NlbmUtbmlnaHRcblx0QGF1dGhvcjogICBsdWtlaGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9zY2VuZS1uaWdodC5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLW5pZ2h0Lmh0bWxcbiMjI1xuXG5cbk1vZHVsZSA9IHJlcXVpcmUgXCIuL2Fic3RyYWN0LXNjZW5lXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9zY2VuZS1uaWdodC5odG1sXCJcblxuXHRvbmluaXQ6IC0+IEBfc3VwZXIoKVxuXG5cdG9ucmVuZGVyOiAtPlxuIiwiIyMjXG5cdEBtb2R1bGU6ICAgc3RhZ2Vcblx0QGF1dGhvcjogICBsdWtlaGVkZ2VyIDxsdWtlLmhlZGdlckBnbWFpbC5jb20+XG5cdEBjc3M6ICAgICAgLi9zb3VyY2UvY3NzL21vZHVsZS9zdGFnZS5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3N0YWdlLmh0bWxcbiMjI1xuXG5cbk1vZHVsZSA9IHJlcXVpcmUgXCIuL2Fic3RyYWN0LW1vZHVsZVwiXG5rZXlzID0gcmVxdWlyZShcIm1vdXRcIikub2JqZWN0LmtleXNcblxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGUuZXh0ZW5kXG5cblx0dGVtcGxhdGU6IHJlcXVpcmUgXCJtb2R1bGUvc3RhZ2UuaHRtbFwiXG5cblx0ZGF0YTpcblx0XHRjdXJyZW50OiAwXG5cdFx0c2NlbmU6IG51bGxcblx0XHRzY2VuZXM6XG5cdFx0XHQxOiBcImRheVwiXG5cdFx0XHQyOiBcImRpZ2VzdFwiXG5cdFx0XHQzOiBcIm5pZ2h0XCJcblxuXHRvbmluaXQ6IC0+XG5cdFx0QHNldFNjZW5lIDFcblxuXHRcdHdpbmRvdy5vbmtleWRvd24gPSAoZSkgPT5cblx0XHRcdEBwcmV2U2NlbmUoKSBpZiBlLmtleUNvZGUgaXMgMzhcblx0XHRcdEBuZXh0U2NlbmUoKSBpZiBlLmtleUNvZGUgaXMgNDBcblxuXHRcdEBvbiBcIioubmV4dFNjZW5lXCIsIC0+IEBuZXh0U2NlbmUoKVxuXHRcdEBvbiBcIioucHJldlNjZW5lXCIsIC0+IEBwcmV2U2NlbmUoKVxuXG5cdG5leHRTY2VuZTogLT5cblx0XHRjdXJyZW50ID0gQGdldChcImN1cnJlbnRcIilcblx0XHRuZXh0ID0gaWYgY3VycmVudCBpcyBrZXlzKEBnZXQoXCJzY2VuZXNcIikpLmxlbmd0aCB0aGVuIDEgZWxzZSBjdXJyZW50Kz0xXG5cdFx0QHNldFNjZW5lIG5leHRcblxuXHRwcmV2U2NlbmU6IC0+XG5cdFx0Y3VycmVudCA9IEBnZXQoXCJjdXJyZW50XCIpXG5cdFx0cHJldiA9IGlmIGN1cnJlbnQgaXMgMSB0aGVuIGtleXMoQGdldChcInNjZW5lc1wiKSkubGVuZ3RoIGVsc2UgY3VycmVudC09MVxuXHRcdEBzZXRTY2VuZSBwcmV2XG5cblx0c2V0U2NlbmU6IChzY2VuZSkgLT5cblx0XHRAc2V0XG5cdFx0XHRzY2VuZTogQGdldChcInNjZW5lcy4je3NjZW5lfVwiKVxuXHRcdFx0Y3VycmVudDogc2NlbmVcbiIsIlJhY3RpdmUgPSByZXF1aXJlIFwicmFjdGl2ZVwiXG5GaXJlYmFzZSA9IHJlcXVpcmUgXCJmaXJlYmFzZVwiXG5wYWdlID0gcmVxdWlyZSBcInBhZ2VcIlxuXG5jb25maWcgPSByZXF1aXJlIFwiLi4vY29uZmlnXCJcblxubW9kdWxlLmV4cG9ydHMgPSBSYWN0aXZlLmV4dGVuZFxuXG5cdGVsOiBkb2N1bWVudC5ib2R5XG5cblx0YXBwZW5kOiB0cnVlXG5cblx0dGVtcGxhdGU6IHJlcXVpcmUgXCJtYWluLXZpZXcuaHRtbFwiXG5cblx0ZGF0YTpcblx0XHR2aWV3OiBudWxsXG5cdFx0Z3Vlc3Q6IG51bGxcblxuXHRvbmluaXQ6ICgpIC0+XG5cdFx0Y29uc29sZS5sb2cgXCJbbWFpbi12aWV3XSBpbml0XCJcblxuXHRcdEBnZXREYXRhKClcblxuXHRcdEBzZXRfcm91dGVyKClcblxuXHRnZXREYXRhOiAtPlxuXHRcdCMgVE9ETyAtIGxvYWQgZGF0YS9ndWVzdHMgdG8gZmlyZWJhc2UgdGhlbiBnZXQgZGIuY2hpbGQoXCJndWVzdHNcIikub24oXCJ2YWx1ZVwiLCAuLi4pXG5cdFx0ZGIgPSBuZXcgRmlyZWJhc2UgXCJodHRwczovLyN7Y29uZmlnLmZpcmViYXNlfS5maXJlYmFzZWlvLmNvbS9cIlxuXHRcdGRiLm9uIFwidmFsdWVcIiwgKHNuYXBzaG90KSA9PlxuXHRcdFx0IyBUT0RPIC0gY2hlY2sgZ3Vlc3QgY29kZSBhZ2FpbnN0IGd1ZXN0c1xuXHRcdFx0Y29uc29sZS5sb2cgXCJvazpcIiwgc25hcHNob3QudmFsKClcblx0XHQsIChlcnIpIC0+XG5cdFx0ICAgIGNvbnNvbGUubG9nIFwiZXJyOlwiLCBlcnIuY29kZVxuXG5cdHNldF9yb3V0ZXI6IC0+XG5cdFx0c2VsZiA9IEBcblxuXHRcdHBhZ2UgXCIvXCIsIC0+XG5cdFx0XHRjb25zb2xlLmxvZyBcIlttYWluLXZpZXddIGluZGV4XCJcblx0XHRcdHNlbGYuc2V0IFwidmlld1wiOiBcImluZGV4XCJcblxuXHRcdHBhZ2UgY2xpY2s6IGZhbHNlLCBkaXNwYXRjaDogdHJ1ZSwgaGFzaGJhbmc6IGZhbHNlXG4iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwid3JhcHBlclwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJ1aS1zdGFnZVwifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmYXJtXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmaWVsZFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiYnVudGluZ1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwicG9sZVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJ0cmVlc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZS0tZGFya1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZS0tZGFya1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZVwifX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJ0ZW50c1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVudFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY2FudmFzXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJhd25pbmdcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXBzXCJ9fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVudC0tYmx1ZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY2FudmFzXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJhd25pbmdcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXBzXCJ9fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVudC0tcGlua1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY2FudmFzXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJhd25pbmdcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXBzXCJ9fV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmaXJlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJsb2dzXCJ9fV19XX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImFic3RyYWN0LXNjZW5lXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImgxXCIsXCJmXCI6W1wiYWJzdHJhY3Qtc2NlbmUgOilcIl19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJuYXZcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwidlwiOntcInRhcFwiOlwidG9JbmRleFwifSxcImZcIjpbXCJIb21lXCJdfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImFcIixcInZcIjp7XCJ0YXBcIjpcInRvVGVzdFwifSxcImZcIjpbXCJUZXN0XCJdfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2NlbmUgc2NlbmUtZGF5XCJ9LFwidDFcIjpcImZhZGVcIixcImZcIjpbe1widFwiOjgsXCJyXCI6XCJzdGFnZUNvbnRyb2xzXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3ZnXCIsXCJhXCI6e1wid2lkdGhcIjpcIjIwMHB4XCIsXCJoZWlnaHRcIjpcIjIwMHB4XCIsXCJ2ZXJzaW9uXCI6XCIxLjFcIixcInhtbG5zXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwYXRoXCIsXCJhXCI6e1wiZFwiOlwiTTEwIDEwIEMgMjAgMjAsIDQwIDIwLCA1MCAxMFwiLFwic3Ryb2tlXCI6XCJibGFja1wiLFwiZmlsbFwiOlwidHJhbnNwYXJlbnRcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiZ3JlZXRpbmdcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaDJcIixcImZcIjpbXCJIb3dkeSEgWW91J3JlIGludml0ZWQgdG8gV29vZHN0b2NrIDIwMTVcIl19XX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNjZW5lIHNjZW5lLWRpZ2VzdFwifSxcImZcIjpbe1widFwiOjgsXCJyXCI6XCJzdGFnZUNvbnRyb2xzXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNob3d0aW1lXCJ9LFwidlwiOntcInN3aXBlcmlnaHRcIjpcImdvUHJldlNsaWRlXCIsXCJzd2lwZWxlZnRcIjpcImdvTmV4dFNsaWRlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzaG93dGltZV9fY29udHJvbHNcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImNsYXNzXCI6XCJzaG93dGltZV9fY29udHJvbC0tcHJldlwifSxcInZcIjp7XCJ0YXBcIjpcImdvUHJldlNsaWRlXCJ9LFwiZlwiOltcIuKGkFwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpcInNob3d0aW1lX19jb250cm9sLS1uZXh0XCJ9LFwidlwiOntcInRhcFwiOlwiZ29OZXh0U2xpZGVcIn0sXCJmXCI6W1wi4oaSXCJdfV19LFwiIFwiLHtcInRcIjo0LFwiclwiOlwic2xpZGVzXCIsXCJpXCI6XCJzbGlkZVwiLFwiZlwiOlt7XCJ0XCI6NCxcInJcIjpcImFjdGl2ZVwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W1wic2xpZGUtLVwiLHtcInRcIjoyLFwiclwiOlwic2xpZGVcIn1dfSxcInQwXCI6e1wiblwiOlwiZmx5XCIsXCJkXCI6W1wieyB4OidcIix7XCJ0XCI6MixcInJcIjpcInhcIn0sXCInLCB5OicwJScsIG9wYWNpdHk6MSB9XCJdfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJoMVwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcInRpdGxlXCJ9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiYm9keVwifV19LFwiIFwiLHtcInRcIjo0LFwiclwiOlwibGlua3NcIixcImZcIjpbe1widFwiOjIsXCJyXCI6XCIuXCJ9XX1dfV19XX1dfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2NlbmUgc2NlbmUtbmlnaHRcIn0sXCJmXCI6W3tcInRcIjo4LFwiclwiOlwic3RhZ2VDb250cm9sc1wifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImgxXCIsXCJmXCI6W1wic2NlbmUtbmlnaHQgOilcIl19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W1wic3RhZ2UgXCIse1widFwiOjIsXCJyXCI6XCJzY2VuZVwifV19LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInVpLXNjZW5lLWRheVwiLFwiYVwiOntcImFjdGl2ZVwiOlt7XCJ0XCI6MixcInhcIjp7XCJyXCI6W1wic2NlbmVcIl0sXCJzXCI6XCJfMD09XFxcImRheVxcXCI/dHJ1ZTpmYWxzZVwifX1dfX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJ1aS1zY2VuZS1kaWdlc3RcIixcImFcIjp7XCJhY3RpdmVcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInNjZW5lXCJdLFwic1wiOlwiXzA9PVxcXCJkaWdlc3RcXFwiP3RydWU6ZmFsc2VcIn19XX19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwidWktc2NlbmUtbmlnaHRcIixcImFcIjp7XCJhY3RpdmVcIjpbe1widFwiOjIsXCJ4XCI6e1wiclwiOltcInNjZW5lXCJdLFwic1wiOlwiXzA9PVxcXCJuaWdodFxcXCI/dHJ1ZTpmYWxzZVwifX1dfX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImNsYXNzXCI6XCJzdGFnZV9fY29udHJvbC0tcHJldlwifSxcInZcIjp7XCJ0YXBcIjpcImdvUHJldlNjZW5lXCJ9LFwiZlwiOltcIuKGkVwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpcInN0YWdlX19jb250cm9sLS1uZXh0XCJ9LFwidlwiOntcInRhcFwiOlwiZ29OZXh0U2NlbmVcIn0sXCJmXCI6W1wi4oaTXCJdfV19IiwiLyohXG4gICogZG9tcmVhZHkgKGMpIER1c3RpbiBEaWF6IDIwMTQgLSBMaWNlbnNlIE1JVFxuICAqL1xuIWZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JykgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKVxuXG59KCdkb21yZWFkeScsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZm5zID0gW10sIGxpc3RlbmVyXG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgaGFjayA9IGRvYy5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGxcbiAgICAsIGRvbUNvbnRlbnRMb2FkZWQgPSAnRE9NQ29udGVudExvYWRlZCdcbiAgICAsIGxvYWRlZCA9IChoYWNrID8gL15sb2FkZWR8XmMvIDogL15sb2FkZWR8Xml8XmMvKS50ZXN0KGRvYy5yZWFkeVN0YXRlKVxuXG5cbiAgaWYgKCFsb2FkZWQpXG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyKVxuICAgIGxvYWRlZCA9IDFcbiAgICB3aGlsZSAobGlzdGVuZXIgPSBmbnMuc2hpZnQoKSkgbGlzdGVuZXIoKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBsb2FkZWQgPyBmbigpIDogZm5zLnB1c2goZm4pXG4gIH1cblxufSk7XG4iLCIvKiFcbiAqIFZFUlNJT046IDEuMTYuMFxuICogREFURTogMjAxNS0wMy0wMVxuICogVVBEQVRFUyBBTkQgRE9DUyBBVDogaHR0cDovL2dyZWVuc29jay5jb21cbiAqIFxuICogSW5jbHVkZXMgYWxsIG9mIHRoZSBmb2xsb3dpbmc6IFR3ZWVuTGl0ZSwgVHdlZW5NYXgsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXgsIEVhc2VQYWNrLCBDU1NQbHVnaW4sIFJvdW5kUHJvcHNQbHVnaW4sIEJlemllclBsdWdpbiwgQXR0clBsdWdpbiwgRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpblxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqKi9cbnZhciBfZ3NTY29wZSA9ICh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YoZ2xvYmFsKSAhPT0gXCJ1bmRlZmluZWRcIikgPyBnbG9iYWwgOiB0aGlzIHx8IHdpbmRvdzsgLy9oZWxwcyBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIEFNRC9SZXF1aXJlSlMgYW5kIENvbW1vbkpTL05vZGVcbihfZ3NTY29wZS5fZ3NRdWV1ZSB8fCAoX2dzU2NvcGUuX2dzUXVldWUgPSBbXSkpLnB1c2goIGZ1bmN0aW9uKCkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlR3ZWVuTWF4XCIsIFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKEFuaW1hdGlvbiwgU2ltcGxlVGltZWxpbmUsIFR3ZWVuTGl0ZSkge1xuXG5cdFx0dmFyIF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRUd2Vlbk1heCA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0VHdlZW5MaXRlLmNhbGwodGhpcywgdGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlOyAvL2Vuc3VyZXMgdGhhdCBpZiB0aGVyZSBpcyBhbnkgcmVwZWF0LCB0aGUgdG90YWxEdXJhdGlvbiB3aWxsIGdldCByZWNhbGN1bGF0ZWQgdG8gYWNjdXJhdGVseSByZXBvcnQgaXQuXG5cdFx0XHRcdHRoaXMucmVuZGVyID0gVHdlZW5NYXgucHJvdG90eXBlLnJlbmRlcjsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNTZWxlY3Rvcixcblx0XHRcdF9pc0FycmF5ID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzQXJyYXksXG5cdFx0XHRwID0gVHdlZW5NYXgucHJvdG90eXBlID0gVHdlZW5MaXRlLnRvKHt9LCAwLjEsIHt9KSxcblx0XHRcdF9ibGFua0FycmF5ID0gW107XG5cblx0XHRUd2Vlbk1heC52ZXJzaW9uID0gXCIxLjE2LjBcIjtcblx0XHRwLmNvbnN0cnVjdG9yID0gVHdlZW5NYXg7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0VHdlZW5NYXgua2lsbFR3ZWVuc09mID0gVHdlZW5NYXgua2lsbERlbGF5ZWRDYWxsc1RvID0gVHdlZW5MaXRlLmtpbGxUd2VlbnNPZjtcblx0XHRUd2Vlbk1heC5nZXRUd2VlbnNPZiA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZjtcblx0XHRUd2Vlbk1heC5sYWdTbW9vdGhpbmcgPSBUd2VlbkxpdGUubGFnU21vb3RoaW5nO1xuXHRcdFR3ZWVuTWF4LnRpY2tlciA9IFR3ZWVuTGl0ZS50aWNrZXI7XG5cdFx0VHdlZW5NYXgucmVuZGVyID0gVHdlZW5MaXRlLnJlbmRlcjtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdHJldHVybiBUd2VlbkxpdGUucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudXBkYXRlVG8gPSBmdW5jdGlvbih2YXJzLCByZXNldER1cmF0aW9uKSB7XG5cdFx0XHR2YXIgY3VyUmF0aW8gPSB0aGlzLnJhdGlvLFxuXHRcdFx0XHRpbW1lZGlhdGUgPSB0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIHx8IHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuXHRcdFx0XHRwO1xuXHRcdFx0aWYgKHJlc2V0RHVyYXRpb24gJiYgdGhpcy5fc3RhcnRUaW1lIDwgdGhpcy5fdGltZWxpbmUuX3RpbWUpIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdGhpcy5fdGltZWxpbmUuX3RpbWU7XG5cdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5pbnNlcnQodGhpcywgdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fZGVsYXkpOyAvL2Vuc3VyZXMgdGhhdCBhbnkgbmVjZXNzYXJ5IHJlLXNlcXVlbmNpbmcgb2YgQW5pbWF0aW9ucyBpbiB0aGUgdGltZWxpbmUgb2NjdXJzIHRvIG1ha2Ugc3VyZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGlzIGNvcnJlY3QuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdHRoaXMudmFyc1twXSA9IHZhcnNbcF07XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5faW5pdHRlZCB8fCBpbW1lZGlhdGUpIHtcblx0XHRcdFx0aWYgKHJlc2V0RHVyYXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkICYmIHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkRpc2FibGVcIiwgdGhpcyk7IC8vaW4gY2FzZSBhIHBsdWdpbiBsaWtlIE1vdGlvbkJsdXIgbXVzdCBwZXJmb3JtIHNvbWUgY2xlYW51cCB0YXNrc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSAvIHRoaXMuX2R1cmF0aW9uID4gMC45OTgpIHsgLy9pZiB0aGUgdHdlZW4gaGFzIGZpbmlzaGVkIChvciBjb21lIGV4dHJlbWVseSBjbG9zZSB0byBmaW5pc2hpbmcpLCB3ZSBqdXN0IG5lZWQgdG8gcmV3aW5kIGl0IHRvIDAgYW5kIHRoZW4gcmVuZGVyIGl0IGFnYWluIGF0IHRoZSBlbmQgd2hpY2ggZm9yY2VzIGl0IHRvIHJlLWluaXRpYWxpemUgKHBhcnNpbmcgdGhlIG5ldyB2YXJzKS4gV2UgYWxsb3cgdHdlZW5zIHRoYXQgYXJlIGNsb3NlIHRvIGZpbmlzaGluZyAoYnV0IGhhdmVuJ3QgcXVpdGUgZmluaXNoZWQpIHRvIHdvcmsgdGhpcyB3YXkgdG9vIGJlY2F1c2Ugb3RoZXJ3aXNlLCB0aGUgdmFsdWVzIGFyZSBzbyBzbWFsbCB3aGVuIGRldGVybWluaW5nIHdoZXJlIHRvIHByb2plY3QgdGhlIHN0YXJ0aW5nIHZhbHVlcyB0aGF0IGJpbmFyeSBtYXRoIGlzc3VlcyBjcmVlcCBpbiBhbmQgY2FuIG1ha2UgdGhlIHR3ZWVuIGFwcGVhciB0byByZW5kZXIgaW5jb3JyZWN0bHkgd2hlbiBydW4gYmFja3dhcmRzLiBcblx0XHRcdFx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcigwLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA+IDAgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdFx0XHR2YXIgaW52ID0gMSAvICgxIC0gY3VyUmF0aW8pLFxuXHRcdFx0XHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQsIGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gcHQucyArIHB0LmM7IFxuXHRcdFx0XHRcdFx0XHRwdC5jICo9IGludjtcblx0XHRcdFx0XHRcdFx0cHQucyA9IGVuZFZhbHVlIC0gcHQuYztcblx0XHRcdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XHRcdFxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLnZhcnMucmVwZWF0KSB7IC8vemVybyBkdXJhdGlvbiB0d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgaGF2ZSByZW5kZXIoKSBjYWxsZWQgZnJvbSBUd2VlbkxpdGUncyBjb25zdHJ1Y3RvciwgYmVmb3JlIFR3ZWVuTWF4J3MgY29uc3RydWN0b3IgaGFzIGZpbmlzaGVkIHNldHRpbmcgX3JlcGVhdCwgX3JlcGVhdERlbGF5LCBhbmQgX3lveW8gd2hpY2ggYXJlIGNyaXRpY2FsIGluIGRldGVybWluaW5nIHRvdGFsRHVyYXRpb24oKSBzbyB3ZSBuZWVkIHRvIGNhbGwgaW52YWxpZGF0ZSgpIHdoaWNoIGlzIGEgbG93LWtiIHdheSB0byBnZXQgdGhvc2Ugc2V0IHByb3Blcmx5LlxuXHRcdFx0XHR0aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsIFxuXHRcdFx0XHRwcmV2Q3ljbGUgPSB0aGlzLl9jeWNsZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgY3ljbGVEdXJhdGlvbiwgciwgdHlwZSwgcG93LCByYXdQcmV2VGltZSwgaTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyKSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHRoaXMuX3JlcGVhdDtcblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSA9PT0gdGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uKSB7IC8vaWYgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGlzIGF0IHRoZSBWRVJZIGVuZCBvZiBhIHRpbWVsaW5lIGFuZCB0aGF0IHRpbWVsaW5lIHJlbmRlcnMgYXQgaXRzIGVuZCwgaXQgd2lsbCB0eXBpY2FsbHkgYWRkIGEgdGlueSBiaXQgb2YgY3VzaGlvbiB0byB0aGUgcmVuZGVyIHRpbWUgdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnMgZnJvbSBnZXR0aW5nIGluIHRoZSB3YXkgb2YgdHdlZW5zIHJlbmRlcmluZyB0aGVpciBWRVJZIGVuZC4gSWYgd2UgdGhlbiByZXZlcnNlKCkgdGhhdCB0aW1lbGluZSwgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gd2lsbCB0cmlnZ2VyIGl0cyBvblJldmVyc2VDb21wbGV0ZSBldmVuIHRob3VnaCB0ZWNobmljYWxseSB0aGUgcGxheWhlYWQgZGlkbid0IHBhc3Mgb3ZlciBpdCBhZ2Fpbi4gSXQncyBhIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlIHdlIG11c3QgYWNjb21tb2RhdGUuXG5cdFx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgfHwgcHJldlJhd1ByZXZUaW1lIDwgMCB8fCBwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lKSB7XG5cdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gMCB8fCAoZHVyYXRpb24gPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lID4gMCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHRcdGN5Y2xlRHVyYXRpb24gPSBkdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5O1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gKHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pID4+IDA7IC8vb3JpZ2luYWxseSBfdG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbiBidXQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIGNhdXNlZCBwcm9ibGVtcywgc28gSSBub3JtYWxpemVkIGl0LiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgRmxhc2ggcmVwb3J0cyBpdCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUtLTsgLy9vdGhlcndpc2Ugd2hlbiByZW5kZXJlZCBleGFjdGx5IGF0IHRoZSBlbmQgdGltZSwgaXQgd2lsbCBhY3QgYXMgdGhvdWdoIGl0IGlzIHJlcGVhdGluZyAoYXQgdGhlIGJlZ2lubmluZylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSAtICh0aGlzLl9jeWNsZSAqIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRcdGlmICh0aGlzLl95b3lvKSBpZiAoKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbiAtIHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fZWFzZVR5cGUpIHtcblx0XHRcdFx0XHRyID0gdGhpcy5fdGltZSAvIGR1cmF0aW9uO1xuXHRcdFx0XHRcdHR5cGUgPSB0aGlzLl9lYXNlVHlwZTtcblx0XHRcdFx0XHRwb3cgPSB0aGlzLl9lYXNlUG93ZXI7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgfHwgKHR5cGUgPT09IDMgJiYgciA+PSAwLjUpKSB7XG5cdFx0XHRcdFx0XHRyID0gMSAtIHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdHIgKj0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMikge1xuXHRcdFx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDQpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIC8gZHVyYXRpb24gPCAwLjUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSAociAvIDIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0aWYgKHByZXZUaW1lID09PSB0aGlzLl90aW1lICYmICFmb3JjZSAmJiBwcmV2Q3ljbGUgPT09IHRoaXMuX2N5Y2xlKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7IC8vd2Ugc3RpY2sgaXQgaW4gdGhlIHF1ZXVlIGZvciByZW5kZXJpbmcgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSB0aWNrIC0gdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBiZWNhdXNlIGJyb3dzZXJzIGludmFsaWRhdGUgc3R5bGVzIGFuZCBmb3JjZSBhIHJlY2FsY3VsYXRpb24gaWYgeW91IHJlYWQsIHdyaXRlLCBhbmQgdGhlbiByZWFkIHN0eWxlIGRhdGEgKHNvIGl0J3MgYmV0dGVyIHRvIHJlYWQvcmVhZC9yZWFkL3dyaXRlL3dyaXRlL3dyaXRlIHRoYW4gcmVhZC93cml0ZS9yZWFkL3dyaXRlL3JlYWQvd3JpdGUpLiBUaGUgZG93biBzaWRlLCBvZiBjb3Vyc2UsIGlzIHRoYXQgdXN1YWxseSB5b3UgV0FOVCB0aGluZ3MgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGJlY2F1c2UgeW91IG1heSBoYXZlIGNvZGUgcnVubmluZyByaWdodCBhZnRlciB0aGF0IHdoaWNoIGRlcGVuZHMgb24gdGhlIGNoYW5nZS4gTGlrZSBpbWFnaW5lIHJ1bm5pbmcgVHdlZW5MaXRlLnNldCguLi4pIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoYXQsIGNyZWF0aW5nIGEgbm90aGVyIHR3ZWVuIHRoYXQgYW5pbWF0ZXMgdGhlIHNhbWUgcHJvcGVydHkgdG8gYW5vdGhlciB2YWx1ZTsgdGhlIHN0YXJ0aW5nIHZhbHVlcyBvZiB0aGF0IDJuZCB0d2VlbiB3b3VsZG4ndCBiZSBhY2N1cmF0ZSBpZiBsYXp5IGlzIHRydWUuXG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHByZXZUb3RhbFRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHR0aGlzLl9sYXp5ID0gW3RpbWUsIHN1cHByZXNzRXZlbnRzXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9fZWFzZSBpcyBpbml0aWFsbHkgc2V0IHRvIGRlZmF1bHRFYXNlLCBzbyBub3cgdGhhdCBpbml0KCkgaGFzIHJ1biwgX2Vhc2UgaXMgc2V0IHByb3Blcmx5IGFuZCB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSByYXRpby4gT3ZlcmFsbCB0aGlzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNvbmRpdGlvbmFsIGxvZ2ljIGVhcmxpZXIgaW4gdGhlIG1ldGhvZCB0byBhdm9pZCBoYXZpbmcgdG8gc2V0IHJhdGlvIHR3aWNlIGJlY2F1c2Ugd2Ugb25seSBpbml0KCkgb25jZSBidXQgcmVuZGVyVGltZSgpIGdldHMgY2FsbGVkIFZFUlkgZnJlcXVlbnRseS5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgJiYgIWlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzQ29tcGxldGUgJiYgdGhpcy5fZWFzZS5fY2FsY0VuZCkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKCh0aGlzLl90aW1lID09PSAwKSA/IDAgOiAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2xhenkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPj0gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBhIHR3ZWVuIChhcyBvcHBvc2VkIHRvIHRoZSB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCB0aGUgdGltZWxpbmUgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdHdlZW4gYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUuXG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRvdGFsVGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5faW5pdHRlZCA9PT0gMiAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHRcdC8vdGhpcy5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5faW5pdCgpOyAvL3dpbGwganVzdCBhcHBseSBvdmVyd3JpdGluZyBzaW5jZSBfaW5pdHRlZCBvZiAoMikgbWVhbnMgaXQgd2FzIGEgZnJvbSgpIHR3ZWVuIHRoYXQgaGFkIGltbWVkaWF0ZVJlbmRlcjp0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwiX2R1bW15R1NcIjsgLy9pZiBubyBjYWxsYmFjayBpcyBkZWZpbmVkLCB1c2UgYSBkdW1teSB2YWx1ZSBqdXN0IHNvIHRoYXQgdGhlIGNvbmRpdGlvbiBhdCB0aGUgZW5kIGV2YWx1YXRlcyBhcyB0cnVlIGJlY2F1c2UgX3N0YXJ0QXQgc2hvdWxkIHJlbmRlciBBRlRFUiB0aGUgbm9ybWFsIHJlbmRlciBsb29wIHdoZW4gdGhlIHRpbWUgaXMgbmVnYXRpdmUuIFdlIGNvdWxkIGhhbmRsZSB0aGlzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LCBvZiBjb3Vyc2UsIGJ1dCB0aGUgcmVuZGVyIGxvb3AgaXMgdGhlIE1PU1QgaW1wb3J0YW50IHRoaW5nIHRvIG9wdGltaXplLCBzbyB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgdXMgdG8gYXZvaWQgYWRkaW5nIGV4dHJhIGNvbmRpdGlvbmFsIGxvZ2ljIGluIGEgaGlnaC1mcmVxdWVuY3kgYXJlYS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzLm9uU3RhcnQuYXBwbHkodGhpcy52YXJzLm9uU3RhcnRTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25TdGFydFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXShwdC5jICogdGhpcy5yYXRpbyArIHB0LnMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5jICogdGhpcy5yYXRpbyArIHB0LnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSB7XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkgaWYgKHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5fc3RhcnRUaW1lKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gcHJldlRvdGFsVGltZSB8fCBpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5fb25VcGRhdGUuYXBwbHkodGhpcy52YXJzLm9uVXBkYXRlU2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uVXBkYXRlUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSBwcmV2Q3ljbGUpIGlmICghc3VwcHJlc3NFdmVudHMpIGlmICghdGhpcy5fZ2MpIGlmICh0aGlzLnZhcnMub25SZXBlYXQpIHtcblx0XHRcdFx0dGhpcy52YXJzLm9uUmVwZWF0LmFwcGx5KHRoaXMudmFycy5vblJlcGVhdFNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblJlcGVhdFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MgfHwgZm9yY2UpIHsgLy9jaGVjayBnYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydFRpbWUpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzW2NhbGxiYWNrXS5hcHBseSh0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlNjb3BlXCJdIHx8IHRoaXMsIHRoaXMudmFyc1tjYWxsYmFjayArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHJhd1ByZXZUaW1lICE9PSBfdGlueU51bSkgeyAvL3RoZSBvbkNvbXBsZXRlIG9yIG9uUmV2ZXJzZUNvbXBsZXRlIGNvdWxkIHRyaWdnZXIgbW92ZW1lbnQgb2YgdGhlIHBsYXloZWFkIGFuZCBmb3IgemVyby1kdXJhdGlvbiB0d2VlbnMgKHdoaWNoIG11c3QgZGlzY2VybiBkaXJlY3Rpb24pIHRoYXQgbGFuZCBkaXJlY3RseSBiYWNrIG9uIHRoZWlyIHN0YXJ0IHRpbWUsIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBhZ2FpbiBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaW5rIG9mIHNldmVyYWwgYWRkUGF1c2UoKSdzIGluIGEgdGltZWxpbmUgdGhhdCBmb3JjZXMgdGhlIHBsYXloZWFkIHRvIGEgY2VydGFpbiBzcG90LCBidXQgd2hhdCBpZiBpdCdzIGFscmVhZHkgcGF1c2VkIGFuZCBhbm90aGVyIHR3ZWVuIGlzIHR3ZWVuaW5nIHRoZSBcInRpbWVcIiBvZiB0aGUgdGltZWxpbmU/IEVhY2ggdGltZSBpdCBtb3ZlcyBbZm9yd2FyZF0gcGFzdCB0aGF0IHNwb3QsIGl0IHdvdWxkIG1vdmUgYmFjaywgYW5kIHNpbmNlIHN1cHByZXNzRXZlbnRzIGlzIHRydWUsIGl0J2QgcmVzZXQgX3Jhd1ByZXZUaW1lIHRvIF90aW55TnVtIHNvIHRoYXQgd2hlbiBpdCBiZWdpbnMgYWdhaW4sIHRoZSBjYWxsYmFjayB3b3VsZCBmaXJlIChzbyB1bHRpbWF0ZWx5IGl0IGNvdWxkIGJvdW5jZSBiYWNrIGFuZCBmb3J0aCBkdXJpbmcgdGhhdCB0d2VlbikuIEFnYWluLCB0aGlzIGlzIGEgdmVyeSB1bmNvbW1vbiBzY2VuYXJpbywgYnV0IHBvc3NpYmxlIG5vbmV0aGVsZXNzLlxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG4vLy0tLS0gU1RBVElDIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFxuXHRcdFR3ZWVuTWF4LnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlclRvID0gVHdlZW5NYXguYWxsVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0dmFyIGRlbGF5ID0gdmFycy5kZWxheSB8fCAwLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGZpbmFsQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAodmFycy5vbkNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR2YXJzLm9uQ29tcGxldGUuYXBwbHkodmFycy5vbkNvbXBsZXRlU2NvcGUgfHwgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b25Db21wbGV0ZUFsbC5hcHBseShvbkNvbXBsZXRlQWxsU2NvcGUgfHwgdGhpcywgb25Db21wbGV0ZUFsbFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGwsIGNvcHksIGksIHA7XG5cdFx0XHRpZiAoIV9pc0FycmF5KHRhcmdldHMpKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YodGFyZ2V0cykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHR0YXJnZXRzID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldHMpIHx8IHRhcmdldHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc1NlbGVjdG9yKHRhcmdldHMpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0cyA9IHRhcmdldHMgfHwgW107XG5cdFx0XHRpZiAoc3RhZ2dlciA8IDApIHtcblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0dGFyZ2V0cy5yZXZlcnNlKCk7XG5cdFx0XHRcdHN0YWdnZXIgKj0gLTE7XG5cdFx0XHR9XG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGggLSAxO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvcHkuZGVsYXkgPSBkZWxheTtcblx0XHRcdFx0aWYgKGkgPT09IGwgJiYgb25Db21wbGV0ZUFsbCkge1xuXHRcdFx0XHRcdGNvcHkub25Db21wbGV0ZSA9IGZpbmFsQ29tcGxldGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXSA9IG5ldyBUd2Vlbk1heCh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgY29weSk7XG5cdFx0XHRcdGRlbGF5ICs9IHN0YWdnZXI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJGcm9tID0gVHdlZW5NYXguYWxsRnJvbSA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBUd2Vlbk1heC5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyRnJvbVRvID0gVHdlZW5NYXguYWxsRnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTWF4LnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cdFx0XHRcdFxuXHRcdFR3ZWVuTWF4LmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCB1c2VGcmFtZXMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgoY2FsbGJhY2ssIDAsIHtkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIG9uQ29tcGxldGVTY29wZTpzY29wZSwgb25SZXZlcnNlQ29tcGxldGU6Y2FsbGJhY2ssIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOnBhcmFtcywgb25SZXZlcnNlQ29tcGxldGVTY29wZTpzY29wZSwgaW1tZWRpYXRlUmVuZGVyOmZhbHNlLCB1c2VGcmFtZXM6dXNlRnJhbWVzLCBvdmVyd3JpdGU6MH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5pc1R3ZWVuaW5nID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gKFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQsIHRydWUpLmxlbmd0aCA+IDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIF9nZXRDaGlsZHJlbk9mID0gZnVuY3Rpb24odGltZWxpbmUsIGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRcdHR3ZWVuID0gdGltZWxpbmUuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRpZiAodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQoX2dldENoaWxkcmVuT2YodHdlZW4sIGluY2x1ZGVUaW1lbGluZXMpKTtcblx0XHRcdFx0XHRcdGNudCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSwgXG5cdFx0XHRnZXRBbGxUd2VlbnMgPSBUd2Vlbk1heC5nZXRBbGxUd2VlbnMgPSBmdW5jdGlvbihpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdHJldHVybiBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykuY29uY2F0KCBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykgKTtcblx0XHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgua2lsbEFsbCA9IGZ1bmN0aW9uKGNvbXBsZXRlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRpZiAodHdlZW5zID09IG51bGwpIHtcblx0XHRcdFx0dHdlZW5zID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChkZWxheWVkQ2FsbHMgPT0gbnVsbCkge1xuXHRcdFx0XHRkZWxheWVkQ2FsbHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBnZXRBbGxUd2VlbnMoKHRpbWVsaW5lcyAhPSBmYWxzZSkpLFxuXHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdGFsbFRydWUgPSAodHdlZW5zICYmIGRlbGF5ZWRDYWxscyAmJiB0aW1lbGluZXMpLFxuXHRcdFx0XHRpc0RDLCB0d2VlbiwgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dHdlZW4gPSBhW2ldO1xuXHRcdFx0XHRpZiAoYWxsVHJ1ZSB8fCAodHdlZW4gaW5zdGFuY2VvZiBTaW1wbGVUaW1lbGluZSkgfHwgKChpc0RDID0gKHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkgJiYgZGVsYXllZENhbGxzKSB8fCAodHdlZW5zICYmICFpc0RDKSkge1xuXHRcdFx0XHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4udG90YWxUaW1lKHR3ZWVuLl9yZXZlcnNlZCA/IDAgOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgua2lsbENoaWxkVHdlZW5zT2YgPSBmdW5jdGlvbihwYXJlbnQsIGNvbXBsZXRlKSB7XG5cdFx0XHRpZiAocGFyZW50ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gVHdlZW5MaXRlSW50ZXJuYWxzLnR3ZWVuTG9va3VwLFxuXHRcdFx0XHRhLCBjdXJQYXJlbnQsIHAsIGksIGw7XG5cdFx0XHRpZiAodHlwZW9mKHBhcmVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cGFyZW50ID0gVHdlZW5MaXRlLnNlbGVjdG9yKHBhcmVudCkgfHwgcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc1NlbGVjdG9yKHBhcmVudCkpIHtcblx0XHRcdFx0cGFyZW50ID0gX3NsaWNlKHBhcmVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2lzQXJyYXkocGFyZW50KSkge1xuXHRcdFx0XHRpID0gcGFyZW50Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0VHdlZW5NYXgua2lsbENoaWxkVHdlZW5zT2YocGFyZW50W2ldLCBjb21wbGV0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0YSA9IFtdO1xuXHRcdFx0Zm9yIChwIGluIHRsKSB7XG5cdFx0XHRcdGN1clBhcmVudCA9IHRsW3BdLnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0XHR3aGlsZSAoY3VyUGFyZW50KSB7XG5cdFx0XHRcdFx0aWYgKGN1clBhcmVudCA9PT0gcGFyZW50KSB7XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQodGxbcF0udHdlZW5zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VyUGFyZW50ID0gY3VyUGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0YVtpXS50b3RhbFRpbWUoYVtpXS50b3RhbER1cmF0aW9uKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIF9jaGFuZ2VQYXVzZSA9IGZ1bmN0aW9uKHBhdXNlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHR0d2VlbnMgPSAodHdlZW5zICE9PSBmYWxzZSk7XG5cdFx0XHRkZWxheWVkQ2FsbHMgPSAoZGVsYXllZENhbGxzICE9PSBmYWxzZSk7XG5cdFx0XHR0aW1lbGluZXMgPSAodGltZWxpbmVzICE9PSBmYWxzZSk7XG5cdFx0XHR2YXIgYSA9IGdldEFsbFR3ZWVucyh0aW1lbGluZXMpLFxuXHRcdFx0XHRhbGxUcnVlID0gKHR3ZWVucyAmJiBkZWxheWVkQ2FsbHMgJiYgdGltZWxpbmVzKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoLFxuXHRcdFx0XHRpc0RDLCB0d2Vlbjtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR0d2VlbiA9IGFbaV07XG5cdFx0XHRcdGlmIChhbGxUcnVlIHx8ICh0d2VlbiBpbnN0YW5jZW9mIFNpbXBsZVRpbWVsaW5lKSB8fCAoKGlzREMgPSAodHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSAmJiBkZWxheWVkQ2FsbHMpIHx8ICh0d2VlbnMgJiYgIWlzREMpKSB7XG5cdFx0XHRcdFx0dHdlZW4ucGF1c2VkKHBhdXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgucGF1c2VBbGwgPSBmdW5jdGlvbih0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRfY2hhbmdlUGF1c2UodHJ1ZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5yZXN1bWVBbGwgPSBmdW5jdGlvbih0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRfY2hhbmdlUGF1c2UoZmFsc2UsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpO1xuXHRcdH07XG5cblx0XHRUd2Vlbk1heC5nbG9iYWxUaW1lU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIHRsID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUsXG5cdFx0XHRcdHQgPSBUd2VlbkxpdGUudGlja2VyLnRpbWU7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRsLl90aW1lU2NhbGU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IF90aW55TnVtOyAvL2Nhbid0IGFsbG93IHplcm8gYmVjYXVzZSBpdCdsbCB0aHJvdyB0aGUgbWF0aCBvZmZcblx0XHRcdHRsLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGwuX3N0YXJ0VGltZSkgKiB0bC5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0dGwgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZTtcblx0XHRcdHQgPSBUd2VlbkxpdGUudGlja2VyLmZyYW1lO1xuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0bC5fc3RhcnRUaW1lKSAqIHRsLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR0bC5fdGltZVNjYWxlID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUuX3RpbWVTY2FsZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdFx0XG5cdFxuLy8tLS0tIEdFVFRFUlMgLyBTRVRURVJTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcblx0XHRwLnByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLmR1cmF0aW9uKCkgKiAoKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApID8gMSAtIHZhbHVlIDogdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKSwgZmFsc2UpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxUaW1lIC8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgZmFsc2UpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgPSAodGhpcy5fZHVyYXRpb24gLSB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgKz0gdGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uOyAvL2Rvbid0IHNldCBfZGlydHkgPSBmYWxzZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIHJlcGVhdHMgdGhhdCBoYXZlbid0IGJlZW4gZmFjdG9yZWQgaW50byB0aGUgX3RvdGFsRHVyYXRpb24geWV0LiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgYSByZXBlYXRlZCBUd2Vlbk1heCBhbmQgdGhlbiBpbW1lZGlhdGVseSBjaGVjayBpdHMgZHVyYXRpb24oKSwgaXQgd291bGQgY2FjaGUgdGhlIHZhbHVlIGFuZCB0aGUgdG90YWxEdXJhdGlvbiB3b3VsZCBub3QgYmUgY29ycmVjdCwgdGh1cyByZXBlYXRzIHdvdWxkbid0IHRha2UgZWZmZWN0LlxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUuZHVyYXRpb24uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0Ly9pbnN0ZWFkIG9mIEluZmluaXR5LCB3ZSB1c2UgOTk5OTk5OTk5OTk5IHNvIHRoYXQgd2UgY2FuIGFjY29tbW9kYXRlIHJldmVyc2VzXG5cdFx0XHRcdFx0dGhpcy5fdG90YWxEdXJhdGlvbiA9ICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IDk5OTk5OTk5OTk5OSA6IHRoaXMuX2R1cmF0aW9uICogKHRoaXMuX3JlcGVhdCArIDEpICsgKHRoaXMuX3JlcGVhdERlbGF5ICogdGhpcy5fcmVwZWF0KTtcblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IHRoaXMgOiB0aGlzLmR1cmF0aW9uKCAodmFsdWUgLSAodGhpcy5fcmVwZWF0ICogdGhpcy5fcmVwZWF0RGVsYXkpKSAvICh0aGlzLl9yZXBlYXQgKyAxKSApO1xuXHRcdH07XG5cdFx0XG5cdFx0cC5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC5yZXBlYXREZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdERlbGF5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC55b3lvID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5feW95bztcblx0XHRcdH1cblx0XHRcdHRoaXMuX3lveW8gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0cmV0dXJuIFR3ZWVuTWF4O1xuXHRcdFxuXHR9LCB0cnVlKTtcblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGltZWxpbmVMaXRlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVGltZWxpbmVMaXRlXCIsIFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKEFuaW1hdGlvbiwgU2ltcGxlVGltZWxpbmUsIFR3ZWVuTGl0ZSkge1xuXG5cdFx0dmFyIFRpbWVsaW5lTGl0ZSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0U2ltcGxlVGltZWxpbmUuY2FsbCh0aGlzLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fbGFiZWxzID0ge307XG5cdFx0XHRcdHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gKHRoaXMudmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLnNtb290aENoaWxkVGltaW5nID0gKHRoaXMudmFycy5zbW9vdGhDaGlsZFRpbWluZyA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3NvcnRDaGlsZHJlbiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0XHR2YWwsIHA7XG5cdFx0XHRcdGZvciAocCBpbiB2KSB7XG5cdFx0XHRcdFx0dmFsID0gdltwXTtcblx0XHRcdFx0XHRpZiAoX2lzQXJyYXkodmFsKSkgaWYgKHZhbC5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR2W3BdID0gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzQXJyYXkodi50d2VlbnMpKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGQodi50d2VlbnMsIDAsIHYuYWxpZ24sIHYuc3RhZ2dlcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2ludGVybmFscyA9IFRpbWVsaW5lTGl0ZS5faW50ZXJuYWxzID0ge30sXG5cdFx0XHRfaXNTZWxlY3RvciA9IFR3ZWVuTGl0ZUludGVybmFscy5pc1NlbGVjdG9yLFxuXHRcdFx0X2lzQXJyYXkgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNBcnJheSxcblx0XHRcdF9sYXp5VHdlZW5zID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMsXG5cdFx0XHRfbGF6eVJlbmRlciA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5UmVuZGVyLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRfY29weSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0dmFyIGNvcHkgPSB7fSwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29weTtcblx0XHRcdH0sXG5cdFx0XHRfcGF1c2VDYWxsYmFjayA9IF9pbnRlcm5hbHMucGF1c2VDYWxsYmFjayA9IGZ1bmN0aW9uKHR3ZWVuLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0XHR2YXIgdGwgPSB0d2Vlbi5fdGltZWxpbmUsXG5cdFx0XHRcdFx0dGltZSA9IHRsLl90b3RhbFRpbWUsXG5cdFx0XHRcdFx0c3RhcnRUaW1lID0gdHdlZW4uX3N0YXJ0VGltZSxcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4ucmF0aW8gPyBfdGlueU51bSA6IDAsXG5cdFx0XHRcdFx0cHJldiA9IHR3ZWVuLnJhdGlvID8gMCA6IF90aW55TnVtLFxuXHRcdFx0XHRcdHNpYmxpbmc7XG5cdFx0XHRcdGlmIChjYWxsYmFjayB8fCAhdGhpcy5fZm9yY2luZ1BsYXloZWFkKSB7IC8vaWYgdGhlIHVzZXIgY2FsbHMgYSBtZXRob2QgdGhhdCBtb3ZlcyB0aGUgcGxheWhlYWQgKGxpa2UgcHJvZ3Jlc3MoKSBvciB0aW1lKCkpLCBpdCBzaG91bGQgaG9ub3IgdGhhdCBhbmQgc2tpcCBhbnkgcGF1c2VzIChhbHRob3VnaCBpZiB0aGVyZSdzIGEgY2FsbGJhY2sgcG9zaXRpb25lZCBhdCB0aGF0IHBhdXNlLCBpdCBtdXN0IGp1bXAgdGhlcmUgYW5kIG1ha2UgdGhlIGNhbGwgdG8gZW5zdXJlIHRoZSB0aW1lIGlzIEVYQUNUTFkgd2hhdCBpdCBpcyBzdXBwb3NlZCB0byBiZSwgYW5kIHRoZW4gcHJvY2VlZCB0byB3aGVyZSB0aGUgcGxheWhlYWQgaXMgYmVpbmcgZm9yY2VkKS4gT3RoZXJ3aXNlLCBpbWFnaW5lIHBsYWNpbmcgYSBwYXVzZSBpbiB0aGUgbWlkZGxlIG9mIGEgdGltZWxpbmUgYW5kIHRoZW4gZG9pbmcgdGltZWxpbmUucHJvZ3Jlc3MoMC45KSAtIGl0IHdvdWxkIGdldCBzdHVjayB3aGVyZSB0aGUgcGF1c2UgaXMuXG5cdFx0XHRcdFx0dGwucGF1c2Uoc3RhcnRUaW1lKTtcblx0XHRcdFx0XHQvL25vdyBmaW5kIHNpYmxpbmcgdHdlZW5zIHRoYXQgYXJlIEVYQUNUTFkgYXQgdGhlIHNhbWUgc3BvdCBvbiB0aGUgdGltZWxpbmUgYW5kIGFkanVzdCB0aGUgX3Jhd1ByZXZUaW1lIHNvIHRoYXQgdGhleSBmaXJlIChvciBkb24ndCBmaXJlKSBjb3JyZWN0bHkgb24gdGhlIG5leHQgcmVuZGVyLiBUaGlzIGlzIHByaW1hcmlseSB0byBhY2NvbW1vZGF0ZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucy9jYWxsYmFja3MgdGhhdCBhcmUgcG9zaXRpb25lZCByaWdodCBvbiB0b3Agb2YgYSBwYXVzZS4gRm9yIGV4YW1wbGUsIHRsLnRvKC4uLikuY2FsbCguLi4pLmFkZFBhdXNlKC4uLikuY2FsbCguLi4pIC0gbm90aWNlIHRoYXQgdGhlcmUncyBhIGNhbGwoKSBvbiBlYWNoIHNpZGUgb2YgdGhlIHBhdXNlLCBzbyB3aGVuIGl0J3MgcnVubmluZyBmb3J3YXJkIGl0IHNob3VsZCBjYWxsIHRoZSBmaXJzdCBvbmUgYW5kIHRoZW4gcGF1c2UsIGFuZCB0aGVuIHdoZW4gcmVzdW1lZCwgY2FsbCB0aGUgb3RoZXIuIFplcm8tZHVyYXRpb24gdHdlZW5zIHVzZSBfcmF3UHJldlRpbWUgdG8gc2Vuc2UgbW9tZW50dW0gZmlndXJlIG91dCBpZiBldmVudHMgd2VyZSBzdXBwcmVzc2VkIHdoZW4gYXJyaXZpbmcgZGlyZWN0bHkgb24gdG9wIG9mIHRoYXQgdGltZS5cblx0XHRcdFx0XHRzaWJsaW5nID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0d2hpbGUgKHNpYmxpbmcgJiYgc2libGluZy5fc3RhcnRUaW1lID09PSBzdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdHNpYmxpbmcuX3Jhd1ByZXZUaW1lID0gcHJldjtcblx0XHRcdFx0XHRcdHNpYmxpbmcgPSBzaWJsaW5nLl9wcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzaWJsaW5nID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0d2hpbGUgKHNpYmxpbmcgJiYgc2libGluZy5fc3RhcnRUaW1lID09PSBzdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdHNpYmxpbmcuX3Jhd1ByZXZUaW1lID0gbmV4dDtcblx0XHRcdFx0XHRcdHNpYmxpbmcgPSBzaWJsaW5nLl9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KHNjb3BlIHx8IHRsLCBwYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fZm9yY2luZ1BsYXloZWFkKSB7XG5cdFx0XHRcdFx0XHR0bC5zZWVrKHRpbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRwID0gVGltZWxpbmVMaXRlLnByb3RvdHlwZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpO1xuXG5cdFx0VGltZWxpbmVMaXRlLnZlcnNpb24gPSBcIjEuMTYuMFwiO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUaW1lbGluZUxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gcC5fZm9yY2luZ1BsYXloZWFkID0gZmFsc2U7XG5cblx0XHQvKiBtaWdodCB1c2UgbGF0ZXIuLi5cblx0XHQvL3RyYW5zbGF0ZXMgYSBsb2NhbCB0aW1lIGluc2lkZSBhbiBhbmltYXRpb24gdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGltZSBvbiB0aGUgcm9vdC9nbG9iYWwgdGltZWxpbmUsIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlcy5cblx0XHRmdW5jdGlvbiBsb2NhbFRvR2xvYmFsKHRpbWUsIGFuaW1hdGlvbikge1xuXHRcdFx0d2hpbGUgKGFuaW1hdGlvbikge1xuXHRcdFx0XHR0aW1lID0gKHRpbWUgLyBhbmltYXRpb24uX3RpbWVTY2FsZSkgKyBhbmltYXRpb24uX3N0YXJ0VGltZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbWU7XG5cdFx0fVxuXG5cdFx0Ly90cmFuc2xhdGVzIHRoZSBzdXBwbGllZCB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHRpbWUgaW5zaWRlIGEgcGFydGljdWxhciBhbmltYXRpb24sIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlc1xuXHRcdGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc2NhbGUgPSAxO1xuXHRcdFx0dGltZSAtPSBsb2NhbFRvR2xvYmFsKDAsIGFuaW1hdGlvbik7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHNjYWxlICo9IGFuaW1hdGlvbi5fdGltZVNjYWxlO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZSAqIHNjYWxlO1xuXHRcdH1cblx0XHQqL1xuXG5cdFx0cC50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGU7XG5cdFx0XHRyZXR1cm4gZHVyYXRpb24gPyB0aGlzLmFkZCggbmV3IEVuZ2luZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pIDogdGhpcy5zZXQodGFyZ2V0LCB2YXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoICgodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZSkuZnJvbSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHRvVmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBFbmdpbmUuZnJvbVRvKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHRvVmFycywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXIgdGwgPSBuZXcgVGltZWxpbmVMaXRlKHtvbkNvbXBsZXRlOm9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVQYXJhbXM6b25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZVNjb3BlOm9uQ29tcGxldGVBbGxTY29wZSwgc21vb3RoQ2hpbGRUaW1pbmc6dGhpcy5zbW9vdGhDaGlsZFRpbWluZ30pLFxuXHRcdFx0XHRpO1xuXHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHR0YXJnZXRzID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldHMpIHx8IHRhcmdldHM7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChfaXNTZWxlY3Rvcih0YXJnZXRzKSkgeyAvL3NlbnNlcyBpZiB0aGUgdGFyZ2V0cyBvYmplY3QgaXMgYSBzZWxlY3Rvci4gSWYgaXQgaXMsIHdlIHNob3VsZCB0cmFuc2xhdGUgaXQgaW50byBhbiBhcnJheS5cblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdH1cblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRpZiAoc3RhZ2dlciA8IDApIHtcblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0dGFyZ2V0cy5yZXZlcnNlKCk7XG5cdFx0XHRcdHN0YWdnZXIgKj0gLTE7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodmFycy5zdGFydEF0KSB7XG5cdFx0XHRcdFx0dmFycy5zdGFydEF0ID0gX2NvcHkodmFycy5zdGFydEF0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bC50byh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgX2NvcHkodmFycyksIGkgKiBzdGFnZ2VyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmFkZCh0bCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJGcm9tID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlKTtcblx0XHRcdGlmICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHBvc2l0aW9uID09PSB0aGlzLl90aW1lICYmICF0aGlzLl9wYXVzZWQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0VGltZWxpbmVMaXRlLmV4cG9ydFJvb3QgPSBmdW5jdGlvbih2YXJzLCBpZ25vcmVEZWxheWVkQ2FsbHMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0aWYgKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXJzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUodmFycyksXG5cdFx0XHRcdHJvb3QgPSB0bC5fdGltZWxpbmUsXG5cdFx0XHRcdHR3ZWVuLCBuZXh0O1xuXHRcdFx0aWYgKGlnbm9yZURlbGF5ZWRDYWxscyA9PSBudWxsKSB7XG5cdFx0XHRcdGlnbm9yZURlbGF5ZWRDYWxscyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyb290Ll9yZW1vdmUodGwsIHRydWUpO1xuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IDA7XG5cdFx0XHR0bC5fcmF3UHJldlRpbWUgPSB0bC5fdGltZSA9IHRsLl90b3RhbFRpbWUgPSByb290Ll90aW1lO1xuXHRcdFx0dHdlZW4gPSByb290Ll9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdGlmICghaWdub3JlRGVsYXllZENhbGxzIHx8ICEodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUgJiYgdHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSB7XG5cdFx0XHRcdFx0dGwuYWRkKHR3ZWVuLCB0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRyb290LmFkZCh0bCwgMCk7XG5cdFx0XHRyZXR1cm4gdGw7XG5cdFx0fTtcblxuXHRcdHAuYWRkID0gZnVuY3Rpb24odmFsdWUsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIGN1clRpbWUsIGwsIGksIGNoaWxkLCB0bCwgYmVmb3JlUmF3VGltZTtcblx0XHRcdGlmICh0eXBlb2YocG9zaXRpb24pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiwgMCwgdHJ1ZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG5cdFx0XHRcdGlmICgodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKHZhbHVlICYmIHZhbHVlLnB1c2ggJiYgX2lzQXJyYXkodmFsdWUpKSkge1xuXHRcdFx0XHRcdGFsaWduID0gYWxpZ24gfHwgXCJub3JtYWxcIjtcblx0XHRcdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0XHRcdGN1clRpbWUgPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRsID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChfaXNBcnJheShjaGlsZCA9IHZhbHVlW2ldKSkge1xuXHRcdFx0XHRcdFx0XHRjaGlsZCA9IG5ldyBUaW1lbGluZUxpdGUoe3R3ZWVuczpjaGlsZH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5hZGQoY2hpbGQsIGN1clRpbWUpO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihjaGlsZCkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mKGNoaWxkKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhbGlnbiA9PT0gXCJzZXF1ZW5jZVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VyVGltZSA9IGNoaWxkLl9zdGFydFRpbWUgKyAoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWxpZ24gPT09IFwic3RhcnRcIikge1xuXHRcdFx0XHRcdFx0XHRcdGNoaWxkLl9zdGFydFRpbWUgLT0gY2hpbGQuZGVsYXkoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyVGltZSArPSBzdGFnZ2VyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGFiZWwodmFsdWUsIHBvc2l0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3coXCJDYW5ub3QgYWRkIFwiICsgdmFsdWUgKyBcIiBpbnRvIHRoZSB0aW1lbGluZTsgaXQgaXMgbm90IGEgdHdlZW4sIHRpbWVsaW5lLCBmdW5jdGlvbiwgb3Igc3RyaW5nLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdmFsdWUsIHBvc2l0aW9uKTtcblxuXHRcdFx0Ly9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgdGhpcy5fdGltZSA9PT0gdGhpcy5fZHVyYXRpb24pIGlmICghdGhpcy5fcGF1c2VkKSBpZiAodGhpcy5fZHVyYXRpb24gPCB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuXHRcdFx0XHR0bCA9IHRoaXM7XG5cdFx0XHRcdGJlZm9yZVJhd1RpbWUgPSAodGwucmF3VGltZSgpID4gdmFsdWUuX3N0YXJ0VGltZSk7IC8vaWYgdGhlIHR3ZWVuIGlzIHBsYWNlZCBvbiB0aGUgdGltZWxpbmUgc28gdGhhdCBpdCBzdGFydHMgQkVGT1JFIHRoZSBjdXJyZW50IHJhd1RpbWUsIHdlIHNob3VsZCBhbGlnbiB0aGUgcGxheWhlYWQgKG1vdmUgdGhlIHRpbWVsaW5lKS4gVGhpcyBpcyBiZWNhdXNlIHNvbWV0aW1lcyB1c2VycyB3aWxsIGNyZWF0ZSBhIHRpbWVsaW5lLCBsZXQgaXQgZmluaXNoLCBhbmQgbXVjaCBsYXRlciBhcHBlbmQgYSB0d2VlbiBhbmQgZXhwZWN0IGl0IHRvIHJ1biBpbnN0ZWFkIG9mIGp1bXBpbmcgdG8gaXRzIGVuZCBzdGF0ZS4gV2hpbGUgdGVjaG5pY2FsbHkgb25lIGNvdWxkIGFyZ3VlIHRoYXQgaXQgc2hvdWxkIGp1bXAgdG8gaXRzIGVuZCBzdGF0ZSwgdGhhdCdzIG5vdCB3aGF0IHVzZXJzIGludHVpdGl2ZWx5IGV4cGVjdC5cblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdGlmIChiZWZvcmVSYXdUaW1lICYmIHRsLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpOyAvL21vdmVzIHRoZSB0aW1lbGluZSAoc2hpZnRzIGl0cyBzdGFydFRpbWUpIGlmIG5lY2Vzc2FyeSwgYW5kIGFsc28gZW5hYmxlcyBpdC5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRsLl9nYykge1xuXHRcdFx0XHRcdFx0dGwuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZW1vdmUodmFsdWUsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdHZhciBpID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZSh2YWx1ZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMua2lsbChudWxsLCB2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAuX3JlbW92ZSA9IGZ1bmN0aW9uKHR3ZWVuLCBza2lwRGlzYWJsZSkge1xuXHRcdFx0U2ltcGxlVGltZWxpbmUucHJvdG90eXBlLl9yZW1vdmUuY2FsbCh0aGlzLCB0d2Vlbiwgc2tpcERpc2FibGUpO1xuXHRcdFx0dmFyIGxhc3QgPSB0aGlzLl9sYXN0O1xuXHRcdFx0aWYgKCFsYXN0KSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID4gbGFzdC5fc3RhcnRUaW1lICsgbGFzdC5fdG90YWxEdXJhdGlvbiAvIGxhc3QuX3RpbWVTY2FsZSkge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldE9yTGFiZWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB2YWx1ZSkpO1xuXHRcdH07XG5cblx0XHRwLmluc2VydCA9IHAuaW5zZXJ0TXVsdGlwbGUgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodmFsdWUsIHBvc2l0aW9uIHx8IDAsIGFsaWduLCBzdGFnZ2VyKTtcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmRNdWx0aXBsZSA9IGZ1bmN0aW9uKHR3ZWVucywgb2Zmc2V0T3JMYWJlbCwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh0d2VlbnMsIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCwgb2Zmc2V0T3JMYWJlbCwgdHJ1ZSwgdHdlZW5zKSwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hZGRQYXVzZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0dmFyIHQgPSBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgX3BhdXNlQ2FsbGJhY2ssIFtcIntzZWxmfVwiLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZV0sIHRoaXMpO1xuXHRcdFx0dC5kYXRhID0gXCJpc1BhdXNlXCI7IC8vIHdlIHVzZSB0aGlzIGZsYWcgaW4gVHdlZW5MaXRlJ3MgcmVuZGVyKCkgbWV0aG9kIHRvIGlkZW50aWZ5IGl0IGFzIGEgc3BlY2lhbCBjYXNlIHRoYXQgc2hvdWxkbid0IGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2aXJ0dWFsIHBsYXloZWFkIGlzIExFQVZJTkcgdGhlIGV4YWN0IHBvc2l0aW9uIHdoZXJlIHRoZSBwYXVzZSBpcywgb3RoZXJ3aXNlIHRpbWVsaW5lLmFkZFBhdXNlKDEpLnBsYXkoMSkgd291bGQgZW5kIHVwIHBhdXNlZCBvbiB0aGUgdmVyeSBuZXh0IHRpY2suXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sYWJlbHNbbGFiZWxdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZ2V0TGFiZWxUaW1lID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHJldHVybiAodGhpcy5fbGFiZWxzW2xhYmVsXSAhPSBudWxsKSA/IHRoaXMuX2xhYmVsc1tsYWJlbF0gOiAtMTtcblx0XHR9O1xuXG5cdFx0cC5fcGFyc2VUaW1lT3JMYWJlbCA9IGZ1bmN0aW9uKHRpbWVPckxhYmVsLCBvZmZzZXRPckxhYmVsLCBhcHBlbmRJZkFic2VudCwgaWdub3JlKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdC8vaWYgd2UncmUgYWJvdXQgdG8gYWRkIGEgdHdlZW4vdGltZWxpbmUgKG9yIGFuIGFycmF5IG9mIHRoZW0pIHRoYXQncyBhbHJlYWR5IGEgY2hpbGQgb2YgdGhpcyB0aW1lbGluZSwgd2Ugc2hvdWxkIHJlbW92ZSBpdCBmaXJzdCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29udGFtaW5hdGUgdGhlIGR1cmF0aW9uKCkuXG5cdFx0XHRpZiAoaWdub3JlIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHR0aGlzLnJlbW92ZShpZ25vcmUpO1xuXHRcdFx0fSBlbHNlIGlmIChpZ25vcmUgJiYgKChpZ25vcmUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKGlnbm9yZS5wdXNoICYmIF9pc0FycmF5KGlnbm9yZSkpKSkge1xuXHRcdFx0XHRpID0gaWdub3JlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGlnbm9yZVtpXSBpbnN0YW5jZW9mIEFuaW1hdGlvbiAmJiBpZ25vcmVbaV0udGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKG9mZnNldE9yTGFiZWwpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG9mZnNldE9yTGFiZWwsIChhcHBlbmRJZkFic2VudCAmJiB0eXBlb2YodGltZU9yTGFiZWwpID09PSBcIm51bWJlclwiICYmIHRoaXMuX2xhYmVsc1tvZmZzZXRPckxhYmVsXSA9PSBudWxsKSA/IHRpbWVPckxhYmVsIC0gdGhpcy5kdXJhdGlvbigpIDogMCwgYXBwZW5kSWZBYnNlbnQpO1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0T3JMYWJlbCA9IG9mZnNldE9yTGFiZWwgfHwgMDtcblx0XHRcdGlmICh0eXBlb2YodGltZU9yTGFiZWwpID09PSBcInN0cmluZ1wiICYmIChpc05hTih0aW1lT3JMYWJlbCkgfHwgdGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSAhPSBudWxsKSkgeyAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuXHRcdFx0XHRpID0gdGltZU9yTGFiZWwuaW5kZXhPZihcIj1cIik7XG5cdFx0XHRcdGlmIChpID09PSAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdID09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhcHBlbmRJZkFic2VudCA/ICh0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdID0gdGhpcy5kdXJhdGlvbigpICsgb2Zmc2V0T3JMYWJlbCkgOiBvZmZzZXRPckxhYmVsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSArIG9mZnNldE9yTGFiZWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2Zmc2V0T3JMYWJlbCA9IHBhcnNlSW50KHRpbWVPckxhYmVsLmNoYXJBdChpLTEpICsgXCIxXCIsIDEwKSAqIE51bWJlcih0aW1lT3JMYWJlbC5zdWJzdHIoaSsxKSk7XG5cdFx0XHRcdHRpbWVPckxhYmVsID0gKGkgPiAxKSA/IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwodGltZU9yTGFiZWwuc3Vic3RyKDAsIGktMSksIDAsIGFwcGVuZElmQWJzZW50KSA6IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdH0gZWxzZSBpZiAodGltZU9yTGFiZWwgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lT3JMYWJlbCA9IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1iZXIodGltZU9yTGFiZWwpICsgb2Zmc2V0T3JMYWJlbDtcblx0XHR9O1xuXG5cdFx0cC5zZWVrID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoKHR5cGVvZihwb3NpdGlvbikgPT09IFwibnVtYmVyXCIpID8gcG9zaXRpb24gOiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKSwgKHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSkpO1xuXHRcdH07XG5cblx0XHRwLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGxheShwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZShwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0cHJldlN0YXJ0ID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRwcmV2VGltZVNjYWxlID0gdGhpcy5fdGltZVNjYWxlLFxuXHRcdFx0XHRwcmV2UGF1c2VkID0gdGhpcy5fcGF1c2VkLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2U7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1cikge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2R1cmF0aW9uID09PSAwKSBpZiAodGltZSA9PT0gMCB8fCB0aGlzLl9yYXdQcmV2VGltZSA8IDAgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtKSBpZiAodGhpcy5fcmF3UHJldlRpbWUgIT09IHRpbWUgJiYgdGhpcy5fZmlyc3QpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0dGltZSA9IHRvdGFsRHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy5cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKHRoaXMuX2R1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lICE9PSBfdGlueU51bSAmJiAodGhpcy5fcmF3UHJldlRpbWUgPiAwIHx8ICh0aW1lIDwgMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA+PSAwKSkpKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgdGhpcy5fcmV2ZXJzZWQpIHsgLy9lbnN1cmVzIHByb3BlciBHQyBpZiBhIHRpbWVsaW5lIGlzIHJlc3VtZWQgYWZ0ZXIgaXQncyBmaW5pc2hlZCByZXZlcnNpbmcuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gaXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lID49IDAgJiYgdGhpcy5fZmlyc3QpIHsgLy93aGVuIGdvaW5nIGJhY2sgYmV5b25kIHRoZSBzdGFydCwgZm9yY2UgYSByZW5kZXIgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyB0aGF0IHNpdCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgcmVuZGVyIHRoZWlyIHN0YXJ0IHZhbHVlcyBwcm9wZXJseS4gT3RoZXJ3aXNlLCBpZiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBhdCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lLCBhbmQgdGhlbiBtb3ZlcyBiYWNrd2FyZHMsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgYmVnaW5uaW5nIHdvdWxkIHN0aWxsIGJlIGF0IHRoZWlyIGVuZCBzdGF0ZS5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwICYmIGlzQ29tcGxldGUpIHsgLy9pZiB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSB0aW1lbGluZSBhbmQgdGhlIHBsYXloZWFkIGxhbmRzIEVYQUNUTFkgYXQgdGltZSAwLCB0aGF0IHR3ZWVuIHdpbGwgY29ycmVjdGx5IHJlbmRlciBpdHMgZW5kIHZhbHVlcywgYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgdGltZWxpbmUgYWxpdmUgZm9yIG9uZSBtb3JlIHJlbmRlciBzbyB0aGF0IHRoZSBiZWdpbm5pbmcgdmFsdWVzIHJlbmRlciBwcm9wZXJseSBhcyB0aGUgcGFyZW50J3MgcGxheWhlYWQga2VlcHMgbW92aW5nIGJleW9uZCB0aGUgYmVnaW5pbmcuIEltYWdpbmUgb2JqLnggc3RhcnRzIGF0IDAgYW5kIHRoZW4gd2UgZG8gdGwuc2V0KG9iaiwge3g6MTAwfSkudG8ob2JqLCAxLCB7eDoyMDB9KSBhbmQgdGhlbiBsYXRlciB3ZSB0bC5yZXZlcnNlKCkuLi50aGUgZ29hbCBpcyB0byBoYXZlIG9iai54IHJldmVydCB0byAwLiBJZiB0aGUgcGxheWhlYWQgaGFwcGVucyB0byBsYW5kIG9uIGV4YWN0bHkgMCwgd2l0aG91dCB0aGlzIGNodW5rIG9mIGNvZGUsIGl0J2QgY29tcGxldGUgdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVuZGVyaW5nIHF1ZXVlIChub3QgZ29vZCkuXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA9IDA7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgKGNvdWxkIGNhdXNlIHByb2JsZW1zIGVzcGVjaWFsbHkgd2l0aCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lKVxuXHRcdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lIHx8ICF0aGlzLl9maXJzdCkgJiYgIWZvcmNlICYmICFpbnRlcm5hbEZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgdGhlIHRpbWVsaW5lIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgaXQgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdGltZWxpbmUgYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUsIGZvciBleGFtcGxlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldlRpbWUgPT09IDApIGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RpbWUgIT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy52YXJzLm9uU3RhcnQuYXBwbHkodGhpcy52YXJzLm9uU3RhcnRTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25TdGFydFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90aW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gdGhpcy5fdGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmdcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0VGltZSB8fCBwcmV2VGltZVNjYWxlICE9PSB0aGlzLl90aW1lU2NhbGUpIGlmICh0aGlzLl90aW1lID09PSAwIHx8IHRvdGFsRHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpKSB7IC8vaWYgb25lIG9mIHRoZSB0d2VlbnMgdGhhdCB3YXMgcmVuZGVyZWQgYWx0ZXJlZCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIChsaWtlIGlmIGFuIG9uQ29tcGxldGUgcmV2ZXJzZWQgdGhlIHRpbWVsaW5lKSwgaXQgcHJvYmFibHkgaXNuJ3QgY29tcGxldGUuIElmIGl0IGlzLCBkb24ndCB3b3JyeSwgYmVjYXVzZSB3aGF0ZXZlciBjYWxsIGFsdGVyZWQgdGhlIHN0YXJ0VGltZSB3b3VsZCBjb21wbGV0ZSBpZiBpdCB3YXMgbmVjZXNzYXJ5IGF0IHRoZSBuZXcgdGltZS4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHRoZSB0aW1lU2NhbGUgcHJvcGVydHkuIEFsc28gY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25Db21wbGV0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMudmFyc1tjYWxsYmFja10uYXBwbHkodGhpcy52YXJzW2NhbGxiYWNrICsgXCJTY29wZVwiXSB8fCB0aGlzLCB0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlBhcmFtc1wiXSB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5faGFzUGF1c2VkQ2hpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fcGF1c2VkIHx8ICgodHdlZW4gaW5zdGFuY2VvZiBUaW1lbGluZUxpdGUpICYmIHR3ZWVuLl9oYXNQYXVzZWRDaGlsZCgpKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAtOTk5OTk5OTk5OTtcblx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGNudCA9IDA7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0Ly9kbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUpIHtcblx0XHRcdFx0XHRpZiAodHdlZW5zICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRpbWVsaW5lcyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChuZXN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQodHdlZW4uZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcblx0XHRcdFx0XHRcdGNudCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbih0YXJnZXQsIG5lc3RlZCkge1xuXHRcdFx0dmFyIGRpc2FibGVkID0gdGhpcy5fZ2MsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0dHdlZW5zLCBpO1xuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgdHJ1ZSk7IC8vZ2V0VHdlZW5zT2YoKSBmaWx0ZXJzIG91dCBkaXNhYmxlZCB0d2VlbnMsIGFuZCB3ZSBoYXZlIHRvIG1hcmsgdGhlbSBhcyBfZ2MgPSB0cnVlIHdoZW4gdGhlIHRpbWVsaW5lIGNvbXBsZXRlcyBpbiBvcmRlciB0byBhbGxvdyBjbGVhbiBnYXJiYWdlIGNvbGxlY3Rpb24sIHNvIHRlbXBvcmFyaWx5IHJlLWVuYWJsZSB0aGUgdGltZWxpbmUgaGVyZS5cblx0XHRcdH1cblx0XHRcdHR3ZWVucyA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQpO1xuXHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS50aW1lbGluZSA9PT0gdGhpcyB8fCAobmVzdGVkICYmIHRoaXMuX2NvbnRhaW5zKHR3ZWVuc1tpXSkpKSB7XG5cdFx0XHRcdFx0YVtjbnQrK10gPSB0d2VlbnNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLnJlY2VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlY2VudDtcblx0XHR9O1xuXG5cdFx0cC5fY29udGFpbnMgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdFx0dmFyIHRsID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwpIHtcblx0XHRcdFx0aWYgKHRsID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGwgPSB0bC50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdGlnbm9yZUJlZm9yZVRpbWUgPSBpZ25vcmVCZWZvcmVUaW1lIHx8IDA7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bGFiZWxzID0gdGhpcy5fbGFiZWxzLFxuXHRcdFx0XHRwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fc3RhcnRUaW1lICs9IGFtb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFkanVzdExhYmVscykge1xuXHRcdFx0XHRmb3IgKHAgaW4gbGFiZWxzKSB7XG5cdFx0XHRcdFx0aWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0XHRsYWJlbHNbcF0gKz0gYW1vdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdGlmICghdmFycyAmJiAhdGFyZ2V0KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHdlZW5zID0gKCF0YXJnZXQpID8gdGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkgOiB0aGlzLmdldFR3ZWVuc09mKHRhcmdldCksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS5fa2lsbCh2YXJzLCB0YXJnZXQpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmNsZWFyID0gZnVuY3Rpb24obGFiZWxzKSB7XG5cdFx0XHR2YXIgdHdlZW5zID0gdGhpcy5nZXRDaGlsZHJlbihmYWxzZSwgdHJ1ZSwgdHJ1ZSksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0dHdlZW5zW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGFiZWxzICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLmludmFsaWRhdGUoKTtcblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTs7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKGVuYWJsZWQgPT09IHRoaXMuX2djKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChlbmFibGVkLCB0cnVlKTtcblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gdHJ1ZTtcblx0XHRcdHZhciB2YWwgPSBBbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTsgLy9qdXN0IHRyaWdnZXJzIHJlY2FsY3VsYXRpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5kdXJhdGlvbigpICE9PSAwICYmIHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudGltZVNjYWxlKHRoaXMuX2R1cmF0aW9uIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dmFyIG1heCA9IDAsXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3QsXG5cdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSA5OTk5OTk5OTk5OTksXG5cdFx0XHRcdFx0XHRwcmV2LCBlbmQ7XG5cdFx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRwcmV2ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fZGlydHkpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4udG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSB0d2VlbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+IHByZXZTdGFydCAmJiB0aGlzLl9zb3J0Q2hpbGRyZW4gJiYgIXR3ZWVuLl9wYXVzZWQpIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgdHdlZW5zIHNoaWZ0ZWQgb3V0IG9mIG9yZGVyLCBpdCBuZWVkcyB0byBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZVxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCAwICYmICF0d2Vlbi5fcGF1c2VkKSB7IC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG5cdFx0XHRcdFx0XHRcdG1heCAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgKz0gdHdlZW4uX3N0YXJ0VGltZSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLnNoaWZ0Q2hpbGRyZW4oLXR3ZWVuLl9zdGFydFRpbWUsIGZhbHNlLCAtOTk5OTk5OTk5OSk7XG5cdFx0XHRcdFx0XHRcdHByZXZTdGFydCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbmQgPSB0d2Vlbi5fc3RhcnRUaW1lICsgKHR3ZWVuLl90b3RhbER1cmF0aW9uIC8gdHdlZW4uX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRpZiAoZW5kID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IGVuZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR3ZWVuID0gcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gbWF4O1xuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy50b3RhbER1cmF0aW9uKCkgIT09IDApIGlmICh2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRpbWVTY2FsZSh0aGlzLl90b3RhbER1cmF0aW9uIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghdmFsdWUpIHsgLy9pZiB0aGVyZSdzIGEgcGF1c2UgZGlyZWN0bHkgYXQgdGhlIHNwb3QgZnJvbSB3aGVyZSB3ZSdyZSB1bnBhdXNpbmcsIHNraXAgaXQuXG5cdFx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA9PT0gdGltZSAmJiB0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIikge1xuXHRcdFx0XHRcdFx0dHdlZW4uX3Jhd1ByZXZUaW1lID0gdGltZTsgLy9yZW1lbWJlciwgX3Jhd1ByZXZUaW1lIGlzIGhvdyB6ZXJvLWR1cmF0aW9uIHR3ZWVucy9jYWxsYmFja3Mgc2Vuc2UgZGlyZWN0aW9uYWxpdHkgYW5kIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmaXJlLiBJZiBfcmF3UHJldlRpbWUgaXMgdGhlIHNhbWUgYXMgX3N0YXJ0VGltZSBvbiB0aGUgbmV4dCByZW5kZXIsIGl0IHdvbid0IGZpcmUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHRwLnVzZXNGcmFtZXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGwgPT09IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lKTtcblx0XHR9O1xuXG5cdFx0cC5yYXdUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkID8gdGhpcy5fdG90YWxUaW1lIDogKHRoaXMuX3RpbWVsaW5lLnJhd1RpbWUoKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZUxpdGU7XG5cblx0fSwgdHJ1ZSk7XG5cdFxuXG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaW1lbGluZU1heFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTWF4XCIsIFtcIlRpbWVsaW5lTGl0ZVwiLFwiVHdlZW5MaXRlXCIsXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oVGltZWxpbmVMaXRlLCBUd2VlbkxpdGUsIEVhc2UpIHtcblxuXHRcdHZhciBUaW1lbGluZU1heCA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0VGltZWxpbmVMaXRlLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfZWFzZU5vbmUgPSBuZXcgRWFzZShudWxsLCBudWxsLCAxLCAwKSxcblx0XHRcdHAgPSBUaW1lbGluZU1heC5wcm90b3R5cGUgPSBuZXcgVGltZWxpbmVMaXRlKCk7XG5cblx0XHRwLmNvbnN0cnVjdG9yID0gVGltZWxpbmVNYXg7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0VGltZWxpbmVNYXgudmVyc2lvbiA9IFwiMS4xNi4wXCI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVGltZWxpbmVMaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblxuXHRcdHAuYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgcG9zaXRpb24sIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUNhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBvc2l0aW9uKSB7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHBvc2l0aW9uID09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9raWxsKG51bGwsIGNhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgYSA9IHRoaXMuZ2V0VHdlZW5zT2YoY2FsbGJhY2ssIGZhbHNlKSxcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldLl9zdGFydFRpbWUgPT09IHRpbWUpIHtcblx0XHRcdFx0XHRcdFx0YVtpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlUGF1c2UgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlQ2FsbGJhY2soVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMucGF1c2VDYWxsYmFjaywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnR3ZWVuVG8gPSBmdW5jdGlvbihwb3NpdGlvbiwgdmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHR2YXIgY29weSA9IHtlYXNlOl9lYXNlTm9uZSwgdXNlRnJhbWVzOnRoaXMudXNlc0ZyYW1lcygpLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2V9LFxuXHRcdFx0XHRkdXJhdGlvbiwgcCwgdDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0Y29weS50aW1lID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRkdXJhdGlvbiA9IChNYXRoLmFicyhOdW1iZXIoY29weS50aW1lKSAtIHRoaXMuX3RpbWUpIC8gdGhpcy5fdGltZVNjYWxlKSB8fCAwLjAwMTtcblx0XHRcdHQgPSBuZXcgVHdlZW5MaXRlKHRoaXMsIGR1cmF0aW9uLCBjb3B5KTtcblx0XHRcdGNvcHkub25TdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0LnRhcmdldC5wYXVzZWQodHJ1ZSk7XG5cdFx0XHRcdGlmICh0LnZhcnMudGltZSAhPT0gdC50YXJnZXQudGltZSgpICYmIGR1cmF0aW9uID09PSB0LmR1cmF0aW9uKCkpIHsgLy9kb24ndCBtYWtlIHRoZSBkdXJhdGlvbiB6ZXJvIC0gaWYgaXQncyBzdXBwb3NlZCB0byBiZSB6ZXJvLCBkb24ndCB3b3JyeSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBpbml0dGluZyB0aGUgdHdlZW4gYW5kIHdpbGwgY29tcGxldGUgaW1tZWRpYXRlbHksIGVmZmVjdGl2ZWx5IG1ha2luZyB0aGUgZHVyYXRpb24gemVybyBhbnl3YXkuIElmIHdlIG1ha2UgZHVyYXRpb24gemVybywgdGhlIHR3ZWVuIHdvbid0IHJ1biBhdCBhbGwuXG5cdFx0XHRcdFx0dC5kdXJhdGlvbiggTWF0aC5hYnMoIHQudmFycy50aW1lIC0gdC50YXJnZXQudGltZSgpKSAvIHQudGFyZ2V0Ll90aW1lU2NhbGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycy5vblN0YXJ0KSB7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuXHRcdFx0XHRcdHZhcnMub25TdGFydC5hcHBseSh2YXJzLm9uU3RhcnRTY29wZSB8fCB0LCB2YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fTtcblxuXHRcdHAudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbihmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0ZnJvbVBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChmcm9tUG9zaXRpb24pO1xuXHRcdFx0dmFycy5zdGFydEF0ID0ge29uQ29tcGxldGU6dGhpcy5zZWVrLCBvbkNvbXBsZXRlUGFyYW1zOltmcm9tUG9zaXRpb25dLCBvbkNvbXBsZXRlU2NvcGU6dGhpc307XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpO1xuXHRcdFx0dmFyIHQgPSB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgdmFycyk7XG5cdFx0XHRyZXR1cm4gdC5kdXJhdGlvbigoTWF0aC5hYnMoIHQudmFycy50aW1lIC0gZnJvbVBvc2l0aW9uKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDEpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2UsIGN5Y2xlRHVyYXRpb247XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1cikge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gdGhpcy5fcmVwZWF0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2R1cmF0aW9uID09PSAwKSBpZiAodGltZSA9PT0gMCB8fCBwcmV2UmF3UHJldlRpbWUgPCAwIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0pIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUgJiYgdGhpcy5fZmlyc3QpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXI7XG5cdFx0XHRcdFx0dGltZSA9IGR1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAtIHNvbWV0aW1lcyBjaGlsZCB0d2VlbnMvdGltZWxpbmVzIHdlcmUgbm90IGJlaW5nIGZ1bGx5IGNvbXBsZXRlZCAodGhlaXIgcHJvZ3Jlc3MgbWlnaHQgYmUgMC45OTk5OTk5OTk5OTk5OTggaW5zdGVhZCBvZiAxIGJlY2F1c2Ugd2hlbiBfdGltZSAtIHR3ZWVuLl9zdGFydFRpbWUgaXMgcGVyZm9ybWVkLCBmbG9hdGluZyBwb2ludCBlcnJvcnMgd291bGQgcmV0dXJuIGEgdmFsdWUgdGhhdCB3YXMgU0xJR0hUTFkgb2ZmKS4gVHJ5ICg5OTk5OTk5OTk5OTkuNyAtIDk5OTk5OTk5OTk5OSkgKiAxID0gMC42OTk5NTExNzE4NzUgaW5zdGVhZCBvZiAwLjcuIFdlIGNhbm5vdCBkbyBsZXNzIHRoZW4gMC4wMDAxIGJlY2F1c2UgdGhlIHNhbWUgaXNzdWUgY2FuIG9jY3VyIHdoZW4gdGhlIGR1cmF0aW9uIGlzIGV4dHJlbWVseSBsYXJnZSBsaWtlIDk5OTk5OTk5OTk5OSBpbiB3aGljaCBjYXNlIGFkZGluZyAwLjAwMDAwMDAxLCBmb3IgZXhhbXBsZSwgY2F1c2VzIGl0IHRvIGFjdCBsaWtlIG5vdGhpbmcgd2FzIGFkZGVkLlxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8IChkdXIgPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lICE9PSBfdGlueU51bSAmJiAocHJldlJhd1ByZXZUaW1lID4gMCB8fCAodGltZSA8IDAgJiYgcHJldlJhd1ByZXZUaW1lID49IDApKSAmJiAhdGhpcy5fbG9ja2VkKSkgeyAvL2VkZ2UgY2FzZSBmb3IgY2hlY2tpbmcgdGltZSA8IDAgJiYgcHJldlJhd1ByZXZUaW1lID49IDA6IGEgemVyby1kdXJhdGlvbiBmcm9tVG8oKSB0d2VlbiBpbnNpZGUgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lICh5ZWFoLCB2ZXJ5IHJhcmUpXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSBpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgdGhpcy5fZmlyc3QpIHsgLy93aGVuIGdvaW5nIGJhY2sgYmV5b25kIHRoZSBzdGFydCwgZm9yY2UgYSByZW5kZXIgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyB0aGF0IHNpdCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgcmVuZGVyIHRoZWlyIHN0YXJ0IHZhbHVlcyBwcm9wZXJseS4gT3RoZXJ3aXNlLCBpZiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBhdCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lLCBhbmQgdGhlbiBtb3ZlcyBiYWNrd2FyZHMsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgYmVnaW5uaW5nIHdvdWxkIHN0aWxsIGJlIGF0IHRoZWlyIGVuZCBzdGF0ZS5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAoZHVyIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7IC8vaWYgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgdGltZWxpbmUgYW5kIHRoZSBwbGF5aGVhZCBsYW5kcyBFWEFDVExZIGF0IHRpbWUgMCwgdGhhdCB0d2VlbiB3aWxsIGNvcnJlY3RseSByZW5kZXIgaXRzIGVuZCB2YWx1ZXMsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHRpbWVsaW5lIGFsaXZlIGZvciBvbmUgbW9yZSByZW5kZXIgc28gdGhhdCB0aGUgYmVnaW5uaW5nIHZhbHVlcyByZW5kZXIgcHJvcGVybHkgYXMgdGhlIHBhcmVudCdzIHBsYXloZWFkIGtlZXBzIG1vdmluZyBiZXlvbmQgdGhlIGJlZ2luaW5nLiBJbWFnaW5lIG9iai54IHN0YXJ0cyBhdCAwIGFuZCB0aGVuIHdlIGRvIHRsLnNldChvYmosIHt4OjEwMH0pLnRvKG9iaiwgMSwge3g6MjAwfSkgYW5kIHRoZW4gbGF0ZXIgd2UgdGwucmV2ZXJzZSgpLi4udGhlIGdvYWwgaXMgdG8gaGF2ZSBvYmoueCByZXZlcnQgdG8gMC4gSWYgdGhlIHBsYXloZWFkIGhhcHBlbnMgdG8gbGFuZCBvbiBleGFjdGx5IDAsIHdpdGhvdXQgdGhpcyBjaHVuayBvZiBjb2RlLCBpdCdkIGNvbXBsZXRlIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlbmRlcmluZyBxdWV1ZSAobm90IGdvb2QpLlxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPSAwOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIChjb3VsZCBjYXVzZSBwcm9ibGVtcyBlc3BlY2lhbGx5IHdpdGggemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZHVyID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA8IDApIHsgLy93aXRob3V0IHRoaXMsIHplcm8tZHVyYXRpb24gcmVwZWF0aW5nIHRpbWVsaW5lcyAobGlrZSB3aXRoIGEgc2ltcGxlIGNhbGxiYWNrIG5lc3RlZCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgYW5kIGEgcmVwZWF0RGVsYXkpIHdvdWxkbid0IHJlbmRlciB0aGUgZmlyc3QgdGltZSB0aHJvdWdoLlxuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9ICh0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSA+PiAwOyAvL29yaWdpbmFsbHkgX3RvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24gYnV0IGZsb2F0aW5nIHBvaW50IGVycm9ycyBjYXVzZWQgcHJvYmxlbXMsIHNvIEkgbm9ybWFsaXplZCBpdC4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IGl0IGdldHMgcmVwb3J0ZWQgYXMgMC43OTk5OTk5OSEpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jeWNsZS0tOyAvL290aGVyd2lzZSB3aGVuIHJlbmRlcmVkIGV4YWN0bHkgYXQgdGhlIGVuZCB0aW1lLCBpdCB3aWxsIGFjdCBhcyB0aG91Z2ggaXQgaXMgcmVwZWF0aW5nIChhdCB0aGUgYmVnaW5uaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSAtICh0aGlzLl9jeWNsZSAqIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3lveW8pIGlmICgodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyIC0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gZHVyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXI7XG5cdFx0XHRcdFx0XHRcdHRpbWUgPSBkdXIgKyAwLjAwMDE7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IDA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSBwcmV2Q3ljbGUpIGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdC8qXG5cdFx0XHRcdG1ha2Ugc3VyZSBjaGlsZHJlbiBhdCB0aGUgZW5kL2JlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUgYXJlIHJlbmRlcmVkIHByb3Blcmx5LiBJZiwgZm9yIGV4YW1wbGUsXG5cdFx0XHRcdGEgMy1zZWNvbmQgbG9uZyB0aW1lbGluZSByZW5kZXJlZCBhdCAyLjkgc2Vjb25kcyBwcmV2aW91c2x5LCBhbmQgbm93IHJlbmRlcnMgYXQgMy4yIHNlY29uZHMgKHdoaWNoXG5cdFx0XHRcdHdvdWxkIGdldCB0cmFuc2F0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG5cdFx0XHRcdGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xuXHRcdFx0XHR3ZSBuZWVkIHRvIHB1c2ggdGhlIHRpbWVsaW5lIHRvIHRoZSBlbmQgKGFuZC9vciBiZWdpbm5pbmcgZGVwZW5kaW5nIG9uIGl0cyB5b3lvIHZhbHVlKS4gQWxzbyB3ZSBtdXN0XG5cdFx0XHRcdGVuc3VyZSB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIFRpbWVsaW5lTWF4IHdvcmsuXG5cdFx0XHRcdCovXG5cdFx0XHRcdHZhciBiYWNrd2FyZHMgPSAodGhpcy5feW95byAmJiAocHJldkN5Y2xlICYgMSkgIT09IDApLFxuXHRcdFx0XHRcdHdyYXAgPSAoYmFja3dhcmRzID09PSAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkpLFxuXHRcdFx0XHRcdHJlY1RvdGFsVGltZSA9IHRoaXMuX3RvdGFsVGltZSxcblx0XHRcdFx0XHRyZWNDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHRcdHJlY1Jhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdFx0cmVjVGltZSA9IHRoaXMuX3RpbWU7XG5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcHJldkN5Y2xlICogZHVyO1xuXHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgPCBwcmV2Q3ljbGUpIHtcblx0XHRcdFx0XHRiYWNrd2FyZHMgPSAhYmFja3dhcmRzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSArPSBkdXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHByZXZUaW1lOyAvL3RlbXBvcmFyaWx5IHJldmVydCBfdGltZSBzbyB0aGF0IHJlbmRlcigpIHJlbmRlcnMgdGhlIGNoaWxkcmVuIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBXaXRob3V0IHRoaXMsIHR3ZWVucyB3b24ndCByZXdpbmQgY29ycmVjdGx5LiBXZSBjb3VsZCBhcmhpY3RlY3QgdGhpbmdzIGluIGEgXCJjbGVhbmVyXCIgd2F5IGJ5IHNwbGl0dGluZyBvdXQgdGhlIHJlbmRlcmluZyBxdWV1ZSBpbnRvIGEgc2VwYXJhdGUgbWV0aG9kIGJ1dCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2Uga2VwdCBpdCBhbGwgaW5zaWRlIHRoaXMgbWV0aG9kLlxuXG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKGR1ciA9PT0gMCkgPyBwcmV2UmF3UHJldlRpbWUgLSAwLjAwMDEgOiBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gcHJldkN5Y2xlO1xuXHRcdFx0XHR0aGlzLl9sb2NrZWQgPSB0cnVlOyAvL3ByZXZlbnRzIGNoYW5nZXMgdG8gdG90YWxUaW1lIGFuZCBza2lwcyByZXBlYXQveW95byBiZWhhdmlvciB3aGVuIHdlIHJlY3Vyc2l2ZWx5IGNhbGwgcmVuZGVyKClcblx0XHRcdFx0cHJldlRpbWUgPSAoYmFja3dhcmRzKSA/IDAgOiBkdXI7XG5cdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCBzdXBwcmVzc0V2ZW50cywgKGR1ciA9PT0gMCkpO1xuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAoIXRoaXMuX2djKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMudmFycy5vblJlcGVhdCkge1xuXHRcdFx0XHRcdFx0dGhpcy52YXJzLm9uUmVwZWF0LmFwcGx5KHRoaXMudmFycy5vblJlcGVhdFNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblJlcGVhdFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh3cmFwKSB7XG5cdFx0XHRcdFx0cHJldlRpbWUgPSAoYmFja3dhcmRzKSA/IGR1ciArIDAuMDAwMSA6IC0wLjAwMDE7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkgeyAvL2lmIHRoZSByZW5kZXIoKSB0cmlnZ2VyZWQgY2FsbGJhY2sgdGhhdCBwYXVzZWQgdGhpcyB0aW1lbGluZSwgd2Ugc2hvdWxkIGFib3J0ICh2ZXJ5IHJhcmUsIGJ1dCBwb3NzaWJsZSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHJlY1RpbWU7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHJlY1RvdGFsVGltZTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSByZWNDeWNsZTtcblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByZWNSYXdQcmV2VGltZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCh0aGlzLl90aW1lID09PSBwcmV2VGltZSB8fCAhdGhpcy5fZmlyc3QpICYmICFmb3JjZSAmJiAhaW50ZXJuYWxGb3JjZSkge1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gdGhpcy5fdG90YWxUaW1lKSBpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHsgLy9zbyB0aGF0IG9uVXBkYXRlIGZpcmVzIGV2ZW4gZHVyaW5nIHRoZSByZXBlYXREZWxheSAtIGFzIGxvbmcgYXMgdGhlIHRvdGFsVGltZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdHJpZ2dlciBvblVwZGF0ZS5cblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90b3RhbFRpbWUgIT09IHByZXZUb3RhbFRpbWUgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIHRoZSB0aW1lbGluZSAoYXMgb3Bwb3NlZCB0byB0aGUgcGFyZW50IHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIGl0IGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHRpbWVsaW5lIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLCBmb3IgZXhhbXBsZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgPT09IDApIGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0aGlzLnZhcnMub25TdGFydC5hcHBseSh0aGlzLnZhcnMub25TdGFydFNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblN0YXJ0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmdcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSB0aGlzLl90aW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gcHJldlRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fb25VcGRhdGUuYXBwbHkodGhpcy52YXJzLm9uVXBkYXRlU2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uVXBkYXRlUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9sb2NrZWQpIGlmICghdGhpcy5fZ2MpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0VGltZSB8fCBwcmV2VGltZVNjYWxlICE9PSB0aGlzLl90aW1lU2NhbGUpIGlmICh0aGlzLl90aW1lID09PSAwIHx8IHRvdGFsRHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpKSB7IC8vaWYgb25lIG9mIHRoZSB0d2VlbnMgdGhhdCB3YXMgcmVuZGVyZWQgYWx0ZXJlZCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIChsaWtlIGlmIGFuIG9uQ29tcGxldGUgcmV2ZXJzZWQgdGhlIHRpbWVsaW5lKSwgaXQgcHJvYmFibHkgaXNuJ3QgY29tcGxldGUuIElmIGl0IGlzLCBkb24ndCB3b3JyeSwgYmVjYXVzZSB3aGF0ZXZlciBjYWxsIGFsdGVyZWQgdGhlIHN0YXJ0VGltZSB3b3VsZCBjb21wbGV0ZSBpZiBpdCB3YXMgbmVjZXNzYXJ5IGF0IHRoZSBuZXcgdGltZS4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHRoZSB0aW1lU2NhbGUgcHJvcGVydHkuIEFsc28gY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25Db21wbGV0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMudmFyc1tjYWxsYmFja10uYXBwbHkodGhpcy52YXJzW2NhbGxiYWNrICsgXCJTY29wZVwiXSB8fCB0aGlzLCB0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlBhcmFtc1wiXSB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5nZXRBY3RpdmUgPSBmdW5jdGlvbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzKSB7XG5cdFx0XHRpZiAobmVzdGVkID09IG51bGwpIHtcblx0XHRcdFx0bmVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0d2VlbnMgPT0gbnVsbCkge1xuXHRcdFx0XHR0d2VlbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpbWVsaW5lcyA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWVsaW5lcyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0YWxsID0gdGhpcy5nZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzKSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0bCA9IGFsbC5sZW5ndGgsXG5cdFx0XHRcdGksIHR3ZWVuO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0d2VlbiA9IGFsbFtpXTtcblx0XHRcdFx0aWYgKHR3ZWVuLmlzQWN0aXZlKCkpIHtcblx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cblx0XHRwLmdldExhYmVsQWZ0ZXIgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0XHRpZiAoIXRpbWUpIGlmICh0aW1lICE9PSAwKSB7IC8vZmFzdGVyIHRoYW4gaXNOYW4oKVxuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGwgPSBsYWJlbHMubGVuZ3RoLFxuXHRcdFx0XHRpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldLnRpbWUgPiB0aW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhYmVsc1tpXS5uYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbEJlZm9yZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICh0aW1lID09IG51bGwpIHtcblx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHNBcnJheSgpLFxuXHRcdFx0XHRpID0gbGFiZWxzLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldLnRpbWUgPCB0aW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhYmVsc1tpXS5uYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbHNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0cDtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9sYWJlbHMpIHtcblx0XHRcdFx0YVtjbnQrK10gPSB7dGltZTp0aGlzLl9sYWJlbHNbcF0sIG5hbWU6cH07XG5cdFx0XHR9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHRcdHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblxuLy8tLS0tIEdFVFRFUlMgLyBTRVRURVJTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAucHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLmR1cmF0aW9uKCkgKiAoKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApID8gMSAtIHZhbHVlIDogdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxUaW1lIC8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUudG90YWxEdXJhdGlvbi5jYWxsKHRoaXMpOyAvL2p1c3QgZm9yY2VzIHJlZnJlc2hcblx0XHRcdFx0XHQvL0luc3RlYWQgb2YgSW5maW5pdHksIHdlIHVzZSA5OTk5OTk5OTk5OTkgc28gdGhhdCB3ZSBjYW4gYWNjb21tb2RhdGUgcmV2ZXJzZXMuXG5cdFx0XHRcdFx0dGhpcy5fdG90YWxEdXJhdGlvbiA9ICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IDk5OTk5OTk5OTk5OSA6IHRoaXMuX2R1cmF0aW9uICogKHRoaXMuX3JlcGVhdCArIDEpICsgKHRoaXMuX3JlcGVhdERlbGF5ICogdGhpcy5fcmVwZWF0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyB0aGlzIDogdGhpcy5kdXJhdGlvbiggKHZhbHVlIC0gKHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JlcGVhdERlbGF5KSkgLyAodGhpcy5fcmVwZWF0ICsgMSkgKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgPSAodGhpcy5fZHVyYXRpb24gLSB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgKz0gdGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldExhYmVsQmVmb3JlKHRoaXMuX3RpbWUgKyAwLjAwMDAwMDAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnNlZWsodmFsdWUsIHRydWUpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gVGltZWxpbmVNYXg7XG5cblx0fSwgdHJ1ZSk7XG5cdFxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJlemllclBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdChmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfcjEgPSBbXSxcblx0XHRcdF9yMiA9IFtdLFxuXHRcdFx0X3IzID0gW10sXG5cdFx0XHRfY29yUHJvcHMgPSB7fSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRTZWdtZW50ID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHR0aGlzLmEgPSBhO1xuXHRcdFx0XHR0aGlzLmIgPSBiO1xuXHRcdFx0XHR0aGlzLmMgPSBjO1xuXHRcdFx0XHR0aGlzLmQgPSBkO1xuXHRcdFx0XHR0aGlzLmRhID0gZCAtIGE7XG5cdFx0XHRcdHRoaXMuY2EgPSBjIC0gYTtcblx0XHRcdFx0dGhpcy5iYSA9IGIgLSBhO1xuXHRcdFx0fSxcblx0XHRcdF9jb3JyZWxhdGUgPSBcIix4LHkseixsZWZ0LHRvcCxyaWdodCxib3R0b20sbWFyZ2luVG9wLG1hcmdpbkxlZnQsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLHBhZGRpbmdMZWZ0LHBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20sYmFja2dyb3VuZFBvc2l0aW9uLGJhY2tncm91bmRQb3NpdGlvbl95LFwiLFxuXHRcdFx0Y3ViaWNUb1F1YWRyYXRpYyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcblx0XHRcdFx0dmFyIHExID0ge2E6YX0sXG5cdFx0XHRcdFx0cTIgPSB7fSxcblx0XHRcdFx0XHRxMyA9IHt9LFxuXHRcdFx0XHRcdHE0ID0ge2M6ZH0sXG5cdFx0XHRcdFx0bWFiID0gKGEgKyBiKSAvIDIsXG5cdFx0XHRcdFx0bWJjID0gKGIgKyBjKSAvIDIsXG5cdFx0XHRcdFx0bWNkID0gKGMgKyBkKSAvIDIsXG5cdFx0XHRcdFx0bWFiYyA9IChtYWIgKyBtYmMpIC8gMixcblx0XHRcdFx0XHRtYmNkID0gKG1iYyArIG1jZCkgLyAyLFxuXHRcdFx0XHRcdG04ID0gKG1iY2QgLSBtYWJjKSAvIDg7XG5cdFx0XHRcdHExLmIgPSBtYWIgKyAoYSAtIG1hYikgLyA0O1xuXHRcdFx0XHRxMi5iID0gbWFiYyArIG04O1xuXHRcdFx0XHRxMS5jID0gcTIuYSA9IChxMS5iICsgcTIuYikgLyAyO1xuXHRcdFx0XHRxMi5jID0gcTMuYSA9IChtYWJjICsgbWJjZCkgLyAyO1xuXHRcdFx0XHRxMy5iID0gbWJjZCAtIG04O1xuXHRcdFx0XHRxNC5iID0gbWNkICsgKGQgLSBtY2QpIC8gNDtcblx0XHRcdFx0cTMuYyA9IHE0LmEgPSAocTMuYiArIHE0LmIpIC8gMjtcblx0XHRcdFx0cmV0dXJuIFtxMSwgcTIsIHEzLCBxNF07XG5cdFx0XHR9LFxuXHRcdFx0X2NhbGN1bGF0ZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbihhLCBjdXJ2aW5lc3MsIHF1YWQsIGJhc2ljLCBjb3JyZWxhdGUpIHtcblx0XHRcdFx0dmFyIGwgPSBhLmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0aWkgPSAwLFxuXHRcdFx0XHRcdGNwMSA9IGFbMF0uYSxcblx0XHRcdFx0XHRpLCBwMSwgcDIsIHAzLCBzZWcsIG0xLCBtMiwgbW0sIGNwMiwgcWIsIHIxLCByMiwgdGw7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRzZWcgPSBhW2lpXTtcblx0XHRcdFx0XHRwMSA9IHNlZy5hO1xuXHRcdFx0XHRcdHAyID0gc2VnLmQ7XG5cdFx0XHRcdFx0cDMgPSBhW2lpKzFdLmQ7XG5cblx0XHRcdFx0XHRpZiAoY29ycmVsYXRlKSB7XG5cdFx0XHRcdFx0XHRyMSA9IF9yMVtpXTtcblx0XHRcdFx0XHRcdHIyID0gX3IyW2ldO1xuXHRcdFx0XHRcdFx0dGwgPSAoKHIyICsgcjEpICogY3VydmluZXNzICogMC4yNSkgLyAoYmFzaWMgPyAwLjUgOiBfcjNbaV0gfHwgMC41KTtcblx0XHRcdFx0XHRcdG0xID0gcDIgLSAocDIgLSBwMSkgKiAoYmFzaWMgPyBjdXJ2aW5lc3MgKiAwLjUgOiAocjEgIT09IDAgPyB0bCAvIHIxIDogMCkpO1xuXHRcdFx0XHRcdFx0bTIgPSBwMiArIChwMyAtIHAyKSAqIChiYXNpYyA/IGN1cnZpbmVzcyAqIDAuNSA6IChyMiAhPT0gMCA/IHRsIC8gcjIgOiAwKSk7XG5cdFx0XHRcdFx0XHRtbSA9IHAyIC0gKG0xICsgKCgobTIgLSBtMSkgKiAoKHIxICogMyAvIChyMSArIHIyKSkgKyAwLjUpIC8gNCkgfHwgMCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtMSA9IHAyIC0gKHAyIC0gcDEpICogY3VydmluZXNzICogMC41O1xuXHRcdFx0XHRcdFx0bTIgPSBwMiArIChwMyAtIHAyKSAqIGN1cnZpbmVzcyAqIDAuNTtcblx0XHRcdFx0XHRcdG1tID0gcDIgLSAobTEgKyBtMikgLyAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtMSArPSBtbTtcblx0XHRcdFx0XHRtMiArPSBtbTtcblxuXHRcdFx0XHRcdHNlZy5jID0gY3AyID0gbTE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IDApIHtcblx0XHRcdFx0XHRcdHNlZy5iID0gY3AxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWcuYiA9IGNwMSA9IHNlZy5hICsgKHNlZy5jIC0gc2VnLmEpICogMC42OyAvL2luc3RlYWQgb2YgcGxhY2luZyBiIG9uIGEgZXhhY3RseSwgd2UgbW92ZSBpdCBpbmxpbmUgd2l0aCBjIHNvIHRoYXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIGFuIGVhc2UgbGlrZSBCYWNrLmVhc2VJbiBvciBFbGFzdGljLmVhc2VJbiB3aGljaCBnb2VzIEJFWU9ORCB0aGUgYmVnaW5uaW5nLCBpdCB3aWxsIGRvIHNvIHNtb290aGx5LlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNlZy5kYSA9IHAyIC0gcDE7XG5cdFx0XHRcdFx0c2VnLmNhID0gY3AyIC0gcDE7XG5cdFx0XHRcdFx0c2VnLmJhID0gY3AxIC0gcDE7XG5cblx0XHRcdFx0XHRpZiAocXVhZCkge1xuXHRcdFx0XHRcdFx0cWIgPSBjdWJpY1RvUXVhZHJhdGljKHAxLCBjcDEsIGNwMiwgcDIpO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaWksIDEsIHFiWzBdLCBxYlsxXSwgcWJbMl0sIHFiWzNdKTtcblx0XHRcdFx0XHRcdGlpICs9IDQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlpKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3AxID0gbTI7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VnID0gYVtpaV07XG5cdFx0XHRcdHNlZy5iID0gY3AxO1xuXHRcdFx0XHRzZWcuYyA9IGNwMSArIChzZWcuZCAtIGNwMSkgKiAwLjQ7IC8vaW5zdGVhZCBvZiBwbGFjaW5nIGMgb24gZCBleGFjdGx5LCB3ZSBtb3ZlIGl0IGlubGluZSB3aXRoIGIgc28gdGhhdCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgYW4gZWFzZSBsaWtlIEJhY2suZWFzZU91dCBvciBFbGFzdGljLmVhc2VPdXQgd2hpY2ggZ29lcyBCRVlPTkQgdGhlIGVuZCwgaXQgd2lsbCBkbyBzbyBzbW9vdGhseS5cblx0XHRcdFx0c2VnLmRhID0gc2VnLmQgLSBzZWcuYTtcblx0XHRcdFx0c2VnLmNhID0gc2VnLmMgLSBzZWcuYTtcblx0XHRcdFx0c2VnLmJhID0gY3AxIC0gc2VnLmE7XG5cdFx0XHRcdGlmIChxdWFkKSB7XG5cdFx0XHRcdFx0cWIgPSBjdWJpY1RvUXVhZHJhdGljKHNlZy5hLCBjcDEsIHNlZy5jLCBzZWcuZCk7XG5cdFx0XHRcdFx0YS5zcGxpY2UoaWksIDEsIHFiWzBdLCBxYlsxXSwgcWJbMl0sIHFiWzNdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9wYXJzZUFuY2hvcnMgPSBmdW5jdGlvbih2YWx1ZXMsIHAsIGNvcnJlbGF0ZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGwsIGksIHAxLCBwMiwgcDMsIHRtcDtcblx0XHRcdFx0aWYgKHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdFx0aSA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKCAodG1wID0gdmFsdWVzW2ldW3BdKSApID09PSBcInN0cmluZ1wiKSBpZiAodG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzW2ldW3BdID0gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSk7IC8vYWNjb21tb2RhdGUgcmVsYXRpdmUgdmFsdWVzLiBEbyBpdCBpbmxpbmUgaW5zdGVhZCBvZiBicmVha2luZyBpdCBvdXQgaW50byBhIGZ1bmN0aW9uIGZvciBzcGVlZCByZWFzb25zXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoIC0gMjtcblx0XHRcdFx0aWYgKGwgPCAwKSB7XG5cdFx0XHRcdFx0YVswXSA9IG5ldyBTZWdtZW50KHZhbHVlc1swXVtwXSwgMCwgMCwgdmFsdWVzWyhsIDwgLTEpID8gMCA6IDFdW3BdKTtcblx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cDEgPSB2YWx1ZXNbaV1bcF07XG5cdFx0XHRcdFx0cDIgPSB2YWx1ZXNbaSsxXVtwXTtcblx0XHRcdFx0XHRhW2ldID0gbmV3IFNlZ21lbnQocDEsIDAsIDAsIHAyKTtcblx0XHRcdFx0XHRpZiAoY29ycmVsYXRlKSB7XG5cdFx0XHRcdFx0XHRwMyA9IHZhbHVlc1tpKzJdW3BdO1xuXHRcdFx0XHRcdFx0X3IxW2ldID0gKF9yMVtpXSB8fCAwKSArIChwMiAtIHAxKSAqIChwMiAtIHAxKTtcblx0XHRcdFx0XHRcdF9yMltpXSA9IChfcjJbaV0gfHwgMCkgKyAocDMgLSBwMikgKiAocDMgLSBwMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0gPSBuZXcgU2VnbWVudCh2YWx1ZXNbaV1bcF0sIDAsIDAsIHZhbHVlc1tpKzFdW3BdKTtcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LFxuXHRcdFx0YmV6aWVyVGhyb3VnaCA9IGZ1bmN0aW9uKHZhbHVlcywgY3VydmluZXNzLCBxdWFkcmF0aWMsIGJhc2ljLCBjb3JyZWxhdGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dmFyIG9iaiA9IHt9LFxuXHRcdFx0XHRcdHByb3BzID0gW10sXG5cdFx0XHRcdFx0Zmlyc3QgPSBwcmVwZW5kIHx8IHZhbHVlc1swXSxcblx0XHRcdFx0XHRpLCBwLCBhLCBqLCByLCBsLCBzZWFtbGVzcywgbGFzdDtcblx0XHRcdFx0Y29ycmVsYXRlID0gKHR5cGVvZihjb3JyZWxhdGUpID09PSBcInN0cmluZ1wiKSA/IFwiLFwiK2NvcnJlbGF0ZStcIixcIiA6IF9jb3JyZWxhdGU7XG5cdFx0XHRcdGlmIChjdXJ2aW5lc3MgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGN1cnZpbmVzcyA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIHZhbHVlc1swXSkge1xuXHRcdFx0XHRcdHByb3BzLnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jaGVjayB0byBzZWUgaWYgdGhlIGxhc3QgYW5kIGZpcnN0IHZhbHVlcyBhcmUgaWRlbnRpY2FsICh3ZWxsLCB3aXRoaW4gMC4wNSkuIElmIHNvLCBtYWtlIHNlYW1sZXNzIGJ5IGFwcGVuZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQgdG8gdGhlIHZlcnkgZW5kIG9mIHRoZSB2YWx1ZXMgYXJyYXkgYW5kIHRoZSAybmQtdG8tbGFzdCBlbGVtZW50IHRvIHRoZSB2ZXJ5IGJlZ2lubmluZyAod2UnbGwgcmVtb3ZlIHRob3NlIHNlZ21lbnRzIGxhdGVyKVxuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRsYXN0ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRzZWFtbGVzcyA9IHRydWU7XG5cdFx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhmaXJzdFtwXSAtIGxhc3RbcF0pID4gMC4wNSkgeyAvL2J1aWxkIGluIGEgdG9sZXJhbmNlIG9mICsvLTAuMDUgdG8gYWNjb21tb2RhdGUgcm91bmRpbmcgZXJyb3JzLiBGb3IgZXhhbXBsZSwgaWYgeW91IHNldCBhbiBvYmplY3QncyBwb3NpdGlvbiB0byA0Ljk0NSwgRmxhc2ggd2lsbCBtYWtlIGl0IDQuOVxuXHRcdFx0XHRcdFx0XHRzZWFtbGVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KCk7IC8vZHVwbGljYXRlIHRoZSBhcnJheSB0byBhdm9pZCBjb250YW1pbmF0aW5nIHRoZSBvcmlnaW5hbCB3aGljaCB0aGUgdXNlciBtYXkgYmUgcmV1c2luZyBmb3Igb3RoZXIgdHdlZW5zXG5cdFx0XHRcdFx0XHRpZiAocHJlcGVuZCkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMudW5zaGlmdChwcmVwZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlc1sxXSk7XG5cdFx0XHRcdFx0XHRwcmVwZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAzXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X3IxLmxlbmd0aCA9IF9yMi5sZW5ndGggPSBfcjMubGVuZ3RoID0gMDtcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdF9jb3JQcm9wc1twXSA9IChjb3JyZWxhdGUuaW5kZXhPZihcIixcIitwK1wiLFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdG9ialtwXSA9IF9wYXJzZUFuY2hvcnModmFsdWVzLCBwLCBfY29yUHJvcHNbcF0sIHByZXBlbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBfcjEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRfcjFbaV0gPSBNYXRoLnNxcnQoX3IxW2ldKTtcblx0XHRcdFx0XHRfcjJbaV0gPSBNYXRoLnNxcnQoX3IyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWJhc2ljKSB7XG5cdFx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChfY29yUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0YSA9IG9ialtwcm9wc1tpXV07XG5cdFx0XHRcdFx0XHRcdGwgPSBhLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRyID0gYVtqKzFdLmRhIC8gX3IyW2pdICsgYVtqXS5kYSAvIF9yMVtqXTtcblx0XHRcdFx0XHRcdFx0XHRfcjNbal0gPSAoX3IzW2pdIHx8IDApICsgciAqIHI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSA9IF9yMy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRfcjNbaV0gPSBNYXRoLnNxcnQoX3IzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0aiA9IHF1YWRyYXRpYyA/IDQgOiAxO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0YSA9IG9ialtwXTtcblx0XHRcdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyhhLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIF9jb3JQcm9wc1twXSk7IC8vdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCBfcGFyc2VBbmNob3JzKCkgYW5kIF9zZXRTZWdtZW50UmF0aW9zKCkgcmFuIGZpcnN0IHNvIHRoYXQgX3IxLCBfcjIsIGFuZCBfcjMgdmFsdWVzIGFyZSBwb3B1bGF0ZWQgZm9yIGFsbCBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0aWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZSgwLCBqKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGEubGVuZ3RoIC0gaiwgaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQmV6aWVyRGF0YSA9IGZ1bmN0aW9uKHZhbHVlcywgdHlwZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR0eXBlID0gdHlwZSB8fCBcInNvZnRcIjtcblx0XHRcdFx0dmFyIG9iaiA9IHt9LFxuXHRcdFx0XHRcdGluYyA9ICh0eXBlID09PSBcImN1YmljXCIpID8gMyA6IDIsXG5cdFx0XHRcdFx0c29mdCA9ICh0eXBlID09PSBcInNvZnRcIiksXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRhLCBiLCBjLCBkLCBjdXIsIGksIGosIGwsIHAsIGNudCwgdG1wO1xuXHRcdFx0XHRpZiAoc29mdCAmJiBwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YWx1ZXMgPT0gbnVsbCB8fCB2YWx1ZXMubGVuZ3RoIDwgaW5jICsgMSkgeyB0aHJvdyBcImludmFsaWQgQmV6aWVyIGRhdGFcIjsgfVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0b2JqW3BdID0gY3VyID0gW107XG5cdFx0XHRcdFx0Y250ID0gMDtcblx0XHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRhID0gKHByZXBlbmQgPT0gbnVsbCkgPyB2YWx1ZXNbal1bcF0gOiAodHlwZW9mKCAodG1wID0gdmFsdWVzW2pdW3BdKSApID09PSBcInN0cmluZ1wiICYmIHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpIDogTnVtYmVyKHRtcCk7XG5cdFx0XHRcdFx0XHRpZiAoc29mdCkgaWYgKGogPiAxKSBpZiAoaiA8IGwgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSAoYSArIGN1cltjbnQtMl0pIC8gMjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSBhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsID0gY250IC0gaW5jICsgMTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqICs9IGluYykge1xuXHRcdFx0XHRcdFx0YSA9IGN1cltqXTtcblx0XHRcdFx0XHRcdGIgPSBjdXJbaisxXTtcblx0XHRcdFx0XHRcdGMgPSBjdXJbaisyXTtcblx0XHRcdFx0XHRcdGQgPSAoaW5jID09PSAyKSA/IDAgOiBjdXJbaiszXTtcblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSB0bXAgPSAoaW5jID09PSAzKSA/IG5ldyBTZWdtZW50KGEsIGIsIGMsIGQpIDogbmV3IFNlZ21lbnQoYSwgKDIgKiBiICsgYSkgLyAzLCAoMiAqIGIgKyBjKSAvIDMsIGMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXIubGVuZ3RoID0gY250O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X2FkZEN1YmljTGVuZ3RocyA9IGZ1bmN0aW9uKGEsIHN0ZXBzLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHZhciBpbmMgPSAxIC8gcmVzb2x1dGlvbixcblx0XHRcdFx0XHRqID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0ZCwgZDEsIHMsIGRhLCBjYSwgYmEsIHAsIGksIGludiwgYmV6LCBpbmRleDtcblx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0YmV6ID0gYVtqXTtcblx0XHRcdFx0XHRzID0gYmV6LmE7XG5cdFx0XHRcdFx0ZGEgPSBiZXouZCAtIHM7XG5cdFx0XHRcdFx0Y2EgPSBiZXouYyAtIHM7XG5cdFx0XHRcdFx0YmEgPSBiZXouYiAtIHM7XG5cdFx0XHRcdFx0ZCA9IGQxID0gMDtcblx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDw9IHJlc29sdXRpb247IGkrKykge1xuXHRcdFx0XHRcdFx0cCA9IGluYyAqIGk7XG5cdFx0XHRcdFx0XHRpbnYgPSAxIC0gcDtcblx0XHRcdFx0XHRcdGQgPSBkMSAtIChkMSA9IChwICogcCAqIGRhICsgMyAqIGludiAqIChwICogY2EgKyBpbnYgKiBiYSkpICogcCk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGogKiByZXNvbHV0aW9uICsgaSAtIDE7XG5cdFx0XHRcdFx0XHRzdGVwc1tpbmRleF0gPSAoc3RlcHNbaW5kZXhdIHx8IDApICsgZCAqIGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlTGVuZ3RoRGF0YSA9IGZ1bmN0aW9uKG9iaiwgcmVzb2x1dGlvbikge1xuXHRcdFx0XHRyZXNvbHV0aW9uID0gcmVzb2x1dGlvbiA+PiAwIHx8IDY7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bGVuZ3RocyA9IFtdLFxuXHRcdFx0XHRcdGQgPSAwLFxuXHRcdFx0XHRcdHRvdGFsID0gMCxcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSByZXNvbHV0aW9uIC0gMSxcblx0XHRcdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0XHRcdGN1ckxTID0gW10sIC8vY3VycmVudCBsZW5ndGggc2VnbWVudHMgYXJyYXlcblx0XHRcdFx0XHRwLCBpLCBsLCBpbmRleDtcblx0XHRcdFx0Zm9yIChwIGluIG9iaikge1xuXHRcdFx0XHRcdF9hZGRDdWJpY0xlbmd0aHMob2JqW3BdLCBhLCByZXNvbHV0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gYS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRkICs9IE1hdGguc3FydChhW2ldKTtcblx0XHRcdFx0XHRpbmRleCA9IGkgJSByZXNvbHV0aW9uO1xuXHRcdFx0XHRcdGN1ckxTW2luZGV4XSA9IGQ7XG5cdFx0XHRcdFx0aWYgKGluZGV4ID09PSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdHRvdGFsICs9IGQ7XG5cdFx0XHRcdFx0XHRpbmRleCA9IChpIC8gcmVzb2x1dGlvbikgPj4gMDtcblx0XHRcdFx0XHRcdHNlZ21lbnRzW2luZGV4XSA9IGN1ckxTO1xuXHRcdFx0XHRcdFx0bGVuZ3Roc1tpbmRleF0gPSB0b3RhbDtcblx0XHRcdFx0XHRcdGQgPSAwO1xuXHRcdFx0XHRcdFx0Y3VyTFMgPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtsZW5ndGg6dG90YWwsIGxlbmd0aHM6bGVuZ3Rocywgc2VnbWVudHM6c2VnbWVudHN9O1xuXHRcdFx0fSxcblxuXG5cblx0XHRcdEJlemllclBsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0XHRcdHByb3BOYW1lOiBcImJlemllclwiLFxuXHRcdFx0XHRcdHByaW9yaXR5OiAtMSxcblx0XHRcdFx0XHR2ZXJzaW9uOiBcIjEuMy40XCIsXG5cdFx0XHRcdFx0QVBJOiAyLFxuXHRcdFx0XHRcdGdsb2JhbDp0cnVlLFxuXG5cdFx0XHRcdFx0Ly9nZXRzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgdHdlZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmICh2YXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0dmFycyA9IHt2YWx1ZXM6dmFyc307XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9mdW5jID0ge307XG5cdFx0XHRcdFx0XHR0aGlzLl9yb3VuZCA9IHt9O1xuXHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMgPSBbXTtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWVSZXMgPSAodmFycy50aW1lUmVzb2x1dGlvbiA9PSBudWxsKSA/IDYgOiBwYXJzZUludCh2YXJzLnRpbWVSZXNvbHV0aW9uLCAxMCk7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFycy52YWx1ZXMgfHwgW10sXG5cdFx0XHRcdFx0XHRcdGZpcnN0ID0ge30sXG5cdFx0XHRcdFx0XHRcdHNlY29uZCA9IHZhbHVlc1swXSxcblx0XHRcdFx0XHRcdFx0YXV0b1JvdGF0ZSA9IHZhcnMuYXV0b1JvdGF0ZSB8fCB0d2Vlbi52YXJzLm9yaWVudFRvQmV6aWVyLFxuXHRcdFx0XHRcdFx0XHRwLCBpc0Z1bmMsIGksIGosIHByZXBlbmQ7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID8gKGF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkgPyBhdXRvUm90YXRlIDogW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsKChhdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIoYXV0b1JvdGF0ZSkgfHwgMCldXSA6IG51bGw7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4gc2Vjb25kKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdGlzRnVuYyA9IHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIik7XG5cdFx0XHRcdFx0XHRcdGZpcnN0W3BdID0gKCFpc0Z1bmMpID8gcGFyc2VGbG9hdCh0YXJnZXRbcF0pIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXByZXBlbmQpIGlmIChmaXJzdFtwXSAhPT0gdmFsdWVzWzBdW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlcGVuZCA9IGZpcnN0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9iZXppZXJzID0gKHZhcnMudHlwZSAhPT0gXCJjdWJpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJxdWFkcmF0aWNcIiAmJiB2YXJzLnR5cGUgIT09IFwic29mdFwiKSA/IGJlemllclRocm91Z2godmFsdWVzLCBpc05hTih2YXJzLmN1cnZpbmVzcykgPyAxIDogdmFycy5jdXJ2aW5lc3MsIGZhbHNlLCAodmFycy50eXBlID09PSBcInRocnVCYXNpY1wiKSwgdmFycy5jb3JyZWxhdGUsIHByZXBlbmQpIDogX3BhcnNlQmV6aWVyRGF0YSh2YWx1ZXMsIHZhcnMudHlwZSwgZmlyc3QpO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2VnQ291bnQgPSB0aGlzLl9iZXppZXJzW3BdLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxkID0gX3BhcnNlTGVuZ3RoRGF0YSh0aGlzLl9iZXppZXJzLCB0aGlzLl90aW1lUmVzKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RoID0gbGQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGhzID0gbGQubGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHMgPSBsZC5zZWdtZW50cztcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSB0aGlzLl9saSA9IHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IHRoaXMuX2xlbmd0aHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IHRoaXMuX2N1clNlZ1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJlYyA9IDEgLyB0aGlzLl9jdXJTZWcubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGF1dG9Sb3RhdGUgPSB0aGlzLl9hdXRvUm90YXRlKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zID0gW107XG5cdFx0XHRcdFx0XHRcdGlmICghKGF1dG9Sb3RhdGVbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA9IFthdXRvUm90YXRlXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpID0gYXV0b1JvdGF0ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0gOiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXSA9IHRoaXMuX2Z1bmNbcF0gPyB0aGlzLl9mdW5jW3BdLmNhbGwodGhpcy5fdGFyZ2V0KSA6IHRoaXMuX3RhcmdldFtwXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRSYXRpbyA9IHR3ZWVuLnZhcnMucnVuQmFja3dhcmRzID8gMSA6IDA7IC8vd2UgZGV0ZXJtaW5lIHRoZSBzdGFydGluZyByYXRpbyB3aGVuIHRoZSB0d2VlbiBpbml0cyB3aGljaCBpcyBhbHdheXMgMCB1bmxlc3MgdGhlIHR3ZWVuIGhhcyBydW5CYWNrd2FyZHM6dHJ1ZSAoaW5kaWNhdGluZyBpdCdzIGEgZnJvbSgpIHR3ZWVuKSBpbiB3aGljaCBjYXNlIGl0J3MgMS5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnQ291bnQsXG5cdFx0XHRcdFx0XHRcdGZ1bmMgPSB0aGlzLl9mdW5jLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG5cdFx0XHRcdFx0XHRcdG5vdFN0YXJ0ID0gKHYgIT09IHRoaXMuX3N0YXJ0UmF0aW8pLFxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCwgaW52LCBpLCBwLCBiLCB0LCB2YWwsIGwsIGxlbmd0aHMsIGN1clNlZztcblx0XHRcdFx0XHRcdGlmICghdGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9ICh2IDwgMCkgPyAwIDogKHYgPj0gMSkgPyBzZWdtZW50cyAtIDEgOiAoc2VnbWVudHMgKiB2KSA+PiAwO1xuXHRcdFx0XHRcdFx0XHR0ID0gKHYgLSAoY3VySW5kZXggKiAoMSAvIHNlZ21lbnRzKSkpICogc2VnbWVudHM7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGhzID0gdGhpcy5fbGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0Y3VyU2VnID0gdGhpcy5fY3VyU2VnO1xuXHRcdFx0XHRcdFx0XHR2ICo9IHRoaXMuX2xlbmd0aDtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX2xpO1xuXHRcdFx0XHRcdFx0XHQvL2ZpbmQgdGhlIGFwcHJvcHJpYXRlIHNlZ21lbnQgKGlmIHRoZSBjdXJyZW50bHkgY2FjaGVkIG9uZSBpc24ndCBjb3JyZWN0KVxuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX2wyICYmIGkgPCBzZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gc2VnbWVudHMgLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fbDIgPSBsZW5ndGhzWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IGxlbmd0aHNbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbKHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwKV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX2wxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9sMSA9IGxlbmd0aHNbLS1pXSkgPj0gdikgeyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX2wxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSBsZW5ndGhzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1sodGhpcy5fc2kgPSBjdXJTZWcubGVuZ3RoIC0gMSkgLSAxXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW3RoaXMuX3NpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdC8vbm93IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHN1Yi1zZWdtZW50ICh3ZSBzcGxpdCBpdCBpbnRvIHRoZSBudW1iZXIgb2YgcGllY2VzIHRoYXQgd2FzIGRlZmluZWQgYnkgXCJwcmVjaXNpb25cIiBhbmQgbWVhc3VyZWQgZWFjaCBvbmUpXG5cdFx0XHRcdFx0XHRcdHYgLT0gdGhpcy5fbDE7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9zaTtcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9zMiAmJiBpIDwgY3VyU2VnLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gY3VyU2VnLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9zMiA9IGN1clNlZ1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX3MxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9zMSA9IGN1clNlZ1stLWldKSA+PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX3MxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHQgPSAoaSArICh2IC0gdGhpcy5fczEpIC8gKHRoaXMuX3MyIC0gdGhpcy5fczEpKSAqIHRoaXMuX3ByZWM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbnYgPSAxIC0gdDtcblxuXHRcdFx0XHRcdFx0aSA9IHRoaXMuX3Byb3BzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fcHJvcHNbaV07XG5cdFx0XHRcdFx0XHRcdGIgPSB0aGlzLl9iZXppZXJzW3BdW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0dmFsID0gKHQgKiB0ICogYi5kYSArIDMgKiBpbnYgKiAodCAqIGIuY2EgKyBpbnYgKiBiLmJhKSkgKiB0ICsgYi5hO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fcm91bmRbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0odmFsKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2F1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyID0gdGhpcy5fYXV0b1JvdGF0ZSxcblx0XHRcdFx0XHRcdFx0XHRiMiwgeDEsIHkxLCB4MiwgeTIsIGFkZCwgY29udjtcblx0XHRcdFx0XHRcdFx0aSA9IGFyLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGFyW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdGFkZCA9IGFyW2ldWzNdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0Y29udiA9IChhcltpXVs0XSA9PT0gdHJ1ZSkgPyAxIDogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMF1dO1xuXHRcdFx0XHRcdFx0XHRcdGIyID0gdGhpcy5fYmV6aWVyc1thcltpXVsxXV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoYiAmJiBiMikgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGdvdCBvdmVyd3JpdHRlbi5cblx0XHRcdFx0XHRcdFx0XHRcdGIgPSBiW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdGIyID0gYjJbY3VySW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR4MSA9IGIuYSArIChiLmIgLSBiLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyID0gYi5iICsgKGIuYyAtIGIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDEgKz0gKHgyIC0geDEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyICs9ICgoYi5jICsgKGIuZCAtIGIuYykgKiB0KSAtIHgyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHkxID0gYjIuYSArIChiMi5iIC0gYjIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgPSBiMi5iICsgKGIyLmMgLSBiMi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MSArPSAoeTIgLSB5MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgKz0gKChiMi5jICsgKGIyLmQgLSBiMi5jKSAqIHQpIC0geTIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gbm90U3RhcnQgPyBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogY29udiArIGFkZCA6IHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChmdW5jW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSh2YWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdFx0cCA9IEJlemllclBsdWdpbi5wcm90b3R5cGU7XG5cblxuXHRcdEJlemllclBsdWdpbi5iZXppZXJUaHJvdWdoID0gYmV6aWVyVGhyb3VnaDtcblx0XHRCZXppZXJQbHVnaW4uY3ViaWNUb1F1YWRyYXRpYyA9IGN1YmljVG9RdWFkcmF0aWM7XG5cdFx0QmV6aWVyUGx1Z2luLl9hdXRvQ1NTID0gdHJ1ZTsgLy9pbmRpY2F0ZXMgdGhhdCB0aGlzIHBsdWdpbiBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgXCJjc3NcIiBvYmplY3QgdXNpbmcgdGhlIGF1dG9DU1MgZmVhdHVyZSBvZiBUd2VlbkxpdGVcblx0XHRCZXppZXJQbHVnaW4ucXVhZHJhdGljVG9DdWJpYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcblx0XHRcdHJldHVybiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0fTtcblxuXHRcdEJlemllclBsdWdpbi5fY3NzUmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBDU1NQbHVnaW4gPSBfZ2xvYmFscy5DU1NQbHVnaW47XG5cdFx0XHRpZiAoIUNTU1BsdWdpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgX2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzLFxuXHRcdFx0XHRfcGFyc2VUb1Byb3h5ID0gX2ludGVybmFscy5fcGFyc2VUb1Byb3h5LFxuXHRcdFx0XHRfc2V0UGx1Z2luUmF0aW8gPSBfaW50ZXJuYWxzLl9zZXRQbHVnaW5SYXRpbyxcblx0XHRcdFx0Q1NTUHJvcFR3ZWVuID0gX2ludGVybmFscy5DU1NQcm9wVHdlZW47XG5cdFx0XHRfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJlemllclwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHByb3AsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdGUgPSB7dmFsdWVzOmV9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbiA9IG5ldyBCZXppZXJQbHVnaW4oKTtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGUudmFsdWVzLFxuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRwbHVnaW5WYWx1ZXMgPSBbXSxcblx0XHRcdFx0XHR2ID0ge30sXG5cdFx0XHRcdFx0aSwgcCwgZGF0YTtcblx0XHRcdFx0aWYgKGwgPCAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPD0gbDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IF9wYXJzZVRvUHJveHkodCwgdmFsdWVzW2ldLCBjc3NwLCBwdCwgcGx1Z2luLCAobCAhPT0gaSkpO1xuXHRcdFx0XHRcdHBsdWdpblZhbHVlc1tpXSA9IGRhdGEuZW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiBlKSB7XG5cdFx0XHRcdFx0dltwXSA9IGVbcF07IC8vZHVwbGljYXRlIHRoZSB2YXJzIG9iamVjdCBiZWNhdXNlIHdlIG5lZWQgdG8gYWx0ZXIgc29tZSB0aGluZ3Mgd2hpY2ggd291bGQgY2F1c2UgcHJvYmxlbXMgaWYgdGhlIHVzZXIgcGxhbnMgdG8gcmV1c2UgdGhlIHNhbWUgdmFycyBvYmplY3QgZm9yIGFub3RoZXIgdHdlZW4uXG5cdFx0XHRcdH1cblx0XHRcdFx0di52YWx1ZXMgPSBwbHVnaW5WYWx1ZXM7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBcImJlemllclwiLCAwLCAwLCBkYXRhLnB0LCAyKTtcblx0XHRcdFx0cHQuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0UGx1Z2luUmF0aW87XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgPT09IDApIHtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgJiYgISh2LmF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRpID0gKHYuYXV0b1JvdGF0ZSA9PT0gdHJ1ZSkgPyAwIDogTnVtYmVyKHYuYXV0b1JvdGF0ZSk7XG5cdFx0XHRcdFx0di5hdXRvUm90YXRlID0gKGRhdGEuZW5kLmxlZnQgIT0gbnVsbCkgPyBbW1wibGVmdFwiLFwidG9wXCIsXCJyb3RhdGlvblwiLGksZmFsc2VdXSA6IChkYXRhLmVuZC54ICE9IG51bGwpID8gW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdGlmICghY3NzcC5fdHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRjc3NwLl9lbmFibGVUcmFuc2Zvcm1zKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YS5hdXRvUm90YXRlID0gY3NzcC5fdGFyZ2V0Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbHVnaW4uX29uSW5pdFR3ZWVuKGRhdGEucHJveHksIHYsIGNzc3AuX3R3ZWVuKTtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fX0pO1xuXHRcdH07XG5cblx0XHRwLl9yb3VuZFByb3BzID0gZnVuY3Rpb24obG9va3VwLCB2YWx1ZSkge1xuXHRcdFx0dmFyIG9wID0gdGhpcy5fb3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdGkgPSBvcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFtvcFtpXV0gfHwgbG9va3VwLmJlemllciB8fCBsb29rdXAuYmV6aWVyVGhyb3VnaCkge1xuXHRcdFx0XHRcdHRoaXMuX3JvdW5kW29wW2ldXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBhID0gdGhpcy5fcHJvcHMsXG5cdFx0XHRcdHAsIGk7XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy5fYmV6aWVycykge1xuXHRcdFx0XHRpZiAocCBpbiBsb29rdXApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fYmV6aWVyc1twXTtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fZnVuY1twXTtcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gcCkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9zdXBlci5fa2lsbC5jYWxsKHRoaXMsIGxvb2t1cCk7XG5cdFx0fTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ1NTUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwicGx1Z2lucy5DU1NQbHVnaW5cIiwgW1wicGx1Z2lucy5Ud2VlblBsdWdpblwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihUd2VlblBsdWdpbiwgVHdlZW5MaXRlKSB7XG5cblx0XHQvKiogQGNvbnN0cnVjdG9yICoqL1xuXHRcdHZhciBDU1NQbHVnaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBcImNzc1wiKTtcblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoID0gMDtcblx0XHRcdFx0dGhpcy5zZXRSYXRpbyA9IENTU1BsdWdpbi5wcm90b3R5cGUuc2V0UmF0aW87IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9oYXNQcmlvcml0eSwgLy90dXJucyB0cnVlIHdoZW5ldmVyIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGlzIGNyZWF0ZWQgdGhhdCBoYXMgYSBwcmlvcml0eSBvdGhlciB0aGFuIDAuIFRoaXMgaGVscHMgdXMgZGlzY2VybiB3aGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgc3BlbmQgdGhlIHRpbWUgb3JnYW5pemluZyB0aGUgbGlua2VkIGxpc3Qgb3Igbm90IGFmdGVyIGEgQ1NTUGx1Z2luJ3MgX29uSW5pdFR3ZWVuKCkgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHRcdF9zdWZmaXhNYXAsIC8vd2Ugc2V0IHRoaXMgaW4gX29uSW5pdFR3ZWVuKCkgZWFjaCB0aW1lIGFzIGEgd2F5IHRvIGhhdmUgYSBwZXJzaXN0ZW50IHZhcmlhYmxlIHdlIGNhbiB1c2UgaW4gb3RoZXIgbWV0aG9kcyBsaWtlIF9wYXJzZSgpIHdpdGhvdXQgaGF2aW5nIHRvIHBhc3MgaXQgYXJvdW5kIGFzIGEgcGFyYW1ldGVyIGFuZCB3ZSBrZWVwIF9wYXJzZSgpIGRlY291cGxlZCBmcm9tIGEgcGFydGljdWxhciBDU1NQbHVnaW4gaW5zdGFuY2Vcblx0XHRcdF9jcywgLy9jb21wdXRlZCBzdHlsZSAod2Ugc3RvcmUgdGhpcyBpbiBhIHNoYXJlZCB2YXJpYWJsZSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIG1ha2UgbWluaWZpY2F0aW9uIHRpZ2h0ZXJcblx0XHRcdF9vdmVyd3JpdGVQcm9wcywgLy9hbGlhcyB0byB0aGUgY3VycmVudGx5IGluc3RhbnRpYXRpbmcgQ1NTUGx1Z2luJ3MgX292ZXJ3cml0ZVByb3BzIGFycmF5LiBXZSB1c2UgdGhpcyBjbG9zdXJlIGluIG9yZGVyIHRvIGF2b2lkIGhhdmluZyB0byBwYXNzIGEgcmVmZXJlbmNlIGFyb3VuZCBmcm9tIG1ldGhvZCB0byBtZXRob2QgYW5kIGFpZCBpbiBtaW5pZmljYXRpb24uXG5cdFx0XHRfc3BlY2lhbFByb3BzID0ge30sXG5cdFx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihcImNzc1wiKTtcblxuXHRcdHAuY29uc3RydWN0b3IgPSBDU1NQbHVnaW47XG5cdFx0Q1NTUGx1Z2luLnZlcnNpb24gPSBcIjEuMTYuMFwiO1xuXHRcdENTU1BsdWdpbi5BUEkgPSAyO1xuXHRcdENTU1BsdWdpbi5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUgPSAwO1xuXHRcdENTU1BsdWdpbi5kZWZhdWx0U2tld1R5cGUgPSBcImNvbXBlbnNhdGVkXCI7XG5cdFx0cCA9IFwicHhcIjsgLy93ZSdsbCByZXVzZSB0aGUgXCJwXCIgdmFyaWFibGUgdG8ga2VlcCBmaWxlIHNpemUgZG93blxuXHRcdENTU1BsdWdpbi5zdWZmaXhNYXAgPSB7dG9wOnAsIHJpZ2h0OnAsIGJvdHRvbTpwLCBsZWZ0OnAsIHdpZHRoOnAsIGhlaWdodDpwLCBmb250U2l6ZTpwLCBwYWRkaW5nOnAsIG1hcmdpbjpwLCBwZXJzcGVjdGl2ZTpwLCBsaW5lSGVpZ2h0OlwiXCJ9O1xuXG5cblx0XHR2YXIgX251bUV4cCA9IC8oPzpcXGR8XFwtXFxkfFxcLlxcZHxcXC1cXC5cXGQpKy9nLFxuXHRcdFx0X3JlbE51bUV4cCA9IC8oPzpcXGR8XFwtXFxkfFxcLlxcZHxcXC1cXC5cXGR8XFwrPVxcZHxcXC09XFxkfFxcKz0uXFxkfFxcLT1cXC5cXGQpKy9nLFxuXHRcdFx0X3ZhbHVlc0V4cCA9IC8oPzpcXCs9fFxcLT18XFwtfFxcYilbXFxkXFwtXFwuXStbYS16QS1aMC05XSooPzolfFxcYikvZ2ksIC8vZmluZHMgYWxsIHRoZSB2YWx1ZXMgdGhhdCBiZWdpbiB3aXRoIG51bWJlcnMgb3IgKz0gb3IgLT0gYW5kIHRoZW4gYSBudW1iZXIuIEluY2x1ZGVzIHN1ZmZpeGVzLiBXZSB1c2UgdGhpcyB0byBzcGxpdCBjb21wbGV4IHZhbHVlcyBhcGFydCBsaWtlIFwiMXB4IDVweCAyMHB4IHJnYigyNTUsMTAyLDUxKVwiXG5cdFx0XHRfTmFORXhwID0gLyg/IVsrLV0/XFxkKlxcLj9cXGQrfFsrLV18ZVsrLV1cXGQrKVteMC05XS9nLCAvL2Fsc28gYWxsb3dzIHNjaWVudGlmaWMgbm90YXRpb24gYW5kIGRvZXNuJ3Qga2lsbCB0aGUgbGVhZGluZyAtLysgaW4gLT0gYW5kICs9XG5cdFx0XHRfc3VmZml4RXhwID0gLyg/OlxcZHxcXC18XFwrfD18I3xcXC4pKi9nLFxuXHRcdFx0X29wYWNpdHlFeHAgPSAvb3BhY2l0eSAqPSAqKFteKV0qKS9pLFxuXHRcdFx0X29wYWNpdHlWYWxFeHAgPSAvb3BhY2l0eTooW147XSopL2ksXG5cdFx0XHRfYWxwaGFGaWx0ZXJFeHAgPSAvYWxwaGFcXChvcGFjaXR5ICo9Lis/XFwpL2ksXG5cdFx0XHRfcmdiaHNsRXhwID0gL14ocmdifGhzbCkvLFxuXHRcdFx0X2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuXHRcdFx0X2NhbWVsRXhwID0gLy0oW2Etel0pL2dpLFxuXHRcdFx0X3VybEV4cCA9IC8oXig/OnVybFxcKFxcXCJ8dXJsXFwoKSl8KD86KFxcXCJcXCkpJHxcXCkkKS9naSwgLy9mb3IgcHVsbGluZyBvdXQgdXJscyBmcm9tIHVybCguLi4pIG9yIHVybChcIi4uLlwiKSBzdHJpbmdzIChzb21lIGJyb3dzZXJzIHdyYXAgdXJscyBpbiBxdW90ZXMsIHNvbWUgZG9uJ3Qgd2hlbiByZXBvcnRpbmcgdGhpbmdzIGxpa2UgYmFja2dyb3VuZEltYWdlKVxuXHRcdFx0X2NhbWVsRnVuYyA9IGZ1bmN0aW9uKHMsIGcpIHsgcmV0dXJuIGcudG9VcHBlckNhc2UoKTsgfSxcblx0XHRcdF9ob3JpekV4cCA9IC8oPzpMZWZ0fFJpZ2h0fFdpZHRoKS9pLFxuXHRcdFx0X2llR2V0TWF0cml4RXhwID0gLyhNMTF8TTEyfE0yMXxNMjIpPVtcXGRcXC1cXC5lXSsvZ2ksXG5cdFx0XHRfaWVTZXRNYXRyaXhFeHAgPSAvcHJvZ2lkXFw6RFhJbWFnZVRyYW5zZm9ybVxcLk1pY3Jvc29mdFxcLk1hdHJpeFxcKC4rP1xcKS9pLFxuXHRcdFx0X2NvbW1hc091dHNpZGVQYXJlbkV4cCA9IC8sKD89W15cXCldKig/OlxcKHwkKSkvZ2ksIC8vZmluZHMgYW55IGNvbW1hcyB0aGF0IGFyZSBub3Qgd2l0aGluIHBhcmVudGhlc2lzXG5cdFx0XHRfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfZm9yY2VQVCA9IHt9LFxuXHRcdFx0X2RvYyA9IGRvY3VtZW50LFxuXHRcdFx0X2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHJldHVybiBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcblx0XHRcdH0sXG5cdFx0XHRfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdFx0X3RlbXBJbWcgPSBfY3JlYXRlRWxlbWVudChcImltZ1wiKSxcblx0XHRcdF9pbnRlcm5hbHMgPSBDU1NQbHVnaW4uX2ludGVybmFscyA9IHtfc3BlY2lhbFByb3BzOl9zcGVjaWFsUHJvcHN9LCAvL3Byb3ZpZGVzIGEgaG9vayB0byBhIGZldyBpbnRlcm5hbCBtZXRob2RzIHRoYXQgd2UgbmVlZCB0byBhY2Nlc3MgZnJvbSBpbnNpZGUgb3RoZXIgcGx1Z2luc1xuXHRcdFx0X2FnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblx0XHRcdF9hdXRvUm91bmQsXG5cdFx0XHRfcmVxU2FmYXJpRml4LCAvL3dlIHdvbid0IGFwcGx5IHRoZSBTYWZhcmkgdHJhbnNmb3JtIGZpeCB1bnRpbCB3ZSBhY3R1YWxseSBjb21lIGFjcm9zcyBhIHR3ZWVuIHRoYXQgYWZmZWN0cyBhIHRyYW5zZm9ybSBwcm9wZXJ0eSAodG8gbWFpbnRhaW4gYmVzdCBwZXJmb3JtYW5jZSkuXG5cblx0XHRcdF9pc1NhZmFyaSxcblx0XHRcdF9pc0ZpcmVmb3gsIC8vRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgM0QgdHJhbnNmb3JtZWQgZWxlbWVudHMgdG8gcmFuZG9tbHkgZGlzYXBwZWFyIHVubGVzcyBhIHJlcGFpbnQgaXMgZm9yY2VkIGFmdGVyIGVhY2ggdXBkYXRlIG9uIGVhY2ggZWxlbWVudC5cblx0XHRcdF9pc1NhZmFyaUxUNiwgLy9TYWZhcmkgKGFuZCBBbmRyb2lkIDQgd2hpY2ggdXNlcyBhIGZsYXZvciBvZiBTYWZhcmkpIGhhcyBhIGJ1ZyB0aGF0IHByZXZlbnRzIGNoYW5nZXMgdG8gXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgcHJvcGVydGllcyBmcm9tIHJlbmRlcmluZyBwcm9wZXJseSBpZiBjaGFuZ2VkIG9uIHRoZSBzYW1lIGZyYW1lIGFzIGEgdHJhbnNmb3JtIFVOTEVTUyB3ZSBzZXQgdGhlIGVsZW1lbnQncyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgdG8gaGlkZGVuICh3ZWlyZCwgSSBrbm93KS4gRG9pbmcgdGhpcyBmb3IgQW5kcm9pZCAzIGFuZCBlYXJsaWVyIHNlZW1zIHRvIGFjdHVhbGx5IGNhdXNlIG90aGVyIHByb2JsZW1zLCB0aG91Z2ggKGZ1biEpXG5cdFx0XHRfaWVWZXJzLFxuXHRcdFx0X3N1cHBvcnRzT3BhY2l0eSA9IChmdW5jdGlvbigpIHsgLy93ZSBzZXQgX2lzU2FmYXJpLCBfaWVWZXJzLCBfaXNGaXJlZm94LCBhbmQgX3N1cHBvcnRzT3BhY2l0eSBhbGwgaW4gb25lIGZ1bmN0aW9uIGhlcmUgdG8gcmVkdWNlIGZpbGUgc2l6ZSBzbGlnaHRseSwgZXNwZWNpYWxseSBpbiB0aGUgbWluaWZpZWQgdmVyc2lvbi5cblx0XHRcdFx0dmFyIGkgPSBfYWdlbnQuaW5kZXhPZihcIkFuZHJvaWRcIiksXG5cdFx0XHRcdFx0YSA9IF9jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHRcdFx0X2lzU2FmYXJpID0gKF9hZ2VudC5pbmRleE9mKFwiU2FmYXJpXCIpICE9PSAtMSAmJiBfYWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA9PT0gLTEgJiYgKGkgPT09IC0xIHx8IE51bWJlcihfYWdlbnQuc3Vic3RyKGkrOCwgMSkpID4gMykpO1xuXHRcdFx0XHRfaXNTYWZhcmlMVDYgPSAoX2lzU2FmYXJpICYmIChOdW1iZXIoX2FnZW50LnN1YnN0cihfYWdlbnQuaW5kZXhPZihcIlZlcnNpb24vXCIpKzgsIDEpKSA8IDYpKTtcblx0XHRcdFx0X2lzRmlyZWZveCA9IChfYWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgIT09IC0xKTtcblx0XHRcdFx0aWYgKCgvTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pLmV4ZWMoX2FnZW50KSB8fCAoL1RyaWRlbnRcXC8uKnJ2OihbMC05XXsxLH1bXFwuMC05XXswLH0pLykuZXhlYyhfYWdlbnQpKSB7XG5cdFx0XHRcdFx0X2llVmVycyA9IHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnN0eWxlLmNzc1RleHQgPSBcInRvcDoxcHg7b3BhY2l0eTouNTU7XCI7XG5cdFx0XHRcdHJldHVybiAvXjAuNTUvLnRlc3QoYS5zdHlsZS5vcGFjaXR5KTtcblx0XHRcdH0oKSksXG5cdFx0XHRfZ2V0SUVPcGFjaXR5ID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRyZXR1cm4gKF9vcGFjaXR5RXhwLnRlc3QoICgodHlwZW9mKHYpID09PSBcInN0cmluZ1wiKSA/IHYgOiAodi5jdXJyZW50U3R5bGUgPyB2LmN1cnJlbnRTdHlsZS5maWx0ZXIgOiB2LnN0eWxlLmZpbHRlcikgfHwgXCJcIikgKSA/ICggcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgLyAxMDAgKSA6IDEpO1xuXHRcdFx0fSxcblx0XHRcdF9sb2cgPSBmdW5jdGlvbihzKSB7Ly9mb3IgbG9nZ2luZyBtZXNzYWdlcywgYnV0IGluIGEgd2F5IHRoYXQgd29uJ3QgdGhyb3cgZXJyb3JzIGluIG9sZCB2ZXJzaW9ucyBvZiBJRS5cblx0XHRcdFx0aWYgKHdpbmRvdy5jb25zb2xlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cocyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9wcmVmaXhDU1MgPSBcIlwiLCAvL3RoZSBub24tY2FtZWxDYXNlIHZlbmRvciBwcmVmaXggbGlrZSBcIi1vLVwiLCBcIi1tb3otXCIsIFwiLW1zLVwiLCBvciBcIi13ZWJraXQtXCJcblx0XHRcdF9wcmVmaXggPSBcIlwiLCAvL2NhbWVsQ2FzZSB2ZW5kb3IgcHJlZml4IGxpa2UgXCJPXCIsIFwibXNcIiwgXCJXZWJraXRcIiwgb3IgXCJNb3pcIi5cblxuXHRcdFx0Ly8gQHByaXZhdGUgZmVlZCBpbiBhIGNhbWVsQ2FzZSBwcm9wZXJ0eSBuYW1lIGxpa2UgXCJ0cmFuc2Zvcm1cIiBhbmQgaXQgd2lsbCBjaGVjayB0byBzZWUgaWYgaXQgaXMgdmFsaWQgYXMtaXMgb3IgaWYgaXQgbmVlZHMgYSB2ZW5kb3IgcHJlZml4LiBJdCByZXR1cm5zIHRoZSBjb3JyZWN0ZWQgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUgKGkuZS4gXCJXZWJraXRUcmFuc2Zvcm1cIiBvciBcIk1velRyYW5zZm9ybVwiIG9yIFwidHJhbnNmb3JtXCIgb3IgbnVsbCBpZiBubyBzdWNoIHByb3BlcnR5IGlzIGZvdW5kLCBsaWtlIGlmIHRoZSBicm93c2VyIGlzIElFOCBvciBiZWZvcmUsIFwidHJhbnNmb3JtXCIgd29uJ3QgYmUgZm91bmQgYXQgYWxsKVxuXHRcdFx0X2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uKHAsIGUpIHtcblx0XHRcdFx0ZSA9IGUgfHwgX3RlbXBEaXY7XG5cdFx0XHRcdHZhciBzID0gZS5zdHlsZSxcblx0XHRcdFx0XHRhLCBpO1xuXHRcdFx0XHRpZiAoc1twXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cCA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKTtcblx0XHRcdFx0YSA9IFtcIk9cIixcIk1velwiLFwibXNcIixcIk1zXCIsXCJXZWJraXRcIl07XG5cdFx0XHRcdGkgPSA1O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEgJiYgc1thW2ldK3BdID09PSB1bmRlZmluZWQpIHsgfVxuXHRcdFx0XHRpZiAoaSA+PSAwKSB7XG5cdFx0XHRcdFx0X3ByZWZpeCA9IChpID09PSAzKSA/IFwibXNcIiA6IGFbaV07XG5cdFx0XHRcdFx0X3ByZWZpeENTUyA9IFwiLVwiICsgX3ByZWZpeC50b0xvd2VyQ2FzZSgpICsgXCItXCI7XG5cdFx0XHRcdFx0cmV0dXJuIF9wcmVmaXggKyBwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldENvbXB1dGVkU3R5bGUgPSBfZG9jLmRlZmF1bHRWaWV3ID8gX2RvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlIDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBSZXR1cm5zIHRoZSBjc3Mgc3R5bGUgZm9yIGEgcGFydGljdWxhciBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50LiBGb3IgZXhhbXBsZSwgdG8gZ2V0IHdoYXRldmVyIHRoZSBjdXJyZW50IFwibGVmdFwiIGNzcyB2YWx1ZSBmb3IgYW4gZWxlbWVudCB3aXRoIGFuIElEIG9mIFwibXlFbGVtZW50XCIsIHlvdSBjb3VsZCBkbzpcblx0XHRcdCAqIHZhciBjdXJyZW50TGVmdCA9IENTU1BsdWdpbi5nZXRTdHlsZSggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUVsZW1lbnRcIiksIFwibGVmdFwiKTtcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnQgd2hvc2Ugc3R5bGUgcHJvcGVydHkgeW91IHdhbnQgdG8gcXVlcnlcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwibGVmdFwiIG9yIFwidG9wXCIgb3IgXCJtYXJnaW5Ub3BcIiwgZXRjLilcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gY3MgQ29tcHV0ZWQgc3R5bGUgb2JqZWN0LiBUaGlzIGp1c3QgcHJvdmlkZXMgYSB3YXkgdG8gc3BlZWQgcHJvY2Vzc2luZyBpZiB5b3UncmUgZ29pbmcgdG8gZ2V0IHNldmVyYWwgcHJvcGVydGllcyBvbiB0aGUgc2FtZSBlbGVtZW50IGluIHF1aWNrIHN1Y2Nlc3Npb24gLSB5b3UgY2FuIHJldXNlIHRoZSByZXN1bHQgb2YgdGhlIGdldENvbXB1dGVkU3R5bGUoKSBjYWxsLlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY2FsYyBJZiB0cnVlLCB0aGUgdmFsdWUgd2lsbCBub3QgYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBlbGVtZW50J3MgXCJzdHlsZVwiIHByb3BlcnR5IChpZiBpdCBleGlzdHMgdGhlcmUpLCBidXQgaW5zdGVhZCB0aGUgZ2V0Q29tcHV0ZWRTdHlsZSgpIHJlc3VsdCB3aWxsIGJlIHVzZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IHRoZSBicm93c2VyIGl0c2VsZiBpcyBpbnRlcnByZXRpbmcgdGhlIHZhbHVlLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBkZmx0IERlZmF1bHQgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWQgaW4gdGhlIHBsYWNlIG9mIG51bGwsIFwibm9uZVwiLCBcImF1dG9cIiBvciBcImF1dG8gYXV0b1wiLlxuXHRcdFx0ICogQHJldHVybiB7P3N0cmluZ30gVGhlIGN1cnJlbnQgcHJvcGVydHkgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0X2dldFN0eWxlID0gQ1NTUGx1Z2luLmdldFN0eWxlID0gZnVuY3Rpb24odCwgcCwgY3MsIGNhbGMsIGRmbHQpIHtcblx0XHRcdFx0dmFyIHJ2O1xuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIGlmIChwID09PSBcIm9wYWNpdHlcIikgeyAvL3NldmVyYWwgdmVyc2lvbnMgb2YgSUUgZG9uJ3QgdXNlIHRoZSBzdGFuZGFyZCBcIm9wYWNpdHlcIiBwcm9wZXJ0eSAtIHRoZXkgdXNlIHRoaW5ncyBsaWtlIGZpbHRlcjphbHBoYShvcGFjaXR5PTUwKSwgc28gd2UgcGFyc2UgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdHJldHVybiBfZ2V0SUVPcGFjaXR5KHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghY2FsYyAmJiB0LnN0eWxlW3BdKSB7XG5cdFx0XHRcdFx0cnYgPSB0LnN0eWxlW3BdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKChjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQpKSkge1xuXHRcdFx0XHRcdHJ2ID0gY3NbcF0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodC5jdXJyZW50U3R5bGUpIHtcblx0XHRcdFx0XHRydiA9IHQuY3VycmVudFN0eWxlW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoZGZsdCAhPSBudWxsICYmICghcnYgfHwgcnYgPT09IFwibm9uZVwiIHx8IHJ2ID09PSBcImF1dG9cIiB8fCBydiA9PT0gXCJhdXRvIGF1dG9cIikpID8gZGZsdCA6IHJ2O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBQYXNzIHRoZSB0YXJnZXQgZWxlbWVudCwgdGhlIHByb3BlcnR5IG5hbWUsIHRoZSBudW1lcmljIHZhbHVlLCBhbmQgdGhlIHN1ZmZpeCAobGlrZSBcIiVcIiwgXCJlbVwiLCBcInB4XCIsIGV0Yy4pIGFuZCBpdCB3aWxsIHNwaXQgYmFjayB0aGUgZXF1aXZhbGVudCBwaXhlbCBudW1iZXIuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwibGVmdFwiLCBcInRvcFwiLCBcIm1hcmdpbkxlZnRcIiwgZXRjLilcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gdiBWYWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBzZnggU3VmZml4IChsaWtlIFwicHhcIiBvciBcIiVcIiBvciBcImVtXCIpXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWN1cnNlIElmIHRydWUsIHRoZSBjYWxsIGlzIGEgcmVjdXJzaXZlIG9uZS4gSW4gc29tZSBicm93c2VycyAobGlrZSBJRTcvOCksIG9jY2FzaW9uYWxseSB0aGUgdmFsdWUgaXNuJ3QgYWNjdXJhdGVseSByZXBvcnRlZCBpbml0aWFsbHksIGJ1dCBpZiB3ZSBydW4gdGhlIGZ1bmN0aW9uIGFnYWluIGl0IHdpbGwgdGFrZSBlZmZlY3QuXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlIGluIHBpeGVsc1xuXHRcdFx0ICovXG5cdFx0XHRfY29udmVydFRvUGl4ZWxzID0gX2ludGVybmFscy5jb252ZXJ0VG9QaXhlbHMgPSBmdW5jdGlvbih0LCBwLCB2LCBzZngsIHJlY3Vyc2UpIHtcblx0XHRcdFx0aWYgKHNmeCA9PT0gXCJweFwiIHx8ICFzZngpIHsgcmV0dXJuIHY7IH1cblx0XHRcdFx0aWYgKHNmeCA9PT0gXCJhdXRvXCIgfHwgIXYpIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0dmFyIGhvcml6ID0gX2hvcml6RXhwLnRlc3QocCksXG5cdFx0XHRcdFx0bm9kZSA9IHQsXG5cdFx0XHRcdFx0c3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcblx0XHRcdFx0XHRuZWcgPSAodiA8IDApLFxuXHRcdFx0XHRcdHBpeCwgY2FjaGUsIHRpbWU7XG5cdFx0XHRcdGlmIChuZWcpIHtcblx0XHRcdFx0XHR2ID0gLXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNmeCA9PT0gXCIlXCIgJiYgcC5pbmRleE9mKFwiYm9yZGVyXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdHBpeCA9ICh2IC8gMTAwKSAqIChob3JpeiA/IHQuY2xpZW50V2lkdGggOiB0LmNsaWVudEhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjAgc29saWQgcmVkO3Bvc2l0aW9uOlwiICsgX2dldFN0eWxlKHQsIFwicG9zaXRpb25cIikgKyBcIjtsaW5lLWhlaWdodDowO1wiO1xuXHRcdFx0XHRcdGlmIChzZnggPT09IFwiJVwiIHx8ICFub2RlLmFwcGVuZENoaWxkKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gdC5wYXJlbnROb2RlIHx8IF9kb2MuYm9keTtcblx0XHRcdFx0XHRcdGNhY2hlID0gbm9kZS5fZ3NDYWNoZTtcblx0XHRcdFx0XHRcdHRpbWUgPSBUd2VlbkxpdGUudGlja2VyLmZyYW1lO1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlICYmIGhvcml6ICYmIGNhY2hlLnRpbWUgPT09IHRpbWUpIHsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IHdlIHJlY29yZCB0aGUgd2lkdGggb2YgZWxlbWVudHMgYWxvbmcgd2l0aCB0aGUgdGlja2VyIGZyYW1lIHNvIHRoYXQgd2UgY2FuIHF1aWNrbHkgZ2V0IGl0IGFnYWluIG9uIHRoZSBzYW1lIHRpY2sgKHNlZW1zIHJlbGF0aXZlbHkgc2FmZSB0byBhc3N1bWUgaXQgd291bGRuJ3QgY2hhbmdlIG9uIHRoZSBzYW1lIHRpY2spXG5cdFx0XHRcdFx0XHRcdHJldHVybiBjYWNoZS53aWR0aCAqIHYgLyAxMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdHlsZVsoaG9yaXogPyBcIndpZHRoXCIgOiBcImhlaWdodFwiKV0gPSB2ICsgc2Z4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVsoaG9yaXogPyBcImJvcmRlckxlZnRXaWR0aFwiIDogXCJib3JkZXJUb3BXaWR0aFwiKV0gPSB2ICsgc2Z4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0XHRwaXggPSBwYXJzZUZsb2F0KF90ZW1wRGl2Wyhob3JpeiA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCIpXSk7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdFx0aWYgKGhvcml6ICYmIHNmeCA9PT0gXCIlXCIgJiYgQ1NTUGx1Z2luLmNhY2hlV2lkdGhzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBub2RlLl9nc0NhY2hlID0gbm9kZS5fZ3NDYWNoZSB8fCB7fTtcblx0XHRcdFx0XHRcdGNhY2hlLnRpbWUgPSB0aW1lO1xuXHRcdFx0XHRcdFx0Y2FjaGUud2lkdGggPSBwaXggLyB2ICogMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGl4ID09PSAwICYmICFyZWN1cnNlKSB7XG5cdFx0XHRcdFx0XHRwaXggPSBfY29udmVydFRvUGl4ZWxzKHQsIHAsIHYsIHNmeCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZWcgPyAtcGl4IDogcGl4O1xuXHRcdFx0fSxcblx0XHRcdF9jYWxjdWxhdGVPZmZzZXQgPSBfaW50ZXJuYWxzLmNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uKHQsIHAsIGNzKSB7IC8vZm9yIGZpZ3VyaW5nIG91dCBcInRvcFwiIG9yIFwibGVmdFwiIGluIHB4IHdoZW4gaXQncyBcImF1dG9cIi4gV2UgbmVlZCB0byBmYWN0b3IgaW4gbWFyZ2luIHdpdGggdGhlIG9mZnNldExlZnQvb2Zmc2V0VG9wXG5cdFx0XHRcdGlmIChfZ2V0U3R5bGUodCwgXCJwb3NpdGlvblwiLCBjcykgIT09IFwiYWJzb2x1dGVcIikgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHR2YXIgZGltID0gKChwID09PSBcImxlZnRcIikgPyBcIkxlZnRcIiA6IFwiVG9wXCIpLFxuXHRcdFx0XHRcdHYgPSBfZ2V0U3R5bGUodCwgXCJtYXJnaW5cIiArIGRpbSwgY3MpO1xuXHRcdFx0XHRyZXR1cm4gdFtcIm9mZnNldFwiICsgZGltXSAtIChfY29udmVydFRvUGl4ZWxzKHQsIHAsIHBhcnNlRmxvYXQodiksIHYucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSkgfHwgMCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSByZXR1cm5zIGF0IG9iamVjdCBjb250YWluaW5nIEFMTCBvZiB0aGUgc3R5bGUgcHJvcGVydGllcyBpbiBjYW1lbENhc2UgYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzLlxuXHRcdFx0X2dldEFsbFN0eWxlcyA9IGZ1bmN0aW9uKHQsIGNzKSB7XG5cdFx0XHRcdHZhciBzID0ge30sXG5cdFx0XHRcdFx0aSwgdHIsIHA7XG5cdFx0XHRcdGlmICgoY3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKSkpIHtcblx0XHRcdFx0XHRpZiAoKGkgPSBjcy5sZW5ndGgpKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0XHRpZiAocC5pbmRleE9mKFwiLXRyYW5zZm9ybVwiKSA9PT0gLTEgfHwgX3RyYW5zZm9ybVByb3BDU1MgPT09IHApIHsgLy9Tb21lIHdlYmtpdCBicm93c2VycyBkdXBsaWNhdGUgdHJhbnNmb3JtIHZhbHVlcywgb25lIG5vbi1wcmVmaXhlZCBhbmQgb25lIHByZWZpeGVkIChcInRyYW5zZm9ybVwiIGFuZCBcIldlYmtpdFRyYW5zZm9ybVwiKSwgc28gd2UgbXVzdCB3ZWVkIG91dCB0aGUgZXh0cmEgb25lIGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0c1twLnJlcGxhY2UoX2NhbWVsRXhwLCBfY2FtZWxGdW5jKV0gPSBjcy5nZXRQcm9wZXJ0eVZhbHVlKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9zb21lIGJyb3dzZXJzIGJlaGF2ZSBkaWZmZXJlbnRseSAtIGNzLmxlbmd0aCBpcyBhbHdheXMgMCwgc28gd2UgbXVzdCBkbyBhIGZvci4uLmluIGxvb3AuXG5cdFx0XHRcdFx0XHRmb3IgKGkgaW4gY3MpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGkuaW5kZXhPZihcIlRyYW5zZm9ybVwiKSA9PT0gLTEgfHwgX3RyYW5zZm9ybVByb3AgPT09IGkpIHsgLy9Tb21lIHdlYmtpdCBicm93c2VycyBkdXBsaWNhdGUgdHJhbnNmb3JtIHZhbHVlcywgb25lIG5vbi1wcmVmaXhlZCBhbmQgb25lIHByZWZpeGVkIChcInRyYW5zZm9ybVwiIGFuZCBcIldlYmtpdFRyYW5zZm9ybVwiKSwgc28gd2UgbXVzdCB3ZWVkIG91dCB0aGUgZXh0cmEgb25lIGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0c1tpXSA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKChjcyA9IHQuY3VycmVudFN0eWxlIHx8IHQuc3R5bGUpKSB7XG5cdFx0XHRcdFx0Zm9yIChpIGluIGNzKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGkpID09PSBcInN0cmluZ1wiICYmIHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRzW2kucmVwbGFjZShfY2FtZWxFeHAsIF9jYW1lbEZ1bmMpXSA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIHtcblx0XHRcdFx0XHRzLm9wYWNpdHkgPSBfZ2V0SUVPcGFjaXR5KHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyID0gX2dldFRyYW5zZm9ybSh0LCBjcywgZmFsc2UpO1xuXHRcdFx0XHRzLnJvdGF0aW9uID0gdHIucm90YXRpb247XG5cdFx0XHRcdHMuc2tld1ggPSB0ci5za2V3WDtcblx0XHRcdFx0cy5zY2FsZVggPSB0ci5zY2FsZVg7XG5cdFx0XHRcdHMuc2NhbGVZID0gdHIuc2NhbGVZO1xuXHRcdFx0XHRzLnggPSB0ci54O1xuXHRcdFx0XHRzLnkgPSB0ci55O1xuXHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRzLnogPSB0ci56O1xuXHRcdFx0XHRcdHMucm90YXRpb25YID0gdHIucm90YXRpb25YO1xuXHRcdFx0XHRcdHMucm90YXRpb25ZID0gdHIucm90YXRpb25ZO1xuXHRcdFx0XHRcdHMuc2NhbGVaID0gdHIuc2NhbGVaO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzLmZpbHRlcnMpIHtcblx0XHRcdFx0XHRkZWxldGUgcy5maWx0ZXJzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgYW5hbHl6ZXMgdHdvIHN0eWxlIG9iamVjdHMgKGFzIHJldHVybmVkIGJ5IF9nZXRBbGxTdHlsZXMoKSkgYW5kIG9ubHkgbG9va3MgZm9yIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlbSB0aGF0IGNvbnRhaW4gdHdlZW5hYmxlIHZhbHVlcyAobGlrZSBhIG51bWJlciBvciBjb2xvcikuIEl0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBcImRpZnNcIiBwcm9wZXJ0eSB3aGljaCByZWZlcnMgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aG9zZSBpc29sYXRlZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgZm9yIHR3ZWVuaW5nLCBhbmQgYSBcImZpcnN0TVBUXCIgcHJvcGVydHkgd2hpY2ggcmVmZXJzIHRvIHRoZSBmaXJzdCBNaW5pUHJvcFR3ZWVuIGluc3RhbmNlIGluIGEgbGlua2VkIGxpc3QgdGhhdCByZWNvcmRlZCBhbGwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBvZiB0aGUgZGlmZmVyZW50IHByb3BlcnRpZXMgc28gdGhhdCB3ZSBjYW4gcmV2ZXJ0IHRvIHRoZW0gYXQgdGhlIGVuZCBvciBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIC0gd2UgZG9uJ3Qgd2FudCB0aGUgY2FzY2FkaW5nIHRvIGdldCBtZXNzZWQgdXAuIFRoZSBmb3JjZUxvb2t1cCBwYXJhbWV0ZXIgaXMgYW4gb3B0aW9uYWwgZ2VuZXJpYyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGZvcmNlZCBpbnRvIHRoZSByZXN1bHRzIC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNsYXNzTmFtZSB0d2VlbnMgdGhhdCBhcmUgb3ZlcndyaXRpbmcgb3RoZXJzIGJlY2F1c2UgaW1hZ2luZSBhIHNjZW5hcmlvIHdoZXJlIGEgcm9sbG92ZXIvcm9sbG91dCBhZGRzL3JlbW92ZXMgYSBjbGFzcyBhbmQgdGhlIHVzZXIgc3dpcGVzIHRoZSBtb3VzZSBvdmVyIHRoZSB0YXJnZXQgU1VQRVIgZmFzdCwgdGh1cyBub3RoaW5nIGFjdHVhbGx5IGNoYW5nZWQgeWV0IGFuZCB0aGUgc3Vic2VxdWVudCBjb21wYXJpc29uIG9mIHRoZSBwcm9wZXJ0aWVzIHdvdWxkIGluZGljYXRlIHRoZXkgbWF0Y2ggKGVzcGVjaWFsbHkgd2hlbiBweCByb3VuZGluZyBpcyB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24pLCB0aHVzIG5vIHR3ZWVuaW5nIGlzIG5lY2Vzc2FyeSBldmVuIHRob3VnaCBpdCBTSE9VTEQgdHdlZW4gYW5kIHJlbW92ZSB0aG9zZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSB0d2VlbiAob3RoZXJ3aXNlIHRoZSBpbmxpbmUgc3R5bGVzIHdpbGwgY29udGFtaW5hdGUgdGhpbmdzKS4gU2VlIHRoZSBjbGFzc05hbWUgU3BlY2lhbFByb3AgY29kZSBmb3IgZGV0YWlscy5cblx0XHRcdF9jc3NEaWYgPSBmdW5jdGlvbih0LCBzMSwgczIsIHZhcnMsIGZvcmNlTG9va3VwKSB7XG5cdFx0XHRcdHZhciBkaWZzID0ge30sXG5cdFx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRcdHZhbCwgcCwgbXB0O1xuXHRcdFx0XHRmb3IgKHAgaW4gczIpIHtcblx0XHRcdFx0XHRpZiAocCAhPT0gXCJjc3NUZXh0XCIpIGlmIChwICE9PSBcImxlbmd0aFwiKSBpZiAoaXNOYU4ocCkpIGlmIChzMVtwXSAhPT0gKHZhbCA9IHMyW3BdKSB8fCAoZm9yY2VMb29rdXAgJiYgZm9yY2VMb29rdXBbcF0pKSBpZiAocC5pbmRleE9mKFwiT3JpZ2luXCIpID09PSAtMSkgaWYgKHR5cGVvZih2YWwpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZih2YWwpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRkaWZzW3BdID0gKHZhbCA9PT0gXCJhdXRvXCIgJiYgKHAgPT09IFwibGVmdFwiIHx8IHAgPT09IFwidG9wXCIpKSA/IF9jYWxjdWxhdGVPZmZzZXQodCwgcCkgOiAoKHZhbCA9PT0gXCJcIiB8fCB2YWwgPT09IFwiYXV0b1wiIHx8IHZhbCA9PT0gXCJub25lXCIpICYmIHR5cGVvZihzMVtwXSkgPT09IFwic3RyaW5nXCIgJiYgczFbcF0ucmVwbGFjZShfTmFORXhwLCBcIlwiKSAhPT0gXCJcIikgPyAwIDogdmFsOyAvL2lmIHRoZSBlbmRpbmcgdmFsdWUgaXMgZGVmYXVsdGluZyAoXCJcIiBvciBcImF1dG9cIiksIHdlIGNoZWNrIHRoZSBzdGFydGluZyB2YWx1ZSBhbmQgaWYgaXQgY2FuIGJlIHBhcnNlZCBpbnRvIGEgbnVtYmVyIChhIHN0cmluZyB3aGljaCBjb3VsZCBoYXZlIGEgc3VmZml4IHRvbywgbGlrZSA3MDBweCksIHRoZW4gd2Ugc3dhcCBpbiAwIGZvciBcIlwiIG9yIFwiYXV0b1wiIHNvIHRoYXQgdGhpbmdzIGFjdHVhbGx5IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHN0eWxlW3BdICE9PSB1bmRlZmluZWQpIHsgLy9mb3IgY2xhc3NOYW1lIHR3ZWVucywgd2UgbXVzdCByZW1lbWJlciB3aGljaCBwcm9wZXJ0aWVzIGFscmVhZHkgZXhpc3RlZCBpbmxpbmUgLSB0aGUgb25lcyB0aGF0IGRpZG4ndCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHRoZSB0d2VlbiBpc24ndCBpbiBwcm9ncmVzcyBiZWNhdXNlIHRoZXkgd2VyZSBvbmx5IGludHJvZHVjZWQgdG8gZmFjaWxpdGF0ZSB0aGUgdHJhbnNpdGlvbiBiZXR3ZWVuIGNsYXNzZXMuXG5cdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHN0eWxlLCBwLCBzdHlsZVtwXSwgbXB0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhcnMpIHtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycykgeyAvL2NvcHkgcHJvcGVydGllcyAoZXhjZXB0IGNsYXNzTmFtZSlcblx0XHRcdFx0XHRcdGlmIChwICE9PSBcImNsYXNzTmFtZVwiKSB7XG5cdFx0XHRcdFx0XHRcdGRpZnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2RpZnM6ZGlmcywgZmlyc3RNUFQ6bXB0fTtcblx0XHRcdH0sXG5cdFx0XHRfZGltZW5zaW9ucyA9IHt3aWR0aDpbXCJMZWZ0XCIsXCJSaWdodFwiXSwgaGVpZ2h0OltcIlRvcFwiLFwiQm90dG9tXCJdfSxcblx0XHRcdF9tYXJnaW5zID0gW1wibWFyZ2luTGVmdFwiLFwibWFyZ2luUmlnaHRcIixcIm1hcmdpblRvcFwiLFwibWFyZ2luQm90dG9tXCJdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIEdldHMgdGhlIHdpZHRoIG9yIGhlaWdodCBvZiBhbiBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChcIndpZHRoXCIgb3IgXCJoZWlnaHRcIilcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gY3MgQ29tcHV0ZWQgc3R5bGUgb2JqZWN0IChpZiBvbmUgZXhpc3RzKS4gSnVzdCBhIHNwZWVkIG9wdGltaXphdGlvbi5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gRGltZW5zaW9uIChpbiBwaXhlbHMpXG5cdFx0XHQgKi9cblx0XHRcdF9nZXREaW1lbnNpb24gPSBmdW5jdGlvbih0LCBwLCBjcykge1xuXHRcdFx0XHR2YXIgdiA9IHBhcnNlRmxvYXQoKHAgPT09IFwid2lkdGhcIikgPyB0Lm9mZnNldFdpZHRoIDogdC5vZmZzZXRIZWlnaHQpLFxuXHRcdFx0XHRcdGEgPSBfZGltZW5zaW9uc1twXSxcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCwgbnVsbCk7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHYgLT0gcGFyc2VGbG9hdCggX2dldFN0eWxlKHQsIFwicGFkZGluZ1wiICsgYVtpXSwgY3MsIHRydWUpICkgfHwgMDtcblx0XHRcdFx0XHR2IC09IHBhcnNlRmxvYXQoIF9nZXRTdHlsZSh0LCBcImJvcmRlclwiICsgYVtpXSArIFwiV2lkdGhcIiwgY3MsIHRydWUpICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIFBhcnNlcyBwb3NpdGlvbi1yZWxhdGVkIGNvbXBsZXggc3RyaW5ncyBsaWtlIFwidG9wIGxlZnRcIiBvciBcIjUwcHggMTBweFwiIG9yIFwiNzAlIDIwJVwiLCBldGMuIHdoaWNoIGFyZSB1c2VkIGZvciB0aGluZ3MgbGlrZSB0cmFuc2Zvcm1PcmlnaW4gb3IgYmFja2dyb3VuZFBvc2l0aW9uLiBPcHRpb25hbGx5IGRlY29yYXRlcyBhIHN1cHBsaWVkIG9iamVjdCAocmVjT2JqKSB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogXCJveFwiIChvZmZzZXRYKSwgXCJveVwiIChvZmZzZXRZKSwgXCJveHBcIiAoaWYgdHJ1ZSwgXCJveFwiIGlzIGEgcGVyY2VudGFnZSBub3QgYSBwaXhlbCB2YWx1ZSksIGFuZCBcIm94eVwiIChpZiB0cnVlLCBcIm95XCIgaXMgYSBwZXJjZW50YWdlIG5vdCBhIHBpeGVsIHZhbHVlKVxuXHRcdFx0X3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbih2LCByZWNPYmopIHtcblx0XHRcdFx0aWYgKHYgPT0gbnVsbCB8fCB2ID09PSBcIlwiIHx8IHYgPT09IFwiYXV0b1wiIHx8IHYgPT09IFwiYXV0byBhdXRvXCIpIHsgLy9ub3RlOiBGaXJlZm94IHVzZXMgXCJhdXRvIGF1dG9cIiBhcyBkZWZhdWx0IHdoZXJlYXMgQ2hyb21lIHVzZXMgXCJhdXRvXCIuXG5cdFx0XHRcdFx0diA9IFwiMCAwXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0XHR4ID0gKHYuaW5kZXhPZihcImxlZnRcIikgIT09IC0xKSA/IFwiMCVcIiA6ICh2LmluZGV4T2YoXCJyaWdodFwiKSAhPT0gLTEpID8gXCIxMDAlXCIgOiBhWzBdLFxuXHRcdFx0XHRcdHkgPSAodi5pbmRleE9mKFwidG9wXCIpICE9PSAtMSkgPyBcIjAlXCIgOiAodi5pbmRleE9mKFwiYm90dG9tXCIpICE9PSAtMSkgPyBcIjEwMCVcIiA6IGFbMV07XG5cdFx0XHRcdGlmICh5ID09IG51bGwpIHtcblx0XHRcdFx0XHR5ID0gKHggPT09IFwiY2VudGVyXCIpID8gXCI1MCVcIiA6IFwiMFwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHkgPT09IFwiY2VudGVyXCIpIHtcblx0XHRcdFx0XHR5ID0gXCI1MCVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeCA9PT0gXCJjZW50ZXJcIiB8fCAoaXNOYU4ocGFyc2VGbG9hdCh4KSkgJiYgKHggKyBcIlwiKS5pbmRleE9mKFwiPVwiKSA9PT0gLTEpKSB7IC8vcmVtZW1iZXIsIHRoZSB1c2VyIGNvdWxkIGZsaXAtZmxvcCB0aGUgdmFsdWVzIGFuZCBzYXkgXCJib3R0b20gY2VudGVyXCIgb3IgXCJjZW50ZXIgYm90dG9tXCIsIGV0Yy4gXCJjZW50ZXJcIiBpcyBhbWJpZ3VvdXMgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkIHRvIGRlc2NyaWJlIGhvcml6b250YWwgb3IgdmVydGljYWwsIGhlbmNlIHRoZSBpc05hTigpLiBJZiB0aGVyZSdzIGFuIFwiPVwiIHNpZ24gaW4gdGhlIHZhbHVlLCBpdCdzIHJlbGF0aXZlLlxuXHRcdFx0XHRcdHggPSBcIjUwJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZWNPYmopIHtcblx0XHRcdFx0XHRyZWNPYmoub3hwID0gKHguaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRyZWNPYmoub3lwID0gKHkuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRyZWNPYmoub3hyID0gKHguY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0cmVjT2JqLm95ciA9ICh5LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdHJlY09iai5veCA9IHBhcnNlRmxvYXQoeC5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpKTtcblx0XHRcdFx0XHRyZWNPYmoub3kgPSBwYXJzZUZsb2F0KHkucmVwbGFjZShfTmFORXhwLCBcIlwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHggKyBcIiBcIiArIHkgKyAoKGEubGVuZ3RoID4gMikgPyBcIiBcIiArIGFbMl0gOiBcIlwiKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVGFrZXMgYW4gZW5kaW5nIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcsIGJ1dCBjYW4gYmUgYSBudW1iZXIpIGFuZCBhIHN0YXJ0aW5nIHZhbHVlIGFuZCByZXR1cm5zIHRoZSBjaGFuZ2UgYmV0d2VlbiB0aGUgdHdvLCBsb29raW5nIGZvciByZWxhdGl2ZSB2YWx1ZSBpbmRpY2F0b3JzIGxpa2UgKz0gYW5kIC09IGFuZCBpdCBhbHNvIGlnbm9yZXMgc3VmZml4ZXMgKGJ1dCBtYWtlIHN1cmUgdGhlIGVuZGluZyB2YWx1ZSBzdGFydHMgd2l0aCBhIG51bWJlciBvciArPS8tPSBhbmQgdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWUgaXMgYSBOVU1CRVIhKVxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGUgRW5kIHZhbHVlIHdoaWNoIGlzIHR5cGljYWxseSBhIHN0cmluZywgYnV0IGNvdWxkIGJlIGEgbnVtYmVyXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gYiBCZWdpbm5pbmcgdmFsdWUgd2hpY2ggaXMgdHlwaWNhbGx5IGEgc3RyaW5nIGJ1dCBjb3VsZCBiZSBhIG51bWJlclxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBBbW91bnQgb2YgY2hhbmdlIGJldHdlZW4gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyAocmVsYXRpdmUgdmFsdWVzIHRoYXQgaGF2ZSBhIFwiKz1cIiBvciBcIi09XCIgYXJlIHJlY29nbml6ZWQpXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNoYW5nZSA9IGZ1bmN0aW9uKGUsIGIpIHtcblx0XHRcdFx0cmV0dXJuICh0eXBlb2YoZSkgPT09IFwic3RyaW5nXCIgJiYgZS5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KGUuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoZS5zdWJzdHIoMikpIDogcGFyc2VGbG9hdChlKSAtIHBhcnNlRmxvYXQoYik7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFRha2VzIGEgdmFsdWUgYW5kIGEgZGVmYXVsdCBudW1iZXIsIGNoZWNrcyBpZiB0aGUgdmFsdWUgaXMgcmVsYXRpdmUsIG51bGwsIG9yIG51bWVyaWMgYW5kIHNwaXRzIGJhY2sgYSBub3JtYWxpemVkIG51bWJlciBhY2NvcmRpbmdseS4gUHJpbWFyaWx5IHVzZWQgaW4gdGhlIF9wYXJzZVRyYW5zZm9ybSgpIGZ1bmN0aW9uLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHYgVmFsdWUgdG8gYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGQgRGVmYXVsdCB2YWx1ZSAod2hpY2ggaXMgYWxzbyB1c2VkIGZvciByZWxhdGl2ZSBjYWxjdWxhdGlvbnMgaWYgXCIrPVwiIG9yIFwiLT1cIiBpcyBmb3VuZCBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyKVxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBQYXJzZWQgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlVmFsID0gZnVuY3Rpb24odiwgZCkge1xuXHRcdFx0XHRyZXR1cm4gKHYgPT0gbnVsbCkgPyBkIDogKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdCh2LnN1YnN0cigyKSkgKyBkIDogcGFyc2VGbG9hdCh2KTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVHJhbnNsYXRlcyBzdHJpbmdzIGxpa2UgXCI0MGRlZ1wiIG9yIFwiNDBcIiBvciA0MHJhZFwiIG9yIFwiKz00MGRlZ1wiIG9yIFwiMjcwX3Nob3J0XCIgb3IgXCItOTBfY3dcIiBvciBcIis9NDVfY2N3XCIgdG8gYSBudW1lcmljIHJhZGlhbiBhbmdsZS4gT2YgY291cnNlIGEgc3RhcnRpbmcvZGVmYXVsdCB2YWx1ZSBtdXN0IGJlIGZlZCBpbiB0b28gc28gdGhhdCByZWxhdGl2ZSB2YWx1ZXMgY2FuIGJlIGNhbGN1bGF0ZWQgcHJvcGVybHkuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSB0byBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gZCBEZWZhdWx0IHZhbHVlICh3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHJlbGF0aXZlIGNhbGN1bGF0aW9ucyBpZiBcIis9XCIgb3IgXCItPVwiIGlzIGZvdW5kIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHAgcHJvcGVydHkgbmFtZSBmb3IgZGlyZWN0aW9uYWxFbmQgKG9wdGlvbmFsIC0gb25seSB1c2VkIHdoZW4gdGhlIHBhcnNlZCB2YWx1ZSBpcyBkaXJlY3Rpb25hbCAoXCJfc2hvcnRcIiwgXCJfY3dcIiwgb3IgXCJfY2N3XCIgc3VmZml4KS4gV2UgbmVlZCBhIHdheSB0byBzdG9yZSB0aGUgdW5jb21wZW5zYXRlZCB2YWx1ZSBzbyB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgaXQgdG8gZXhhY3RseSB3aGF0IHdhcyByZXF1ZXN0ZWQgd2l0aCBubyBkaXJlY3Rpb25hbCBjb21wZW5zYXRpb24pLiBQcm9wZXJ0eSBuYW1lIHdvdWxkIGJlIFwicm90YXRpb25cIiwgXCJyb3RhdGlvblhcIiwgb3IgXCJyb3RhdGlvbllcIlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBkaXJlY3Rpb25hbEVuZCBBbiBvYmplY3QgdGhhdCB3aWxsIHN0b3JlIHRoZSByYXcgZW5kIHZhbHVlcyBmb3IgZGlyZWN0aW9uYWwgYW5nbGVzIChcIl9zaG9ydFwiLCBcIl9jd1wiLCBvciBcIl9jY3dcIiBzdWZmaXgpLiBXZSBuZWVkIGEgd2F5IHRvIHN0b3JlIHRoZSB1bmNvbXBlbnNhdGVkIHZhbHVlIHNvIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCBpdCB0byBleGFjdGx5IHdoYXQgd2FzIHJlcXVlc3RlZCB3aXRoIG5vIGRpcmVjdGlvbmFsIGNvbXBlbnNhdGlvbi5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gcGFyc2VkIGFuZ2xlIGluIHJhZGlhbnNcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQW5nbGUgPSBmdW5jdGlvbih2LCBkLCBwLCBkaXJlY3Rpb25hbEVuZCkge1xuXHRcdFx0XHR2YXIgbWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0Y2FwLCBzcGxpdCwgZGlmLCByZXN1bHQsIGlzUmVsYXRpdmU7XG5cdFx0XHRcdGlmICh2ID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBkO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FwID0gMzYwO1xuXHRcdFx0XHRcdHNwbGl0ID0gdi5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0aXNSZWxhdGl2ZSA9ICh2LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdGRpZiA9IChpc1JlbGF0aXZlID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChzcGxpdFswXS5zdWJzdHIoMikpIDogcGFyc2VGbG9hdChzcGxpdFswXSkpICogKCh2LmluZGV4T2YoXCJyYWRcIikgPT09IC0xKSA/IDEgOiBfUkFEMkRFRykgLSAoaXNSZWxhdGl2ZSA/IDAgOiBkKTtcblx0XHRcdFx0XHRpZiAoc3BsaXQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGlyZWN0aW9uYWxFbmQpIHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uYWxFbmRbcF0gPSBkICsgZGlmO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcInNob3J0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSBkaWYgJSBjYXA7XG5cdFx0XHRcdFx0XHRcdGlmIChkaWYgIT09IGRpZiAlIChjYXAgLyAyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpZiA9IChkaWYgPCAwKSA/IGRpZiArIGNhcCA6IGRpZiAtIGNhcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcIl9jd1wiKSAhPT0gLTEgJiYgZGlmIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiArIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCJjY3dcIikgIT09IC0xICYmIGRpZiA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgLSBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0gZCArIGRpZjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzdWx0IDwgbWluICYmIHJlc3VsdCA+IC1taW4pIHtcblx0XHRcdFx0XHRyZXN1bHQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY29sb3JMb29rdXAgPSB7YXF1YTpbMCwyNTUsMjU1XSxcblx0XHRcdFx0bGltZTpbMCwyNTUsMF0sXG5cdFx0XHRcdHNpbHZlcjpbMTkyLDE5MiwxOTJdLFxuXHRcdFx0XHRibGFjazpbMCwwLDBdLFxuXHRcdFx0XHRtYXJvb246WzEyOCwwLDBdLFxuXHRcdFx0XHR0ZWFsOlswLDEyOCwxMjhdLFxuXHRcdFx0XHRibHVlOlswLDAsMjU1XSxcblx0XHRcdFx0bmF2eTpbMCwwLDEyOF0sXG5cdFx0XHRcdHdoaXRlOlsyNTUsMjU1LDI1NV0sXG5cdFx0XHRcdGZ1Y2hzaWE6WzI1NSwwLDI1NV0sXG5cdFx0XHRcdG9saXZlOlsxMjgsMTI4LDBdLFxuXHRcdFx0XHR5ZWxsb3c6WzI1NSwyNTUsMF0sXG5cdFx0XHRcdG9yYW5nZTpbMjU1LDE2NSwwXSxcblx0XHRcdFx0Z3JheTpbMTI4LDEyOCwxMjhdLFxuXHRcdFx0XHRwdXJwbGU6WzEyOCwwLDEyOF0sXG5cdFx0XHRcdGdyZWVuOlswLDEyOCwwXSxcblx0XHRcdFx0cmVkOlsyNTUsMCwwXSxcblx0XHRcdFx0cGluazpbMjU1LDE5MiwyMDNdLFxuXHRcdFx0XHRjeWFuOlswLDI1NSwyNTVdLFxuXHRcdFx0XHR0cmFuc3BhcmVudDpbMjU1LDI1NSwyNTUsMF19LFxuXG5cdFx0XHRfaHVlID0gZnVuY3Rpb24oaCwgbTEsIG0yKSB7XG5cdFx0XHRcdGggPSAoaCA8IDApID8gaCArIDEgOiAoaCA+IDEpID8gaCAtIDEgOiBoO1xuXHRcdFx0XHRyZXR1cm4gKCgoKGggKiA2IDwgMSkgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogKGggPCAwLjUpID8gbTIgOiAoaCAqIDMgPCAyKSA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogMjU1KSArIDAuNSkgfCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBQYXJzZXMgYSBjb2xvciAobGlrZSAjOUYwLCAjRkY5OTAwLCBvciByZ2IoMjU1LDUxLDE1MykpIGludG8gYW4gYXJyYXkgd2l0aCAzIGVsZW1lbnRzIGZvciByZWQsIGdyZWVuLCBhbmQgYmx1ZS4gQWxzbyBoYW5kbGVzIHJnYmEoKSB2YWx1ZXMgKHNwbGl0cyBpbnRvIGFycmF5IG9mIDQgZWxlbWVudHMgb2YgY291cnNlKVxuXHRcdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IHYgVGhlIHZhbHVlIHRoZSBzaG91bGQgYmUgcGFyc2VkIHdoaWNoIGNvdWxkIGJlIGEgc3RyaW5nIGxpa2UgIzlGMCBvciByZ2IoMjU1LDEwMiw1MSkgb3IgcmdiYSgyNTUsMCwwLDAuNSkgb3IgaXQgY291bGQgYmUgYSBudW1iZXIgbGlrZSAweEZGMDBDQyBvciBldmVuIGEgbmFtZWQgY29sb3IgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLlxuXHRcdFx0ICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEFuIGFycmF5IGNvbnRhaW5pbmcgcmVkLCBncmVlbiwgYW5kIGJsdWUgKGFuZCBvcHRpb25hbGx5IGFscGhhKSBpbiB0aGF0IG9yZGVyLlxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDb2xvciA9IENTU1BsdWdpbi5wYXJzZUNvbG9yID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgYzEsIGMyLCBjMywgaCwgcywgbDtcblx0XHRcdFx0aWYgKCF2IHx8IHYgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2NvbG9yTG9va3VwLmJsYWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gW3YgPj4gMTYsICh2ID4+IDgpICYgMjU1LCB2ICYgMjU1XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5jaGFyQXQodi5sZW5ndGggLSAxKSA9PT0gXCIsXCIpIHsgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG5cdFx0XHRcdFx0diA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9jb2xvckxvb2t1cFt2XSkge1xuXHRcdFx0XHRcdHJldHVybiBfY29sb3JMb29rdXBbdl07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuXHRcdFx0XHRcdGlmICh2Lmxlbmd0aCA9PT0gNCkgeyAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwXG5cdFx0XHRcdFx0XHRjMSA9IHYuY2hhckF0KDEpLFxuXHRcdFx0XHRcdFx0YzIgPSB2LmNoYXJBdCgyKSxcblx0XHRcdFx0XHRcdGMzID0gdi5jaGFyQXQoMyk7XG5cdFx0XHRcdFx0XHR2ID0gXCIjXCIgKyBjMSArIGMxICsgYzIgKyBjMiArIGMzICsgYzM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuXHRcdFx0XHRcdHJldHVybiBbdiA+PiAxNiwgKHYgPj4gOCkgJiAyNTUsIHYgJiAyNTVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuXHRcdFx0XHRcdHYgPSB2Lm1hdGNoKF9udW1FeHApO1xuXHRcdFx0XHRcdGggPSAoTnVtYmVyKHZbMF0pICUgMzYwKSAvIDM2MDtcblx0XHRcdFx0XHRzID0gTnVtYmVyKHZbMV0pIC8gMTAwO1xuXHRcdFx0XHRcdGwgPSBOdW1iZXIodlsyXSkgLyAxMDA7XG5cdFx0XHRcdFx0YzIgPSAobCA8PSAwLjUpID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuXHRcdFx0XHRcdGMxID0gbCAqIDIgLSBjMjtcblx0XHRcdFx0XHRpZiAodi5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0XHR2WzNdID0gTnVtYmVyKHZbM10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2WzBdID0gX2h1ZShoICsgMSAvIDMsIGMxLCBjMik7XG5cdFx0XHRcdFx0dlsxXSA9IF9odWUoaCwgYzEsIGMyKTtcblx0XHRcdFx0XHR2WzJdID0gX2h1ZShoIC0gMSAvIDMsIGMxLCBjMik7XG5cdFx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHRcdH1cblx0XHRcdFx0diA9IHYubWF0Y2goX251bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuXHRcdFx0XHR2WzBdID0gTnVtYmVyKHZbMF0pO1xuXHRcdFx0XHR2WzFdID0gTnVtYmVyKHZbMV0pO1xuXHRcdFx0XHR2WzJdID0gTnVtYmVyKHZbMl0pO1xuXHRcdFx0XHRpZiAodi5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0dlszXSA9IE51bWJlcih2WzNdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH0sXG5cdFx0XHRfY29sb3JFeHAgPSBcIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjLis/XFxcXGJcIjsgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLlxuXG5cdFx0Zm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuXHRcdFx0X2NvbG9yRXhwICs9IFwifFwiICsgcCArIFwiXFxcXGJcIjtcblx0XHR9XG5cdFx0X2NvbG9yRXhwID0gbmV3IFJlZ0V4cChfY29sb3JFeHArXCIpXCIsIFwiZ2lcIik7XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZSBSZXR1cm5zIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0YWtpbmcgYSBzdHJpbmcgKG9yIG51bWJlciBpbiBzb21lIGNhc2VzKSBhbmQgcmV0dXJuaW5nIGEgY29uc2lzdGVudGx5IGZvcm1hdHRlZCBvbmUgaW4gdGVybXMgb2YgZGVsaW1pdGVycywgcXVhbnRpdHkgb2YgdmFsdWVzLCBldGMuIEZvciBleGFtcGxlLCB3ZSBtYXkgZ2V0IGJveFNoYWRvdyB2YWx1ZXMgZGVmaW5lZCBhcyBcIjBweCByZWRcIiBvciBcIjBweCAwcHggMTBweCByZ2IoMjU1LDAsMClcIiBvciBcIjBweCAwcHggMjBweCAyMHB4ICNGMDBcIiBhbmQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3aGF0IHdlIGdldCBiYWNrIGlzIGRlc2NyaWJlZCB3aXRoIDQgbnVtYmVycyBhbmQgYSBjb2xvci4gVGhpcyBhbGxvd3MgdXMgdG8gZmVlZCBpdCBpbnRvIHRoZSBfcGFyc2VDb21wbGV4KCkgbWV0aG9kIGFuZCBzcGxpdCB0aGUgdmFsdWVzIHVwIGFwcHJvcHJpYXRlbHkuIFRoZSBuZWF0IHRoaW5nIGFib3V0IHRoaXMgX2dldEZvcm1hdHRlcigpIGZ1bmN0aW9uIGlzIHRoYXQgdGhlIGRmbHQgZGVmaW5lcyBhIHBhdHRlcm4gYXMgd2VsbCBhcyBhIGRlZmF1bHQsIHNvIGZvciBleGFtcGxlLCBfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweCAwcHggMHB4ICM3NzdcIiwgdHJ1ZSkgbm90IG9ubHkgc2V0cyB0aGUgZGVmYXVsdCBhcyAwcHggZm9yIGFsbCBkaXN0YW5jZXMgYW5kICM3NzcgZm9yIHRoZSBjb2xvciwgYnV0IGFsc28gc2V0cyB0aGUgcGF0dGVybiBzdWNoIHRoYXQgNCBudW1iZXJzIGFuZCBhIGNvbG9yIHdpbGwgYWx3YXlzIGdldCByZXR1cm5lZC5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IGRmbHQgVGhlIGRlZmF1bHQgdmFsdWUgYW5kIHBhdHRlcm4gdG8gZm9sbG93LiBTbyBcIjBweCAwcHggMHB4IDBweCAjNzc3XCIgd2lsbCBlbnN1cmUgdGhhdCA0IG51bWJlcnMgYW5kIGEgY29sb3Igd2lsbCBhbHdheXMgZ2V0IHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNsciBJZiB0cnVlLCB0aGUgdmFsdWVzIHNob3VsZCBiZSBzZWFyY2hlZCBmb3IgY29sb3ItcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IHZhbHVlcyB0eXBpY2FsbHkgY29udGFpbiBhIGNvbG9yIHdoZXJlYXMgYm9yZGVyUmFkaXVzIGRvbid0LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbGxhcHNpYmxlIElmIHRydWUsIHRoZSB2YWx1ZSBpcyBhIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBzdHlsZSBvbmUgdGhhdCBhY3RzIGxpa2UgbWFyZ2luIG9yIHBhZGRpbmcsIHdoZXJlIGlmIG9ubHkgb25lIHZhbHVlIGlzIHJlY2VpdmVkLCBpdCdzIHVzZWQgZm9yIGFsbCA0OyBpZiAyIGFyZSByZWNlaXZlZCwgdGhlIGZpcnN0IGlzIGR1cGxpY2F0ZWQgZm9yIDNyZCAoYm90dG9tKSBhbmQgdGhlIDJuZCBpcyBkdXBsaWNhdGVkIGZvciB0aGUgNHRoIHNwb3QgKGxlZnQpLCBldGMuXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259IGZvcm1hdHRlciBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdHZhciBfZ2V0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZGZsdCwgY2xyLCBjb2xsYXBzaWJsZSwgbXVsdGkpIHtcblx0XHRcdFx0aWYgKGRmbHQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih2KSB7cmV0dXJuIHY7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZENvbG9yID0gY2xyID8gKGRmbHQubWF0Y2goX2NvbG9yRXhwKSB8fCBbXCJcIl0pWzBdIDogXCJcIixcblx0XHRcdFx0XHRkVmFscyA9IGRmbHQuc3BsaXQoZENvbG9yKS5qb2luKFwiXCIpLm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdLFxuXHRcdFx0XHRcdHBmeCA9IGRmbHQuc3Vic3RyKDAsIGRmbHQuaW5kZXhPZihkVmFsc1swXSkpLFxuXHRcdFx0XHRcdHNmeCA9IChkZmx0LmNoYXJBdChkZmx0Lmxlbmd0aCAtIDEpID09PSBcIilcIikgPyBcIilcIiA6IFwiXCIsXG5cdFx0XHRcdFx0ZGVsaW0gPSAoZGZsdC5pbmRleE9mKFwiIFwiKSAhPT0gLTEpID8gXCIgXCIgOiBcIixcIixcblx0XHRcdFx0XHRudW1WYWxzID0gZFZhbHMubGVuZ3RoLFxuXHRcdFx0XHRcdGRTZnggPSAobnVtVmFscyA+IDApID8gZFZhbHNbMF0ucmVwbGFjZShfbnVtRXhwLCBcIlwiKSA6IFwiXCIsXG5cdFx0XHRcdFx0Zm9ybWF0dGVyO1xuXHRcdFx0XHRpZiAoIW51bVZhbHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odikge3JldHVybiB2O307XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNscikge1xuXHRcdFx0XHRcdGZvcm1hdHRlciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHZhciBjb2xvciwgdmFscywgaSwgYTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdFx0diArPSBkU2Z4O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtdWx0aSAmJiBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QodikpIHtcblx0XHRcdFx0XHRcdFx0YSA9IHYucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGFbaV0gPSBmb3JtYXR0ZXIoYVtpXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGEuam9pbihcIixcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb2xvciA9ICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW2RDb2xvcl0pWzBdO1xuXHRcdFx0XHRcdFx0dmFscyA9IHYuc3BsaXQoY29sb3IpLmpvaW4oXCJcIikubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW107XG5cdFx0XHRcdFx0XHRpID0gdmFscy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpZiAobnVtVmFscyA+IGktLSkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoKytpIDwgbnVtVmFscykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHNbaV0gPSBjb2xsYXBzaWJsZSA/IHZhbHNbKCgoaSAtIDEpIC8gMikgfCAwKV0gOiBkVmFsc1tpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHBmeCArIHZhbHMuam9pbihkZWxpbSkgKyBkZWxpbSArIGNvbG9yICsgc2Z4ICsgKHYuaW5kZXhPZihcImluc2V0XCIpICE9PSAtMSA/IFwiIGluc2V0XCIgOiBcIlwiKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybiBmb3JtYXR0ZXI7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3JtYXR0ZXIgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHMsIGEsIGk7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0diArPSBkU2Z4O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobXVsdGkgJiYgX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KHYpKSB7XG5cdFx0XHRcdFx0XHRhID0gdi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRhW2ldID0gZm9ybWF0dGVyKGFbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGEuam9pbihcIixcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhbHMgPSB2Lm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdO1xuXHRcdFx0XHRcdGkgPSB2YWxzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobnVtVmFscyA+IGktLSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCsraSA8IG51bVZhbHMpIHtcblx0XHRcdFx0XHRcdFx0dmFsc1tpXSA9IGNvbGxhcHNpYmxlID8gdmFsc1soKChpIC0gMSkgLyAyKSB8IDApXSA6IGRWYWxzW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcGZ4ICsgdmFscy5qb2luKGRlbGltKSArIHNmeDtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcjtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgcmV0dXJucyBhIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0J3MgdXNlZCBmb3IgZWRnZS1yZWxhdGVkIHZhbHVlcyBsaWtlIG1hcmdpblRvcCwgbWFyZ2luTGVmdCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBldGMuIEp1c3QgcGFzcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHJlbGF0ZWQgdG8gdGhlIGVkZ2VzLlxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwcm9wcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIGluIG9yZGVyIGZyb20gdG9wIHRvIGxlZnQsIGxpa2UgXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIlxuXHRcdFx0ICogQHJldHVybiB7RnVuY3Rpb259IGEgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cdFx0XHQgKi9cblx0XHRcdF9nZXRFZGdlUGFyc2VyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRcdFx0dmFyIGEgPSAoZSArIFwiXCIpLnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0XHRcdGk7XG5cdFx0XHRcdFx0dmFycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHZhcnNbcHJvcHNbaV1dID0gYVtpXSA9IGFbaV0gfHwgYVsoKChpIC0gMSkgLyAyKSA+PiAwKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjc3NwLnBhcnNlKHQsIHZhcnMsIHB0LCBwbHVnaW4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgdXNlZCB3aGVuIG90aGVyIHBsdWdpbnMgbXVzdCB0d2VlbiB2YWx1ZXMgZmlyc3QsIGxpa2UgQmV6aWVyUGx1Z2luIG9yIFRocm93UHJvcHNQbHVnaW4sIGV0Yy4gVGhhdCBwbHVnaW4ncyBzZXRSYXRpbygpIGdldHMgY2FsbGVkIGZpcnN0IHNvIHRoYXQgdGhlIHZhbHVlcyBhcmUgdXBkYXRlZCwgYW5kIHRoZW4gd2UgbG9vcCB0aHJvdWdoIHRoZSBNaW5pUHJvcFR3ZWVucyAgd2hpY2ggaGFuZGxlIGNvcHlpbmcgdGhlIHZhbHVlcyBpbnRvIHRoZWlyIGFwcHJvcHJpYXRlIHNsb3RzIHNvIHRoYXQgdGhleSBjYW4gdGhlbiBiZSBhcHBsaWVkIGNvcnJlY3RseSBpbiB0aGUgbWFpbiBDU1NQbHVnaW4gc2V0UmF0aW8oKSBtZXRob2QuIFJlbWVtYmVyLCB3ZSB0eXBpY2FsbHkgY3JlYXRlIGEgcHJveHkgb2JqZWN0IHRoYXQgaGFzIGEgYnVuY2ggb2YgdW5pcXVlbHktbmFtZWQgcHJvcGVydGllcyB0aGF0IHdlIGZlZWQgdG8gdGhlIHN1Yi1wbHVnaW4gYW5kIGl0IGRvZXMgaXRzIG1hZ2ljIG5vcm1hbGx5LCBhbmQgdGhlbiB3ZSBtdXN0IGludGVycHJldCB0aG9zZSB2YWx1ZXMgYW5kIGFwcGx5IHRoZW0gdG8gdGhlIGNzcyBiZWNhdXNlIG9mdGVuIG51bWJlcnMgbXVzdCBnZXQgY29tYmluZWQvY29uY2F0ZW5hdGVkLCBzdWZmaXhlcyBhZGRlZCwgZXRjLiB0byB3b3JrIHdpdGggY3NzLCBsaWtlIGJveFNoYWRvdyBjb3VsZCBoYXZlIDQgdmFsdWVzIHBsdXMgYSBjb2xvci5cblx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXRSYXRpbyh2KTtcblx0XHRcdFx0dmFyIGQgPSB0aGlzLmRhdGEsXG5cdFx0XHRcdFx0cHJveHkgPSBkLnByb3h5LFxuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQsXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0dmFsLCBwdCwgaSwgc3RyO1xuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0dmFsID0gcHJveHlbbXB0LnZdO1xuXHRcdFx0XHRcdGlmIChtcHQucikge1xuXHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluICYmIHZhbCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1wdC50W21wdC5wXSA9IHZhbDtcblx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGQuYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdGQuYXV0b1JvdGF0ZS5yb3RhdGlvbiA9IHByb3h5LnJvdGF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vYXQgdGhlIGVuZCwgd2UgbXVzdCBzZXQgdGhlIENTU1Byb3BUd2VlbidzIFwiZVwiIChlbmQpIHZhbHVlIGR5bmFtaWNhbGx5IGhlcmUgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpcyB1c2VkIGluIHRoZSBmaW5hbCBzZXRSYXRpbygpIG1ldGhvZC5cblx0XHRcdFx0aWYgKHYgPT09IDEpIHtcblx0XHRcdFx0XHRtcHQgPSBkLmZpcnN0TVBUO1xuXHRcdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHRcdHB0ID0gbXB0LnQ7XG5cdFx0XHRcdFx0XHRpZiAoIXB0LnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0cHQuZSA9IHB0LnMgKyBwdC54czA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQucyArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0LmUgPSBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIEBjb25zdHJ1Y3RvciBVc2VkIGJ5IGEgZmV3IFNwZWNpYWxQcm9wcyB0byBob2xkIGltcG9ydGFudCB2YWx1ZXMgZm9yIHByb3hpZXMuIEZvciBleGFtcGxlLCBfcGFyc2VUb1Byb3h5KCkgY3JlYXRlcyBhIE1pbmlQcm9wVHdlZW4gaW5zdGFuY2UgZm9yIGVhY2ggcHJvcGVydHkgdGhhdCBtdXN0IGdldCB0d2VlbmVkIG9uIHRoZSBwcm94eSwgYW5kIHdlIHJlY29yZCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgbmFtZSBhcyB3ZWxsIGFzIHRoZSB1bmlxdWUgb25lIHdlIGNyZWF0ZSBmb3IgdGhlIHByb3h5LCBwbHVzIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZSBuZWVkcyB0byBiZSByb3VuZGVkIHBsdXMgdGhlIG9yaWdpbmFsIHZhbHVlLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2UncmUgdHdlZW5pbmcgKG9mdGVuIGEgQ1NTUHJvcFR3ZWVuKVxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIHByb3BlcnR5IG5hbWVcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmd8b2JqZWN0KX0gdiB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtNaW5pUHJvcFR3ZWVuPX0gbmV4dCBuZXh0IE1pbmlQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByIGlmIHRydWUsIHRoZSB0d2VlbmVkIHZhbHVlIHNob3VsZCBiZSByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcblx0XHRcdCAqL1xuXHRcdFx0TWluaVByb3BUd2VlbiA9IGZ1bmN0aW9uKHQsIHAsIHYsIG5leHQsIHIpIHtcblx0XHRcdFx0dGhpcy50ID0gdDtcblx0XHRcdFx0dGhpcy5wID0gcDtcblx0XHRcdFx0dGhpcy52ID0gdjtcblx0XHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBNb3N0IG90aGVyIHBsdWdpbnMgKGxpa2UgQmV6aWVyUGx1Z2luIGFuZCBUaHJvd1Byb3BzUGx1Z2luIGFuZCBvdGhlcnMpIGNhbiBvbmx5IHR3ZWVuIG51bWVyaWMgdmFsdWVzLCBidXQgQ1NTUGx1Z2luIG11c3QgYWNjb21tb2RhdGUgc3BlY2lhbCB2YWx1ZXMgdGhhdCBoYXZlIGEgYnVuY2ggb2YgZXh0cmEgZGF0YSAobGlrZSBhIHN1ZmZpeCBvciBzdHJpbmdzIGJldHdlZW4gbnVtZXJpYyB2YWx1ZXMsIGV0Yy4pLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IGhhcyB2YWx1ZXMgbGlrZSBcIjEwcHggMTBweCAyMHB4IDMwcHggcmdiKDI1NSwwLDApXCIgd2hpY2ggd291bGQgdXR0ZXJseSBjb25mdXNlIG90aGVyIHBsdWdpbnMuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBzcGxpdCB0aGF0IGRhdGEgYXBhcnQgYW5kIGdyYWIgb25seSB0aGUgbnVtZXJpYyBkYXRhIGFuZCBhdHRhY2ggaXQgdG8gdW5pcXVlbHktbmFtZWQgcHJvcGVydGllcyBvZiBhIGdlbmVyaWMgcHJveHkgb2JqZWN0ICh7fSkgc28gdGhhdCB3ZSBjYW4gZmVlZCB0aGF0IHRvIHZpcnR1YWxseSBhbnkgcGx1Z2luIHRvIGhhdmUgdGhlIG51bWJlcnMgdHdlZW5lZC4gSG93ZXZlciwgd2UgbXVzdCBhbHNvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcHJvcGVydGllcyBmcm9tIHRoZSBwcm94eSBnbyB3aXRoIHdoaWNoIENTU1Byb3BUd2VlbiB2YWx1ZXMgYW5kIGluc3RhbmNlcy4gU28gd2UgY3JlYXRlIGEgbGlua2VkIGxpc3Qgb2YgTWluaVByb3BUd2VlbnMuIEVhY2ggb25lIHJlY29yZHMgYSB0YXJnZXQgKHRoZSBvcmlnaW5hbCBDU1NQcm9wVHdlZW4pLCBwcm9wZXJ0eSAobGlrZSBcInNcIiBvciBcInhuMVwiIG9yIFwieG4yXCIpIHRoYXQgd2UncmUgdHdlZW5pbmcgYW5kIHRoZSB1bmlxdWUgcHJvcGVydHkgbmFtZSB0aGF0IHdhcyB1c2VkIGZvciB0aGUgcHJveHkgKGxpa2UgXCJib3hTaGFkb3dfeG4xXCIgYW5kIFwiYm94U2hhZG93X3huMlwiKSBhbmQgd2hldGhlciBvciBub3QgdGhleSBuZWVkIHRvIGJlIHJvdW5kZWQuIFRoYXQgd2F5LCBpbiB0aGUgX3NldFBsdWdpblJhdGlvKCkgbWV0aG9kIHdlIGNhbiBzaW1wbHkgY29weSB0aGUgdmFsdWVzIG92ZXIgZnJvbSB0aGUgcHJveHkgdG8gdGhlIENTU1Byb3BUd2VlbiBpbnN0YW5jZShzKS4gVGhlbiwgd2hlbiB0aGUgbWFpbiBDU1NQbHVnaW4gc2V0UmF0aW8oKSBtZXRob2QgcnVucyBhbmQgYXBwbGllcyB0aGUgQ1NTUHJvcFR3ZWVuIHZhbHVlcyBhY2NvcmRpbmdseSwgdGhleSdyZSB1cGRhdGVkIG5pY2VseS4gU28gdGhlIGV4dGVybmFsIHBsdWdpbiB0d2VlbnMgdGhlIG51bWJlcnMsIF9zZXRQbHVnaW5SYXRpbygpIGNvcGllcyB0aGVtIG92ZXIsIGFuZCBzZXRSYXRpbygpIGFjdHMgbm9ybWFsbHksIGFwcGx5aW5nIGNzcy1zcGVjaWZpYyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQuXG5cdFx0XHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0XHQgKiAgLSBwcm94eTogYSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFydGluZyB2YWx1ZXMgZm9yIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdHdlZW5lZCBieSB0aGUgZXh0ZXJuYWwgcGx1Z2luLiAgVGhpcyBpcyB3aGF0IHdlIGZlZWQgdG8gdGhlIGV4dGVybmFsIF9vbkluaXRUd2VlbigpIGFzIHRoZSB0YXJnZXRcblx0XHRcdCAqICAtIGVuZDogYSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHRoZSBlbmRpbmcgdmFsdWVzIGZvciBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgYnkgdGhlIGV4dGVybmFsIHBsdWdpbi4gVGhpcyBpcyB3aGF0IHdlIGZlZWQgdG8gdGhlIGV4dGVybmFsIHBsdWdpbidzIF9vbkluaXRUd2VlbigpIGFzIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZXNcblx0XHRcdCAqICAtIGZpcnN0TVBUOiB0aGUgZmlyc3QgTWluaVByb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqICAtIHB0OiB0aGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB0aGF0IHdhcyBjcmVhdGVkIHdoZW4gcGFyc2luZy4gSWYgc2hhbGxvdyBpcyB0cnVlLCB0aGlzIGxpbmtlZCBsaXN0IHdpbGwgTk9UIGF0dGFjaCB0byB0aGUgb25lIHBhc3NlZCBpbnRvIHRoZSBfcGFyc2VUb1Byb3h5KCkgYXMgdGhlIFwicHRcIiAoNHRoKSBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IG9iamVjdCB0byBiZSB0d2VlbmVkXG5cdFx0XHQgKiBAcGFyYW0geyEoT2JqZWN0fHN0cmluZyl9IHZhcnMgdGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdHdlZW5pbmcgdmFsdWVzICh0eXBpY2FsbHkgdGhlIGVuZC9kZXN0aW5hdGlvbiB2YWx1ZXMpIHRoYXQgc2hvdWxkIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshQ1NTUGx1Z2lufSBjc3NwIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2Vcblx0XHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gcHQgdGhlIG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiB0aGUgZXh0ZXJuYWwgVHdlZW5QbHVnaW4gaW5zdGFuY2UgdGhhdCB3aWxsIGJlIGhhbmRsaW5nIHR3ZWVuaW5nIHRoZSBudW1lcmljIHZhbHVlc1xuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gc2hhbGxvdyBpZiB0cnVlLCB0aGUgcmVzdWx0aW5nIGxpbmtlZCBsaXN0IGZyb20gdGhlIHBhcnNlIHdpbGwgTk9UIGJlIGF0dGFjaGVkIHRvIHRoZSBDU1NQcm9wVHdlZW4gdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBcInB0XCIgKDR0aCkgcGFyYW1ldGVyLlxuXHRcdFx0ICogQHJldHVybiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHByb3h5LCBlbmQsIGZpcnN0TVBULCBhbmQgcHQgKHNlZSBhYm92ZSBmb3IgZGVzY3JpcHRpb25zKVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VUb1Byb3h5ID0gX2ludGVybmFscy5fcGFyc2VUb1Byb3h5ID0gZnVuY3Rpb24odCwgdmFycywgY3NzcCwgcHQsIHBsdWdpbiwgc2hhbGxvdykge1xuXHRcdFx0XHR2YXIgYnB0ID0gcHQsXG5cdFx0XHRcdFx0c3RhcnQgPSB7fSxcblx0XHRcdFx0XHRlbmQgPSB7fSxcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBjc3NwLl90cmFuc2Zvcm0sXG5cdFx0XHRcdFx0b2xkRm9yY2UgPSBfZm9yY2VQVCxcblx0XHRcdFx0XHRpLCBwLCB4cCwgbXB0LCBmaXJzdFBUO1xuXHRcdFx0XHRjc3NwLl90cmFuc2Zvcm0gPSBudWxsO1xuXHRcdFx0XHRfZm9yY2VQVCA9IHZhcnM7XG5cdFx0XHRcdHB0ID0gZmlyc3RQVCA9IGNzc3AucGFyc2UodCwgdmFycywgcHQsIHBsdWdpbik7XG5cdFx0XHRcdF9mb3JjZVBUID0gb2xkRm9yY2U7XG5cdFx0XHRcdC8vYnJlYWsgb2ZmIGZyb20gdGhlIGxpbmtlZCBsaXN0IHNvIHRoZSBuZXcgb25lcyBhcmUgaXNvbGF0ZWQuXG5cdFx0XHRcdGlmIChzaGFsbG93KSB7XG5cdFx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuXHRcdFx0XHRcdGlmIChicHQpIHtcblx0XHRcdFx0XHRcdGJwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoYnB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdGJwdC5fcHJldi5fbmV4dCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChwdCAmJiBwdCAhPT0gYnB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgPD0gMSkge1xuXHRcdFx0XHRcdFx0cCA9IHB0LnA7XG5cdFx0XHRcdFx0XHRlbmRbcF0gPSBwdC5zICsgcHQuYztcblx0XHRcdFx0XHRcdHN0YXJ0W3BdID0gcHQucztcblx0XHRcdFx0XHRcdGlmICghc2hhbGxvdykge1xuXHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihwdCwgXCJzXCIsIHAsIG1wdCwgcHQucik7XG5cdFx0XHRcdFx0XHRcdHB0LmMgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHB0LnR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0eHAgPSBcInhuXCIgKyBpO1xuXHRcdFx0XHRcdFx0XHRcdHAgPSBwdC5wICsgXCJfXCIgKyB4cDtcblx0XHRcdFx0XHRcdFx0XHRlbmRbcF0gPSBwdC5kYXRhW3hwXTtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFtwXSA9IHB0W3hwXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXNoYWxsb3cpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHB0LCB4cCwgcCwgbXB0LCBwdC5yeHBbeHBdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge3Byb3h5OnN0YXJ0LCBlbmQ6ZW5kLCBmaXJzdE1QVDptcHQsIHB0OmZpcnN0UFR9O1xuXHRcdFx0fSxcblxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yIEVhY2ggcHJvcGVydHkgdGhhdCBpcyB0d2VlbmVkIGhhcyBhdCBsZWFzdCBvbmUgQ1NTUHJvcFR3ZWVuIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhlc2UgaW5zdGFuY2VzIHN0b3JlIGltcG9ydGFudCBpbmZvcm1hdGlvbiBsaWtlIHRoZSB0YXJnZXQsIHByb3BlcnR5LCBzdGFydGluZyB2YWx1ZSwgYW1vdW50IG9mIGNoYW5nZSwgZXRjLiBUaGV5IGNhbiBhbHNvIG9wdGlvbmFsbHkgaGF2ZSBhIG51bWJlciBvZiBcImV4dHJhXCIgc3RyaW5ncyBhbmQgbnVtZXJpYyB2YWx1ZXMgbmFtZWQgeHMxLCB4bjEsIHhzMiwgeG4yLCB4czMsIHhuMywgZXRjLiB3aGVyZSBcInNcIiBpbmRpY2F0ZXMgc3RyaW5nIGFuZCBcIm5cIiBpbmRpY2F0ZXMgbnVtYmVyLiBUaGVzZSBjYW4gYmUgcGllY2VkIHRvZ2V0aGVyIGluIGEgY29tcGxleC12YWx1ZSB0d2VlbiAodHlwZToxKSB0aGF0IGhhcyBhbHRlcm5hdGluZyB0eXBlcyBvZiBkYXRhIGxpa2UgYSBzdHJpbmcsIG51bWJlciwgc3RyaW5nLCBudW1iZXIsIGV0Yy4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyBjb3VsZCBiZSBcIjVweCA1cHggOHB4IHJnYigxMDIsIDEwMiwgNTEpXCIuIEluIHRoYXQgdmFsdWUsIHRoZXJlIGFyZSA2IG51bWJlcnMgdGhhdCBtYXkgbmVlZCB0byB0d2VlbiBhbmQgdGhlbiBwaWVjZWQgYmFjayB0b2dldGhlciBpbnRvIGEgc3RyaW5nIGFnYWluIHdpdGggc3BhY2VzLCBzdWZmaXhlcywgZXRjLiB4czAgaXMgc3BlY2lhbCBpbiB0aGF0IGl0IHN0b3JlcyB0aGUgc3VmZml4IGZvciBzdGFuZGFyZCAodHlwZTowKSB0d2VlbnMsIC1PUi0gdGhlIGZpcnN0IHN0cmluZyAocHJlZml4KSBpbiBhIGNvbXBsZXgtdmFsdWUgKHR5cGU6MSkgQ1NTUHJvcFR3ZWVuIC1PUi0gaXQgY2FuIGJlIHRoZSBub24tdHdlZW5pbmcgdmFsdWUgaW4gYSB0eXBlOi0xIENTU1Byb3BUd2Vlbi4gV2UgZG8gdGhpcyB0byBjb25zZXJ2ZSBtZW1vcnkuXG5cdFx0XHQgKiBDU1NQcm9wVHdlZW5zIGhhdmUgdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIGFzIHdlbGwgKG5vdCBkZWZpbmVkIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yKTpcblx0XHRcdCAqICAtIGw6IExlbmd0aCBpbiB0ZXJtcyBvZiB0aGUgbnVtYmVyIG9mIGV4dHJhIHByb3BlcnRpZXMgdGhhdCB0aGUgQ1NTUHJvcFR3ZWVuIGhhcyAoZGVmYXVsdDogMCkuIEZvciBleGFtcGxlLCBmb3IgYSBib3hTaGFkb3cgd2UgbWF5IG5lZWQgdG8gdHdlZW4gNSBudW1iZXJzIGluIHdoaWNoIGNhc2UgbCB3b3VsZCBiZSA1OyBLZWVwIGluIG1pbmQgdGhhdCB0aGUgc3RhcnQvZW5kIHZhbHVlcyBmb3IgdGhlIGZpcnN0IG51bWJlciB0aGF0J3MgdHdlZW5lZCBhcmUgYWx3YXlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBwcm9wZXJ0aWVzIHRvIGNvbnNlcnZlIG1lbW9yeS4gQWxsIGFkZGl0aW9uYWwgdmFsdWVzIHRoZXJlYWZ0ZXIgYXJlIHN0b3JlZCBpbiB4bjEsIHhuMiwgZXRjLlxuXHRcdFx0ICogIC0geGZpcnN0OiBUaGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IHN1Yi1DU1NQcm9wVHdlZW5zIHRoYXQgYXJlIHR3ZWVuaW5nIHByb3BlcnRpZXMgb2YgdGhpcyBpbnN0YW5jZS4gRm9yIGV4YW1wbGUsIHdlIG1heSBzcGxpdCB1cCBhIGJveFNoYWRvdyB0d2VlbiBzbyB0aGF0IHRoZXJlJ3MgYSBtYWluIENTU1Byb3BUd2VlbiBvZiB0eXBlOjEgdGhhdCBoYXMgdmFyaW91cyB4cyogYW5kIHhuKiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBoLXNoYWRvdywgdi1zaGFkb3csIGJsdXIsIGNvbG9yLCBldGMuIFRoZW4gd2Ugc3Bhd24gYSBDU1NQcm9wVHdlZW4gZm9yIGVhY2ggb2YgdGhvc2UgdGhhdCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgYW5kIHJ1bnMgQkVGT1JFIHRoZSBtYWluIENTU1Byb3BUd2VlbiBzbyB0aGF0IHRoZSB2YWx1ZXMgYXJlIGFsbCBzZXQgYnkgdGhlIHRpbWUgaXQgbmVlZHMgdG8gcmUtYXNzZW1ibGUgdGhlbS4gVGhlIHhmaXJzdCBnaXZlcyB1cyBhbiBlYXN5IHdheSB0byBpZGVudGlmeSB0aGUgZmlyc3Qgb25lIGluIHRoYXQgY2hhaW4gd2hpY2ggdHlwaWNhbGx5IGVuZHMgYXQgdGhlIG1haW4gb25lIChiZWNhdXNlIHRoZXkncmUgYWxsIHByZXBlbmRlIHRvIHRoZSBsaW5rZWQgbGlzdClcblx0XHRcdCAqICAtIHBsdWdpbjogVGhlIFR3ZWVuUGx1Z2luIGluc3RhbmNlIHRoYXQgd2lsbCBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGFueSBjb21wbGV4IHZhbHVlcy4gRm9yIGV4YW1wbGUsIHNvbWV0aW1lcyB3ZSBkb24ndCB3YW50IHRvIHVzZSBub3JtYWwgc3VidHdlZW5zIChsaWtlIHhmaXJzdCByZWZlcnMgdG8pIHRvIHR3ZWVuIHRoZSB2YWx1ZXMgLSB3ZSBtaWdodCB3YW50IFRocm93UHJvcHNQbHVnaW4gb3IgQmV6aWVyUGx1Z2luIHNvbWUgb3RoZXIgcGx1Z2luIHRvIGRvIHRoZSBhY3R1YWwgdHdlZW5pbmcsIHNvIHdlIGNyZWF0ZSBhIHBsdWdpbiBpbnN0YW5jZSBhbmQgc3RvcmUgYSByZWZlcmVuY2UgaGVyZS4gV2UgbmVlZCB0aGlzIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHdlIGdldCBhIHJlcXVlc3QgdG8gcm91bmQgdmFsdWVzIG9yIGRpc2FibGUgYSB0d2Vlbiwgd2UgY2FuIHBhc3MgYWxvbmcgdGhhdCByZXF1ZXN0LlxuXHRcdFx0ICogIC0gZGF0YTogQXJiaXRyYXJ5IGRhdGEgdGhhdCBuZWVkcyB0byBiZSBzdG9yZWQgd2l0aCB0aGUgQ1NTUHJvcFR3ZWVuLiBUeXBpY2FsbHkgaWYgd2UncmUgZ29pbmcgdG8gaGF2ZSBhIHBsdWdpbiBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGEgY29tcGxleC12YWx1ZSB0d2Vlbiwgd2UgY3JlYXRlIGEgZ2VuZXJpYyBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIEVORCB2YWx1ZXMgdGhhdCB3ZSdyZSB0d2VlbmluZyB0byBhbmQgdGhlIENTU1Byb3BUd2VlbidzIHhzMSwgeHMyLCBldGMuIGhhdmUgdGhlIHN0YXJ0aW5nIHZhbHVlcy4gV2Ugc3RvcmUgdGhhdCBvYmplY3QgYXMgZGF0YS4gVGhhdCB3YXksIHdlIGNhbiBzaW1wbHkgcGFzcyB0aGF0IG9iamVjdCB0byB0aGUgcGx1Z2luIGFuZCB1c2UgdGhlIENTU1Byb3BUd2VlbiBhcyB0aGUgdGFyZ2V0LlxuXHRcdFx0ICogIC0gc2V0UmF0aW86IE9ubHkgdXNlZCBmb3IgdHlwZToyIHR3ZWVucyB0aGF0IHJlcXVpcmUgY3VzdG9tIGZ1bmN0aW9uYWxpdHkuIEluIHRoaXMgY2FzZSwgd2UgY2FsbCB0aGUgQ1NTUHJvcFR3ZWVuJ3Mgc2V0UmF0aW8oKSBtZXRob2QgYW5kIHBhc3MgdGhlIHJhdGlvIGVhY2ggdGltZSB0aGUgdHdlZW4gdXBkYXRlcy4gVGhpcyBpc24ndCBxdWl0ZSBhcyBlZmZpY2llbnQgYXMgZG9pbmcgdGhpbmdzIGRpcmVjdGx5IGluIHRoZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpIG1ldGhvZCwgYnV0IGl0J3MgdmVyeSBjb252ZW5pZW50IGFuZCBmbGV4aWJsZS5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHdpbGwgYmUgdHdlZW5lZC4gT2Z0ZW4gYSBET00gZWxlbWVudCwgYnV0IG5vdCBhbHdheXMuIEl0IGNvdWxkIGJlIGFueXRoaW5nLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHAgUHJvcGVydHkgdG8gdHdlZW4gKG5hbWUpLiBGb3IgZXhhbXBsZSwgdG8gdHdlZW4gZWxlbWVudC53aWR0aCwgcCB3b3VsZCBiZSBcIndpZHRoXCIuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcn0gcyBTdGFydGluZyBudW1lcmljIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcn0gYyBDaGFuZ2UgaW4gbnVtZXJpYyB2YWx1ZSBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIGVudGlyZSB0d2Vlbi4gRm9yIGV4YW1wbGUsIGlmIGVsZW1lbnQud2lkdGggc3RhcnRzIGF0IDUgYW5kIHNob3VsZCBlbmQgYXQgMTAwLCBjIHdvdWxkIGJlIDk1LlxuXHRcdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBuZXh0IFRoZSBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3QuIElmIG9uZSBpcyBkZWZpbmVkLCB3ZSB3aWxsIGRlZmluZSBpdHMgX3ByZXYgYXMgdGhlIG5ldyBpbnN0YW5jZSwgYW5kIHRoZSBuZXcgaW5zdGFuY2UncyBfbmV4dCB3aWxsIGJlIHBvaW50ZWQgYXQgaXQuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHR5cGUgVGhlIHR5cGUgb2YgQ1NTUHJvcFR3ZWVuIHdoZXJlIC0xID0gYSBub24tdHdlZW5pbmcgdmFsdWUsIDAgPSBhIHN0YW5kYXJkIHNpbXBsZSB0d2VlbiwgMSA9IGEgY29tcGxleCB2YWx1ZSAobGlrZSBvbmUgdGhhdCBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbiBhIGNvbW1hLSBvciBzcGFjZS1kZWxpbWl0ZWQgc3RyaW5nIGxpa2UgYm9yZGVyOlwiMXB4IHNvbGlkIHJlZFwiKSwgYW5kIDIgPSBvbmUgdGhhdCB1c2VzIGEgY3VzdG9tIHNldFJhdGlvIGZ1bmN0aW9uIHRoYXQgZG9lcyBhbGwgb2YgdGhlIHdvcmsgb2YgYXBwbHlpbmcgdGhlIHZhbHVlcyBvbiBlYWNoIHVwZGF0ZS5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gbiBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBvdmVyd3JpdGluZyBwdXJwb3NlcyB3aGljaCBpcyB0eXBpY2FsbHkgdGhlIHNhbWUgYXMgcCBidXQgbm90IGFsd2F5cy4gRm9yIGV4YW1wbGUsIHdlIG1heSBuZWVkIHRvIGNyZWF0ZSBhIHN1YnR3ZWVuIGZvciB0aGUgMm5kIHBhcnQgb2YgYSBcImNsaXA6cmVjdCguLi4pXCIgdHdlZW4gaW4gd2hpY2ggY2FzZSBcInBcIiBtaWdodCBiZSB4czEgYnV0IFwiblwiIGlzIHN0aWxsIFwiY2xpcFwiXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByIElmIHRydWUsIHRoZSB2YWx1ZShzKSBzaG91bGQgYmUgcm91bmRlZFxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwciBQcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBDU1NQcm9wVHdlZW5zIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gYiBCZWdpbm5pbmcgdmFsdWUuIFdlIHN0b3JlIHRoaXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgRVhBQ1RMWSB3aGF0IGl0IHdhcyB3aGVuIHRoZSB0d2VlbiBiZWdhbiB3aXRob3V0IGFueSByaXNrIG9mIGludGVycHJldGF0aW9uIGlzc3Vlcy5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gZSBFbmRpbmcgdmFsdWUuIFdlIHN0b3JlIHRoaXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgRVhBQ1RMWSB3aGF0IHRoZSB1c2VyIGRlZmluZWQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4gd2l0aG91dCBhbnkgcmlzayBvZiBpbnRlcnByZXRhdGlvbiBpc3N1ZXMuXG5cdFx0XHQgKi9cblx0XHRcdENTU1Byb3BUd2VlbiA9IF9pbnRlcm5hbHMuQ1NTUHJvcFR3ZWVuID0gZnVuY3Rpb24odCwgcCwgcywgYywgbmV4dCwgdHlwZSwgbiwgciwgcHIsIGIsIGUpIHtcblx0XHRcdFx0dGhpcy50ID0gdDsgLy90YXJnZXRcblx0XHRcdFx0dGhpcy5wID0gcDsgLy9wcm9wZXJ0eVxuXHRcdFx0XHR0aGlzLnMgPSBzOyAvL3N0YXJ0aW5nIHZhbHVlXG5cdFx0XHRcdHRoaXMuYyA9IGM7IC8vY2hhbmdlIHZhbHVlXG5cdFx0XHRcdHRoaXMubiA9IG4gfHwgcDsgLy9uYW1lIHRoYXQgdGhpcyBDU1NQcm9wVHdlZW4gc2hvdWxkIGJlIGFzc29jaWF0ZWQgdG8gKHVzdWFsbHkgdGhlIHNhbWUgYXMgcCwgYnV0IG5vdCBhbHdheXMgLSBuIGlzIHdoYXQgb3ZlcndyaXRpbmcgbG9va3MgYXQpXG5cdFx0XHRcdGlmICghKHQgaW5zdGFuY2VvZiBDU1NQcm9wVHdlZW4pKSB7XG5cdFx0XHRcdFx0X292ZXJ3cml0ZVByb3BzLnB1c2godGhpcy5uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnIgPSByOyAvL3JvdW5kIChib29sZWFuKVxuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlIHx8IDA7IC8vMCA9IG5vcm1hbCB0d2VlbiwgLTEgPSBub24tdHdlZW5pbmcgKGluIHdoaWNoIGNhc2UgeHMwIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdGFyZ2V0J3MgcHJvcGVydHksIGxpa2UgdHAudFt0cC5wXSA9IHRwLnhzMCksIDEgPSBjb21wbGV4LXZhbHVlIFNwZWNpYWxQcm9wLCAyID0gY3VzdG9tIHNldFJhdGlvKCkgdGhhdCBkb2VzIGFsbCB0aGUgd29ya1xuXHRcdFx0XHRpZiAocHIpIHtcblx0XHRcdFx0XHR0aGlzLnByID0gcHI7XG5cdFx0XHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmIgPSAoYiA9PT0gdW5kZWZpbmVkKSA/IHMgOiBiO1xuXHRcdFx0XHR0aGlzLmUgPSAoZSA9PT0gdW5kZWZpbmVkKSA/IHMgKyBjIDogZTtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWtlcyBhIHRhcmdldCwgdGhlIGJlZ2lubmluZyB2YWx1ZSBhbmQgZW5kaW5nIHZhbHVlIChhcyBzdHJpbmdzKSBhbmQgcGFyc2VzIHRoZW0gaW50byBhIENTU1Byb3BUd2VlbiAocG9zc2libHkgd2l0aCBjaGlsZCBDU1NQcm9wVHdlZW5zKSB0aGF0IGFjY29tbW9kYXRlcyBtdWx0aXBsZSBudW1iZXJzLCBjb2xvcnMsIGNvbW1hLWRlbGltaXRlZCB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGU6XG5cdFx0XHQgKiBzcC5wYXJzZUNvbXBsZXgoZWxlbWVudCwgXCJib3hTaGFkb3dcIiwgXCI1cHggMTBweCAyMHB4IHJnYigyNTUsMTAyLDUxKVwiLCBcIjBweCAwcHggMHB4IHJlZFwiLCB0cnVlLCBcIjBweCAwcHggMHB4IHJnYigwLDAsMCwwKVwiLCBwdCk7XG5cdFx0XHQgKiBJdCB3aWxsIHdhbGsgdGhyb3VnaCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZm9ybWF0IHdpdGggdGhlIHNhbWUgbnVtYmVyIGFuZCB0eXBlIG9mIHZhbHVlcykgYW5kIGZpZ3VyZSBvdXQgd2hpY2ggcGFydHMgYXJlIG51bWJlcnMsIHdoYXQgc3RyaW5ncyBzZXBhcmF0ZSB0aGUgbnVtZXJpYy90d2VlbmFibGUgdmFsdWVzLCBhbmQgdGhlbiBjcmVhdGUgdGhlIENTU1Byb3BUd2VlbnMgYWNjb3JkaW5nbHkuIElmIGEgcGx1Z2luIGlzIGRlZmluZWQsIG5vIGNoaWxkIENTU1Byb3BUd2VlbnMgd2lsbCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGUgZW5kaW5nIHZhbHVlcyB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgXCJkYXRhXCIgcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIENTU1Byb3BUd2VlbiBsaWtlOiB7czotNSwgeG4xOi0xMCwgeG4yOi0yMCwgeG4zOjI1NSwgeG40OjAsIHhuNTowfSBzbyB0aGF0IGl0IGNhbiBiZSBmZWQgdG8gYW55IG90aGVyIHBsdWdpbiBhbmQgaXQnbGwgYmUgcGxhaW4gbnVtZXJpYyB0d2VlbnMgYnV0IHRoZSByZWNvbXBvc2l0aW9uIG9mIHRoZSBjb21wbGV4IHZhbHVlIHdpbGwgYmUgaGFuZGxlZCBpbnNpZGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKS5cblx0XHRcdCAqIElmIGEgc2V0UmF0aW8gaXMgZGVmaW5lZCwgdGhlIHR5cGUgb2YgdGhlIENTU1Byb3BUd2VlbiB3aWxsIGJlIHNldCB0byAyIGFuZCByZWNvbXBvc2l0aW9uIG9mIHRoZSB2YWx1ZXMgd2lsbCBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhhdCBtZXRob2QuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIHR3ZWVuZWRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSB0aGF0IHdpbGwgYmUgdHdlZW5lZCAoaXRzIG5hbWUsIGxpa2UgXCJsZWZ0XCIgb3IgXCJiYWNrZ3JvdW5kQ29sb3JcIiBvciBcImJveFNoYWRvd1wiKVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGIgQmVnaW5uaW5nIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZSBFbmRpbmcgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xycyBJZiB0cnVlLCB0aGUgdmFsdWUgY291bGQgY29udGFpbiBhIGNvbG9yIHZhbHVlIGxpa2UgXCJyZ2IoMjU1LDAsMClcIiBvciBcIiNGMDBcIiBvciBcInJlZFwiLiBUaGUgZGVmYXVsdCBpcyBmYWxzZSwgc28gbm8gY29sb3JzIHdpbGwgYmUgcmVjb2duaXplZCAoYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfE9iamVjdCl9IGRmbHQgVGhlIGRlZmF1bHQgYmVnaW5uaW5nIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgaWYgbm8gdmFsaWQgYmVnaW5uaW5nIHZhbHVlIGlzIGRlZmluZWQgb3IgaWYgdGhlIG51bWJlciBvZiB2YWx1ZXMgaW5zaWRlIHRoZSBjb21wbGV4IGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBkb24ndCBtYXRjaFxuXHRcdFx0ICogQHBhcmFtIHs/Q1NTUHJvcFR3ZWVufSBwdCBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byB0aGlzKS5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHIgUHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHNob3VsZCBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGV4dHJhIHByb3BlcnRpZXMsIHBhc3MgdGhlIHBsdWdpbiBpbnN0YW5jZSBoZXJlLiBJZiBvbmUgaXMgZGVmaW5lZCwgdGhlbiBOTyBzdWJ0d2VlbnMgd2lsbCBiZSBjcmVhdGVkIGZvciBhbnkgZXh0cmEgcHJvcGVydGllcyAodGhlIHByb3BlcnRpZXMgd2lsbCBiZSBjcmVhdGVkIC0ganVzdCBub3QgYWRkaXRpb25hbCBDU1NQcm9wVHdlZW4gaW5zdGFuY2VzIHRvIHR3ZWVuIHRoZW0pIGJlY2F1c2UgdGhlIHBsdWdpbiBpcyBleHBlY3RlZCB0byBkbyBzby4gSG93ZXZlciwgdGhlIGVuZCB2YWx1ZXMgV0lMTCBiZSBwb3B1bGF0ZWQgaW4gdGhlIFwiZGF0YVwiIHByb3BlcnR5LCBsaWtlIHtzOjEwMCwgeG4xOjUwLCB4bjI6MzAwfVxuXHRcdFx0ICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpPX0gc2V0UmF0aW8gSWYgdmFsdWVzIHNob3VsZCBiZSBzZXQgaW4gYSBjdXN0b20gZnVuY3Rpb24gaW5zdGVhZCBvZiBiZWluZyBwaWVjZWQgdG9nZXRoZXIgaW4gYSB0eXBlOjEgKGNvbXBsZXgtdmFsdWUpIENTU1Byb3BUd2VlbiwgZGVmaW5lIHRoYXQgY3VzdG9tIGZ1bmN0aW9uIGhlcmUuXG5cdFx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IFRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHdoaWNoIGluY2x1ZGVzIHRoZSBuZXcgb25lKHMpIGFkZGVkIGJ5IHRoZSBwYXJzZUNvbXBsZXgoKSBjYWxsLlxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDb21wbGV4ID0gQ1NTUGx1Z2luLnBhcnNlQ29tcGxleCA9IGZ1bmN0aW9uKHQsIHAsIGIsIGUsIGNscnMsIGRmbHQsIHB0LCBwciwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwicGFyc2VDb21wbGV4OiBcIitwK1wiLCBiOiBcIitiK1wiLCBlOiBcIitlKTtcblx0XHRcdFx0YiA9IGIgfHwgZGZsdCB8fCBcIlwiO1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIChzZXRSYXRpbyA/IDIgOiAxKSwgbnVsbCwgZmFsc2UsIHByLCBiLCBlKTtcblx0XHRcdFx0ZSArPSBcIlwiOyAvL2Vuc3VyZXMgaXQncyBhIHN0cmluZ1xuXHRcdFx0XHR2YXIgYmEgPSBiLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2JlZ2lubmluZyBhcnJheVxuXHRcdFx0XHRcdGVhID0gZS5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSwgLy9lbmRpbmcgYXJyYXlcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoLFxuXHRcdFx0XHRcdGF1dG9Sb3VuZCA9IChfYXV0b1JvdW5kICE9PSBmYWxzZSksXG5cdFx0XHRcdFx0aSwgeGksIG5pLCBidiwgZXYsIGJudW1zLCBlbnVtcywgYm4sIHJnYmEsIHRlbXAsIGN2LCBzdHI7XG5cdFx0XHRcdGlmIChlLmluZGV4T2YoXCIsXCIpICE9PSAtMSB8fCBiLmluZGV4T2YoXCIsXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdGJhID0gYmEuam9pbihcIiBcIikucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcIiwgXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRlYSA9IGVhLmpvaW4oXCIgXCIpLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCIsIFwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobCAhPT0gZWEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm1pc21hdGNoZWQgZm9ybWF0dGluZyBkZXRlY3RlZCBvbiBcIiArIHAgKyBcIiAoXCIgKyBiICsgXCIgdnMgXCIgKyBlICsgXCIpXCIpO1xuXHRcdFx0XHRcdGJhID0gKGRmbHQgfHwgXCJcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IHNldFJhdGlvO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0YnYgPSBiYVtpXTtcblx0XHRcdFx0XHRldiA9IGVhW2ldO1xuXHRcdFx0XHRcdGJuID0gcGFyc2VGbG9hdChidik7XG5cblx0XHRcdFx0XHQvL2lmIHRoZSB2YWx1ZSBiZWdpbnMgd2l0aCBhIG51bWJlciAobW9zdCBjb21tb24pLiBJdCdzIGZpbmUgaWYgaXQgaGFzIGEgc3VmZml4IGxpa2UgcHhcblx0XHRcdFx0XHRpZiAoYm4gfHwgYm4gPT09IDApIHtcblx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoXCJcIiwgYm4sIF9wYXJzZUNoYW5nZShldiwgYm4pLCBldi5yZXBsYWNlKF9yZWxOdW1FeHAsIFwiXCIpLCAoYXV0b1JvdW5kICYmIGV2LmluZGV4T2YoXCJweFwiKSAhPT0gLTEpLCB0cnVlKTtcblxuXHRcdFx0XHRcdC8vaWYgdGhlIHZhbHVlIGlzIGEgY29sb3Jcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNscnMgJiYgKGJ2LmNoYXJBdCgwKSA9PT0gXCIjXCIgfHwgX2NvbG9yTG9va3VwW2J2XSB8fCBfcmdiaHNsRXhwLnRlc3QoYnYpKSkge1xuXHRcdFx0XHRcdFx0c3RyID0gZXYuY2hhckF0KGV2Lmxlbmd0aCAtIDEpID09PSBcIixcIiA/IFwiKSxcIiA6IFwiKVwiOyAvL2lmIHRoZXJlJ3MgYSBjb21tYSBhdCB0aGUgZW5kLCByZXRhaW4gaXQuXG5cdFx0XHRcdFx0XHRidiA9IF9wYXJzZUNvbG9yKGJ2KTtcblx0XHRcdFx0XHRcdGV2ID0gX3BhcnNlQ29sb3IoZXYpO1xuXHRcdFx0XHRcdFx0cmdiYSA9IChidi5sZW5ndGggKyBldi5sZW5ndGggPiA2KTtcblx0XHRcdFx0XHRcdGlmIChyZ2JhICYmICFfc3VwcG9ydHNPcGFjaXR5ICYmIGV2WzNdID09PSAwKSB7IC8vb2xkZXIgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCksIHNvIGlmIHRoZSBkZXN0aW5hdGlvbiBhbHBoYSBpcyAwLCBqdXN0IHVzZSBcInRyYW5zcGFyZW50XCIgZm9yIHRoZSBlbmQgY29sb3Jcblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gcHQubCA/IFwiIHRyYW5zcGFyZW50XCIgOiBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdFx0XHRcdHB0LmUgPSBwdC5lLnNwbGl0KGVhW2ldKS5qb2luKFwidHJhbnNwYXJlbnRcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIHsgLy9vbGQgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCkuXG5cdFx0XHRcdFx0XHRcdFx0cmdiYSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoKHJnYmEgPyBcInJnYmEoXCIgOiBcInJnYihcIiksIGJ2WzBdLCBldlswXSAtIGJ2WzBdLCBcIixcIiwgdHJ1ZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kWHRyYShcIlwiLCBidlsxXSwgZXZbMV0gLSBidlsxXSwgXCIsXCIsIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIGV2WzJdIC0gYnZbMl0sIChyZ2JhID8gXCIsXCIgOiBzdHIpLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKHJnYmEpIHtcblx0XHRcdFx0XHRcdFx0XHRidiA9IChidi5sZW5ndGggPCA0KSA/IDEgOiBidlszXTtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKFwiXCIsIGJ2LCAoKGV2Lmxlbmd0aCA8IDQpID8gMSA6IGV2WzNdKSAtIGJ2LCBzdHIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJudW1zID0gYnYubWF0Y2goX251bUV4cCk7IC8vZ2V0cyBlYWNoIGdyb3VwIG9mIG51bWJlcnMgaW4gdGhlIGJlZ2lubmluZyB2YWx1ZSBzdHJpbmcgYW5kIGRyb3BzIHRoZW0gaW50byBhbiBhcnJheVxuXG5cdFx0XHRcdFx0XHQvL2lmIG5vIG51bWJlciBpcyBmb3VuZCwgdHJlYXQgaXQgYXMgYSBub24tdHdlZW5pbmcgdmFsdWUgYW5kIGp1c3QgYXBwZW5kIHRoZSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgeHMuXG5cdFx0XHRcdFx0XHRpZiAoIWJudW1zKSB7XG5cdFx0XHRcdFx0XHRcdHB0W1wieHNcIiArIHB0LmxdICs9IHB0LmwgPyBcIiBcIiArIGJ2IDogYnY7XG5cblx0XHRcdFx0XHRcdC8vbG9vcCB0aHJvdWdoIGFsbCB0aGUgbnVtYmVycyB0aGF0IGFyZSBmb3VuZCBhbmQgY29uc3RydWN0IHRoZSBleHRyYSB2YWx1ZXMgb24gdGhlIHB0LlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW51bXMgPSBldi5tYXRjaChfcmVsTnVtRXhwKTsgLy9nZXQgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBlbmQgdmFsdWUgc3RyaW5nIGFuZCBkcm9wIHRoZW0gaW50byBhbiBhcnJheS4gV2UgYWxsb3cgcmVsYXRpdmUgdmFsdWVzIHRvbywgbGlrZSArPTUwIG9yIC09LjVcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnVtcyB8fCBlbnVtcy5sZW5ndGggIT09IGJudW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJtaXNtYXRjaGVkIGZvcm1hdHRpbmcgZGV0ZWN0ZWQgb24gXCIgKyBwICsgXCIgKFwiICsgYiArIFwiIHZzIFwiICsgZSArIFwiKVwiKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmkgPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHhpID0gMDsgeGkgPCBibnVtcy5sZW5ndGg7IHhpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjdiA9IGJudW1zW3hpXTtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wID0gYnYuaW5kZXhPZihjdiwgbmkpO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoYnYuc3Vic3RyKG5pLCB0ZW1wIC0gbmkpLCBOdW1iZXIoY3YpLCBfcGFyc2VDaGFuZ2UoZW51bXNbeGldLCBjdiksIFwiXCIsIChhdXRvUm91bmQgJiYgYnYuc3Vic3RyKHRlbXAgKyBjdi5sZW5ndGgsIDIpID09PSBcInB4XCIpLCAoeGkgPT09IDApKTtcblx0XHRcdFx0XHRcdFx0XHRuaSA9IHRlbXAgKyBjdi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gYnYuc3Vic3RyKG5pKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgcmVsYXRpdmUgdmFsdWVzIChcIis9XCIgb3IgXCItPVwiIHByZWZpeCksIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBlbmRpbmcgdmFsdWUgdG8gZWxpbWluYXRlIHRoZSBwcmVmaXhlcyBhbmQgY29tYmluZSB0aGUgdmFsdWVzIHByb3Blcmx5LlxuXHRcdFx0XHRpZiAoZS5pbmRleE9mKFwiPVwiKSAhPT0gLTEpIGlmIChwdC5kYXRhKSB7XG5cdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQuZGF0YS5zO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhzXCIgKyBpXSArIHB0LmRhdGFbXCJ4blwiICsgaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LmUgPSBzdHIgKyBwdFtcInhzXCIgKyBpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXB0LmwpIHtcblx0XHRcdFx0XHRwdC50eXBlID0gLTE7XG5cdFx0XHRcdFx0cHQueHMwID0gcHQuZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQueGZpcnN0IHx8IHB0O1xuXHRcdFx0fSxcblx0XHRcdGkgPSA5O1xuXG5cblx0XHRwID0gQ1NTUHJvcFR3ZWVuLnByb3RvdHlwZTtcblx0XHRwLmwgPSBwLnByID0gMDsgLy9sZW5ndGggKG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIGxpa2UgeG4xLCB4bjIsIHhuMywgZXRjLlxuXHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRwW1wieG5cIiArIGldID0gMDtcblx0XHRcdHBbXCJ4c1wiICsgaV0gPSBcIlwiO1xuXHRcdH1cblx0XHRwLnhzMCA9IFwiXCI7XG5cdFx0cC5fbmV4dCA9IHAuX3ByZXYgPSBwLnhmaXJzdCA9IHAuZGF0YSA9IHAucGx1Z2luID0gcC5zZXRSYXRpbyA9IHAucnhwID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogQXBwZW5kcyBhbmQgZXh0cmEgdHdlZW5pbmcgdmFsdWUgdG8gYSBDU1NQcm9wVHdlZW4gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyBhbnkgcHJlZml4IGFuZCBzdWZmaXggc3RyaW5ncy4gVGhlIGZpcnN0IGV4dHJhIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBvZiB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gaW5zdGFuY2UsIGJ1dCB0aGVyZWFmdGVyIGFueSBleHRyYXMgYXJlIHN0b3JlZCBpbiB0aGUgeG4xLCB4bjIsIHhuMywgZXRjLiBUaGUgcHJlZml4ZXMgYW5kIHN1ZmZpeGVzIGFyZSBzdG9yZWQgaW4gdGhlIHhzMCwgeHMxLCB4czIsIGV0Yy4gcHJvcGVydGllcy4gRm9yIGV4YW1wbGUsIGlmIEkgd2FsayB0aHJvdWdoIGEgY2xpcCB2YWx1ZSBsaWtlIFwicmVjdCgxMHB4LCA1cHgsIDBweCwgMjBweClcIiwgdGhlIHZhbHVlcyB3b3VsZCBiZSBzdG9yZWQgbGlrZSB0aGlzOlxuXHRcdCAqIHhzMDpcInJlY3QoXCIsIHM6MTAsIHhzMTpcInB4LCBcIiwgeG4xOjUsIHhzMjpcInB4LCBcIiwgeG4yOjAsIHhzMzpcInB4LCBcIiwgeG4zOjIwLCB4bjQ6XCJweClcIlxuXHRcdCAqIEFuZCB0aGV5J2QgYWxsIGdldCBqb2luZWQgdG9nZXRoZXIgd2hlbiB0aGUgQ1NTUGx1Z2luIHJlbmRlcnMgKGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCkuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBwZnggUHJlZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBzIFN0YXJ0aW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHN0YXJ0IGlzIDUgYW5kIHRoZSBlbmQgaXMgMTAwLCB0aGUgY2hhbmdlIHdvdWxkIGJlIDk1LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2Z4IFN1ZmZpeCAoaWYgYW55KVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgUm91bmQgKGlmIHRydWUpLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhZCBJZiB0cnVlLCB0aGlzIGV4dHJhIHZhbHVlIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgdGhlIHByZXZpb3VzIG9uZSBieSBhIHNwYWNlLiBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBleHRyYSBhbmQgcGFkIGlzIHRydWUsIGl0IHdpbGwgYXV0b21hdGljYWxseSBkcm9wIHRoZSBzcGFjZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IHJldHVybnMgaXRzZWxmIHNvIHRoYXQgbXVsdGlwbGUgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci5cblx0XHQgKi9cblx0XHRwLmFwcGVuZFh0cmEgPSBmdW5jdGlvbihwZngsIHMsIGMsIHNmeCwgciwgcGFkKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLFxuXHRcdFx0XHRsID0gcHQubDtcblx0XHRcdHB0W1wieHNcIiArIGxdICs9IChwYWQgJiYgbCkgPyBcIiBcIiArIHBmeCA6IHBmeCB8fCBcIlwiO1xuXHRcdFx0aWYgKCFjKSBpZiAobCAhPT0gMCAmJiAhcHQucGx1Z2luKSB7IC8vdHlwaWNhbGx5IHdlJ2xsIGNvbWJpbmUgbm9uLWNoYW5naW5nIHZhbHVlcyByaWdodCBpbnRvIHRoZSB4cyB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSwgYnV0IHdlIGRvbid0IGNvbWJpbmUgdGhlbSB3aGVuIHRoZXJlJ3MgYSBwbHVnaW4gdGhhdCB3aWxsIGJlIHR3ZWVuaW5nIHRoZSB2YWx1ZXMgYmVjYXVzZSBpdCBtYXkgZGVwZW5kIG9uIHRoZSB2YWx1ZXMgYmVpbmcgc3BsaXQgYXBhcnQsIGxpa2UgZm9yIGEgYmV6aWVyLCBpZiBhIHZhbHVlIGRvZXNuJ3QgY2hhbmdlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgaXRlcmF0aW9uIGJ1dCB0aGVuIGl0IGRvZXMgb24gdGhlIDNyZCwgd2UnbGwgcnVuIGludG8gdHJvdWJsZSBiZWNhdXNlIHRoZXJlJ3Mgbm8geG4gc2xvdCBmb3IgdGhhdCB2YWx1ZSFcblx0XHRcdFx0cHRbXCJ4c1wiICsgbF0gKz0gcyArIChzZnggfHwgXCJcIik7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHRcdHB0LmwrKztcblx0XHRcdHB0LnR5cGUgPSBwdC5zZXRSYXRpbyA/IDIgOiAxO1xuXHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gPSBzZnggfHwgXCJcIjtcblx0XHRcdGlmIChsID4gMCkge1xuXHRcdFx0XHRwdC5kYXRhW1wieG5cIiArIGxdID0gcyArIGM7XG5cdFx0XHRcdHB0LnJ4cFtcInhuXCIgKyBsXSA9IHI7IC8vcm91bmQgZXh0cmEgcHJvcGVydHkgKHdlIG5lZWQgdG8gdGFwIGludG8gdGhpcyBpbiB0aGUgX3BhcnNlVG9Qcm94eSgpIG1ldGhvZClcblx0XHRcdFx0cHRbXCJ4blwiICsgbF0gPSBzO1xuXHRcdFx0XHRpZiAoIXB0LnBsdWdpbikge1xuXHRcdFx0XHRcdHB0LnhmaXJzdCA9IG5ldyBDU1NQcm9wVHdlZW4ocHQsIFwieG5cIiArIGwsIHMsIGMsIHB0LnhmaXJzdCB8fCBwdCwgMCwgcHQubiwgciwgcHQucHIpO1xuXHRcdFx0XHRcdHB0LnhmaXJzdC54czAgPSAwOyAvL2p1c3QgdG8gZW5zdXJlIHRoYXQgdGhlIHByb3BlcnR5IHN0YXlzIG51bWVyaWMgd2hpY2ggaGVscHMgbW9kZXJuIGJyb3dzZXJzIHNwZWVkIHVwIHByb2Nlc3NpbmcuIFJlbWVtYmVyLCBpbiB0aGUgc2V0UmF0aW8oKSBtZXRob2QsIHdlIGRvIHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czAgc28gaWYgcHQueHMwIGlzIFwiXCIgKHRoZSBkZWZhdWx0KSwgaXQnbGwgY2FzdCB0aGUgZW5kIHZhbHVlIGFzIGEgc3RyaW5nLiBXaGVuIGEgcHJvcGVydHkgaXMgYSBudW1iZXIgc29tZXRpbWVzIGFuZCBhIHN0cmluZyBzb21ldGltZXMsIGl0IHByZXZlbnRzIHRoZSBjb21waWxlciBmcm9tIGxvY2tpbmcgaW4gdGhlIGRhdGEgdHlwZSwgc2xvd2luZyB0aGluZ3MgZG93biBzbGlnaHRseS5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0XHRwdC5kYXRhID0ge3M6cyArIGN9O1xuXHRcdFx0cHQucnhwID0ge307XG5cdFx0XHRwdC5zID0gcztcblx0XHRcdHB0LmMgPSBjO1xuXHRcdFx0cHQuciA9IHI7XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEBjb25zdHJ1Y3RvciBBIFNwZWNpYWxQcm9wIGlzIGJhc2ljYWxseSBhIGNzcyBwcm9wZXJ0eSB0aGF0IG5lZWRzIHRvIGJlIHRyZWF0ZWQgaW4gYSBub24tc3RhbmRhcmQgd2F5LCBsaWtlIGlmIGl0IG1heSBjb250YWluIGEgY29tcGxleCB2YWx1ZSBsaWtlIGJveFNoYWRvdzpcIjVweCAxMHB4IDE1cHggcmdiKDI1NSwgMTAyLCA1MSlcIiBvciBpZiBpdCBpcyBhc3NvY2lhdGVkIHdpdGggYW5vdGhlciBwbHVnaW4gbGlrZSBUaHJvd1Byb3BzUGx1Z2luIG9yIEJlemllclBsdWdpbi4gRXZlcnkgU3BlY2lhbFByb3AgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciBwcm9wZXJ0eSBuYW1lIGxpa2UgXCJib3hTaGFkb3dcIiBvciBcInRocm93UHJvcHNcIiBvciBcImJlemllclwiIGFuZCBpdCB3aWxsIGludGVyY2VwdCB0aG9zZSB2YWx1ZXMgaW4gdGhlIHZhcnMgb2JqZWN0IHRoYXQncyBwYXNzZWQgdG8gdGhlIENTU1BsdWdpbiBhbmQgaGFuZGxlIHRoZW0gYWNjb3JkaW5nbHkuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJib3hTaGFkb3dcIiBvciBcInRocm93UHJvcHNcIilcblx0XHQgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZmlndXJhdGlvbiBvcHRpb25zOlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gZGVmYXVsdFZhbHVlOiB0aGUgZGVmYXVsdCB2YWx1ZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VyOiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IG5hbWUgaXMgZm91bmQgaW4gdGhlIHZhcnMuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIENTU1Byb3BUd2VlbiBpbnN0YW5jZSBhbmQgaXQgc2hvdWxkIGVuc3VyZSB0aGF0IGl0IGlzIHByb3Blcmx5IGluc2VydGVkIGludG8gdGhlIGxpbmtlZCBsaXN0LiBJdCB3aWxsIHJlY2VpdmUgNCBwYXJhbXRlcnM6IDEpIFRoZSB0YXJnZXQsIDIpIFRoZSB2YWx1ZSBkZWZpbmVkIGluIHRoZSB2YXJzLCAzKSBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlICh3aG9zZSBfZmlyc3RQVCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGxpbmtlZCBsaXN0KSwgYW5kIDQpIEEgY29tcHV0ZWQgc3R5bGUgb2JqZWN0IGlmIG9uZSB3YXMgY2FsY3VsYXRlZCAodGhpcyBpcyBhIHNwZWVkIG9wdGltaXphdGlvbiB0aGF0IGFsbG93cyByZXRyaWV2YWwgb2Ygc3RhcnRpbmcgdmFsdWVzIHF1aWNrZXIpXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBmb3JtYXR0ZXI6IGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGFueSB2YWx1ZSByZWNlaXZlZCBmb3IgdGhpcyBzcGVjaWFsIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgYm94U2hhZG93IGNvdWxkIHRha2UgXCI1cHggNXB4IHJlZFwiIGFuZCBmb3JtYXQgaXQgdG8gXCI1cHggNXB4IDBweCAwcHggcmVkXCIgc28gdGhhdCBib3RoIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgaGF2ZSBhIGNvbW1vbiBvcmRlciBhbmQgcXVhbnRpdHkgb2YgdmFsdWVzLilcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHByZWZpeDogaWYgdHJ1ZSwgd2UnbGwgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoaXMgcHJvcGVydHkgcmVxdWlyZXMgYSB2ZW5kb3IgcHJlZml4IChsaWtlIFdlYmtpdCBvciBNb3ogb3IgbXMgb3IgTylcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGNvbG9yOiBzZXQgdGhpcyB0byB0cnVlIGlmIHRoZSB2YWx1ZSBmb3IgdGhpcyBTcGVjaWFsUHJvcCBtYXkgY29udGFpbiBjb2xvci1yZWxhdGVkIHZhbHVlcyBsaWtlIHJnYigpLCByZ2JhKCksIGV0Yy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHByaW9yaXR5OiBwcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBTcGVjaWFsUHJvcHMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gbXVsdGk6IGlmIHRydWUsIHRoZSBmb3JtYXR0ZXIgc2hvdWxkIGFjY29tbW9kYXRlIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzLCBsaWtlIGJveFNoYWRvdyBjb3VsZCBoYXZlIG11bHRpcGxlIGJveFNoYWRvd3MgbGlzdGVkIG91dC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGNvbGxhcHNpYmxlOiBpZiB0cnVlLCB0aGUgZm9ybWF0dGVyIHNob3VsZCB0cmVhdCB0aGUgdmFsdWUgbGlrZSBpdCdzIGEgdG9wL3JpZ2h0L2JvdHRvbS9sZWZ0IHZhbHVlIHRoYXQgY291bGQgYmUgY29sbGFwc2VkLCBsaWtlIFwiNXB4XCIgd291bGQgYXBwbHkgdG8gYWxsLCBcIjVweCwgMTBweFwiIHdvdWxkIHVzZSA1cHggZm9yIHRvcC9ib3R0b20gYW5kIDEwcHggZm9yIHJpZ2h0L2xlZnQsIGV0Yy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGtleXdvcmQ6IGEgc3BlY2lhbCBrZXl3b3JkIHRoYXQgY2FuIFtvcHRpb25hbGx5XSBiZSBmb3VuZCBpbnNpZGUgdGhlIHZhbHVlIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KS4gVGhpcyBhbGxvd3MgdXMgdG8gdmFsaWRhdGUgYmVnaW5uaW5nL2VuZGluZyB2YWx1ZXMgdG8gbWFrZSBzdXJlIHRoZXkgbWF0Y2ggKGlmIHRoZSBrZXl3b3JkIGlzIGZvdW5kIGluIG9uZSwgaXQnbGwgYmUgYWRkZWQgdG8gdGhlIG90aGVyIGZvciBjb25zaXN0ZW5jeSBieSBkZWZhdWx0KS5cblx0XHQgKi9cblx0XHR2YXIgU3BlY2lhbFByb3AgPSBmdW5jdGlvbihwLCBvcHRpb25zKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0XHR0aGlzLnAgPSBvcHRpb25zLnByZWZpeCA/IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcCA6IHA7XG5cdFx0XHRcdF9zcGVjaWFsUHJvcHNbcF0gPSBfc3BlY2lhbFByb3BzW3RoaXMucF0gPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IF9nZXRGb3JtYXR0ZXIob3B0aW9ucy5kZWZhdWx0VmFsdWUsIG9wdGlvbnMuY29sb3IsIG9wdGlvbnMuY29sbGFwc2libGUsIG9wdGlvbnMubXVsdGkpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5wYXJzZXIpIHtcblx0XHRcdFx0XHR0aGlzLnBhcnNlID0gb3B0aW9ucy5wYXJzZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jbHJzID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdFx0dGhpcy5tdWx0aSA9IG9wdGlvbnMubXVsdGk7XG5cdFx0XHRcdHRoaXMua2V5d29yZCA9IG9wdGlvbnMua2V5d29yZDtcblx0XHRcdFx0dGhpcy5kZmx0ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdHRoaXMucHIgPSBvcHRpb25zLnByaW9yaXR5IHx8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3Nob3J0Y3V0IGZvciBjcmVhdGluZyBhIG5ldyBTcGVjaWFsUHJvcCB0aGF0IGNhbiBhY2NlcHQgbXVsdGlwbGUgcHJvcGVydGllcyBhcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IChoZWxwcyBtaW5pZmljYXRpb24pLiBkZmx0IGNhbiBiZSBhbiBhcnJheSBmb3IgbXVsdGlwbGUgdmFsdWVzICh3ZSBkb24ndCBkbyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IGJlY2F1c2UgdGhlIGRlZmF1bHQgdmFsdWUgbWF5IGNvbnRhaW4gY29tbWFzLCBsaWtlIHJlY3QoMHB4LDBweCwwcHgsMHB4KSkuIFdlIGF0dGFjaCB0aGlzIG1ldGhvZCB0byB0aGUgU3BlY2lhbFByb3AgY2xhc3Mvb2JqZWN0IGluc3RlYWQgb2YgdXNpbmcgYSBwcml2YXRlIF9jcmVhdGVTcGVjaWFsUHJvcCgpIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiB0YXAgaW50byBpdCBleHRlcm5hbGx5IGlmIG5lY2Vzc2FyeSwgbGlrZSBmcm9tIGFub3RoZXIgcGx1Z2luLlxuXHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wID0gX2ludGVybmFscy5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AgPSBmdW5jdGlvbihwLCBvcHRpb25zLCBkZWZhdWx0cykge1xuXHRcdFx0XHRpZiAodHlwZW9mKG9wdGlvbnMpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHtwYXJzZXI6ZGVmYXVsdHN9OyAvL3RvIG1ha2UgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBCZXppZXJQbHVnaW4gYW5kIFRocm93UHJvcHNQbHVnaW5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYSA9IHAuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGQgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZSxcblx0XHRcdFx0XHRpLCB0ZW1wO1xuXHRcdFx0XHRkZWZhdWx0cyA9IGRlZmF1bHRzIHx8IFtkXTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvcHRpb25zLnByZWZpeCA9IChpID09PSAwICYmIG9wdGlvbnMucHJlZml4KTtcblx0XHRcdFx0XHRvcHRpb25zLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRzW2ldIHx8IGQ7XG5cdFx0XHRcdFx0dGVtcCA9IG5ldyBTcGVjaWFsUHJvcChhW2ldLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly9jcmVhdGVzIGEgcGxhY2Vob2xkZXIgc3BlY2lhbCBwcm9wIGZvciBhIHBsdWdpbiBzbyB0aGF0IHRoZSBwcm9wZXJ0eSBnZXRzIGNhdWdodCB0aGUgZmlyc3QgdGltZSBhIHR3ZWVuIG9mIGl0IGlzIGF0dGVtcHRlZCwgYW5kIGF0IHRoYXQgdGltZSBpdCBtYWtlcyB0aGUgcGx1Z2luIHJlZ2lzdGVyIGl0c2VsZiwgdGh1cyB0YWtpbmcgb3ZlciBmb3IgYWxsIGZ1dHVyZSB0d2VlbnMgb2YgdGhhdCBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgdXMgdG8gbm90IG1hbmRhdGUgdGhhdCB0aGluZ3MgbG9hZCBpbiBhIHBhcnRpY3VsYXIgb3JkZXIgYW5kIGl0IGFsc28gYWxsb3dzIHVzIHRvIGxvZygpIGFuIGVycm9yIHRoYXQgaW5mb3JtcyB0aGUgdXNlciB3aGVuIHRoZXkgYXR0ZW1wdCB0byB0d2VlbiBhbiBleHRlcm5hbCBwbHVnaW4tcmVsYXRlZCBwcm9wZXJ0eSB3aXRob3V0IGxvYWRpbmcgaXRzIC5qcyBmaWxlLlxuXHRcdFx0X3JlZ2lzdGVyUGx1Z2luUHJvcCA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKCFfc3BlY2lhbFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0dmFyIHBsdWdpbk5hbWUgPSBwLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcC5zdWJzdHIoMSkgKyBcIlBsdWdpblwiO1xuXHRcdFx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChwLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0XHRcdHZhciBwbHVnaW5DbGFzcyA9IF9nbG9iYWxzLmNvbS5ncmVlbnNvY2sucGx1Z2luc1twbHVnaW5OYW1lXTtcblx0XHRcdFx0XHRcdGlmICghcGx1Z2luQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0X2xvZyhcIkVycm9yOiBcIiArIHBsdWdpbk5hbWUgKyBcIiBqcyBmaWxlIG5vdCBsb2FkZWQuXCIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwbHVnaW5DbGFzcy5fY3NzUmVnaXN0ZXIoKTtcblx0XHRcdFx0XHRcdHJldHVybiBfc3BlY2lhbFByb3BzW3BdLnBhcnNlKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpO1xuXHRcdFx0XHRcdH19KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXG5cdFx0cCA9IFNwZWNpYWxQcm9wLnByb3RvdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIEFsaWFzIGZvciBfcGFyc2VDb21wbGV4KCkgdGhhdCBhdXRvbWF0aWNhbGx5IHBsdWdzIGluIGNlcnRhaW4gdmFsdWVzIGZvciB0aGlzIFNwZWNpYWxQcm9wLCBsaWtlIGl0cyBwcm9wZXJ0eSBuYW1lLCB3aGV0aGVyIG9yIG5vdCBjb2xvcnMgc2hvdWxkIGJlIHNlbnNlZCwgdGhlIGRlZmF1bHQgdmFsdWUsIGFuZCBwcmlvcml0eS4gSXQgYWxzbyBsb29rcyBmb3IgYW55IGtleXdvcmQgdGhhdCB0aGUgU3BlY2lhbFByb3AgZGVmaW5lcyAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykgYW5kIGVuc3VyZXMgdGhhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHZhbHVlcyBmb3IgU3BlY2lhbFByb3BzIHdoZXJlIG11bHRpIGlzIHRydWUgKGxpa2UgYm94U2hhZG93IGFuZCB0ZXh0U2hhZG93IGNhbiBoYXZlIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QpXG5cdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxvYmplY3QpfSBiIGJlZ2lubmluZyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8b2JqZWN0KX0gZSBlbmRpbmcgKGRlc3RpbmF0aW9uKSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gcHQgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhbm90aGVyIHBsdWdpbiB3aWxsIGJlIHR3ZWVuaW5nIHRoZSBjb21wbGV4IHZhbHVlLCB0aGF0IFR3ZWVuUGx1Z2luIGluc3RhbmNlIGdvZXMgaGVyZS5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gc2V0UmF0aW8gSWYgYSBjdXN0b20gc2V0UmF0aW8oKSBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gaGFuZGxlIHRoaXMgY29tcGxleCB2YWx1ZSwgdGhhdCBnb2VzIGhlcmUuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVuPX0gRmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdCAqL1xuXHRcdHAucGFyc2VDb21wbGV4ID0gZnVuY3Rpb24odCwgYiwgZSwgcHQsIHBsdWdpbiwgc2V0UmF0aW8pIHtcblx0XHRcdHZhciBrd2QgPSB0aGlzLmtleXdvcmQsXG5cdFx0XHRcdGksIGJhLCBlYSwgbCwgYmksIGVpO1xuXHRcdFx0Ly9pZiB0aGlzIFNwZWNpYWxQcm9wJ3MgdmFsdWUgY2FuIGNvbnRhaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgKGxpa2UgYm94U2hhZG93IG9yIHRleHRTaGFkb3cpLCB3ZSBtdXN0IHBhcnNlIHRoZW0gaW4gYSBzcGVjaWFsIHdheSwgYW5kIGxvb2sgZm9yIGEga2V5d29yZCAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykgYW5kIGVuc3VyZSB0aGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBCT1RIIGhhdmUgaXQgaWYgdGhlIGVuZCBkZWZpbmVzIGl0IGFzIHN1Y2guIFdlIGFsc28gbXVzdCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgYW4gZXF1YWwgbnVtYmVyIG9mIHZhbHVlcyBzcGVjaWZpZWQgKHdlIGNhbid0IHR3ZWVuIDEgYm94U2hhZG93IHRvIDMgZm9yIGV4YW1wbGUpXG5cdFx0XHRpZiAodGhpcy5tdWx0aSkgaWYgKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdChlKSB8fCBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QoYikpIHtcblx0XHRcdFx0YmEgPSBiLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0ZWEgPSBlLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdH0gZWxzZSBpZiAoa3dkKSB7XG5cdFx0XHRcdGJhID0gW2JdO1xuXHRcdFx0XHRlYSA9IFtlXTtcblx0XHRcdH1cblx0XHRcdGlmIChlYSkge1xuXHRcdFx0XHRsID0gKGVhLmxlbmd0aCA+IGJhLmxlbmd0aCkgPyBlYS5sZW5ndGggOiBiYS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRiID0gYmFbaV0gPSBiYVtpXSB8fCB0aGlzLmRmbHQ7XG5cdFx0XHRcdFx0ZSA9IGVhW2ldID0gZWFbaV0gfHwgdGhpcy5kZmx0O1xuXHRcdFx0XHRcdGlmIChrd2QpIHtcblx0XHRcdFx0XHRcdGJpID0gYi5pbmRleE9mKGt3ZCk7XG5cdFx0XHRcdFx0XHRlaSA9IGUuaW5kZXhPZihrd2QpO1xuXHRcdFx0XHRcdFx0aWYgKGJpICE9PSBlaSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZWkgPT09IC0xKSB7IC8vaWYgdGhlIGtleXdvcmQgaXNuJ3QgaW4gdGhlIGVuZCB2YWx1ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIGJlZ2lubmluZyBvbmUuXG5cdFx0XHRcdFx0XHRcdFx0YmFbaV0gPSBiYVtpXS5zcGxpdChrd2QpLmpvaW4oXCJcIik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYmkgPT09IC0xKSB7IC8vaWYgdGhlIGtleXdvcmQgaXNuJ3QgaW4gdGhlIGJlZ2lubmluZywgYWRkIGl0LlxuXHRcdFx0XHRcdFx0XHRcdGJhW2ldICs9IFwiIFwiICsga3dkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGIgPSBiYS5qb2luKFwiLCBcIik7XG5cdFx0XHRcdGUgPSBlYS5qb2luKFwiLCBcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX3BhcnNlQ29tcGxleCh0LCB0aGlzLnAsIGIsIGUsIHRoaXMuY2xycywgdGhpcy5kZmx0LCBwdCwgdGhpcy5wciwgcGx1Z2luLCBzZXRSYXRpbyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFjY2VwdHMgYSB0YXJnZXQgYW5kIGVuZCB2YWx1ZSBhbmQgc3BpdHMgYmFjayBhIENTU1Byb3BUd2VlbiB0aGF0IGhhcyBiZWVuIGluc2VydGVkIGludG8gdGhlIENTU1BsdWdpbidzIGxpbmtlZCBsaXN0IGFuZCBjb25mb3JtcyB3aXRoIGFsbCB0aGUgY29udmVudGlvbnMgd2UgdXNlIGludGVybmFsbHksIGxpa2UgdHlwZTotMSwgMCwgMSwgb3IgMiwgc2V0dGluZyB1cCBhbnkgZXh0cmEgcHJvcGVydHkgdHdlZW5zLCBwcmlvcml0eSwgZXRjLiBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZSBhIGJveFNoYWRvdyBTcGVjaWFsUHJvcCBhbmQgY2FsbDpcblx0XHQgKiB0aGlzLl9maXJzdFBUID0gc3AucGFyc2UoZWxlbWVudCwgXCI1cHggMTBweCAyMHB4IHJnYigyNTUwLDEwMiw1MSlcIiwgXCJib3hTaGFkb3dcIiwgdGhpcyk7XG5cdFx0ICogSXQgc2hvdWxkIGZpZ3VyZSBvdXQgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIHRoZSBlbGVtZW50J3MgYm94U2hhZG93LCBjb21wYXJlIGl0IHRvIHRoZSBwcm92aWRlZCBlbmQgdmFsdWUgYW5kIGNyZWF0ZSBhbGwgdGhlIG5lY2Vzc2FyeSBDU1NQcm9wVHdlZW5zIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlcyB0byB0d2VlbiB0aGUgYm94U2hhZG93LiBUaGUgQ1NTUHJvcFR3ZWVuIHRoYXQgZ2V0cyBzcGl0IGJhY2sgc2hvdWxkIGFscmVhZHkgYmUgaW5zZXJ0ZWQgaW50byB0aGUgbGlua2VkIGxpc3QgKHRoZSA0dGggcGFyYW1ldGVyIGlzIHRoZSBjdXJyZW50IGhlYWQsIHNvIHByZXBlbmQgdG8gdGhhdCkuXG5cdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgYmVpbmcgdHdlZW5lZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlIEVuZCB2YWx1ZSBhcyBwcm92aWRlZCBpbiB0aGUgdmFycyBvYmplY3QgKHR5cGljYWxseSBhIHN0cmluZywgYnV0IG5vdCBhbHdheXMgLSBsaWtlIGEgdGhyb3dQcm9wcyB3b3VsZCBiZSBhbiBvYmplY3QpLlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lXG5cdFx0ICogQHBhcmFtIHshQ1NTUGx1Z2lufSBjc3NwIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2UgdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHdlZW4uXG5cdFx0ICogQHBhcmFtIHs/Q1NTUHJvcFR3ZWVufSBwdCBUaGUgQ1NTUHJvcFR3ZWVuIHRoYXQgaXMgdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgbGlua2VkIGxpc3QgKHdlJ2xsIHByZXBlbmQgdG8gaXQpXG5cdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhIHBsdWdpbiB3aWxsIGJlIHVzZWQgdG8gdHdlZW4gdGhlIHBhcnNlZCB2YWx1ZSwgdGhpcyBpcyB0aGUgcGx1Z2luIGluc3RhbmNlLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gdmFycyBPcmlnaW5hbCB2YXJzIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIGZvciBwYXJzaW5nLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gVGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Qgd2hpY2ggaW5jbHVkZXMgdGhlIG5ldyBvbmUocykgYWRkZWQgYnkgdGhlIHBhcnNlKCkgY2FsbC5cblx0XHQgKi9cblx0XHRwLnBhcnNlID0gZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCB0aGlzLnAsIF9jcywgZmFsc2UsIHRoaXMuZGZsdCkpLCB0aGlzLmZvcm1hdChlKSwgcHQsIHBsdWdpbik7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgaW50ZXJjZXB0ZWQgZnJvbSBhbnkgXCJjc3NcIiBvYmplY3RzIGRlZmluZWQgaW4gdHdlZW5zLiBUaGlzIGFsbG93cyB5b3UgdG8gaGFuZGxlIHRoZW0gaG93ZXZlciB5b3Ugd2FudCB3aXRob3V0IENTU1BsdWdpbiBkb2luZyBpdCBmb3IgeW91LiBUaGUgMm5kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgMyBwYXJhbWV0ZXJzOlxuXHRcdCAqICAxKSBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHNob3VsZCBiZSB0d2VlbmVkICh0eXBpY2FsbHkgYSBET00gZWxlbWVudClcblx0XHQgKiAgMikgVGhlIGVuZC9kZXN0aW5hdGlvbiB2YWx1ZSAoY291bGQgYmUgYSBzdHJpbmcsIG51bWJlciwgb2JqZWN0LCBvciB3aGF0ZXZlciB5b3Ugd2FudClcblx0XHQgKiAgMykgVGhlIHR3ZWVuIGluc3RhbmNlICh5b3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGlzLCBidXQgaXQgY2FuIGJlIHVzZWZ1bCBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBsaWtlIHRoZSBkdXJhdGlvbilcblx0XHQgKlxuXHRcdCAqIFRoZW4sIHlvdXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGVhY2ggdGltZSB0aGUgdHdlZW4gZ2V0cyByZW5kZXJlZCwgcGFzc2luZyBhIG51bWVyaWMgXCJyYXRpb1wiIHBhcmFtZXRlciB0byB5b3VyIGZ1bmN0aW9uIHRoYXQgaW5kaWNhdGVzIHRoZSBjaGFuZ2UgZmFjdG9yICh1c3VhbGx5IGJldHdlZW4gMCBhbmQgMSkuIEZvciBleGFtcGxlOlxuXHRcdCAqXG5cdFx0ICogQ1NTUGx1Z2luLnJlZ2lzdGVyU3BlY2lhbFByb3AoXCJteUN1c3RvbVByb3BcIiwgZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHQgKiAgICAgIHZhciBzdGFydCA9IHRhcmdldC5zdHlsZS53aWR0aDtcblx0XHQgKiAgICAgIHJldHVybiBmdW5jdGlvbihyYXRpbykge1xuXHRcdCAqICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSAoc3RhcnQgKyB2YWx1ZSAqIHJhdGlvKSArIFwicHhcIjtcblx0XHQgKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZXQgd2lkdGggdG8gXCIgKyB0YXJnZXQuc3R5bGUud2lkdGgpO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiB9LCAwKTtcblx0XHQgKlxuXHRcdCAqIFRoZW4sIHdoZW4gSSBkbyB0aGlzIHR3ZWVuLCBpdCB3aWxsIHRyaWdnZXIgbXkgc3BlY2lhbCBwcm9wZXJ0eTpcblx0XHQgKlxuXHRcdCAqIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntteUN1c3RvbVByb3A6MTAwfX0pO1xuXHRcdCAqXG5cdFx0ICogSW4gdGhlIGV4YW1wbGUsIG9mIGNvdXJzZSwgd2UncmUganVzdCBjaGFuZ2luZyB0aGUgd2lkdGgsIGJ1dCB5b3UgY2FuIGRvIGFueXRoaW5nIHlvdSB3YW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgKG9yIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzKSB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZCBhbmQgaGFuZGxlZCBieSB5b3VyIGZ1bmN0aW9uLiBGb3IgZXhhbXBsZSwgaWYgSSBkZWZpbmUgXCJteUN1c3RvbVByb3BcIiwgdGhlbiBpdCB3b3VsZCBoYW5kbGUgdGhhdCBwb3J0aW9uIG9mIHRoZSBmb2xsb3dpbmcgdHdlZW46IFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntteUN1c3RvbVByb3A6MTAwfX0pXG5cdFx0ICogQHBhcmFtIHshZnVuY3Rpb24oT2JqZWN0LCBPYmplY3QsIE9iamVjdCwgc3RyaW5nKTpmdW5jdGlvbihudW1iZXIpfSBvbkluaXRUd2VlbiBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdHdlZW4gb2YgdGhpcyBzcGVjaWFsIHByb3BlcnR5IGlzIHBlcmZvcm1lZC4gVGhlIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSA0IHBhcmFtZXRlcnM6IDEpIFRhcmdldCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdHdlZW5lZCwgMikgVmFsdWUgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSB0d2VlbiwgMykgVGhlIHR3ZWVuIGluc3RhbmNlIGl0c2VsZiAocmFyZWx5IHVzZWQpLCBhbmQgNCkgVGhlIHByb3BlcnR5IG5hbWUgdGhhdCdzIGJlaW5nIHR3ZWVuZWQuIFlvdXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUgb2YgdGhlIHR3ZWVuLiBUaGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhIHNpbmdsZSBwYXJhbWV0ZXIgdGhhdCBpcyBhIFwiY2hhbmdlIGZhY3RvclwiIHZhbHVlICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2YgY2hhbmdlIGFzIGEgcmF0aW8uIFlvdSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhlIHZhbHVlcyBhcHByb3ByaWF0ZWx5IGluIHlvdXIgZnVuY3Rpb24uXG5cdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwcmlvcml0eSBQcmlvcml0eSB0aGF0IGhlbHBzIHRoZSBlbmdpbmUgZGV0ZXJtaW5lIHRoZSBvcmRlciBpbiB3aGljaCB0byBzZXQgdGhlIHByb3BlcnRpZXMgKGRlZmF1bHQ6IDApLiBIaWdoZXIgcHJpb3JpdHkgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuXG5cdFx0ICovXG5cdFx0Q1NTUGx1Z2luLnJlZ2lzdGVyU3BlY2lhbFByb3AgPSBmdW5jdGlvbihuYW1lLCBvbkluaXRUd2VlbiwgcHJpb3JpdHkpIHtcblx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChuYW1lLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0dmFyIHJ2ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgMiwgcCwgZmFsc2UsIHByaW9yaXR5KTtcblx0XHRcdFx0cnYucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRydi5zZXRSYXRpbyA9IG9uSW5pdFR3ZWVuKHQsIGUsIGNzc3AuX3R3ZWVuLCBwKTtcblx0XHRcdFx0cmV0dXJuIHJ2O1xuXHRcdFx0fSwgcHJpb3JpdHk6cHJpb3JpdHl9KTtcblx0XHR9O1xuXG5cblxuXG5cblxuXHRcdC8vdHJhbnNmb3JtLXJlbGF0ZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXHRcdENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyID0gX2lzU2FmYXJpOyAvL1NhZmFyaSBoYXMgc29tZSByZW5kZXJpbmcgYnVncyB3aGVuIGFwcGx5aW5nIENTUyB0cmFuc2Zvcm1zIHRvIFNWRyBlbGVtZW50cywgc28gZGVmYXVsdCB0byB1c2luZyB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUgaW5zdGVhZC5cblx0XHR2YXIgX3RyYW5zZm9ybVByb3BzID0gKFwic2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHosc2tld1gsc2tld1kscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxwZXJzcGVjdGl2ZSx4UGVyY2VudCx5UGVyY2VudFwiKS5zcGxpdChcIixcIiksXG5cdFx0XHRfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoXCJ0cmFuc2Zvcm1cIiksIC8vdGhlIEphdmFzY3JpcHQgKGNhbWVsQ2FzZSkgdHJhbnNmb3JtIHByb3BlcnR5LCBsaWtlIG1zVHJhbnNmb3JtLCBXZWJraXRUcmFuc2Zvcm0sIE1velRyYW5zZm9ybSwgb3IgT1RyYW5zZm9ybS5cblx0XHRcdF90cmFuc2Zvcm1Qcm9wQ1NTID0gX3ByZWZpeENTUyArIFwidHJhbnNmb3JtXCIsXG5cdFx0XHRfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoXCJ0cmFuc2Zvcm1PcmlnaW5cIiksXG5cdFx0XHRfc3VwcG9ydHMzRCA9IChfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIikgIT09IG51bGwpLFxuXHRcdFx0VHJhbnNmb3JtID0gX2ludGVybmFscy5UcmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wZXJzcGVjdGl2ZSA9IHBhcnNlRmxvYXQoQ1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSkgfHwgMDtcblx0XHRcdFx0dGhpcy5mb3JjZTNEID0gKENTU1BsdWdpbi5kZWZhdWx0Rm9yY2UzRCA9PT0gZmFsc2UgfHwgIV9zdXBwb3J0czNEKSA/IGZhbHNlIDogQ1NTUGx1Z2luLmRlZmF1bHRGb3JjZTNEIHx8IFwiYXV0b1wiO1xuXHRcdFx0fSxcblx0XHRcdF9TVkdFbGVtZW50ID0gd2luZG93LlNWR0VsZW1lbnQsXG5cdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0cixcblx0XHRcdC8vU29tZSBicm93c2VycyAobGlrZSBGaXJlZm94IGFuZCBJRSkgZG9uJ3QgaG9ub3IgdHJhbnNmb3JtLW9yaWdpbiBwcm9wZXJseSBpbiBTVkcgZWxlbWVudHMsIHNvIHdlIG5lZWQgdG8gbWFudWFsbHkgYWRqdXN0IHRoZSBtYXRyaXggYWNjb3JkaW5nbHkuIFdlIGZlYXR1cmUgZGV0ZWN0IGhlcmUgcmF0aGVyIHRoYW4gYWx3YXlzIGRvaW5nIHRoZSBjb252ZXJzaW9uIGZvciBjZXJ0YWluIGJyb3dzZXJzIGJlY2F1c2UgdGhleSBtYXkgZml4IHRoZSBwcm9ibGVtIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cblxuXHRcdFx0X2NyZWF0ZVNWRyA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRhaW5lciwgYXR0cmlidXRlcykge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdHlwZSksXG5cdFx0XHRcdFx0cmVnID0gLyhbYS16XSkoW0EtWl0pL2csXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIHAucmVwbGFjZShyZWcsIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSwgYXR0cmlidXRlc1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdH0sXG5cdFx0XHRfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0X2ZvcmNlU1ZHVHJhbnNmb3JtQXR0ciA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly9JRSBhbmQgQW5kcm9pZCBzdG9jayBkb24ndCBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIG9uIFNWRyBlbGVtZW50cywgc28gd2UgbXVzdCB3cml0ZSB0aGVtIHRvIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZS4gV2UgcG9wdWxhdGUgdGhpcyB2YXJpYWJsZSBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgbWV0aG9kLCBhbmQgb25seSBpZi93aGVuIHdlIGNvbWUgYWNyb3NzIGFuIFNWRyBlbGVtZW50XG5cdFx0XHRcdHZhciBmb3JjZSA9IF9pZVZlcnMgfHwgKC9BbmRyb2lkL2kudGVzdChfYWdlbnQpICYmICF3aW5kb3cuY2hyb21lKSxcblx0XHRcdFx0XHRzdmcsIHJlY3QsIHdpZHRoO1xuXHRcdFx0XHRpZiAoX2RvYy5jcmVhdGVFbGVtZW50TlMgJiYgIWZvcmNlKSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW55d2F5XG5cdFx0XHRcdFx0c3ZnID0gX2NyZWF0ZVNWRyhcInN2Z1wiLCBfZG9jRWxlbWVudCk7XG5cdFx0XHRcdFx0cmVjdCA9IF9jcmVhdGVTVkcoXCJyZWN0XCIsIHN2Zywge3dpZHRoOjEwMCwgaGVpZ2h0OjUwLCB4OjEwMH0pO1xuXHRcdFx0XHRcdHdpZHRoID0gcmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRcdFx0XHRyZWN0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiNTAlIDUwJVwiO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJzY2FsZVgoMC41KVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKHdpZHRoID09PSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICYmICEoX2lzRmlyZWZveCAmJiBfc3VwcG9ydHMzRCkpOyAvL25vdGU6IEZpcmVmb3ggZmFpbHMgdGhlIHRlc3QgZXZlbiB0aG91Z2ggaXQgZG9lcyBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIGluIDNELiBTaW5jZSB3ZSBjYW4ndCBwdXNoIDNEIHN0dWZmIGludG8gdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIHdlIGZvcmNlIEZpcmVmb3ggdG8gcGFzcyB0aGUgdGVzdCBoZXJlIChhcyBsb25nIGFzIGl0IGRvZXMgdHJ1bHkgc3VwcG9ydCAzRCkuXG5cdFx0XHRcdFx0X2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm9yY2U7XG5cdFx0XHR9KSgpLFxuXHRcdFx0X3BhcnNlU1ZHT3JpZ2luID0gZnVuY3Rpb24oZSwgbG9jYWwsIGRlY29yYXRlZSwgYWJzb2x1dGUpIHtcblx0XHRcdFx0dmFyIGJib3gsIHY7XG5cdFx0XHRcdGlmICghYWJzb2x1dGUgfHwgISh2ID0gYWJzb2x1dGUuc3BsaXQoXCIgXCIpKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRiYm94ID0gZS5nZXRCQm94KCk7XG5cdFx0XHRcdFx0bG9jYWwgPSBfcGFyc2VQb3NpdGlvbihsb2NhbCkuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdHYgPSBbKGxvY2FsWzBdLmluZGV4T2YoXCIlXCIpICE9PSAtMSA/IHBhcnNlRmxvYXQobG9jYWxbMF0pIC8gMTAwICogYmJveC53aWR0aCA6IHBhcnNlRmxvYXQobG9jYWxbMF0pKSArIGJib3gueCxcblx0XHRcdFx0XHRcdCAobG9jYWxbMV0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFsxXSkgLyAxMDAgKiBiYm94LmhlaWdodCA6IHBhcnNlRmxvYXQobG9jYWxbMV0pKSArIGJib3gueV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVjb3JhdGVlLnhPcmlnaW4gPSBwYXJzZUZsb2F0KHZbMF0pO1xuXHRcdFx0XHRkZWNvcmF0ZWUueU9yaWdpbiA9IHBhcnNlRmxvYXQodlsxXSk7XG5cdFx0XHRcdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHYuam9pbihcIiBcIikpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYXJzZXMgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgZm9yIGFuIGVsZW1lbnQsIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCB4LCB5LCB6LCBzY2FsZVgsIHNjYWxlWSwgc2NhbGVaLCByb3RhdGlvbiwgcm90YXRpb25YLCByb3RhdGlvblksIHNrZXdYLCBhbmQgc2tld1kgcHJvcGVydGllcy4gTm90ZTogYnkgZGVmYXVsdCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLCBhbGwgc2tld2luZyBpcyBjb21iaW5lZCBpbnRvIHNrZXdYIGFuZCByb3RhdGlvbiBidXQgc2tld1kgc3RpbGwgaGFzIGEgcGxhY2UgaW4gdGhlIHRyYW5zZm9ybSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVjb3JkIGhvdyBtdWNoIG9mIHRoZSBza2V3IGlzIGF0dHJpYnV0ZWQgdG8gc2tld1ggdnMgc2tld1kuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgYW5kIHNrZXdYIG9mIC0xMC5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBjb21wdXRlZCBzdHlsZSBvYmplY3QgKG9wdGlvbmFsKVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcmVjIGlmIHRydWUsIHRoZSB0cmFuc2Zvcm0gdmFsdWVzIHdpbGwgYmUgcmVjb3JkZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50J3MgX2dzVHJhbnNmb3JtIG9iamVjdCwgbGlrZSB0YXJnZXQuX2dzVHJhbnNmb3JtID0ge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcGFyc2UgaWYgdHJ1ZSwgd2UnbGwgaWdub3JlIGFueSBfZ3NUcmFuc2Zvcm0gdmFsdWVzIHRoYXQgYWxyZWFkeSBleGlzdCBvbiB0aGUgZWxlbWVudCwgYW5kIGZvcmNlIGEgcmVwYXJzaW5nIG9mIHRoZSBjc3MgKGNhbGN1bGF0ZWQgc3R5bGUpXG5cdFx0XHQgKiBAcmV0dXJuIHtvYmplY3R9IG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMvdmFsdWVzIGxpa2Uge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0VHJhbnNmb3JtID0gX2ludGVybmFscy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih0LCBjcywgcmVjLCBwYXJzZSkge1xuXHRcdFx0XHRpZiAodC5fZ3NUcmFuc2Zvcm0gJiYgcmVjICYmICFwYXJzZSkge1xuXHRcdFx0XHRcdHJldHVybiB0Ll9nc1RyYW5zZm9ybTsgLy9pZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBhIF9nc1RyYW5zZm9ybSwgdXNlIHRoYXQuIE5vdGU6IHNvbWUgYnJvd3NlcnMgZG9uJ3QgYWNjdXJhdGVseSByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgc3R5bGUgZm9yIHRoZSB0cmFuc2Zvcm0gKHBhcnRpY3VsYXJseSBmb3IgU1ZHKSwgc28gaXQncyBhbG1vc3QgYWx3YXlzIHNhZmVzdCB0byBqdXN0IHVzZSB0aGUgdmFsdWVzIHdlJ3ZlIGFscmVhZHkgYXBwbGllZCByYXRoZXIgdGhhbiByZS1wYXJzaW5nIHRoaW5ncy5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdG0gPSByZWMgPyB0Ll9nc1RyYW5zZm9ybSB8fCBuZXcgVHJhbnNmb3JtKCkgOiBuZXcgVHJhbnNmb3JtKCksXG5cdFx0XHRcdFx0aW52WCA9ICh0bS5zY2FsZVggPCAwKSwgLy9pbiBvcmRlciB0byBpbnRlcnByZXQgdGhpbmdzIHByb3Blcmx5LCB3ZSBuZWVkIHRvIGtub3cgaWYgdGhlIHVzZXIgYXBwbGllZCBhIG5lZ2F0aXZlIHNjYWxlWCBwcmV2aW91c2x5IHNvIHRoYXQgd2UgY2FuIGFkanVzdCB0aGUgcm90YXRpb24gYW5kIHNrZXdYIGFjY29yZGluZ2x5LiBPdGhlcndpc2UsIGlmIHdlIGFsd2F5cyBpbnRlcnByZXQgYSBmbGlwcGVkIG1hdHJpeCBhcyBhZmZlY3Rpbmcgc2NhbGVZIGFuZCB0aGUgdXNlciBvbmx5IHdhbnRzIHRvIHR3ZWVuIHRoZSBzY2FsZVggb24gbXVsdGlwbGUgc2VxdWVudGlhbCB0d2VlbnMsIGl0IHdvdWxkIGtlZXAgdGhlIG5lZ2F0aXZlIHNjYWxlWSB3aXRob3V0IHRoYXQgYmVpbmcgdGhlIHVzZXIncyBpbnRlbnQuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMixcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0ek9yaWdpbiA9IF9zdXBwb3J0czNEID8gcGFyc2VGbG9hdChfZ2V0U3R5bGUodCwgX3RyYW5zZm9ybU9yaWdpblByb3AsIGNzLCBmYWxzZSwgXCIwIDAgMFwiKS5zcGxpdChcIiBcIilbMl0pIHx8IHRtLnpPcmlnaW4gIHx8IDAgOiAwLFxuXHRcdFx0XHRcdGRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBhcnNlRmxvYXQoQ1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSkgfHwgMCxcblx0XHRcdFx0XHRpc0RlZmF1bHQsIHMsIG0sIGksIG4sIGRlYywgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WDtcblx0XHRcdFx0aWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0cyA9IF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtUHJvcENTUywgY3MsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQuY3VycmVudFN0eWxlKSB7XG5cdFx0XHRcdFx0Ly9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUsIHdlIG5lZWQgdG8gaW50ZXJwcmV0IHRoZSBmaWx0ZXIgcG9ydGlvbiB0aGF0IGlzIGluIHRoZSBmb3JtYXQ6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTYuMTIzMjMzOTk1NzM2NzY2ZS0xNywgTTEyPS0xLCBNMjE9MSwgTTIyPTYuMTIzMjMzOTk1NzM2NzY2ZS0xNywgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpIE5vdGljZSB0aGF0IHdlIG5lZWQgdG8gc3dhcCBiIGFuZCBjIGNvbXBhcmVkIHRvIGEgbm9ybWFsIG1hdHJpeC5cblx0XHRcdFx0XHRzID0gdC5jdXJyZW50U3R5bGUuZmlsdGVyLm1hdGNoKF9pZUdldE1hdHJpeEV4cCk7XG5cdFx0XHRcdFx0cyA9IChzICYmIHMubGVuZ3RoID09PSA0KSA/IFtzWzBdLnN1YnN0cig0KSwgTnVtYmVyKHNbMl0uc3Vic3RyKDQpKSwgTnVtYmVyKHNbMV0uc3Vic3RyKDQpKSwgc1szXS5zdWJzdHIoNCksICh0bS54IHx8IDApLCAodG0ueSB8fCAwKV0uam9pbihcIixcIikgOiBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlzRGVmYXVsdCA9ICghcyB8fCBzID09PSBcIm5vbmVcIiB8fCBzID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiKTtcblx0XHRcdFx0dG0uc3ZnID0gISEoX1NWR0VsZW1lbnQgJiYgdHlwZW9mKHQuZ2V0QkJveCkgPT09IFwiZnVuY3Rpb25cIiAmJiB0LmdldENUTSAmJiAoIXQucGFyZW50Tm9kZSB8fCAodC5wYXJlbnROb2RlLmdldEJCb3ggJiYgdC5wYXJlbnROb2RlLmdldENUTSkpKTsgLy9kb24ndCBqdXN0IHJlbHkgb24gXCJpbnN0YW5jZW9mIF9TVkdFbGVtZW50XCIgYmVjYXVzZSBpZiB0aGUgU1ZHIGlzIGVtYmVkZGVkIHZpYSBhbiBvYmplY3QgdGFnLCBpdCB3b24ndCB3b3JrIChTVkdFbGVtZW50IGlzIG1hcHBlZCB0byBhIGRpZmZlcmVudCBvYmplY3QpXG5cdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmICh0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLmluZGV4T2YoXCJtYXRyaXhcIikgIT09IC0xKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUgNDApIGRvbid0IGNvcnJlY3RseSByZXBvcnQgdHJhbnNmb3JtcyB0aGF0IGFyZSBhcHBsaWVkIGlubGluZSBvbiBhbiBTVkcgZWxlbWVudCAodGhleSBkb24ndCBnZXQgaW5jbHVkZWQgaW4gdGhlIGNvbXB1dGVkIHN0eWxlKSwgc28gd2UgZG91YmxlLWNoZWNrIGhlcmUgYW5kIGFjY2VwdCBtYXRyaXggdmFsdWVzXG5cdFx0XHRcdFx0XHRzID0gdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF07XG5cdFx0XHRcdFx0XHRpc0RlZmF1bHQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCwgX2NzLCBmYWxzZSwgXCI1MCUgNTAlXCIpICsgXCJcIiwgdG0sIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpKTtcblx0XHRcdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0ciA9IENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyIHx8IF9mb3JjZVNWR1RyYW5zZm9ybUF0dHI7XG5cdFx0XHRcdFx0bSA9IHQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgbSAmJiBtLmluZGV4T2YoXCJtYXRyaXhcIikgIT09IC0xKSB7IC8vanVzdCBpbiBjYXNlIHRoZXJlJ3MgYSBcInRyYW5zZm9ybVwiIHZhbHVlIHNwZWNpZmllZCBhcyBhbiBhdHRyaWJ1dGUgaW5zdGVhZCBvZiBDU1Mgc3R5bGUuIE9ubHkgYWNjZXB0IGEgbWF0cml4LCB0aG91Z2guXG5cdFx0XHRcdFx0XHRzID0gbTtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNEZWZhdWx0KSB7XG5cdFx0XHRcdFx0Ly9zcGxpdCB0aGUgbWF0cml4IHZhbHVlcyBvdXQgaW50byBhbiBhcnJheSAobSBmb3IgbWF0cml4KVxuXHRcdFx0XHRcdG0gPSAocyB8fCBcIlwiKS5tYXRjaCgvKD86XFwtfFxcYilbXFxkXFwtXFwuZV0rXFxiL2dpKSB8fCBbXTtcblx0XHRcdFx0XHRpID0gbS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRuID0gTnVtYmVyKG1baV0pO1xuXHRcdFx0XHRcdFx0bVtpXSA9IChkZWMgPSBuIC0gKG4gfD0gMCkpID8gKChkZWMgKiBybmQgKyAoZGVjIDwgMCA/IC0wLjUgOiAwLjUpKSB8IDApIC8gcm5kICsgbiA6IG47IC8vY29udmVydCBzdHJpbmdzIHRvIE51bWJlcnMgYW5kIHJvdW5kIHRvIDUgZGVjaW1hbCBwbGFjZXMgdG8gYXZvaWQgaXNzdWVzIHdpdGggdGlueSBudW1iZXJzLiBSb3VnaGx5IDIweCBmYXN0ZXIgdGhhbiBOdW1iZXIudG9GaXhlZCgpLiBXZSBhbHNvIG11c3QgbWFrZSBzdXJlIHRvIHJvdW5kIGJlZm9yZSBkaXZpZGluZyBzbyB0aGF0IHZhbHVlcyBsaWtlIDAuOTk5OTk5OTk5OSBiZWNvbWUgMSB0byBhdm9pZCBnbGl0Y2hlcyBpbiBicm93c2VyIHJlbmRlcmluZyBhbmQgaW50ZXJwcmV0YXRpb24gb2YgZmxpcHBlZC9yb3RhdGVkIDNEIG1hdHJpY2VzLiBBbmQgZG9uJ3QganVzdCBtdWx0aXBseSB0aGUgbnVtYmVyIGJ5IHJuZCwgZmxvb3IgaXQsIGFuZCB0aGVuIGRpdmlkZSBieSBybmQgYmVjYXVzZSB0aGUgYml0d2lzZSBvcGVyYXRpb25zIG1heCBvdXQgYXQgYSAzMi1iaXQgc2lnbmVkIGludGVnZXIsIHRodXMgaXQgY291bGQgZ2V0IGNsaXBwZWQgYXQgYSByZWxhdGl2ZWx5IGxvdyB2YWx1ZSAobGlrZSAyMiwwMDAuMDAwMDAgZm9yIGV4YW1wbGUpLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobS5sZW5ndGggPT09IDE2KSB7XG5cdFx0XHRcdFx0XHQvL3dlJ2xsIG9ubHkgbG9vayBhdCB0aGVzZSBwb3NpdGlvbi1yZWxhdGVkIDYgdmFyaWFibGVzIGZpcnN0IGJlY2F1c2UgaWYgeC95L3ogYWxsIG1hdGNoLCBpdCdzIHJlbGF0aXZlbHkgc2FmZSB0byBhc3N1bWUgd2UgZG9uJ3QgbmVlZCB0byByZS1wYXJzZSBldmVyeXRoaW5nIHdoaWNoIHJpc2tzIGxvc2luZyBpbXBvcnRhbnQgcm90YXRpb25hbCBpbmZvcm1hdGlvbiAobGlrZSByb3RhdGlvblg6MTgwIHBsdXMgcm90YXRpb25ZOjE4MCB3b3VsZCBsb29rIHRoZSBzYW1lIGFzIHJvdGF0aW9uOjE4MCAtIHRoZXJlJ3Mgbm8gd2F5IHRvIGtub3cgZm9yIHN1cmUgd2hpY2ggZGlyZWN0aW9uIHdhcyB0YWtlbiBiYXNlZCBzb2xlbHkgb24gdGhlIG1hdHJpeDNkKCkgdmFsdWVzKVxuXHRcdFx0XHRcdFx0dmFyIGExMSA9IG1bMF0sIGEyMSA9IG1bMV0sIGEzMSA9IG1bMl0sIGE0MSA9IG1bM10sXG5cdFx0XHRcdFx0XHRcdGExMiA9IG1bNF0sIGEyMiA9IG1bNV0sIGEzMiA9IG1bNl0sIGE0MiA9IG1bN10sXG5cdFx0XHRcdFx0XHRcdGExMyA9IG1bOF0sIGEyMyA9IG1bOV0sIGEzMyA9IG1bMTBdLFxuXHRcdFx0XHRcdFx0XHRhMTQgPSBtWzEyXSwgYTI0ID0gbVsxM10sIGEzNCA9IG1bMTRdLFxuXHRcdFx0XHRcdFx0XHRhNDMgPSBtWzExXSxcblx0XHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGEzMiwgYTMzKSxcblx0XHRcdFx0XHRcdFx0dDEsIHQyLCB0MywgdDQsIGNvcywgc2luO1xuXG5cdFx0XHRcdFx0XHQvL3dlIG1hbnVhbGx5IGNvbXBlbnNhdGUgZm9yIG5vbi16ZXJvIHogY29tcG9uZW50IG9mIHRyYW5zZm9ybU9yaWdpbiB0byB3b3JrIGFyb3VuZCBidWdzIGluIFNhZmFyaVxuXHRcdFx0XHRcdFx0aWYgKHRtLnpPcmlnaW4pIHtcblx0XHRcdFx0XHRcdFx0YTM0ID0gLXRtLnpPcmlnaW47XG5cdFx0XHRcdFx0XHRcdGExNCA9IGExMyphMzQtbVsxMl07XG5cdFx0XHRcdFx0XHRcdGEyNCA9IGEyMyphMzQtbVsxM107XG5cdFx0XHRcdFx0XHRcdGEzNCA9IGEzMyphMzQrdG0uek9yaWdpbi1tWzE0XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHQvL3JvdGF0aW9uWFxuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGEyMipjb3MrYTIzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDMgPSBhMzIqY29zK2EzMypzaW47XG5cdFx0XHRcdFx0XHRcdGExMyA9IGExMiotc2luK2ExMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMyA9IGEzMiotc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0XHRcdGE0MyA9IGE0Miotc2luK2E0Mypjb3M7XG5cdFx0XHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMjIgPSB0Mjtcblx0XHRcdFx0XHRcdFx0YTMyID0gdDM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3JvdGF0aW9uWVxuXHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGExMywgYTMzKTtcblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBhMTEqY29zLWExMypzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIxKmNvcy1hMjMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MyA9IGEzMSpjb3MtYTMzKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIzID0gYTIxKnNpbithMjMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzMgPSBhMzEqc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0XHRcdGE0MyA9IGE0MSpzaW4rYTQzKmNvcztcblx0XHRcdFx0XHRcdFx0YTExID0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0XHRhMzEgPSB0Mztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRpb25aXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTIxLCBhMTEpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdGExMSA9IGExMSpjb3MrYTEyKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zK2EyMipzaW47XG5cdFx0XHRcdFx0XHRcdGEyMiA9IGEyMSotc2luK2EyMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMiA9IGEzMSotc2luK2EzMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodG0ucm90YXRpb25YICYmIE1hdGguYWJzKHRtLnJvdGF0aW9uWCkgKyBNYXRoLmFicyh0bS5yb3RhdGlvbikgPiAzNTkuOSkgeyAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gdG0ucm90YXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblkgKz0gMTgwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0bS5zY2FsZVggPSAoKE1hdGguc3FydChhMTEgKiBhMTEgKyBhMjEgKiBhMjEpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVZID0gKChNYXRoLnNxcnQoYTIyICogYTIyICsgYTIzICogYTIzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdHRtLnNjYWxlWiA9ICgoTWF0aC5zcXJ0KGEzMiAqIGEzMiArIGEzMyAqIGEzMykgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5za2V3WCA9IDA7XG5cdFx0XHRcdFx0XHR0bS5wZXJzcGVjdGl2ZSA9IGE0MyA/IDEgLyAoKGE0MyA8IDApID8gLWE0MyA6IGE0MykgOiAwO1xuXHRcdFx0XHRcdFx0dG0ueCA9IGExNDtcblx0XHRcdFx0XHRcdHRtLnkgPSBhMjQ7XG5cdFx0XHRcdFx0XHR0bS56ID0gYTM0O1xuXHRcdFx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0bS54IC09IHRtLnhPcmlnaW4gLSAodG0ueE9yaWdpbiAqIGExMSAtIHRtLnlPcmlnaW4gKiBhMTIpO1xuXHRcdFx0XHRcdFx0XHR0bS55IC09IHRtLnlPcmlnaW4gLSAodG0ueU9yaWdpbiAqIGEyMSAtIHRtLnhPcmlnaW4gKiBhMjIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICgoIV9zdXBwb3J0czNEIHx8IHBhcnNlIHx8ICFtLmxlbmd0aCB8fCB0bS54ICE9PSBtWzRdIHx8IHRtLnkgIT09IG1bNV0gfHwgKCF0bS5yb3RhdGlvblggJiYgIXRtLnJvdGF0aW9uWSkpICYmICEodG0ueCAhPT0gdW5kZWZpbmVkICYmIF9nZXRTdHlsZSh0LCBcImRpc3BsYXlcIiwgY3MpID09PSBcIm5vbmVcIikpIHsgLy9zb21ldGltZXMgYSA2LWVsZW1lbnQgbWF0cml4IGlzIHJldHVybmVkIGV2ZW4gd2hlbiB3ZSBwZXJmb3JtZWQgM0QgdHJhbnNmb3JtcywgbGlrZSBpZiByb3RhdGlvblggYW5kIHJvdGF0aW9uWSBhcmUgMTgwLiBJbiBjYXNlcyBsaWtlIHRoaXMsIHdlIHN0aWxsIG5lZWQgdG8gaG9ub3IgdGhlIDNEIHRyYW5zZm9ybXMuIElmIHdlIGp1c3QgcmVseSBvbiB0aGUgMkQgaW5mbywgaXQgY291bGQgYWZmZWN0IGhvdyB0aGUgZGF0YSBpcyBpbnRlcnByZXRlZCwgbGlrZSBzY2FsZVkgbWlnaHQgZ2V0IHNldCB0byAtMSBvciByb3RhdGlvbiBjb3VsZCBnZXQgb2Zmc2V0IGJ5IDE4MCBkZWdyZWVzLiBGb3IgZXhhbXBsZSwgZG8gYSBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjE4MCwgcm90YXRpb25ZOjE4MH19KSBhbmQgdGhlbiBsYXRlciwgVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e3JvdGF0aW9uWDowfX0pIGFuZCB3aXRob3V0IHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW4gcGxhY2UsIGl0J2QganVtcCB0byBhIHN0YXRlIG9mIGJlaW5nIHVucm90YXRlZCB3aGVuIHRoZSAybmQgdHdlZW4gc3RhcnRzLiBUaGVuIGFnYWluLCB3ZSBuZWVkIHRvIGhvbm9yIHRoZSBmYWN0IHRoYXQgdGhlIHVzZXIgQ09VTEQgYWx0ZXIgdGhlIHRyYW5zZm9ybXMgb3V0c2lkZSBvZiBDU1NQbHVnaW4sIGxpa2UgYnkgbWFudWFsbHkgYXBwbHlpbmcgbmV3IGNzcywgc28gd2UgdHJ5IHRvIHNlbnNlIHRoYXQgYnkgbG9va2luZyBhdCB4IGFuZCB5IGJlY2F1c2UgaWYgdGhvc2UgY2hhbmdlZCwgd2Uga25vdyB0aGUgY2hhbmdlcyB3ZXJlIG1hZGUgb3V0c2lkZSBDU1NQbHVnaW4gYW5kIHdlIGZvcmNlIGEgcmVpbnRlcnByZXRhdGlvbiBvZiB0aGUgbWF0cml4IHZhbHVlcy4gQWxzbywgaW4gV2Via2l0IGJyb3dzZXJzLCBpZiB0aGUgZWxlbWVudCdzIFwiZGlzcGxheVwiIGlzIFwibm9uZVwiLCBpdHMgY2FsY3VsYXRlZCBzdHlsZSB2YWx1ZSB3aWxsIGFsd2F5cyByZXR1cm4gZW1wdHksIHNvIGlmIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgdGhlIHZhbHVlcyBpbiB0aGUgX2dzVHJhbnNmb3JtIG9iamVjdCwgd2UnbGwganVzdCByZWx5IG9uIHRob3NlLlxuXHRcdFx0XHRcdFx0dmFyIGsgPSAobS5sZW5ndGggPj0gNiksXG5cdFx0XHRcdFx0XHRcdGEgPSBrID8gbVswXSA6IDEsXG5cdFx0XHRcdFx0XHRcdGIgPSBtWzFdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGMgPSBtWzJdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGQgPSBrID8gbVszXSA6IDE7XG5cdFx0XHRcdFx0XHR0bS54ID0gbVs0XSB8fCAwO1xuXHRcdFx0XHRcdFx0dG0ueSA9IG1bNV0gfHwgMDtcblx0XHRcdFx0XHRcdHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0XHRcdFx0XHRcdHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcblx0XHRcdFx0XHRcdHJvdGF0aW9uID0gKGEgfHwgYikgPyBNYXRoLmF0YW4yKGIsIGEpICogX1JBRDJERUcgOiB0bS5yb3RhdGlvbiB8fCAwOyAvL25vdGU6IGlmIHNjYWxlWCBpcyAwLCB3ZSBjYW5ub3QgYWNjdXJhdGVseSBtZWFzdXJlIHJvdGF0aW9uLiBTYW1lIGZvciBza2V3WCB3aXRoIGEgc2NhbGVZIG9mIDAuIFRoZXJlZm9yZSwgd2UgZGVmYXVsdCB0byB0aGUgcHJldmlvdXNseSByZWNvcmRlZCB2YWx1ZSAob3IgemVybyBpZiB0aGF0IGRvZXNuJ3QgZXhpc3QpLlxuXHRcdFx0XHRcdFx0c2tld1ggPSAoYyB8fCBkKSA/IE1hdGguYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogdG0uc2tld1ggfHwgMDtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcblx0XHRcdFx0XHRcdFx0aWYgKGludlgpIHtcblx0XHRcdFx0XHRcdFx0XHRzY2FsZVggKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0c2tld1ggKz0gKHJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0XHRyb3RhdGlvbiArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNjYWxlWSAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRza2V3WCArPSAoc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVggPSBzY2FsZVg7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSBzY2FsZVk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0dG0uc2tld1ggPSBza2V3WDtcblx0XHRcdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvblkgPSB0bS56ID0gMDtcblx0XHRcdFx0XHRcdFx0dG0ucGVyc3BlY3RpdmUgPSBkZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmU7XG5cdFx0XHRcdFx0XHRcdHRtLnNjYWxlWiA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnggLT0gdG0ueE9yaWdpbiAtICh0bS54T3JpZ2luICogYSAtIHRtLnlPcmlnaW4gKiBiKTtcblx0XHRcdFx0XHRcdFx0dG0ueSAtPSB0bS55T3JpZ2luIC0gKHRtLnlPcmlnaW4gKiBkIC0gdG0ueE9yaWdpbiAqIGMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bS56T3JpZ2luID0gek9yaWdpbjtcblx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byAwIGluIHRoZXNlIGNhc2VzLiBUaGUgY29uZGl0aW9uYWwgbG9naWMgaGVyZSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIE1hdGguYWJzKCkuIEFsc28sIGJyb3dzZXJzIHRlbmQgdG8gcmVuZGVyIGEgU0xJR0hUTFkgcm90YXRlZCBvYmplY3QgaW4gYSBmdXp6eSB3YXksIHNvIHdlIG5lZWQgdG8gc25hcCB0byBleGFjdGx5IDAgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdFx0XHRmb3IgKGkgaW4gdG0pIHtcblx0XHRcdFx0XHRcdGlmICh0bVtpXSA8IG1pbikgaWYgKHRtW2ldID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR0bVtpXSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZWQgcm90YXRpb24gb2YgXCIgKyB0LmdldEF0dHJpYnV0ZShcImlkXCIpK1wiOiBcIisodG0ucm90YXRpb25YKStcIiwgXCIrKHRtLnJvdGF0aW9uWSkrXCIsIFwiKyh0bS5yb3RhdGlvbikrXCIsIHNjYWxlOiBcIit0bS5zY2FsZVgrXCIsIFwiK3RtLnNjYWxlWStcIiwgXCIrdG0uc2NhbGVaK1wiLCBwb3NpdGlvbjogXCIrdG0ueCtcIiwgXCIrdG0ueStcIiwgXCIrdG0ueitcIiwgcGVyc3BlY3RpdmU6IFwiK3RtLnBlcnNwZWN0aXZlKTtcblx0XHRcdFx0aWYgKHJlYykge1xuXHRcdFx0XHRcdHQuX2dzVHJhbnNmb3JtID0gdG07IC8vcmVjb3JkIHRvIHRoZSBvYmplY3QncyBfZ3NUcmFuc2Zvcm0gd2hpY2ggd2UgdXNlIHNvIHRoYXQgdHdlZW5zIGNhbiBjb250cm9sIGluZGl2aWR1YWwgcHJvcGVydGllcyBpbmRlcGVuZGVudGx5ICh3ZSBuZWVkIGFsbCB0aGUgcHJvcGVydGllcyB0byBhY2N1cmF0ZWx5IHJlY29tcG9zZSB0aGUgbWF0cml4IGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZClcblx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7IC8vaWYgd2UncmUgc3VwcG9zZWQgdG8gYXBwbHkgdHJhbnNmb3JtcyB0byB0aGUgU1ZHIGVsZW1lbnQncyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgbWFrZSBzdXJlIHRoZXJlIGFyZW4ndCBhbnkgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvciB0aGV5J2xsIG92ZXJyaWRlIHRoZSBhdHRyaWJ1dGUgb25lcy4gQWxzbyBjbGVhciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpZiB3ZSdyZSB1c2luZyBDU1MsIGp1c3QgdG8gYmUgY2xlYW4uXG5cdFx0XHRcdFx0XHRpZiAoX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0pIHtcblx0XHRcdFx0XHRcdFx0X3JlbW92ZVByb3AodC5zdHlsZSwgX3RyYW5zZm9ybVByb3ApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICghX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgdC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcblx0XHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0bTtcblx0XHRcdH0sXG5cblx0XHRcdC8vZm9yIHNldHRpbmcgMkQgdHJhbnNmb3JtcyBpbiBJRTYsIElFNywgYW5kIElFOCAobXVzdCB1c2UgYSBcImZpbHRlclwiIHRvIGVtdWxhdGUgdGhlIGJlaGF2aW9yIG9mIG1vZGVybiBkYXkgYnJvd3NlciB0cmFuc2Zvcm1zKVxuXHRcdFx0X3NldElFVHJhbnNmb3JtUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy5kYXRhLCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3Rcblx0XHRcdFx0XHRhbmcgPSAtdC5yb3RhdGlvbiAqIF9ERUcyUkFELFxuXHRcdFx0XHRcdHNrZXcgPSBhbmcgKyB0LnNrZXdYICogX0RFRzJSQUQsXG5cdFx0XHRcdFx0cm5kID0gMTAwMDAwLFxuXHRcdFx0XHRcdGEgPSAoKE1hdGguY29zKGFuZykgKiB0LnNjYWxlWCAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRiID0gKChNYXRoLnNpbihhbmcpICogdC5zY2FsZVggKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0YyA9ICgoTWF0aC5zaW4oc2tldykgKiAtdC5zY2FsZVkgKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0ZCA9ICgoTWF0aC5jb3Moc2tldykgKiB0LnNjYWxlWSAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRzdHlsZSA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHRjcyA9IHRoaXMudC5jdXJyZW50U3R5bGUsXG5cdFx0XHRcdFx0ZmlsdGVycywgdmFsO1xuXHRcdFx0XHRpZiAoIWNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbCA9IGI7IC8vanVzdCBmb3Igc3dhcHBpbmcgdGhlIHZhcmlhYmxlcyBhbiBpbnZlcnRpbmcgdGhlbSAocmV1c2VkIFwidmFsXCIgdG8gYXZvaWQgY3JlYXRpbmcgYW5vdGhlciB2YXJpYWJsZSBpbiBtZW1vcnkpLiBJRSdzIGZpbHRlciBtYXRyaXggdXNlcyBhIG5vbi1zdGFuZGFyZCBtYXRyaXggY29uZmlndXJhdGlvbiAoYW5nbGUgZ29lcyB0aGUgb3Bwb3NpdGUgd2F5LCBhbmQgYiBhbmQgYyBhcmUgcmV2ZXJzZWQgYW5kIGludmVydGVkKVxuXHRcdFx0XHRiID0gLWM7XG5cdFx0XHRcdGMgPSAtdmFsO1xuXHRcdFx0XHRmaWx0ZXJzID0gY3MuZmlsdGVyO1xuXHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBcIlwiOyAvL3JlbW92ZSBmaWx0ZXJzIHNvIHRoYXQgd2UgY2FuIGFjY3VyYXRlbHkgbWVhc3VyZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHRcblx0XHRcdFx0dmFyIHcgPSB0aGlzLnQub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0aCA9IHRoaXMudC5vZmZzZXRIZWlnaHQsXG5cdFx0XHRcdFx0Y2xpcCA9IChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSxcblx0XHRcdFx0XHRtID0gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT1cIiArIGEgKyBcIiwgTTEyPVwiICsgYiArIFwiLCBNMjE9XCIgKyBjICsgXCIsIE0yMj1cIiArIGQsXG5cdFx0XHRcdFx0b3ggPSB0LnggKyAodyAqIHQueFBlcmNlbnQgLyAxMDApLFxuXHRcdFx0XHRcdG95ID0gdC55ICsgKGggKiB0LnlQZXJjZW50IC8gMTAwKSxcblx0XHRcdFx0XHRkeCwgZHk7XG5cblx0XHRcdFx0Ly9pZiB0cmFuc2Zvcm1PcmlnaW4gaXMgYmVpbmcgdXNlZCwgYWRqdXN0IHRoZSBvZmZzZXQgeCBhbmQgeVxuXHRcdFx0XHRpZiAodC5veCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0ZHggPSAoKHQub3hwKSA/IHcgKiB0Lm94ICogMC4wMSA6IHQub3gpIC0gdyAvIDI7XG5cdFx0XHRcdFx0ZHkgPSAoKHQub3lwKSA/IGggKiB0Lm95ICogMC4wMSA6IHQub3kpIC0gaCAvIDI7XG5cdFx0XHRcdFx0b3ggKz0gZHggLSAoZHggKiBhICsgZHkgKiBiKTtcblx0XHRcdFx0XHRveSArPSBkeSAtIChkeCAqIGMgKyBkeSAqIGQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFjbGlwKSB7XG5cdFx0XHRcdFx0bSArPSBcIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZHggPSAodyAvIDIpO1xuXHRcdFx0XHRcdGR5ID0gKGggLyAyKTtcblx0XHRcdFx0XHQvL3RyYW5zbGF0ZSB0byBlbnN1cmUgdGhhdCB0cmFuc2Zvcm1hdGlvbnMgb2NjdXIgYXJvdW5kIHRoZSBjb3JyZWN0IG9yaWdpbiAoZGVmYXVsdCBpcyBjZW50ZXIpLlxuXHRcdFx0XHRcdG0gKz0gXCIsIER4PVwiICsgKGR4IC0gKGR4ICogYSArIGR5ICogYikgKyBveCkgKyBcIiwgRHk9XCIgKyAoZHkgLSAoZHggKiBjICsgZHkgKiBkKSArIG95KSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdHN0eWxlLmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfaWVTZXRNYXRyaXhFeHAsIG0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlLmZpbHRlciA9IG0gKyBcIiBcIiArIGZpbHRlcnM7IC8vd2UgbXVzdCBhbHdheXMgcHV0IHRoZSB0cmFuc2Zvcm0vbWF0cml4IEZJUlNUIChiZWZvcmUgYWxwaGEob3BhY2l0eT14eCkpIHRvIGF2b2lkIGFuIElFIGJ1ZyB0aGF0IHNsaWNlcyBwYXJ0IG9mIHRoZSBvYmplY3Qgd2hlbiByb3RhdGlvbiBpcyBhcHBsaWVkIHdpdGggYWxwaGEuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2F0IHRoZSBlbmQgb3IgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiwgaWYgdGhlIG1hdHJpeCBpcyBub3JtYWwgKDEsIDAsIDAsIDEpIGFuZCBvcGFjaXR5IGlzIDEwMCAob3IgZG9lc24ndCBleGlzdCksIHJlbW92ZSB0aGUgZmlsdGVyIHRvIGltcHJvdmUgYnJvd3NlciBwZXJmb3JtYW5jZS5cblx0XHRcdFx0aWYgKHYgPT09IDAgfHwgdiA9PT0gMSkgaWYgKGEgPT09IDEpIGlmIChiID09PSAwKSBpZiAoYyA9PT0gMCkgaWYgKGQgPT09IDEpIGlmICghY2xpcCB8fCBtLmluZGV4T2YoXCJEeD0wLCBEeT0wXCIpICE9PSAtMSkgaWYgKCFfb3BhY2l0eUV4cC50ZXN0KGZpbHRlcnMpIHx8IHBhcnNlRmxvYXQoUmVnRXhwLiQxKSA9PT0gMTAwKSBpZiAoZmlsdGVycy5pbmRleE9mKFwiZ3JhZGllbnQoXCIgJiYgZmlsdGVycy5pbmRleE9mKFwiQWxwaGFcIikpID09PSAtMSkge1xuXHRcdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vd2UgbXVzdCBzZXQgdGhlIG1hcmdpbnMgQUZURVIgYXBwbHlpbmcgdGhlIGZpbHRlciBpbiBvcmRlciB0byBhdm9pZCBzb21lIGJ1Z3MgaW4gSUU4IHRoYXQgY291bGQgKGluIHJhcmUgc2NlbmFyaW9zKSBjYXVzZSB0aGVtIHRvIGJlIGlnbm9yZWQgaW50ZXJtaXR0ZW50bHkgKHZpYnJhdGlvbikuXG5cdFx0XHRcdGlmICghY2xpcCkge1xuXHRcdFx0XHRcdHZhciBtdWx0ID0gKF9pZVZlcnMgPCA4KSA/IDEgOiAtMSwgLy9pbiBJbnRlcm5ldCBFeHBsb3JlciA3IGFuZCBiZWZvcmUsIHRoZSBib3ggbW9kZWwgaXMgYnJva2VuLCBjYXVzaW5nIHRoZSBicm93c2VyIHRvIHRyZWF0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFjdHVhbCByb3RhdGVkIGZpbHRlcmVkIGltYWdlIGFzIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGJveCBpdHNlbGYsIGJ1dCBNaWNyb3NvZnQgY29ycmVjdGVkIHRoYXQgaW4gSUU4LiBXZSBtdXN0IHVzZSBhIG5lZ2F0aXZlIG9mZnNldCBpbiBJRTggb24gdGhlIHJpZ2h0L2JvdHRvbVxuXHRcdFx0XHRcdFx0bWFyZywgcHJvcCwgZGlmO1xuXHRcdFx0XHRcdGR4ID0gdC5pZU9mZnNldFggfHwgMDtcblx0XHRcdFx0XHRkeSA9IHQuaWVPZmZzZXRZIHx8IDA7XG5cdFx0XHRcdFx0dC5pZU9mZnNldFggPSBNYXRoLnJvdW5kKCh3IC0gKChhIDwgMCA/IC1hIDogYSkgKiB3ICsgKGIgPCAwID8gLWIgOiBiKSAqIGgpKSAvIDIgKyBveCk7XG5cdFx0XHRcdFx0dC5pZU9mZnNldFkgPSBNYXRoLnJvdW5kKChoIC0gKChkIDwgMCA/IC1kIDogZCkgKiBoICsgKGMgPCAwID8gLWMgOiBjKSAqIHcpKSAvIDIgKyBveSk7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdFx0cHJvcCA9IF9tYXJnaW5zW2ldO1xuXHRcdFx0XHRcdFx0bWFyZyA9IGNzW3Byb3BdO1xuXHRcdFx0XHRcdFx0Ly93ZSBuZWVkIHRvIGdldCB0aGUgY3VycmVudCBtYXJnaW4gaW4gY2FzZSBpdCBpcyBiZWluZyB0d2VlbmVkIHNlcGFyYXRlbHkgKHdlIHdhbnQgdG8gcmVzcGVjdCB0aGF0IHR3ZWVuJ3MgY2hhbmdlcylcblx0XHRcdFx0XHRcdHZhbCA9IChtYXJnLmluZGV4T2YoXCJweFwiKSAhPT0gLTEpID8gcGFyc2VGbG9hdChtYXJnKSA6IF9jb252ZXJ0VG9QaXhlbHModGhpcy50LCBwcm9wLCBwYXJzZUZsb2F0KG1hcmcpLCBtYXJnLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIikpIHx8IDA7XG5cdFx0XHRcdFx0XHRpZiAodmFsICE9PSB0W3Byb3BdKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IChpIDwgMikgPyAtdC5pZU9mZnNldFggOiAtdC5pZU9mZnNldFk7IC8vaWYgYW5vdGhlciB0d2VlbiBpcyBjb250cm9sbGluZyBhIG1hcmdpbiwgd2UgY2Fubm90IG9ubHkgYXBwbHkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIGllT2Zmc2V0cywgc28gd2UgZXNzZW50aWFsbHkgemVyby1vdXQgdGhlIGR4IGFuZCBkeSBoZXJlIGluIHRoYXQgY2FzZS4gV2UgcmVjb3JkIHRoZSBtYXJnaW4ocykgbGF0ZXIgc28gdGhhdCB3ZSBjYW4ga2VlcCBjb21wYXJpbmcgdGhlbSwgbWFraW5nIHRoaXMgY29kZSB2ZXJ5IGZsZXhpYmxlLlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKGkgPCAyKSA/IGR4IC0gdC5pZU9mZnNldFggOiBkeSAtIHQuaWVPZmZzZXRZO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3R5bGVbcHJvcF0gPSAodFtwcm9wXSA9IE1hdGgucm91bmQoIHZhbCAtIGRpZiAqICgoaSA9PT0gMCB8fCBpID09PSAyKSA/IDEgOiBtdWx0KSApKSArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qIHRyYW5zbGF0ZXMgYSBzdXBlciBzbWFsbCBkZWNpbWFsIHRvIGEgc3RyaW5nIFdJVEhPVVQgc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0X3NhZmVEZWNpbWFsID0gZnVuY3Rpb24obikge1xuXHRcdFx0XHR2YXIgcyA9IChuIDwgMCA/IC1uIDogbikgKyBcIlwiLFxuXHRcdFx0XHRcdGEgPSBzLnNwbGl0KFwiZS1cIik7XG5cdFx0XHRcdHJldHVybiAobiA8IDAgPyBcIi0wLlwiIDogXCIwLlwiKSArIG5ldyBBcnJheShwYXJzZUludChhWzFdLCAxMCkgfHwgMCkuam9pbihcIjBcIikgKyBhWzBdLnNwbGl0KFwiLlwiKS5qb2luKFwiXCIpO1xuXHRcdFx0fSxcblx0XHRcdCovXG5cblx0XHRcdF9zZXQzRFRyYW5zZm9ybVJhdGlvID0gX2ludGVybmFscy5zZXQzRFRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0YW5nbGUgPSB0LnJvdGF0aW9uICogX0RFRzJSQUQsXG5cdFx0XHRcdFx0c3ggPSB0LnNjYWxlWCxcblx0XHRcdFx0XHRzeSA9IHQuc2NhbGVZLFxuXHRcdFx0XHRcdHN6ID0gdC5zY2FsZVosXG5cdFx0XHRcdFx0eCA9IHQueCxcblx0XHRcdFx0XHR5ID0gdC55LFxuXHRcdFx0XHRcdHogPSB0LnosXG5cdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSB0LnBlcnNwZWN0aXZlLFxuXHRcdFx0XHRcdGExMSwgYTEyLCBhMTMsIGEyMSwgYTIyLCBhMjMsIGEzMSwgYTMyLCBhMzMsIGE0MSwgYTQyLCBhNDMsXG5cdFx0XHRcdFx0ek9yaWdpbiwgbWluLCBjb3MsIHNpbiwgdDEsIHQyLCB0cmFuc2Zvcm0sIGNvbW1hLCB6ZXJvO1xuXHRcdFx0XHRpZiAodiA9PT0gMSB8fCB2ID09PSAwIHx8ICF0LmZvcmNlM0QpIGlmICh0LmZvcmNlM0QgIT09IHRydWUpIGlmICghdC5yb3RhdGlvblkgJiYgIXQucm90YXRpb25YICYmIHN6ID09PSAxICYmICFwZXJzcGVjdGl2ZSAmJiAheiAmJiAodGhpcy50d2Vlbi5fdG90YWxUaW1lID09PSB0aGlzLnR3ZWVuLl90b3RhbER1cmF0aW9uIHx8ICF0aGlzLnR3ZWVuLl90b3RhbFRpbWUpKSB7IC8vb24gdGhlIGZpbmFsIHJlbmRlciAod2hpY2ggY291bGQgYmUgMCBmb3IgYSBmcm9tIHR3ZWVuKSwgaWYgdGhlcmUgYXJlIG5vIDNEIGFzcGVjdHMsIHJlbmRlciBpbiAyRCB0byBmcmVlIHVwIG1lbW9yeSBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZSBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzLiBDaGVjayB0aGUgdHdlZW4ncyB0b3RhbFRpbWUvdG90YWxEdXJhdGlvbiB0b28gaW4gb3JkZXIgdG8gbWFrZSBzdXJlIGl0IGRvZXNuJ3QgaGFwcGVuIGJldHdlZW4gcmVwZWF0cyBpZiBpdCdzIGEgcmVwZWF0aW5nIHR3ZWVuLlxuXHRcdFx0XHRcdF9zZXQyRFRyYW5zZm9ybVJhdGlvLmNhbGwodGhpcywgdik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNGaXJlZm94KSB7XG5cdFx0XHRcdFx0bWluID0gMC4wMDAxO1xuXHRcdFx0XHRcdGlmIChzeCA8IG1pbiAmJiBzeCA+IC1taW4pIHsgLy9GaXJlZm94IGhhcyBhIGJ1ZyAoYXQgbGVhc3QgaW4gdjI1KSB0aGF0IGNhdXNlcyBpdCB0byByZW5kZXIgdGhlIHRyYW5zcGFyZW50IHBhcnQgb2YgMzItYml0IFBORyBpbWFnZXMgYXMgYmxhY2sgd2hlbiBkaXNwbGF5ZWQgaW5zaWRlIGFuIGlmcmFtZSBhbmQgdGhlIDNEIHNjYWxlIGlzIHZlcnkgc21hbGwgYW5kIGRvZXNuJ3QgY2hhbmdlIHN1ZmZpY2llbnRseSBlbm91Z2ggYmV0d2VlbiByZW5kZXJzIChsaWtlIGlmIHlvdSB1c2UgYSBQb3dlcjQuZWFzZUluT3V0IHRvIHNjYWxlIGZyb20gMCB0byAxIHdoZXJlIHRoZSBiZWdpbm5pbmcgdmFsdWVzIG9ubHkgY2hhbmdlIGEgdGlueSBhbW91bnQgdG8gYmVnaW4gdGhlIHR3ZWVuIGJlZm9yZSBhY2NlbGVyYXRpbmcpLiBJbiB0aGlzIGNhc2UsIHdlIGZvcmNlIHRoZSBzY2FsZSB0byBiZSAwLjAwMDAyIGluc3RlYWQgd2hpY2ggaXMgdmlzdWFsbHkgdGhlIHNhbWUgYnV0IHdvcmtzIGFyb3VuZCB0aGUgRmlyZWZveCBpc3N1ZS5cblx0XHRcdFx0XHRcdHN4ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc3kgPCBtaW4gJiYgc3kgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRzeSA9IHN6ID0gMC4wMDAwMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBlcnNwZWN0aXZlICYmICF0LnogJiYgIXQucm90YXRpb25YICYmICF0LnJvdGF0aW9uWSkgeyAvL0ZpcmVmb3ggaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGVsZW1lbnRzIHRvIGhhdmUgYW4gb2RkIHN1cGVyLXRoaW4sIGJyb2tlbi9kb3R0ZWQgYmxhY2sgYm9yZGVyIG9uIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIHBlcnNwZWN0aXZlIHNldCBidXQgYXJlbid0IHV0aWxpemluZyAzRCBzcGFjZSAobm8gcm90YXRpb25YLCByb3RhdGlvblksIG9yIHopLlxuXHRcdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5nbGUgfHwgdC5za2V3WCkge1xuXHRcdFx0XHRcdGNvcyA9IGExMSA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBhMjEgPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0aWYgKHQuc2tld1gpIHtcblx0XHRcdFx0XHRcdGFuZ2xlIC09IHQuc2tld1ggKiBfREVHMlJBRDtcblx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGlmICh0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4odC5za2V3WCAqIF9ERUcyUkFEKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnNxcnQoMSArIHQxICogdDEpO1xuXHRcdFx0XHRcdFx0XHRjb3MgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdHNpbiAqPSB0MTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YTEyID0gLXNpbjtcblx0XHRcdFx0XHRhMjIgPSBjb3M7XG5cblx0XHRcdFx0fSBlbHNlIGlmICghdC5yb3RhdGlvblkgJiYgIXQucm90YXRpb25YICYmIHN6ID09PSAxICYmICFwZXJzcGVjdGl2ZSAmJiAhdC5zdmcpIHsgLy9pZiB3ZSdyZSBvbmx5IHRyYW5zbGF0aW5nIGFuZC9vciAyRCBzY2FsaW5nLCB0aGlzIGlzIGZhc3Rlci4uLlxuXHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIHRyYW5zbGF0ZTNkKFwiIDogXCJ0cmFuc2xhdGUzZChcIikgKyB4ICsgXCJweCxcIiArIHkgKyBcInB4LFwiICsgeiArXCJweClcIiArICgoc3ggIT09IDEgfHwgc3kgIT09IDEpID8gXCIgc2NhbGUoXCIgKyBzeCArIFwiLFwiICsgc3kgKyBcIilcIiA6IFwiXCIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhMTEgPSBhMjIgPSAxO1xuXHRcdFx0XHRcdGExMiA9IGEyMSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gS0VZICBJTkRFWCAgIEFGRkVDVFNcblx0XHRcdFx0Ly8gYTExICAwICAgICAgIHJvdGF0aW9uLCByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMjEgIDEgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEzMSAgMiAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhNDEgIDMgICAgICAgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTEyICA0ICAgICAgIHJvdGF0aW9uLCBza2V3WCwgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTIyICA1ICAgICAgIHJvdGF0aW9uLCBza2V3WCwgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTMyICA2ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGE0MiAgNyAgICAgICByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMTMgIDggICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMjMgIDkgICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMzMgIDEwICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHNjYWxlWlxuXHRcdFx0XHQvLyBhNDMgIDExICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHBlcnNwZWN0aXZlLCBzY2FsZVpcblx0XHRcdFx0Ly8gYTE0ICAxMiAgICAgIHgsIHpPcmlnaW4sIHN2Z09yaWdpblxuXHRcdFx0XHQvLyBhMjQgIDEzICAgICAgeSwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEzNCAgMTQgICAgICB6LCB6T3JpZ2luXG5cdFx0XHRcdC8vIGE0NCAgMTVcblx0XHRcdFx0Ly8gcm90YXRpb246IE1hdGguYXRhbjIoYTIxLCBhMTEpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWTogTWF0aC5hdGFuMihhMTMsIGEzMykgKG9yIE1hdGguYXRhbjIoYTEzLCBhMTEpKVxuXHRcdFx0XHQvLyByb3RhdGlvblg6IE1hdGguYXRhbjIoYTMyLCBhMzMpXG5cdFx0XHRcdGEzMyA9IDE7XG5cdFx0XHRcdGExMyA9IGEyMyA9IGEzMSA9IGEzMiA9IGE0MSA9IGE0MiA9IDA7XG5cdFx0XHRcdGE0MyA9IChwZXJzcGVjdGl2ZSkgPyAtMSAvIHBlcnNwZWN0aXZlIDogMDtcblx0XHRcdFx0ek9yaWdpbiA9IHQuek9yaWdpbjtcblx0XHRcdFx0bWluID0gMC4wMDAwMDE7IC8vdGhyZXNob2xkIGJlbG93IHdoaWNoIGJyb3dzZXJzIHVzZSBzY2llbnRpZmljIG5vdGF0aW9uIHdoaWNoIHdvbid0IHdvcmsuXG5cdFx0XHRcdGNvbW1hID0gXCIsXCI7XG5cdFx0XHRcdHplcm8gPSBcIjBcIjtcblx0XHRcdFx0YW5nbGUgPSB0LnJvdGF0aW9uWSAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGEzMSA9IC1zaW47XG5cdFx0XHRcdFx0YTQxID0gYTQzKi1zaW47XG5cdFx0XHRcdFx0YTEzID0gYTExKnNpbjtcblx0XHRcdFx0XHRhMjMgPSBhMjEqc2luO1xuXHRcdFx0XHRcdGEzMyA9IGNvcztcblx0XHRcdFx0XHRhNDMgKj0gY29zO1xuXHRcdFx0XHRcdGExMSAqPSBjb3M7XG5cdFx0XHRcdFx0YTIxICo9IGNvcztcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmdsZSA9IHQucm90YXRpb25YICogX0RFRzJSQUQ7XG5cdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0dDEgPSBhMTIqY29zK2ExMypzaW47XG5cdFx0XHRcdFx0dDIgPSBhMjIqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0YTMyID0gYTMzKnNpbjtcblx0XHRcdFx0XHRhNDIgPSBhNDMqc2luO1xuXHRcdFx0XHRcdGExMyA9IGExMiotc2luK2ExMypjb3M7XG5cdFx0XHRcdFx0YTIzID0gYTIyKi1zaW4rYTIzKmNvcztcblx0XHRcdFx0XHRhMzMgPSBhMzMqY29zO1xuXHRcdFx0XHRcdGE0MyA9IGE0Mypjb3M7XG5cdFx0XHRcdFx0YTEyID0gdDE7XG5cdFx0XHRcdFx0YTIyID0gdDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN6ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTEzKj1zejtcblx0XHRcdFx0XHRhMjMqPXN6O1xuXHRcdFx0XHRcdGEzMyo9c3o7XG5cdFx0XHRcdFx0YTQzKj1zejtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3kgIT09IDEpIHtcblx0XHRcdFx0XHRhMTIqPXN5O1xuXHRcdFx0XHRcdGEyMio9c3k7XG5cdFx0XHRcdFx0YTMyKj1zeTtcblx0XHRcdFx0XHRhNDIqPXN5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeCAhPT0gMSkge1xuXHRcdFx0XHRcdGExMSo9c3g7XG5cdFx0XHRcdFx0YTIxKj1zeDtcblx0XHRcdFx0XHRhMzEqPXN4O1xuXHRcdFx0XHRcdGE0MSo9c3g7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoek9yaWdpbiB8fCB0LnN2Zykge1xuXHRcdFx0XHRcdGlmICh6T3JpZ2luKSB7XG5cdFx0XHRcdFx0XHR4ICs9IGExMyotek9yaWdpbjtcblx0XHRcdFx0XHRcdHkgKz0gYTIzKi16T3JpZ2luO1xuXHRcdFx0XHRcdFx0eiArPSBhMzMqLXpPcmlnaW4rek9yaWdpbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHQuc3ZnKSB7IC8vZHVlIHRvIGJ1Z3MgaW4gc29tZSBicm93c2Vycywgd2UgbmVlZCB0byBtYW5hZ2UgdGhlIHRyYW5zZm9ybS1vcmlnaW4gb2YgU1ZHIG1hbnVhbGx5XG5cdFx0XHRcdFx0XHR4ICs9IHQueE9yaWdpbiAtICh0LnhPcmlnaW4gKiBhMTEgKyB0LnlPcmlnaW4gKiBhMTIpO1xuXHRcdFx0XHRcdFx0eSArPSB0LnlPcmlnaW4gLSAodC54T3JpZ2luICogYTIxICsgdC55T3JpZ2luICogYTIyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHggPCBtaW4gJiYgeCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHggPSB6ZXJvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeSA8IG1pbiAmJiB5ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eSA9IHplcm87XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh6IDwgbWluICYmIHogPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR6ID0gMDsgLy9kb24ndCB1c2Ugc3RyaW5nIGJlY2F1c2Ugd2UgY2FsY3VsYXRlIHBlcnNwZWN0aXZlIGxhdGVyIGFuZCBuZWVkIHRoZSBudW1iZXIuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9vcHRpbWl6ZWQgd2F5IG9mIGNvbmNhdGVuYXRpbmcgYWxsIHRoZSB2YWx1ZXMgaW50byBhIHN0cmluZy4gSWYgd2UgZG8gaXQgYWxsIGluIG9uZSBzaG90LCBpdCdzIHNsb3dlciBiZWNhdXNlIG9mIHRoZSB3YXkgYnJvd3NlcnMgaGF2ZSB0byBjcmVhdGUgdGVtcCBzdHJpbmdzIGFuZCB0aGUgd2F5IGl0IGFmZmVjdHMgbWVtb3J5LiBJZiB3ZSBkbyBpdCBwaWVjZS1ieS1waWVjZSB3aXRoICs9LCBpdCdzIGEgYml0IHNsb3dlciB0b28uIFdlIGZvdW5kIHRoYXQgZG9pbmcgaXQgaW4gdGhlc2Ugc2l6ZWQgY2h1bmtzIHdvcmtzIGJlc3Qgb3ZlcmFsbDpcblx0XHRcdFx0dHJhbnNmb3JtID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4M2QoXCIgOiBcIm1hdHJpeDNkKFwiKTtcblx0XHRcdFx0dHJhbnNmb3JtICs9ICgoYTExIDwgbWluICYmIGExMSA+IC1taW4pID8gemVybyA6IGExMSkgKyBjb21tYSArICgoYTIxIDwgbWluICYmIGEyMSA+IC1taW4pID8gemVybyA6IGEyMSkgKyBjb21tYSArICgoYTMxIDwgbWluICYmIGEzMSA+IC1taW4pID8gemVybyA6IGEzMSk7XG5cdFx0XHRcdHRyYW5zZm9ybSArPSBjb21tYSArICgoYTQxIDwgbWluICYmIGE0MSA+IC1taW4pID8gemVybyA6IGE0MSkgKyBjb21tYSArICgoYTEyIDwgbWluICYmIGExMiA+IC1taW4pID8gemVybyA6IGExMikgKyBjb21tYSArICgoYTIyIDwgbWluICYmIGEyMiA+IC1taW4pID8gemVybyA6IGEyMik7XG5cdFx0XHRcdGlmICh0LnJvdGF0aW9uWCB8fCB0LnJvdGF0aW9uWSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAob2Z0ZW4gdGhlcmUncyBubyByb3RhdGlvblggb3Igcm90YXRpb25ZLCBzbyB3ZSBjYW4gc2tpcCB0aGVzZSBjYWxjdWxhdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMzIgPCBtaW4gJiYgYTMyID4gLW1pbikgPyB6ZXJvIDogYTMyKSArIGNvbW1hICsgKChhNDIgPCBtaW4gJiYgYTQyID4gLW1pbikgPyB6ZXJvIDogYTQyKSArIGNvbW1hICsgKChhMTMgPCBtaW4gJiYgYTEzID4gLW1pbikgPyB6ZXJvIDogYTEzKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEyMyA8IG1pbiAmJiBhMjMgPiAtbWluKSA/IHplcm8gOiBhMjMpICsgY29tbWEgKyAoKGEzMyA8IG1pbiAmJiBhMzMgPiAtbWluKSA/IHplcm8gOiBhMzMpICsgY29tbWEgKyAoKGE0MyA8IG1pbiAmJiBhNDMgPiAtbWluKSA/IHplcm8gOiBhNDMpICsgY29tbWE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IFwiLDAsMCwwLDAsMSwwLFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zZm9ybSArPSB4ICsgY29tbWEgKyB5ICsgY29tbWEgKyB6ICsgY29tbWEgKyAocGVyc3BlY3RpdmUgPyAoMSArICgteiAvIHBlcnNwZWN0aXZlKSkgOiAxKSArIFwiKVwiO1xuXG5cdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXQyRFRyYW5zZm9ybVJhdGlvID0gX2ludGVybmFscy5zZXQyRFRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0dGFyZyA9IHRoaXMudCxcblx0XHRcdFx0XHRzdHlsZSA9IHRhcmcuc3R5bGUsXG5cdFx0XHRcdFx0eCA9IHQueCxcblx0XHRcdFx0XHR5ID0gdC55LFxuXHRcdFx0XHRcdGFuZywgc2tldywgcm5kLCBzeCwgc3ksIGEsIGIsIGMsIGQsIG1hdHJpeCwgbWluLCB0MTtcblx0XHRcdFx0aWYgKCh0LnJvdGF0aW9uWCB8fCB0LnJvdGF0aW9uWSB8fCB0LnogfHwgdC5mb3JjZTNEID09PSB0cnVlIHx8ICh0LmZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHYgIT09IDEgJiYgdiAhPT0gMCkpICYmICEodC5zdmcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpICYmIF9zdXBwb3J0czNEKSB7IC8vaWYgYSAzRCB0d2VlbiBiZWdpbnMgd2hpbGUgYSAyRCBvbmUgaXMgcnVubmluZywgd2UgbmVlZCB0byBraWNrIHRoZSByZW5kZXJpbmcgb3ZlciB0byB0aGUgM0QgbWV0aG9kLiBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHlveW8taW5nLCBpbmZpbml0ZWx5IHJlcGVhdGluZyBzY2FsZSB0d2VlbiBydW5uaW5nLCBhbmQgdGhlbiB0aGUgb2JqZWN0IGdldHMgcm90YXRlZCBpbiAzRCBzcGFjZSB3aXRoIGEgZGlmZmVyZW50IHR3ZWVuLlxuXHRcdFx0XHRcdHRoaXMuc2V0UmF0aW8gPSBfc2V0M0RUcmFuc2Zvcm1SYXRpbztcblx0XHRcdFx0XHRfc2V0M0RUcmFuc2Zvcm1SYXRpby5jYWxsKHRoaXMsIHYpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzeCA9IHQuc2NhbGVYO1xuXHRcdFx0XHRzeSA9IHQuc2NhbGVZO1xuXHRcdFx0XHRpZiAodC5yb3RhdGlvbiB8fCB0LnNrZXdYIHx8IHQuc3ZnKSB7XG5cdFx0XHRcdFx0YW5nID0gdC5yb3RhdGlvbiAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdHNrZXcgPSB0LnNrZXdYICogX0RFRzJSQUQ7XG5cdFx0XHRcdFx0cm5kID0gMTAwMDAwO1xuXHRcdFx0XHRcdGEgPSBNYXRoLmNvcyhhbmcpICogc3g7XG5cdFx0XHRcdFx0YiA9IE1hdGguc2luKGFuZykgKiBzeDtcblx0XHRcdFx0XHRjID0gTWF0aC5zaW4oYW5nIC0gc2tldykgKiAtc3k7XG5cdFx0XHRcdFx0ZCA9IE1hdGguY29zKGFuZyAtIHNrZXcpICogc3k7XG5cdFx0XHRcdFx0aWYgKHNrZXcgJiYgdC5za2V3VHlwZSA9PT0gXCJzaW1wbGVcIikgeyAvL2J5IGRlZmF1bHQsIHdlIGNvbXBlbnNhdGUgc2tld2luZyBvbiB0aGUgb3RoZXIgYXhpcyB0byBtYWtlIGl0IGxvb2sgbW9yZSBuYXR1cmFsLCBidXQgeW91IGNhbiBzZXQgdGhlIHNrZXdUeXBlIHRvIFwic2ltcGxlXCIgdG8gdXNlIHRoZSB1bmNvbXBlbnNhdGVkIHNrZXdpbmcgdGhhdCBDU1MgZG9lc1xuXHRcdFx0XHRcdFx0dDEgPSBNYXRoLnRhbihza2V3KTtcblx0XHRcdFx0XHRcdHQxID0gTWF0aC5zcXJ0KDEgKyB0MSAqIHQxKTtcblx0XHRcdFx0XHRcdGMgKj0gdDE7XG5cdFx0XHRcdFx0XHRkICo9IHQxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodC5zdmcpIHtcblx0XHRcdFx0XHRcdHggKz0gdC54T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEgKyB0LnlPcmlnaW4gKiBjKTtcblx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGIgKyB0LnlPcmlnaW4gKiBkKTtcblx0XHRcdFx0XHRcdG1pbiA9IDAuMDAwMDAxO1xuXHRcdFx0XHRcdFx0aWYgKHggPCBtaW4pIGlmICh4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR4ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh5IDwgbWluKSBpZiAoeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1hdHJpeCA9ICgoKGEgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChiICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYyAqIHJuZCkgfCAwKSAvIHJuZCkgKyBcIixcIiArICgoKGQgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG5cdFx0XHRcdFx0aWYgKHQuc3ZnICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSB7XG5cdFx0XHRcdFx0XHR0YXJnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIm1hdHJpeChcIiArIG1hdHJpeCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vc29tZSBicm93c2VycyBoYXZlIGEgaGFyZCB0aW1lIHdpdGggdmVyeSBzbWFsbCB2YWx1ZXMgbGlrZSAyLjQ0OTI5MzU5ODI5NDcwNjRlLTE2IChub3RpY2UgdGhlIFwiZS1cIiB0b3dhcmRzIHRoZSBlbmQpIGFuZCB3b3VsZCByZW5kZXIgdGhlIG9iamVjdCBzbGlnaHRseSBvZmYuIFNvIHdlIHJvdW5kIHRvIDUgZGVjaW1hbCBwbGFjZXMuXG5cdFx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgoXCIgOiBcIm1hdHJpeChcIikgKyBtYXRyaXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeChcIiA6IFwibWF0cml4KFwiKSArIHN4ICsgXCIsMCwwLFwiICsgc3kgKyBcIixcIiArIHggKyBcIixcIiArIHkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdHAgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXHRcdHAueCA9IHAueSA9IHAueiA9IHAuc2tld1ggPSBwLnNrZXdZID0gcC5yb3RhdGlvbiA9IHAucm90YXRpb25YID0gcC5yb3RhdGlvblkgPSBwLnpPcmlnaW4gPSBwLnhQZXJjZW50ID0gcC55UGVyY2VudCA9IDA7XG5cdFx0cC5zY2FsZVggPSBwLnNjYWxlWSA9IHAuc2NhbGVaID0gMTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRyYW5zZm9ybSxzY2FsZSxzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHJvdGF0aW9uWixza2V3WCxza2V3WSxzaG9ydFJvdGF0aW9uLHNob3J0Um90YXRpb25YLHNob3J0Um90YXRpb25ZLHNob3J0Um90YXRpb25aLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmUsZGlyZWN0aW9uYWxSb3RhdGlvbixwYXJzZVRyYW5zZm9ybSxmb3JjZTNELHNrZXdUeXBlLHhQZXJjZW50LHlQZXJjZW50XCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0aWYgKGNzc3AuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPT09IHZhcnMpIHsgcmV0dXJuIHB0OyB9IC8vb25seSBuZWVkIHRvIHBhcnNlIHRoZSB0cmFuc2Zvcm0gb25jZSwgYW5kIG9ubHkgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQuXG5cdFx0XHRjc3NwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID0gdmFycztcblx0XHRcdHZhciBtMSA9IGNzc3AuX3RyYW5zZm9ybSA9IF9nZXRUcmFuc2Zvcm0odCwgX2NzLCB0cnVlLCB2YXJzLnBhcnNlVHJhbnNmb3JtKSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0aSA9IF90cmFuc2Zvcm1Qcm9wcy5sZW5ndGgsXG5cdFx0XHRcdHYgPSB2YXJzLFxuXHRcdFx0XHRlbmRSb3RhdGlvbnMgPSB7fSxcblx0XHRcdFx0bTIsIHNrZXdZLCBjb3B5LCBvcmlnLCBoYXMzRCwgaGFzQ2hhbmdlLCBkcjtcblx0XHRcdGlmICh0eXBlb2Yodi50cmFuc2Zvcm0pID09PSBcInN0cmluZ1wiICYmIF90cmFuc2Zvcm1Qcm9wKSB7IC8vZm9yIHZhbHVlcyBsaWtlIHRyYW5zZm9ybTpcInJvdGF0ZSg2MGRlZykgc2NhbGUoMC41LCAwLjgpXCJcblx0XHRcdFx0Y29weSA9IF90ZW1wRGl2LnN0eWxlOyAvL2Rvbid0IHVzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0IGJlY2F1c2UgaXQgbWlnaHQgYmUgU1ZHIGluIHdoaWNoIGNhc2Ugc29tZSBicm93c2VycyBkb24ndCByZXBvcnQgY29tcHV0ZWQgc3R5bGUgY29ycmVjdGx5LlxuXHRcdFx0XHRjb3B5W190cmFuc2Zvcm1Qcm9wXSA9IHYudHJhbnNmb3JtO1xuXHRcdFx0XHRjb3B5LmRpc3BsYXkgPSBcImJsb2NrXCI7IC8vaWYgZGlzcGxheSBpcyBcIm5vbmVcIiwgdGhlIGJyb3dzZXIgb2Z0ZW4gcmVmdXNlcyB0byByZXBvcnQgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGNvcnJlY3RseS5cblx0XHRcdFx0Y29weS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRcdFx0X2RvYy5ib2R5LmFwcGVuZENoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0bTIgPSBfZ2V0VHJhbnNmb3JtKF90ZW1wRGl2LCBudWxsLCBmYWxzZSk7XG5cdFx0XHRcdF9kb2MuYm9keS5yZW1vdmVDaGlsZChfdGVtcERpdik7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2KSA9PT0gXCJvYmplY3RcIikgeyAvL2ZvciB2YWx1ZXMgbGlrZSBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHgsIHksIHNrZXdYLCBhbmQgc2tld1kgb3IgdHJhbnNmb3JtOnsuLi59IChvYmplY3QpXG5cdFx0XHRcdG0yID0ge3NjYWxlWDpfcGFyc2VWYWwoKHYuc2NhbGVYICE9IG51bGwpID8gdi5zY2FsZVggOiB2LnNjYWxlLCBtMS5zY2FsZVgpLFxuXHRcdFx0XHRcdHNjYWxlWTpfcGFyc2VWYWwoKHYuc2NhbGVZICE9IG51bGwpID8gdi5zY2FsZVkgOiB2LnNjYWxlLCBtMS5zY2FsZVkpLFxuXHRcdFx0XHRcdHNjYWxlWjpfcGFyc2VWYWwodi5zY2FsZVosIG0xLnNjYWxlWiksXG5cdFx0XHRcdFx0eDpfcGFyc2VWYWwodi54LCBtMS54KSxcblx0XHRcdFx0XHR5Ol9wYXJzZVZhbCh2LnksIG0xLnkpLFxuXHRcdFx0XHRcdHo6X3BhcnNlVmFsKHYueiwgbTEueiksXG5cdFx0XHRcdFx0eFBlcmNlbnQ6X3BhcnNlVmFsKHYueFBlcmNlbnQsIG0xLnhQZXJjZW50KSxcblx0XHRcdFx0XHR5UGVyY2VudDpfcGFyc2VWYWwodi55UGVyY2VudCwgbTEueVBlcmNlbnQpLFxuXHRcdFx0XHRcdHBlcnNwZWN0aXZlOl9wYXJzZVZhbCh2LnRyYW5zZm9ybVBlcnNwZWN0aXZlLCBtMS5wZXJzcGVjdGl2ZSl9O1xuXHRcdFx0XHRkciA9IHYuZGlyZWN0aW9uYWxSb3RhdGlvbjtcblx0XHRcdFx0aWYgKGRyICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mKGRyKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRcdFx0Zm9yIChjb3B5IGluIGRyKSB7XG5cdFx0XHRcdFx0XHRcdHZbY29weV0gPSBkcltjb3B5XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0di5yb3RhdGlvbiA9IGRyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mKHYueCkgPT09IFwic3RyaW5nXCIgJiYgdi54LmluZGV4T2YoXCIlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdG0yLnggPSAwO1xuXHRcdFx0XHRcdG0yLnhQZXJjZW50ID0gX3BhcnNlVmFsKHYueCwgbTEueFBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2Yodi55KSA9PT0gXCJzdHJpbmdcIiAmJiB2LnkuaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0bTIueSA9IDA7XG5cdFx0XHRcdFx0bTIueVBlcmNlbnQgPSBfcGFyc2VWYWwodi55LCBtMS55UGVyY2VudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtMi5yb3RhdGlvbiA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uXCIgaW4gdikgPyB2LnJvdGF0aW9uIDogKFwic2hvcnRSb3RhdGlvblwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uICsgXCJfc2hvcnRcIiA6IChcInJvdGF0aW9uWlwiIGluIHYpID8gdi5yb3RhdGlvblogOiBtMS5yb3RhdGlvbiwgbTEucm90YXRpb24sIFwicm90YXRpb25cIiwgZW5kUm90YXRpb25zKTtcblx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0bTIucm90YXRpb25YID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25YXCIgaW4gdikgPyB2LnJvdGF0aW9uWCA6IChcInNob3J0Um90YXRpb25YXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb25YICsgXCJfc2hvcnRcIiA6IG0xLnJvdGF0aW9uWCB8fCAwLCBtMS5yb3RhdGlvblgsIFwicm90YXRpb25YXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdFx0bTIucm90YXRpb25ZID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25ZXCIgaW4gdikgPyB2LnJvdGF0aW9uWSA6IChcInNob3J0Um90YXRpb25ZXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb25ZICsgXCJfc2hvcnRcIiA6IG0xLnJvdGF0aW9uWSB8fCAwLCBtMS5yb3RhdGlvblksIFwicm90YXRpb25ZXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bTIuc2tld1ggPSAodi5za2V3WCA9PSBudWxsKSA/IG0xLnNrZXdYIDogX3BhcnNlQW5nbGUodi5za2V3WCwgbTEuc2tld1gpO1xuXG5cdFx0XHRcdC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcywgaWdub3Jpbmcgc2tld1kgYnV0IHdlIG11c3Qgc3RpbGwgcmVjb3JkIGl0IHNvIHRoYXQgd2UgY2FuIGRpc2Nlcm4gaG93IG11Y2ggb2YgdGhlIG92ZXJhbGwgc2tldyBpcyBhdHRyaWJ1dGVkIHRvIHNrZXdYIHZzLiBza2V3WS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2tld1kgd291bGQgYWx3YXlzIGFjdCByZWxhdGl2ZSAodHdlZW4gc2tld1kgdG8gMTBkZWcsIGZvciBleGFtcGxlLCBtdWx0aXBsZSB0aW1lcyBhbmQgaWYgd2UgYWx3YXlzIGNvbWJpbmUgdGhpbmdzIGludG8gc2tld1gsIHdlIGNhbid0IHJlbWVtYmVyIHRoYXQgc2tld1kgd2FzIDEwIGZyb20gbGFzdCB0aW1lKS4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIC0xMCBkZWdyZWVzLlxuXHRcdFx0XHRtMi5za2V3WSA9ICh2LnNrZXdZID09IG51bGwpID8gbTEuc2tld1kgOiBfcGFyc2VBbmdsZSh2LnNrZXdZLCBtMS5za2V3WSk7XG5cdFx0XHRcdGlmICgoc2tld1kgPSBtMi5za2V3WSAtIG0xLnNrZXdZKSkge1xuXHRcdFx0XHRcdG0yLnNrZXdYICs9IHNrZXdZO1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uICs9IHNrZXdZO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoX3N1cHBvcnRzM0QgJiYgdi5mb3JjZTNEICE9IG51bGwpIHtcblx0XHRcdFx0bTEuZm9yY2UzRCA9IHYuZm9yY2UzRDtcblx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0bTEuc2tld1R5cGUgPSB2LnNrZXdUeXBlIHx8IG0xLnNrZXdUeXBlIHx8IENTU1BsdWdpbi5kZWZhdWx0U2tld1R5cGU7XG5cblx0XHRcdGhhczNEID0gKG0xLmZvcmNlM0QgfHwgbTEueiB8fCBtMS5yb3RhdGlvblggfHwgbTEucm90YXRpb25ZIHx8IG0yLnogfHwgbTIucm90YXRpb25YIHx8IG0yLnJvdGF0aW9uWSB8fCBtMi5wZXJzcGVjdGl2ZSk7XG5cdFx0XHRpZiAoIWhhczNEICYmIHYuc2NhbGUgIT0gbnVsbCkge1xuXHRcdFx0XHRtMi5zY2FsZVogPSAxOyAvL25vIG5lZWQgdG8gdHdlZW4gc2NhbGVaLlxuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0cCA9IF90cmFuc2Zvcm1Qcm9wc1tpXTtcblx0XHRcdFx0b3JpZyA9IG0yW3BdIC0gbTFbcF07XG5cdFx0XHRcdGlmIChvcmlnID4gbWluIHx8IG9yaWcgPCAtbWluIHx8IHZbcF0gIT0gbnVsbCB8fCBfZm9yY2VQVFtwXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIHAsIG0xW3BdLCBvcmlnLCBwdCk7XG5cdFx0XHRcdFx0aWYgKHAgaW4gZW5kUm90YXRpb25zKSB7XG5cdFx0XHRcdFx0XHRwdC5lID0gZW5kUm90YXRpb25zW3BdOyAvL2RpcmVjdGlvbmFsIHJvdGF0aW9ucyB0eXBpY2FsbHkgaGF2ZSBjb21wZW5zYXRlZCB2YWx1ZXMgZHVyaW5nIHRoZSB0d2VlbiwgYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXkgZW5kIGF0IGV4YWN0bHkgd2hhdCB0aGUgdXNlciByZXF1ZXN0ZWRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQueHMwID0gMDsgLy9lbnN1cmVzIHRoZSB2YWx1ZSBzdGF5cyBudW1lcmljIGluIHNldFJhdGlvKClcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdFx0Y3NzcC5fb3ZlcndyaXRlUHJvcHMucHVzaChwdC5uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRvcmlnID0gdi50cmFuc2Zvcm1PcmlnaW47XG5cdFx0XHRpZiAobTEuc3ZnICYmIChvcmlnIHx8IHYuc3ZnT3JpZ2luKSkge1xuXHRcdFx0XHRfcGFyc2VTVkdPcmlnaW4odCwgX3BhcnNlUG9zaXRpb24ob3JpZyksIG0yLCB2LnN2Z09yaWdpbik7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgXCJ4T3JpZ2luXCIsIG0xLnhPcmlnaW4sIG0yLnhPcmlnaW4gLSBtMS54T3JpZ2luLCBwdCwgLTEsIFwidHJhbnNmb3JtT3JpZ2luXCIpO1xuXHRcdFx0XHRwdC5iID0gbTEueE9yaWdpbjtcblx0XHRcdFx0cHQuZSA9IHB0LnhzMCA9IG0yLnhPcmlnaW47XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgXCJ5T3JpZ2luXCIsIG0xLnlPcmlnaW4sIG0yLnlPcmlnaW4gLSBtMS55T3JpZ2luLCBwdCwgLTEsIFwidHJhbnNmb3JtT3JpZ2luXCIpO1xuXHRcdFx0XHRwdC5iID0gbTEueU9yaWdpbjtcblx0XHRcdFx0cHQuZSA9IHB0LnhzMCA9IG0yLnlPcmlnaW47XG5cdFx0XHRcdG9yaWcgPSBfdXNlU1ZHVHJhbnNmb3JtQXR0ciA/IG51bGwgOiBcIjBweCAwcHhcIjsgLy9jZXJ0YWluIGJyb3dzZXJzIChsaWtlIGZpcmVmb3gpIGNvbXBsZXRlbHkgYm90Y2ggdHJhbnNmb3JtLW9yaWdpbiwgc28gd2UgbXVzdCByZW1vdmUgaXQgdG8gcHJldmVudCBpdCBmcm9tIGNvbnRhbWluYXRpbmcgdHJhbnNmb3Jtcy4gV2UgbWFuYWdlIGl0IG91cnNlbHZlcyB3aXRoIHhPcmlnaW4gYW5kIHlPcmlnaW5cblx0XHRcdH1cblx0XHRcdGlmIChvcmlnIHx8IChfc3VwcG9ydHMzRCAmJiBoYXMzRCAmJiBtMS56T3JpZ2luKSkgeyAvL2lmIGFueXRoaW5nIDNEIGlzIGhhcHBlbmluZyBhbmQgdGhlcmUncyBhIHRyYW5zZm9ybU9yaWdpbiB3aXRoIGEgeiBjb21wb25lbnQgdGhhdCdzIG5vbi16ZXJvLCB3ZSBtdXN0IGVuc3VyZSB0aGF0IHRoZSB0cmFuc2Zvcm1PcmlnaW4ncyB6LWNvbXBvbmVudCBpcyBzZXQgdG8gMCBzbyB0aGF0IHdlIGNhbiBtYW51YWxseSBkbyB0aG9zZSBjYWxjdWxhdGlvbnMgdG8gZ2V0IGFyb3VuZCBTYWZhcmkgYnVncy4gRXZlbiBpZiB0aGUgdXNlciBkaWRuJ3Qgc3BlY2lmaWNhbGx5IGRlZmluZSBhIFwidHJhbnNmb3JtT3JpZ2luXCIgaW4gdGhpcyBwYXJ0aWN1bGFyIHR3ZWVuIChtYXliZSB0aGV5IGRpZCBpdCB2aWEgY3NzIGRpcmVjdGx5KS5cblx0XHRcdFx0aWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0XHRwID0gX3RyYW5zZm9ybU9yaWdpblByb3A7XG5cdFx0XHRcdFx0b3JpZyA9IChvcmlnIHx8IF9nZXRTdHlsZSh0LCBwLCBfY3MsIGZhbHNlLCBcIjUwJSA1MCVcIikpICsgXCJcIjsgLy9jYXN0IGFzIHN0cmluZyB0byBhdm9pZCBlcnJvcnNcblx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIDAsIDAsIHB0LCAtMSwgXCJ0cmFuc2Zvcm1PcmlnaW5cIik7XG5cdFx0XHRcdFx0cHQuYiA9IHN0eWxlW3BdO1xuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRcdGNvcHkgPSBtMS56T3JpZ2luO1xuXHRcdFx0XHRcdFx0b3JpZyA9IG9yaWcuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0bTEuek9yaWdpbiA9ICgob3JpZy5sZW5ndGggPiAyICYmICEoY29weSAhPT0gMCAmJiBvcmlnWzJdID09PSBcIjBweFwiKSkgPyBwYXJzZUZsb2F0KG9yaWdbMl0pIDogY29weSkgfHwgMDsgLy9TYWZhcmkgZG9lc24ndCBoYW5kbGUgdGhlIHogcGFydCBvZiB0cmFuc2Zvcm1PcmlnaW4gY29ycmVjdGx5LCBzbyB3ZSdsbCBtYW51YWxseSBoYW5kbGUgaXQgaW4gdGhlIF9zZXQzRFRyYW5zZm9ybVJhdGlvKCkgbWV0aG9kLlxuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG9yaWdbMF0gKyBcIiBcIiArIChvcmlnWzFdIHx8IFwiNTAlXCIpICsgXCIgMHB4XCI7IC8vd2UgbXVzdCBkZWZpbmUgYSB6IHZhbHVlIG9mIDBweCBzcGVjaWZpY2FsbHkgb3RoZXJ3aXNlIGlPUyA1IFNhZmFyaSB3aWxsIHN0aWNrIHdpdGggdGhlIG9sZCBvbmUgKGlmIG9uZSB3YXMgZGVmaW5lZCkhXG5cdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIFwiek9yaWdpblwiLCAwLCAwLCBwdCwgLTEsIHB0Lm4pOyAvL3dlIG11c3QgY3JlYXRlIGEgQ1NTUHJvcFR3ZWVuIGZvciB0aGUgX2dzVHJhbnNmb3JtLnpPcmlnaW4gc28gdGhhdCBpdCBnZXRzIHJlc2V0IHByb3Blcmx5IGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHR3ZWVuIHJ1bnMgYmFja3dhcmQgKGFzIG9wcG9zZWQgdG8ganVzdCBzZXR0aW5nIG0xLnpPcmlnaW4gaGVyZSlcblx0XHRcdFx0XHRcdHB0LmIgPSBjb3B5O1xuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG0xLnpPcmlnaW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBvcmlnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSAoNi04KSwgd2UgbmVlZCB0byBtYW51YWxseSBjYWxjdWxhdGUgdGhpbmdzIGluc2lkZSB0aGUgc2V0UmF0aW8oKSBmdW5jdGlvbi4gV2UgcmVjb3JkIG9yaWdpbiB4IGFuZCB5IChveCBhbmQgb3kpIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWVzIGFyZSBwZXJjZW50YWdlcyAob3hwIGFuZCBveXApLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9wYXJzZVBvc2l0aW9uKG9yaWcgKyBcIlwiLCBtMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNDaGFuZ2UpIHtcblx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtVHlwZSA9ICghKG0xLnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgKGhhczNEIHx8IHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpKSA/IDMgOiAyOyAvL3F1aWNrZXIgdGhhbiBjYWxsaW5nIGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9LCBwcmVmaXg6dHJ1ZX0pO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm94U2hhZG93XCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAwcHggIzk5OVwiLCBwcmVmaXg6dHJ1ZSwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZSwga2V5d29yZDpcImluc2V0XCJ9KTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlclJhZGl1c1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR2YXIgcHJvcHMgPSBbXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIl0sXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0ZWExLCBpLCBlczIsIGJzMiwgYnMsIGVzLCBibiwgZW4sIHcsIGgsIGVzZngsIGJzZngsIHJlbCwgaG4sIHZuLCBlbTtcblx0XHRcdHcgPSBwYXJzZUZsb2F0KHQub2Zmc2V0V2lkdGgpO1xuXHRcdFx0aCA9IHBhcnNlRmxvYXQodC5vZmZzZXRIZWlnaHQpO1xuXHRcdFx0ZWExID0gZS5zcGxpdChcIiBcIik7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgLy9pZiB3ZSdyZSBkZWFsaW5nIHdpdGggcGVyY2VudGFnZXMsIHdlIG11c3QgY29udmVydCB0aGluZ3Mgc2VwYXJhdGVseSBmb3IgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGF4aXMhXG5cdFx0XHRcdGlmICh0aGlzLnAuaW5kZXhPZihcImJvcmRlclwiKSkgeyAvL29sZGVyIGJyb3dzZXJzIHVzZWQgYSBwcmVmaXhcblx0XHRcdFx0XHRwcm9wc1tpXSA9IF9jaGVja1Byb3BQcmVmaXgocHJvcHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJzID0gYnMyID0gX2dldFN0eWxlKHQsIHByb3BzW2ldLCBfY3MsIGZhbHNlLCBcIjBweFwiKTtcblx0XHRcdFx0aWYgKGJzLmluZGV4T2YoXCIgXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdGJzMiA9IGJzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRicyA9IGJzMlswXTtcblx0XHRcdFx0XHRiczIgPSBiczJbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXMgPSBlczIgPSBlYTFbaV07XG5cdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdGJzZnggPSBicy5zdWJzdHIoKGJuICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0cmVsID0gKGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUludChlcy5jaGFyQXQoMCkrXCIxXCIsIDEwKTtcblx0XHRcdFx0XHRlcyA9IGVzLnN1YnN0cigyKTtcblx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCAtIChlbiA8IDAgPyAxIDogMCkpIHx8IFwiXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRlc2Z4ID0gX3N1ZmZpeE1hcFtwXSB8fCBic2Z4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlc2Z4ICE9PSBic2Z4KSB7XG5cdFx0XHRcdFx0aG4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyTGVmdFwiLCBibiwgYnNmeCk7IC8vaG9yaXpvbnRhbCBudW1iZXIgKHdlIHVzZSBhIGJvZ3VzIFwiYm9yZGVyTGVmdFwiIHByb3BlcnR5IGp1c3QgYmVjYXVzZSB0aGUgX2NvbnZlcnRUb1BpeGVscygpIG1ldGhvZCBzZWFyY2hlcyBmb3IgdGhlIGtleXdvcmRzIFwiTGVmdFwiLCBcIlJpZ2h0XCIsIFwiVG9wXCIsIGFuZCBcIkJvdHRvbVwiIHRvIGRldGVybWluZSBvZiBpdCdzIGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0eSwgYW5kIHdlIG5lZWQgXCJib3JkZXJcIiBpbiB0aGUgbmFtZSBzbyB0aGF0IGl0IGtub3dzIGl0IHNob3VsZCBtZWFzdXJlIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50IGl0c2VsZiwgbm90IGl0cyBwYXJlbnQuXG5cdFx0XHRcdFx0dm4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyVG9wXCIsIGJuLCBic2Z4KTsgLy92ZXJ0aWNhbCBudW1iZXJcblx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gdyAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdGJzMiA9ICh2biAvIGggKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ID09PSBcImVtXCIpIHtcblx0XHRcdFx0XHRcdGVtID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlckxlZnRcIiwgMSwgXCJlbVwiKTtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdFx0YnMyID0gKHZuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRicyA9IGhuICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0YnMyID0gdm4gKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdGVzID0gKHBhcnNlRmxvYXQoYnMpICsgZW4pICsgZXNmeDtcblx0XHRcdFx0XHRcdGVzMiA9IChwYXJzZUZsb2F0KGJzMikgKyBlbikgKyBlc2Z4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHByb3BzW2ldLCBicyArIFwiIFwiICsgYnMyLCBlcyArIFwiIFwiICsgZXMyLCBmYWxzZSwgXCIwcHhcIiwgcHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH0sIHByZWZpeDp0cnVlLCBmb3JtYXR0ZXI6X2dldEZvcm1hdHRlcihcIjBweCAwcHggMHB4IDBweFwiLCBmYWxzZSwgdHJ1ZSl9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZ3JvdW5kUG9zaXRpb25cIiwge2RlZmF1bHRWYWx1ZTpcIjAgMFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIGJwID0gXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXG5cdFx0XHRcdGNzID0gKF9jcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKSksXG5cdFx0XHRcdGJzID0gdGhpcy5mb3JtYXQoICgoY3MpID8gX2llVmVycyA/IGNzLmdldFByb3BlcnR5VmFsdWUoYnAgKyBcIi14XCIpICsgXCIgXCIgKyBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwICsgXCIteVwiKSA6IGNzLmdldFByb3BlcnR5VmFsdWUoYnApIDogdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWCArIFwiIFwiICsgdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWSkgfHwgXCIwIDBcIiksIC8vSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCByZXBvcnQgYmFja2dyb3VuZC1wb3NpdGlvbiBjb3JyZWN0bHkgLSB3ZSBtdXN0IHF1ZXJ5IGJhY2tncm91bmQtcG9zaXRpb24teCBhbmQgYmFja2dyb3VuZC1wb3NpdGlvbi15IGFuZCBjb21iaW5lIHRoZW0gKGV2ZW4gaW4gSUUxMCkuIEJlZm9yZSBJRTksIHdlIG11c3QgZG8gdGhlIHNhbWUgd2l0aCB0aGUgY3VycmVudFN0eWxlIG9iamVjdCBhbmQgdXNlIGNhbWVsQ2FzZVxuXHRcdFx0XHRlcyA9IHRoaXMuZm9ybWF0KGUpLFxuXHRcdFx0XHRiYSwgZWEsIGksIHBjdCwgb3ZlcmxhcCwgc3JjO1xuXHRcdFx0aWYgKChicy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpICE9PSAoZXMuaW5kZXhPZihcIiVcIikgIT09IC0xKSkge1xuXHRcdFx0XHRzcmMgPSBfZ2V0U3R5bGUodCwgXCJiYWNrZ3JvdW5kSW1hZ2VcIikucmVwbGFjZShfdXJsRXhwLCBcIlwiKTtcblx0XHRcdFx0aWYgKHNyYyAmJiBzcmMgIT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YmEgPSBicy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0ZWEgPSBlcy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0X3RlbXBJbWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7IC8vc2V0IHRoZSB0ZW1wIElNRydzIHNyYyB0byB0aGUgYmFja2dyb3VuZC1pbWFnZSBzbyB0aGF0IHdlIGNhbiBtZWFzdXJlIGl0cyB3aWR0aC9oZWlnaHRcblx0XHRcdFx0XHRpID0gMjtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGJzID0gYmFbaV07XG5cdFx0XHRcdFx0XHRwY3QgPSAoYnMuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRcdGlmIChwY3QgIT09IChlYVtpXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJsYXAgPSAoaSA9PT0gMCkgPyB0Lm9mZnNldFdpZHRoIC0gX3RlbXBJbWcud2lkdGggOiB0Lm9mZnNldEhlaWdodCAtIF90ZW1wSW1nLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0YmFbaV0gPSBwY3QgPyAocGFyc2VGbG9hdChicykgLyAxMDAgKiBvdmVybGFwKSArIFwicHhcIiA6IChwYXJzZUZsb2F0KGJzKSAvIG92ZXJsYXAgKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJzID0gYmEuam9pbihcIiBcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCBicywgZXMsIHB0LCBwbHVnaW4pO1xuXHRcdH0sIGZvcm1hdHRlcjpfcGFyc2VQb3NpdGlvbn0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tncm91bmRTaXplXCIsIHtkZWZhdWx0VmFsdWU6XCIwIDBcIiwgZm9ybWF0dGVyOl9wYXJzZVBvc2l0aW9ufSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGVyc3BlY3RpdmVcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBlcnNwZWN0aXZlT3JpZ2luXCIsIHtkZWZhdWx0VmFsdWU6XCI1MCUgNTAlXCIsIHByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidHJhbnNmb3JtU3R5bGVcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2ZhY2VWaXNpYmlsaXR5XCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInVzZXJTZWxlY3RcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwibWFyZ2luXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIil9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwYWRkaW5nXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLHBhZGRpbmdMZWZ0XCIpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xpcFwiLCB7ZGVmYXVsdFZhbHVlOlwicmVjdCgwcHgsMHB4LDBweCwwcHgpXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKXtcblx0XHRcdHZhciBiLCBjcywgZGVsaW07XG5cdFx0XHRpZiAoX2llVmVycyA8IDkpIHsgLy9JRTggYW5kIGVhcmxpZXIgZG9uJ3QgcmVwb3J0IGEgXCJjbGlwXCIgdmFsdWUgaW4gdGhlIGN1cnJlbnRTdHlsZSAtIGluc3RlYWQsIHRoZSB2YWx1ZXMgYXJlIHNwbGl0IGFwYXJ0IGludG8gY2xpcFRvcCwgY2xpcFJpZ2h0LCBjbGlwQm90dG9tLCBhbmQgY2xpcExlZnQuIEFsc28sIGluIElFNyBhbmQgZWFybGllciwgdGhlIHZhbHVlcyBpbnNpZGUgcmVjdCgpIGFyZSBzcGFjZS1kZWxpbWl0ZWQsIG5vdCBjb21tYS1kZWxpbWl0ZWQuXG5cdFx0XHRcdGNzID0gdC5jdXJyZW50U3R5bGU7XG5cdFx0XHRcdGRlbGltID0gX2llVmVycyA8IDggPyBcIiBcIiA6IFwiLFwiO1xuXHRcdFx0XHRiID0gXCJyZWN0KFwiICsgY3MuY2xpcFRvcCArIGRlbGltICsgY3MuY2xpcFJpZ2h0ICsgZGVsaW0gKyBjcy5jbGlwQm90dG9tICsgZGVsaW0gKyBjcy5jbGlwTGVmdCArIFwiKVwiO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSkuc3BsaXQoXCIsXCIpLmpvaW4oZGVsaW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YiA9IHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCB0aGlzLnAsIF9jcywgZmFsc2UsIHRoaXMuZGZsdCkpO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgYiwgZSwgcHQsIHBsdWdpbik7XG5cdFx0fX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRleHRTaGFkb3dcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4ICM5OTlcIiwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImF1dG9Sb3VuZCxzdHJpY3RVbml0c1wiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0KSB7cmV0dXJuIHB0O319KTsgLy9qdXN0IHNvIHRoYXQgd2UgY2FuIGlnbm9yZSB0aGVzZSBwcm9wZXJ0aWVzIChub3QgdHdlZW4gdGhlbSlcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCBzb2xpZCAjMDAwXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BXaWR0aFwiLCBfY3MsIGZhbHNlLCBcIjBweFwiKSArIFwiIFwiICsgX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wU3R5bGVcIiwgX2NzLCBmYWxzZSwgXCJzb2xpZFwiKSArIFwiIFwiICsgX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wQ29sb3JcIiwgX2NzLCBmYWxzZSwgXCIjMDAwXCIpKSwgdGhpcy5mb3JtYXQoZSksIHB0LCBwbHVnaW4pO1xuXHRcdFx0fSwgY29sb3I6dHJ1ZSwgZm9ybWF0dGVyOmZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0cmV0dXJuIGFbMF0gKyBcIiBcIiArIChhWzFdIHx8IFwic29saWRcIikgKyBcIiBcIiArICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW1wiIzAwMFwiXSlbMF07XG5cdFx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyV2lkdGhcIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcImJvcmRlclRvcFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsYm9yZGVyTGVmdFdpZHRoXCIpfSk7IC8vRmlyZWZveCBkb2Vzbid0IHBpY2sgdXAgb24gYm9yZGVyV2lkdGggc2V0IGluIHN0eWxlIHNoZWV0cyAob25seSBpbmxpbmUpLlxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImZsb2F0LGNzc0Zsb2F0LHN0eWxlRmxvYXRcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgcyA9IHQuc3R5bGUsXG5cdFx0XHRcdHByb3AgPSAoXCJjc3NGbG9hdFwiIGluIHMpID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCI7XG5cdFx0XHRyZXR1cm4gbmV3IENTU1Byb3BUd2VlbihzLCBwcm9wLCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBzW3Byb3BdLCBlKTtcblx0XHR9fSk7XG5cblx0XHQvL29wYWNpdHktcmVsYXRlZFxuXHRcdHZhciBfc2V0SUVPcGFjaXR5UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy50LCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHByb3BlcnR5XG5cdFx0XHRcdFx0ZmlsdGVycyA9IHQuZmlsdGVyIHx8IF9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpIHx8IFwiXCIsXG5cdFx0XHRcdFx0dmFsID0gKHRoaXMucyArIHRoaXMuYyAqIHYpIHwgMCxcblx0XHRcdFx0XHRza2lwO1xuXHRcdFx0XHRpZiAodmFsID09PSAxMDApIHsgLy9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhhdCBuZWVkIHRvIHVzZSBhIGZpbHRlciB0byBhcHBseSBvcGFjaXR5LCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBmaWx0ZXIgaWYgb3BhY2l0eSBoaXRzIDEgaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IG1ha2Ugc3VyZSB0aGVyZSBpc24ndCBhIHRyYW5zZm9ybSAobWF0cml4KSBvciBncmFkaWVudCBpbiB0aGUgZmlsdGVycy5cblx0XHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiYXRyaXgoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJyYWRpZW50KFwiKSA9PT0gLTEgJiYgZmlsdGVycy5pbmRleE9mKFwib2FkZXIoXCIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gKCFfZ2V0U3R5bGUodGhpcy5kYXRhLCBcImZpbHRlclwiKSk7IC8vaWYgYSBjbGFzcyBpcyBhcHBsaWVkIHRoYXQgaGFzIGFuIGFscGhhIGZpbHRlciwgaXQgd2lsbCB0YWtlIGVmZmVjdCAod2UgZG9uJ3Qgd2FudCB0aGF0KSwgc28gcmUtYXBwbHkgb3VyIGFscGhhIGZpbHRlciBpbiB0aGF0IGNhc2UuIFdlIG11c3QgZmlyc3QgcmVtb3ZlIGl0IGFuZCB0aGVuIGNoZWNrLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfYWxwaGFGaWx0ZXJFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnhuMSkge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzID0gZmlsdGVycyB8fCAoXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCIpOyAvL3dvcmtzIGFyb3VuZCBidWcgaW4gSUU3LzggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseSBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEgb24gdGhlIHNhbWUgZnJhbWUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJwYWNpdHlcIikgPT09IC0xKSB7IC8vb25seSB1c2VkIGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBzdGFuZGFyZCBvcGFjaXR5IHN0eWxlIHByb3BlcnR5IChJRSA3IGFuZCA4KS4gV2Ugb21pdCB0aGUgXCJPXCIgdG8gYXZvaWQgY2FzZS1zZW5zaXRpdml0eSBpc3N1ZXNcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IDAgfHwgIXRoaXMueG4xKSB7IC8vYnVncyBpbiBJRTcvOCB3b24ndCByZW5kZXIgdGhlIGZpbHRlciBwcm9wZXJseSBpZiBvcGFjaXR5IGlzIEFEREVEIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBcInZpc2liaWxpdHlcIiBjaGFuZ2VzICh0aGlzLnhuMSBpcyAxIGlmIHRoaXMgdHdlZW4gaXMgYW4gXCJhdXRvQWxwaGFcIiB0d2Vlbilcblx0XHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzICsgXCIgYWxwaGEob3BhY2l0eT1cIiArIHZhbCArIFwiKVwiOyAvL3dlIHJvdW5kIHRoZSB2YWx1ZSBiZWNhdXNlIG90aGVyd2lzZSwgYnVncyBpbiBJRTcvOCBjYW4gcHJldmVudCBcInZpc2liaWxpdHlcIiBjaGFuZ2VzIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseS5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX29wYWNpdHlFeHAsIFwib3BhY2l0eT1cIiArIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm9wYWNpdHksYWxwaGEsYXV0b0FscGhhXCIsIHtkZWZhdWx0VmFsdWU6XCIxXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYiA9IHBhcnNlRmxvYXQoX2dldFN0eWxlKHQsIFwib3BhY2l0eVwiLCBfY3MsIGZhbHNlLCBcIjFcIikpLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdGlzQXV0b0FscGhhID0gKHAgPT09IFwiYXV0b0FscGhhXCIpO1xuXHRcdFx0aWYgKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0ZSA9ICgoZS5jaGFyQXQoMCkgPT09IFwiLVwiKSA/IC0xIDogMSkgKiBwYXJzZUZsb2F0KGUuc3Vic3RyKDIpKSArIGI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEgJiYgYiA9PT0gMSAmJiBfZ2V0U3R5bGUodCwgXCJ2aXNpYmlsaXR5XCIsIF9jcykgPT09IFwiaGlkZGVuXCIgJiYgZSAhPT0gMCkgeyAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuXHRcdFx0XHRiID0gMDtcblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHNPcGFjaXR5KSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIsIGUgLSBiLCBwdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIFwib3BhY2l0eVwiLCBiICogMTAwLCAoZSAtIGIpICogMTAwLCBwdCk7XG5cdFx0XHRcdHB0LnhuMSA9IGlzQXV0b0FscGhhID8gMSA6IDA7IC8vd2UgbmVlZCB0byByZWNvcmQgd2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhdXRvQWxwaGEgc28gdGhhdCBpbiB0aGUgc2V0UmF0aW8oKSwgd2Uga25vdyB0byBkdXBsaWNhdGUgdGhlIHNldHRpbmcgb2YgdGhlIGFscGhhIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFNyBhbmQgSUU4IHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInZpc2liaWxpdHlcIiBmcm9tIHRha2luZyBlZmZlY3QgaWYgdGhlIGZpbHRlciBpcyBjaGFuZ2VkIHRvIGEgZGlmZmVyZW50IGFscGhhKG9wYWNpdHkpIGF0IHRoZSBzYW1lIHRpbWUuIFNldHRpbmcgaXQgdG8gdGhlIFNBTUUgdmFsdWUgZmlyc3QsIHRoZW4gdGhlIG5ldyB2YWx1ZSB3b3JrcyBhcm91bmQgdGhlIElFNy84IGJ1Zy5cblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0cHQudHlwZSA9IDI7XG5cdFx0XHRcdHB0LmIgPSBcImFscGhhKG9wYWNpdHk9XCIgKyBwdC5zICsgXCIpXCI7XG5cdFx0XHRcdHB0LmUgPSBcImFscGhhKG9wYWNpdHk9XCIgKyAocHQucyArIHB0LmMpICsgXCIpXCI7XG5cdFx0XHRcdHB0LmRhdGEgPSB0O1xuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gX3NldElFT3BhY2l0eVJhdGlvO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXV0b0FscGhhKSB7IC8vd2UgaGF2ZSB0byBjcmVhdGUgdGhlIFwidmlzaWJpbGl0eVwiIFByb3BUd2VlbiBhZnRlciB0aGUgb3BhY2l0eSBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0IHNvIHRoYXQgdGhleSBydW4gaW4gdGhlIG9yZGVyIHRoYXQgd29ya3MgcHJvcGVybHkgaW4gSUU4IGFuZCBlYXJsaWVyXG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJ2aXNpYmlsaXR5XCIsIDAsIDAsIHB0LCAtMSwgbnVsbCwgZmFsc2UsIDAsICgoYiAhPT0gMCkgPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIpLCAoKGUgPT09IDApID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiKSk7XG5cdFx0XHRcdHB0LnhzMCA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXG5cdFx0dmFyIF9yZW1vdmVQcm9wID0gZnVuY3Rpb24ocywgcCkge1xuXHRcdFx0XHRpZiAocCkge1xuXHRcdFx0XHRcdGlmIChzLnJlbW92ZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRpZiAocC5zdWJzdHIoMCwyKSA9PT0gXCJtc1wiIHx8IHAuc3Vic3RyKDAsNikgPT09IFwid2Via2l0XCIpIHsgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdFx0XHRwID0gXCItXCIgKyBwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cy5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuXHRcdFx0XHRcdFx0cy5yZW1vdmVBdHRyaWJ1dGUocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3NldENsYXNzTmFtZVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IHRoaXM7XG5cdFx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgKHYgPT09IDApID8gdGhpcy5iIDogdGhpcy5lKTtcblx0XHRcdFx0XHR2YXIgbXB0ID0gdGhpcy5kYXRhLCAvL2ZpcnN0IE1pbmlQcm9wVHdlZW5cblx0XHRcdFx0XHRcdHMgPSB0aGlzLnQuc3R5bGU7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0aWYgKCFtcHQudikge1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBtcHQucCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzW21wdC5wXSA9IG1wdC52O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodiA9PT0gMSAmJiB0aGlzLnQuX2dzQ2xhc3NQVCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy50Ll9nc0NsYXNzUFQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgIT09IHRoaXMuZSkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsYXNzTmFtZVwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdHZhciBiID0gdC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiLCAvL2Rvbid0IHVzZSB0LmNsYXNzTmFtZSBiZWNhdXNlIGl0IGRvZXNuJ3Qgd29yayBjb25zaXN0ZW50bHkgb24gU1ZHIGVsZW1lbnRzOyBnZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSBhbmQgc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWVcIikgaXMgbW9yZSByZWxpYWJsZS5cblx0XHRcdFx0Y3NzVGV4dCA9IHQuc3R5bGUuY3NzVGV4dCxcblx0XHRcdFx0ZGlmRGF0YSwgYnMsIGNucHQsIGNucHRMb29rdXAsIG1wdDtcblx0XHRcdHB0ID0gY3NzcC5fY2xhc3NOYW1lUFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsYXNzTmFtZVJhdGlvO1xuXHRcdFx0cHQucHIgPSAtMTE7XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cHQuYiA9IGI7XG5cdFx0XHRicyA9IF9nZXRBbGxTdHlsZXModCwgX2NzKTtcblx0XHRcdC8vaWYgdGhlcmUncyBhIGNsYXNzTmFtZSB0d2VlbiBhbHJlYWR5IG9wZXJhdGluZyBvbiB0aGUgdGFyZ2V0LCBmb3JjZSBpdCB0byBpdHMgZW5kIHNvIHRoYXQgdGhlIG5lY2Vzc2FyeSBpbmxpbmUgc3R5bGVzIGFyZSByZW1vdmVkIGFuZCB0aGUgY2xhc3MgbmFtZSBpcyBhcHBsaWVkIGJlZm9yZSB3ZSBkZXRlcm1pbmUgdGhlIGVuZCBzdGF0ZSAod2UgZG9uJ3Qgd2FudCBpbmxpbmUgc3R5bGVzIGludGVyZmVyaW5nIHRoYXQgd2VyZSB0aGVyZSBqdXN0IGZvciBjbGFzcy1zcGVjaWZpYyB2YWx1ZXMpXG5cdFx0XHRjbnB0ID0gdC5fZ3NDbGFzc1BUO1xuXHRcdFx0aWYgKGNucHQpIHtcblx0XHRcdFx0Y25wdExvb2t1cCA9IHt9O1xuXHRcdFx0XHRtcHQgPSBjbnB0LmRhdGE7IC8vZmlyc3QgTWluaVByb3BUd2VlbiB3aGljaCBzdG9yZXMgdGhlIGlubGluZSBzdHlsZXMgLSB3ZSBuZWVkIHRvIGZvcmNlIHRoZXNlIHNvIHRoYXQgdGhlIGlubGluZSBzdHlsZXMgZG9uJ3QgY29udGFtaW5hdGUgdGhpbmdzLiBPdGhlcndpc2UsIHRoZXJlJ3MgYSBzbWFsbCBjaGFuY2UgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IGFuZCB0aGUgaW5saW5lIHZhbHVlcyBtYXRjaCB0aGUgZGVzdGluYXRpb24gdmFsdWVzIGFuZCB0aGV5IG5ldmVyIGdldCBjbGVhbmVkLlxuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0Y25wdExvb2t1cFttcHQucF0gPSAxO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbnB0LnNldFJhdGlvKDEpO1xuXHRcdFx0fVxuXHRcdFx0dC5fZ3NDbGFzc1BUID0gcHQ7XG5cdFx0XHRwdC5lID0gKGUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlIDogYi5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxccypcXFxcYlwiICsgZS5zdWJzdHIoMikgKyBcIlxcXFxiXCIpLCBcIlwiKSArICgoZS5jaGFyQXQoMCkgPT09IFwiK1wiKSA/IFwiIFwiICsgZS5zdWJzdHIoMikgOiBcIlwiKTtcblx0XHRcdGlmIChjc3NwLl90d2Vlbi5fZHVyYXRpb24pIHsgLy9pZiBpdCdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiwgdGhlcmUncyBubyBuZWVkIHRvIHR3ZWVuIGFueXRoaW5nIG9yIHBhcnNlIHRoZSBkYXRhLiBJbiBmYWN0LCBpZiB3ZSBzd2l0Y2ggY2xhc3NlcyB0ZW1wb3JhcmlseSAod2hpY2ggd2UgbXVzdCBkbyBmb3IgcHJvcGVyIHBhcnNpbmcpIGFuZCB0aGUgY2xhc3MgaGFzIGEgdHJhbnNpdGlvbiBhcHBsaWVkLCBpdCBjb3VsZCBjYXVzZSBhIHF1aWNrIGZsYXNoIHRvIHRoZSBlbmQgc3RhdGUgYW5kIGJhY2sgYWdhaW4gaW5pdGlhbGx5IGluIHNvbWUgYnJvd3NlcnMuXG5cdFx0XHRcdHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcHQuZSk7XG5cdFx0XHRcdGRpZkRhdGEgPSBfY3NzRGlmKHQsIGJzLCBfZ2V0QWxsU3R5bGVzKHQpLCB2YXJzLCBjbnB0TG9va3VwKTtcblx0XHRcdFx0dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBiKTtcblx0XHRcdFx0cHQuZGF0YSA9IGRpZkRhdGEuZmlyc3RNUFQ7XG5cdFx0XHRcdHQuc3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG5cdFx0XHRcdHB0ID0gcHQueGZpcnN0ID0gY3NzcC5wYXJzZSh0LCBkaWZEYXRhLmRpZnMsIHB0LCBwbHVnaW4pOyAvL3dlIHJlY29yZCB0aGUgQ1NTUHJvcFR3ZWVuIGFzIHRoZSB4Zmlyc3Qgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIG92ZXJ3cml0aW5nIHByb3BlcnRseSAoaWYgXCJjbGFzc05hbWVcIiBnZXRzIG92ZXJ3cml0dGVuLCB3ZSBtdXN0IGtpbGwgYWxsIHRoZSBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2xhc3NOYW1lIHBhcnQgb2YgdGhlIHR3ZWVuLCBzbyB3ZSBjYW4gbG9vcCB0aHJvdWdoIGZyb20geGZpcnN0IHRvIHRoZSBwdCBpdHNlbGYpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cblx0XHR2YXIgX3NldENsZWFyUHJvcHNSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIGlmICh0aGlzLmRhdGEuX3RvdGFsVGltZSA9PT0gdGhpcy5kYXRhLl90b3RhbER1cmF0aW9uICYmIHRoaXMuZGF0YS5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHsgLy90aGlzLmRhdGEgcmVmZXJzIHRvIHRoZSB0d2Vlbi4gT25seSBjbGVhciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgbWFrZSB0aGUgcmF0aW8gZ28gZnJvbSAxIHRvIDAsIHNvIHdlIGNhbid0IGp1c3QgY2hlY2sgdGhhdCBhbmQgaWYgdGhlIHR3ZWVuIGlzIHRoZSB6ZXJvLWR1cmF0aW9uIG9uZSB0aGF0J3MgY3JlYXRlZCBpbnRlcm5hbGx5IHRvIHJlbmRlciB0aGUgc3RhcnRpbmcgdmFsdWVzIGluIGEgZnJvbSgpIHR3ZWVuLCBpZ25vcmUgdGhhdCBiZWNhdXNlIG90aGVyd2lzZSwgZm9yIGV4YW1wbGUsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluKS5cblx0XHRcdFx0dmFyIHMgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0dHJhbnNmb3JtUGFyc2UgPSBfc3BlY2lhbFByb3BzLnRyYW5zZm9ybS5wYXJzZSxcblx0XHRcdFx0XHRhLCBwLCBpLCBjbGVhclRyYW5zZm9ybTtcblx0XHRcdFx0aWYgKHRoaXMuZSA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHRcdHMuY3NzVGV4dCA9IFwiXCI7XG5cdFx0XHRcdFx0Y2xlYXJUcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGEgPSB0aGlzLmUuc3BsaXQoXCIgXCIpLmpvaW4oXCJcIikuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHAgPSBhW2ldO1xuXHRcdFx0XHRcdFx0aWYgKF9zcGVjaWFsUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0aWYgKF9zcGVjaWFsUHJvcHNbcF0ucGFyc2UgPT09IHRyYW5zZm9ybVBhcnNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJUcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHAgPSAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikgPyBfdHJhbnNmb3JtT3JpZ2luUHJvcCA6IF9zcGVjaWFsUHJvcHNbcF0ucDsgLy9lbnN1cmVzIHRoYXQgc3BlY2lhbCBwcm9wZXJ0aWVzIHVzZSB0aGUgcHJvcGVyIGJyb3dzZXItc3BlY2lmaWMgcHJvcGVydHkgbmFtZSwgbGlrZSBcInNjYWxlWFwiIG1pZ2h0IGJlIFwiLXdlYmtpdC10cmFuc2Zvcm1cIiBvciBcImJveFNoYWRvd1wiIG1pZ2h0IGJlIFwiLW1vei1ib3gtc2hhZG93XCJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X3JlbW92ZVByb3AocywgcCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbGVhclRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdFx0XHRpZiAodGhpcy50Ll9nc1RyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMudC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsZWFyUHJvcHNcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCkge1xuXHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsZWFyUHJvcHNSYXRpbztcblx0XHRcdHB0LmUgPSBlO1xuXHRcdFx0cHQucHIgPSAtMTA7XG5cdFx0XHRwdC5kYXRhID0gY3NzcC5fdHdlZW47XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXHRcdHAgPSBcImJlemllcix0aHJvd1Byb3BzLHBoeXNpY3NQcm9wcyxwaHlzaWNzMkRcIi5zcGxpdChcIixcIik7XG5cdFx0aSA9IHAubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdF9yZWdpc3RlclBsdWdpblByb3AocFtpXSk7XG5cdFx0fVxuXG5cblxuXG5cblxuXG5cblx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZTtcblx0XHRwLl9maXJzdFBUID0gcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9IHAuX3RyYW5zZm9ybSA9IG51bGw7XG5cblx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGtpY2tzIGV2ZXJ5dGhpbmcgb2ZmLCByZWNvcmRpbmcgc3RhcnQvZW5kIHZhbHVlcywgZXRjLlxuXHRcdHAuX29uSW5pdFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0aWYgKCF0YXJnZXQubm9kZVR5cGUpIHsgLy9jc3MgaXMgb25seSBmb3IgZG9tIGVsZW1lbnRzXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHR0aGlzLl92YXJzID0gdmFycztcblx0XHRcdF9hdXRvUm91bmQgPSB2YXJzLmF1dG9Sb3VuZDtcblx0XHRcdF9oYXNQcmlvcml0eSA9IGZhbHNlO1xuXHRcdFx0X3N1ZmZpeE1hcCA9IHZhcnMuc3VmZml4TWFwIHx8IENTU1BsdWdpbi5zdWZmaXhNYXA7XG5cdFx0XHRfY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsIFwiXCIpO1xuXHRcdFx0X292ZXJ3cml0ZVByb3BzID0gdGhpcy5fb3ZlcndyaXRlUHJvcHM7XG5cdFx0XHR2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHYsIHB0LCBwdDIsIGZpcnN0LCBsYXN0LCBuZXh0LCB6SW5kZXgsIHRwdCwgdGhyZWVEO1xuXHRcdFx0aWYgKF9yZXFTYWZhcmlGaXgpIGlmIChzdHlsZS56SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0diA9IF9nZXRTdHlsZSh0YXJnZXQsIFwiekluZGV4XCIsIF9jcyk7XG5cdFx0XHRcdGlmICh2ID09PSBcImF1dG9cIiB8fCB2ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0Ly9jb3JyZWN0cyBhIGJ1ZyBpbiBbbm9uLUFuZHJvaWRdIFNhZmFyaSB0aGF0IHByZXZlbnRzIGl0IGZyb20gcmVwYWludGluZyBlbGVtZW50cyBpbiB0aGVpciBuZXcgcG9zaXRpb25zIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHpJbmRleCBzZXQuIFdlIGFsc28gY2FuJ3QganVzdCBhcHBseSB0aGlzIGluc2lkZSBfcGFyc2VUcmFuc2Zvcm0oKSBiZWNhdXNlIGFueXRoaW5nIHRoYXQncyBtb3ZlZCBpbiBhbnkgd2F5IChsaWtlIHVzaW5nIFwibGVmdFwiIG9yIFwidG9wXCIgaW5zdGVhZCBvZiB0cmFuc2Zvcm1zIGxpa2UgXCJ4XCIgYW5kIFwieVwiKSBjYW4gYmUgYWZmZWN0ZWQsIHNvIGl0IGlzIGJlc3QgdG8gZW5zdXJlIHRoYXQgYW55dGhpbmcgdGhhdCdzIHR3ZWVuaW5nIGhhcyBhIHotaW5kZXguIFNldHRpbmcgXCJXZWJraXRQZXJzcGVjdGl2ZVwiIHRvIGEgbm9uLXplcm8gdmFsdWUgd29ya2VkIHRvbyBleGNlcHQgdGhhdCBvbiBpT1MgU2FmYXJpIHRoaW5ncyB3b3VsZCBmbGlja2VyIHJhbmRvbWx5LiBQbHVzIHpJbmRleCBpcyBsZXNzIG1lbW9yeS1pbnRlbnNpdmUuXG5cdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJ6SW5kZXhcIiwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZih2YXJzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmaXJzdCA9IHN0eWxlLmNzc1RleHQ7XG5cdFx0XHRcdHYgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCwgX2NzKTtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGZpcnN0ICsgXCI7XCIgKyB2YXJzO1xuXHRcdFx0XHR2ID0gX2Nzc0RpZih0YXJnZXQsIHYsIF9nZXRBbGxTdHlsZXModGFyZ2V0KSkuZGlmcztcblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5ICYmIF9vcGFjaXR5VmFsRXhwLnRlc3QodmFycykpIHtcblx0XHRcdFx0XHR2Lm9wYWNpdHkgPSBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXJzID0gdjtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0gdGhpcy5wYXJzZSh0YXJnZXQsIHZhcnMsIG51bGwpO1xuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNmb3JtVHlwZSkge1xuXHRcdFx0XHR0aHJlZUQgPSAodGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMyk7XG5cdFx0XHRcdGlmICghX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzdHlsZS56b29tID0gMTsgLy9oZWxwcyBjb3JyZWN0IGFuIElFIGlzc3VlLlxuXHRcdFx0XHR9IGVsc2UgaWYgKF9pc1NhZmFyaSkge1xuXHRcdFx0XHRcdF9yZXFTYWZhcmlGaXggPSB0cnVlO1xuXHRcdFx0XHRcdC8vaWYgekluZGV4IGlzbid0IHNldCwgaU9TIFNhZmFyaSBkb2Vzbid0IHJlcGFpbnQgdGhpbmdzIGNvcnJlY3RseSBzb21ldGltZXMgKHNlZW1pbmdseSBhdCByYW5kb20pLlxuXHRcdFx0XHRcdGlmIChzdHlsZS56SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHpJbmRleCA9IF9nZXRTdHlsZSh0YXJnZXQsIFwiekluZGV4XCIsIF9jcyk7XG5cdFx0XHRcdFx0XHRpZiAoekluZGV4ID09PSBcImF1dG9cIiB8fCB6SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJ6SW5kZXhcIiwgMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vU2V0dGluZyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgY29ycmVjdHMgMyBidWdzOlxuXHRcdFx0XHRcdC8vIDEpIFtub24tQW5kcm9pZF0gU2FmYXJpIHNraXBzIHJlbmRlcmluZyBjaGFuZ2VzIHRvIFwidG9wXCIgYW5kIFwibGVmdFwiIHRoYXQgYXJlIG1hZGUgb24gdGhlIHNhbWUgZnJhbWUvcmVuZGVyIGFzIGEgdHJhbnNmb3JtIHVwZGF0ZS5cblx0XHRcdFx0XHQvLyAyKSBpT1MgU2FmYXJpIHNvbWV0aW1lcyBuZWdsZWN0cyB0byByZXBhaW50IGVsZW1lbnRzIGluIHRoZWlyIG5ldyBwb3NpdGlvbnMuIFNldHRpbmcgXCJXZWJraXRQZXJzcGVjdGl2ZVwiIHRvIGEgbm9uLXplcm8gdmFsdWUgd29ya2VkIHRvbyBleGNlcHQgdGhhdCBvbiBpT1MgU2FmYXJpIHRoaW5ncyB3b3VsZCBmbGlja2VyIHJhbmRvbWx5LlxuXHRcdFx0XHRcdC8vIDMpIFNhZmFyaSBzb21ldGltZXMgZGlzcGxheWVkIG9kZCBhcnRpZmFjdHMgd2hlbiB0d2VlbmluZyB0aGUgdHJhbnNmb3JtIChvciBXZWJraXRUcmFuc2Zvcm0pIHByb3BlcnR5LCBsaWtlIGdob3N0cyBvZiB0aGUgZWRnZXMgb2YgdGhlIGVsZW1lbnQgcmVtYWluZWQuIERlZmluaXRlbHkgYSBicm93c2VyIGJ1Zy5cblx0XHRcdFx0XHQvL05vdGU6IHdlIGFsbG93IHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoZSBhdXRvLXNldHRpbmcgYnkgZGVmaW5pbmcgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IGluIHRoZSB2YXJzIG9mIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRpZiAoX2lzU2FmYXJpTFQ2KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcIldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eVwiLCB0aGlzLl92YXJzLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB8fCAodGhyZWVEID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0MiA9IHB0O1xuXHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5fbmV4dCkge1xuXHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHRhcmdldCwgXCJ0cmFuc2Zvcm1cIiwgMCwgMCwgbnVsbCwgMik7XG5cdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHRwdCwgbnVsbCwgcHQyKTtcblx0XHRcdFx0dHB0LnNldFJhdGlvID0gKHRocmVlRCAmJiBfc3VwcG9ydHMzRCkgPyBfc2V0M0RUcmFuc2Zvcm1SYXRpbyA6IF90cmFuc2Zvcm1Qcm9wID8gX3NldDJEVHJhbnNmb3JtUmF0aW8gOiBfc2V0SUVUcmFuc2Zvcm1SYXRpbztcblx0XHRcdFx0dHB0LmRhdGEgPSB0aGlzLl90cmFuc2Zvcm0gfHwgX2dldFRyYW5zZm9ybSh0YXJnZXQsIF9jcywgdHJ1ZSk7XG5cdFx0XHRcdHRwdC50d2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRfb3ZlcndyaXRlUHJvcHMucG9wKCk7IC8vd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSB0aGUgb3ZlcndyaXRlIG9mIGFsbCBcInRyYW5zZm9ybVwiIHR3ZWVucyBvZiB0aGUgdGFyZ2V0IC0gd2Ugb25seSBjYXJlIGFib3V0IGluZGl2aWR1YWwgdHJhbnNmb3JtIHByb3BlcnRpZXMgbGlrZSBzY2FsZVgsIHJvdGF0aW9uLCBldGMuIFRoZSBDU1NQcm9wVHdlZW4gY29uc3RydWN0b3IgYXV0b21hdGljYWxseSBhZGRzIHRoZSBwcm9wZXJ0eSB0byBfb3ZlcndyaXRlUHJvcHMgd2hpY2ggaXMgd2h5IHdlIG5lZWQgdG8gcG9wKCkgaGVyZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKF9oYXNQcmlvcml0eSkge1xuXHRcdFx0XHQvL3Jlb3JkZXJzIHRoZSBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwciAocHJpb3JpdHkpXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cblx0XHRwLnBhcnNlID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHAsIHNwLCBibiwgZW4sIGJzLCBlcywgYnNmeCwgZXNmeCwgaXNTdHIsIHJlbDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdGVzID0gdmFyc1twXTsgLy9lbmRpbmcgdmFsdWUgc3RyaW5nXG5cdFx0XHRcdHNwID0gX3NwZWNpYWxQcm9wc1twXTsgLy9TcGVjaWFsUHJvcCBsb29rdXAuXG5cdFx0XHRcdGlmIChzcCkge1xuXHRcdFx0XHRcdHB0ID0gc3AucGFyc2UodGFyZ2V0LCBlcywgcCwgdGhpcywgcHQsIHBsdWdpbiwgdmFycyk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicyA9IF9nZXRTdHlsZSh0YXJnZXQsIHAsIF9jcykgKyBcIlwiO1xuXHRcdFx0XHRcdGlzU3RyID0gKHR5cGVvZihlcykgPT09IFwic3RyaW5nXCIpO1xuXHRcdFx0XHRcdGlmIChwID09PSBcImNvbG9yXCIgfHwgcCA9PT0gXCJmaWxsXCIgfHwgcCA9PT0gXCJzdHJva2VcIiB8fCBwLmluZGV4T2YoXCJDb2xvclwiKSAhPT0gLTEgfHwgKGlzU3RyICYmIF9yZ2Joc2xFeHAudGVzdChlcykpKSB7IC8vT3BlcmEgdXNlcyBiYWNrZ3JvdW5kOiB0byBkZWZpbmUgY29sb3Igc29tZXRpbWVzIGluIGFkZGl0aW9uIHRvIGJhY2tncm91bmRDb2xvcjpcblx0XHRcdFx0XHRcdGlmICghaXNTdHIpIHtcblx0XHRcdFx0XHRcdFx0ZXMgPSBfcGFyc2VDb2xvcihlcyk7XG5cdFx0XHRcdFx0XHRcdGVzID0gKChlcy5sZW5ndGggPiAzKSA/IFwicmdiYShcIiA6IFwicmdiKFwiKSArIGVzLmpvaW4oXCIsXCIpICsgXCIpXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHAsIGJzLCBlcywgdHJ1ZSwgXCJ0cmFuc3BhcmVudFwiLCBwdCwgMCwgcGx1Z2luKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNTdHIgJiYgKGVzLmluZGV4T2YoXCIgXCIpICE9PSAtMSB8fCBlcy5pbmRleE9mKFwiLFwiKSAhPT0gLTEpKSB7XG5cdFx0XHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHAsIGJzLCBlcywgdHJ1ZSwgbnVsbCwgcHQsIDAsIHBsdWdpbik7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJzKTtcblx0XHRcdFx0XHRcdGJzZnggPSAoYm4gfHwgYm4gPT09IDApID8gYnMuc3Vic3RyKChibiArIFwiXCIpLmxlbmd0aCkgOiBcIlwiOyAvL3JlbWVtYmVyLCBicyBjb3VsZCBiZSBub24tbnVtZXJpYyBsaWtlIFwibm9ybWFsXCIgZm9yIGZvbnRXZWlnaHQsIHNvIHdlIHNob3VsZCBkZWZhdWx0IHRvIGEgYmxhbmsgc3VmZml4IGluIHRoYXQgY2FzZS5cblxuXHRcdFx0XHRcdFx0aWYgKGJzID09PSBcIlwiIHx8IGJzID09PSBcImF1dG9cIikge1xuXHRcdFx0XHRcdFx0XHRpZiAocCA9PT0gXCJ3aWR0aFwiIHx8IHAgPT09IFwiaGVpZ2h0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IF9nZXREaW1lbnNpb24odGFyZ2V0LCBwLCBfY3MpO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocCA9PT0gXCJsZWZ0XCIgfHwgcCA9PT0gXCJ0b3BcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gX2NhbGN1bGF0ZU9mZnNldCh0YXJnZXQsIHAsIF9jcyk7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IChwICE9PSBcIm9wYWNpdHlcIikgPyAwIDogMTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZWwgPSAoaXNTdHIgJiYgZXMuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0XHRcdGVuID0gcGFyc2VJbnQoZXMuY2hhckF0KDApICsgXCIxXCIsIDEwKTtcblx0XHRcdFx0XHRcdFx0ZXMgPSBlcy5zdWJzdHIoMik7XG5cdFx0XHRcdFx0XHRcdGVuICo9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gZXMucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVuID0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSBpc1N0ciA/IGVzLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIikgOiBcIlwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gKHAgaW4gX3N1ZmZpeE1hcCkgPyBfc3VmZml4TWFwW3BdIDogYnNmeDsgLy9wb3B1bGF0ZSB0aGUgZW5kIHN1ZmZpeCwgcHJpb3JpdGl6aW5nIHRoZSBtYXAsIHRoZW4gaWYgbm9uZSBpcyBmb3VuZCwgdXNlIHRoZSBiZWdpbm5pbmcgc3VmZml4LlxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlcyA9IChlbiB8fCBlbiA9PT0gMCkgPyAocmVsID8gZW4gKyBibiA6IGVuKSArIGVzZnggOiB2YXJzW3BdOyAvL2Vuc3VyZXMgdGhhdCBhbnkgKz0gb3IgLT0gcHJlZml4ZXMgYXJlIHRha2VuIGNhcmUgb2YuIFJlY29yZCB0aGUgZW5kIHZhbHVlIGJlZm9yZSBub3JtYWxpemluZyB0aGUgc3VmZml4IGJlY2F1c2Ugd2UgYWx3YXlzIHdhbnQgdG8gZW5kIHRoZSB0d2VlbiBvbiBleGFjdGx5IHdoYXQgdGhleSBpbnRlbmRlZCBldmVuIGlmIGl0IGRvZXNuJ3QgbWF0Y2ggdGhlIGJlZ2lubmluZyB2YWx1ZSdzIHN1ZmZpeC5cblxuXHRcdFx0XHRcdFx0Ly9pZiB0aGUgYmVnaW5uaW5nL2VuZGluZyBzdWZmaXhlcyBkb24ndCBtYXRjaCwgbm9ybWFsaXplIHRoZW0uLi5cblx0XHRcdFx0XHRcdGlmIChic2Z4ICE9PSBlc2Z4KSBpZiAoZXNmeCAhPT0gXCJcIikgaWYgKGVuIHx8IGVuID09PSAwKSBpZiAoYm4pIHsgLy9ub3RlOiBpZiB0aGUgYmVnaW5uaW5nIHZhbHVlIChibikgaXMgMCwgd2UgZG9uJ3QgbmVlZCB0byBjb252ZXJ0IHVuaXRzIVxuXHRcdFx0XHRcdFx0XHRibiA9IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCBibiwgYnNmeCk7XG5cdFx0XHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuIC89IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCAxMDAsIFwiJVwiKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFycy5zdHJpY3RVbml0cyAhPT0gdHJ1ZSkgeyAvL3NvbWUgYnJvd3NlcnMgcmVwb3J0IG9ubHkgXCJweFwiIHZhbHVlcyBpbnN0ZWFkIG9mIGFsbG93aW5nIFwiJVwiIHdpdGggZ2V0Q29tcHV0ZWRTdHlsZSgpLCBzbyB3ZSBhc3N1bWUgdGhhdCBpZiB3ZSdyZSB0d2VlbmluZyB0byBhICUsIHdlIHNob3VsZCBzdGFydCB0aGVyZSB0b28gdW5sZXNzIHN0cmljdFVuaXRzOnRydWUgaXMgZGVmaW5lZC4gVGhpcyBhcHByb2FjaCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciByZXNwb25zaXZlIGRlc2lnbnMgdGhhdCB1c2UgZnJvbSgpIHR3ZWVucy5cblx0XHRcdFx0XHRcdFx0XHRcdGJzID0gYm4gKyBcIiVcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ID09PSBcImVtXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiAvPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgMSwgXCJlbVwiKTtcblxuXHRcdFx0XHRcdFx0XHQvL290aGVyd2lzZSBjb252ZXJ0IHRvIHBpeGVscy5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ICE9PSBcInB4XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRlbiA9IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCBlbiwgZXNmeCk7XG5cdFx0XHRcdFx0XHRcdFx0ZXNmeCA9IFwicHhcIjsgLy93ZSBkb24ndCB1c2UgYnNmeCBhZnRlciB0aGlzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHNldCBpdCB0byBweCB0b28uXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHJlbCkgaWYgKGVuIHx8IGVuID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZXMgPSAoZW4gKyBibikgKyBlc2Z4OyAvL3RoZSBjaGFuZ2VzIHdlIG1hZGUgYWZmZWN0IHJlbGF0aXZlIGNhbGN1bGF0aW9ucywgc28gYWRqdXN0IHRoZSBlbmQgdmFsdWUgaGVyZS5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0XHRcdGVuICs9IGJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGJuIHx8IGJuID09PSAwKSAmJiAoZW4gfHwgZW4gPT09IDApKSB7IC8vZmFzdGVyIHRoYW4gaXNOYU4oKS4gQWxzbywgcHJldmlvdXNseSB3ZSByZXF1aXJlZCBlbiAhPT0gYm4gYnV0IHRoYXQgZG9lc24ndCByZWFsbHkgZ2FpbiBtdWNoIHBlcmZvcm1hbmNlIGFuZCBpdCBwcmV2ZW50cyBfcGFyc2VUb1Byb3h5KCkgZnJvbSB3b3JraW5nIHByb3Blcmx5IGlmIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBtYXRjaCBidXQgbmVlZCB0byBnZXQgdHdlZW5lZCBieSBhbiBleHRlcm5hbCBwbHVnaW4gYW55d2F5LiBGb3IgZXhhbXBsZSwgYSBiZXppZXIgdHdlZW4gd2hlcmUgdGhlIHRhcmdldCBzdGFydHMgYXQgbGVmdDowIGFuZCBoYXMgdGhlc2UgcG9pbnRzOiBbe2xlZnQ6NTB9LHtsZWZ0OjB9XSB3b3VsZG4ndCB3b3JrIHByb3Blcmx5IGJlY2F1c2Ugd2hlbiBwYXJzaW5nIHRoZSBsYXN0IHBvaW50LCBpdCdkIG1hdGNoIHRoZSBmaXJzdCAoY3VycmVudCkgb25lIGFuZCBhIG5vbi10d2VlbmluZyBDU1NQcm9wVHdlZW4gd291bGQgYmUgcmVjb3JkZWQgd2hlbiB3ZSBhY3R1YWxseSBuZWVkIGEgbm9ybWFsIHR3ZWVuICh0eXBlOjApIHNvIHRoYXQgdGhpbmdzIGdldCB1cGRhdGVkIGR1cmluZyB0aGUgdHdlZW4gcHJvcGVybHkuXG5cdFx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgYm4sIGVuIC0gYm4sIHB0LCAwLCBwLCAoX2F1dG9Sb3VuZCAhPT0gZmFsc2UgJiYgKGVzZnggPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSksIDAsIGJzLCBlcyk7XG5cdFx0XHRcdFx0XHRcdHB0LnhzMCA9IGVzZng7XG5cdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJ0d2VlbiBcIitwK1wiIGZyb20gXCIrcHQuYitcIiAoXCIrYm4rZXNmeCtcIikgdG8gXCIrcHQuZStcIiB3aXRoIHN1ZmZpeDogXCIrcHQueHMwKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc3R5bGVbcF0gPT09IHVuZGVmaW5lZCB8fCAhZXMgJiYgKGVzICsgXCJcIiA9PT0gXCJOYU5cIiB8fCBlcyA9PSBudWxsKSkge1xuXHRcdFx0XHRcdFx0XHRfbG9nKFwiaW52YWxpZCBcIiArIHAgKyBcIiB0d2VlbiB2YWx1ZTogXCIgKyB2YXJzW3BdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgZW4gfHwgYm4gfHwgMCwgMCwgcHQsIC0xLCBwLCBmYWxzZSwgMCwgYnMsIGVzKTtcblx0XHRcdFx0XHRcdFx0cHQueHMwID0gKGVzID09PSBcIm5vbmVcIiAmJiAocCA9PT0gXCJkaXNwbGF5XCIgfHwgcC5pbmRleE9mKFwiU3R5bGVcIikgIT09IC0xKSkgPyBicyA6IGVzOyAvL2ludGVybWVkaWF0ZSB2YWx1ZSBzaG91bGQgdHlwaWNhbGx5IGJlIHNldCBpbW1lZGlhdGVseSAoZW5kIHZhbHVlKSBleGNlcHQgZm9yIFwiZGlzcGxheVwiIG9yIHRoaW5ncyBsaWtlIGJvcmRlclRvcFN0eWxlLCBib3JkZXJCb3R0b21TdHlsZSwgZXRjLiB3aGljaCBzaG91bGQgdXNlIHRoZSBiZWdpbm5pbmcgdmFsdWUgZHVyaW5nIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm5vbi10d2VlbmluZyB2YWx1ZSBcIitwK1wiOiBcIitwdC54czApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGx1Z2luKSBpZiAocHQgJiYgIXB0LnBsdWdpbikge1xuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblxuXHRcdC8vZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgdHdlZW4gdXBkYXRlcywgcGFzc2luZyB0aGUgbmV3IHJhdGlvICh0eXBpY2FsbHkgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBub3QgYWx3YXlzIChmb3IgZXhhbXBsZSwgaWYgYW4gRWxhc3RpYy5lYXNlT3V0IGlzIHVzZWQsIHRoZSB2YWx1ZSBjYW4ganVtcCBhYm92ZSAxIG1pZC10d2VlbikuIEl0IHdpbGwgYWx3YXlzIHN0YXJ0IGFuZCAwIGFuZCBlbmQgYXQgMS5cblx0XHRwLnNldFJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdHZhbCwgc3RyLCBpO1xuXHRcdFx0Ly9hdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IHRoZSB2YWx1ZXMgdG8gZXhhY3RseSB3aGF0IHdlIHJlY2VpdmVkIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSBub24tdHdlZW5pbmcgdmFsdWVzIChsaWtlIFwicG9zaXRpb25cIiBvciBcImZsb2F0XCIgb3Igd2hhdGV2ZXIpIGFyZSBzZXQgYW5kIHNvIHRoYXQgaWYgdGhlIGJlZ2lubmluZy9lbmRpbmcgc3VmZml4ZXMgKHVuaXRzKSBkaWRuJ3QgbWF0Y2ggYW5kIHdlIG5vcm1hbGl6ZWQgdG8gcHgsIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIHBhc3NlZCBpbiBpcyB1c2VkIGhlcmUuIFdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHdlZW4gaXMgYXQgaXRzIGJlZ2lubmluZyBpbiBjYXNlIGl0J3MgYSBmcm9tKCkgdHdlZW4gaW4gd2hpY2ggY2FzZSB0aGUgcmF0aW8gd2lsbCBhY3R1YWxseSBnbyBmcm9tIDEgdG8gMCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHR3ZWVuIChiYWNrd2FyZHMpLlxuXHRcdFx0aWYgKHYgPT09IDEgJiYgKHRoaXMuX3R3ZWVuLl90aW1lID09PSB0aGlzLl90d2Vlbi5fZHVyYXRpb24gfHwgdGhpcy5fdHdlZW4uX3RpbWUgPT09IDApKSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh2IHx8ICEodGhpcy5fdHdlZW4uX3RpbWUgPT09IHRoaXMuX3R3ZWVuLl9kdXJhdGlvbiB8fCB0aGlzLl90d2Vlbi5fdGltZSA9PT0gMCkgfHwgdGhpcy5fdHdlZW4uX3Jhd1ByZXZUaW1lID09PSAtMC4wMDAwMDEpIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0dmFsID0gcHQuYyAqIHYgKyBwdC5zO1xuXHRcdFx0XHRcdGlmIChwdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4pIGlmICh2YWwgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXB0LnR5cGUpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAxKSB7IC8vY29tcGxleCB2YWx1ZSAob25lIHRoYXQgdHlwaWNhbGx5IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluc2lkZSBhIHN0cmluZywgbGlrZSBcInJlY3QoNXB4LDEwcHgsMjBweCwyNXB4KVwiXG5cdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdGlmIChpID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDMpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gNCkge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzICsgcHQueG4zICsgcHQueHM0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czMgKyBwdC54bjMgKyBwdC54czQgKyBwdC54bjQgKyBwdC54czU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyB2YWwgKyBwdC54czE7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gcHRbXCJ4blwiK2ldICsgcHRbXCJ4c1wiKyhpKzEpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gc3RyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAtMSkgeyAvL25vbi10d2VlbmluZyB2YWx1ZVxuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQuc2V0UmF0aW8pIHsgLy9jdXN0b20gc2V0UmF0aW8oKSBmb3IgdGhpbmdzIGxpa2UgU3BlY2lhbFByb3BzLCBleHRlcm5hbCBwbHVnaW5zLCBldGMuXG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHQvL2lmIHRoZSB0d2VlbiBpcyByZXZlcnNlZCBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWVzIHdoaWNoIG1heSBoYXZlIGRpZmZlcmVudCB1bml0cyAobGlrZSAlIGluc3RlYWQgb2YgcHggb3IgZW0gb3Igd2hhdGV2ZXIpLlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgIT09IDIpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5iO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEZvcmNlcyByZW5kZXJpbmcgb2YgdGhlIHRhcmdldCdzIHRyYW5zZm9ybXMgKHJvdGF0aW9uLCBzY2FsZSwgZXRjLikgd2hlbmV2ZXIgdGhlIENTU1BsdWdpbidzIHNldFJhdGlvKCkgaXMgY2FsbGVkLlxuXHRcdCAqIEJhc2ljYWxseSwgdGhpcyB0ZWxscyB0aGUgQ1NTUGx1Z2luIHRvIGNyZWF0ZSBhIENTU1Byb3BUd2VlbiAodHlwZSAyKSBhZnRlciBpbnN0YW50aWF0aW9uIHRoYXQgcnVucyBsYXN0IGluIHRoZSBsaW5rZWRcblx0XHQgKiBsaXN0IGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgKDNEIG9yIDJEKSByZW5kZXJpbmcgZnVuY3Rpb24uIFdlIHNlcGFyYXRlIHRoaXMgaW50byBpdHMgb3duIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjYWxsXG5cdFx0ICogaXQgZnJvbSBvdGhlciBwbHVnaW5zIGxpa2UgQmV6aWVyUGx1Z2luIGlmLCBmb3IgZXhhbXBsZSwgaXQgbmVlZHMgdG8gYXBwbHkgYW4gYXV0b1JvdGF0aW9uIGFuZCB0aGlzIENTU1BsdWdpblxuXHRcdCAqIGRvZXNuJ3QgaGF2ZSBhbnkgdHJhbnNmb3JtLXJlbGF0ZWQgcHJvcGVydGllcyBvZiBpdHMgb3duLiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgYXMgbWFueSB0aW1lcyBhcyB5b3Vcblx0XHQgKiB3YW50IGFuZCBpdCB3b24ndCBjcmVhdGUgZHVwbGljYXRlIENTU1Byb3BUd2VlbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRocmVlRCBpZiB0cnVlLCBpdCBzaG91bGQgYXBwbHkgM0QgdHdlZW5zIChvdGhlcndpc2UsIGp1c3QgMkQgb25lcyBhcmUgZmluZSBhbmQgdHlwaWNhbGx5IGZhc3Rlcilcblx0XHQgKi9cblx0XHRwLl9lbmFibGVUcmFuc2Zvcm1zID0gZnVuY3Rpb24odGhyZWVEKSB7XG5cdFx0XHR0aGlzLl90cmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm0gfHwgX2dldFRyYW5zZm9ybSh0aGlzLl90YXJnZXQsIF9jcywgdHJ1ZSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBlbGVtZW50IGhhcyBhIF9nc1RyYW5zZm9ybSBwcm9wZXJ0eSB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXMuXG5cdFx0XHR0aGlzLl90cmFuc2Zvcm1UeXBlID0gKCEodGhpcy5fdHJhbnNmb3JtLnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgKHRocmVlRCB8fCB0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKSkgPyAzIDogMjtcblx0XHR9O1xuXG5cdFx0dmFyIGxhenlTZXQgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR0aGlzLnRbdGhpcy5wXSA9IHRoaXMuZTtcblx0XHRcdHRoaXMuZGF0YS5fbGlua0NTU1AodGhpcywgdGhpcy5fbmV4dCwgbnVsbCwgdHJ1ZSk7IC8vd2UgcHVycG9zZWZ1bGx5IGtlZXAgdGhpcy5fbmV4dCBldmVuIHRob3VnaCBpdCdkIG1ha2Ugc2Vuc2UgdG8gbnVsbCBpdCwgYnV0IHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIGFzIHRoaXMgaGFwcGVucyBkdXJpbmcgdGhlIHdoaWxlIChwdCkge30gbG9vcCBpbiBzZXRSYXRpbygpIGF0IHRoZSBib3R0b20gb2Ygd2hpY2ggaXQgc2V0cyBwdCA9IHB0Ll9uZXh0LCBzbyBpZiB3ZSBudWxsIGl0LCB0aGUgbGlua2VkIGxpc3Qgd2lsbCBiZSBicm9rZW4gaW4gdGhhdCBsb29wLlxuXHRcdH07XG5cdFx0LyoqIEBwcml2YXRlIEdpdmVzIHVzIGEgd2F5IHRvIHNldCBhIHZhbHVlIG9uIHRoZSBmaXJzdCByZW5kZXIgKGFuZCBvbmx5IHRoZSBmaXJzdCByZW5kZXIpLiAqKi9cblx0XHRwLl9hZGRMYXp5U2V0ID0gZnVuY3Rpb24odCwgcCwgdikge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgdGhpcy5fZmlyc3RQVCwgMik7XG5cdFx0XHRwdC5lID0gdjtcblx0XHRcdHB0LnNldFJhdGlvID0gbGF6eVNldDtcblx0XHRcdHB0LmRhdGEgPSB0aGlzO1xuXHRcdH07XG5cblx0XHQvKiogQHByaXZhdGUgKiovXG5cdFx0cC5fbGlua0NTU1AgPSBmdW5jdGlvbihwdCwgbmV4dCwgcHJldiwgcmVtb3ZlKSB7XG5cdFx0XHRpZiAocHQpIHtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0UFQgPT09IHB0KSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHJlbW92ZSA9IHRydWU7IC8vanVzdCB0byBwcmV2ZW50IHJlc2V0dGluZyB0aGlzLl9maXJzdFBUIDUgbGluZXMgZG93biBpbiBjYXNlIHB0Ll9uZXh0IGlzIG51bGwuIChvcHRpbWl6ZWQgZm9yIHNwZWVkKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmV2KSB7XG5cdFx0XHRcdFx0cHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFyZW1vdmUgJiYgdGhpcy5fZmlyc3RQVCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdHB0Ll9wcmV2ID0gcHJldjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cdFx0Ly93ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIGFscGhhIG9yIGF1dG9BbHBoYSBpcyBraWxsZWQsIG9wYWNpdHkgaXMgdG9vLiBBbmQgYXV0b0FscGhhIGFmZmVjdHMgdGhlIFwidmlzaWJpbGl0eVwiIHByb3BlcnR5LlxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBjb3B5ID0gbG9va3VwLFxuXHRcdFx0XHRwdCwgcCwgeGZpcnN0O1xuXHRcdFx0aWYgKGxvb2t1cC5hdXRvQWxwaGEgfHwgbG9va3VwLmFscGhhKSB7XG5cdFx0XHRcdGNvcHkgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIGxvb2t1cCkgeyAvL2NvcHkgdGhlIGxvb2t1cCBzbyB0aGF0IHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgb3JpZ2luYWwgd2hpY2ggbWF5IGJlIHBhc3NlZCBlbHNld2hlcmUuXG5cdFx0XHRcdFx0Y29weVtwXSA9IGxvb2t1cFtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb3B5Lm9wYWNpdHkgPSAxO1xuXHRcdFx0XHRpZiAoY29weS5hdXRvQWxwaGEpIHtcblx0XHRcdFx0XHRjb3B5LnZpc2liaWxpdHkgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobG9va3VwLmNsYXNzTmFtZSAmJiAocHQgPSB0aGlzLl9jbGFzc05hbWVQVCkpIHsgLy9mb3IgY2xhc3NOYW1lIHR3ZWVucywgd2UgbmVlZCB0byBraWxsIGFueSBhc3NvY2lhdGVkIENTU1Byb3BUd2VlbnMgdG9vOyBhIGxpbmtlZCBsaXN0IHN0YXJ0cyBhdCB0aGUgY2xhc3NOYW1lJ3MgXCJ4Zmlyc3RcIi5cblx0XHRcdFx0eGZpcnN0ID0gcHQueGZpcnN0O1xuXHRcdFx0XHRpZiAoeGZpcnN0ICYmIHhmaXJzdC5fcHJldikge1xuXHRcdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHhmaXJzdC5fcHJldiwgcHQuX25leHQsIHhmaXJzdC5fcHJldi5fcHJldik7IC8vYnJlYWsgb2ZmIHRoZSBwcmV2XG5cdFx0XHRcdH0gZWxzZSBpZiAoeGZpcnN0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHB0Ll9uZXh0LCBwdC5fbmV4dC5fbmV4dCwgeGZpcnN0Ll9wcmV2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jbGFzc05hbWVQVCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gVHdlZW5QbHVnaW4ucHJvdG90eXBlLl9raWxsLmNhbGwodGhpcywgY29weSk7XG5cdFx0fTtcblxuXG5cblx0XHQvL3VzZWQgYnkgY2FzY2FkZVRvKCkgZm9yIGdhdGhlcmluZyBhbGwgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgZWFjaCBjaGlsZCBlbGVtZW50IGludG8gYW4gYXJyYXkgZm9yIGNvbXBhcmlzb24uXG5cdFx0dmFyIF9nZXRDaGlsZFN0eWxlcyA9IGZ1bmN0aW9uKGUsIHByb3BzLCB0YXJnZXRzKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiwgaSwgY2hpbGQsIHR5cGU7XG5cdFx0XHRcdGlmIChlLnNsaWNlKSB7XG5cdFx0XHRcdFx0aSA9IGUubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0X2dldENoaWxkU3R5bGVzKGVbaV0sIHByb3BzLCB0YXJnZXRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkcmVuID0gZS5jaGlsZE5vZGVzO1xuXHRcdFx0XHRpID0gY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdHR5cGUgPSBjaGlsZC50eXBlO1xuXHRcdFx0XHRcdGlmIChjaGlsZC5zdHlsZSkge1xuXHRcdFx0XHRcdFx0cHJvcHMucHVzaChfZ2V0QWxsU3R5bGVzKGNoaWxkKSk7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0cykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHR5cGUgPT09IDEgfHwgdHlwZSA9PT0gOSB8fCB0eXBlID09PSAxMSkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdF9nZXRDaGlsZFN0eWxlcyhjaGlsZCwgcHJvcHMsIHRhcmdldHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFR5cGljYWxseSBvbmx5IHVzZWZ1bCBmb3IgY2xhc3NOYW1lIHR3ZWVucyB0aGF0IG1heSBhZmZlY3QgY2hpbGQgZWxlbWVudHMsIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBUd2VlbkxpdGVcblx0XHQgKiBhbmQgdGhlbiBjb21wYXJlcyB0aGUgc3R5bGUgcHJvcGVydGllcyBvZiBhbGwgdGhlIHRhcmdldCdzIGNoaWxkIGVsZW1lbnRzIGF0IHRoZSB0d2VlbidzIHN0YXJ0IGFuZCBlbmQsIGFuZFxuXHRcdCAqIGlmIGFueSBhcmUgZGlmZmVyZW50LCBpdCBhbHNvIGNyZWF0ZXMgdHdlZW5zIGZvciB0aG9zZSBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIEFMTCBvZiB0aGUgcmVzdWx0aW5nXG5cdFx0ICogdHdlZW5zIChzbyB0aGF0IHlvdSBjYW4gZWFzaWx5IGFkZCgpIHRoZW0gdG8gYSBUaW1lbGluZUxpdGUsIGZvciBleGFtcGxlKS4gVGhlIHJlYXNvbiB0aGlzIGZ1bmN0aW9uYWxpdHkgaXNcblx0XHQgKiB3cmFwcGVkIGludG8gYSBzZXBhcmF0ZSBzdGF0aWMgbWV0aG9kIG9mIENTU1BsdWdpbiBpbnN0ZWFkIG9mIGJlaW5nIGludGVncmF0ZWQgaW50byBhbGwgcmVndWxhciBjbGFzc05hbWUgdHdlZW5zXG5cdFx0ICogaXMgYmVjYXVzZSBpdCBjcmVhdGVzIGVudGlyZWx5IG5ldyB0d2VlbnMgdGhhdCBtYXkgaGF2ZSBjb21wbGV0ZWx5IGRpZmZlcmVudCB0YXJnZXRzIHRoYW4gdGhlIG9yaWdpbmFsIHR3ZWVuLFxuXHRcdCAqIHNvIGlmIHRoZXkgd2VyZSBhbGwgbHVtcGVkIGludG8gdGhlIG9yaWdpbmFsIHR3ZWVuIGluc3RhbmNlLCBpdCB3b3VsZCBiZSBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgQVBJXG5cdFx0ICogYW5kIGl0IHdvdWxkIGNyZWF0ZSBvdGhlciBwcm9ibGVtcy4gRm9yIGV4YW1wbGU6XG5cdFx0ICogIC0gSWYgSSBjcmVhdGUgYSB0d2VlbiBvZiBlbGVtZW50QSwgdGhhdCB0d2VlbiBpbnN0YW5jZSBtYXkgc3VkZGVubHkgY2hhbmdlIGl0cyB0YXJnZXQgdG8gaW5jbHVkZSA1MCBvdGhlciBlbGVtZW50cyAodW5pbnR1aXRpdmUgaWYgSSBzcGVjaWZpY2FsbHkgZGVmaW5lZCB0aGUgdGFyZ2V0IEkgd2FudGVkKVxuXHRcdCAqICAtIFdlIGNhbid0IGp1c3QgY3JlYXRlIG5ldyBpbmRlcGVuZGVudCB0d2VlbnMgYmVjYXVzZSBvdGhlcndpc2UsIHdoYXQgaGFwcGVucyBpZiB0aGUgb3JpZ2luYWwvcGFyZW50IHR3ZWVuIGlzIHJldmVyc2VkIG9yIHBhdXNlIG9yIGRyb3BwZWQgaW50byBhIFRpbWVsaW5lTGl0ZSBmb3IgdGlnaHQgY29udHJvbD8gWW91J2QgZXhwZWN0IHRoYXQgdHdlZW4ncyBiZWhhdmlvciB0byBhZmZlY3QgYWxsIHRoZSBvdGhlcnMuXG5cdFx0ICogIC0gQW5hbHl6aW5nIGV2ZXJ5IHN0eWxlIHByb3BlcnR5IG9mIGV2ZXJ5IGNoaWxkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHR3ZWVuIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gd2hlbiB0aGVyZSBhcmUgbWFueSBjaGlsZHJlbiwgc28gdGhpcyBiZWhhdmlvciBzaG91bGRuJ3QgYmUgaW1wb3NlZCBvbiBhbGwgY2xhc3NOYW1lIHR3ZWVucyBieSBkZWZhdWx0LCBlc3BlY2lhbGx5IHNpbmNlIGl0J3MgcHJvYmFibHkgcmFyZSB0aGF0IHRoaXMgZXh0cmEgZnVuY3Rpb25hbGl0eSBpcyBuZWVkZWQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IG9iamVjdCB0byBiZSB0d2VlbmVkXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IER1cmF0aW9uIGluIHNlY29uZHMgKG9yIGZyYW1lcyBmb3IgZnJhbWVzLWJhc2VkIHR3ZWVucylcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuZCB2YWx1ZXMsIGxpa2Uge2NsYXNzTmFtZTpcIm5ld0NsYXNzXCIsIGVhc2U6TGluZWFyLmVhc2VOb25lfVxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBUd2VlbkxpdGUgaW5zdGFuY2VzXG5cdFx0ICovXG5cdFx0Q1NTUGx1Z2luLmNhc2NhZGVUbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhciB0d2VlbiA9IFR3ZWVuTGl0ZS50byh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSxcblx0XHRcdFx0cmVzdWx0cyA9IFt0d2Vlbl0sXG5cdFx0XHRcdGIgPSBbXSxcblx0XHRcdFx0ZSA9IFtdLFxuXHRcdFx0XHR0YXJnZXRzID0gW10sXG5cdFx0XHRcdF9yZXNlcnZlZFByb3BzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcyxcblx0XHRcdFx0aSwgZGlmcywgcCwgZnJvbTtcblx0XHRcdHRhcmdldCA9IHR3ZWVuLl90YXJnZXRzIHx8IHR3ZWVuLnRhcmdldDtcblx0XHRcdF9nZXRDaGlsZFN0eWxlcyh0YXJnZXQsIGIsIHRhcmdldHMpO1xuXHRcdFx0dHdlZW4ucmVuZGVyKGR1cmF0aW9uLCB0cnVlLCB0cnVlKTtcblx0XHRcdF9nZXRDaGlsZFN0eWxlcyh0YXJnZXQsIGUpO1xuXHRcdFx0dHdlZW4ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0dHdlZW4uX2VuYWJsZWQodHJ1ZSk7XG5cdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0ZGlmcyA9IF9jc3NEaWYodGFyZ2V0c1tpXSwgYltpXSwgZVtpXSk7XG5cdFx0XHRcdGlmIChkaWZzLmZpcnN0TVBUKSB7XG5cdFx0XHRcdFx0ZGlmcyA9IGRpZnMuZGlmcztcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGRpZnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcm9tID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIGRpZnMpIHtcblx0XHRcdFx0XHRcdGZyb21bcF0gPSBiW2ldW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHRzLnB1c2goVHdlZW5MaXRlLmZyb21Ubyh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgZnJvbSwgZGlmcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW0NTU1BsdWdpbl0pO1xuXHRcdHJldHVybiBDU1NQbHVnaW47XG5cblx0fSwgdHJ1ZSk7XG5cblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUm91bmRQcm9wc1BsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdChmdW5jdGlvbigpIHtcblxuXHRcdHZhciBSb3VuZFByb3BzUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdHByb3BOYW1lOiBcInJvdW5kUHJvcHNcIixcblx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRBUEk6IDIsXG5cblx0XHRcdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl90d2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pLFxuXHRcdFx0cCA9IFJvdW5kUHJvcHNQbHVnaW4ucHJvdG90eXBlO1xuXG5cdFx0cC5fb25Jbml0QWxsUHJvcHMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX3R3ZWVuLFxuXHRcdFx0XHRycCA9ICh0d2Vlbi52YXJzLnJvdW5kUHJvcHMgaW5zdGFuY2VvZiBBcnJheSkgPyB0d2Vlbi52YXJzLnJvdW5kUHJvcHMgOiB0d2Vlbi52YXJzLnJvdW5kUHJvcHMuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRpID0gcnAubGVuZ3RoLFxuXHRcdFx0XHRsb29rdXAgPSB7fSxcblx0XHRcdFx0cnB0ID0gdHdlZW4uX3Byb3BMb29rdXAucm91bmRQcm9wcyxcblx0XHRcdFx0cHJvcCwgcHQsIG5leHQ7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0bG9va3VwW3JwW2ldXSA9IDE7XG5cdFx0XHR9XG5cdFx0XHRpID0gcnAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHByb3AgPSBycFtpXTtcblx0XHRcdFx0cHQgPSB0d2Vlbi5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0OyAvL3JlY29yZCBoZXJlLCBiZWNhdXNlIGl0IG1heSBnZXQgcmVtb3ZlZFxuXHRcdFx0XHRcdGlmIChwdC5wZykge1xuXHRcdFx0XHRcdFx0cHQudC5fcm91bmRQcm9wcyhsb29rdXAsIHRydWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQubiA9PT0gcHJvcCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkKHB0LnQsIHByb3AsIHB0LnMsIHB0LmMpO1xuXHRcdFx0XHRcdFx0Ly9yZW1vdmUgZnJvbSBsaW5rZWQgbGlzdFxuXHRcdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdFx0bmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2ZpcnN0UFQgPT09IHB0KSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLl9maXJzdFBUID0gbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0Ll9uZXh0ID0gcHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0dHdlZW4uX3Byb3BMb29rdXBbcHJvcF0gPSBycHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLl9hZGQgPSBmdW5jdGlvbih0YXJnZXQsIHAsIHMsIGMpIHtcblx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgcywgcyArIGMsIHAsIHRydWUpO1xuXHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHR9O1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBdHRyUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0cHJvcE5hbWU6IFwiYXR0clwiLFxuXHRcdEFQSTogMixcblx0XHR2ZXJzaW9uOiBcIjAuMy4zXCIsXG5cblx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHR2YXIgcCwgc3RhcnQsIGVuZDtcblx0XHRcdGlmICh0eXBlb2YodGFyZ2V0LnNldEF0dHJpYnV0ZSkgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHR0aGlzLl9wcm94eSA9IHt9O1xuXHRcdFx0dGhpcy5fc3RhcnQgPSB7fTsgLy8gd2UgcmVjb3JkIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGV4YWN0bHkgYXMgdGhleSBhcmUgaW4gY2FzZSB0aGV5J3JlIHN0cmluZ3MgKG5vdCBudW1iZXJzKSAtIHdlIG5lZWQgdG8gYmUgYWJsZSB0byByZXZlcnQgdG8gdGhlbSBjbGVhbmx5LlxuXHRcdFx0dGhpcy5fZW5kID0ge307XG5cdFx0XHRmb3IgKHAgaW4gdmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRbcF0gPSB0aGlzLl9wcm94eVtwXSA9IHN0YXJ0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShwKTtcblx0XHRcdFx0ZW5kID0gdGhpcy5fYWRkVHdlZW4odGhpcy5fcHJveHksIHAsIHBhcnNlRmxvYXQoc3RhcnQpLCB2YWx1ZVtwXSwgcCk7XG5cdFx0XHRcdHRoaXMuX2VuZFtwXSA9IGVuZCA/IGVuZC5zICsgZW5kLmMgOiB2YWx1ZVtwXTtcblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdHNldDogZnVuY3Rpb24ocmF0aW8pIHtcblx0XHRcdHRoaXMuX3N1cGVyLnNldFJhdGlvLmNhbGwodGhpcywgcmF0aW8pO1xuXHRcdFx0dmFyIHByb3BzID0gdGhpcy5fb3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGgsXG5cdFx0XHRcdGxvb2t1cCA9IChyYXRpbyA9PT0gMSkgPyB0aGlzLl9lbmQgOiByYXRpbyA/IHRoaXMuX3Byb3h5IDogdGhpcy5fc3RhcnQsXG5cdFx0XHRcdHA7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHR0aGlzLl90YXJnZXQuc2V0QXR0cmlidXRlKHAsIGxvb2t1cFtwXSArIFwiXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9KTtcblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRwcm9wTmFtZTogXCJkaXJlY3Rpb25hbFJvdGF0aW9uXCIsXG5cdFx0dmVyc2lvbjogXCIwLjIuMVwiLFxuXHRcdEFQSTogMixcblxuXHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdHZhbHVlID0ge3JvdGF0aW9uOnZhbHVlfTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmluYWxzID0ge307XG5cdFx0XHR2YXIgY2FwID0gKHZhbHVlLnVzZVJhZGlhbnMgPT09IHRydWUpID8gTWF0aC5QSSAqIDIgOiAzNjAsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRwLCB2LCBzdGFydCwgZW5kLCBkaWYsIHNwbGl0O1xuXHRcdFx0Zm9yIChwIGluIHZhbHVlKSB7XG5cdFx0XHRcdGlmIChwICE9PSBcInVzZVJhZGlhbnNcIikge1xuXHRcdFx0XHRcdHNwbGl0ID0gKHZhbHVlW3BdICsgXCJcIikuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdHYgPSBzcGxpdFswXTtcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlRmxvYXQoICh0eXBlb2YodGFyZ2V0W3BdKSAhPT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFtwXSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKSApO1xuXHRcdFx0XHRcdGVuZCA9IHRoaXMuZmluYWxzW3BdID0gKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gc3RhcnQgKyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodi5zdWJzdHIoMikpIDogTnVtYmVyKHYpIHx8IDA7XG5cdFx0XHRcdFx0ZGlmID0gZW5kIC0gc3RhcnQ7XG5cdFx0XHRcdFx0aWYgKHNwbGl0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0diA9IHNwbGl0LmpvaW4oXCJfXCIpO1xuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcInNob3J0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSBkaWYgJSBjYXA7XG5cdFx0XHRcdFx0XHRcdGlmIChkaWYgIT09IGRpZiAlIChjYXAgLyAyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpZiA9IChkaWYgPCAwKSA/IGRpZiArIGNhcCA6IGRpZiAtIGNhcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcIl9jd1wiKSAhPT0gLTEgJiYgZGlmIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiArIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCJjY3dcIikgIT09IC0xICYmIGRpZiA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgLSBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRpZiA+IG1pbiB8fCBkaWYgPCAtbWluKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIHAsIHN0YXJ0LCBzdGFydCArIGRpZiwgcCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8vY2FsbGVkIGVhY2ggdGltZSB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkLCBhbmQgdGhlIHJhdGlvIGdldHMgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAodHlwaWNhbGx5IGl0J3MgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBpdCBjYW4gZXhjZWVkIHRob3NlIHdoZW4gdXNpbmcgYW4gZWFzZSBsaWtlIEVsYXN0aWMuZWFzZU91dCBvciBCYWNrLmVhc2VPdXQsIGV0Yy4pXG5cdFx0c2V0OiBmdW5jdGlvbihyYXRpbykge1xuXHRcdFx0dmFyIHB0O1xuXHRcdFx0aWYgKHJhdGlvICE9PSAxKSB7XG5cdFx0XHRcdHRoaXMuX3N1cGVyLnNldFJhdGlvLmNhbGwodGhpcywgcmF0aW8pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSh0aGlzLmZpbmFsc1twdC5wXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB0aGlzLmZpbmFsc1twdC5wXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9KS5fYXV0b0NTUyA9IHRydWU7XG5cblxuXG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRWFzZVBhY2tcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJlYXNpbmcuQmFja1wiLCBbXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oRWFzZSkge1xuXHRcdFxuXHRcdHZhciB3ID0gKF9nc1Njb3BlLkdyZWVuU29ja0dsb2JhbHMgfHwgX2dzU2NvcGUpLFxuXHRcdFx0Z3MgPSB3LmNvbS5ncmVlbnNvY2ssXG5cdFx0XHRfMlBJID0gTWF0aC5QSSAqIDIsXG5cdFx0XHRfSEFMRl9QSSA9IE1hdGguUEkgLyAyLFxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzLFxuXHRcdFx0X2NyZWF0ZSA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbigpe30sIHRydWUpLFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0X2Vhc2VSZWcgPSBFYXNlLnJlZ2lzdGVyIHx8IGZ1bmN0aW9uKCl7fSwgLy9wdXQgYW4gZW1wdHkgZnVuY3Rpb24gaW4gcGxhY2UganVzdCBhcyBhIHNhZmV0eSBtZWFzdXJlIGluIGNhc2Ugc29tZW9uZSBsb2FkcyBhbiBPTEQgdmVyc2lvbiBvZiBUd2VlbkxpdGUuanMgd2hlcmUgRWFzZS5yZWdpc3RlciBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0X3dyYXAgPSBmdW5jdGlvbihuYW1lLCBFYXNlT3V0LCBFYXNlSW4sIEVhc2VJbk91dCwgYWxpYXNlcykge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCB7XG5cdFx0XHRcdFx0ZWFzZU91dDpuZXcgRWFzZU91dCgpLFxuXHRcdFx0XHRcdGVhc2VJbjpuZXcgRWFzZUluKCksXG5cdFx0XHRcdFx0ZWFzZUluT3V0Om5ldyBFYXNlSW5PdXQoKVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0X2Vhc2VSZWcoQywgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblx0XHRcdEVhc2VQb2ludCA9IGZ1bmN0aW9uKHRpbWUsIHZhbHVlLCBuZXh0KSB7XG5cdFx0XHRcdHRoaXMudCA9IHRpbWU7XG5cdFx0XHRcdHRoaXMudiA9IHZhbHVlO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdHRoaXMubmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dC5wcmV2ID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLmMgPSBuZXh0LnYgLSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLmdhcCA9IG5leHQudCAtIHRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vQmFja1xuXHRcdFx0X2NyZWF0ZUJhY2sgPSBmdW5jdGlvbihuLCBmKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24ob3ZlcnNob290KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMSA9IChvdmVyc2hvb3QgfHwgb3ZlcnNob290ID09PSAwKSA/IG92ZXJzaG9vdCA6IDEuNzAxNTg7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMiA9IHRoaXMuX3AxICogMS41MjU7XG5cdFx0XHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKG92ZXJzaG9vdCkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgQyhvdmVyc2hvb3QpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cblx0XHRcdEJhY2sgPSBfd3JhcChcIkJhY2tcIixcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwID0gcCAtIDEpICogcCAqICgodGhpcy5fcDEgKyAxKSAqIHAgKyB0aGlzLl9wMSkgKyAxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gcCAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwIC0gdGhpcy5fcDEpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IDAuNSAqIHAgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCAtIHRoaXMuX3AyKSA6IDAuNSAqICgocCAtPSAyKSAqIHAgKiAoKHRoaXMuX3AyICsgMSkgKiBwICsgdGhpcy5fcDIpICsgMik7XG5cdFx0XHRcdH0pXG5cdFx0XHQpLFxuXG5cblx0XHRcdC8vU2xvd01vXG5cdFx0XHRTbG93TW8gPSBfY2xhc3MoXCJlYXNpbmcuU2xvd01vXCIsIGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdFx0cG93ZXIgPSAocG93ZXIgfHwgcG93ZXIgPT09IDApID8gcG93ZXIgOiAwLjc7XG5cdFx0XHRcdGlmIChsaW5lYXJSYXRpbyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bGluZWFyUmF0aW8gPSAwLjc7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZWFyUmF0aW8gPiAxKSB7XG5cdFx0XHRcdFx0bGluZWFyUmF0aW8gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3AgPSAobGluZWFyUmF0aW8gIT09IDEpID8gcG93ZXIgOiAwO1xuXHRcdFx0XHR0aGlzLl9wMSA9ICgxIC0gbGluZWFyUmF0aW8pIC8gMjtcblx0XHRcdFx0dGhpcy5fcDIgPSBsaW5lYXJSYXRpbztcblx0XHRcdFx0dGhpcy5fcDMgPSB0aGlzLl9wMSArIHRoaXMuX3AyO1xuXHRcdFx0XHR0aGlzLl9jYWxjRW5kID0gKHlveW9Nb2RlID09PSB0cnVlKTtcblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0cCA9IFNsb3dNby5wcm90b3R5cGUgPSBuZXcgRWFzZSgpLFxuXHRcdFx0U3RlcHBlZEVhc2UsIFJvdWdoRWFzZSwgX2NyZWF0ZUVsYXN0aWM7XG5cblx0XHRwLmNvbnN0cnVjdG9yID0gU2xvd01vO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHR2YXIgciA9IHAgKyAoMC41IC0gcCkgKiB0aGlzLl9wO1xuXHRcdFx0aWYgKHAgPCB0aGlzLl9wMSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgLSAoKHAgPSAxIC0gKHAgLyB0aGlzLl9wMSkpICogcCkgOiByIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHAgKiBwICogcCAqIHIpO1xuXHRcdFx0fSBlbHNlIGlmIChwID4gdGhpcy5fcDMpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKHAgPSAocCAtIHRoaXMuX3AzKSAvIHRoaXMuX3AxKSAqIHAgOiByICsgKChwIC0gcikgKiAocCA9IChwIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDEpICogcCAqIHAgKiBwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSA6IHI7XG5cdFx0fTtcblx0XHRTbG93TW8uZWFzZSA9IG5ldyBTbG93TW8oMC43LCAwLjcpO1xuXG5cdFx0cC5jb25maWcgPSBTbG93TW8uY29uZmlnID0gZnVuY3Rpb24obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTbG93TW8obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSk7XG5cdFx0fTtcblxuXG5cdFx0Ly9TdGVwcGVkRWFzZVxuXHRcdFN0ZXBwZWRFYXNlID0gX2NsYXNzKFwiZWFzaW5nLlN0ZXBwZWRFYXNlXCIsIGZ1bmN0aW9uKHN0ZXBzKSB7XG5cdFx0XHRcdHN0ZXBzID0gc3RlcHMgfHwgMTtcblx0XHRcdFx0dGhpcy5fcDEgPSAxIC8gc3RlcHM7XG5cdFx0XHRcdHRoaXMuX3AyID0gc3RlcHMgKyAxO1xuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFN0ZXBwZWRFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFN0ZXBwZWRFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAocCA8IDApIHtcblx0XHRcdFx0cCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPj0gMSkge1xuXHRcdFx0XHRwID0gMC45OTk5OTk5OTk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKCh0aGlzLl9wMiAqIHApID4+IDApICogdGhpcy5fcDE7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IFN0ZXBwZWRFYXNlLmNvbmZpZyA9IGZ1bmN0aW9uKHN0ZXBzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN0ZXBwZWRFYXNlKHN0ZXBzKTtcblx0XHR9O1xuXG5cblx0XHQvL1JvdWdoRWFzZVxuXHRcdFJvdWdoRWFzZSA9IF9jbGFzcyhcImVhc2luZy5Sb3VnaEVhc2VcIiwgZnVuY3Rpb24odmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHR2YXIgdGFwZXIgPSB2YXJzLnRhcGVyIHx8IFwibm9uZVwiLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHBvaW50cyA9ICh2YXJzLnBvaW50cyB8fCAyMCkgfCAwLFxuXHRcdFx0XHRpID0gcG9pbnRzLFxuXHRcdFx0XHRyYW5kb21pemUgPSAodmFycy5yYW5kb21pemUgIT09IGZhbHNlKSxcblx0XHRcdFx0Y2xhbXAgPSAodmFycy5jbGFtcCA9PT0gdHJ1ZSksXG5cdFx0XHRcdHRlbXBsYXRlID0gKHZhcnMudGVtcGxhdGUgaW5zdGFuY2VvZiBFYXNlKSA/IHZhcnMudGVtcGxhdGUgOiBudWxsLFxuXHRcdFx0XHRzdHJlbmd0aCA9ICh0eXBlb2YodmFycy5zdHJlbmd0aCkgPT09IFwibnVtYmVyXCIpID8gdmFycy5zdHJlbmd0aCAqIDAuNCA6IDAuNCxcblx0XHRcdFx0eCwgeSwgYnVtcCwgaW52WCwgb2JqLCBwbnQ7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0eCA9IHJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgOiAoMSAvIHBvaW50cykgKiBpO1xuXHRcdFx0XHR5ID0gdGVtcGxhdGUgPyB0ZW1wbGF0ZS5nZXRSYXRpbyh4KSA6IHg7XG5cdFx0XHRcdGlmICh0YXBlciA9PT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRidW1wID0gc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFwZXIgPT09IFwib3V0XCIpIHtcblx0XHRcdFx0XHRpbnZYID0gMSAtIHg7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFwZXIgPT09IFwiaW5cIikge1xuXHRcdFx0XHRcdGJ1bXAgPSB4ICogeCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHggPCAwLjUpIHsgIC8vXCJib3RoXCIgKHN0YXJ0KVxuXHRcdFx0XHRcdGludlggPSB4ICogMjtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHRcdC8vXCJib3RoXCIgKGVuZClcblx0XHRcdFx0XHRpbnZYID0gKDEgLSB4KSAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJhbmRvbWl6ZSkge1xuXHRcdFx0XHRcdHkgKz0gKE1hdGgucmFuZG9tKCkgKiBidW1wKSAtIChidW1wICogMC41KTtcblx0XHRcdFx0fSBlbHNlIGlmIChpICUgMikge1xuXHRcdFx0XHRcdHkgKz0gYnVtcCAqIDAuNTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5IC09IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNsYW1wKSB7XG5cdFx0XHRcdFx0aWYgKHkgPiAxKSB7XG5cdFx0XHRcdFx0XHR5ID0gMTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgPCAwKSB7XG5cdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtjbnQrK10gPSB7eDp4LCB5Onl9O1xuXHRcdFx0fVxuXHRcdFx0YS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEueCAtIGIueDtcblx0XHRcdH0pO1xuXG5cdFx0XHRwbnQgPSBuZXcgRWFzZVBvaW50KDEsIDEsIG51bGwpO1xuXHRcdFx0aSA9IHBvaW50cztcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRvYmogPSBhW2ldO1xuXHRcdFx0XHRwbnQgPSBuZXcgRWFzZVBvaW50KG9iai54LCBvYmoueSwgcG50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcHJldiA9IG5ldyBFYXNlUG9pbnQoMCwgMCwgKHBudC50ICE9PSAwKSA/IHBudCA6IHBudC5uZXh0KTtcblx0XHR9LCB0cnVlKTtcblx0XHRwID0gUm91Z2hFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFJvdWdoRWFzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHBudCA9IHRoaXMuX3ByZXY7XG5cdFx0XHRpZiAocCA+IHBudC50KSB7XG5cdFx0XHRcdHdoaWxlIChwbnQubmV4dCAmJiBwID49IHBudC50KSB7XG5cdFx0XHRcdFx0cG50ID0gcG50Lm5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG50ID0gcG50LnByZXY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAocG50LnByZXYgJiYgcCA8PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wcmV2ID0gcG50O1xuXHRcdFx0cmV0dXJuIChwbnQudiArICgocCAtIHBudC50KSAvIHBudC5nYXApICogcG50LmMpO1xuXHRcdH07XG5cdFx0cC5jb25maWcgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJvdWdoRWFzZSh2YXJzKTtcblx0XHR9O1xuXHRcdFJvdWdoRWFzZS5lYXNlID0gbmV3IFJvdWdoRWFzZSgpO1xuXG5cblx0XHQvL0JvdW5jZVxuXHRcdF93cmFwKFwiQm91bmNlXCIsXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAoKHAgPSAxIC0gcCkgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIHAgKiBwKTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1KTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzUpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHR2YXIgaW52ZXJ0ID0gKHAgPCAwLjUpO1xuXHRcdFx0XHRpZiAoaW52ZXJ0KSB7XG5cdFx0XHRcdFx0cCA9IDEgLSAocCAqIDIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSAocCAqIDIpIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocCA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIHAgKiBwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGludmVydCA/ICgxIC0gcCkgKiAwLjUgOiBwICogMC41ICsgMC41O1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0NJUkNcblx0XHRfd3JhcChcIkNpcmNcIixcblx0XHRcdF9jcmVhdGUoXCJDaXJjT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKHAgPSBwIC0gMSkgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtKE1hdGguc3FydCgxIC0gKHAgKiBwKSkgLSAxKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAqPTIpIDwgMSkgPyAtMC41ICogKE1hdGguc3FydCgxIC0gcCAqIHApIC0gMSkgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAocCAtPSAyKSAqIHApICsgMSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vRWxhc3RpY1xuXHRcdF9jcmVhdGVFbGFzdGljID0gZnVuY3Rpb24obiwgZiwgZGVmKSB7XG5cdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdFx0dGhpcy5fcDEgPSAoYW1wbGl0dWRlID49IDEpID8gYW1wbGl0dWRlIDogMTsgLy9ub3RlOiBpZiBhbXBsaXR1ZGUgaXMgPCAxLCB3ZSBzaW1wbHkgYWRqdXN0IHRoZSBwZXJpb2QgZm9yIGEgbW9yZSBuYXR1cmFsIGZlZWwuIE90aGVyd2lzZSB0aGUgbWF0aCBkb2Vzbid0IHdvcmsgcmlnaHQgYW5kIHRoZSBjdXJ2ZSBzdGFydHMgYXQgMS5cblx0XHRcdFx0XHR0aGlzLl9wMiA9IChwZXJpb2QgfHwgZGVmKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSk7XG5cdFx0XHRcdFx0dGhpcy5fcDMgPSB0aGlzLl9wMiAvIF8yUEkgKiAoTWF0aC5hc2luKDEgLyB0aGlzLl9wMSkgfHwgMCk7XG5cdFx0XHRcdFx0dGhpcy5fcDIgPSBfMlBJIC8gdGhpcy5fcDI7IC8vcHJlY2FsY3VsYXRlIHRvIG9wdGltaXplXG5cdFx0XHRcdH0sIHRydWUpLFxuXHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdHAuY29uZmlnID0gZnVuY3Rpb24oYW1wbGl0dWRlLCBwZXJpb2QpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBDKGFtcGxpdHVkZSwgcGVyaW9kKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gQztcblx0XHR9O1xuXHRcdF93cmFwKFwiRWxhc3RpY1wiLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3AxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApICsgMTtcblx0XHRcdH0sIDAuMyksXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApKTtcblx0XHRcdH0sIDAuMyksXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IC0wLjUgKiAodGhpcy5fcDEgKiBNYXRoLnBvdygyLCAxMCAqIChwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyKSkgOiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSAqIDAuNSArIDE7XG5cdFx0XHR9LCAwLjQ1KVxuXHRcdCk7XG5cblxuXHRcdC8vRXhwb1xuXHRcdF93cmFwKFwiRXhwb1wiLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHApO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiRXhwb0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgLSAwLjAwMTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9Jbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9TaW5lXG5cdFx0X3dyYXAoXCJTaW5lXCIsXG5cdFx0XHRfY3JlYXRlKFwiU2luZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNpbihwICogX0hBTEZfUEkpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiU2luZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC1NYXRoLmNvcyhwICogX0hBTEZfUEkpICsgMTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiBwKSAtIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0X2NsYXNzKFwiZWFzaW5nLkVhc2VMb29rdXBcIiwge1xuXHRcdFx0XHRmaW5kOmZ1bmN0aW9uKHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gRWFzZS5tYXBbc107XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpO1xuXG5cdFx0Ly9yZWdpc3RlciB0aGUgbm9uLXN0YW5kYXJkIGVhc2VzXG5cdFx0X2Vhc2VSZWcody5TbG93TW8sIFwiU2xvd01vXCIsIFwiZWFzZSxcIik7XG5cdFx0X2Vhc2VSZWcoUm91Z2hFYXNlLCBcIlJvdWdoRWFzZVwiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFN0ZXBwZWRFYXNlLCBcIlN0ZXBwZWRFYXNlXCIsIFwiZWFzZSxcIik7XG5cblx0XHRyZXR1cm4gQmFjaztcblx0XHRcblx0fSwgdHJ1ZSk7XG5cblxufSk7XG5cbmlmIChfZ3NTY29wZS5fZ3NEZWZpbmUpIHsgX2dzU2NvcGUuX2dzUXVldWUucG9wKCkoKTsgfSAvL25lY2Vzc2FyeSBpbiBjYXNlIFR3ZWVuTGl0ZSB3YXMgYWxyZWFkeSBsb2FkZWQgc2VwYXJhdGVseS5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQmFzZSBjbGFzc2VzIGxpa2UgVHdlZW5MaXRlLCBTaW1wbGVUaW1lbGluZSwgRWFzZSwgVGlja2VyLCBldGMuXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIG1vZHVsZU5hbWUpIHtcblxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfZ2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgfHwgd2luZG93O1xuXHRcdGlmIChfZ2xvYmFscy5Ud2VlbkxpdGUpIHtcblx0XHRcdHJldHVybjsgLy9pbiBjYXNlIHRoZSBjb3JlIHNldCBvZiBjbGFzc2VzIGlzIGFscmVhZHkgbG9hZGVkLCBkb24ndCBpbnN0YW50aWF0ZSB0d2ljZS5cblx0XHR9XG5cdFx0dmFyIF9uYW1lc3BhY2UgPSBmdW5jdGlvbihucykge1xuXHRcdFx0XHR2YXIgYSA9IG5zLnNwbGl0KFwiLlwiKSxcblx0XHRcdFx0XHRwID0gX2dsb2JhbHMsIGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cFthW2ldXSA9IHAgPSBwW2FbaV1dIHx8IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fSxcblx0XHRcdGdzID0gX25hbWVzcGFjZShcImNvbS5ncmVlbnNvY2tcIiksXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdF9lbXB0eUZ1bmMgPSBmdW5jdGlvbigpIHt9LFxuXHRcdFx0X2lzQXJyYXkgPSAoZnVuY3Rpb24oKSB7IC8vd29ya3MgYXJvdW5kIGlzc3VlcyBpbiBpZnJhbWUgZW52aXJvbm1lbnRzIHdoZXJlIHRoZSBBcnJheSBnbG9iYWwgaXNuJ3Qgc2hhcmVkLCB0aHVzIGlmIHRoZSBvYmplY3Qgb3JpZ2luYXRlcyBpbiBhIGRpZmZlcmVudCB3aW5kb3cvaWZyYW1lLCBcIihvYmogaW5zdGFuY2VvZiBBcnJheSlcIiB3aWxsIGV2YWx1YXRlIGZhbHNlLiBXZSBhZGRlZCBzb21lIHNwZWVkIG9wdGltaXphdGlvbnMgdG8gYXZvaWQgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCkgdW5sZXNzIGl0J3MgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIFZFUlkgc2xvdyAobGlrZSAyMHggc2xvd2VyKVxuXHRcdFx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuXHRcdFx0XHRcdGFycmF5ID0gdG9TdHJpbmcuY2FsbChbXSk7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5IHx8ICh0eXBlb2Yob2JqKSA9PT0gXCJvYmplY3RcIiAmJiAhIW9iai5wdXNoICYmIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gYXJyYXkpKTtcblx0XHRcdFx0fTtcblx0XHRcdH0oKSksXG5cdFx0XHRhLCBpLCBwLCBfdGlja2VyLCBfdGlja2VyQWN0aXZlLFxuXHRcdFx0X2RlZkxvb2t1cCA9IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdFx0ICogRGVmaW5lcyBhIEdyZWVuU29jayBjbGFzcywgb3B0aW9uYWxseSB3aXRoIGFuIGFycmF5IG9mIGRlcGVuZGVuY2llcyB0aGF0IG11c3QgYmUgaW5zdGFudGlhdGVkIGZpcnN0IGFuZCBwYXNzZWQgaW50byB0aGUgZGVmaW5pdGlvbi5cblx0XHRcdCAqIFRoaXMgYWxsb3dzIHVzZXJzIHRvIGxvYWQgR3JlZW5Tb2NrIEpTIGZpbGVzIGluIGFueSBvcmRlciBldmVuIGlmIHRoZXkgaGF2ZSBpbnRlcmRlcGVuZGVuY2llcyAobGlrZSBDU1NQbHVnaW4gZXh0ZW5kcyBUd2VlblBsdWdpbiB3aGljaCBpc1xuXHRcdFx0ICogaW5zaWRlIFR3ZWVuTGl0ZS5qcywgYnV0IGlmIENTU1BsdWdpbiBpcyBsb2FkZWQgZmlyc3QsIGl0IHNob3VsZCB3YWl0IHRvIHJ1biBpdHMgY29kZSB1bnRpbCBUd2VlbkxpdGUuanMgbG9hZHMgYW5kIGluc3RhbnRpYXRlcyBUd2VlblBsdWdpblxuXHRcdFx0ICogYW5kIHRoZW4gcGFzcyBUd2VlblBsdWdpbiB0byBDU1NQbHVnaW4ncyBkZWZpbml0aW9uKS4gVGhpcyBpcyBhbGwgZG9uZSBhdXRvbWF0aWNhbGx5IGFuZCBpbnRlcm5hbGx5LlxuXHRcdFx0ICpcblx0XHRcdCAqIEV2ZXJ5IGRlZmluaXRpb24gd2lsbCBiZSBhZGRlZCB0byBhIFwiY29tLmdyZWVuc29ja1wiIGdsb2JhbCBvYmplY3QgKHR5cGljYWxseSB3aW5kb3csIGJ1dCBpZiBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdCBpcyBmb3VuZCxcblx0XHRcdCAqIGl0IHdpbGwgZ28gdGhlcmUgYXMgb2YgdjEuNykuIEZvciBleGFtcGxlLCBUd2VlbkxpdGUgd2lsbCBiZSBmb3VuZCBhdCB3aW5kb3cuY29tLmdyZWVuc29jay5Ud2VlbkxpdGUgYW5kIHNpbmNlIGl0J3MgYSBnbG9iYWwgY2xhc3MgdGhhdCBzaG91bGQgYmUgYXZhaWxhYmxlIGFueXdoZXJlLFxuXHRcdFx0ICogaXQgaXMgQUxTTyByZWZlcmVuY2VkIGF0IHdpbmRvdy5Ud2VlbkxpdGUuIEhvd2V2ZXIgc29tZSBjbGFzc2VzIGFyZW4ndCBjb25zaWRlcmVkIGdsb2JhbCwgbGlrZSB0aGUgYmFzZSBjb20uZ3JlZW5zb2NrLmNvcmUuQW5pbWF0aW9uIGNsYXNzLCBzb1xuXHRcdFx0ICogdGhvc2Ugd2lsbCBvbmx5IGJlIGF0IHRoZSBwYWNrYWdlIGxpa2Ugd2luZG93LmNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24uIEFnYWluLCBpZiB5b3UgZGVmaW5lIGEgR3JlZW5Tb2NrR2xvYmFscyBvYmplY3Qgb24gdGhlIHdpbmRvdywgZXZlcnl0aGluZ1xuXHRcdFx0ICogZ2V0cyB0dWNrZWQgbmVhdGx5IGluc2lkZSB0aGVyZSBpbnN0ZWFkIG9mIG9uIHRoZSB3aW5kb3cgZGlyZWN0bHkuIFRoaXMgYWxsb3dzIHlvdSB0byBkbyBhZHZhbmNlZCB0aGluZ3MgbGlrZSBsb2FkIG11bHRpcGxlIHZlcnNpb25zIG9mIEdyZWVuU29ja1xuXHRcdFx0ICogZmlsZXMgYW5kIHB1dCB0aGVtIGludG8gZGlzdGluY3Qgb2JqZWN0cyAoaW1hZ2luZSBhIGJhbm5lciBhZCB1c2VzIGEgbmV3ZXIgdmVyc2lvbiBidXQgdGhlIG1haW4gc2l0ZSB1c2VzIGFuIG9sZGVyIG9uZSkuIEluIHRoYXQgY2FzZSwgeW91IGNvdWxkXG5cdFx0XHQgKiBzYW5kYm94IHRoZSBiYW5uZXIgb25lIGxpa2U6XG5cdFx0XHQgKlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB2YXIgZ3MgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHt9OyAvL3RoZSBuZXdlciB2ZXJzaW9uIHdlJ3JlIGFib3V0IHRvIGxvYWQgY291bGQgbm93IGJlIHJlZmVyZW5jZWQgaW4gYSBcImdzXCIgb2JqZWN0LCBsaWtlIGdzLlR3ZWVuTGl0ZS50byguLi4pLiBVc2Ugd2hhdGV2ZXIgYWxpYXMgeW91IHdhbnQgYXMgbG9uZyBhcyBpdCdzIHVuaXF1ZSwgXCJnc1wiIG9yIFwiYmFubmVyXCIgb3Igd2hhdGV2ZXIuXG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQgc3JjPVwianMvZ3JlZW5zb2NrL3YxLjcvVHdlZW5NYXguanNcIj48L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3cuX2dzUXVldWUgPSB3aW5kb3cuX2dzRGVmaW5lID0gbnVsbDsgLy9yZXNldCBpdCBiYWNrIHRvIG51bGwgKGFsb25nIHdpdGggdGhlIHNwZWNpYWwgX2dzUXVldWUgdmFyaWFibGUpIHNvIHRoYXQgdGhlIG5leHQgbG9hZCBvZiBUd2Vlbk1heCBhZmZlY3RzIHRoZSB3aW5kb3cgYW5kIHdlIGNhbiByZWZlcmVuY2UgdGhpbmdzIGRpcmVjdGx5IGxpa2UgVHdlZW5MaXRlLnRvKC4uLilcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNi9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICBncy5Ud2VlbkxpdGUudG8oLi4uKTsgLy93b3VsZCB1c2UgdjEuN1xuXHRcdFx0ICogICAgIFR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS42XG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IG5zIFRoZSBuYW1lc3BhY2Ugb2YgdGhlIGNsYXNzIGRlZmluaXRpb24sIGxlYXZpbmcgb2ZmIFwiY29tLmdyZWVuc29jay5cIiBhcyB0aGF0J3MgYXNzdW1lZC4gRm9yIGV4YW1wbGUsIFwiVHdlZW5MaXRlXCIgb3IgXCJwbHVnaW5zLkNTU1BsdWdpblwiIG9yIFwiZWFzaW5nLkJhY2tcIi5cblx0XHRcdCAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBkZXBlbmRlbmNpZXMgQW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIChkZXNjcmliZWQgYXMgdGhlaXIgbmFtZXNwYWNlcyBtaW51cyBcImNvbS5ncmVlbnNvY2suXCIgcHJlZml4KS4gRm9yIGV4YW1wbGUgW1wiVHdlZW5MaXRlXCIsXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJjb3JlLkFuaW1hdGlvblwiXVxuXHRcdFx0ICogQHBhcmFtIHshZnVuY3Rpb24oKTpPYmplY3R9IGZ1bmMgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBhbmQgcGFzc2VkIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXMgd2hpY2ggd2lsbCByZXR1cm4gdGhlIGFjdHVhbCBjbGFzcyBmb3IgdGhpcyBkZWZpbml0aW9uLlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gZ2xvYmFsIElmIHRydWUsIHRoZSBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBnbG9iYWwgc2NvcGUgKHR5cGljYWxseSB3aW5kb3cgdW5sZXNzIHlvdSBkZWZpbmUgYSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyBvYmplY3QpXG5cdFx0XHQgKi9cblx0XHRcdERlZmluaXRpb24gPSBmdW5jdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0dGhpcy5zYyA9IChfZGVmTG9va3VwW25zXSkgPyBfZGVmTG9va3VwW25zXS5zYyA6IFtdOyAvL3N1YmNsYXNzZXNcblx0XHRcdFx0X2RlZkxvb2t1cFtuc10gPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmdzQ2xhc3MgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmZ1bmMgPSBmdW5jO1xuXHRcdFx0XHR2YXIgX2NsYXNzZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5jaGVjayA9IGZ1bmN0aW9uKGluaXQpIHtcblx0XHRcdFx0XHR2YXIgaSA9IGRlcGVuZGVuY2llcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRtaXNzaW5nID0gaSxcblx0XHRcdFx0XHRcdGN1ciwgYSwgbiwgY2w7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGN1ciA9IF9kZWZMb29rdXBbZGVwZW5kZW5jaWVzW2ldXSB8fCBuZXcgRGVmaW5pdGlvbihkZXBlbmRlbmNpZXNbaV0sIFtdKSkuZ3NDbGFzcykge1xuXHRcdFx0XHRcdFx0XHRfY2xhc3Nlc1tpXSA9IGN1ci5nc0NsYXNzO1xuXHRcdFx0XHRcdFx0XHRtaXNzaW5nLS07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGluaXQpIHtcblx0XHRcdFx0XHRcdFx0Y3VyLnNjLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtaXNzaW5nID09PSAwICYmIGZ1bmMpIHtcblx0XHRcdFx0XHRcdGEgPSAoXCJjb20uZ3JlZW5zb2NrLlwiICsgbnMpLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0XHRcdG4gPSBhLnBvcCgpO1xuXHRcdFx0XHRcdFx0Y2wgPSBfbmFtZXNwYWNlKGEuam9pbihcIi5cIikpW25dID0gdGhpcy5nc0NsYXNzID0gZnVuYy5hcHBseShmdW5jLCBfY2xhc3Nlcyk7XG5cblx0XHRcdFx0XHRcdC8vZXhwb3J0cyB0byBtdWx0aXBsZSBlbnZpcm9ubWVudHNcblx0XHRcdFx0XHRcdGlmIChnbG9iYWwpIHtcblx0XHRcdFx0XHRcdFx0X2dsb2JhbHNbbl0gPSBjbDsgLy9wcm92aWRlcyBhIHdheSB0byBhdm9pZCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvbi4gQnkgZGVmYXVsdCwgdGhlIG1haW4gY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgUG93ZXIxLCBTdHJvbmcsIGV0Yy4gYXJlIGFkZGVkIHRvIHdpbmRvdyB1bmxlc3MgYSBHcmVlblNvY2tHbG9iYWxzIGlzIGRlZmluZWQuIFNvIGlmIHlvdSB3YW50IHRvIGhhdmUgdGhpbmdzIGFkZGVkIHRvIGEgY3VzdG9tIG9iamVjdCBpbnN0ZWFkLCBqdXN0IGRvIHNvbWV0aGluZyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge30gYmVmb3JlIGxvYWRpbmcgYW55IEdyZWVuU29jayBmaWxlcy4gWW91IGNhbiBldmVuIHNldCB1cCBhbiBhbGlhcyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93cy5ncyA9IHt9IHNvIHRoYXQgeW91IGNhbiBhY2Nlc3MgZXZlcnl0aGluZyBsaWtlIGdzLlR3ZWVuTGl0ZS4gQWxzbyByZW1lbWJlciB0aGF0IEFMTCBjbGFzc2VzIGFyZSBhZGRlZCB0byB0aGUgd2luZG93LmNvbS5ncmVlbnNvY2sgb2JqZWN0IChpbiB0aGVpciByZXNwZWN0aXZlIHBhY2thZ2VzLCBsaWtlIGNvbS5ncmVlbnNvY2suZWFzaW5nLlBvd2VyMSwgY29tLmdyZWVuc29jay5Ud2VlbkxpdGUsIGV0Yy4pXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpeyAvL0FNRFxuXHRcdFx0XHRcdFx0XHRcdGRlZmluZSgod2luZG93LkdyZWVuU29ja0FNRFBhdGggPyB3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCArIFwiL1wiIDogXCJcIikgKyBucy5zcGxpdChcIi5cIikucG9wKCksIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsOyB9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChucyA9PT0gbW9kdWxlTmFtZSAmJiB0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyl7IC8vbm9kZVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gY2w7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLnNjLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2NbaV0uY2hlY2soKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuY2hlY2sodHJ1ZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3VzZWQgdG8gY3JlYXRlIERlZmluaXRpb24gaW5zdGFuY2VzICh3aGljaCBiYXNpY2FsbHkgcmVnaXN0ZXJzIGEgY2xhc3MgdGhhdCBoYXMgZGVwZW5kZW5jaWVzKS5cblx0XHRcdF9nc0RlZmluZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBmdW5jdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBEZWZpbml0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2EgcXVpY2sgd2F5IHRvIGNyZWF0ZSBhIGNsYXNzIHRoYXQgZG9lc24ndCBoYXZlIGFueSBkZXBlbmRlbmNpZXMuIFJldHVybnMgdGhlIGNsYXNzLCBidXQgZmlyc3QgcmVnaXN0ZXJzIGl0IGluIHRoZSBHcmVlblNvY2sgbmFtZXNwYWNlIHNvIHRoYXQgb3RoZXIgY2xhc3NlcyBjYW4gZ3JhYiBpdCAob3RoZXIgY2xhc3NlcyBtaWdodCBiZSBkZXBlbmRlbnQgb24gdGhlIGNsYXNzKS5cblx0XHRcdF9jbGFzcyA9IGdzLl9jbGFzcyA9IGZ1bmN0aW9uKG5zLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0ZnVuYyA9IGZ1bmMgfHwgZnVuY3Rpb24oKSB7fTtcblx0XHRcdFx0X2dzRGVmaW5lKG5zLCBbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmM7IH0sIGdsb2JhbCk7XG5cdFx0XHRcdHJldHVybiBmdW5jO1xuXHRcdFx0fTtcblxuXHRcdF9nc0RlZmluZS5nbG9iYWxzID0gX2dsb2JhbHM7XG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRWFzZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIF9iYXNlUGFyYW1zID0gWzAsIDAsIDEsIDFdLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuRWFzZVwiLCBmdW5jdGlvbihmdW5jLCBleHRyYVBhcmFtcywgdHlwZSwgcG93ZXIpIHtcblx0XHRcdFx0dGhpcy5fZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3Bvd2VyID0gcG93ZXIgfHwgMDtcblx0XHRcdFx0dGhpcy5fcGFyYW1zID0gZXh0cmFQYXJhbXMgPyBfYmFzZVBhcmFtcy5jb25jYXQoZXh0cmFQYXJhbXMpIDogX2Jhc2VQYXJhbXM7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdF9lYXNlTWFwID0gRWFzZS5tYXAgPSB7fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGVhc2UsIG5hbWVzLCB0eXBlcywgY3JlYXRlKSB7XG5cdFx0XHRcdHZhciBuYSA9IG5hbWVzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRpID0gbmEubGVuZ3RoLFxuXHRcdFx0XHRcdHRhID0gKHR5cGVzIHx8IFwiZWFzZUluLGVhc2VPdXQsZWFzZUluT3V0XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRlLCBuYW1lLCBqLCB0eXBlO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRuYW1lID0gbmFbaV07XG5cdFx0XHRcdFx0ZSA9IGNyZWF0ZSA/IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCBudWxsLCB0cnVlKSA6IGdzLmVhc2luZ1tuYW1lXSB8fCB7fTtcblx0XHRcdFx0XHRqID0gdGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRhW2pdO1xuXHRcdFx0XHRcdFx0X2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgdHlwZV0gPSBfZWFzZU1hcFt0eXBlICsgbmFtZV0gPSBlW3R5cGVdID0gZWFzZS5nZXRSYXRpbyA/IGVhc2UgOiBlYXNlW3R5cGVdIHx8IG5ldyBlYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cCA9IEVhc2UucHJvdG90eXBlO1xuXHRcdHAuX2NhbGNFbmQgPSBmYWxzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHRoaXMuX2Z1bmMpIHtcblx0XHRcdFx0dGhpcy5fcGFyYW1zWzBdID0gcDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2Z1bmMuYXBwbHkobnVsbCwgdGhpcy5fcGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHZhciB0ID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cHcgPSB0aGlzLl9wb3dlcixcblx0XHRcdFx0ciA9ICh0ID09PSAxKSA/IDEgLSBwIDogKHQgPT09IDIpID8gcCA6IChwIDwgMC41KSA/IHAgKiAyIDogKDEgLSBwKSAqIDI7XG5cdFx0XHRpZiAocHcgPT09IDEpIHtcblx0XHRcdFx0ciAqPSByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMikge1xuXHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMykge1xuXHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDQpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgLSByIDogKHQgPT09IDIpID8gciA6IChwIDwgMC41KSA/IHIgLyAyIDogMSAtIChyIC8gMik7XG5cdFx0fTtcblxuXHRcdC8vY3JlYXRlIGFsbCB0aGUgc3RhbmRhcmQgZWFzZXMgbGlrZSBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBhbmQgUG93ZXI0IChlYWNoIHdpdGggZWFzZUluLCBlYXNlT3V0LCBhbmQgZWFzZUluT3V0KVxuXHRcdGEgPSBbXCJMaW5lYXJcIixcIlF1YWRcIixcIkN1YmljXCIsXCJRdWFydFwiLFwiUXVpbnQsU3Ryb25nXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdHAgPSBhW2ldK1wiLFBvd2VyXCIraTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwxLGkpLCBwLCBcImVhc2VPdXRcIiwgdHJ1ZSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMixpKSwgcCwgXCJlYXNlSW5cIiArICgoaSA9PT0gMCkgPyBcIixlYXNlTm9uZVwiIDogXCJcIikpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDMsaSksIHAsIFwiZWFzZUluT3V0XCIpO1xuXHRcdH1cblx0XHRfZWFzZU1hcC5saW5lYXIgPSBncy5lYXNpbmcuTGluZWFyLmVhc2VJbjtcblx0XHRfZWFzZU1hcC5zd2luZyA9IGdzLmVhc2luZy5RdWFkLmVhc2VJbk91dDsgLy9mb3IgalF1ZXJ5IGZvbGtzXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEV2ZW50RGlzcGF0Y2hlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEV2ZW50RGlzcGF0Y2hlciA9IF9jbGFzcyhcImV2ZW50cy5FdmVudERpc3BhdGNoZXJcIiwgZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRcdHRoaXMuX2V2ZW50VGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXM7XG5cdFx0fSk7XG5cdFx0cCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cblx0XHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgc2NvcGUsIHVzZVBhcmFtLCBwcmlvcml0eSkge1xuXHRcdFx0cHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGlzdGVuZXIsIGk7XG5cdFx0XHRpZiAobGlzdCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IGxpc3QgPSBbXTtcblx0XHRcdH1cblx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdGlmIChsaXN0ZW5lci5jID09PSBjYWxsYmFjayAmJiBsaXN0ZW5lci5zID09PSBzY29wZSkge1xuXHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4ID09PSAwICYmIGxpc3RlbmVyLnByIDwgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHRpbmRleCA9IGkgKyAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNwbGljZShpbmRleCwgMCwge2M6Y2FsbGJhY2ssIHM6c2NvcGUsIHVwOnVzZVBhcmFtLCBwcjpwcmlvcml0eX0pO1xuXHRcdFx0aWYgKHRoaXMgPT09IF90aWNrZXIgJiYgIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSwgaTtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGxpc3RbaV0uYyA9PT0gY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aSwgdCwgbGlzdGVuZXI7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdHQgPSB0aGlzLl9ldmVudFRhcmdldDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChsaXN0ZW5lcikge1xuXHRcdFx0XHRcdFx0aWYgKGxpc3RlbmVyLnVwKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmMuY2FsbChsaXN0ZW5lci5zIHx8IHQsIHt0eXBlOnR5cGUsIHRhcmdldDp0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jLmNhbGwobGlzdGVuZXIucyB8fCB0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaWNrZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuIFx0XHR2YXIgX3JlcUFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG5cdFx0XHRfY2FuY2VsQW5pbUZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFxuXHRcdFx0X2dldFRpbWUgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7fSxcblx0XHRcdF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKTtcblxuXHRcdC8vbm93IHRyeSB0byBkZXRlcm1pbmUgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhbmQgY2FuY2VsQW5pbWF0aW9uRnJhbWUgZnVuY3Rpb25zIGFuZCBpZiBub25lIGFyZSBmb3VuZCwgd2UnbGwgdXNlIGEgc2V0VGltZW91dCgpL2NsZWFyVGltZW91dCgpIHBvbHlmaWxsLlxuXHRcdGEgPSBbXCJtc1wiLFwibW96XCIsXCJ3ZWJraXRcIixcIm9cIl07XG5cdFx0aSA9IGEubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSAmJiAhX3JlcUFuaW1GcmFtZSkge1xuXHRcdFx0X3JlcUFuaW1GcmFtZSA9IHdpbmRvd1thW2ldICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG5cdFx0XHRfY2FuY2VsQW5pbUZyYW1lID0gd2luZG93W2FbaV0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8IHdpbmRvd1thW2ldICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG5cdFx0fVxuXG5cdFx0X2NsYXNzKFwiVGlja2VyXCIsIGZ1bmN0aW9uKGZwcywgdXNlUkFGKSB7XG5cdFx0XHR2YXIgX3NlbGYgPSB0aGlzLFxuXHRcdFx0XHRfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcblx0XHRcdFx0X3VzZVJBRiA9ICh1c2VSQUYgIT09IGZhbHNlICYmIF9yZXFBbmltRnJhbWUpLFxuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gNTAwLFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSAzMyxcblx0XHRcdFx0X3RpY2tXb3JkID0gXCJ0aWNrXCIsIC8vaGVscHMgcmVkdWNlIGdjIGJ1cmRlblxuXHRcdFx0XHRfZnBzLCBfcmVxLCBfaWQsIF9nYXAsIF9uZXh0VGltZSxcblx0XHRcdFx0X3RpY2sgPSBmdW5jdGlvbihtYW51YWwpIHtcblx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSxcblx0XHRcdFx0XHRcdG92ZXJsYXAsIGRpc3BhdGNoO1xuXHRcdFx0XHRcdGlmIChlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0X3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdF9zZWxmLnRpbWUgPSAoX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lKSAvIDEwMDA7XG5cdFx0XHRcdFx0b3ZlcmxhcCA9IF9zZWxmLnRpbWUgLSBfbmV4dFRpbWU7XG5cdFx0XHRcdFx0aWYgKCFfZnBzIHx8IG92ZXJsYXAgPiAwIHx8IG1hbnVhbCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0X3NlbGYuZnJhbWUrKztcblx0XHRcdFx0XHRcdF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDAuMDA0IDogX2dhcCAtIG92ZXJsYXApO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWFudWFsICE9PSB0cnVlKSB7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cdFx0XHRcdFx0XHRfaWQgPSBfcmVxKF90aWNrKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5kaXNwYXRjaEV2ZW50KF90aWNrV29yZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRFdmVudERpc3BhdGNoZXIuY2FsbChfc2VsZik7XG5cdFx0XHRfc2VsZi50aW1lID0gX3NlbGYuZnJhbWUgPSAwO1xuXHRcdFx0X3NlbGYudGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGljayh0cnVlKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmxhZ1Ntb290aGluZyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdFx0X2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAoMSAvIF90aW55TnVtKTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnNsZWVwID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfaWQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV91c2VSQUYgfHwgIV9jYW5jZWxBbmltRnJhbWUpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoX2lkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfY2FuY2VsQW5pbUZyYW1lKF9pZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IF9lbXB0eUZ1bmM7XG5cdFx0XHRcdF9pZCA9IG51bGw7XG5cdFx0XHRcdGlmIChfc2VsZiA9PT0gX3RpY2tlcikge1xuXHRcdFx0XHRcdF90aWNrZXJBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYud2FrZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX2lkICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0X3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChfc2VsZi5mcmFtZSA+IDEwKSB7IC8vZG9uJ3QgdHJpZ2dlciBsYWdTbW9vdGhpbmcgaWYgd2UncmUganVzdCB3YWtpbmcgdXAsIGFuZCBtYWtlIHN1cmUgdGhhdCBhdCBsZWFzdCAxMCBmcmFtZXMgaGF2ZSBlbGFwc2VkIGJlY2F1c2Ugb2YgdGhlIGlPUyBidWcgdGhhdCB3ZSB3b3JrIGFyb3VuZCBiZWxvdyB3aXRoIHRoZSAxLjUtc2Vjb25kIHNldFRpbW91dCgpLlxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKSAtIF9sYWdUaHJlc2hvbGQgKyA1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXEgPSAoX2ZwcyA9PT0gMCkgPyBfZW1wdHlGdW5jIDogKCFfdXNlUkFGIHx8ICFfcmVxQW5pbUZyYW1lKSA/IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHNldFRpbWVvdXQoZiwgKChfbmV4dFRpbWUgLSBfc2VsZi50aW1lKSAqIDEwMDAgKyAxKSB8IDApOyB9IDogX3JlcUFuaW1GcmFtZTtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RpY2soMik7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5mcHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2Zwcztcblx0XHRcdFx0fVxuXHRcdFx0XHRfZnBzID0gdmFsdWU7XG5cdFx0XHRcdF9nYXAgPSAxIC8gKF9mcHMgfHwgNjApO1xuXHRcdFx0XHRfbmV4dFRpbWUgPSB0aGlzLnRpbWUgKyBfZ2FwO1xuXHRcdFx0XHRfc2VsZi53YWtlKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi51c2VSQUYgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3VzZVJBRjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfc2VsZi5zbGVlcCgpO1xuXHRcdFx0XHRfdXNlUkFGID0gdmFsdWU7XG5cdFx0XHRcdF9zZWxmLmZwcyhfZnBzKTtcblx0XHRcdH07XG5cdFx0XHRfc2VsZi5mcHMoZnBzKTtcblxuXHRcdFx0Ly9hIGJ1ZyBpbiBpT1MgNiBTYWZhcmkgb2NjYXNpb25hbGx5IHByZXZlbnRzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJvbSB3b3JraW5nIGluaXRpYWxseSwgc28gd2UgdXNlIGEgMS41LXNlY29uZCB0aW1lb3V0IHRoYXQgYXV0b21hdGljYWxseSBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQoKSBpZiBpdCBzZW5zZXMgdGhpcyBjb25kaXRpb24uXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3VzZVJBRiAmJiAoIV9pZCB8fCBfc2VsZi5mcmFtZSA8IDUpKSB7XG5cdFx0XHRcdFx0X3NlbGYudXNlUkFGKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTUwMCk7XG5cdFx0fSk7XG5cblx0XHRwID0gZ3MuVGlja2VyLnByb3RvdHlwZSA9IG5ldyBncy5ldmVudHMuRXZlbnREaXNwYXRjaGVyKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IGdzLlRpY2tlcjtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQW5pbWF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgQW5pbWF0aW9uID0gX2NsYXNzKFwiY29yZS5BbmltYXRpb25cIiwgZnVuY3Rpb24oZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0dGhpcy52YXJzID0gdmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDA7XG5cdFx0XHRcdHRoaXMuX2RlbGF5ID0gTnVtYmVyKHZhcnMuZGVsYXkpIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3RpbWVTY2FsZSA9IDE7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSAodmFycy5yZXZlcnNlZCA9PT0gdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFfcm9vdFRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TIDYgU2FmYXJpKSBzaHV0IGRvd24gSmF2YVNjcmlwdCBleGVjdXRpb24gd2hlbiB0aGUgdGFiIGlzIGRpc2FibGVkIGFuZCB0aGV5IFtvY2Nhc2lvbmFsbHldIG5lZ2xlY3QgdG8gc3RhcnQgdXAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFnYWluIHdoZW4gcmV0dXJuaW5nIC0gdGhpcyBjb2RlIGVuc3VyZXMgdGhhdCB0aGUgZW5naW5lIHN0YXJ0cyB1cCBhZ2FpbiBwcm9wZXJseS5cblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0bCA9IHRoaXMudmFycy51c2VGcmFtZXMgPyBfcm9vdEZyYW1lc1RpbWVsaW5lIDogX3Jvb3RUaW1lbGluZTtcblx0XHRcdFx0dGwuYWRkKHRoaXMsIHRsLl90aW1lKTtcblxuXHRcdFx0XHRpZiAodGhpcy52YXJzLnBhdXNlZCkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdF90aWNrZXIgPSBBbmltYXRpb24udGlja2VyID0gbmV3IGdzLlRpY2tlcigpO1xuXHRcdHAgPSBBbmltYXRpb24ucHJvdG90eXBlO1xuXHRcdHAuX2RpcnR5ID0gcC5fZ2MgPSBwLl9pbml0dGVkID0gcC5fcGF1c2VkID0gZmFsc2U7XG5cdFx0cC5fdG90YWxUaW1lID0gcC5fdGltZSA9IDA7XG5cdFx0cC5fcmF3UHJldlRpbWUgPSAtMTtcblx0XHRwLl9uZXh0ID0gcC5fbGFzdCA9IHAuX29uVXBkYXRlID0gcC5fdGltZWxpbmUgPSBwLnRpbWVsaW5lID0gbnVsbDtcblx0XHRwLl9wYXVzZWQgPSBmYWxzZTtcblxuXG5cdFx0Ly9zb21lIGJyb3dzZXJzIChsaWtlIGlPUykgb2NjYXNpb25hbGx5IGRyb3AgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBldmVudCB3aGVuIHRoZSB1c2VyIHN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHRhYiBhbmQgdGhlbiBjb21lcyBiYWNrIGFnYWluLCBzbyB3ZSB1c2UgYSAyLXNlY29uZCBzZXRUaW1lb3V0KCkgdG8gc2Vuc2UgaWYvd2hlbiB0aGF0IGNvbmRpdGlvbiBvY2N1cnMgYW5kIHRoZW4gd2FrZSgpIHRoZSB0aWNrZXIuXG5cdFx0dmFyIF9jaGVja1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF90aWNrZXJBY3RpdmUgJiYgX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlID4gMjAwMCkge1xuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldFRpbWVvdXQoX2NoZWNrVGltZW91dCwgMjAwMCk7XG5cdFx0XHR9O1xuXHRcdF9jaGVja1RpbWVvdXQoKTtcblxuXG5cdFx0cC5wbGF5ID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlID0gZnVuY3Rpb24oYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGF0VGltZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN1bWUgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5zZWVrID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZShOdW1iZXIodGltZSksIHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVzdGFydCA9IGZ1bmN0aW9uKGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlaygoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHQvL3N0dWIgLSB3ZSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBzdWJjbGFzc2VzLlxuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRoaXMuX2djID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdFx0aWYgKHRoaXMuX2djIHx8ICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsIC8vdGhlIDIgcm9vdCB0aW1lbGluZXMgd29uJ3QgaGF2ZSBhIF90aW1lbGluZTsgdGhleSdyZSBhbHdheXMgYWN0aXZlLlxuXHRcdFx0XHRzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHJhd1RpbWU7XG5cdFx0XHRyZXR1cm4gKCF0bCB8fCAoIXRoaXMuX2djICYmICF0aGlzLl9wYXVzZWQgJiYgdGwuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHRsLnJhd1RpbWUoKSkgPj0gc3RhcnRUaW1lICYmIHJhd1RpbWUgPCBzdGFydFRpbWUgKyB0aGlzLnRvdGFsRHVyYXRpb24oKSAvIHRoaXMuX3RpbWVTY2FsZSkpO1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9nYyA9ICFlbmFibGVkO1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0aWYgKGlnbm9yZVRpbWVsaW5lICE9PSB0cnVlKSB7XG5cdFx0XHRcdGlmIChlbmFibGVkICYmICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuYWRkKHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTtcblx0XHRcdFx0fSBlbHNlIGlmICghZW5hYmxlZCAmJiB0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuX3JlbW92ZSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAua2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0dGhpcy5fa2lsbCh2YXJzLCB0YXJnZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3VuY2FjaGUgPSBmdW5jdGlvbihpbmNsdWRlU2VsZikge1xuXHRcdFx0dmFyIHR3ZWVuID0gaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3N3YXBTZWxmSW5QYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHRcdHZhciBpID0gcGFyYW1zLmxlbmd0aCxcblx0XHRcdFx0Y29weSA9IHBhcmFtcy5jb25jYXQoKTtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGFyYW1zW2ldID09PSBcIntzZWxmfVwiKSB7XG5cdFx0XHRcdFx0Y29weVtpXSA9IHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH07XG5cbi8vLS0tLUFuaW1hdGlvbiBnZXR0ZXJzL3NldHRlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRpZiAoKHR5cGUgfHwgXCJcIikuc3Vic3RyKDAsMikgPT09IFwib25cIikge1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFycztcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdlt0eXBlXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB2W3R5cGVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZbdHlwZV0gPSBjYWxsYmFjaztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlBhcmFtc1wiXSA9IChfaXNBcnJheShwYXJhbXMpICYmIHBhcmFtcy5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSA/IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXMocGFyYW1zKSA6IHBhcmFtcztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlNjb3BlXCJdID0gc2NvcGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGUgPT09IFwib25VcGRhdGVcIikge1xuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2s7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmRlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZGVsYXk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dGhpcy5zdGFydFRpbWUoIHRoaXMuX3N0YXJ0VGltZSArIHZhbHVlIC0gdGhpcy5fZGVsYXkgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gdmFsdWU7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpOyAvL3RydWUgaW4gY2FzZSBpdCdzIGEgVHdlZW5NYXggb3IgVGltZWxpbmVNYXggdGhhdCBoYXMgYSByZXBlYXQgLSB3ZSdsbCBuZWVkIHRvIHJlZnJlc2ggdGhlIHRvdGFsRHVyYXRpb24uXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIGlmICh0aGlzLl90aW1lID4gMCkgaWYgKHRoaXMuX3RpbWUgPCB0aGlzLl9kdXJhdGlvbikgaWYgKHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudG90YWxUaW1lKHRoaXMuX3RvdGFsVGltZSAqICh2YWx1ZSAvIHRoaXMuX2R1cmF0aW9uKSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uKHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pID8gdGhpcy5fZHVyYXRpb24gOiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmICF1bmNhcHBlZCkge1xuXHRcdFx0XHRcdHRpbWUgKz0gdGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHRvdGFsRHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uLFxuXHRcdFx0XHRcdFx0dGwgPSB0aGlzLl90aW1lbGluZTtcblx0XHRcdFx0XHRpZiAodGltZSA+IHRvdGFsRHVyYXRpb24gJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0XHR0aW1lID0gdG90YWxEdXJhdGlvbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gKHRoaXMuX3BhdXNlZCA/IHRoaXMuX3BhdXNlVGltZSA6IHRsLl90aW1lKSAtICgoIXRoaXMuX3JldmVyc2VkID8gdGltZSA6IHRvdGFsRHVyYXRpb24gLSB0aW1lKSAvIHRoaXMuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0aWYgKCF0bC5fZGlydHkpIHsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG5cdFx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0VGltZSBvZiB0aGF0IGNoaWxkIHdvdWxkIGdldCBwdXNoZWQgb3V0LCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgbWF5IGhhdmUgY29tcGxldGVkLlxuXHRcdFx0XHRcdGlmICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZS5fdGltZSAhPT0gKHRsLl9zdGFydFRpbWUgKyB0bC5fdG90YWxUaW1lKSAvIHRsLl90aW1lU2NhbGUpIHtcblx0XHRcdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHRpbWUgfHwgdGhpcy5fZHVyYXRpb24gPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIHNvbWVvbmUgY2FsbHMgc2VlaygpIG9yIHRpbWUoKSBvciBwcm9ncmVzcygpLCB0aGV5IGV4cGVjdCBhbiBpbW1lZGlhdGUgcmVuZGVyLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnByb2dyZXNzID0gcC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnN0YXJ0VGltZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAodGhpcy50aW1lbGluZSkgaWYgKHRoaXMudGltZWxpbmUuX3NvcnRDaGlsZHJlbikge1xuXHRcdFx0XHRcdHRoaXMudGltZWxpbmUuYWRkKHRoaXMsIHZhbHVlIC0gdGhpcy5fZGVsYXkpOyAvL2Vuc3VyZXMgdGhhdCBhbnkgbmVjZXNzYXJ5IHJlLXNlcXVlbmNpbmcgb2YgQW5pbWF0aW9ucyBpbiB0aGUgdGltZWxpbmUgb2NjdXJzIHRvIG1ha2Ugc3VyZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGlzIGNvcnJlY3QuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmVuZFRpbWUgPSBmdW5jdGlvbihpbmNsdWRlUmVwZWF0cykge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZSArICgoaW5jbHVkZVJlcGVhdHMgIT0gZmFsc2UpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdH07XG5cblx0XHRwLnRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgX3RpbnlOdW07IC8vY2FuJ3QgYWxsb3cgemVybyBiZWNhdXNlIGl0J2xsIHRocm93IHRoZSBtYXRoIG9mZlxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lICYmIHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdHZhciBwYXVzZVRpbWUgPSB0aGlzLl9wYXVzZVRpbWUsXG5cdFx0XHRcdFx0dCA9IChwYXVzZVRpbWUgfHwgcGF1c2VUaW1lID09PSAwKSA/IHBhdXNlVGltZSA6IHRoaXMuX3RpbWVsaW5lLnRvdGFsVGltZSgpO1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGhpcy5fc3RhcnRUaW1lKSAqIHRoaXMuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RpbWVTY2FsZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJldmVyc2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUoKCh0aGlzLl90aW1lbGluZSAmJiAhdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgLSB0aGlzLl90b3RhbFRpbWUgOiB0aGlzLl90b3RhbFRpbWUpLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhdXNlZDtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lLFxuXHRcdFx0XHRyYXcsIGVsYXBzZWQ7XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcGF1c2VkKSBpZiAodGwpIHtcblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlICYmICF2YWx1ZSkge1xuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhdyA9IHRsLnJhd1RpbWUoKTtcblx0XHRcdFx0ZWxhcHNlZCA9IHJhdyAtIHRoaXMuX3BhdXNlVGltZTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiB0bC5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3BhdXNlVGltZSA9IHZhbHVlID8gcmF3IDogbnVsbDtcblx0XHRcdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiBlbGFwc2VkICE9PSAwICYmIHRoaXMuX2luaXR0ZWQgJiYgdGhpcy5kdXJhdGlvbigpKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIoKHRsLnNtb290aENoaWxkVGltaW5nID8gdGhpcy5fdG90YWxUaW1lIDogKHJhdyAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl90aW1lU2NhbGUpLCB0cnVlLCB0cnVlKTsgLy9pbiBjYXNlIHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzIGNoYW5nZWQgdmlhIHNvbWUgb3RoZXIgdHdlZW4gb3IgbWFudWFsIHVwZGF0ZSBieSB0aGUgdXNlciwgd2Ugc2hvdWxkIGZvcmNlIGEgcmVuZGVyLlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZ2MgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogU2ltcGxlVGltZWxpbmVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBTaW1wbGVUaW1lbGluZSA9IF9jbGFzcyhcImNvcmUuU2ltcGxlVGltZWxpbmVcIiwgZnVuY3Rpb24odmFycykge1xuXHRcdFx0QW5pbWF0aW9uLmNhbGwodGhpcywgMCwgdmFycyk7XG5cdFx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9IHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0cCA9IFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZSA9IG5ldyBBbmltYXRpb24oKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gU2ltcGxlVGltZWxpbmU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0cC5fZmlyc3QgPSBwLl9sYXN0ID0gcC5fcmVjZW50ID0gbnVsbDtcblx0XHRwLl9zb3J0Q2hpbGRyZW4gPSBmYWxzZTtcblxuXHRcdHAuYWRkID0gcC5pbnNlcnQgPSBmdW5jdGlvbihjaGlsZCwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgcHJldlR3ZWVuLCBzdDtcblx0XHRcdGNoaWxkLl9zdGFydFRpbWUgPSBOdW1iZXIocG9zaXRpb24gfHwgMCkgKyBjaGlsZC5fZGVsYXk7XG5cdFx0XHRpZiAoY2hpbGQuX3BhdXNlZCkgaWYgKHRoaXMgIT09IGNoaWxkLl90aW1lbGluZSkgeyAvL3dlIG9ubHkgYWRqdXN0IHRoZSBfcGF1c2VUaW1lIGlmIGl0IHdhc24ndCBpbiB0aGlzIHRpbWVsaW5lIGFscmVhZHkuIFJlbWVtYmVyLCBzb21ldGltZXMgYSB0d2VlbiB3aWxsIGJlIGluc2VydGVkIGFnYWluIGludG8gdGhlIHNhbWUgdGltZWxpbmUgd2hlbiBpdHMgc3RhcnRUaW1lIGlzIGNoYW5nZWQgc28gdGhhdCB0aGUgdHdlZW5zIGluIHRoZSBUaW1lbGluZUxpdGUvTWF4IGFyZSByZS1vcmRlcmVkIHByb3Blcmx5IGluIHRoZSBsaW5rZWQgbGlzdCAoc28gZXZlcnl0aGluZyByZW5kZXJzIGluIHRoZSBwcm9wZXIgb3JkZXIpLlxuXHRcdFx0XHRjaGlsZC5fcGF1c2VUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArICgodGhpcy5yYXdUaW1lKCkgLSBjaGlsZC5fc3RhcnRUaW1lKSAvIGNoaWxkLl90aW1lU2NhbGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoaWxkLnRpbWVsaW5lKSB7XG5cdFx0XHRcdGNoaWxkLnRpbWVsaW5lLl9yZW1vdmUoY2hpbGQsIHRydWUpOyAvL3JlbW92ZXMgZnJvbSBleGlzdGluZyB0aW1lbGluZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSBhZGRlZCB0byB0aGlzIG9uZS5cblx0XHRcdH1cblx0XHRcdGNoaWxkLnRpbWVsaW5lID0gY2hpbGQuX3RpbWVsaW5lID0gdGhpcztcblx0XHRcdGlmIChjaGlsZC5fZ2MpIHtcblx0XHRcdFx0Y2hpbGQuX2VuYWJsZWQodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRwcmV2VHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0aWYgKHRoaXMuX3NvcnRDaGlsZHJlbikge1xuXHRcdFx0XHRzdCA9IGNoaWxkLl9zdGFydFRpbWU7XG5cdFx0XHRcdHdoaWxlIChwcmV2VHdlZW4gJiYgcHJldlR3ZWVuLl9zdGFydFRpbWUgPiBzdCkge1xuXHRcdFx0XHRcdHByZXZUd2VlbiA9IHByZXZUd2Vlbi5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUd2Vlbikge1xuXHRcdFx0XHRjaGlsZC5fbmV4dCA9IHByZXZUd2Vlbi5fbmV4dDtcblx0XHRcdFx0cHJldlR3ZWVuLl9uZXh0ID0gY2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5fbmV4dCA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR0aGlzLl9maXJzdCA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoaWxkLl9uZXh0KSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9sYXN0ID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZC5fcHJldiA9IHByZXZUd2Vlbjtcblx0XHRcdHRoaXMuX3JlY2VudCA9IGNoaWxkO1xuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRpZiAodHdlZW4udGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0aWYgKCFza2lwRGlzYWJsZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0d2Vlbi5fcHJldikge1xuXHRcdFx0XHRcdHR3ZWVuLl9wcmV2Ll9uZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3QgPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3QgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4uX25leHQpIHtcblx0XHRcdFx0XHR0d2Vlbi5fbmV4dC5fcHJldiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xhc3QgPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fbGFzdCA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuLl9uZXh0ID0gdHdlZW4uX3ByZXYgPSB0d2Vlbi50aW1lbGluZSA9IG51bGw7XG5cdFx0XHRcdGlmICh0d2VlbiA9PT0gdGhpcy5fcmVjZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVjZW50ID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdG5leHQ7XG5cdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0aW1lID49IHR3ZWVuLl9zdGFydFRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQpKSB7XG5cdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAucmF3VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHR9O1xuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHdlZW5MaXRlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgVHdlZW5MaXRlID0gX2NsYXNzKFwiVHdlZW5MaXRlXCIsIGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0QW5pbWF0aW9uLmNhbGwodGhpcywgZHVyYXRpb24sIHZhcnMpO1xuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUucmVuZGVyOyAvL3NwZWVkIG9wdGltaXphdGlvbiAoYXZvaWQgcHJvdG90eXBlIGxvb2t1cCBvbiB0aGlzIFwiaG90XCIgbWV0aG9kKVxuXG5cdFx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRocm93IFwiQ2Fubm90IHR3ZWVuIGEgbnVsbCB0YXJnZXQuXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRhcmdldCA9IHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyB0YXJnZXQgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cblx0XHRcdFx0dmFyIGlzU2VsZWN0b3IgPSAodGFyZ2V0LmpxdWVyeSB8fCAodGFyZ2V0Lmxlbmd0aCAmJiB0YXJnZXQgIT09IHdpbmRvdyAmJiB0YXJnZXRbMF0gJiYgKHRhcmdldFswXSA9PT0gd2luZG93IHx8ICh0YXJnZXRbMF0ubm9kZVR5cGUgJiYgdGFyZ2V0WzBdLnN0eWxlICYmICF0YXJnZXQubm9kZVR5cGUpKSkpLFxuXHRcdFx0XHRcdG92ZXJ3cml0ZSA9IHRoaXMudmFycy5vdmVyd3JpdGUsXG5cdFx0XHRcdFx0aSwgdGFyZywgdGFyZ2V0cztcblxuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGUgPSAob3ZlcndyaXRlID09IG51bGwpID8gX292ZXJ3cml0ZUxvb2t1cFtUd2VlbkxpdGUuZGVmYXVsdE92ZXJ3cml0ZV0gOiAodHlwZW9mKG92ZXJ3cml0ZSkgPT09IFwibnVtYmVyXCIpID8gb3ZlcndyaXRlID4+IDAgOiBfb3ZlcndyaXRlTG9va3VwW292ZXJ3cml0ZV07XG5cblx0XHRcdFx0aWYgKChpc1NlbGVjdG9yIHx8IHRhcmdldCBpbnN0YW5jZW9mIEFycmF5IHx8ICh0YXJnZXQucHVzaCAmJiBfaXNBcnJheSh0YXJnZXQpKSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IF9zbGljZSh0YXJnZXQpOyAgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSBbXTtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpXTtcblx0XHRcdFx0XHRcdGlmICghdGFyZykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHRhcmcpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmcgPSB0YXJnZXRzW2ktLV0gPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZyk7IC8vaW4gY2FzZSBpdCdzIGFuIGFycmF5IG9mIHN0cmluZ3Ncblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGkrMSwgMSk7IC8vdG8gYXZvaWQgYW4gZW5kbGVzcyBsb29wIChjYW4ndCBpbWFnaW5lIHdoeSB0aGUgc2VsZWN0b3Igd291bGQgcmV0dXJuIGEgc3RyaW5nLCBidXQganVzdCBpbiBjYXNlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0YXJnLmxlbmd0aCAmJiB0YXJnICE9PSB3aW5kb3cgJiYgdGFyZ1swXSAmJiAodGFyZ1swXSA9PT0gd2luZG93IHx8ICh0YXJnWzBdLm5vZGVUeXBlICYmIHRhcmdbMF0uc3R5bGUgJiYgIXRhcmcubm9kZVR5cGUpKSkgeyAvL2luIGNhc2UgdGhlIHVzZXIgaXMgcGFzc2luZyBpbiBhbiBhcnJheSBvZiBzZWxlY3RvciBvYmplY3RzIChsaWtlIGpRdWVyeSBvYmplY3RzKSwgd2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSBsZXZlbCBhbmQgcHVsbCB0aGluZ3Mgb3V0IGlmIG5lY2Vzc2FyeS4gQWxzbyBub3RlIHRoYXQgPHNlbGVjdD4gZWxlbWVudHMgcGFzcyBhbGwgdGhlIGNyaXRlcmlhIHJlZ2FyZGluZyBsZW5ndGggYW5kIHRoZSBmaXJzdCBjaGlsZCBoYXZpbmcgc3R5bGUsIHNvIHdlIG11c3QgYWxzbyBjaGVjayB0byBlbnN1cmUgdGhlIHRhcmdldCBpc24ndCBhbiBIVE1MIG5vZGUgaXRzZWxmLlxuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KF9zbGljZSh0YXJnKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZywgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzW2ldLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdFx0X2FwcGx5T3ZlcndyaXRlKHRhcmcsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0ge307XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGFyZ2V0LCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnZXQsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgfHwgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX2RlbGF5ID09PSAwICYmIHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHRcdHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAodiAmJiB2Lmxlbmd0aCAmJiB2ICE9PSB3aW5kb3cgJiYgdlswXSAmJiAodlswXSA9PT0gd2luZG93IHx8ICh2WzBdLm5vZGVUeXBlICYmIHZbMF0uc3R5bGUgJiYgIXYubm9kZVR5cGUpKSk7IC8vd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBpZiB0aGUgdGFyZ2V0IGlzIHdpbmRvdyBmcm9tIHdpdGhpbiBhbiBpZnJhbWUsIG90aGVyd2lzZSBpdCB3aWxsIHRyaWdnZXIgYSBzZWN1cml0eSBlcnJvciBpbiBzb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cblx0XHRcdH0sXG5cdFx0XHRfYXV0b0NTUyA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0XHR2YXIgY3NzID0ge30sXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdICYmICghKHAgaW4gdGFyZ2V0KSB8fCBwID09PSBcInRyYW5zZm9ybVwiIHx8IHAgPT09IFwieFwiIHx8IHAgPT09IFwieVwiIHx8IHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiIHx8IHAgPT09IFwiY2xhc3NOYW1lXCIgfHwgcCA9PT0gXCJib3JkZXJcIikgJiYgKCFfcGx1Z2luc1twXSB8fCAoX3BsdWdpbnNbcF0gJiYgX3BsdWdpbnNbcF0uX2F1dG9DU1MpKSkgeyAvL25vdGU6IDxpbWc+IGVsZW1lbnRzIGNvbnRhaW4gcmVhZC1vbmx5IFwieFwiIGFuZCBcInlcIiBwcm9wZXJ0aWVzLiBXZSBzaG91bGQgYWxzbyBwcmlvcml0aXplIGVkaXRpbmcgY3NzIHdpZHRoL2hlaWdodCByYXRoZXIgdGhhbiB0aGUgZWxlbWVudCdzIHByb3BlcnRpZXMuXG5cdFx0XHRcdFx0XHRjc3NbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHZhcnNbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMuY3NzID0gY3NzO1xuXHRcdFx0fTtcblxuXHRcdHAgPSBUd2VlbkxpdGUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2VlbkxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cbi8vLS0tLVR3ZWVuTGl0ZSBkZWZhdWx0cywgb3ZlcndyaXRlIG1hbmFnZW1lbnQsIGFuZCByb290IHVwZGF0ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5yYXRpbyA9IDA7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX3RhcmdldHMgPSBwLl9vdmVyd3JpdHRlblByb3BzID0gcC5fc3RhcnRBdCA9IG51bGw7XG5cdFx0cC5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHAuX2xhenkgPSBmYWxzZTtcblxuXHRcdFR3ZWVuTGl0ZS52ZXJzaW9uID0gXCIxLjE2LjBcIjtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdEVhc2UgPSBwLl9lYXNlID0gbmV3IEVhc2UobnVsbCwgbnVsbCwgMSwgMSk7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGUgPSBcImF1dG9cIjtcblx0XHRUd2VlbkxpdGUudGlja2VyID0gX3RpY2tlcjtcblx0XHRUd2VlbkxpdGUuYXV0b1NsZWVwID0gMTIwO1xuXHRcdFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmcgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRfdGlja2VyLmxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeSB8fCBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5O1xuXHRcdFx0aWYgKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gc2VsZWN0b3IoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHR5cGVvZihkb2N1bWVudCkgPT09IFwidW5kZWZpbmVkXCIpID8gZSA6IChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSA6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKChlLmNoYXJBdCgwKSA9PT0gXCIjXCIpID8gZS5zdWJzdHIoMSkgOiBlKSk7XG5cdFx0fTtcblxuXHRcdHZhciBfbGF6eVR3ZWVucyA9IFtdLFxuXHRcdFx0X2xhenlMb29rdXAgPSB7fSxcblx0XHRcdF9pbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyA9IHtpc0FycmF5Ol9pc0FycmF5LCBpc1NlbGVjdG9yOl9pc1NlbGVjdG9yLCBsYXp5VHdlZW5zOl9sYXp5VHdlZW5zfSwgLy9naXZlcyB1cyBhIHdheSB0byBleHBvc2UgY2VydGFpbiBwcml2YXRlIHZhbHVlcyB0byBvdGhlciBHcmVlblNvY2sgY2xhc3NlcyB3aXRob3V0IGNvbnRhbWluYXRpbmcgdGhhIG1haW4gVHdlZW5MaXRlIG9iamVjdC5cblx0XHRcdF9wbHVnaW5zID0gVHdlZW5MaXRlLl9wbHVnaW5zID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXAgPSBfaW50ZXJuYWxzLnR3ZWVuTG9va3VwID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXBOdW0gPSAwLFxuXHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBfaW50ZXJuYWxzLnJlc2VydmVkUHJvcHMgPSB7ZWFzZToxLCBkZWxheToxLCBvdmVyd3JpdGU6MSwgb25Db21wbGV0ZToxLCBvbkNvbXBsZXRlUGFyYW1zOjEsIG9uQ29tcGxldGVTY29wZToxLCB1c2VGcmFtZXM6MSwgcnVuQmFja3dhcmRzOjEsIHN0YXJ0QXQ6MSwgb25VcGRhdGU6MSwgb25VcGRhdGVQYXJhbXM6MSwgb25VcGRhdGVTY29wZToxLCBvblN0YXJ0OjEsIG9uU3RhcnRQYXJhbXM6MSwgb25TdGFydFNjb3BlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOjEsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6MSwgb25SZXBlYXQ6MSwgb25SZXBlYXRQYXJhbXM6MSwgb25SZXBlYXRTY29wZToxLCBlYXNlUGFyYW1zOjEsIHlveW86MSwgaW1tZWRpYXRlUmVuZGVyOjEsIHJlcGVhdDoxLCByZXBlYXREZWxheToxLCBkYXRhOjEsIHBhdXNlZDoxLCByZXZlcnNlZDoxLCBhdXRvQ1NTOjEsIGxhenk6MSwgb25PdmVyd3JpdGU6MX0sXG5cdFx0XHRfb3ZlcndyaXRlTG9va3VwID0ge25vbmU6MCwgYWxsOjEsIGF1dG86MiwgY29uY3VycmVudDozLCBhbGxPblN0YXJ0OjQsIHByZWV4aXN0aW5nOjUsIFwidHJ1ZVwiOjEsIFwiZmFsc2VcIjowfSxcblx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpLFxuXHRcdFx0X3Jvb3RUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfbmV4dEdDRnJhbWUgPSAzMCxcblx0XHRcdF9sYXp5UmVuZGVyID0gX2ludGVybmFscy5sYXp5UmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRcdHR3ZWVuO1xuXHRcdFx0XHRfbGF6eUxvb2t1cCA9IHt9O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0d2VlbiA9IF9sYXp5VHdlZW5zW2ldO1xuXHRcdFx0XHRcdGlmICh0d2VlbiAmJiB0d2Vlbi5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcih0d2Vlbi5fbGF6eVswXSwgdHdlZW4uX2xhenlbMV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0dHdlZW4uX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X2xhenlUd2VlbnMubGVuZ3RoID0gMDtcblx0XHRcdH07XG5cblx0XHRfcm9vdFRpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLnRpbWU7XG5cdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lID0gX3RpY2tlci5mcmFtZTtcblx0XHRfcm9vdFRpbWVsaW5lLl9hY3RpdmUgPSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9hY3RpdmUgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoX2xhenlSZW5kZXIsIDEpOyAvL29uIHNvbWUgbW9iaWxlIGRldmljZXMsIHRoZXJlIGlzbid0IGEgXCJ0aWNrXCIgYmVmb3JlIGNvZGUgcnVucyB3aGljaCBtZWFucyBhbnkgbGF6eSByZW5kZXJzIHdvdWxkbid0IHJ1biBiZWZvcmUgdGhlIG5leHQgb2ZmaWNpYWwgXCJ0aWNrXCIuXG5cblx0XHRBbmltYXRpb24uX3VwZGF0ZVJvb3QgPSBUd2VlbkxpdGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhLCBwO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaWYgY29kZSBpcyBydW4gb3V0c2lkZSBvZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AsIHRoZXJlIG1heSBiZSB0d2VlbnMgcXVldWVkIEFGVEVSIHRoZSBlbmdpbmUgcmVmcmVzaGVkLCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBhbnkgcGVuZGluZyByZW5kZXJzIG9jY3VyIGJlZm9yZSB3ZSByZWZyZXNoIGFnYWluLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jvb3RUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIudGltZSAtIF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSkgKiBfcm9vdFRpbWVsaW5lLl90aW1lU2NhbGUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUucmVuZGVyKChfdGlja2VyLmZyYW1lIC0gX3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290RnJhbWVzVGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7IC8vZHVtcCBnYXJiYWdlIGV2ZXJ5IDEyMCBmcmFtZXMgb3Igd2hhdGV2ZXIgdGhlIHVzZXIgc2V0cyBUd2VlbkxpdGUuYXV0b1NsZWVwIHRvXG5cdFx0XHRcdFx0X25leHRHQ0ZyYW1lID0gX3RpY2tlci5mcmFtZSArIChwYXJzZUludChUd2VlbkxpdGUuYXV0b1NsZWVwLCAxMCkgfHwgMTIwKTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gX3R3ZWVuTG9va3VwKSB7XG5cdFx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW3BdLnR3ZWVucztcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGEubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBfdHdlZW5Mb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaWYgdGhlcmUgYXJlIG5vIG1vcmUgdHdlZW5zIGluIHRoZSByb290IHRpbWVsaW5lcywgb3IgaWYgdGhleSdyZSBhbGwgcGF1c2VkLCBtYWtlIHRoZSBfdGltZXIgc2xlZXAgdG8gcmVkdWNlIGxvYWQgb24gdGhlIENQVSBzbGlnaHRseVxuXHRcdFx0XHRcdHAgPSBfcm9vdFRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0XHRpZiAoIXAgfHwgcC5fcGF1c2VkKSBpZiAoVHdlZW5MaXRlLmF1dG9TbGVlcCAmJiAhX3Jvb3RGcmFtZXNUaW1lbGluZS5fZmlyc3QgJiYgX3RpY2tlci5fbGlzdGVuZXJzLnRpY2subGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAocCAmJiBwLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHAuX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXApIHtcblx0XHRcdFx0XHRcdFx0X3RpY2tlci5zbGVlcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdF90aWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgQW5pbWF0aW9uLl91cGRhdGVSb290KTtcblxuXHRcdHZhciBfcmVnaXN0ZXIgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBzY3J1Yikge1xuXHRcdFx0XHR2YXIgaWQgPSB0YXJnZXQuX2dzVHdlZW5JRCwgYSwgaTtcblx0XHRcdFx0aWYgKCFfdHdlZW5Mb29rdXBbaWQgfHwgKHRhcmdldC5fZ3NUd2VlbklEID0gaWQgPSBcInRcIiArIChfdHdlZW5Mb29rdXBOdW0rKykpXSkge1xuXHRcdFx0XHRcdF90d2Vlbkxvb2t1cFtpZF0gPSB7dGFyZ2V0OnRhcmdldCwgdHdlZW5zOltdfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4pIHtcblx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHRcdFx0YVsoaSA9IGEubGVuZ3RoKV0gPSB0d2Vlbjtcblx0XHRcdFx0XHRpZiAoc2NydWIpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25PdmVyd3JpdGUgPSBmdW5jdGlvbihvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKSB7XG5cdFx0XHRcdHZhciBmdW5jID0gb3ZlcndyaXR0ZW5Ud2Vlbi52YXJzLm9uT3ZlcndyaXRlLCByMSwgcjI7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjEgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmMgPSBUd2VlbkxpdGUub25PdmVyd3JpdGU7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjIgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAocjEgIT09IGZhbHNlICYmIHIyICE9PSBmYWxzZSk7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5T3ZlcndyaXRlID0gZnVuY3Rpb24odGFyZ2V0LCB0d2VlbiwgcHJvcHMsIG1vZGUsIHNpYmxpbmdzKSB7XG5cdFx0XHRcdHZhciBpLCBjaGFuZ2VkLCBjdXJUd2VlbiwgbDtcblx0XHRcdFx0aWYgKG1vZGUgPT09IDEgfHwgbW9kZSA+PSA0KSB7XG5cdFx0XHRcdFx0bCA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGN1clR3ZWVuID0gc2libGluZ3NbaV0pICE9PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWN1clR3ZWVuLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChfb25PdmVyd3JpdGUoY3VyVHdlZW4sIHR3ZWVuKSAmJiBjdXJUd2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobW9kZSA9PT0gNSkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9OT1RFOiBBZGQgMC4wMDAwMDAwMDAxIHRvIG92ZXJjb21lIGZsb2F0aW5nIHBvaW50IGVycm9ycyB0aGF0IGNhbiBjYXVzZSB0aGUgc3RhcnRUaW1lIHRvIGJlIFZFUlkgc2xpZ2h0bHkgb2ZmICh3aGVuIGEgdHdlZW4ncyB0aW1lKCkgaXMgc2V0IGZvciBleGFtcGxlKVxuXHRcdFx0XHR2YXIgc3RhcnRUaW1lID0gdHdlZW4uX3N0YXJ0VGltZSArIF90aW55TnVtLFxuXHRcdFx0XHRcdG92ZXJsYXBzID0gW10sXG5cdFx0XHRcdFx0b0NvdW50ID0gMCxcblx0XHRcdFx0XHR6ZXJvRHVyID0gKHR3ZWVuLl9kdXJhdGlvbiA9PT0gMCksXG5cdFx0XHRcdFx0Z2xvYmFsU3RhcnQ7XG5cdFx0XHRcdGkgPSBzaWJsaW5ncy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICgoY3VyVHdlZW4gPSBzaWJsaW5nc1tpXSkgPT09IHR3ZWVuIHx8IGN1clR3ZWVuLl9nYyB8fCBjdXJUd2Vlbi5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHQvL2lnbm9yZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VyVHdlZW4uX3RpbWVsaW5lICE9PSB0d2Vlbi5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdGdsb2JhbFN0YXJ0ID0gZ2xvYmFsU3RhcnQgfHwgX2NoZWNrT3ZlcmxhcCh0d2VlbiwgMCwgemVyb0R1cik7XG5cdFx0XHRcdFx0XHRpZiAoX2NoZWNrT3ZlcmxhcChjdXJUd2VlbiwgZ2xvYmFsU3RhcnQsIHplcm9EdXIpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJsYXBzW29Db3VudCsrXSA9IGN1clR3ZWVuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VyVHdlZW4uX3N0YXJ0VGltZSA8PSBzdGFydFRpbWUpIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lICsgY3VyVHdlZW4udG90YWxEdXJhdGlvbigpIC8gY3VyVHdlZW4uX3RpbWVTY2FsZSA+IHN0YXJ0VGltZSkgaWYgKCEoKHplcm9EdXIgfHwgIWN1clR3ZWVuLl9pbml0dGVkKSAmJiBzdGFydFRpbWUgLSBjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IDAuMDAwMDAwMDAwMikpIHtcblx0XHRcdFx0XHRcdG92ZXJsYXBzW29Db3VudCsrXSA9IGN1clR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgPSBvQ291bnQ7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGN1clR3ZWVuID0gb3ZlcmxhcHNbaV07XG5cdFx0XHRcdFx0aWYgKG1vZGUgPT09IDIpIGlmIChjdXJUd2Vlbi5fa2lsbChwcm9wcywgdGFyZ2V0LCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobW9kZSAhPT0gMiB8fCAoIWN1clR3ZWVuLl9maXJzdFBUICYmIGN1clR3ZWVuLl9pbml0dGVkKSkge1xuXHRcdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgJiYgIV9vbk92ZXJ3cml0ZShjdXJUd2VlbiwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1clR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSkpIHsgLy9pZiBhbGwgcHJvcGVydHkgdHdlZW5zIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiwga2lsbCB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdH0sXG5cblx0XHRcdF9jaGVja092ZXJsYXAgPSBmdW5jdGlvbih0d2VlbiwgcmVmZXJlbmNlLCB6ZXJvRHVyKSB7XG5cdFx0XHRcdHZhciB0bCA9IHR3ZWVuLl90aW1lbGluZSxcblx0XHRcdFx0XHR0cyA9IHRsLl90aW1lU2NhbGUsXG5cdFx0XHRcdFx0dCA9IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0ICs9IHRsLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0dHMgKj0gdGwuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRpZiAodGwuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIC0xMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHQgLz0gdHM7XG5cdFx0XHRcdHJldHVybiAodCA+IHJlZmVyZW5jZSkgPyB0IC0gcmVmZXJlbmNlIDogKCh6ZXJvRHVyICYmIHQgPT09IHJlZmVyZW5jZSkgfHwgKCF0d2Vlbi5faW5pdHRlZCAmJiB0IC0gcmVmZXJlbmNlIDwgMiAqIF90aW55TnVtKSkgPyBfdGlueU51bSA6ICgodCArPSB0d2Vlbi50b3RhbER1cmF0aW9uKCkgLyB0d2Vlbi5fdGltZVNjYWxlIC8gdHMpID4gcmVmZXJlbmNlICsgX3RpbnlOdW0pID8gMCA6IHQgLSByZWZlcmVuY2UgLSBfdGlueU51bTtcblx0XHRcdH07XG5cblxuLy8tLS0tIFR3ZWVuTGl0ZSBpbnN0YW5jZSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0b3AgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzLFxuXHRcdFx0XHRkdXIgPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0aW1tZWRpYXRlID0gISF2LmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0ZWFzZSA9IHYuZWFzZSxcblx0XHRcdFx0aSwgaW5pdFBsdWdpbnMsIHB0LCBwLCBzdGFydFZhcnM7XG5cdFx0XHRpZiAodi5zdGFydEF0KSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvL2lmIHdlJ3ZlIHJ1biBhIHN0YXJ0QXQgcHJldmlvdXNseSAod2hlbiB0aGUgdHdlZW4gaW5zdGFudGlhdGVkKSwgd2Ugc2hvdWxkIHJldmVydCBpdCBzbyB0aGF0IHRoZSB2YWx1ZXMgcmUtaW5zdGFudGlhdGUgY29ycmVjdGx5IHBhcnRpY3VsYXJseSBmb3IgcmVsYXRpdmUgdHdlZW5zLiBXaXRob3V0IHRoaXMsIGEgVHdlZW5MaXRlLmZyb21UbyhvYmosIDEsIHt4OlwiKz0xMDBcIn0sIHt4OlwiLT0xMDBcIn0pLCBmb3IgZXhhbXBsZSwgd291bGQgYWN0dWFsbHkganVtcCB0byArPTIwMCBiZWNhdXNlIHRoZSBzdGFydEF0IHdvdWxkIHJ1biB0d2ljZSwgZG91YmxpbmcgdGhlIHJlbGF0aXZlIGNoYW5nZS5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFZhcnMgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIHYuc3RhcnRBdCkgeyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgMSwgZnJvbSwgdG8pLmZyb21UbyhlLCAxLCB0bywgZnJvbSk7XG5cdFx0XHRcdFx0c3RhcnRWYXJzW3BdID0gdi5zdGFydEF0W3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycy5vdmVyd3JpdGUgPSBmYWxzZTtcblx0XHRcdFx0c3RhcnRWYXJzLmltbWVkaWF0ZVJlbmRlciA9IHRydWU7XG5cdFx0XHRcdHN0YXJ0VmFycy5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0c3RhcnRWYXJzLnN0YXJ0QXQgPSBzdGFydFZhcnMuZGVsYXkgPSBudWxsOyAvL25vIG5lc3Rpbmcgb2Ygc3RhcnRBdCBvYmplY3RzIGFsbG93ZWQgKG90aGVyd2lzZSBpdCBjb3VsZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wKS5cblx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgc3RhcnRWYXJzKTtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lTGl0ZS9NYXggaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2UgKHdoaWNoIGlzIHRoZSBkZWZhdWx0IGluIHRoZSBjb252ZW5pZW5jZSBtZXRob2RzIGxpa2UgZnJvbSgpKS5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGR1ciAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lTGl0ZSBvciBUaW1lbGluZU1heCwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodi5ydW5CYWNrd2FyZHMgJiYgZHVyICE9PSAwKSB7XG5cdFx0XHRcdC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgIT09IDApIHsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblx0XHRcdFx0XHRcdGltbWVkaWF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiB2KSB7IC8vY29weSBwcm9wcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgc2tpcCBhbnkgcmVzZXJ2ZWQgcHJvcHMsIG90aGVyd2lzZSBvbkNvbXBsZXRlIG9yIG9uVXBkYXRlIG9yIG9uU3RhcnQgY291bGQgZmlyZS4gV2Ugc2hvdWxkLCBob3dldmVyLCBwZXJtaXQgYXV0b0NTUyB0byBnbyB0aHJvdWdoLlxuXHRcdFx0XHRcdFx0aWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSB8fCBwID09PSBcImF1dG9DU1NcIikge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHZbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0Lm92ZXJ3cml0ZSA9IDA7XG5cdFx0XHRcdFx0cHQuZGF0YSA9IFwiaXNGcm9tU3RhcnRcIjsgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG5cdFx0XHRcdFx0cHQubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdFx0cHQuaW1tZWRpYXRlUmVuZGVyID0gaW1tZWRpYXRlOyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgcHQpO1xuXHRcdFx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0Ll9pbml0KCk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoZmFsc2UpOyAvL25vIG5lZWQgdG8gaGF2ZSB0aGUgdHdlZW4gcmVuZGVyIG9uIHRoZSBuZXh0IGN5Y2xlLiBEaXNhYmxlIGl0IGJlY2F1c2Ugd2UnbGwgYWx3YXlzIG1hbnVhbGx5IGNvbnRyb2wgdGhlIHJlbmRlcnMgb2YgdGhlIF9zdGFydEF0IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlID0gZWFzZSA9ICghZWFzZSkgPyBUd2VlbkxpdGUuZGVmYXVsdEVhc2UgOiAoZWFzZSBpbnN0YW5jZW9mIEVhc2UpID8gZWFzZSA6ICh0eXBlb2YoZWFzZSkgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgRWFzZShlYXNlLCB2LmVhc2VQYXJhbXMpIDogX2Vhc2VNYXBbZWFzZV0gfHwgVHdlZW5MaXRlLmRlZmF1bHRFYXNlO1xuXHRcdFx0aWYgKHYuZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5ICYmIGVhc2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlLmNvbmZpZy5hcHBseShlYXNlLCB2LmVhc2VQYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWFzZVR5cGUgPSB0aGlzLl9lYXNlLl90eXBlO1xuXHRcdFx0dGhpcy5fZWFzZVBvd2VyID0gdGhpcy5fZWFzZS5fcG93ZXI7XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gbnVsbDtcblxuXHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0aSA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMuX2luaXRQcm9wcyggdGhpcy5fdGFyZ2V0c1tpXSwgKHRoaXMuX3Byb3BMb29rdXBbaV0gPSB7fSksIHRoaXMuX3NpYmxpbmdzW2ldLCAob3AgPyBvcFtpXSA6IG51bGwpKSApIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluaXRQbHVnaW5zID0gdGhpcy5faW5pdFByb3BzKHRoaXMudGFyZ2V0LCB0aGlzLl9wcm9wTG9va3VwLCB0aGlzLl9zaWJsaW5ncywgb3ApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW5pdFBsdWdpbnMpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uSW5pdEFsbFByb3BzXCIsIHRoaXMpOyAvL3Jlb3JkZXJzIHRoZSBhcnJheSBpbiBvcmRlciBvZiBwcmlvcml0eS4gVXNlcyBhIHN0YXRpYyBUd2VlblBsdWdpbiBtZXRob2QgaW4gb3JkZXIgdG8gbWluaW1pemUgZmlsZSBzaXplIGluIFR3ZWVuTGl0ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9wKSBpZiAoIXRoaXMuX2ZpcnN0UFQpIGlmICh0eXBlb2YodGhpcy50YXJnZXQpICE9PSBcImZ1bmN0aW9uXCIpIHsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4sIGtpbGwgdGhlIHR3ZWVuLiBJZiB0aGUgdGFyZ2V0IGlzIGEgZnVuY3Rpb24sIGl0J3MgcHJvYmFibHkgYSBkZWxheWVkQ2FsbCBzbyBsZXQgaXQgbGl2ZS5cblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHYucnVuQmFja3dhcmRzKSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0cHQucyArPSBwdC5jO1xuXHRcdFx0XHRcdHB0LmMgPSAtcHQuYztcblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHYub25VcGRhdGU7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0cC5faW5pdFByb3BzID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcykge1xuXHRcdFx0dmFyIHAsIGksIGluaXRQbHVnaW5zLCBwbHVnaW4sIHB0LCB2O1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9sYXp5TG9va3VwW3RhcmdldC5fZ3NUd2VlbklEXSkge1xuXHRcdFx0XHRfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMudmFycy5jc3MpIGlmICh0YXJnZXQuc3R5bGUpIGlmICh0YXJnZXQgIT09IHdpbmRvdyAmJiB0YXJnZXQubm9kZVR5cGUpIGlmIChfcGx1Z2lucy5jc3MpIGlmICh0aGlzLnZhcnMuYXV0b0NTUyAhPT0gZmFsc2UpIHsgLy9pdCdzIHNvIGNvbW1vbiB0byB1c2UgVHdlZW5MaXRlL01heCB0byBhbmltYXRlIHRoZSBjc3Mgb2YgRE9NIGVsZW1lbnRzLCB3ZSBhc3N1bWUgdGhhdCBpZiB0aGUgdGFyZ2V0IGlzIGEgRE9NIGVsZW1lbnQsIHRoYXQncyB3aGF0IGlzIGludGVuZGVkIChhIGNvbnZlbmllbmNlIHNvIHRoYXQgdXNlcnMgZG9uJ3QgaGF2ZSB0byB3cmFwIHRoaW5ncyBpbiBjc3M6e30sIGFsdGhvdWdoIHdlIHN0aWxsIHJlY29tbWVuZCBpdCBmb3IgYSBzbGlnaHQgcGVyZm9ybWFuY2UgYm9vc3QgYW5kIGJldHRlciBzcGVjaWZpY2l0eSkuIE5vdGU6IHdlIGNhbm5vdCBjaGVjayBcIm5vZGVUeXBlXCIgb24gdGhlIHdpbmRvdyBpbnNpZGUgYW4gaWZyYW1lLlxuXHRcdFx0XHRfYXV0b0NTUyh0aGlzLnZhcnMsIHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy52YXJzKSB7XG5cdFx0XHRcdHYgPSB0aGlzLnZhcnNbcF07XG5cdFx0XHRcdGlmIChfcmVzZXJ2ZWRQcm9wc1twXSkge1xuXHRcdFx0XHRcdGlmICh2KSBpZiAoKHYgaW5zdGFuY2VvZiBBcnJheSkgfHwgKHYucHVzaCAmJiBfaXNBcnJheSh2KSkpIGlmICh2LmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMudmFyc1twXSA9IHYgPSB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHYsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKF9wbHVnaW5zW3BdICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcF0oKSkuX29uSW5pdFR3ZWVuKHRhcmdldCwgdGhpcy52YXJzW3BdLCB0aGlzKSkge1xuXG5cdFx0XHRcdFx0Ly90IC0gdGFyZ2V0IFx0XHRbb2JqZWN0XVxuXHRcdFx0XHRcdC8vcCAtIHByb3BlcnR5IFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcyAtIHN0YXJ0XHRcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2MgLSBjaGFuZ2VcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2YgLSBpc0Z1bmN0aW9uXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL24gLSBuYW1lXHRcdFx0W3N0cmluZ11cblx0XHRcdFx0XHQvL3BnIC0gaXNQbHVnaW4gXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL3ByIC0gcHJpb3JpdHlcdFx0W251bWJlcl1cblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDpwbHVnaW4sIHA6XCJzZXRSYXRpb1wiLCBzOjAsIGM6MSwgZjp0cnVlLCBuOnAsIHBnOnRydWUsIHByOnBsdWdpbi5fcHJpb3JpdHl9O1xuXHRcdFx0XHRcdGkgPSBwbHVnaW4uX292ZXJ3cml0ZVByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHByb3BMb29rdXBbcGx1Z2luLl9vdmVyd3JpdGVQcm9wc1tpXV0gPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGx1Z2luLl9wcmlvcml0eSB8fCBwbHVnaW4uX29uSW5pdEFsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX29uRGlzYWJsZSB8fCBwbHVnaW4uX29uRW5hYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHJvcExvb2t1cFtwXSA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6dGFyZ2V0LCBwOnAsIGY6KHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpLCBuOnAsIHBnOmZhbHNlLCBwcjowfTtcblx0XHRcdFx0XHRwdC5zID0gKCFwdC5mKSA/IHBhcnNlRmxvYXQodGFyZ2V0W3BdKSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKTtcblx0XHRcdFx0XHRwdC5jID0gKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKHYuc3Vic3RyKDIpKSA6IChOdW1iZXIodikgLSBwdC5zKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdCkgaWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3ZlcndyaXR0ZW5Qcm9wcykgaWYgKHRoaXMuX2tpbGwob3ZlcndyaXR0ZW5Qcm9wcywgdGFyZ2V0KSkgeyAvL2Fub3RoZXIgdHdlZW4gbWF5IGhhdmUgdHJpZWQgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgb2YgdGhpcyB0d2VlbiBiZWZvcmUgaW5pdCgpIHdhcyBjYWxsZWQgKGxpa2UgaWYgdHdvIHR3ZWVucyBzdGFydCBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgb25lIGNyZWF0ZWQgc2Vjb25kIHdpbGwgcnVuIGZpcnN0KVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX292ZXJ3cml0ZSA+IDEpIGlmICh0aGlzLl9maXJzdFBUKSBpZiAoc2libGluZ3MubGVuZ3RoID4gMSkgaWYgKF9hcHBseU92ZXJ3cml0ZSh0YXJnZXQsIHRoaXMsIHByb3BMb29rdXAsIHRoaXMuX292ZXJ3cml0ZSwgc2libGluZ3MpKSB7XG5cdFx0XHRcdHRoaXMuX2tpbGwocHJvcExvb2t1cCwgdGFyZ2V0KTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9wcyh0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9maXJzdFBUKSBpZiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpIHsgLy96ZXJvIGR1cmF0aW9uIHR3ZWVucyBkb24ndCBsYXp5IHJlbmRlciBieSBkZWZhdWx0OyBldmVyeXRoaW5nIGVsc2UgZG9lcy5cblx0XHRcdFx0X2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbml0UGx1Z2lucztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRpc0NvbXBsZXRlLCBjYWxsYmFjaywgcHQsIHJhd1ByZXZUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkICkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhcnRUaW1lID09PSB0aGlzLl90aW1lbGluZS5fZHVyYXRpb24pIHsgLy9pZiBhIHplcm8tZHVyYXRpb24gdHdlZW4gaXMgYXQgdGhlIFZFUlkgZW5kIG9mIGEgdGltZWxpbmUgYW5kIHRoYXQgdGltZWxpbmUgcmVuZGVycyBhdCBpdHMgZW5kLCBpdCB3aWxsIHR5cGljYWxseSBhZGQgYSB0aW55IGJpdCBvZiBjdXNoaW9uIHRvIHRoZSByZW5kZXIgdGltZSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGdldHRpbmcgaW4gdGhlIHdheSBvZiB0d2VlbnMgcmVuZGVyaW5nIHRoZWlyIFZFUlkgZW5kLiBJZiB3ZSB0aGVuIHJldmVyc2UoKSB0aGF0IHRpbWVsaW5lLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiB3aWxsIHRyaWdnZXIgaXRzIG9uUmV2ZXJzZUNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5IHRoZSBwbGF5aGVhZCBkaWRuJ3QgcGFzcyBvdmVyIGl0IGFnYWluLiBJdCdzIGEgdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2Ugd2UgbXVzdCBhY2NvbW1vZGF0ZS5cblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCB8fCBwcmV2UmF3UHJldlRpbWUgPCAwIHx8IChwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSAhPT0gXCJpc1BhdXNlXCIpKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lKSB7IC8vbm90ZTogd2hlbiB0aGlzLmRhdGEgaXMgXCJpc1BhdXNlXCIsIGl0J3MgYSBjYWxsYmFjayBhZGRlZCBieSBhZGRQYXVzZSgpIG9uIGEgdGltZWxpbmUgdGhhdCB3ZSBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCB3aGVuIExFQVZJTkcgaXRzIGV4YWN0IHN0YXJ0IHRpbWUuIEluIG90aGVyIHdvcmRzLCB0bC5hZGRQYXVzZSgxKS5wbGF5KDEpIHNob3VsZG4ndCBwYXVzZS5cblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8IChkdXJhdGlvbiA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPiAwKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+PSAwICYmICEocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgPT09IFwiaXNQYXVzZVwiKSkge1xuXHRcdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSkge1xuXHRcdFx0XHRcdHZhciByID0gdGltZSAvIGR1cmF0aW9uLCB0eXBlID0gdGhpcy5fZWFzZVR5cGUsIHBvdyA9IHRoaXMuX2Vhc2VQb3dlcjtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSB8fCAodHlwZSA9PT0gMyAmJiByID49IDAuNSkpIHtcblx0XHRcdFx0XHRcdHIgPSAxIC0gcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvdyA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ciAqPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAyKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gNCkge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRpbWUgLyBkdXJhdGlvbiA8IDAuNSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHIgLyAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIChyIC8gMik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fZ2MpIHsgLy9pbW1lZGlhdGVSZW5kZXIgdHdlZW5zIHR5cGljYWxseSB3b24ndCBpbml0aWFsaXplIHVudGlsIHRoZSBwbGF5aGVhZCBhZHZhbmNlcyAoX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDApIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IG92ZXJ3cml0aW5nIG9jY3VycyBwcm9wZXJseS4gQWxzbywgaWYgYWxsIG9mIHRoZSB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiAod2hpY2ggd291bGQgY2F1c2UgX2djIHRvIGJlIHRydWUsIGFzIHNldCBpbiBfaW5pdCgpKSwgd2Ugc2hvdWxkbid0IGNvbnRpbnVlIG90aGVyd2lzZSBhbiBvblN0YXJ0IGNhbGxiYWNrIGNvdWxkIGJlIGNhbGxlZCBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWZvcmNlICYmIHRoaXMuX2ZpcnN0UFQgJiYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSBwcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0XHRfbGF6eVR3ZWVucy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMuX2xhenkgPSBbdGltZSwgc3VwcHJlc3NFdmVudHNdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL19lYXNlIGlzIGluaXRpYWxseSBzZXQgdG8gZGVmYXVsdEVhc2UsIHNvIG5vdyB0aGF0IGluaXQoKSBoYXMgcnVuLCBfZWFzZSBpcyBzZXQgcHJvcGVybHkgYW5kIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHJhdGlvLiBPdmVyYWxsIHRoaXMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY29uZGl0aW9uYWwgbG9naWMgZWFybGllciBpbiB0aGUgbWV0aG9kIHRvIGF2b2lkIGhhdmluZyB0byBzZXQgcmF0aW8gdHdpY2UgYmVjYXVzZSB3ZSBvbmx5IGluaXQoKSBvbmNlIGJ1dCByZW5kZXJUaW1lKCkgZ2V0cyBjYWxsZWQgVkVSWSBmcmVxdWVudGx5LlxuXHRcdFx0XHRpZiAodGhpcy5fdGltZSAmJiAhaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNDb21wbGV0ZSAmJiB0aGlzLl9lYXNlLl9jYWxjRW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oKHRoaXMuX3RpbWUgPT09IDApID8gMCA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fbGF6eSAhPT0gZmFsc2UpIHsgLy9pbiBjYXNlIGEgbGF6eSByZW5kZXIgaXMgcGVuZGluZywgd2Ugc2hvdWxkIGZsdXNoIGl0IGJlY2F1c2UgdGhlIG5ldyByZW5kZXIgaXMgb2NjdXJyaW5nIG5vdyAoaW1hZ2luZSBhIGxhenkgdHdlZW4gaW5zdGFudGlhdGluZyBhbmQgdGhlbiBpbW1lZGlhdGVseSB0aGUgdXNlciBjYWxscyB0d2Vlbi5zZWVrKHR3ZWVuLmR1cmF0aW9uKCkpLCBza2lwcGluZyB0byB0aGUgZW5kIC0gdGhlIGVuZCByZW5kZXIgd291bGQgYmUgZm9yY2VkLCBhbmQgdGhlbiBpZiB3ZSBkaWRuJ3QgZmx1c2ggdGhlIGxhenkgcmVuZGVyLCBpdCdkIGZpcmUgQUZURVIgdGhlIHNlZWsoKSwgcmVuZGVyaW5nIGl0IGF0IHRoZSB3cm9uZyB0aW1lLlxuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBhIHR3ZWVuIChhcyBvcHBvc2VkIHRvIHRoZSB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCB0aGUgdGltZWxpbmUgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdHdlZW4gYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUuXG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRpbWUgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwiX2R1bW15R1NcIjsgLy9pZiBubyBjYWxsYmFjayBpcyBkZWZpbmVkLCB1c2UgYSBkdW1teSB2YWx1ZSBqdXN0IHNvIHRoYXQgdGhlIGNvbmRpdGlvbiBhdCB0aGUgZW5kIGV2YWx1YXRlcyBhcyB0cnVlIGJlY2F1c2UgX3N0YXJ0QXQgc2hvdWxkIHJlbmRlciBBRlRFUiB0aGUgbm9ybWFsIHJlbmRlciBsb29wIHdoZW4gdGhlIHRpbWUgaXMgbmVnYXRpdmUuIFdlIGNvdWxkIGhhbmRsZSB0aGlzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LCBvZiBjb3Vyc2UsIGJ1dCB0aGUgcmVuZGVyIGxvb3AgaXMgdGhlIE1PU1QgaW1wb3J0YW50IHRoaW5nIHRvIG9wdGltaXplLCBzbyB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgdXMgdG8gYXZvaWQgYWRkaW5nIGV4dHJhIGNvbmRpdGlvbmFsIGxvZ2ljIGluIGEgaGlnaC1mcmVxdWVuY3kgYXJlYS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCB8fCBkdXJhdGlvbiA9PT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdHRoaXMudmFycy5vblN0YXJ0LmFwcGx5KHRoaXMudmFycy5vblN0YXJ0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKHRoaXMuX3RpbWUgIT09IHByZXZUaW1lIHx8IGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MgfHwgZm9yY2UpIHsgLy9jaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGltZSAhPT0gLTAuMDAwMSkgeyAvLy0wLjAwMDEgaXMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgd2UgdXNlIHdoZW4gbG9vcGluZyBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSByZXBlYXRlZCBUaW1lbGluZU1heCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRuJ3QgcmVuZGVyIHRoZSBfc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzW2NhbGxiYWNrXS5hcHBseSh0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlNjb3BlXCJdIHx8IHRoaXMsIHRoaXMudmFyc1tjYWxsYmFjayArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHJhd1ByZXZUaW1lICE9PSBfdGlueU51bSkgeyAvL3RoZSBvbkNvbXBsZXRlIG9yIG9uUmV2ZXJzZUNvbXBsZXRlIGNvdWxkIHRyaWdnZXIgbW92ZW1lbnQgb2YgdGhlIHBsYXloZWFkIGFuZCBmb3IgemVyby1kdXJhdGlvbiB0d2VlbnMgKHdoaWNoIG11c3QgZGlzY2VybiBkaXJlY3Rpb24pIHRoYXQgbGFuZCBkaXJlY3RseSBiYWNrIG9uIHRoZWlyIHN0YXJ0IHRpbWUsIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBhZ2FpbiBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaW5rIG9mIHNldmVyYWwgYWRkUGF1c2UoKSdzIGluIGEgdGltZWxpbmUgdGhhdCBmb3JjZXMgdGhlIHBsYXloZWFkIHRvIGEgY2VydGFpbiBzcG90LCBidXQgd2hhdCBpZiBpdCdzIGFscmVhZHkgcGF1c2VkIGFuZCBhbm90aGVyIHR3ZWVuIGlzIHR3ZWVuaW5nIHRoZSBcInRpbWVcIiBvZiB0aGUgdGltZWxpbmU/IEVhY2ggdGltZSBpdCBtb3ZlcyBbZm9yd2FyZF0gcGFzdCB0aGF0IHNwb3QsIGl0IHdvdWxkIG1vdmUgYmFjaywgYW5kIHNpbmNlIHN1cHByZXNzRXZlbnRzIGlzIHRydWUsIGl0J2QgcmVzZXQgX3Jhd1ByZXZUaW1lIHRvIF90aW55TnVtIHNvIHRoYXQgd2hlbiBpdCBiZWdpbnMgYWdhaW4sIHRoZSBjYWxsYmFjayB3b3VsZCBmaXJlIChzbyB1bHRpbWF0ZWx5IGl0IGNvdWxkIGJvdW5jZSBiYWNrIGFuZCBmb3J0aCBkdXJpbmcgdGhhdCB0d2VlbikuIEFnYWluLCB0aGlzIGlzIGEgdmVyeSB1bmNvbW1vbiBzY2VuYXJpbywgYnV0IHBvc3NpYmxlIG5vbmV0aGVsZXNzLlxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0LCBvdmVyd3JpdGluZ1R3ZWVuKSB7XG5cdFx0XHRpZiAodmFycyA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHR2YXJzID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICh2YXJzID09IG51bGwpIGlmICh0YXJnZXQgPT0gbnVsbCB8fCB0YXJnZXQgPT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyAodGFyZ2V0IHx8IHRoaXMuX3RhcmdldHMgfHwgdGhpcy50YXJnZXQpIDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIGksIG92ZXJ3cml0dGVuUHJvcHMsIHAsIHB0LCBwcm9wTG9va3VwLCBjaGFuZ2VkLCBraWxsUHJvcHMsIHJlY29yZCwga2lsbGVkO1xuXHRcdFx0aWYgKChfaXNBcnJheSh0YXJnZXQpIHx8IF9pc1NlbGVjdG9yKHRhcmdldCkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fa2lsbCh2YXJzLCB0YXJnZXRbaV0pKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl90YXJnZXRzKSB7XG5cdFx0XHRcdFx0aSA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gdGhpcy5fdGFyZ2V0c1tpXSkge1xuXHRcdFx0XHRcdFx0XHRwcm9wTG9va3VwID0gdGhpcy5fcHJvcExvb2t1cFtpXSB8fCB7fTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwgW107XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzW2ldID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLnRhcmdldCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwcm9wTG9va3VwID0gdGhpcy5fcHJvcExvb2t1cDtcblx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHZhcnMgPyB0aGlzLl9vdmVyd3JpdHRlblByb3BzIHx8IHt9IDogXCJhbGxcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcm9wTG9va3VwKSB7XG5cdFx0XHRcdFx0a2lsbFByb3BzID0gdmFycyB8fCBwcm9wTG9va3VwO1xuXHRcdFx0XHRcdHJlY29yZCA9ICh2YXJzICE9PSBvdmVyd3JpdHRlblByb3BzICYmIG92ZXJ3cml0dGVuUHJvcHMgIT09IFwiYWxsXCIgJiYgdmFycyAhPT0gcHJvcExvb2t1cCAmJiAodHlwZW9mKHZhcnMpICE9PSBcIm9iamVjdFwiIHx8ICF2YXJzLl90ZW1wS2lsbCkpOyAvL190ZW1wS2lsbCBpcyBhIHN1cGVyLXNlY3JldCB3YXkgdG8gZGVsZXRlIGEgcGFydGljdWxhciB0d2VlbmluZyBwcm9wZXJ0eSBidXQgTk9UIGhhdmUgaXQgcmVtZW1iZXJlZCBhcyBhbiBvZmZpY2lhbCBvdmVyd3JpdHRlbiBwcm9wZXJ0eSAobGlrZSBpbiBCZXppZXJQbHVnaW4pXG5cdFx0XHRcdFx0aWYgKG92ZXJ3cml0aW5nVHdlZW4gJiYgKFR3ZWVuTGl0ZS5vbk92ZXJ3cml0ZSB8fCB0aGlzLnZhcnMub25PdmVyd3JpdGUpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4ga2lsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wTG9va3VwW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFraWxsZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGtpbGxlZCA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRraWxsZWQucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCFfb25PdmVyd3JpdGUodGhpcywgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWQpKSB7IC8vaWYgdGhlIG9uT3ZlcndyaXRlIHJldHVybmVkIGZhbHNlLCB0aGF0IG1lYW5zIHRoZSB1c2VyIHdhbnRzIHRvIG92ZXJyaWRlIHRoZSBvdmVyd3JpdGluZyAoY2FuY2VsIGl0KS5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdGlmICgocHQgPSBwcm9wTG9va3VwW3BdKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocHQucGcgJiYgcHQudC5fa2lsbChraWxsUHJvcHMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7IC8vc29tZSBwbHVnaW5zIG5lZWQgdG8gYmUgbm90aWZpZWQgc28gdGhleSBjYW4gcGVyZm9ybSBjbGVhbnVwIHRhc2tzIGZpcnN0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFwdC5wZyB8fCBwdC50Ll9vdmVyd3JpdGVQcm9wcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwdCA9PT0gdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHB0Ll9uZXh0ID0gcHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBwcm9wTG9va3VwW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHJlY29yZCkge1xuXHRcdFx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzW3BdID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9maXJzdFBUICYmIHRoaXMuX2luaXR0ZWQpIHsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBhcmUga2lsbGVkLCBraWxsIHRoZSB0d2Vlbi4gV2l0aG91dCB0aGlzIGxpbmUsIGlmIHRoZXJlJ3MgYSB0d2VlbiB3aXRoIG11bHRpcGxlIHRhcmdldHMgYW5kIHRoZW4geW91IGtpbGxUd2VlbnNPZigpIGVhY2ggdGFyZ2V0IGluZGl2aWR1YWxseSwgdGhlIHR3ZWVuIHdvdWxkIHRlY2huaWNhbGx5IHN0aWxsIHJlbWFpbiBhY3RpdmUgYW5kIGZpcmUgaXRzIG9uQ29tcGxldGUgZXZlbiB0aG91Z2ggdGhlcmUgYXJlbid0IGFueSBtb3JlIHByb3BlcnRpZXMgdHdlZW5pbmcuXG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCkge1xuXHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZmlyc3RQVCA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSBudWxsO1xuXHRcdFx0dGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSAodGhpcy5fdGFyZ2V0cykgPyB7fSA6IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdFx0dGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmIChlbmFibGVkICYmIHRoaXMuX2djKSB7XG5cdFx0XHRcdHZhciB0YXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRpZiAodGFyZ2V0cykge1xuXHRcdFx0XHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzW2ldID0gX3JlZ2lzdGVyKHRhcmdldHNbaV0sIHRoaXMsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IF9yZWdpc3Rlcih0aGlzLnRhcmdldCwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdEFuaW1hdGlvbi5wcm90b3R5cGUuX2VuYWJsZWQuY2FsbCh0aGlzLCBlbmFibGVkLCBpZ25vcmVUaW1lbGluZSk7XG5cdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCkgaWYgKHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0cmV0dXJuIFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudCgoZW5hYmxlZCA/IFwiX29uRW5hYmxlXCIgOiBcIl9vbkRpc2FibGVcIiksIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuLy8tLS0tVHdlZW5MaXRlIHN0YXRpYyBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRUd2VlbkxpdGUudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHRvVmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgdXNlRnJhbWVzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZShjYWxsYmFjaywgMCwge2RlbGF5OmRlbGF5LCBvbkNvbXBsZXRlOmNhbGxiYWNrLCBvbkNvbXBsZXRlUGFyYW1zOnBhcmFtcywgb25Db21wbGV0ZVNjb3BlOnNjb3BlLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBvblJldmVyc2VDb21wbGV0ZVNjb3BlOnNjb3BlLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2UsIGxhenk6ZmFsc2UsIHVzZUZyYW1lczp1c2VGcmFtZXMsIG92ZXJ3cml0ZTowfSk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uKHRhcmdldCwgb25seUFjdGl2ZSkge1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/IHRhcmdldCA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblx0XHRcdHZhciBpLCBhLCBqLCB0O1xuXHRcdFx0aWYgKChfaXNBcnJheSh0YXJnZXQpIHx8IF9pc1NlbGVjdG9yKHRhcmdldCkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXQubGVuZ3RoO1xuXHRcdFx0XHRhID0gW107XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGEgPSBhLmNvbmNhdChUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0W2ldLCBvbmx5QWN0aXZlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHQvL25vdyBnZXQgcmlkIG9mIGFueSBkdXBsaWNhdGVzICh0d2VlbnMgb2YgYXJyYXlzIG9mIG9iamVjdHMgY291bGQgY2F1c2UgZHVwbGljYXRlcylcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dCA9IGFbaV07XG5cdFx0XHRcdFx0aiA9IGk7XG5cdFx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodCA9PT0gYVtqXSkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGEgPSBfcmVnaXN0ZXIodGFyZ2V0KS5jb25jYXQoKTtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MgfHwgKG9ubHlBY3RpdmUgJiYgIWFbaV0uaXNBY3RpdmUoKSkpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2YgPSBUd2VlbkxpdGUua2lsbERlbGF5ZWRDYWxsc1RvID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlLCB2YXJzKSB7XG5cdFx0XHRpZiAodHlwZW9mKG9ubHlBY3RpdmUpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBvbmx5QWN0aXZlOyAvL2ZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoYmVmb3JlIFwib25seUFjdGl2ZVwiIHBhcmFtZXRlciB3YXMgaW5zZXJ0ZWQpXG5cdFx0XHRcdG9ubHlBY3RpdmUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBhID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCwgb25seUFjdGl2ZSksXG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRhW2ldLl9raWxsKHZhcnMsIHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUd2VlblBsdWdpbiAgIChjb3VsZCBlYXNpbHkgYmUgc3BsaXQgb3V0IGFzIGEgc2VwYXJhdGUgZmlsZS9jbGFzcywgYnV0IGluY2x1ZGVkIGZvciBlYXNlIG9mIHVzZSAoc28gdGhhdCBwZW9wbGUgZG9uJ3QgbmVlZCB0byBpbmNsdWRlIGFub3RoZXIgc2NyaXB0IGNhbGwgYmVmb3JlIGxvYWRpbmcgcGx1Z2lucyB3aGljaCBpcyBlYXN5IHRvIGZvcmdldClcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBUd2VlblBsdWdpbiA9IF9jbGFzcyhcInBsdWdpbnMuVHdlZW5QbHVnaW5cIiwgZnVuY3Rpb24ocHJvcHMsIHByaW9yaXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSAocHJvcHMgfHwgXCJcIikuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BOYW1lID0gdGhpcy5fb3ZlcndyaXRlUHJvcHNbMF07XG5cdFx0XHRcdFx0dGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gVHdlZW5QbHVnaW4ucHJvdG90eXBlO1xuXHRcdFx0XHR9LCB0cnVlKTtcblxuXHRcdHAgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0VHdlZW5QbHVnaW4udmVyc2lvbiA9IFwiMS4xMC4xXCI7XG5cdFx0VHdlZW5QbHVnaW4uQVBJID0gMjtcblx0XHRwLl9maXJzdFBUID0gbnVsbDtcblxuXHRcdHAuX2FkZFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBvdmVyd3JpdGVQcm9wLCByb3VuZCkge1xuXHRcdFx0dmFyIGMsIHB0O1xuXHRcdFx0aWYgKGVuZCAhPSBudWxsICYmIChjID0gKHR5cGVvZihlbmQpID09PSBcIm51bWJlclwiIHx8IGVuZC5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IE51bWJlcihlbmQpIC0gc3RhcnQgOiBwYXJzZUludChlbmQuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIE51bWJlcihlbmQuc3Vic3RyKDIpKSkpIHtcblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6dGFyZ2V0LCBwOnByb3AsIHM6c3RhcnQsIGM6YywgZjoodHlwZW9mKHRhcmdldFtwcm9wXSkgPT09IFwiZnVuY3Rpb25cIiksIG46b3ZlcndyaXRlUHJvcCB8fCBwcm9wLCByOnJvdW5kfTtcblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0dmFsO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdHZhbCA9IHB0LmMgKiB2ICsgcHQucztcblx0XHRcdFx0aWYgKHB0LnIpIHtcblx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluKSBpZiAodmFsID4gLW1pbikgeyAvL3ByZXZlbnRzIGlzc3VlcyB3aXRoIGNvbnZlcnRpbmcgdmVyeSBzbWFsbCBudW1iZXJzIHRvIHN0cmluZ3MgaW4gdGhlIGJyb3dzZXJcblx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSh2YWwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRpO1xuXHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobG9va3VwW2FbaV1dICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChsb29rdXBbcHQubl0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fcm91bmRQcm9wcyA9IGZ1bmN0aW9uKGxvb2t1cCwgdmFsdWUpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gfHwgKHB0Lm4gIT0gbnVsbCAmJiBsb29rdXBbIHB0Lm4uc3BsaXQodGhpcy5fcHJvcE5hbWUgKyBcIl9cIikuam9pbihcIlwiKSBdKSkgeyAvL3NvbWUgcHJvcGVydGllcyB0aGF0IGFyZSB2ZXJ5IHBsdWdpbi1zcGVjaWZpYyBhZGQgYSBwcmVmaXggbmFtZWQgYWZ0ZXIgdGhlIF9wcm9wTmFtZSBwbHVzIGFuIHVuZGVyc2NvcmUsIHNvIHdlIG5lZWQgdG8gaWdub3JlIHRoYXQgZXh0cmEgc3R1ZmYgaGVyZS5cblx0XHRcdFx0XHRwdC5yID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50ID0gZnVuY3Rpb24odHlwZSwgdHdlZW4pIHtcblx0XHRcdHZhciBwdCA9IHR3ZWVuLl9maXJzdFBULFxuXHRcdFx0XHRjaGFuZ2VkLCBwdDIsIGZpcnN0LCBsYXN0LCBuZXh0O1xuXHRcdFx0aWYgKHR5cGUgPT09IFwiX29uSW5pdEFsbFByb3BzXCIpIHtcblx0XHRcdFx0Ly9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gcmVuZGVyIGVhcmxpZXIvbGF0ZXIgdGhhbiBvdGhlcnMsIGxpa2UgTW90aW9uQmx1clBsdWdpbiBhcHBsaWVzIGl0cyBlZmZlY3RzIGFmdGVyIGFsbCB4L3kvYWxwaGEgdHdlZW5zIGhhdmUgcmVuZGVyZWQgb24gZWFjaCBmcmFtZS5cblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gdHdlZW4uX2ZpcnN0UFQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQucGcpIGlmICh0eXBlb2YocHQudFt0eXBlXSkgPT09IFwiZnVuY3Rpb25cIikgaWYgKHB0LnRbdHlwZV0oKSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUgPSBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0XHR2YXIgaSA9IHBsdWdpbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwbHVnaW5zW2ldLkFQSSA9PT0gVHdlZW5QbHVnaW4uQVBJKSB7XG5cdFx0XHRcdFx0X3BsdWdpbnNbKG5ldyBwbHVnaW5zW2ldKCkpLl9wcm9wTmFtZV0gPSBwbHVnaW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0Ly9wcm92aWRlcyBhIG1vcmUgY29uY2lzZSB3YXkgdG8gZGVmaW5lIHBsdWdpbnMgdGhhdCBoYXZlIG5vIGRlcGVuZGVuY2llcyBiZXNpZGVzIFR3ZWVuUGx1Z2luIGFuZCBUd2VlbkxpdGUsIHdyYXBwaW5nIGNvbW1vbiBib2lsZXJwbGF0ZSBzdHVmZiBpbnRvIG9uZSBmdW5jdGlvbiAoYWRkZWQgaW4gMS45LjApLiBZb3UgZG9uJ3QgTkVFRCB0byB1c2UgdGhpcyB0byBkZWZpbmUgYSBwbHVnaW4gLSB0aGUgb2xkIHdheSBzdGlsbCB3b3JrcyBhbmQgY2FuIGJlIHVzZWZ1bCBpbiBjZXJ0YWluIChyYXJlKSBzaXR1YXRpb25zLlxuXHRcdF9nc0RlZmluZS5wbHVnaW4gPSBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdGlmICghY29uZmlnIHx8ICFjb25maWcucHJvcE5hbWUgfHwgIWNvbmZpZy5pbml0IHx8ICFjb25maWcuQVBJKSB7IHRocm93IFwiaWxsZWdhbCBwbHVnaW4gZGVmaW5pdGlvbi5cIjsgfVxuXHRcdFx0dmFyIHByb3BOYW1lID0gY29uZmlnLnByb3BOYW1lLFxuXHRcdFx0XHRwcmlvcml0eSA9IGNvbmZpZy5wcmlvcml0eSB8fCAwLFxuXHRcdFx0XHRvdmVyd3JpdGVQcm9wcyA9IGNvbmZpZy5vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0bWFwID0ge2luaXQ6XCJfb25Jbml0VHdlZW5cIiwgc2V0Olwic2V0UmF0aW9cIiwga2lsbDpcIl9raWxsXCIsIHJvdW5kOlwiX3JvdW5kUHJvcHNcIiwgaW5pdEFsbDpcIl9vbkluaXRBbGxQcm9wc1wifSxcblx0XHRcdFx0UGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5cIiArIHByb3BOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcE5hbWUuc3Vic3RyKDEpICsgXCJQbHVnaW5cIixcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFR3ZWVuUGx1Z2luLmNhbGwodGhpcywgcHJvcE5hbWUsIHByaW9yaXR5KTtcblx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXRlUHJvcHMgfHwgW107XG5cdFx0XHRcdFx0fSwgKGNvbmZpZy5nbG9iYWwgPT09IHRydWUpKSxcblx0XHRcdFx0cCA9IFBsdWdpbi5wcm90b3R5cGUgPSBuZXcgVHdlZW5QbHVnaW4ocHJvcE5hbWUpLFxuXHRcdFx0XHRwcm9wO1xuXHRcdFx0cC5jb25zdHJ1Y3RvciA9IFBsdWdpbjtcblx0XHRcdFBsdWdpbi5BUEkgPSBjb25maWcuQVBJO1xuXHRcdFx0Zm9yIChwcm9wIGluIG1hcCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKGNvbmZpZ1twcm9wXSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHBbbWFwW3Byb3BdXSA9IGNvbmZpZ1twcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0UGx1Z2luLnZlcnNpb24gPSBjb25maWcudmVyc2lvbjtcblx0XHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlKFtQbHVnaW5dKTtcblx0XHRcdHJldHVybiBQbHVnaW47XG5cdFx0fTtcblxuXG5cdFx0Ly9ub3cgcnVuIHRocm91Z2ggYWxsIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBhbmQgaWYgYW55IGFyZSBtaXNzaW5nLCBsb2cgdGhhdCB0byB0aGUgY29uc29sZSBhcyBhIHdhcm5pbmcuIFRoaXMgaXMgd2h5IGl0J3MgYmVzdCB0byBoYXZlIFR3ZWVuTGl0ZSBsb2FkIGxhc3QgLSBpdCBjYW4gY2hlY2sgYWxsIHRoZSBkZXBlbmRlbmNpZXMgZm9yIHlvdS5cblx0XHRhID0gd2luZG93Ll9nc1F1ZXVlO1xuXHRcdGlmIChhKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRhW2ldKCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gX2RlZkxvb2t1cCkge1xuXHRcdFx0XHRpZiAoIV9kZWZMb29rdXBbcF0uZnVuYykge1xuXHRcdFx0XHRcdHdpbmRvdy5jb25zb2xlLmxvZyhcIkdTQVAgZW5jb3VudGVyZWQgbWlzc2luZyBkZXBlbmRlbmN5OiBjb20uZ3JlZW5zb2NrLlwiICsgcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7IC8vZW5zdXJlcyB0aGF0IHRoZSBmaXJzdCBvZmZpY2lhbCBhbmltYXRpb24gZm9yY2VzIGEgdGlja2VyLnRpY2soKSB0byB1cGRhdGUgdGhlIHRpbWUgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWRcblxufSkoKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93LCBcIlR3ZWVuTWF4XCIpOyIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjQgLSAyMDE0LTA5LTI4XG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ21veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgZXh0ZW5kKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gbGFzdC5kZWx0YVggLSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBsYXN0LmRlbHRhWSAtIGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5ID4gMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpIC0gZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5hbGxvdyA9IHRydWU7IC8vIHVzZWQgYnkgSW5wdXQuVG91Y2hNb3VzZSB0byBkaXNhYmxlIG1vdXNlIGV2ZW50c1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duLCBhbmQgbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkIChzZWUgdGhlIFRvdWNoTW91c2UgaW5wdXQpXG4gICAgICAgIGlmICghdGhpcy5wcmVzc2VkIHx8ICF0aGlzLmFsbG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbn1cblxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICBdO1xufVxuXG4vKipcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCBzbyAgYmxvY2sgYWxsIHVwY29taW5nIG1vdXNlIGV2ZW50c1xuICAgICAgICAvLyBtb3N0IG1vYmlsZSBicm93c2VyIGFsc28gZW1pdCBtb3VzZWV2ZW50cywgcmlnaHQgYWZ0ZXIgdG91Y2hzdGFydFxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgIXRoaXMubW91c2UuYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBhbGxvd01vdXNlIHdoZW4gd2UncmUgZG9uZVxuICAgICAgICBpZiAoaW5wdXRFdmVudCAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgLy8gbm90IG5lZWRlZCB3aXRoIG5hdGl2ZSBzdXBwb3J0IGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHlcbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcblxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgIC8vIHBhbi14IGFuZCBwYW4teSBjYW4gYmUgY29tYmluZWRcbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fUEFOX1ggKyAnICcgKyBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRzKTtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBleHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KHdpdGhTdGF0ZSkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgKHdpdGhTdGF0ZSA/IHN0YXRlU3RyKHN0YXRlKSA6ICcnKSwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdCgpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBleHRlbmQoe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0LCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDUwMCwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA1IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjY1LFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eVg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0LnZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQuZGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn1cblxuaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0YXBzOiAxLFxuICAgICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgIHRocmVzaG9sZDogMiwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCApIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYW4gbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNCc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfSwgWydyb3RhdGUnXV0sXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIseyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwgeyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH0sIFsnc3dpcGUnXV0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIEhhbW1lci5kZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2gob3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xufVxuXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXI7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ3JlbW92ZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpLCAxKTtcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKV0gPSBhZGQgPyB2YWx1ZSA6ICcnO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5leHRlbmQoSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PSBUWVBFX0ZVTkNUSU9OICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbn0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xufVxuXG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG4iLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5wYWdlPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAvKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG4vKipcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIHBhdGh0b1JlZ2V4cCA9IHJlcXVpcmUoJ3BhdGgtdG8tcmVnZXhwJyk7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBleHBvcnRzLlxuICAgKi9cblxuICBtb2R1bGUuZXhwb3J0cyA9IHBhZ2U7XG5cbiAgLyoqXG4gICAqIFRvIHdvcmsgcHJvcGVybHkgd2l0aCB0aGUgVVJMXG4gICAqIGhpc3RvcnkubG9jYXRpb24gZ2VuZXJhdGVkIHBvbHlmaWxsIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZvdGUvSFRNTDUtSGlzdG9yeS1BUElcbiAgICovXG5cbiAgdmFyIGxvY2F0aW9uID0gd2luZG93Lmhpc3RvcnkubG9jYXRpb24gfHwgd2luZG93LmxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGluaXRpYWwgZGlzcGF0Y2guXG4gICAqL1xuXG4gIHZhciBkaXNwYXRjaCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEJhc2UgcGF0aC5cbiAgICovXG5cbiAgdmFyIGJhc2UgPSAnJztcblxuICAvKipcbiAgICogUnVubmluZyBmbGFnLlxuICAgKi9cblxuICB2YXIgcnVubmluZztcblxuICAvKipcbiAgKiBIYXNoQmFuZyBvcHRpb25cbiAgKi9cblxuICB2YXIgaGFzaGJhbmcgPSBmYWxzZTtcblxuICAvKipcbiAgICogUHJldmlvdXMgY29udGV4dCwgZm9yIGNhcHR1cmluZ1xuICAgKiBwYWdlIGV4aXQgZXZlbnRzLlxuICAgKi9cblxuICB2YXIgcHJldkNvbnRleHQ7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGBwYXRoYCB3aXRoIGNhbGxiYWNrIGBmbigpYCxcbiAgICogb3Igcm91dGUgYHBhdGhgLCBvciByZWRpcmVjdGlvbixcbiAgICogb3IgYHBhZ2Uuc3RhcnQoKWAuXG4gICAqXG4gICAqICAgcGFnZShmbik7XG4gICAqICAgcGFnZSgnKicsIGZuKTtcbiAgICogICBwYWdlKCcvdXNlci86aWQnLCBsb2FkLCB1c2VyKTtcbiAgICogICBwYWdlKCcvdXNlci8nICsgdXNlci5pZCwgeyBzb21lOiAndGhpbmcnIH0pO1xuICAgKiAgIHBhZ2UoJy91c2VyLycgKyB1c2VyLmlkKTtcbiAgICogICBwYWdlKCcvZnJvbScsICcvdG8nKVxuICAgKiAgIHBhZ2UoKTtcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHBhdGhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4uLi5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gcGFnZShwYXRoLCBmbikge1xuICAgIC8vIDxjYWxsYmFjaz5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYWdlKCcqJywgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gcm91dGUgPHBhdGg+IHRvIDxjYWxsYmFjayAuLi4+XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmbikge1xuICAgICAgdmFyIHJvdXRlID0gbmV3IFJvdXRlKHBhdGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcGFnZS5jYWxsYmFja3MucHVzaChyb3V0ZS5taWRkbGV3YXJlKGFyZ3VtZW50c1tpXSkpO1xuICAgICAgfVxuICAgIC8vIHNob3cgPHBhdGg+IHdpdGggW3N0YXRlXVxuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHBhdGgpIHtcbiAgICAgICdzdHJpbmcnID09PSB0eXBlb2YgZm5cbiAgICAgICAgPyBwYWdlLnJlZGlyZWN0KHBhdGgsIGZuKVxuICAgICAgICA6IHBhZ2Uuc2hvdyhwYXRoLCBmbik7XG4gICAgLy8gc3RhcnQgW29wdGlvbnNdXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2Uuc3RhcnQocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICovXG5cbiAgcGFnZS5jYWxsYmFja3MgPSBbXTtcbiAgcGFnZS5leGl0cyA9IFtdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGJhc2VwYXRoIHRvIGBwYXRoYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5iYXNlID0gZnVuY3Rpb24ocGF0aCl7XG4gICAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYXNlO1xuICAgIGJhc2UgPSBwYXRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAgICpcbiAgICogT3B0aW9uczpcbiAgICpcbiAgICogICAgLSBgY2xpY2tgIGJpbmQgdG8gY2xpY2sgZXZlbnRzIFt0cnVlXVxuICAgKiAgICAtIGBwb3BzdGF0ZWAgYmluZCB0byBwb3BzdGF0ZSBbdHJ1ZV1cbiAgICogICAgLSBgZGlzcGF0Y2hgIHBlcmZvcm0gaW5pdGlhbCBkaXNwYXRjaCBbdHJ1ZV1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChydW5uaW5nKSByZXR1cm47XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgaWYgKGZhbHNlID09PSBvcHRpb25zLmRpc3BhdGNoKSBkaXNwYXRjaCA9IGZhbHNlO1xuICAgIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5wb3BzdGF0ZSkgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25wb3BzdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5jbGljaykgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25jbGljaywgZmFsc2UpO1xuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmhhc2hiYW5nKSBoYXNoYmFuZyA9IHRydWU7XG4gICAgaWYgKCFkaXNwYXRjaCkgcmV0dXJuO1xuICAgIHZhciB1cmwgPSAoaGFzaGJhbmcgJiYgfmxvY2F0aW9uLmhhc2guaW5kZXhPZignIyEnKSlcbiAgICAgID8gbG9jYXRpb24uaGFzaC5zdWJzdHIoMikgKyBsb2NhdGlvbi5zZWFyY2hcbiAgICAgIDogbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoO1xuICAgIHBhZ2UucmVwbGFjZSh1cmwsIG51bGwsIHRydWUsIGRpc3BhdGNoKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIGNsaWNrIGFuZCBwb3BzdGF0ZSBldmVudCBoYW5kbGVycy5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoIXJ1bm5pbmcpIHJldHVybjtcbiAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25jbGljaywgZmFsc2UpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9ucG9wc3RhdGUsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyBgcGF0aGAgd2l0aCBvcHRpb25hbCBgc3RhdGVgIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzcGF0Y2hcbiAgICogQHJldHVybiB7Q29udGV4dH1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5zaG93ID0gZnVuY3Rpb24ocGF0aCwgc3RhdGUsIGRpc3BhdGNoKXtcbiAgICB2YXIgY3R4ID0gbmV3IENvbnRleHQocGF0aCwgc3RhdGUpO1xuICAgIGlmIChmYWxzZSAhPT0gZGlzcGF0Y2gpIHBhZ2UuZGlzcGF0Y2goY3R4KTtcbiAgICBpZiAoZmFsc2UgIT09IGN0eC5oYW5kbGVkKSBjdHgucHVzaFN0YXRlKCk7XG4gICAgcmV0dXJuIGN0eDtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgcm91dGUgdG8gcmVkaXJlY3QgZnJvbSBvbmUgcGF0aCB0byBvdGhlclxuICAgKiBvciBqdXN0IHJlZGlyZWN0IHRvIGFub3RoZXIgcm91dGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyb20gLSBpZiBwYXJhbSAndG8nIGlzIHVuZGVmaW5lZCByZWRpcmVjdHMgdG8gJ2Zyb20nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdG9dXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBwYWdlLnJlZGlyZWN0ID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAvLyBEZWZpbmUgcm91dGUgZnJvbSBhIHBhdGggdG8gYW5vdGhlclxuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGZyb20gJiYgJ3N0cmluZycgPT09IHR5cGVvZiB0bykge1xuICAgICAgcGFnZShmcm9tLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHBhZ2UucmVwbGFjZSh0byk7XG4gICAgICAgIH0sMCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXYWl0IGZvciB0aGUgcHVzaCBzdGF0ZSBhbmQgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXJcbiAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGZyb20gJiYgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0bykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBwYWdlLnJlcGxhY2UoZnJvbSk7XG4gICAgICB9LDApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZSBgcGF0aGAgd2l0aCBvcHRpb25hbCBgc3RhdGVgIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEByZXR1cm4ge0NvbnRleHR9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2UucmVwbGFjZSA9IGZ1bmN0aW9uKHBhdGgsIHN0YXRlLCBpbml0LCBkaXNwYXRjaCl7XG4gICAgdmFyIGN0eCA9IG5ldyBDb250ZXh0KHBhdGgsIHN0YXRlKTtcbiAgICBjdHguaW5pdCA9IGluaXQ7XG4gICAgY3R4LnNhdmUoKTsgLy8gc2F2ZSBiZWZvcmUgZGlzcGF0Y2hpbmcsIHdoaWNoIG1heSByZWRpcmVjdFxuICAgIGlmIChmYWxzZSAhPT0gZGlzcGF0Y2gpIHBhZ2UuZGlzcGF0Y2goY3R4KTtcbiAgICByZXR1cm4gY3R4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCB0aGUgZ2l2ZW4gYGN0eGAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIHBhZ2UuZGlzcGF0Y2ggPSBmdW5jdGlvbihjdHgpe1xuICAgIHZhciBwcmV2ID0gcHJldkNvbnRleHQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHByZXZDb250ZXh0ID0gY3R4O1xuXG4gICAgZnVuY3Rpb24gbmV4dEV4aXQoKSB7XG4gICAgICB2YXIgZm4gPSBwYWdlLmV4aXRzW2orK107XG4gICAgICBpZiAoIWZuKSByZXR1cm4gbmV4dEVudGVyKCk7XG4gICAgICBmbihwcmV2LCBuZXh0RXhpdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dEVudGVyKCkge1xuICAgICAgdmFyIGZuID0gcGFnZS5jYWxsYmFja3NbaSsrXTtcbiAgICAgIGlmICghZm4pIHJldHVybiB1bmhhbmRsZWQoY3R4KTtcbiAgICAgIGZuKGN0eCwgbmV4dEVudGVyKTtcbiAgICB9XG5cbiAgICBpZiAocHJldikge1xuICAgICAgbmV4dEV4aXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEVudGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbmhhbmRsZWQgYGN0eGAuIFdoZW4gaXQncyBub3QgdGhlIGluaXRpYWxcbiAgICogcG9wc3RhdGUgdGhlbiByZWRpcmVjdC4gSWYgeW91IHdpc2ggdG8gaGFuZGxlXG4gICAqIDQwNHMgb24geW91ciBvd24gdXNlIGBwYWdlKCcqJywgY2FsbGJhY2spYC5cbiAgICpcbiAgICogQHBhcmFtIHtDb250ZXh0fSBjdHhcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHVuaGFuZGxlZChjdHgpIHtcbiAgICBpZiAoY3R4LmhhbmRsZWQpIHJldHVybjtcbiAgICB2YXIgY3VycmVudDtcblxuICAgIGlmIChoYXNoYmFuZykge1xuICAgICAgY3VycmVudCA9IGJhc2UgKyBsb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMhJywnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gY3R4LmNhbm9uaWNhbFBhdGgpIHJldHVybjtcbiAgICBwYWdlLnN0b3AoKTtcbiAgICBjdHguaGFuZGxlZCA9IGZhbHNlO1xuICAgIGxvY2F0aW9uLmhyZWYgPSBjdHguY2Fub25pY2FsUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBleGl0IHJvdXRlIG9uIGBwYXRoYCB3aXRoXG4gICAqIGNhbGxiYWNrIGBmbigpYCwgd2hpY2ggd2lsbCBiZSBjYWxsZWRcbiAgICogb24gdGhlIHByZXZpb3VzIGNvbnRleHQgd2hlbiBhIG5ld1xuICAgKiBwYWdlIGlzIHZpc2l0ZWQuXG4gICAqL1xuICBwYWdlLmV4aXQgPSBmdW5jdGlvbihwYXRoLCBmbikge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcGFnZS5leGl0KCcqJywgcGF0aCk7XG4gICAgfTtcblxuICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZShwYXRoKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgcGFnZS5leGl0cy5wdXNoKHJvdXRlLm1pZGRsZXdhcmUoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIFJlbW92ZSBVUkwgZW5jb2RpbmcgZnJvbSB0aGUgZ2l2ZW4gYHN0cmAuXG4gICogQWNjb21tb2RhdGVzIHdoaXRlc3BhY2UgaW4gYm90aCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgKiBhbmQgcmVndWxhciBwZXJjZW50LWVuY29kZWQgZm9ybS5cbiAgKlxuICAqIEBwYXJhbSB7c3RyfSBVUkwgY29tcG9uZW50IHRvIGRlY29kZVxuICAqL1xuICBmdW5jdGlvbiBkZWNvZGVVUkxFbmNvZGVkVVJJQ29tcG9uZW50KHN0cikge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IFwicmVxdWVzdFwiIGBDb250ZXh0YFxuICAgKiB3aXRoIHRoZSBnaXZlbiBgcGF0aGAgYW5kIG9wdGlvbmFsIGluaXRpYWwgYHN0YXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIENvbnRleHQocGF0aCwgc3RhdGUpIHtcbiAgICBwYXRoID0gZGVjb2RlVVJMRW5jb2RlZFVSSUNvbXBvbmVudChwYXRoKTtcbiAgICBpZiAoJy8nID09PSBwYXRoWzBdICYmIDAgIT09IHBhdGguaW5kZXhPZihiYXNlKSkgcGF0aCA9IGJhc2UgKyBwYXRoO1xuICAgIHZhciBpID0gcGF0aC5pbmRleE9mKCc/Jyk7XG5cbiAgICB0aGlzLmNhbm9uaWNhbFBhdGggPSBwYXRoO1xuICAgIHRoaXMucGF0aCA9IHBhdGgucmVwbGFjZShiYXNlLCAnJykgfHwgJy8nO1xuXG4gICAgdGhpcy50aXRsZSA9IGRvY3VtZW50LnRpdGxlO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgICB0aGlzLnN0YXRlLnBhdGggPSBwYXRoO1xuICAgIHRoaXMucXVlcnlzdHJpbmcgPSB+aVxuICAgICAgPyBwYXRoLnNsaWNlKGkgKyAxKVxuICAgICAgOiAnJztcbiAgICB0aGlzLnBhdGhuYW1lID0gfmlcbiAgICAgID8gcGF0aC5zbGljZSgwLCBpKVxuICAgICAgOiBwYXRoO1xuICAgIHRoaXMucGFyYW1zID0gW107XG5cbiAgICAvLyBmcmFnbWVudFxuICAgIHRoaXMuaGFzaCA9ICcnO1xuICAgIGlmICghfnRoaXMucGF0aC5pbmRleE9mKCcjJykpIHJldHVybjtcbiAgICB2YXIgcGFydHMgPSB0aGlzLnBhdGguc3BsaXQoJyMnKTtcbiAgICB0aGlzLnBhdGggPSBwYXJ0c1swXTtcbiAgICB0aGlzLmhhc2ggPSBwYXJ0c1sxXSB8fCAnJztcbiAgICB0aGlzLnF1ZXJ5c3RyaW5nID0gdGhpcy5xdWVyeXN0cmluZy5zcGxpdCgnIycpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBgQ29udGV4dGAuXG4gICAqL1xuXG4gIHBhZ2UuQ29udGV4dCA9IENvbnRleHQ7XG5cbiAgLyoqXG4gICAqIFB1c2ggc3RhdGUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBDb250ZXh0LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbigpe1xuICAgIGhpc3RvcnkucHVzaFN0YXRlKHRoaXMuc3RhdGVcbiAgICAgICwgdGhpcy50aXRsZVxuICAgICAgLCBoYXNoYmFuZyAmJiB0aGlzLnBhdGggIT09ICcvJ1xuICAgICAgICA/ICcjIScgKyB0aGlzLnBhdGhcbiAgICAgICAgOiB0aGlzLmNhbm9uaWNhbFBhdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHRoZSBjb250ZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDb250ZXh0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKXtcbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh0aGlzLnN0YXRlXG4gICAgICAsIHRoaXMudGl0bGVcbiAgICAgICwgaGFzaGJhbmcgJiYgdGhpcy5wYXRoICE9PSAnLydcbiAgICAgICAgPyAnIyEnICsgdGhpcy5wYXRoXG4gICAgICAgIDogdGhpcy5jYW5vbmljYWxQYXRoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBgUm91dGVgIHdpdGggdGhlIGdpdmVuIEhUVFAgYHBhdGhgLFxuICAgKiBhbmQgYW4gYXJyYXkgb2YgYGNhbGxiYWNrc2AgYW5kIGBvcHRpb25zYC5cbiAgICpcbiAgICogT3B0aW9uczpcbiAgICpcbiAgICogICAtIGBzZW5zaXRpdmVgICAgIGVuYWJsZSBjYXNlLXNlbnNpdGl2ZSByb3V0ZXNcbiAgICogICAtIGBzdHJpY3RgICAgICAgIGVuYWJsZSBzdHJpY3QgbWF0Y2hpbmcgZm9yIHRyYWlsaW5nIHNsYXNoZXNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBSb3V0ZShwYXRoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5wYXRoID0gKHBhdGggPT09ICcqJykgPyAnKC4qKScgOiBwYXRoO1xuICAgIHRoaXMubWV0aG9kID0gJ0dFVCc7XG4gICAgdGhpcy5yZWdleHAgPSBwYXRodG9SZWdleHAodGhpcy5wYXRoLFxuICAgICAgdGhpcy5rZXlzID0gW10sXG4gICAgICBvcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIG9wdGlvbnMuc3RyaWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgYFJvdXRlYC5cbiAgICovXG5cbiAgcGFnZS5Sb3V0ZSA9IFJvdXRlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gcm91dGUgbWlkZGxld2FyZSB3aXRoXG4gICAqIHRoZSBnaXZlbiBjYWxsYmFjayBgZm4oKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBSb3V0ZS5wcm90b3R5cGUubWlkZGxld2FyZSA9IGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGN0eCwgbmV4dCl7XG4gICAgICBpZiAoc2VsZi5tYXRjaChjdHgucGF0aCwgY3R4LnBhcmFtcykpIHJldHVybiBmbihjdHgsIG5leHQpO1xuICAgICAgbmV4dCgpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgcm91dGUgbWF0Y2hlcyBgcGF0aGAsIGlmIHNvXG4gICAqIHBvcHVsYXRlIGBwYXJhbXNgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIFJvdXRlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdGgsIHBhcmFtcyl7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgIHFzSW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKSxcbiAgICAgICAgcGF0aG5hbWUgPSB+cXNJbmRleFxuICAgICAgICAgID8gcGF0aC5zbGljZSgwLCBxc0luZGV4KVxuICAgICAgICAgIDogcGF0aCxcbiAgICAgICAgbSA9IHRoaXMucmVnZXhwLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHBhdGhuYW1lKSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG5cbiAgICAgIHZhciB2YWwgPSAnc3RyaW5nJyA9PT0gdHlwZW9mIG1baV1cbiAgICAgICAgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSlcbiAgICAgICAgOiBtW2ldO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB1bmRlZmluZWQgIT09IHBhcmFtc1trZXkubmFtZV1cbiAgICAgICAgICA/IHBhcmFtc1trZXkubmFtZV1cbiAgICAgICAgICA6IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBcInBvcHVsYXRlXCIgZXZlbnRzLlxuICAgKi9cblxuICBmdW5jdGlvbiBvbnBvcHN0YXRlKGUpIHtcbiAgICBpZiAoZS5zdGF0ZSkge1xuICAgICAgdmFyIHBhdGggPSBlLnN0YXRlLnBhdGg7XG4gICAgICBwYWdlLnJlcGxhY2UocGF0aCwgZS5zdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBcImNsaWNrXCIgZXZlbnRzLlxuICAgKi9cblxuICBmdW5jdGlvbiBvbmNsaWNrKGUpIHtcbiAgICBpZiAoMSAhPSB3aGljaChlKSkgcmV0dXJuO1xuICAgIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHJldHVybjtcbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAvLyBlbnN1cmUgbGlua1xuICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgIHdoaWxlIChlbCAmJiAnQScgIT0gZWwubm9kZU5hbWUpIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICBpZiAoIWVsIHx8ICdBJyAhPSBlbC5ub2RlTmFtZSkgcmV0dXJuO1xuXG4gICAgLy8gSWdub3JlIGlmIHRhZyBoYXMgYSBcImRvd25sb2FkXCIgYXR0cmlidXRlXG4gICAgaWYgKGVsLmdldEF0dHJpYnV0ZShcImRvd25sb2FkXCIpKSByZXR1cm47XG5cbiAgICAvLyBlbnN1cmUgbm9uLWhhc2ggZm9yIHRoZSBzYW1lIHBhdGhcbiAgICB2YXIgbGluayA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGlmIChlbC5wYXRobmFtZSA9PT0gbG9jYXRpb24ucGF0aG5hbWUgJiYgKGVsLmhhc2ggfHwgJyMnID09PSBsaW5rKSkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgZm9yIG1haWx0bzogaW4gdGhlIGhyZWZcbiAgICBpZiAobGluayAmJiBsaW5rLmluZGV4T2YoXCJtYWlsdG86XCIpID4gLTEpIHJldHVybjtcblxuICAgIC8vIGNoZWNrIHRhcmdldFxuICAgIGlmIChlbC50YXJnZXQpIHJldHVybjtcblxuICAgIC8vIHgtb3JpZ2luXG4gICAgaWYgKCFzYW1lT3JpZ2luKGVsLmhyZWYpKSByZXR1cm47XG5cbiAgICAvLyByZWJ1aWxkIHBhdGhcbiAgICB2YXIgcGF0aCA9IGVsLnBhdGhuYW1lICsgZWwuc2VhcmNoICsgKGVsLmhhc2ggfHwgJycpO1xuXG4gICAgLy8gc2FtZSBwYWdlXG4gICAgdmFyIG9yaWcgPSBwYXRoO1xuXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZShiYXNlLCAnJyk7XG5cbiAgICBpZiAoYmFzZSAmJiBvcmlnID09PSBwYXRoKSByZXR1cm47XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcGFnZS5zaG93KG9yaWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGJ1dHRvbi5cbiAgICovXG5cbiAgZnVuY3Rpb24gd2hpY2goZSkge1xuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICByZXR1cm4gbnVsbCA9PT0gZS53aGljaFxuICAgICAgPyBlLmJ1dHRvblxuICAgICAgOiBlLndoaWNoO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGBocmVmYCBpcyB0aGUgc2FtZSBvcmlnaW4uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNhbWVPcmlnaW4oaHJlZikge1xuICAgIHZhciBvcmlnaW4gPSBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgICBpZiAobG9jYXRpb24ucG9ydCkgb3JpZ2luICs9ICc6JyArIGxvY2F0aW9uLnBvcnQ7XG4gICAgcmV0dXJuIChocmVmICYmICgwID09PSBocmVmLmluZGV4T2Yob3JpZ2luKSkpO1xuICB9XG5cbiAgcGFnZS5zYW1lT3JpZ2luID0gc2FtZU9yaWdpbjtcblxufSx7XCJwYXRoLXRvLXJlZ2V4cFwiOjJ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogRXhwb3NlIGBwYXRodG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGh0b1JlZ2V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBhbHJlYWR5IGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBpbmNvcnJlY3RseSBhcHBlYXJcbiAgLy8gaW4gZnV0dXJlIG1hdGNoZXMuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdFxuICAvLyBzaG91bGRuJ3QgYmUgdHJhbnNmb3JtZWQuXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCJdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZF1cbiAgJyhbXFxcXC8uXSk/KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKShbKyo/XSk/JyxcbiAgLy8gTWF0Y2ggcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBhbHdheXMgYmUgZXNjYXBlZC5cbiAgJyhbLisqPz1eIToke30oKVtcXFxcXXxcXFxcL10pJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG52YXIgYXR0YWNoS2V5cyA9IGZ1bmN0aW9uIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcblxuICByZXR1cm4gcmU7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBzaG91bGQgYmUgcGFzc2VkIGluLCB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIHBsYWNlaG9sZGVyIGtleVxuICogbmFtZXMuIEZvciBleGFtcGxlIGAvdXNlci86aWRgIHdpbGwgdGhlbiBjb250YWluIGBbXCJpZFwiXWAuXG4gKlxuICogQHBhcmFtICB7KFN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRodG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKGtleXMgJiYgIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0ga2V5cztcbiAgICBrZXlzID0gbnVsbDtcbiAgfVxuXG4gIGtleXMgPSBrZXlzIHx8IFtdO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciBmbGFncyA9IG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSc7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBNYXRjaCBhbGwgY2FwdHVyaW5nIGdyb3VwcyBvZiBhIHJlZ2V4cC5cbiAgICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZykgfHwgW107XG5cbiAgICAvLyBNYXAgYWxsIHRoZSBtYXRjaGVzIHRvIHRoZWlyIG51bWVyaWMga2V5cyBhbmQgcHVzaCBpbnRvIHRoZSBrZXlzLlxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBncm91cHMubWFwKGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICAgICAgaW5kZXgsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6ICBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiAgICBmYWxzZVxuICAgICAgfTtcbiAgICB9KSk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHNvdXJjZSBiYWNrIHRvIHRoZSB1c2VyLlxuICAgIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAvLyBNYXAgYXJyYXkgcGFydHMgaW50byByZWdleHBzIGFuZCByZXR1cm4gdGhlaXIgc291cmNlLiBXZSBhbHNvIHBhc3NcbiAgICAvLyB0aGUgc2FtZSBrZXlzIGFuZCBvcHRpb25zIGluc3RhbmNlIGludG8gZXZlcnkgZ2VuZXJhdGlvbiB0byBnZXRcbiAgICAvLyBjb25zaXN0ZW50IG1hdGNoaW5nIGdyb3VwcyBiZWZvcmUgd2Ugam9pbiB0aGUgc291cmNlcyB0b2dldGhlci5cbiAgICBwYXRoID0gcGF0aC5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcGF0aHRvUmVnZXhwKHZhbHVlLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7XG4gICAgfSk7XG5cbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyByZWdleHAgaW5zdGFuY2UgYnkgam9pbmluZyBhbGwgdGhlIHBhcnRzIHRvZ2V0aGVyLlxuICAgIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJyg/OicgKyBwYXRoLmpvaW4oJ3wnKSArICcpJywgZmxhZ3MpLCBrZXlzKTtcbiAgfVxuXG4gIC8vIEFsdGVyIHRoZSBwYXRoIHN0cmluZyBpbnRvIGEgdXNhYmxlIHJlZ2V4cC5cbiAgcGF0aCA9IHBhdGgucmVwbGFjZShQQVRIX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoLCBlc2NhcGVkLCBwcmVmaXgsIGtleSwgY2FwdHVyZSwgZ3JvdXAsIHN1ZmZpeCwgZXNjYXBlKSB7XG4gICAgLy8gQXZvaWRpbmcgcmUtZXNjYXBpbmcgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG5cbiAgICAvLyBFc2NhcGUgcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlO1xuICAgIH1cblxuICAgIHZhciByZXBlYXQgICA9IHN1ZmZpeCA9PT0gJysnIHx8IHN1ZmZpeCA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IHN1ZmZpeCA9PT0gJz8nIHx8IHN1ZmZpeCA9PT0gJyonO1xuXG4gICAga2V5cy5wdXNoKHtcbiAgICAgIG5hbWU6ICAgICAga2V5IHx8IGluZGV4KyssXG4gICAgICBkZWxpbWl0ZXI6IHByZWZpeCB8fCAnLycsXG4gICAgICBvcHRpb25hbDogIG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiAgICByZXBlYXRcbiAgICB9KTtcblxuICAgIC8vIEVzY2FwZSB0aGUgcHJlZml4IGNoYXJhY3Rlci5cbiAgICBwcmVmaXggPSBwcmVmaXggPyAnXFxcXCcgKyBwcmVmaXggOiAnJztcblxuICAgIC8vIE1hdGNoIHVzaW5nIHRoZSBjdXN0b20gY2FwdHVyaW5nIGdyb3VwLCBvciBmYWxsYmFjayB0byBjYXB0dXJpbmdcbiAgICAvLyBldmVyeXRoaW5nIHVwIHRvIHRoZSBuZXh0IHNsYXNoIChvciBuZXh0IHBlcmlvZCBpZiB0aGUgcGFyYW0gd2FzXG4gICAgLy8gcHJlZml4ZWQgd2l0aCBhIHBlcmlvZCkuXG4gICAgY2FwdHVyZSA9IGVzY2FwZUdyb3VwKGNhcHR1cmUgfHwgZ3JvdXAgfHwgJ1teJyArIChwcmVmaXggfHwgJ1xcXFwvJykgKyAnXSs/Jyk7XG5cbiAgICAvLyBBbGxvdyBwYXJhbWV0ZXJzIHRvIGJlIHJlcGVhdGVkIG1vcmUgdGhhbiBvbmNlLlxuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgIGNhcHR1cmUgPSBjYXB0dXJlICsgJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBhIHBhcmFtZXRlciB0byBiZSBvcHRpb25hbC5cbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICB9XG5cbiAgICAvLyBCYXNpYyBwYXJhbWV0ZXIgc3VwcG9ydC5cbiAgICByZXR1cm4gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgfSk7XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcGF0aCBlbmRzIGluIGEgc2xhc2ggYXMgaXQgYWx0ZXJzIHNvbWUgbWF0Y2ggYmVoYXZpb3VyLlxuICB2YXIgZW5kc1dpdGhTbGFzaCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhbiBvcHRpb25hbCB0cmFpbGluZyBzbGFzaCBpbiB0aGUgbWF0Y2guIElmXG4gIC8vIHRoZSBwYXRoIHRvIG1hdGNoIGFscmVhZHkgZW5kZWQgd2l0aCBhIHNsYXNoLCB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmb3JcbiAgLy8gY29uc2lzdGVuY3kuIFRoZSBzbGFzaCBpcyBvbmx5IHZhbGlkIGF0IHRoZSB2ZXJ5IGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdFxuICAvLyBhbnl3aGVyZSBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudCBmb3Igbm9uLWVuZGluZyBtb2RlLCBvdGhlcndpc2VcbiAgLy8gXCIvdGVzdC9cIiB3aWxsIG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcGF0aCA9IChlbmRzV2l0aFNsYXNoID8gcGF0aC5zbGljZSgwLCAtMikgOiBwYXRoKSArICcoPzpcXFxcLyg/PSQpKT8nO1xuICB9XG5cbiAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHByb21wdCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoXG4gIC8vIGFzIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIGZvciB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICBpZiAoIWVuZCkge1xuICAgIHBhdGggKz0gc3RyaWN0ICYmIGVuZHNXaXRoU2xhc2ggPyAnJyA6ICcoPz1cXFxcL3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHBhdGggKyAoZW5kID8gJyQnIDogJycpLCBmbGFncyksIGtleXMpO1xufTtcblxufSx7fV19LHt9LFsxXSkoMSlcbn0pOyIsIi8qXG5cblx0cmFjdGl2ZS1ldmVudHMtdGFwXG5cdD09PT09PT09PT09PT09PT09PVxuXG5cdFZlcnNpb24gMC4xLjIuXG5cblx0T24gbW9iaWxlIGRldmljZXMsIHVzaW5nIGBvbi1jbGlja2AgaXNuJ3QgZ29vZCBlbm91Z2guIFRhcHBpbmcgdGhlXG5cdHRvdWNoc2NyZWVuIHdpbGwgZmlyZSBhIHNpbXVsYXRlZCBjbGljayBldmVudCwgYnV0IG9ubHkgYWZ0ZXIgYSAzMDBcblx0bWlsbGlzZWNvbmQgZGVsYXksIHdoaWNoIG1ha2VzIHlvdXIgYXBwIGZlZWwgc2x1Z2dpc2guIEl0IGFsc29cblx0Y2F1c2VzIHRoZSB0YXBwZWQgYXJlYSB0byBoaWdobGlnaHQsIHdoaWNoIGluIG1vc3QgY2FzZXMgbG9va3MgYVxuXHRiaXQgbWVzc3kuXG5cblx0SW5zdGVhZCwgdXNlIGBvbi10YXBgLiBXaGVuIHlvdSB0YXAgYW4gYXJlYSwgdGhlIHNpbXVsYXRlZCBjbGlja1xuXHRldmVudCB3aWxsIGJlIHByZXZlbnRlZCwgYW5kIHRoZSB1c2VyJ3MgYWN0aW9uIGlzIHJlc3BvbmRlZCB0b1xuXHRpbnN0YW50bHkuIFRoZSBgb24tdGFwYCBldmVudCBhbHNvIGRpZmZlcnMgZnJvbSBgb24tY2xpY2tgIGluIHRoYXRcblx0dGhlIGNsaWNrIGV2ZW50IHdpbGwgKGZyYW5rbHkgcmF0aGVyIGJpemFycmVseSkgZmlyZSBldmVuIGlmIHlvdVxuXHRob2xkIHRoZSBtb3VzZSBkb3duIG92ZXIgYSBzaW5nbGUgZWxlbWVudCBmb3Igc2V2ZXJhbCBzZWNvbmRzIGFuZFxuXHR3YWdnbGUgaXQgYWJvdXQuXG5cblx0UG9pbnRlciBldmVudHMgYXJlIGFsc28gc3VwcG9ydGVkLCBhcyBpcyBwcmVzc2luZyB0aGUgc3BhY2ViYXIgd2hlblxuXHR0aGUgcmVsZXZhbnQgZWxlbWVudCBpcyBmb2N1c2VkICh3aGljaCB0cmlnZ2VycyBhIGNsaWNrIGV2ZW50LCBhbmRcblx0aXMgZ29vZCBmb3IgYWNjZXNzaWJpbGl0eSkuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRUcm91Ymxlc2hvb3Rpbmc6IElmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBzeXN0ZW0gaW4geW91ciBhcHAgKEFNRCBvclxuXHRzb21ldGhpbmcgbW9yZSBub2RleSkgdGhlbiB5b3UgbWF5IG5lZWQgdG8gY2hhbmdlIHRoZSBwYXRocyBiZWxvdyxcblx0d2hlcmUgaXQgc2F5cyBgcmVxdWlyZSggJ3JhY3RpdmUnIClgIG9yIGBkZWZpbmUoWyAncmFjdGl2ZScgXS4uLilgLlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VXNhZ2U6IEluY2x1ZGUgdGhpcyBmaWxlIG9uIHlvdXIgcGFnZSBiZWxvdyBSYWN0aXZlLCBlLmc6XG5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS5qcyc+PC9zY3JpcHQ+XG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUtZXZlbnRzLXRhcC5qcyc+PC9zY3JpcHQ+XG5cblx0T3IsIGlmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBsb2FkZXIsIHJlcXVpcmUgdGhpcyBtb2R1bGU6XG5cblx0ICAgIC8vIHJlcXVpcmluZyB0aGUgcGx1Z2luIHdpbGwgJ2FjdGl2YXRlJyBpdCAtIG5vIG5lZWQgdG8gdXNlXG5cdCAgICAvLyB0aGUgcmV0dXJuIHZhbHVlXG5cdCAgICByZXF1aXJlKCAncmFjdGl2ZS1ldmVudHMtdGFwJyApO1xuXG5cdEFkZCBhIHRhcCBldmVudCBpbiB0aGUgbm9ybWFsIGZhc2hpb246XG5cblx0ICAgIDxkaXYgb24tdGFwPSdmb28nPnRhcCBtZSE8L2Rpdj5cblxuXHRUaGVuIGFkZCBhIGhhbmRsZXI6XG5cblx0ICAgIHJhY3RpdmUub24oICdmb28nLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHQgICAgICBhbGVydCggJ3RhcHBlZCcgKTtcblx0ICAgIH0pO1xuXG4qL1xuXG4oZnVuY3Rpb24gKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIENvbW1vbiBKUyAoaS5lLiBicm93c2VyaWZ5KSBlbnZpcm9ubWVudFxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdGZhY3RvcnkoIHJlcXVpcmUoIFwiLi8uLi9yYWN0aXZlL3JhY3RpdmUuanNcIiApICk7XG5cdH1cblxuXHQvLyBBTUQ/XG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKFsgJ3JhY3RpdmUnIF0sIGZhY3RvcnkgKTtcblx0fVxuXG5cdC8vIGJyb3dzZXIgZ2xvYmFsXG5cdGVsc2UgaWYgKCBnbG9iYWwuUmFjdGl2ZSApIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwuUmFjdGl2ZSApO1xuXHR9XG5cblx0ZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgUmFjdGl2ZSEgSXQgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIHRoZSByYWN0aXZlLWV2ZW50cy10YXAgcGx1Z2luJyApO1xuXHR9XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKCBSYWN0aXZlICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdGFwID0gZnVuY3Rpb24gKCBub2RlLCBmaXJlICkge1xuXHRcdHZhciBtb3VzZWRvd24sIHRvdWNoc3RhcnQsIGZvY3VzSGFuZGxlciwgZGlzdGFuY2VUaHJlc2hvbGQsIHRpbWVUaHJlc2hvbGQsIHByZXZlbnRNb3VzZWRvd25FdmVudHMsIHByZXZlbnRNb3VzZWRvd25UaW1lb3V0O1xuXG5cdFx0ZGlzdGFuY2VUaHJlc2hvbGQgPSA1OyAvLyBtYXhpbXVtIHBpeGVscyBwb2ludGVyIGNhbiBtb3ZlIGJlZm9yZSBjYW5jZWxcblx0XHR0aW1lVGhyZXNob2xkID0gNDAwOyAgIC8vIG1heGltdW0gbWlsbGlzZWNvbmRzIGJldHdlZW4gZG93biBhbmQgdXAgYmVmb3JlIGNhbmNlbFxuXG5cdFx0bW91c2Vkb3duID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciBjdXJyZW50VGFyZ2V0LCB4LCB5LCBwb2ludGVySWQsIHVwLCBtb3ZlLCBjYW5jZWw7XG5cblx0XHRcdGlmICggcHJldmVudE1vdXNlZG93bkV2ZW50cyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoICE9PSB1bmRlZmluZWQgJiYgZXZlbnQud2hpY2ggIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0eCA9IGV2ZW50LmNsaWVudFg7XG5cdFx0XHR5ID0gZXZlbnQuY2xpZW50WTtcblx0XHRcdGN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdFx0Ly8gVGhpcyB3aWxsIGJlIG51bGwgZm9yIG1vdXNlIGV2ZW50cy5cblx0XHRcdHBvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuXHRcdFx0dXAgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50LnBvaW50ZXJJZCAhPSBwb2ludGVySWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmlyZSh7XG5cdFx0XHRcdFx0bm9kZTogY3VycmVudFRhcmdldCxcblx0XHRcdFx0XHRvcmlnaW5hbDogZXZlbnRcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRtb3ZlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBldmVudC5wb2ludGVySWQgIT0gcG9pbnRlcklkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggKCBNYXRoLmFicyggZXZlbnQuY2xpZW50WCAtIHggKSA+PSBkaXN0YW5jZVRocmVzaG9sZCApIHx8ICggTWF0aC5hYnMoIGV2ZW50LmNsaWVudFkgLSB5ICkgPj0gZGlzdGFuY2VUaHJlc2hvbGQgKSApIHtcblx0XHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Y2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJVcCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyTW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJDYW5jZWwnLCBjYW5jZWwsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCApIHtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyVXAnLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlck1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyQ2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHR9XG5cblx0XHRcdHNldFRpbWVvdXQoIGNhbmNlbCwgdGltZVRocmVzaG9sZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVyZG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHR9IGVsc2UgaWYgKCB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJEb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0fVxuXG5cblx0XHR0b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciBjdXJyZW50VGFyZ2V0LCB4LCB5LCB0b3VjaCwgZmluZ2VyLCBtb3ZlLCB1cCwgY2FuY2VsO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcblxuXHRcdFx0eCA9IHRvdWNoLmNsaWVudFg7XG5cdFx0XHR5ID0gdG91Y2guY2xpZW50WTtcblx0XHRcdGN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXG5cdFx0XHRmaW5nZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHR1cCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0b3VjaDtcblxuXHRcdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXHRcdFx0XHRpZiAoIHRvdWNoLmlkZW50aWZpZXIgIT09IGZpbmdlciApIHtcblx0XHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7ICAvLyBwcmV2ZW50IGNvbXBhdGliaWxpdHkgbW91c2UgZXZlbnRcblxuXHRcdFx0XHQvLyBmb3IgdGhlIGJlbmVmaXQgb2YgbW9iaWxlIEZpcmVmb3ggYW5kIG9sZCBBbmRyb2lkIGJyb3dzZXJzLCB3ZSBuZWVkIHRoaXMgYWJzdXJkIGhhY2suXG5cdFx0XHRcdHByZXZlbnRNb3VzZWRvd25FdmVudHMgPSB0cnVlO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHByZXZlbnRNb3VzZWRvd25UaW1lb3V0ICk7XG5cblx0XHRcdFx0cHJldmVudE1vdXNlZG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cHJldmVudE1vdXNlZG93bkV2ZW50cyA9IGZhbHNlO1xuXHRcdFx0XHR9LCA0MDAgKTtcblxuXHRcdFx0XHRmaXJlKHtcblx0XHRcdFx0XHRub2RlOiBjdXJyZW50VGFyZ2V0LFxuXHRcdFx0XHRcdG9yaWdpbmFsOiBldmVudFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdH07XG5cblx0XHRcdG1vdmUgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdG91Y2g7XG5cblx0XHRcdFx0aWYgKCBldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMSB8fCBldmVudC50b3VjaGVzWzBdLmlkZW50aWZpZXIgIT09IGZpbmdlciApIHtcblx0XHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcblx0XHRcdFx0aWYgKCAoIE1hdGguYWJzKCB0b3VjaC5jbGllbnRYIC0geCApID49IGRpc3RhbmNlVGhyZXNob2xkICkgfHwgKCBNYXRoLmFicyggdG91Y2guY2xpZW50WSAtIHkgKSA+PSBkaXN0YW5jZVRocmVzaG9sZCApICkge1xuXHRcdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaGNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdH07XG5cblx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdXAsIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoY2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCBjYW5jZWwsIHRpbWVUaHJlc2hvbGQgKTtcblx0XHR9O1xuXG5cdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlICk7XG5cblxuXHRcdC8vIG5hdGl2ZSBidXR0b25zLCBhbmQgPGlucHV0IHR5cGU9J2J1dHRvbic+IGVsZW1lbnRzLCBzaG91bGQgZmlyZSBhIHRhcCBldmVudFxuXHRcdC8vIHdoZW4gdGhlIHNwYWNlIGtleSBpcyBwcmVzc2VkXG5cdFx0aWYgKCBub2RlLnRhZ05hbWUgPT09ICdCVVRUT04nIHx8IG5vZGUudHlwZSA9PT0gJ2J1dHRvbicgKSB7XG5cdFx0XHRmb2N1c0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBibHVySGFuZGxlciwga2V5ZG93bkhhbmRsZXI7XG5cblx0XHRcdFx0a2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQud2hpY2ggPT09IDMyICkgeyAvLyBzcGFjZSBrZXlcblx0XHRcdFx0XHRcdGZpcmUoe1xuXHRcdFx0XHRcdFx0XHRub2RlOiBub2RlLFxuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbDogZXZlbnRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRibHVySGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywga2V5ZG93bkhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnYmx1cicsIGJsdXJIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBrZXlkb3duSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsIGJsdXJIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fTtcblxuXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBmb2N1c0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0fVxuXG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcmRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlckRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2ZvY3VzJywgZm9jdXNIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cblx0UmFjdGl2ZS5ldmVudHMudGFwID0gdGFwO1xuXG59KSk7XG4iLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3JhY3RpdmUnLCAnaGFtbWVyanMnXSwgZmFjdG9yeSk7XG4gIH1cblxuICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkocmVxdWlyZShcIi4vLi4vcmFjdGl2ZS9yYWN0aXZlLmpzXCIpLCByZXF1aXJlKFwiLi8uLi9oYW1tZXJqcy9oYW1tZXIuanNcIikpO1xuICB9XG5cbiAgZWxzZSB7XG4gICAgZmFjdG9yeShyb290LlJhY3RpdmUsIHJvb3QuSGFtbWVyKTtcbiAgfVxuXG59KHRoaXMsIGZ1bmN0aW9uIChSYWN0aXZlLCBIYW1tZXIpIHtcblxuICAvLyBDaGVjayB0aGUgcmVjb2duaXplcnMgZG9jdW1lbnRhdGlvbi5cbiAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXRhcFxuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICB0YXA6IHtcbiAgICAgIHJlY29nbml6ZXJDbGFzczogSGFtbWVyLlRhcCxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdGltZTogNTAwXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgICd0YXAnIFxuICAgICAgXVxuICAgIH0sXG4gICAgZG91YmxldGFwOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5UYXAsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHRhcHM6IDIsXG4gICAgICAgIGV2ZW50OiAnZG91YmxldGFwJ1xuICAgICAgfSxcbiAgICAgIHJlY29nbml6ZVdpdGg6IFsndGFwJ10sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAgJ2RvdWJsZXRhcCcgXG4gICAgICBdXG4gICAgfSxcbiAgICBzd2lwZToge1xuICAgICAgcmVjb2duaXplckNsYXNzOiBIYW1tZXIuU3dpcGUsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAnc3dpcGUnLFxuICAgICAgICAnc3dpcGVsZWZ0JyxcbiAgICAgICAgJ3N3aXBlcmlnaHQnLFxuICAgICAgICAnc3dpcGV1cCcsXG4gICAgICAgICdzd2lwZWRvd24nIFxuICAgICAgXVxuICAgIH0sXG4gICAgcGFuOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5QYW4sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgICB9LFxuICAgICAgcmVjb2duaXplV2l0aDogWydzd2lwZSddLFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgICdwYW4nLFxuICAgICAgICAncGFuc3RhcnQnLFxuICAgICAgICAncGFubW92ZScsXG4gICAgICAgICdwYW5lbmQnLFxuICAgICAgICAncGFuY2FuY2VsJyxcbiAgICAgICAgJ3BhbmxlZnQnLFxuICAgICAgICAncGFucmlnaHQnLFxuICAgICAgICAncGFudXAnLFxuICAgICAgICAncGFuZG93bicgXG4gICAgICBdXG4gICAgfSxcbiAgICBwcmVzczoge1xuICAgICAgcmVjb2duaXplckNsYXNzOiBIYW1tZXIuUHJlc3MsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAncHJlc3MnIFxuICAgICAgXVxuICAgIH0sXG4gICAgcm90YXRlOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5Sb3RhdGUsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAncm90YXRlJyxcbiAgICAgICAgJ3JvdGF0ZXN0YXJ0JyxcbiAgICAgICAgJ3JvdGF0ZW1vdmUnLFxuICAgICAgICAncm90YXRlZW5kJyxcbiAgICAgICAgJ3JvdGF0ZWNhbmNlbCcgXG4gICAgICBdXG4gICAgfSxcbiAgICBwaW5jaDoge1xuICAgICAgcmVjb2duaXplckNsYXNzOiBIYW1tZXIuUGluY2gsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIHJlY29nbml6ZVdpdGg6IFsncm90YXRlJ10sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAgJ3BpbmNoJyxcbiAgICAgICAgJ3BpbmNoc3RhcnQnLFxuICAgICAgICAncGluY2htb3ZlJyxcbiAgICAgICAgJ3BpbmNoZW5kJyxcbiAgICAgICAgJ3BpbmNoY2FuY2VsJyxcbiAgICAgICAgJ3BpbmNoaW4nLFxuICAgICAgICAncGluY2hvdXQnIFxuICAgICAgXVxuICAgIH1cbiAgfTtcblxuICB2YXIgYWxpYXNlcztcblxuICAvLyBiaW5kIGFsbCBldmVudHMgdXNpbmcgYnVpbGRFdmVudFxuICBmb3IgKHZhciByZWNvZ25pemVyTmFtZSBpbiBkZWZhdWx0cykge1xuICAgIGlmICghZGVmYXVsdHMuaGFzT3duUHJvcGVydHkocmVjb2duaXplck5hbWUpKSBjb250aW51ZTtcbiAgICBcbiAgICB2YXIgZXZlbnRzID0gZGVmYXVsdHNbcmVjb2duaXplck5hbWVdLmV2ZW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYnVpbGRFdmVudChldmVudHNbaV0sIHJlY29nbml6ZXJOYW1lLCBkZWZhdWx0c1tyZWNvZ25pemVyTmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBidWlsZEV2ZW50IDogYnVpbGRFdmVudChldmVudCwgcmVjb2duaXplck5hbWUsIGNvbmZpZylcbiAgICogKHByaXZhdGUpIHJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciBidWlsZEV2ZW50LlxuICAgKlxuICAgKiAgICAgYnVpbGRFdmVudCgncGFuc3RhcnQnLCAncGFuJywgeyAuLi4gfSk7XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJ1aWxkRXZlbnQoZXZlbnROYW1lLCByZWNvZ25pemVyTmFtZSwgY29uZmlnKSB7XG4gICAgUmFjdGl2ZS5ldmVudHNbZXZlbnROYW1lXSA9IGJ1aWxkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgcmVjb2duaXplck5hbWUsIGNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogYnVpbGRFdmVudEhhbmRsZXIoKSA6IGJ1aWxkRXZlbnRIYW5kbGVyKGV2ZW50LCByZWNvZ25pemVyTmFtZSwgY29uZmlnKVxuICAgKiAocHJpdmF0ZSkgQ3JlYXRlcyB0aGUgZXZlbnQgaGFuZGxlciBmb3IgYSBnaXZlbiBgZXZlbnROYW1lYCB0aGF0IHdpbGwgYmVcbiAgICogcmVnaXN0ZXJlZCB0byBgUmFjdGl2ZS5ldmVudHNgLlxuICAgKi9cblxuICBmdW5jdGlvbiBidWlsZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIHJlY29nbml6ZXJOYW1lLCBjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGZpcmUpIHtcbiAgICAgIHZhciBoYW1tZXJNYW5hZ2VyID0gZ2V0SGFtbWVyTWFuYWdlcihub2RlKTtcblxuICAgICAgdmFyIHJlY29nbml6ZXJFeGlzdHMgPSAoaGFtbWVyTWFuYWdlci5nZXQocmVjb2duaXplck5hbWUpICE9PSBudWxsKTtcblxuICAgICAgaWYgKCFyZWNvZ25pemVyRXhpc3RzKSB7XG4gICAgICAgIC8vIGluaXQgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSBuZXcgY29uZmlnLnJlY29nbml6ZXJDbGFzcyhjb25maWcub3B0aW9ucyk7XG5cbiAgICAgICAgLy8gSGFtbWVyLlJlY29nbml6ZXIuc2V0IG1lcmdlcyBpdCBvbiB0b3Agb2YgdGhlIGRlZmF1bHRzIHN1cHBsaWVkIGFib3ZlXG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VPcHRpb25zKG5vZGUsIHJlY29nbml6ZXJOYW1lKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpXG4gICAgICAgICAgcmVjb2duaXplci5zZXQob3B0aW9ucyk7XG5cbiAgICAgICAgaGFtbWVyTWFuYWdlci5hZGQocmVjb2duaXplcik7XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVSZWNvZ25pemVXaXRoKGhhbW1lck1hbmFnZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWdpc3RlciB0aGUgaGFuZGxlclxuICAgICAgaGFtbWVyTWFuYWdlci5vbihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZpcmUoe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb3JpZ2luYWw6IGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gaGFuZGxlIGV4aXRzXG4gICAgICBmdW5jdGlvbiB0ZWFyZG93bigpIHtcbiAgICAgICAgZ2V0SGFtbWVyTWFuYWdlcihub2RlKS5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSBub2RlLl9oYW1tZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHRlYXJkb3duOiB0ZWFyZG93biB9O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlUmVjb2duaXplV2l0aCA6IHVwZGF0ZVJlY29nbml6ZVdpdGgoaGFtbWVyTWFuYWdlcilcbiAgICogKHByaXZhdGUpIFNldHMgcmVjb2duaXplV2l0aCBpZiBkZWZhdWx0cyBoYXZlIGl0XG4gICAqXG4gICAqIFNpbmNlIHdlIGFkZCByZWNvZ25pemVycyBkeW5hbWljYWxseSBhbmQgd2l0aG91dCBhbnkgc3RyaWN0IG9yZGVyLFxuICAgKiAgd2UgbmVlZCB0byBndWFyZCBhZ2FpbnN0IHRyeWluZyB0byBzZXQgYSByZXF1aXJlV2l0aCBmb3IgYSByZWNvZ25pemVyXG4gICAqICB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldC5cbiAgICogXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVSZWNvZ25pemVXaXRoKGhhbW1lck1hbmFnZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbW1lck1hbmFnZXIucmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZWNvZ25pemVyID0gaGFtbWVyTWFuYWdlci5yZWNvZ25pemVyc1tpXTtcbiAgICAgIHZhciByZWNvZ25pemVyTmFtZSA9IHJlY29nbml6ZXIub3B0aW9ucy5ldmVudDtcblxuICAgICAgaWYgKCFkZWZhdWx0c1tyZWNvZ25pemVyTmFtZV0uaGFzT3duUHJvcGVydHkoJ3JlY29nbml6ZVdpdGgnKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIHZhciByZWNvZ25pemVXaXRocyA9IGRlZmF1bHRzW3JlY29nbml6ZXJOYW1lXS5yZWNvZ25pemVXaXRoO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByZWNvZ25pemVXaXRocy5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgcmVjZ29uaXplciB3ZSdyZSB0cnlpbmcgdG8gZGVwZW5kIG9uIGlzIHJlYWxseSB0aGVyZVxuICAgICAgICBpZiAoIWhhbW1lck1hbmFnZXIuZ2V0KHJlY29nbml6ZVdpdGhzW2tdKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gSXQncyBzYWZlIHRvIHJlY29nbml6ZVdpdGggbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJlY29nbml6ZXJcbiAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKHJlY29nbml6ZVdpdGhzW2tdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcGFyc2VPcHRpb25zIDogcGFyc2VPcHRpb25zKG5vZGUsIGtleSlcbiAgICogKHByaXZhdGUpIFJldHVybnMgb3B0aW9ucyBmb3IgYSBnaXZlbiBET00gbm9kZS5cbiAgICpcbiAgICogICAgIG5vZGUgPSA8ZGl2IGRhdGEtc3dpcGUtZGlyZWN0aW9uPSdsZWZ0JyBkYXRhLXN3aXBlLXRocmVzaG9sZD0nMic+XG4gICAqXG4gICAqICAgICBwYXJzZU9wdGlvbnMobm9kZSwgJ3N3aXBlJylcbiAgICogICAgID0+IHsgZGlyZWN0aW9uOiAnbGVmdCcsIHRocmVzaG9sZDogMiB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhub2RlLCBrZXkpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKFwiXig/OmRhdGEtKT9cIitrZXkrXCItKC4qKSRcIik7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldLFxuICAgICAgICAgIG0gPSBhdHRyLm5hbWUubWF0Y2gocmUpO1xuXG4gICAgICBpZiAoIW0pIGNvbnRpbnVlO1xuICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgb3V0cHV0W21bMV1dID0gcGFyc2VIYW1tZXJWYWx1ZShhdHRyLnZhbHVlLCBtWzFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlSGFtbWVyVmFsdWUgOiBwYXJzZUhhbW1lclZhbHVlKHN0ciwga2V5KVxuICAgKiAocHJpdmF0ZSkgVmFsdWUtaXplcyBhIGdpdmVuIHN0cmluZyBgc3RyYCwgY29udmVydGluZyBpdCB0byBhIG51bWJlciBhc1xuICAgKiBuZWVkZWQuIElmIGBrZXlgIGlzIGdpdmVuLCBpdCBjYW4gYWxzbyByZXNvbHZlIGFsaWFzZXMgZm9yIHRoYXQgZ2l2ZW5cbiAgICoga2V5LlxuICAgKlxuICAgKiBVc2VkIGJ5IGBnZXREYXRhKClgLiBcbiAgICpcbiAgICogICAgIHBhcnNlSGFtbWVyVmFsdWUoXCIxMDBcIikgICA9PiAxMDBcbiAgICogICAgIHBhcnNlSGFtbWVyVmFsdWUoXCJyaWdodFwiKSA9PiBcInJpZ2h0XCJcbiAgICogICAgIHBhcnNlSGFtbWVyVmFsdWUoXCJyaWdodFwiLCBcImRpcmVjdGlvblwiKSA9PiBIYW1tZXIuRElSRUNUSU9OX1JJR0hUXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGFtbWVyVmFsdWUoc3RyLCBrZXkpIHtcbiAgICBpZiAoc3RyLm1hdGNoICYmIHN0ci5tYXRjaCgvXi0/XFxkKyg/OlxcLlxcZCspPyQvKSkgcmV0dXJuICtzdHI7XG4gICAgcmV0dXJuIChhbGlhc2VzW2tleV0gJiYgYWxpYXNlc1trZXldW3N0cl0pIHx8XG4gICAgICBhbGlhc2VzLmFsbFtzdHJdIHx8IHN0cjtcbiAgfVxuXG4gIC8qXG4gICAqIEFsaWFzZXMgZm9yIGB2YWwoKWAuXG4gICAqL1xuXG4gIGFsaWFzZXMgPSB7XG4gICAgYWxsOiB7XG4gICAgICAndHJ1ZSc6IHRydWUsXG4gICAgICAnZmFsc2UnOiBmYWxzZSxcbiAgICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWQsXG4gICAgICAnbnVsbCc6IG51bGxcbiAgICB9LFxuICAgIGRpcmVjdGlvbjoge1xuICAgICAgJ25vbmUnOiBIYW1tZXIuRElSRUNUSU9OX05PTkUsXG4gICAgICAnYWxsJzogSGFtbWVyLkRJUkVDVElPTl9BTEwsXG4gICAgICAndXAnOiBIYW1tZXIuRElSRUNUSU9OX1VQLFxuICAgICAgJ2Rvd24nOiBIYW1tZXIuRElSRUNUSU9OX0RPV04sXG4gICAgICAnbGVmdCc6IEhhbW1lci5ESVJFQ1RJT05fTEVGVCxcbiAgICAgICdyaWdodCc6IEhhbW1lci5ESVJFQ1RJT05fUklHSFQsXG4gICAgICAnaG9yaXpvbnRhbCc6IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICAgICd2ZXJ0aWNhbCc6IEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUxcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGdldEhhbW1lck1hbmFnZXIgOiBnZXRIYW1tZXJNYW5hZ2VyKG5vZGUpXG4gICAqIChwcml2YXRlKSBSZXR1cm5zIHRoZSBgSGFtbWVyTWFuYWdlcmAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBub2RlLlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRIYW1tZXJNYW5hZ2VyKG5vZGUpIHtcbiAgICBpZiAobm9kZS5faGFtbWVyKSByZXR1cm4gbm9kZS5faGFtbWVyO1xuXG4gICAgbm9kZS5faGFtbWVyID0gbmV3IEhhbW1lci5NYW5hZ2VyKG5vZGUsIHtyZWNvZ25pemVyczogW119KTtcbiAgICByZXR1cm4gbm9kZS5faGFtbWVyO1xuICB9XG5cblxuICByZXR1cm4ge2RlZmF1bHRzOiBkZWZhdWx0c307XG5cbn0pKTtcbiIsIi8qXG5cblx0cmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlXG5cdD09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFZlcnNpb24gMC4xLjIuXG5cblx0VGhpcyBwbHVnaW4gZG9lcyBleGFjdGx5IHdoYXQgaXQgc2F5cyBvbiB0aGUgdGluIC0gaXQgZmFkZXMgZWxlbWVudHNcblx0aW4gYW5kIG91dCwgdXNpbmcgQ1NTIHRyYW5zaXRpb25zLiBZb3UgY2FuIGNvbnRyb2wgdGhlIGZvbGxvd2luZ1xuXHRwcm9wZXJ0aWVzOiBgZHVyYXRpb25gLCBgZGVsYXlgIGFuZCBgZWFzaW5nYCAod2hpY2ggbXVzdCBiZSBhIHZhbGlkXG5cdENTUyB0cmFuc2l0aW9uIHRpbWluZyBmdW5jdGlvbiwgYW5kIGRlZmF1bHRzIHRvIGBsaW5lYXJgKS5cblxuXHRUaGUgYGR1cmF0aW9uYCBwcm9wZXJ0eSBpcyBpbiBtaWxsaXNlY29uZHMsIGFuZCBkZWZhdWx0cyB0byAzMDAgKHlvdVxuXHRjYW4gYWxzbyB1c2UgYGZhc3RgIG9yIGBzbG93YCBpbnN0ZWFkIG9mIGEgbWlsbGlzZWNvbmQgdmFsdWUsIHdoaWNoXG5cdGVxdWF0ZSB0byAyMDAgYW5kIDYwMCByZXNwZWN0aXZlbHkpLiBBcyBhIHNob3J0aGFuZCwgeW91IGNhbiB1c2Vcblx0YGludHJvPSdmYWRlOjUwMCdgIGluc3RlYWQgb2YgYGludHJvPSdmYWRlOntcImR1cmF0aW9uXCI6NTAwfSdgIC0gdGhpc1xuXHRhcHBsaWVzIHRvIG1hbnkgb3RoZXIgdHJhbnNpdGlvbiBwbHVnaW5zIGFzIHdlbGwuXG5cblx0SWYgYW4gZWxlbWVudCBoYXMgYW4gb3BhY2l0eSBvdGhlciB0aGFuIDEgKHdoZXRoZXIgZGlyZWN0bHksIGJlY2F1c2Vcblx0b2YgYW4gaW5saW5lIHN0eWxlLCBvciBpbmRpcmVjdGx5IGJlY2F1c2Ugb2YgYSBDU1MgcnVsZSksIGl0IHdpbGwgYmVcblx0cmVzcGVjdGVkLiBZb3UgY2FuIG92ZXJyaWRlIHRoZSB0YXJnZXQgb3BhY2l0eSBvZiBhbiBpbnRybyBmYWRlIGJ5XG5cdHNwZWNpZnlpbmcgYSBgdG9gIHByb3BlcnR5IGJldHdlZW4gMCBhbmQgMS5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFRyb3VibGVzaG9vdGluZzogSWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIHN5c3RlbSBpbiB5b3VyIGFwcCAoQU1EIG9yXG5cdHNvbWV0aGluZyBtb3JlIG5vZGV5KSB0aGVuIHlvdSBtYXkgbmVlZCB0byBjaGFuZ2UgdGhlIHBhdGhzIGJlbG93LFxuXHR3aGVyZSBpdCBzYXlzIGByZXF1aXJlKCAnUmFjdGl2ZScgKWAgb3IgYGRlZmluZShbICdSYWN0aXZlJyBdLi4uKWAuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRVc2FnZTogSW5jbHVkZSB0aGlzIGZpbGUgb24geW91ciBwYWdlIGJlbG93IFJhY3RpdmUsIGUuZzpcblxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLmpzJz48L3NjcmlwdD5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlLmpzJz48L3NjcmlwdD5cblxuXHRPciwgaWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIGxvYWRlciwgcmVxdWlyZSB0aGlzIG1vZHVsZTpcblxuXHQgICAgLy8gcmVxdWlyaW5nIHRoZSBwbHVnaW4gd2lsbCAnYWN0aXZhdGUnIGl0IC0gbm8gbmVlZCB0byB1c2Vcblx0ICAgIC8vIHRoZSByZXR1cm4gdmFsdWVcblx0ICAgIHJlcXVpcmUoICdyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUnICk7XG5cblx0QWRkIGEgZmFkZSB0cmFuc2l0aW9uIGxpa2Ugc286XG5cblx0ICAgIDxkaXYgaW50cm89J2ZhZGUnPnRoaXMgd2lsbCBmYWRlIGluPC9kaXY+XG5cbiovXG5cbihmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gQ29tbW9uIEpTIChpLmUuIGJyb3dzZXJpZnkpIGVudmlyb25tZW50XG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0ZmFjdG9yeSggcmVxdWlyZSggXCIuLy4uL3JhY3RpdmUvcmFjdGl2ZS5qc1wiICkgKTtcblx0fVxuXG5cdC8vIEFNRD9cblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoWyAncmFjdGl2ZScgXSwgZmFjdG9yeSApO1xuXHR9XG5cblx0Ly8gYnJvd3NlciBnbG9iYWxcblx0ZWxzZSBpZiAoIGdsb2JhbC5SYWN0aXZlICkge1xuXHRcdGZhY3RvcnkoIGdsb2JhbC5SYWN0aXZlICk7XG5cdH1cblxuXHRlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBSYWN0aXZlISBJdCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhlIHJhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZSBwbHVnaW4nICk7XG5cdH1cblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJhY3RpdmUgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBmYWRlLCBkZWZhdWx0cztcblxuXHRkZWZhdWx0cyA9IHtcblx0XHRkZWxheTogMCxcblx0XHRkdXJhdGlvbjogMzAwLFxuXHRcdGVhc2luZzogJ2xpbmVhcidcblx0fTtcblxuXHRmYWRlID0gZnVuY3Rpb24gKCB0LCBwYXJhbXMgKSB7XG5cdFx0dmFyIHRhcmdldE9wYWNpdHk7XG5cblx0XHRwYXJhbXMgPSB0LnByb2Nlc3NQYXJhbXMoIHBhcmFtcywgZGVmYXVsdHMgKTtcblxuXHRcdGlmICggdC5pc0ludHJvICkge1xuXHRcdFx0dGFyZ2V0T3BhY2l0eSA9IHQuZ2V0U3R5bGUoICdvcGFjaXR5JyApO1xuXHRcdFx0dC5zZXRTdHlsZSggJ29wYWNpdHknLCAwICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldE9wYWNpdHkgPSAwO1xuXHRcdH1cblxuXHRcdHQuYW5pbWF0ZVN0eWxlKCAnb3BhY2l0eScsIHRhcmdldE9wYWNpdHksIHBhcmFtcyApLnRoZW4oIHQuY29tcGxldGUgKTtcblx0fTtcblxuXHRSYWN0aXZlLnRyYW5zaXRpb25zLmZhZGUgPSBmYWRlO1xuXG59KSk7XG4iLCIvKlxuXG5cdHJhY3RpdmUtdHJhbnNpdGlvbnMtZmx5XG5cdD09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VmVyc2lvbiAwLjEuMy5cblxuXHRUaGlzIHRyYW5zaXRpb24gdXNlcyBDU1MgdHJhbnNmb3JtcyB0byAnZmx5JyBlbGVtZW50cyB0byB0aGVpclxuXHRuYXR1cmFsIGxvY2F0aW9uIG9uIHRoZSBwYWdlLCBmYWRpbmcgaW4gZnJvbSB0cmFuc3BhcmVudCBhcyB0aGV5IGdvLlxuXHRCeSBkZWZhdWx0LCB0aGV5IHdpbGwgZmx5IGluIGZyb20gbGVmdC5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFRyb3VibGVzaG9vdGluZzogSWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIHN5c3RlbSBpbiB5b3VyIGFwcCAoQU1EIG9yXG5cdHNvbWV0aGluZyBtb3JlIG5vZGV5KSB0aGVuIHlvdSBtYXkgbmVlZCB0byBjaGFuZ2UgdGhlIHBhdGhzIGJlbG93LFxuXHR3aGVyZSBpdCBzYXlzIGByZXF1aXJlKCAncmFjdGl2ZScgKWAgb3IgYGRlZmluZShbICdyYWN0aXZlJyBdLi4uKWAuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRVc2FnZTogSW5jbHVkZSB0aGlzIGZpbGUgb24geW91ciBwYWdlIGJlbG93IFJhY3RpdmUsIGUuZzpcblxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLmpzJz48L3NjcmlwdD5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS10cmFuc2l0aW9ucy1mbHkuanMnPjwvc2NyaXB0PlxuXG5cdE9yLCBpZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgbG9hZGVyLCByZXF1aXJlIHRoaXMgbW9kdWxlOlxuXG5cdCAgICAvLyByZXF1aXJpbmcgdGhlIHBsdWdpbiB3aWxsICdhY3RpdmF0ZScgaXQgLSBubyBuZWVkIHRvIHVzZVxuXHQgICAgLy8gdGhlIHJldHVybiB2YWx1ZVxuXHQgICAgcmVxdWlyZSggJ3JhY3RpdmUtdHJhbnNpdGlvbnMtZmx5JyApO1xuXG5cdFlvdSBjYW4gYWRqdXN0IHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogYHhgLCBgeWAsIGBkdXJhdGlvbmAsXG5cdGBkZWxheWAgYW5kIGBlYXNpbmdgLlxuXG4qL1xuXG4oZnVuY3Rpb24gKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIENvbW1vbiBKUyAoaS5lLiBicm93c2VyaWZ5KSBlbnZpcm9ubWVudFxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdGZhY3RvcnkoIHJlcXVpcmUoIFwiLi8uLi9yYWN0aXZlL3JhY3RpdmUuanNcIiApICk7XG5cdH1cblxuXHQvLyBBTUQ/XG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKFsgJ3JhY3RpdmUnIF0sIGZhY3RvcnkgKTtcblx0fVxuXG5cdC8vIGJyb3dzZXIgZ2xvYmFsXG5cdGVsc2UgaWYgKCBnbG9iYWwuUmFjdGl2ZSApIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwuUmFjdGl2ZSApO1xuXHR9XG5cblx0ZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgUmFjdGl2ZSEgSXQgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIHRoZSByYWN0aXZlLXRyYW5zaXRpb25zLWZseSBwbHVnaW4nICk7XG5cdH1cblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJhY3RpdmUgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBmbHksIGFkZFB4LCBkZWZhdWx0cztcblxuXHRkZWZhdWx0cyA9IHtcblx0XHRkdXJhdGlvbjogODAwLFxuXHRcdGVhc2luZzogJ2N1YmljLWJlemllcigwLjc3MCwgMC4wMDAsIDAuMTc1LCAxLjAwMCknLFxuXHRcdHg6IC01MDAsXG5cdFx0eTogMFxuXHR9O1xuXG5cdGFkZFB4ID0gZnVuY3Rpb24gKCBudW0gKSB7XG5cdFx0aWYgKCBudW0gPT09IDAgfHwgdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRyZXR1cm4gbnVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBudW0gKyAncHgnO1xuXHR9O1xuXG5cdGZseSA9IGZ1bmN0aW9uICggdCwgcGFyYW1zICkge1xuXHRcdHZhciB4LCB5LCBvZmZzY3JlZW4sIHRhcmdldDtcblxuXHRcdHBhcmFtcyA9IHQucHJvY2Vzc1BhcmFtcyggcGFyYW1zLCBkZWZhdWx0cyApO1xuXG5cdFx0eCA9IGFkZFB4KCBwYXJhbXMueCApO1xuXHRcdHkgPSBhZGRQeCggcGFyYW1zLnkgKTtcblxuXHRcdG9mZnNjcmVlbiA9IHtcblx0XHRcdHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKSdcblx0XHR9O1xuXG5cdFx0aWYgKCB0LmlzSW50cm8gKSB7XG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSBjdXJyZW50IHN0eWxlXG5cdFx0XHR0YXJnZXQgPSB0LmdldFN0eWxlKFsgJ3RyYW5zZm9ybScgXSk7XG5cblx0XHRcdC8vIHNldCBvZmZzY3JlZW4gc3R5bGVcblx0XHRcdHQuc2V0U3R5bGUoIG9mZnNjcmVlbiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQgPSBvZmZzY3JlZW47XG5cdFx0fVxuXG5cdFx0dC5hbmltYXRlU3R5bGUoIHRhcmdldCwgcGFyYW1zICkudGhlbiggdC5jb21wbGV0ZSApO1xuXHR9O1xuXG5cdFJhY3RpdmUudHJhbnNpdGlvbnMuZmx5ID0gZmx5O1xuXG59KSk7XG4iLCIvKlxuXG5cdHJhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGVcblx0PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFZlcnNpb24gMC4xLjIuXG5cblx0VGhpcyB0cmFuc2l0aW9uIHNsaWRlcyBhbiBlbGVtZW50IGluIGFuZCBvdXQgb2Ygdmlldyxcblx0dXNpbmcgQ1NTIHRyYW5zaXRpb25zIHdoZXJlIHBvc3NpYmxlLlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VHJvdWJsZXNob290aW5nOiBJZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgc3lzdGVtIGluIHlvdXIgYXBwIChBTUQgb3Jcblx0c29tZXRoaW5nIG1vcmUgbm9kZXkpIHRoZW4geW91IG1heSBuZWVkIHRvIGNoYW5nZSB0aGUgcGF0aHMgYmVsb3csXG5cdHdoZXJlIGl0IHNheXMgYHJlcXVpcmUoICdyYWN0aXZlJyApYCBvciBgZGVmaW5lKFsgJ3JhY3RpdmUnIF0uLi4pYC5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFVzYWdlOiBJbmNsdWRlIHRoaXMgZmlsZSBvbiB5b3VyIHBhZ2UgYmVsb3cgUmFjdGl2ZSwgZS5nOlxuXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUuanMnPjwvc2NyaXB0PlxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLXRyYW5zaXRpb25zLXNsaWRlLmpzJz48L3NjcmlwdD5cblxuXHRPciwgaWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIGxvYWRlciwgcmVxdWlyZSB0aGlzIG1vZHVsZTpcblxuXHQgICAgLy8gcmVxdWlyaW5nIHRoZSBwbHVnaW4gd2lsbCAnYWN0aXZhdGUnIGl0IC0gbm8gbmVlZCB0byB1c2Vcblx0ICAgIC8vIHRoZSByZXR1cm4gdmFsdWVcblx0ICAgIHJlcXVpcmUoICdyYWN0aXZlLXRyYW5zaXRpb25zLXNsaWRlJyApO1xuXG5cdFlvdSBjYW4gc3BlY2lmeSB0aGUgYGRlbGF5YCwgYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllc1xuXHR1c2luZyB0aGUgY29udmVudGlvbmFsIHN5bnRheDpcblxuXHQgICAgPGRpdiBpbnRybz0nc2xpZGU6e1wiZGVsYXlcIjo1MDAsXCJlYXNpbmdcIjpcImVhc2Utb3V0XCJ9Jz5jb250ZW50PC9kaXY+XG5cblx0Qm90aCBgZGVsYXlgIGFuZCBgZHVyYXRpb25gIGFyZSBpbiBtaWxsaXNlY29uZHMuIFRoZSBgZWFzaW5nYCB2YWx1ZVxuXHRtdXN0IGJlIGEgdmFsaWQgQ1NTIGVhc2luZyBmdW5jdGlvbiAoc2VlIGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLykuXG5cbiovXG5cbihmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gQ29tbW9uIEpTIChpLmUuIGJyb3dzZXJpZnkpIGVudmlyb25tZW50XG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0ZmFjdG9yeSggcmVxdWlyZSggXCIuLy4uL3JhY3RpdmUvcmFjdGl2ZS5qc1wiICkgKTtcblx0fVxuXG5cdC8vIEFNRD9cblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoWyAncmFjdGl2ZScgXSwgZmFjdG9yeSApO1xuXHR9XG5cblx0Ly8gYnJvd3NlciBnbG9iYWxcblx0ZWxzZSBpZiAoIGdsb2JhbC5SYWN0aXZlICkge1xuXHRcdGZhY3RvcnkoIGdsb2JhbC5SYWN0aXZlICk7XG5cdH1cblxuXHRlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBSYWN0aXZlISBJdCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhlIHJhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGUgcGx1Z2luJyApO1xuXHR9XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKCBSYWN0aXZlICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgc2xpZGUsIHByb3BzLCBjb2xsYXBzZWQsIGRlZmF1bHRzO1xuXG5cdGRlZmF1bHRzID0ge1xuXHRcdGR1cmF0aW9uOiAzMDAsXG5cdFx0ZWFzaW5nOiAnZWFzZUluT3V0J1xuXHR9O1xuXG5cdHByb3BzID0gW1xuXHRcdCdoZWlnaHQnLFxuXHRcdCdib3JkZXJUb3BXaWR0aCcsXG5cdFx0J2JvcmRlckJvdHRvbVdpZHRoJyxcblx0XHQncGFkZGluZ1RvcCcsXG5cdFx0J3BhZGRpbmdCb3R0b20nLFxuXHRcdCdtYXJnaW5Ub3AnLFxuXHRcdCdtYXJnaW5Cb3R0b20nXG5cdF07XG5cblx0Y29sbGFwc2VkID0ge1xuXHRcdGhlaWdodDogMCxcblx0XHRib3JkZXJUb3BXaWR0aDogMCxcblx0XHRib3JkZXJCb3R0b21XaWR0aDogMCxcblx0XHRwYWRkaW5nVG9wOiAwLFxuXHRcdHBhZGRpbmdCb3R0b206IDAsXG5cdFx0bWFyZ2luVG9wOiAwLFxuXHRcdG1hcmdpbkJvdHRvbTogMFxuXHR9O1xuXG5cdHNsaWRlID0gZnVuY3Rpb24gKCB0LCBwYXJhbXMgKSB7XG5cdFx0dmFyIHRhcmdldFN0eWxlO1xuXG5cdFx0cGFyYW1zID0gdC5wcm9jZXNzUGFyYW1zKCBwYXJhbXMsIGRlZmF1bHRzICk7XG5cblx0XHRpZiAoIHQuaXNJbnRybyApIHtcblx0XHRcdHRhcmdldFN0eWxlID0gdC5nZXRTdHlsZSggcHJvcHMgKTtcblx0XHRcdHQuc2V0U3R5bGUoIGNvbGxhcHNlZCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBtYWtlIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSdyZSBub3QgdHJhbnNpdGlvbmluZyB0byAnYXV0bydcblx0XHRcdHQuc2V0U3R5bGUoIHQuZ2V0U3R5bGUoIHByb3BzICkgKTtcblx0XHRcdHRhcmdldFN0eWxlID0gY29sbGFwc2VkO1xuXHRcdH1cblxuXHRcdHQuc2V0U3R5bGUoICdvdmVyZmxvd1knLCAnaGlkZGVuJyApO1xuXG5cdFx0dC5hbmltYXRlU3R5bGUoIHRhcmdldFN0eWxlLCBwYXJhbXMgKS50aGVuKCB0LmNvbXBsZXRlICk7XG5cdH07XG5cblx0UmFjdGl2ZS50cmFuc2l0aW9ucy5zbGlkZSA9IHNsaWRlO1xuXG59KSk7XG4iLCIvKlxuXHRyYWN0aXZlLmpzIHYwLjYuMVxuXHQyMDE0LTEwLTI1IC0gY29tbWl0IDNhNTc2ZWIzIFxuXG5cdGh0dHA6Ly9yYWN0aXZlanMub3JnXG5cdGh0dHA6Ly90d2l0dGVyLmNvbS9SYWN0aXZlSlNcblxuXHRSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuXG4oIGZ1bmN0aW9uKCBnbG9iYWwgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBub0NvbmZsaWN0ID0gZ2xvYmFsLlJhY3RpdmU7XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL29wdGlvbnMuanMgKi9cblx0dmFyIG9wdGlvbnMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRcdC8vIHJlbmRlciBwbGFjZW1lbnQ6XG5cdFx0XHRlbDogdm9pZCAwLFxuXHRcdFx0YXBwZW5kOiBmYWxzZSxcblx0XHRcdC8vIHRlbXBsYXRlOlxuXHRcdFx0dGVtcGxhdGU6IHtcblx0XHRcdFx0djogMSxcblx0XHRcdFx0dDogW11cblx0XHRcdH0sXG5cdFx0XHR5aWVsZDogbnVsbCxcblx0XHRcdC8vIHBhcnNlOlxuXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlOiBmYWxzZSxcblx0XHRcdHNhbml0aXplOiBmYWxzZSxcblx0XHRcdHN0cmlwQ29tbWVudHM6IHRydWUsXG5cdFx0XHQvLyBkYXRhICYgYmluZGluZzpcblx0XHRcdGRhdGE6IHt9LFxuXHRcdFx0Y29tcHV0ZWQ6IHt9LFxuXHRcdFx0bWFnaWM6IGZhbHNlLFxuXHRcdFx0bW9kaWZ5QXJyYXlzOiB0cnVlLFxuXHRcdFx0YWRhcHQ6IFtdLFxuXHRcdFx0aXNvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0dHdvd2F5OiB0cnVlLFxuXHRcdFx0bGF6eTogZmFsc2UsXG5cdFx0XHQvLyB0cmFuc2l0aW9uczpcblx0XHRcdG5vSW50cm86IGZhbHNlLFxuXHRcdFx0dHJhbnNpdGlvbnNFbmFibGVkOiB0cnVlLFxuXHRcdFx0Y29tcGxldGU6IHZvaWQgMCxcblx0XHRcdC8vIGNzczpcblx0XHRcdG5vQ3NzVHJhbnNmb3JtOiBmYWxzZSxcblx0XHRcdC8vIGRlYnVnOlxuXHRcdFx0ZGVidWc6IGZhbHNlXG5cdFx0fTtcblx0XHRyZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG5cdH0oKTtcblxuXHQvKiBjb25maWcvZGVmYXVsdHMvZWFzaW5nLmpzICovXG5cdHZhciBlYXNpbmcgPSB7XG5cdFx0bGluZWFyOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0cmV0dXJuIHBvcztcblx0XHR9LFxuXHRcdGVhc2VJbjogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyggcG9zLCAzICk7XG5cdFx0fSxcblx0XHRlYXNlT3V0OiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0cmV0dXJuIE1hdGgucG93KCBwb3MgLSAxLCAzICkgKyAxO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0OiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0aWYgKCAoIHBvcyAvPSAwLjUgKSA8IDEgKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdyggcG9zLCAzICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKCBNYXRoLnBvdyggcG9zIC0gMiwgMyApICsgMiApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBjaXJjdWxhci5qcyAqL1xuXHR2YXIgY2lyY3VsYXIgPSBbXTtcblxuXHQvKiB1dGlscy9oYXNPd25Qcm9wZXJ0eS5qcyAqL1xuXHR2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKiB1dGlscy9pc0FycmF5LmpzICovXG5cdHZhciBpc0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcdC8vIHRoYW5rcywgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaW5zdGFuY2VvZi1jb25zaWRlcmVkLWhhcm1mdWwtb3ItaG93LXRvLXdyaXRlLWEtcm9idXN0LWlzYXJyYXkvXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdHJldHVybiB0b1N0cmluZy5jYWxsKCB0aGluZyApID09PSAnW29iamVjdCBBcnJheV0nO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB1dGlscy9pc09iamVjdC5qcyAqL1xuXHR2YXIgaXNPYmplY3QgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdHJldHVybiB0aGluZyAmJiB0b1N0cmluZy5jYWxsKCB0aGluZyApID09PSAnW29iamVjdCBPYmplY3RdJztcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvaXNOdW1lcmljLmpzICovXG5cdHZhciBpc051bWVyaWMgPSBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdCggdGhpbmcgKSApICYmIGlzRmluaXRlKCB0aGluZyApO1xuXHR9O1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9pbnRlcnBvbGF0b3JzLmpzICovXG5cdHZhciBpbnRlcnBvbGF0b3JzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBoYXNPd25Qcm9wZXJ0eSwgaXNBcnJheSwgaXNPYmplY3QsIGlzTnVtZXJpYyApIHtcblxuXHRcdHZhciBpbnRlcnBvbGF0b3JzLCBpbnRlcnBvbGF0ZSwgY3NzTGVuZ3RoUGF0dGVybjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGludGVycG9sYXRlID0gY2lyY3VsYXIuaW50ZXJwb2xhdGU7XG5cdFx0fSApO1xuXHRcdGNzc0xlbmd0aFBhdHRlcm4gPSAvXihbKy1dP1swLTldK1xcLj8oPzpbMC05XSspPykocHh8ZW18ZXh8JXxpbnxjbXxtbXxwdHxwYykkLztcblx0XHRpbnRlcnBvbGF0b3JzID0ge1xuXHRcdFx0bnVtYmVyOiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBkZWx0YTtcblx0XHRcdFx0aWYgKCAhaXNOdW1lcmljKCBmcm9tICkgfHwgIWlzTnVtZXJpYyggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcm9tID0gK2Zyb207XG5cdFx0XHRcdHRvID0gK3RvO1xuXHRcdFx0XHRkZWx0YSA9IHRvIC0gZnJvbTtcblx0XHRcdFx0aWYgKCAhZGVsdGEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb207XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZyb20gKyB0ICogZGVsdGE7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0YXJyYXk6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIGludGVybWVkaWF0ZSwgaW50ZXJwb2xhdG9ycywgbGVuLCBpO1xuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBmcm9tICkgfHwgIWlzQXJyYXkoIHRvICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW50ZXJtZWRpYXRlID0gW107XG5cdFx0XHRcdGludGVycG9sYXRvcnMgPSBbXTtcblx0XHRcdFx0aSA9IGxlbiA9IE1hdGgubWluKCBmcm9tLmxlbmd0aCwgdG8ubGVuZ3RoICk7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGludGVycG9sYXRvcnNbIGkgXSA9IGludGVycG9sYXRlKCBmcm9tWyBpIF0sIHRvWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzdXJwbHVzIHZhbHVlcyAtIGRvbid0IGludGVycG9sYXRlLCBidXQgZG9uJ3QgZXhjbHVkZSB0aGVtIGVpdGhlclxuXHRcdFx0XHRmb3IgKCBpID0gbGVuOyBpIDwgZnJvbS5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IGZyb21bIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBpID0gbGVuOyBpIDwgdG8ubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSB0b1sgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHR2YXIgaSA9IGxlbjtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gaW50ZXJwb2xhdG9yc1sgaSBdKCB0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0b2JqZWN0OiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBwcm9wZXJ0aWVzLCBsZW4sIGludGVycG9sYXRvcnMsIGludGVybWVkaWF0ZSwgcHJvcDtcblx0XHRcdFx0aWYgKCAhaXNPYmplY3QoIGZyb20gKSB8fCAhaXNPYmplY3QoIHRvICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvcGVydGllcyA9IFtdO1xuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSB7fTtcblx0XHRcdFx0aW50ZXJwb2xhdG9ycyA9IHt9O1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIGZyb20gKSB7XG5cdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCBmcm9tLCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHRvLCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzWyBwcm9wIF0gPSBpbnRlcnBvbGF0ZSggZnJvbVsgcHJvcCBdLCB0b1sgcHJvcCBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IGZyb21bIHByb3AgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggcHJvcCBpbiB0byApIHtcblx0XHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHRvLCBwcm9wICkgJiYgIWhhc093blByb3BlcnR5LmNhbGwoIGZyb20sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gdG9bIHByb3AgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHR2YXIgaSA9IGxlbixcblx0XHRcdFx0XHRcdHByb3A7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1sgaSBdO1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSBpbnRlcnBvbGF0b3JzWyBwcm9wIF0oIHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBpbnRlcnBvbGF0b3JzO1xuXHR9KCBjaXJjdWxhciwgaGFzT3duLCBpc0FycmF5LCBpc09iamVjdCwgaXNOdW1lcmljICk7XG5cblx0LyogY29uZmlnL3N2Zy5qcyAqL1xuXHR2YXIgc3ZnID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3ZnO1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHN2ZyA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdmcgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCAnaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZScsICcxLjEnICk7XG5cdFx0fVxuXHRcdHJldHVybiBzdmc7XG5cdH0oKTtcblxuXHQvKiB1dGlscy93YXJuLmpzICovXG5cdHZhciB3YXJuID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvKiBnbG9iYWwgY29uc29sZSAqL1xuXHRcdHZhciB3YXJuLCB3YXJuZWQgPSB7fTtcblx0XHRpZiAoIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25zb2xlLndhcm4uYXBwbHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR3YXJuID0gZnVuY3Rpb24oIG1lc3NhZ2UsIGFsbG93RHVwbGljYXRlcyApIHtcblx0XHRcdFx0aWYgKCAhYWxsb3dEdXBsaWNhdGVzICkge1xuXHRcdFx0XHRcdGlmICggd2FybmVkWyBtZXNzYWdlIF0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdhcm5lZFsgbWVzc2FnZSBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLndhcm4oICclY1JhY3RpdmUuanM6ICVjJyArIG1lc3NhZ2UsICdjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7JywgJ2NvbG9yOiByZ2IoODUsIDg1LCA4NSk7JyApO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2FybiA9IGZ1bmN0aW9uKCkge307XG5cdFx0fVxuXHRcdHJldHVybiB3YXJuO1xuXHR9KCk7XG5cblx0LyogY29uZmlnL2Vycm9ycy5qcyAqL1xuXHR2YXIgZXJyb3JzID0ge1xuXHRcdG1pc3NpbmdQYXJzZXI6ICdNaXNzaW5nIFJhY3RpdmUucGFyc2UgLSBjYW5ub3QgcGFyc2UgdGVtcGxhdGUuIEVpdGhlciBwcmVwYXJzZSBvciB1c2UgdGhlIHZlcnNpb24gdGhhdCBpbmNsdWRlcyB0aGUgcGFyc2VyJyxcblx0XHRtZXJnZUNvbXBhcmlzb25GYWlsOiAnTWVyZ2Ugb3BlcmF0aW9uOiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nJyxcblx0XHRub0NvbXBvbmVudEV2ZW50QXJndW1lbnRzOiAnQ29tcG9uZW50cyBjdXJyZW50bHkgb25seSBzdXBwb3J0IHNpbXBsZSBldmVudHMgLSB5b3UgY2Fubm90IGluY2x1ZGUgYXJndW1lbnRzLiBTb3JyeSEnLFxuXHRcdG5vVGVtcGxhdGVGb3JQYXJ0aWFsOiAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXCJ7bmFtZX1cIicsXG5cdFx0bm9OZXN0ZWRQYXJ0aWFsczogJ1BhcnRpYWxzICh7ez57bmFtZX19fSkgY2Fubm90IGNvbnRhaW4gbmVzdGVkIGlubGluZSBwYXJ0aWFscycsXG5cdFx0ZXZhbHVhdGlvbkVycm9yOiAnRXJyb3IgZXZhbHVhdGluZyBcInt1bmlxdWVTdHJpbmd9XCI6IHtlcnJ9Jyxcblx0XHRiYWRBcmd1bWVudHM6ICdCYWQgYXJndW1lbnRzIFwie2FyZ3VtZW50c31cIi4gSVxcJ20gbm90IGFsbG93ZWQgdG8gYXJndWUgdW5sZXNzIHlvdVxcJ3ZlIHBhaWQuJyxcblx0XHRmYWlsZWRDb21wdXRhdGlvbjogJ0ZhaWxlZCB0byBjb21wdXRlIFwie2tleX1cIjoge2Vycn0nLFxuXHRcdG1pc3NpbmdQbHVnaW46ICdNaXNzaW5nIFwie25hbWV9XCIge3BsdWdpbn0gcGx1Z2luLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSB7cGx1Z2lufSB2aWEgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvcGx1Z2lucyN7cGx1Z2lufXMnLFxuXHRcdGJhZFJhZGlvSW5wdXRCaW5kaW5nOiAnQSByYWRpbyBpbnB1dCBjYW4gaGF2ZSB0d28td2F5IGJpbmRpbmcgb24gaXRzIG5hbWUgYXR0cmlidXRlLCBvciBpdHMgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aCcsXG5cdFx0bm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuOiAnQSBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkIGZvciBcIntuYW1lfVwiIHtyZWdpc3RyeX0sIGJ1dCBubyB7cmVnaXN0cnl9IHdhcyByZXR1cm5lZCcsXG5cdFx0ZGVmYXVsdEVsU3BlY2lmaWVkOiAnVGhlIDx7bmFtZX0vPiBjb21wb25lbnQgaGFzIGEgZGVmYXVsdCBgZWxgIHByb3BlcnR5OyBpdCBoYXMgYmVlbiBkaXNyZWdhcmRlZCcsXG5cdFx0bm9FbGVtZW50UHJveHlFdmVudFdpbGRjYXJkczogJ09ubHkgY29tcG9uZW50IHByb3h5LWV2ZW50cyBtYXkgY29udGFpbiBcIipcIiB3aWxkY2FyZHMsIDx7ZWxlbWVudH0gb24te2V2ZW50fS8+IGlzIG5vdCB2YWxpZC4nLFxuXHRcdG1ldGhvZERlcHJlY2F0ZWQ6ICdUaGUgbWV0aG9kIFwie2RlcHJlY2F0ZWR9XCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBcIntyZXBsYWNlbWVudH1cIiBhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLidcblx0fTtcblxuXHQvKiB1dGlscy9sb2cuanMgKi9cblx0dmFyIGxvZyA9IGZ1bmN0aW9uKCBjb25zb2xld2FybiwgZXJyb3JzICkge1xuXG5cdFx0dmFyIGxvZyA9IHtcblx0XHRcdHdhcm46IGZ1bmN0aW9uKCBvcHRpb25zLCBwYXNzdGhydSApIHtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kZWJ1ZyAmJiAhcGFzc3RocnUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMud2FybkFsd2F5cyggb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdHdhcm5BbHdheXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmxvZ2dlciggZ2V0TWVzc2FnZSggb3B0aW9ucyApLCBvcHRpb25zLmFsbG93RHVwbGljYXRlcyApO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5lcnJvck9ubHkoIG9wdGlvbnMgKTtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLndhcm4oIG9wdGlvbnMsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGVycm9yT25seTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLmNyaXRpY2FsKCBvcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjcml0aWNhbDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciBlcnIgPSBvcHRpb25zLmVyciB8fCBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSApO1xuXHRcdFx0XHR0aGlzLnRocm93ZXIoIGVyciApO1xuXHRcdFx0fSxcblx0XHRcdGxvZ2dlcjogY29uc29sZXdhcm4sXG5cdFx0XHR0aHJvd2VyOiBmdW5jdGlvbiggZXJyICkge1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IGVycm9yc1sgb3B0aW9ucy5tZXNzYWdlIF0gfHwgb3B0aW9ucy5tZXNzYWdlIHx8ICcnO1xuXHRcdFx0cmV0dXJuIGludGVycG9sYXRlKCBtZXNzYWdlLCBvcHRpb25zLmFyZ3MgKTtcblx0XHR9XG5cdFx0Ly8gc2ltcGxlIGludGVycG9sYXRpb24uIHByb2JhYmx5IHF1aWNrZXIgKGFuZCBiZXR0ZXIpIG91dCB0aGVyZSxcblx0XHQvLyBidXQgbG9nIGlzIG5vdCBpbiBnb2xkZW4gcGF0aCBvZiBleGVjdXRpb24sIG9ubHkgZXhjZXB0aW9uc1xuXHRcdGZ1bmN0aW9uIGludGVycG9sYXRlKCBtZXNzYWdlLCBhcmdzICkge1xuXHRcdFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSggL3soW157fV0qKX0vZywgZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdHJldHVybiBhcmdzWyBiIF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2c7XG5cdH0oIHdhcm4sIGVycm9ycyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9ob29rcy9Ib29rLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHZhciBkZXByZWNhdGlvbnMgPSB7XG5cdFx0XHRjb25zdHJ1Y3Q6IHtcblx0XHRcdFx0ZGVwcmVjYXRlZDogJ2JlZm9yZUluaXQnLFxuXHRcdFx0XHRyZXBsYWNlbWVudDogJ29uY29uc3RydWN0J1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjoge1xuXHRcdFx0XHRkZXByZWNhdGVkOiAnaW5pdCcsXG5cdFx0XHRcdG1lc3NhZ2U6ICdUaGUgXCJpbml0XCIgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiAnICsgJ1lvdSBjYW4gZWl0aGVyIHVzZSB0aGUgXCJvbmluaXRcIiBtZXRob2Qgd2hpY2ggd2lsbCBmaXJlICcgKyAnb25seSBvbmNlIHByaW9yIHRvLCBhbmQgcmVnYXJkbGVzcyBvZiwgYW55IGV2ZW50dWFsIHJhY3RpdmUgJyArICdpbnN0YW5jZSBiZWluZyByZW5kZXJlZCwgb3IgaWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSAnICsgJ3JlbmRlcmVkIERPTSwgdXNlIFwib25yZW5kZXJcIiBpbnN0ZWFkLiAnICsgJ1NlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJ1xuXHRcdFx0fSxcblx0XHRcdGNvbXBsZXRlOiB7XG5cdFx0XHRcdGRlcHJlY2F0ZWQ6ICdjb21wbGV0ZScsXG5cdFx0XHRcdHJlcGxhY2VtZW50OiAnb25jb21wbGV0ZSdcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gSG9vayggZXZlbnQgKSB7XG5cdFx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHR0aGlzLm1ldGhvZCA9ICdvbicgKyBldmVudDtcblx0XHRcdHRoaXMuZGVwcmVjYXRlID0gZGVwcmVjYXRpb25zWyBldmVudCBdO1xuXHRcdH1cblx0XHRIb29rLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24oIHJhY3RpdmUsIGFyZyApIHtcblx0XHRcdGZ1bmN0aW9uIGNhbGwoIG1ldGhvZCApIHtcblx0XHRcdFx0aWYgKCByYWN0aXZlWyBtZXRob2QgXSApIHtcblx0XHRcdFx0XHRhcmcgPyByYWN0aXZlWyBtZXRob2QgXSggYXJnICkgOiByYWN0aXZlWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYWxsKCB0aGlzLm1ldGhvZCApO1xuXHRcdFx0aWYgKCAhcmFjdGl2ZVsgdGhpcy5tZXRob2QgXSAmJiB0aGlzLmRlcHJlY2F0ZSAmJiBjYWxsKCB0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkICkgKSB7XG5cdFx0XHRcdGxvZy53YXJuQWx3YXlzKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogdGhpcy5kZXByZWNhdGUubWVzc2FnZSB8fCAnbWV0aG9kRGVwcmVjYXRlZCcsXG5cdFx0XHRcdFx0YXJnczogdGhpcy5kZXByZWNhdGVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0YXJnID8gcmFjdGl2ZS5maXJlKCB0aGlzLmV2ZW50LCBhcmcgKSA6IHJhY3RpdmUuZmlyZSggdGhpcy5ldmVudCApO1xuXHRcdH07XG5cdFx0cmV0dXJuIEhvb2s7XG5cdH0oIGxvZyApO1xuXG5cdC8qIHV0aWxzL3JlbW92ZUZyb21BcnJheS5qcyAqL1xuXHR2YXIgcmVtb3ZlRnJvbUFycmF5ID0gZnVuY3Rpb24oIGFycmF5LCBtZW1iZXIgKSB7XG5cdFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZiggbWVtYmVyICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRhcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHV0aWxzL1Byb21pc2UuanMgKi9cblx0dmFyIFByb21pc2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgX1Byb21pc2UsIFBFTkRJTkcgPSB7fSxcblx0XHRcdEZVTEZJTExFRCA9IHt9LFxuXHRcdFx0UkVKRUNURUQgPSB7fTtcblx0XHRpZiAoIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gdXNlIG5hdGl2ZSBQcm9taXNlXG5cdFx0XHRfUHJvbWlzZSA9IFByb21pc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9Qcm9taXNlID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHR2YXIgZnVsZmlsbGVkSGFuZGxlcnMgPSBbXSxcblx0XHRcdFx0XHRyZWplY3RlZEhhbmRsZXJzID0gW10sXG5cdFx0XHRcdFx0c3RhdGUgPSBQRU5ESU5HLFxuXHRcdFx0XHRcdHJlc3VsdCwgZGlzcGF0Y2hIYW5kbGVycywgbWFrZVJlc29sdmVyLCBmdWxmaWwsIHJlamVjdCwgcHJvbWlzZTtcblx0XHRcdFx0bWFrZVJlc29sdmVyID0gZnVuY3Rpb24oIG5ld1N0YXRlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHN0YXRlID0gbmV3U3RhdGU7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaEhhbmRsZXJzID0gbWFrZURpc3BhdGNoZXIoIHN0YXRlID09PSBGVUxGSUxMRUQgPyBmdWxmaWxsZWRIYW5kbGVycyA6IHJlamVjdGVkSGFuZGxlcnMsIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0Ly8gZGlzcGF0Y2ggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHRcdHdhaXQoIGRpc3BhdGNoSGFuZGxlcnMgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmdWxmaWwgPSBtYWtlUmVzb2x2ZXIoIEZVTEZJTExFRCApO1xuXHRcdFx0XHRyZWplY3QgPSBtYWtlUmVzb2x2ZXIoIFJFSkVDVEVEICk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCBlcnIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRcdC8vIGB0aGVuKClgIHJldHVybnMgYSBQcm9taXNlIC0gMi4yLjdcblx0XHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJvbWlzZTIgPSBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCBoYW5kbGVyLCBoYW5kbGVycywgZm9yd2FyZCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAyLjIuMS4xXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goIGZ1bmN0aW9uKCBwMXJlc3VsdCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eCA9IGhhbmRsZXIoIHAxcmVzdWx0ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggcHJvbWlzZTIsIHgsIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVqZWN0KCBlcnIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3J3YXJkIHRoZSByZXN1bHQgb2YgcHJvbWlzZTEgdG8gcHJvbWlzZTIsIGlmIHJlc29sdXRpb24gaGFuZGxlcnNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGFyZSBub3QgZ2l2ZW5cblx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goIGZvcndhcmQgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdC8vIDIuMlxuXHRcdFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uRnVsZmlsbGVkLCBmdWxmaWxsZWRIYW5kbGVycywgZnVsZmlsICk7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciggb25SZWplY3RlZCwgcmVqZWN0ZWRIYW5kbGVycywgcmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggc3RhdGUgIT09IFBFTkRJTkcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByb21pc2UgaGFzIHJlc29sdmVkIGFscmVhZHksIGRpc3BhdGNoIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuXHRcdFx0XHRcdFx0XHRcdHdhaXQoIGRpc3BhdGNoSGFuZGxlcnMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb21pc2UyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0cHJvbWlzZVsgJ2NhdGNoJyBdID0gZnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudGhlbiggbnVsbCwgb25SZWplY3RlZCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiggcHJvbWlzZXMgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdFx0XHRwZW5kaW5nLCBpLCBwcm9jZXNzUHJvbWlzZTtcblx0XHRcdFx0XHRpZiAoICFwcm9taXNlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmdWxmaWwoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcm9jZXNzUHJvbWlzZSA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdFx0cHJvbWlzZXNbIGkgXS50aGVuKCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGlmICggIS0tcGVuZGluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRmdWxmaWwoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCByZWplY3QgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHBlbmRpbmcgPSBpID0gcHJvbWlzZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UoIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsICkge1xuXHRcdFx0XHRcdGZ1bGZpbCggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHRcdF9Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKCByZWFzb24gKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHRyZWplY3QoIHJlYXNvbiApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRfX2V4cG9ydCA9IF9Qcm9taXNlO1xuXHRcdC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcblx0XHRmdW5jdGlvbiB3YWl0KCBjYWxsYmFjayApIHtcblx0XHRcdHNldFRpbWVvdXQoIGNhbGxiYWNrLCAwICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIoIGhhbmRsZXJzLCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBoYW5kbGVyO1xuXHRcdFx0XHR3aGlsZSAoIGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpICkge1xuXHRcdFx0XHRcdGhhbmRsZXIoIHJlc3VsdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmUoIHByb21pc2UsIHgsIGZ1bGZpbCwgcmVqZWN0ICkge1xuXHRcdFx0Ly8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVxuXHRcdFx0dmFyIHRoZW47XG5cdFx0XHQvLyAyLjMuMVxuXHRcdFx0aWYgKCB4ID09PSBwcm9taXNlICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnQSBwcm9taXNlXFwncyBmdWxmaWxsbWVudCBoYW5kbGVyIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIDIuMy4yXG5cdFx0XHRpZiAoIHggaW5zdGFuY2VvZiBfUHJvbWlzZSApIHtcblx0XHRcdFx0eC50aGVuKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0fSBlbHNlIGlmICggeCAmJiAoIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyApICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdHJlamVjdCggZSApO1xuXHRcdFx0XHRcdC8vIDIuMy4zLjJcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gMi4zLjMuM1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHZhciBjYWxsZWQsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlO1xuXHRcdFx0XHRcdHJlc29sdmVQcm9taXNlID0gZnVuY3Rpb24oIHkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UsIHksIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZWplY3RQcm9taXNlID0gZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlamVjdCggciApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoZW4uY2FsbCggeCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UgKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0cmVqZWN0KCBlICk7XG5cdFx0XHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4yXG5cdFx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnVsZmlsKCB4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGZpbCggeCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB1dGlscy9ub3JtYWxpc2VSZWYuanMgKi9cblx0dmFyIG5vcm1hbGlzZVJlZiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHJlZ2V4ID0gL1xcW1xccyooXFwqfFswLTldfFsxLTldWzAtOV0rKVxccypcXF0vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXNlUmVmKCByZWYgKSB7XG5cdFx0XHRyZXR1cm4gKCByZWYgfHwgJycgKS5yZXBsYWNlKCByZWdleCwgJy4kMScgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0Lyogc2hhcmVkL2dldElubmVyQ29udGV4dC5qcyAqL1xuXHR2YXIgZ2V0SW5uZXJDb250ZXh0ID0gZnVuY3Rpb24oIGZyYWdtZW50ICkge1xuXHRcdGRvIHtcblx0XHRcdGlmICggZnJhZ21lbnQuY29udGV4dCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dDtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRyZXR1cm4gJyc7XG5cdH07XG5cblx0LyogdXRpbHMvaXNFcXVhbC5qcyAqL1xuXHR2YXIgaXNFcXVhbCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gbnVsbCAmJiBiID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGEgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBiID09PSAnb2JqZWN0JyApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIGEgPT09IGI7XG5cdH07XG5cblx0Lyogc2hhcmVkL2NyZWF0ZUNvbXBvbmVudEJpbmRpbmcuanMgKi9cblx0dmFyIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgcnVubG9vcDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBydW5sb29wID0gY2lyY3VsYXIucnVubG9vcDtcblx0XHR9ICk7XG5cdFx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5cGF0aCwgb3RoZXJJbnN0YW5jZSwgb3RoZXJLZXlwYXRoICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdHRoaXMub3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2U7XG5cdFx0XHR0aGlzLm90aGVyS2V5cGF0aCA9IG90aGVyS2V5cGF0aDtcblx0XHRcdHRoaXMubG9jayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnVubG9jayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdH07XG5cdFx0QmluZGluZy5wcm90b3R5cGUgPSB7XG5cdFx0XHRpc0xvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnVwZGF0aW5nIHx8IHRoaXMuY291bnRlcnBhcnQgJiYgdGhpcy5jb3VudGVycGFydC51cGRhdGluZztcblx0XHRcdH0sXG5cdFx0XHRzaHVmZmxlOiBmdW5jdGlvbiggbmV3SW5kaWNlcywgdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKCB2YWx1ZSwgbmV3SW5kaWNlcyApO1xuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKCB2YWx1ZSApO1xuXHRcdFx0fSxcblx0XHRcdHByb3BhZ2F0ZUNoYW5nZTogZnVuY3Rpb24oIHZhbHVlLCBuZXdJbmRpY2VzICkge1xuXHRcdFx0XHR2YXIgb3RoZXI7XG5cdFx0XHRcdC8vIE9ubHkgKnlvdSogY2FuIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLmlzTG9ja2VkKCkgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMubG9jaygpO1xuXHRcdFx0XHRcdC8vIFRPRE8gbWF5YmUgdGhlIGNhc2UgdGhhdCBgdmFsdWUgPT09IHRoaXMudmFsdWVgIC0gc2hvdWxkIHRoYXQgcmVzdWx0XG5cdFx0XHRcdFx0Ly8gaW4gYW4gdXBkYXRlIHJhdGhlciB0aGFuIGEgc2V0P1xuXHRcdFx0XHRcdC8vIGlmIHRoZSBvdGhlciB2aWV3bW9kZWwgaXMgYWxyZWFkeSBsb2NrZWQgdXAsIG5lZWQgdG8gZG8gYSBkZWZlcnJlZCB1cGRhdGVcblx0XHRcdFx0XHRpZiAoICFydW5sb29wLmFkZFZpZXdtb2RlbCggb3RoZXIgPSB0aGlzLm90aGVySW5zdGFuY2Uudmlld21vZGVsICkgJiYgdGhpcy5jb3VudGVycGFydC52YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBydW5sb29wLmFkZFZpZXdtb2RlbCggb3RoZXIgKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBuZXdJbmRpY2VzICkge1xuXHRcdFx0XHRcdFx0b3RoZXIuc21hcnRVcGRhdGUoIHRoaXMub3RoZXJLZXlwYXRoLCB2YWx1ZSwgbmV3SW5kaWNlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoIGlzU2V0dGFibGUoIG90aGVyLCB0aGlzLm90aGVyS2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHRvdGhlci5zZXQoIHRoaXMub3RoZXJLZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0Ly8gVE9ETyB3aWxsIHRoZSBjb3VudGVycGFydCB1cGRhdGUgYWZ0ZXIgdGhpcyBsaW5lLCBkdXJpbmdcblx0XHRcdFx0XHQvLyB0aGUgcnVubG9vcCBlbmQgY3ljbGU/IG1heSBiZSBhIHByb2JsZW0uLi5cblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggdGhpcy51bmxvY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlZmluZVZhbHVlOiBmdW5jdGlvbigga2V5cGF0aHMgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgb3RoZXI7XG5cdFx0XHRcdGlmICggdGhpcy5pc0xvY2tlZCgpICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmxvY2soKTtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIG90aGVyID0gdGhpcy5vdGhlckluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRrZXlwYXRocy5tYXAoIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAub3RoZXJLZXlwYXRoICsga2V5cGF0aC5zdWJzdHIoIHRoaXMkMC5rZXlwYXRoLmxlbmd0aCApO1xuXHRcdFx0XHR9ICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG90aGVyLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggdGhpcy51bmxvY2sgKTtcblx0XHRcdH0sXG5cdFx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy51bmJpbmQoKTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0dGhpcy5jb3VudGVycGFydC5vdGhlcktleXBhdGggPSBuZXdLZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1NldHRhYmxlKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgY29tcHV0ZWQgPSB2aWV3bW9kZWwuY29tcHV0YXRpb25zWyBrZXlwYXRoIF07XG5cdFx0XHRyZXR1cm4gIWNvbXB1dGVkIHx8IGNvbXB1dGVkLnNldHRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIGNvbXBvbmVudCwgcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aCApIHtcblx0XHRcdHZhciBoYXNoLCBjaGlsZEluc3RhbmNlLCBiaW5kaW5ncywgcGFyZW50VG9DaGlsZEJpbmRpbmcsIGNoaWxkVG9QYXJlbnRCaW5kaW5nO1xuXHRcdFx0aGFzaCA9IHBhcmVudEtleXBhdGggKyAnPScgKyBjaGlsZEtleXBhdGg7XG5cdFx0XHRiaW5kaW5ncyA9IGNvbXBvbmVudC5iaW5kaW5ncztcblx0XHRcdGlmICggYmluZGluZ3NbIGhhc2ggXSApIHtcblx0XHRcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgZXZlciBoYXBwZW4/XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNoaWxkSW5zdGFuY2UgPSBjb21wb25lbnQuaW5zdGFuY2U7XG5cdFx0XHRwYXJlbnRUb0NoaWxkQmluZGluZyA9IG5ldyBCaW5kaW5nKCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCwgY2hpbGRJbnN0YW5jZSwgY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRiaW5kaW5ncy5wdXNoKCBwYXJlbnRUb0NoaWxkQmluZGluZyApO1xuXHRcdFx0aWYgKCBjaGlsZEluc3RhbmNlLnR3b3dheSApIHtcblx0XHRcdFx0Y2hpbGRUb1BhcmVudEJpbmRpbmcgPSBuZXcgQmluZGluZyggY2hpbGRJbnN0YW5jZSwgY2hpbGRLZXlwYXRoLCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBjaGlsZFRvUGFyZW50QmluZGluZyApO1xuXHRcdFx0XHRwYXJlbnRUb0NoaWxkQmluZGluZy5jb3VudGVycGFydCA9IGNoaWxkVG9QYXJlbnRCaW5kaW5nO1xuXHRcdFx0XHRjaGlsZFRvUGFyZW50QmluZGluZy5jb3VudGVycGFydCA9IHBhcmVudFRvQ2hpbGRCaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0YmluZGluZ3NbIGhhc2ggXSA9IHBhcmVudFRvQ2hpbGRCaW5kaW5nO1xuXHRcdH07XG5cdH0oIGNpcmN1bGFyLCBpc0VxdWFsICk7XG5cblx0Lyogc2hhcmVkL3Jlc29sdmVSZWYuanMgKi9cblx0dmFyIHJlc29sdmVSZWYgPSBmdW5jdGlvbiggbm9ybWFsaXNlUmVmLCBnZXRJbm5lckNvbnRleHQsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGFuY2VzdG9yRXJyb3JNZXNzYWdlLCBnZXRPcHRpb25zO1xuXHRcdGFuY2VzdG9yRXJyb3JNZXNzYWdlID0gJ0NvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSAtIHRvbyBtYW55IFwiLi4vXCIgcHJlZml4ZXMnO1xuXHRcdGdldE9wdGlvbnMgPSB7XG5cdFx0XHRldmFsdWF0ZVdyYXBwZWQ6IHRydWVcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBmcmFnbWVudCwgaXNQYXJlbnRMb29rdXAgKSB7XG5cdFx0XHR2YXIgY29udGV4dCwga2V5LCBpbmRleCwga2V5cGF0aCwgcGFyZW50VmFsdWUsIGhhc0NvbnRleHRDaGFpbiwgcGFyZW50S2V5cywgY2hpbGRLZXlzLCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGg7XG5cdFx0XHRyZWYgPSBub3JtYWxpc2VSZWYoIHJlZiApO1xuXHRcdFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zICd+LycsIGl0J3MgYSB0b3AtbGV2ZWwgcmVmZXJlbmNlXG5cdFx0XHRpZiAoIHJlZi5zdWJzdHIoIDAsIDIgKSA9PT0gJ34vJyApIHtcblx0XHRcdFx0cmV0dXJuIHJlZi5zdWJzdHJpbmcoIDIgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyB3aXRoICcuJywgaXQncyBlaXRoZXIgYSByZXN0cmljdGVkIHJlZmVyZW5jZSBvclxuXHRcdFx0Ly8gYW4gYW5jZXN0b3IgcmVmZXJlbmNlLi4uXG5cdFx0XHRpZiAoIHJlZi5jaGFyQXQoIDAgKSA9PT0gJy4nICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzb2x2ZUFuY2VzdG9yUmVmZXJlbmNlKCBnZXRJbm5lckNvbnRleHQoIGZyYWdtZW50ICksIHJlZiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmluZCB0aGUga2V5cGF0aFxuXHRcdFx0a2V5ID0gcmVmLnNwbGl0KCAnLicgKVsgMCBdO1xuXHRcdFx0Ly8gZ2V0KCkgaW4gdmlld21vZGVsIGNyZWF0aW9uIG1lYW5zIG5vIGZyYWdtZW50ICh5ZXQpXG5cdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50IHx8IHt9O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRjb250ZXh0ID0gZnJhZ21lbnQuY29udGV4dDtcblx0XHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldCggY29udGV4dCwgZ2V0T3B0aW9ucyApO1xuXHRcdFx0XHRpZiAoIHBhcmVudFZhbHVlICYmICggdHlwZW9mIHBhcmVudFZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdmdW5jdGlvbicgKSAmJiBrZXkgaW4gcGFyZW50VmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRleHQgKyAnLicgKyByZWY7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdFx0Ly8gUm9vdC9jb21wdXRlZCBwcm9wZXJ0eT9cblx0XHRcdGlmICgga2V5IGluIHJhY3RpdmUuZGF0YSB8fCBrZXkgaW4gcmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0YXRpb25zICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbmxpbmUgY29tcG9uZW50LCBhbmQgaXQncyBub3QgaXNvbGF0ZWQsIHdlXG5cdFx0XHQvLyBjYW4gdHJ5IGdvaW5nIHVwIHRoZSBzY29wZSBjaGFpblxuXHRcdFx0aWYgKCByYWN0aXZlLl9wYXJlbnQgJiYgIXJhY3RpdmUuaXNvbGF0ZWQgKSB7XG5cdFx0XHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG5cdFx0XHRcdGZyYWdtZW50ID0gcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGluZGV4IHJlZnNcblx0XHRcdFx0aWYgKCBmcmFnbWVudC5pbmRleFJlZnMgJiYgKCBpbmRleCA9IGZyYWdtZW50LmluZGV4UmVmc1sgcmVmIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIENyZWF0ZSBhbiBpbmRleCByZWYgYmluZGluZywgc28gdGhhdCBpdCBjYW4gYmUgcmVib3VuZCBsZXR0ZXIgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0XHRcdC8vIEl0IGRvZXNuJ3QgaGF2ZSBhbiBhbGlhcyBzaW5jZSBpdCdzIGFuIGltcGxpY2l0IGJpbmRpbmcsIGhlbmNlIGAuLi5bIHJlZiBdID0gcmVmYFxuXHRcdFx0XHRcdHJhY3RpdmUuY29tcG9uZW50LmluZGV4UmVmQmluZGluZ3NbIHJlZiBdID0gcmVmO1xuXHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldCggcmVmLCBpbmRleCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZS5fcGFyZW50LCByZWYsIGZyYWdtZW50LCB0cnVlICk7XG5cdFx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhbiBpbnRlci1jb21wb25lbnQgYmluZGluZ1xuXHRcdFx0XHRcdC8vIElmIHBhcmVudCBrZXlwYXRoIGlzICdvbmUuZm9vJyBhbmQgY2hpbGQgaXMgJ3R3by5mb28nLCB3ZSBiaW5kXG5cdFx0XHRcdFx0Ly8gJ29uZScgdG8gJ3R3bycgYXMgaXQncyBtb3JlIGVmZmljaWVudCBhbmQgYXZvaWRzIGVkZ2UgY2FzZXNcblx0XHRcdFx0XHRwYXJlbnRLZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdFx0Y2hpbGRLZXlzID0gcmVmLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHR3aGlsZSAoIHBhcmVudEtleXMubGVuZ3RoID4gMSAmJiBjaGlsZEtleXMubGVuZ3RoID4gMSAmJiBwYXJlbnRLZXlzWyBwYXJlbnRLZXlzLmxlbmd0aCAtIDEgXSA9PT0gY2hpbGRLZXlzWyBjaGlsZEtleXMubGVuZ3RoIC0gMSBdICkge1xuXHRcdFx0XHRcdFx0cGFyZW50S2V5cy5wb3AoKTtcblx0XHRcdFx0XHRcdGNoaWxkS2V5cy5wb3AoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IHBhcmVudEtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdFx0Y2hpbGRLZXlwYXRoID0gY2hpbGRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldCggY2hpbGRLZXlwYXRoLCByYWN0aXZlLl9wYXJlbnQudmlld21vZGVsLmdldCggcGFyZW50S2V5cGF0aCApLCB0cnVlICk7XG5cdFx0XHRcdFx0Y3JlYXRlQ29tcG9uZW50QmluZGluZyggcmFjdGl2ZS5jb21wb25lbnQsIHJhY3RpdmUuX3BhcmVudCwgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhlcmUncyBubyBjb250ZXh0IGNoYWluLCBhbmQgdGhlIGluc3RhbmNlIGlzIGVpdGhlciBhKSBpc29sYXRlZCBvclxuXHRcdFx0Ly8gYikgYW4gb3JwaGFuLCB0aGVuIHdlIGtub3cgdGhhdCB0aGUga2V5cGF0aCBpcyBpZGVudGljYWwgdG8gdGhlIHJlZmVyZW5jZVxuXHRcdFx0aWYgKCAhaXNQYXJlbnRMb29rdXAgJiYgIWhhc0NvbnRleHRDaGFpbiApIHtcblx0XHRcdFx0Ly8gdGhlIGRhdGEgb2JqZWN0IG5lZWRzIHRvIGhhdmUgYSBwcm9wZXJ0eSBieSB0aGlzIG5hbWUsXG5cdFx0XHRcdC8vIHRvIHByZXZlbnQgZnV0dXJlIGZhaWxlZCBsb29rdXBzXG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldCggcmVmLCB1bmRlZmluZWQgKTtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCByZWYgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlQW5jZXN0b3JSZWZlcmVuY2UoIGJhc2VDb250ZXh0LCByZWYgKSB7XG5cdFx0XHR2YXIgY29udGV4dEtleXM7XG5cdFx0XHQvLyB7ey59fSBtZWFucyAnY3VycmVudCBjb250ZXh0J1xuXHRcdFx0aWYgKCByZWYgPT09ICcuJyApXG5cdFx0XHRcdHJldHVybiBiYXNlQ29udGV4dDtcblx0XHRcdGNvbnRleHRLZXlzID0gYmFzZUNvbnRleHQgPyBiYXNlQ29udGV4dC5zcGxpdCggJy4nICkgOiBbXTtcblx0XHRcdC8vIGFuY2VzdG9yIHJlZmVyZW5jZXMgKHN0YXJ0aW5nIFwiLi4vXCIpIGdvIHVwIHRoZSB0cmVlXG5cdFx0XHRpZiAoIHJlZi5zdWJzdHIoIDAsIDMgKSA9PT0gJy4uLycgKSB7XG5cdFx0XHRcdHdoaWxlICggcmVmLnN1YnN0ciggMCwgMyApID09PSAnLi4vJyApIHtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0S2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGFuY2VzdG9yRXJyb3JNZXNzYWdlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRleHRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdHJlZiA9IHJlZi5zdWJzdHJpbmcoIDMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZXh0S2V5cy5wdXNoKCByZWYgKTtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm90IGFuIGFuY2VzdG9yIHJlZmVyZW5jZSAtIG11c3QgYmUgYSByZXN0cmljdGVkIHJlZmVyZW5jZSAocHJlcGVuZGVkIHdpdGggXCIuXCIgb3IgXCIuL1wiKVxuXHRcdFx0aWYgKCAhYmFzZUNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZWYucmVwbGFjZSggL15cXC5cXC8/LywgJycgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBiYXNlQ29udGV4dCArIHJlZi5yZXBsYWNlKCAvXlxcLlxcLy8sICcuJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIG5vcm1hbGlzZVJlZiwgZ2V0SW5uZXJDb250ZXh0LCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogZ2xvYmFsL1RyYW5zaXRpb25NYW5hZ2VyLmpzICovXG5cdHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiggY2FsbGJhY2ssIHBhcmVudCApIHtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHRcdFx0dGhpcy5pbnRyb3MgPSBbXTtcblx0XHRcdHRoaXMub3V0cm9zID0gW107XG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXHRcdFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuXHRcdFx0dGhpcy5vdXRyb3NDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5hZGRDaGlsZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKCBjaGlsZCApIHtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gKz0gMTtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuICs9IDE7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50T3V0cm9zOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuIC09IDE7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50VG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gLT0gMTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG5cdFx0XHRcdGxpc3QucHVzaCggdHJhbnNpdGlvbiApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBsaXN0LCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGRldGFjaE5vZGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kZXRhY2hRdWV1ZS5mb3JFYWNoKCBkZXRhY2ggKTtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBkZXRhY2hOb2RlcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkZXRhY2goIGVsZW1lbnQgKSB7XG5cdFx0XHRlbGVtZW50LmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRldGFjaE5vZGVzKCB0bSApIHtcblx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2soIHRtICkge1xuXHRcdFx0aWYgKCAhdG0ucmVhZHkgfHwgdG0ub3V0cm9zLmxlbmd0aCB8fCB0bS5vdXRyb0NoaWxkcmVuIClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Ly8gSWYgYWxsIG91dHJvcyBhcmUgY29tcGxldGUsIGFuZCB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSB0aGlzLFxuXHRcdFx0Ly8gd2Ugbm90aWZ5IHRoZSBwYXJlbnQgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2Vcblx0XHRcdC8vIHN0YXJ0IGRldGFjaGluZyBub2Rlc1xuXHRcdFx0aWYgKCAhdG0ub3V0cm9zQ29tcGxldGUgKSB7XG5cdFx0XHRcdGlmICggdG0ucGFyZW50ICkge1xuXHRcdFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRPdXRyb3MoIHRtICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bS5vdXRyb3NDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuXHRcdFx0Ly8gbWFuYWdlciBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcblx0XHRcdGlmICggIXRtLmludHJvcy5sZW5ndGggJiYgIXRtLnRvdGFsQ2hpbGRyZW4gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRtLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHRtLmNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0bS5wYXJlbnQgKSB7XG5cdFx0XHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudFRvdGFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFRyYW5zaXRpb25NYW5hZ2VyO1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBnbG9iYWwvcnVubG9vcC5qcyAqL1xuXHR2YXIgcnVubG9vcCA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgSG9vaywgcmVtb3ZlRnJvbUFycmF5LCBQcm9taXNlLCByZXNvbHZlUmVmLCBUcmFuc2l0aW9uTWFuYWdlciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgYmF0Y2gsIHJ1bmxvb3AsIHVucmVzb2x2ZWQgPSBbXSxcblx0XHRcdGNoYW5nZUhvb2sgPSBuZXcgSG9vayggJ2NoYW5nZScgKTtcblx0XHRydW5sb29wID0ge1xuXHRcdFx0c3RhcnQ6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgcmV0dXJuUHJvbWlzZSApIHtcblx0XHRcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2U7XG5cdFx0XHRcdGlmICggcmV0dXJuUHJvbWlzZSApIHtcblx0XHRcdFx0XHRwcm9taXNlID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCBmICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bGZpbFByb21pc2UgPSBmO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRiYXRjaCA9IHtcblx0XHRcdFx0XHRwcmV2aW91c0JhdGNoOiBiYXRjaCxcblx0XHRcdFx0XHR0cmFuc2l0aW9uTWFuYWdlcjogbmV3IFRyYW5zaXRpb25NYW5hZ2VyKCBmdWxmaWxQcm9taXNlLCBiYXRjaCAmJiBiYXRjaC50cmFuc2l0aW9uTWFuYWdlciApLFxuXHRcdFx0XHRcdHZpZXdzOiBbXSxcblx0XHRcdFx0XHR0YXNrczogW10sXG5cdFx0XHRcdFx0dmlld21vZGVsczogW10sXG5cdFx0XHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0YmF0Y2gudmlld21vZGVscy5wdXNoKCBpbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH0sXG5cdFx0XHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmbHVzaENoYW5nZXMoKTtcblx0XHRcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuaW5pdCgpO1xuXHRcdFx0XHRpZiAoICFiYXRjaC5wcmV2aW91c0JhdGNoICYmICEhYmF0Y2guaW5zdGFuY2UgKVxuXHRcdFx0XHRcdGJhdGNoLmluc3RhbmNlLnZpZXdtb2RlbC5jaGFuZ2VzID0gW107XG5cdFx0XHRcdGJhdGNoID0gYmF0Y2gucHJldmlvdXNCYXRjaDtcblx0XHRcdH0sXG5cdFx0XHRhZGRWaWV3bW9kZWw6IGZ1bmN0aW9uKCB2aWV3bW9kZWwgKSB7XG5cdFx0XHRcdGlmICggYmF0Y2ggKSB7XG5cdFx0XHRcdFx0aWYgKCBiYXRjaC52aWV3bW9kZWxzLmluZGV4T2YoIHZpZXdtb2RlbCApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGJhdGNoLnZpZXdtb2RlbHMucHVzaCggdmlld21vZGVsICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2aWV3bW9kZWwuYXBwbHlDaGFuZ2VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVnaXN0ZXJUcmFuc2l0aW9uOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGQoIHRyYW5zaXRpb24gKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRWaWV3OiBmdW5jdGlvbiggdmlldyApIHtcblx0XHRcdFx0YmF0Y2gudmlld3MucHVzaCggdmlldyApO1xuXHRcdFx0fSxcblx0XHRcdGFkZFVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0dW5yZXNvbHZlZC5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZVVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB1bnJlc29sdmVkLCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdC8vIHN5bmNocm9uaXNlIG5vZGUgZGV0YWNobWVudHMgd2l0aCB0cmFuc2l0aW9uIGVuZHNcblx0XHRcdGRldGFjaFdoZW5SZWFkeTogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHNjaGVkdWxlVGFzazogZnVuY3Rpb24oIHRhc2ssIHBvc3RSZW5kZXIgKSB7XG5cdFx0XHRcdHZhciBfYmF0Y2g7XG5cdFx0XHRcdGlmICggIWJhdGNoICkge1xuXHRcdFx0XHRcdHRhc2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfYmF0Y2ggPSBiYXRjaDtcblx0XHRcdFx0XHR3aGlsZSAoIHBvc3RSZW5kZXIgJiYgX2JhdGNoLnByZXZpb3VzQmF0Y2ggKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzIGNhbid0IGhhcHBlbiB1bnRpbCB0aGUgRE9NIGhhcyBiZWVuIGZ1bGx5IHVwZGF0ZWRcblx0XHRcdFx0XHRcdC8vIG90aGVyd2lzZSBpbiBzb21lIHNpdHVhdGlvbnMgKHdpdGggY29tcG9uZW50cyBpbnNpZGUgZWxlbWVudHMpXG5cdFx0XHRcdFx0XHQvLyB0cmFuc2l0aW9ucyBhbmQgZGVjb3JhdG9ycyB3aWxsIGluaXRpYWxpc2UgcHJlbWF0dXJlbHlcblx0XHRcdFx0XHRcdF9iYXRjaCA9IF9iYXRjaC5wcmV2aW91c0JhdGNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfYmF0Y2gudGFza3MucHVzaCggdGFzayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjaXJjdWxhci5ydW5sb29wID0gcnVubG9vcDtcblx0XHRfX2V4cG9ydCA9IHJ1bmxvb3A7XG5cblx0XHRmdW5jdGlvbiBmbHVzaENoYW5nZXMoKSB7XG5cdFx0XHR2YXIgaSwgdGhpbmcsIGNoYW5nZUhhc2g7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdHRoaW5nID0gYmF0Y2gudmlld21vZGVsc1sgaSBdO1xuXHRcdFx0XHRjaGFuZ2VIYXNoID0gdGhpbmcuYXBwbHlDaGFuZ2VzKCk7XG5cdFx0XHRcdGlmICggY2hhbmdlSGFzaCApIHtcblx0XHRcdFx0XHRjaGFuZ2VIb29rLmZpcmUoIHRoaW5nLnJhY3RpdmUsIGNoYW5nZUhhc2ggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudmlld21vZGVscy5sZW5ndGggPSAwO1xuXHRcdFx0YXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCk7XG5cdFx0XHQvLyBOb3cgdGhhdCBjaGFuZ2VzIGhhdmUgYmVlbiBmdWxseSBwcm9wYWdhdGVkLCB3ZSBjYW4gdXBkYXRlIHRoZSBET01cblx0XHRcdC8vIGFuZCBjb21wbGV0ZSBvdGhlciB0YXNrc1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC52aWV3cy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0YmF0Y2gudmlld3NbIGkgXS51cGRhdGUoKTtcblx0XHRcdH1cblx0XHRcdGJhdGNoLnZpZXdzLmxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnRhc2tzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRiYXRjaC50YXNrc1sgaSBdKCk7XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC50YXNrcy5sZW5ndGggPSAwO1xuXHRcdFx0Ly8gSWYgdXBkYXRpbmcgdGhlIHZpZXcgY2F1c2VkIHNvbWUgbW9kZWwgYmxvd2JhY2sgLSBlLmcuIGEgdHJpcGxlXG5cdFx0XHQvLyBjb250YWluaW5nIDxvcHRpb24+IGVsZW1lbnRzIGNhdXNlZCB0aGUgYmluZGluZyBvbiB0aGUgPHNlbGVjdD5cblx0XHRcdC8vIHRvIHVwZGF0ZSAtIHRoZW4gd2Ugc3RhcnQgb3ZlclxuXHRcdFx0aWYgKCBiYXRjaC52aWV3bW9kZWxzLmxlbmd0aCApXG5cdFx0XHRcdHJldHVybiBmbHVzaENoYW5nZXMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKSB7XG5cdFx0XHR2YXIgaSwgaXRlbSwga2V5cGF0aCwgcmVzb2x2ZWQ7XG5cdFx0XHRpID0gdW5yZXNvbHZlZC5sZW5ndGg7XG5cdFx0XHQvLyBzZWUgaWYgd2UgY2FuIHJlc29sdmUgYW55IHVucmVzb2x2ZWQgcmVmZXJlbmNlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGl0ZW0gPSB1bnJlc29sdmVkWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5rZXlwYXRoICkge1xuXHRcdFx0XHRcdC8vIGl0IHJlc29sdmVkIHNvbWUgb3RoZXIgd2F5LiBUT0RPIGhvdz8gdHdvLXdheSBiaW5kaW5nPyBTZWVtc1xuXHRcdFx0XHRcdC8vIHdlaXJkIHRoYXQgd2UnZCBzdGlsbCBlbmQgdXAgaGVyZVxuXHRcdFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggaXRlbS5yb290LCBpdGVtLnJlZiwgaXRlbS5wYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRcdCggcmVzb2x2ZWQgfHwgKCByZXNvbHZlZCA9IFtdICkgKS5wdXNoKCB7XG5cdFx0XHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR1bnJlc29sdmVkLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlc29sdmVkICkge1xuXHRcdFx0XHRyZXNvbHZlZC5mb3JFYWNoKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSggcmVzb2x2ZWQgKSB7XG5cdFx0XHRyZXNvbHZlZC5pdGVtLnJlc29sdmUoIHJlc29sdmVkLmtleXBhdGggKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjaXJjdWxhciwgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgcmVtb3ZlRnJvbUFycmF5LCBQcm9taXNlLCByZXNvbHZlUmVmLCBUcmFuc2l0aW9uTWFuYWdlciApO1xuXG5cdC8qIHV0aWxzL2NyZWF0ZUJyYW5jaC5qcyAqL1xuXHR2YXIgY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbnVtZXJpYyA9IC9eXFxzKlswLTldK1xccyokLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBudW1lcmljLnRlc3QoIGtleSApID8gW10gOiB7fTtcblx0XHR9O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvbWFnaWNBZGFwdG9yLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciA9IGZ1bmN0aW9uKCBydW5sb29wLCBjcmVhdGVCcmFuY2gsIGlzQXJyYXkgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHRcdG1hZ2ljQWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFdyYXBwZXIsIHBhcmVudFZhbHVlO1xuXHRcdFx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgdmFsdWUgaXMgYSB3cmFwcGVyLCBvdGhlciB0aGFuIGEgbWFnaWMgd3JhcHBlcixcblx0XHRcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG5cdFx0XHRcdFx0aWYgKCAoIHBhcmVudFdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSAmJiAhcGFyZW50V3JhcHBlci5tYWdpYyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRcdC8vIGlmIHBhcmVudFZhbHVlIGlzIGFuIGFycmF5IHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoaXMgbWVtYmVyLFxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG5cdFx0XHRcdFx0aWYgKCBpc0FycmF5KCBwYXJlbnRWYWx1ZSApICYmIC9eWzAtOV0rJC8udGVzdCgga2V5ICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljV3JhcHBlciggcmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGtleXMsIG9iaktleXBhdGgsIHRlbXBsYXRlLCBzaWJsaW5ncztcblx0XHRcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHR0aGlzLnByb3AgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRvYmpLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoID8gcmFjdGl2ZS5nZXQoIG9iaktleXBhdGggKSA6IHJhY3RpdmUuZGF0YTtcblx0XHRcdFx0dGVtcGxhdGUgPSB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMub2JqLCB0aGlzLnByb3AgKTtcblx0XHRcdFx0Ly8gSGFzIHRoaXMgcHJvcGVydHkgYWxyZWFkeSBiZWVuIHdyYXBwZWQ/XG5cdFx0XHRcdGlmICggdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0ICYmICggc2libGluZ3MgPSB0ZW1wbGF0ZS5zZXQuX3JhY3RpdmVXcmFwcGVycyApICkge1xuXHRcdFx0XHRcdC8vIFllcy4gUmVnaXN0ZXIgdGhpcyB3cmFwcGVyIHRvIHRoaXMgcHJvcGVydHksIGlmIGl0IGhhc24ndCBiZWVuIGFscmVhZHlcblx0XHRcdFx0XHRpZiAoIHNpYmxpbmdzLmluZGV4T2YoIHRoaXMgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRzaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBObywgaXQgaGFzbid0IGJlZW4gd3JhcHBlZFxuXHRcdFx0XHRjcmVhdGVBY2Nlc3NvcnMoIHRoaXMsIHZhbHVlLCB0ZW1wbGF0ZSApO1xuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHQvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucmFjdGl2ZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXRoaXMub2JqWyB0aGlzLnByb3AgXSApIHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gY3JlYXRlQnJhbmNoKCBrZXkgKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG5cdFx0XHRcdFx0Ly8gcmVzdWx0IG9mIGEgc2V0KCkvdXBkYXRlKCkgY2FsbCBtYWRlIGJ5IHRoaXMgd3JhcHBlciwgd2UgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdFx0Ly8gc28gdGhhdCBpdCBkb2Vzbid0IGdldCB0b3JuIGRvd25cblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcy5vYmosIHRoaXMucHJvcCApO1xuXHRcdFx0XHRcdHNldCA9IHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldDtcblx0XHRcdFx0XHRpZiAoICFzZXQgKSB7XG5cdFx0XHRcdFx0XHQvLyBtb3N0IGxpa2VseSwgdGhpcyB3YXMgYW4gYXJyYXkgbWVtYmVyIHRoYXQgd2FzIHNwbGljZWQgb3V0XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cdFx0XHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuXHRcdFx0XHRcdGlmICggIXdyYXBwZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbIHRoaXMucHJvcCBdO1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG5cdFx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bWFnaWNBZGFwdG9yID0gZmFsc2U7XG5cdFx0fVxuXHRcdF9fZXhwb3J0ID0gbWFnaWNBZGFwdG9yO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQWNjZXNzb3JzKCBvcmlnaW5hbFdyYXBwZXIsIHZhbHVlLCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBvYmplY3QsIHByb3BlcnR5LCBvbGRHZXQsIG9sZFNldCwgZ2V0LCBzZXQ7XG5cdFx0XHRvYmplY3QgPSBvcmlnaW5hbFdyYXBwZXIub2JqO1xuXHRcdFx0cHJvcGVydHkgPSBvcmlnaW5hbFdyYXBwZXIucHJvcDtcblx0XHRcdC8vIElzIHRoaXMgdGVtcGxhdGUgY29uZmlndXJhYmxlP1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29uZmlndXJhYmxlICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBhcnJheSBsZW5ndGhcblx0XHRcdFx0aWYgKCBwcm9wZXJ0eSA9PT0gJ2xlbmd0aCcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCB1c2UgbWFnaWMgbW9kZSB3aXRoIHByb3BlcnR5IFwiJyArIHByb3BlcnR5ICsgJ1wiIC0gb2JqZWN0IGlzIG5vdCBjb25maWd1cmFibGUnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lIHRvIHdyYXAgdGhpcyBwcm9wZXJ0eVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0b2xkR2V0ID0gdGVtcGxhdGUuZ2V0O1xuXHRcdFx0XHRvbGRTZXQgPSB0ZW1wbGF0ZS5zZXQ7XG5cdFx0XHR9XG5cdFx0XHRnZXQgPSBvbGRHZXQgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH07XG5cdFx0XHRzZXQgPSBmdW5jdGlvbiggdiApIHtcblx0XHRcdFx0aWYgKCBvbGRTZXQgKSB7XG5cdFx0XHRcdFx0b2xkU2V0KCB2ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBvbGRHZXQgPyBvbGRHZXQoKSA6IHY7XG5cdFx0XHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzLmZvckVhY2goIHVwZGF0ZVdyYXBwZXIgKTtcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoIHdyYXBwZXIgKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoLCByYWN0aXZlO1xuXHRcdFx0XHR3cmFwcGVyLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGlmICggd3JhcHBlci51cGRhdGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmFjdGl2ZSA9IHdyYXBwZXIucmFjdGl2ZTtcblx0XHRcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblx0XHRcdFx0d3JhcHBlci51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHJhY3RpdmUgKTtcblx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFyaygga2V5cGF0aCApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBDcmVhdGUgYW4gYXJyYXkgb2Ygd3JhcHBlcnMsIGluIGNhc2Ugb3RoZXIga2V5cGF0aHMvcmFjdGl2ZXMgZGVwZW5kIG9uIHRoaXMgcHJvcGVydHkuXG5cdFx0XHQvLyBIYW5kaWx5LCB3ZSBjYW4gc3RvcmUgdGhlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBzZXQgZnVuY3Rpb24uIFlheSBKYXZhU2NyaXB0LlxuXHRcdFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMgPSBbIG9yaWdpbmFsV3JhcHBlciBdO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmplY3QsIHByb3BlcnR5LCB7XG5cdFx0XHRcdGdldDogZ2V0LFxuXHRcdFx0XHRzZXQ6IHNldCxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggcnVubG9vcCwgY3JlYXRlQnJhbmNoLCBpc0FycmF5ICk7XG5cblx0LyogY29uZmlnL21hZ2ljLmpzICovXG5cdHZhciBtYWdpYyA9IGZ1bmN0aW9uKCBtYWdpY0FkYXB0b3IgKSB7XG5cblx0XHRyZXR1cm4gISFtYWdpY0FkYXB0b3I7XG5cdH0oIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yICk7XG5cblx0LyogY29uZmlnL25hbWVzcGFjZXMuanMgKi9cblx0dmFyIG5hbWVzcGFjZXMgPSB7XG5cdFx0aHRtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuXHRcdG1hdGhtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuXHRcdHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHR4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG5cdFx0eG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcblx0fTtcblxuXHQvKiB1dGlscy9jcmVhdGVFbGVtZW50LmpzICovXG5cdHZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHN2ZywgbmFtZXNwYWNlcyApIHtcblxuXHRcdHZhciBjcmVhdGVFbGVtZW50O1xuXHRcdC8vIFRlc3QgZm9yIFNWRyBzdXBwb3J0XG5cdFx0aWYgKCAhc3ZnICkge1xuXHRcdFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCB0eXBlLCBucyApIHtcblx0XHRcdFx0aWYgKCBucyAmJiBucyAhPT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRcdHRocm93ICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG90aGVyIHRoYW4gaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIG9mIHRoaXMgZXJyb3IgaXMgdGhhdCB5b3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIFNWRyBpbiBhbiBvbGRlciBicm93c2VyLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3Qvc3ZnLWFuZC1vbGRlci1icm93c2VycyBmb3IgbW9yZSBpbmZvcm1hdGlvbic7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHR5cGUgKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZSwgbnMgKSB7XG5cdFx0XHRcdGlmICggIW5zIHx8IG5zID09PSBuYW1lc3BhY2VzLmh0bWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCBucywgdHlwZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQ7XG5cdH0oIHN2ZywgbmFtZXNwYWNlcyApO1xuXG5cdC8qIGNvbmZpZy9pc0NsaWVudC5qcyAqL1xuXHR2YXIgaXNDbGllbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCc7XG5cdFx0cmV0dXJuIGlzQ2xpZW50O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvZGVmaW5lUHJvcGVydHkuanMgKi9cblx0dmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24oIGlzQ2xpZW50ICkge1xuXG5cdFx0dmFyIGRlZmluZVByb3BlcnR5O1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHRcdGlmICggaXNDbGllbnQgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCBvciB3ZSdyZSBpbiBJRTggd2hlcmUgeW91IGNhblxuXHRcdFx0Ly8gb25seSB1c2UgaXQgd2l0aCBET00gb2JqZWN0cyAod2hhdCB0aGUgZnVjayB3ZXJlIHlvdSBzbW9raW5nLCBNU0ZUPylcblx0XHRcdGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24oIG9iaiwgcHJvcCwgZGVzYyApIHtcblx0XHRcdFx0b2JqWyBwcm9wIF0gPSBkZXNjLnZhbHVlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlZmluZVByb3BlcnR5O1xuXHR9KCBpc0NsaWVudCApO1xuXG5cdC8qIHV0aWxzL2RlZmluZVByb3BlcnRpZXMuanMgKi9cblx0dmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIGlzQ2xpZW50ICkge1xuXG5cdFx0dmFyIGRlZmluZVByb3BlcnRpZXM7XG5cdFx0dHJ5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB7fSwge1xuXHRcdFx0XHRcdHRlc3Q6IHtcblx0XHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHQvLyBUT0RPIGhvdyBkbyB3ZSBhY2NvdW50IGZvciB0aGlzPyBub01hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpc0NsaWVudCApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIGNyZWF0ZUVsZW1lbnQoICdkaXYnICksIHtcblx0XHRcdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIG9iaiwgcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBwcm9wO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdFx0XHRcdGlmICggcHJvcHMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBvYmosIHByb3AsIHByb3BzWyBwcm9wIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzO1xuXHR9KCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgaXNDbGllbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvYWRkLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9hZGQgPSBmdW5jdGlvbiggaXNOdW1lcmljICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFkZCggcm9vdCwga2V5cGF0aCwgZCApIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnIHx8ICFpc051bWVyaWMoIGQgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQmFkIGFyZ3VtZW50cycgKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gK3Jvb3QuZ2V0KCBrZXlwYXRoICkgfHwgMDtcblx0XHRcdGlmICggIWlzTnVtZXJpYyggdmFsdWUgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IGFkZCB0byBhIG5vbi1udW1lcmljIHZhbHVlJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJvb3Quc2V0KCBrZXlwYXRoLCB2YWx1ZSArIGQgKTtcblx0XHR9O1xuXHR9KCBpc051bWVyaWMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9hZGQuanMgKi9cblx0dmFyIFJhY3RpdmUkYWRkID0gZnVuY3Rpb24oIGFkZCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGFkZCgga2V5cGF0aCwgZCApIHtcblx0XHRcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IDEgOiArZCApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2FkZCApO1xuXG5cdC8qIHV0aWxzL25vcm1hbGlzZUtleXBhdGguanMgKi9cblx0dmFyIG5vcm1hbGlzZUtleXBhdGggPSBmdW5jdGlvbiggbm9ybWFsaXNlUmVmICkge1xuXG5cdFx0dmFyIGxlYWRpbmdEb3QgPSAvXlxcLisvO1xuXHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIG5vcm1hbGlzZVJlZigga2V5cGF0aCApLnJlcGxhY2UoIGxlYWRpbmdEb3QsICcnICk7XG5cdFx0fTtcblx0fSggbm9ybWFsaXNlUmVmICk7XG5cblx0LyogY29uZmlnL3ZlbmRvcnMuanMgKi9cblx0dmFyIHZlbmRvcnMgPSBbXG5cdFx0J28nLFxuXHRcdCdtcycsXG5cdFx0J21veicsXG5cdFx0J3dlYmtpdCdcblx0XTtcblxuXHQvKiB1dGlscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMgKi9cblx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQvLyBJZiB3aW5kb3cgZG9lc24ndCBleGlzdCwgd2UgZG9uJ3QgbmVlZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcblx0XHRcdCggZnVuY3Rpb24oIHZlbmRvcnMsIGxhc3RUaW1lLCB3aW5kb3cgKSB7XG5cdFx0XHRcdHZhciB4LCBzZXRUaW1lb3V0O1xuXHRcdFx0XHRpZiAoIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCApIHtcblx0XHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93WyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHRcdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuXHRcdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VyclRpbWUsIHRpbWVUb0NhbGwsIGlkO1xuXHRcdFx0XHRcdFx0Y3VyclRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdFx0dGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XG5cdFx0XHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XG5cdFx0XHRcdFx0XHR9LCB0aW1lVG9DYWxsICk7XG5cdFx0XHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcblx0XHRcdFx0XHRcdHJldHVybiBpZDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9KCB2ZW5kb3JzLCAwLCB3aW5kb3cgKSApO1xuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHV0aWxzL2dldFRpbWUuanMgKi9cblx0dmFyIGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBnZXRUaW1lO1xuXHRcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Z2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gRGF0ZS5ub3coKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBnZXRUaW1lO1xuXHR9KCk7XG5cblx0Lyogc2hhcmVkL2FuaW1hdGlvbnMuanMgKi9cblx0dmFyIGFuaW1hdGlvbnMgPSBmdW5jdGlvbiggckFGLCBnZXRUaW1lLCBydW5sb29wICkge1xuXG5cdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB7XG5cdFx0XHR0aWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGksIGFuaW1hdGlvbiwgbm93O1xuXHRcdFx0XHRub3cgPSBnZXRUaW1lKCk7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVsgaSBdO1xuXHRcdFx0XHRcdGlmICggIWFuaW1hdGlvbi50aWNrKCBub3cgKSApIHtcblx0XHRcdFx0XHRcdC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCBhbmQgZGVjcmVtZW50IGkgc28gd2UgZG9uJ3QgbWlzcyBvbmVcblx0XHRcdFx0XHRcdHF1ZXVlLnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdGlmICggcXVldWUubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJBRiggYW5pbWF0aW9ucy50aWNrICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XG5cdFx0XHRcdHF1ZXVlLnB1c2goIGFuaW1hdGlvbiApO1xuXHRcdFx0XHRpZiAoICFhbmltYXRpb25zLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRyQUYoIGFuaW1hdGlvbnMudGljayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVE9ETyBvcHRpbWlzZSB0aGlzXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oIGtleXBhdGgsIHJvb3QgKSB7XG5cdFx0XHRcdHZhciBpID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0XHRcdGFuaW1hdGlvbjtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gcXVldWVbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbi5yb290ID09PSByb290ICYmIGFuaW1hdGlvbi5rZXlwYXRoID09PSBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBhbmltYXRpb25zO1xuXHR9KCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGdldFRpbWUsIHJ1bmxvb3AgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvdHJhbnNmb3JtLmpzICovXG5cdHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgc2VsZWN0b3JzUGF0dGVybiA9IC8oPzpefFxcfSk/XFxzKihbXlxce1xcfV0rKVxccypcXHsvZyxcblx0XHRcdGNvbW1lbnRzUGF0dGVybiA9IC9cXC9cXCouKj9cXCpcXC8vZyxcblx0XHRcdHNlbGVjdG9yVW5pdFBhdHRlcm4gPSAvKCg/Oig/OlxcW1teXFxdK11cXF0pfCg/OlteXFxzXFwrXFw+XFx+Ol0pKSspKCg/OjpbXlxcc1xcK1xcPlxcfl0rKT9cXHMqW1xcc1xcK1xcPlxcfl0/KVxccyovZyxcblx0XHRcdG1lZGlhUXVlcnlQYXR0ZXJuID0gL15AbWVkaWEvLFxuXHRcdFx0ZGF0YVJ2Y0d1aWRQYXR0ZXJuID0gL1xcW2RhdGEtcnZjZ3VpZD1cIlthLXowLTktXStcIl0vZztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyggY3NzLCBndWlkICkge1xuXHRcdFx0dmFyIHRyYW5zZm9ybWVkLCBhZGRHdWlkO1xuXHRcdFx0YWRkR3VpZCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0dmFyIHNlbGVjdG9yVW5pdHMsIG1hdGNoLCB1bml0LCBkYXRhQXR0ciwgYmFzZSwgcHJlcGVuZGVkLCBhcHBlbmRlZCwgaSwgdHJhbnNmb3JtZWQgPSBbXTtcblx0XHRcdFx0c2VsZWN0b3JVbml0cyA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIG1hdGNoID0gc2VsZWN0b3JVbml0UGF0dGVybi5leGVjKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHNlbGVjdG9yVW5pdHMucHVzaCgge1xuXHRcdFx0XHRcdFx0c3RyOiBtYXRjaFsgMCBdLFxuXHRcdFx0XHRcdFx0YmFzZTogbWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdG1vZGlmaWVyczogbWF0Y2hbIDIgXVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBGb3IgZWFjaCBzaW1wbGUgc2VsZWN0b3Igd2l0aGluIHRoZSBzZWxlY3Rvciwgd2UgbmVlZCB0byBjcmVhdGUgYSB2ZXJzaW9uXG5cdFx0XHRcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgZ3VpZCwgYW5kIGIpIGlzIGluc2lkZSB0aGUgZ3VpZFxuXHRcdFx0XHRkYXRhQXR0ciA9ICdbZGF0YS1ydmNndWlkPVwiJyArIGd1aWQgKyAnXCJdJztcblx0XHRcdFx0YmFzZSA9IHNlbGVjdG9yVW5pdHMubWFwKCBleHRyYWN0U3RyaW5nICk7XG5cdFx0XHRcdGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YXBwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cdFx0XHRcdFx0Ly8gUHNldWRvLXNlbGVjdG9ycyBzaG91bGQgZ28gYWZ0ZXIgdGhlIGF0dHJpYnV0ZSBzZWxlY3RvclxuXHRcdFx0XHRcdHVuaXQgPSBzZWxlY3RvclVuaXRzWyBpIF07XG5cdFx0XHRcdFx0YXBwZW5kZWRbIGkgXSA9IHVuaXQuYmFzZSArIGRhdGFBdHRyICsgdW5pdC5tb2RpZmllcnMgfHwgJyc7XG5cdFx0XHRcdFx0cHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXHRcdFx0XHRcdHByZXBlbmRlZFsgaSBdID0gZGF0YUF0dHIgKyAnICcgKyBwcmVwZW5kZWRbIGkgXTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZC5wdXNoKCBhcHBlbmRlZC5qb2luKCAnICcgKSwgcHJlcGVuZGVkLmpvaW4oICcgJyApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRyYW5zZm9ybWVkLmpvaW4oICcsICcgKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoIGRhdGFSdmNHdWlkUGF0dGVybi50ZXN0KCBjc3MgKSApIHtcblx0XHRcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZSggZGF0YVJ2Y0d1aWRQYXR0ZXJuLCAnW2RhdGEtcnZjZ3VpZD1cIicgKyBndWlkICsgJ1wiXScgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoIGNvbW1lbnRzUGF0dGVybiwgJycgKS5yZXBsYWNlKCBzZWxlY3RvcnNQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3RvcnMsIHRyYW5zZm9ybWVkO1xuXHRcdFx0XHRcdC8vIGRvbid0IHRyYW5zZm9ybSBtZWRpYSBxdWVyaWVzIVxuXHRcdFx0XHRcdGlmICggbWVkaWFRdWVyeVBhdHRlcm4udGVzdCggJDEgKSApXG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdFx0c2VsZWN0b3JzID0gJDEuc3BsaXQoICcsJyApLm1hcCggdHJpbSApO1xuXHRcdFx0XHRcdHRyYW5zZm9ybWVkID0gc2VsZWN0b3JzLm1hcCggYWRkR3VpZCApLmpvaW4oICcsICcgKSArICcgJztcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSggJDEsIHRyYW5zZm9ybWVkICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJpbSggc3RyICkge1xuXHRcdFx0aWYgKCBzdHIudHJpbSApIHtcblx0XHRcdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9eXFxzKy8sICcnICkucmVwbGFjZSggL1xccyskLywgJycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRyYWN0U3RyaW5nKCB1bml0ICkge1xuXHRcdFx0cmV0dXJuIHVuaXQuc3RyO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvY3NzLmpzICovXG5cdHZhciBjc3MgPSBmdW5jdGlvbiggdHJhbnNmb3JtQ3NzICkge1xuXG5cdFx0dmFyIGNzc0NvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICdjc3MnLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBndWlkID0gcHJvdG8uY29uc3RydWN0b3IuX2d1aWQsXG5cdFx0XHRcdGNzcztcblx0XHRcdGlmICggY3NzID0gZ2V0Q3NzKCBvcHRpb25zLmNzcywgb3B0aW9ucywgZ3VpZCApIHx8IGdldENzcyggUGFyZW50LmNzcywgUGFyZW50LCBndWlkICkgKSB7XG5cdFx0XHRcdHByb3RvLmNvbnN0cnVjdG9yLmNzcyA9IGNzcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDc3MoIGNzcywgdGFyZ2V0LCBndWlkICkge1xuXHRcdFx0aWYgKCAhY3NzICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm5vQ3NzVHJhbnNmb3JtID8gY3NzIDogdHJhbnNmb3JtQ3NzKCBjc3MsIGd1aWQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNzc0NvbmZpZztcblx0fSggdHJhbnNmb3JtICk7XG5cblx0LyogdXRpbHMvd3JhcE1ldGhvZC5qcyAqL1xuXHR2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIG1ldGhvZCwgc3VwZXJNZXRob2QsIGZvcmNlICkge1xuXHRcdFx0aWYgKCBmb3JjZSB8fCBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaGFzU3VwZXIgPSAnX3N1cGVyJyBpbiB0aGlzLFxuXHRcdFx0XHRcdFx0X3N1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblx0XHRcdFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGlmICggaGFzU3VwZXIgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG5lZWRzU3VwZXIoIG1ldGhvZCwgc3VwZXJNZXRob2QgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHN1cGVyTWV0aG9kID09PSAnZnVuY3Rpb24nICYmIC9fc3VwZXIvLnRlc3QoIG1ldGhvZCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9kYXRhLmpzICovXG5cdHZhciBkYXRhID0gZnVuY3Rpb24oIHdyYXAgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGRhdGFDb25maWcgPSB7XG5cdFx0XHRuYW1lOiAnZGF0YScsXG5cdFx0XHRleHRlbmQ6IGV4dGVuZCxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZXNldDogcmVzZXRcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZGF0YUNvbmZpZztcblxuXHRcdGZ1bmN0aW9uIGNvbWJpbmUoIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9ucy5kYXRhIHx8IHt9LFxuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGdldEFkZGVkS2V5cyggUGFyZW50LnByb3RvdHlwZS5kYXRhICk7XG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnZGF0YSBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgXCInICsgdmFsdWUgKyAnXCIgaXMgbm90IHZhbGlkJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRpc3BhdGNoKCBwYXJlbnRWYWx1ZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRwcm90by5kYXRhID0gY29tYmluZSggUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXQoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSxcblx0XHRcdFx0cmVzdWx0ID0gY29tYmluZSggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHRpZiAoIHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jYWxsKCByYWN0aXZlLCB2YWx1ZSApIHx8IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhY3RpdmUuZGF0YSA9IHJlc3VsdCB8fCB7fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNldCggcmFjdGl2ZSApIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmluaXQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHJhY3RpdmUgKTtcblx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRyYWN0aXZlLmRhdGEgPSByZXN1bHQ7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEFkZGVkS2V5cyggcGFyZW50ICkge1xuXHRcdFx0Ly8gb25seSBmb3IgZnVuY3Rpb25zIHRoYXQgaGFkIGtleXMgYWRkZWRcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyB8fCAhT2JqZWN0LmtleXMoIHBhcmVudCApLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHRcdH1cblx0XHRcdC8vIGNvcHkgdGhlIGFkZGVkIGtleXMgdG8gdGVtcCAnb2JqZWN0Jywgb3RoZXJ3aXNlXG5cdFx0XHQvLyBwYXJlbnQgd291bGQgYmUgaW50ZXJwcmV0ZWQgYXMgJ2Z1bmN0aW9uJyBieSBkaXNwYXRjaFxuXHRcdFx0dmFyIHRlbXAgPSB7fTtcblx0XHRcdGNvcHkoIHBhcmVudCwgdGVtcCApO1xuXHRcdFx0Ly8gcm9sbCBpbiBhZGRlZCBrZXlzXG5cdFx0XHRyZXR1cm4gZGlzcGF0Y2goIHBhcmVudCwgdGVtcCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3BhdGNoKCBwYXJlbnQsIGNoaWxkICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBleHRlbmRGbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGZyb21GbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29weSggZnJvbSwgdG8sIGZpbGxPbmx5ICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBmcm9tICkge1xuXHRcdFx0XHRpZiAoIGZpbGxPbmx5ICYmIGtleSBpbiB0byApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1sga2V5IF0gPSBmcm9tWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tUHJvcGVydGllcyggY2hpbGQsIHBhcmVudCApIHtcblx0XHRcdGNoaWxkID0gY2hpbGQgfHwge307XG5cdFx0XHRpZiAoICFwYXJlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNvcHkoIHBhcmVudCwgY2hpbGQsIHRydWUgKTtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tRm4oIGNoaWxkLCBwYXJlbnRGbiApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0dmFyIGtleXM7XG5cdFx0XHRcdGlmICggY2hpbGQgKSB7XG5cdFx0XHRcdFx0Ly8gVHJhY2sgdGhlIGtleXMgdGhhdCBvdXIgb24gdGhlIGNoaWxkLFxuXHRcdFx0XHRcdC8vIGJ1dCBub3Qgb24gdGhlIGRhdGEuIFdlJ2xsIG5lZWQgdG8gYXBwbHkgdGhlc2Vcblx0XHRcdFx0XHQvLyBhZnRlciB0aGUgcGFyZW50IGZ1bmN0aW9uIHJldHVybnMuXG5cdFx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2hpbGQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFkYXRhIHx8ICEoIGtleSBpbiBkYXRhICkgKSB7XG5cdFx0XHRcdFx0XHRcdGtleXMucHVzaCgga2V5ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNhbGwgdGhlIHBhcmVudCBmbiwgdXNlIGRhdGEgaWYgbm8gcmV0dXJuIHZhbHVlXG5cdFx0XHRcdGRhdGEgPSBwYXJlbnRGbi5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0Ly8gQ29weSBjaGlsZCBrZXlzIGJhY2sgb250byBkYXRhLiBUaGUgY2hpbGQga2V5c1xuXHRcdFx0XHQvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgd2hhdGV2ZXIgdGhlXG5cdFx0XHRcdC8vIHBhcmVudCBkaWQgd2l0aCB0aGUgZGF0YS5cblx0XHRcdFx0aWYgKCBrZXlzICYmIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gY2hpbGRbIGtleSBdO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kRm4oIGNoaWxkRm4sIHBhcmVudCApIHtcblx0XHRcdHZhciBwYXJlbnRGbjtcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gY29weSBwcm9wcyB0byBkYXRhXG5cdFx0XHRcdHBhcmVudEZuID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdFx0ZnJvbVByb3BlcnRpZXMoIGRhdGEsIHBhcmVudCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyZW50Rm4gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHQvLyBnaXZlIHBhcmVudCBmdW5jdGlvbiBpdCdzIG93biB0aGlzLl9zdXBlciBjb250ZXh0LFxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB0aGlzLl9zdXBlciBpcyBmcm9tIGNoaWxkIGFuZFxuXHRcdFx0XHRcdC8vIGNhdXNlcyBpbmZpbml0ZSBsb29wXG5cdFx0XHRcdFx0cGFyZW50ID0gd3JhcCggcGFyZW50LCBmdW5jdGlvbigpIHt9LCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3cmFwKCBjaGlsZEZuLCBwYXJlbnRGbiApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdyYXBNZXRob2QgKTtcblxuXHQvKiBjb25maWcvdHlwZXMuanMgKi9cblx0dmFyIHR5cGVzID0ge1xuXHRcdFRFWFQ6IDEsXG5cdFx0SU5URVJQT0xBVE9SOiAyLFxuXHRcdFRSSVBMRTogMyxcblx0XHRTRUNUSU9OOiA0LFxuXHRcdElOVkVSVEVEOiA1LFxuXHRcdENMT1NJTkc6IDYsXG5cdFx0RUxFTUVOVDogNyxcblx0XHRQQVJUSUFMOiA4LFxuXHRcdENPTU1FTlQ6IDksXG5cdFx0REVMSU1DSEFOR0U6IDEwLFxuXHRcdE1VU1RBQ0hFOiAxMSxcblx0XHRUQUc6IDEyLFxuXHRcdEFUVFJJQlVURTogMTMsXG5cdFx0Q0xPU0lOR19UQUc6IDE0LFxuXHRcdENPTVBPTkVOVDogMTUsXG5cdFx0TlVNQkVSX0xJVEVSQUw6IDIwLFxuXHRcdFNUUklOR19MSVRFUkFMOiAyMSxcblx0XHRBUlJBWV9MSVRFUkFMOiAyMixcblx0XHRPQkpFQ1RfTElURVJBTDogMjMsXG5cdFx0Qk9PTEVBTl9MSVRFUkFMOiAyNCxcblx0XHRHTE9CQUw6IDI2LFxuXHRcdEtFWV9WQUxVRV9QQUlSOiAyNyxcblx0XHRSRUZFUkVOQ0U6IDMwLFxuXHRcdFJFRklORU1FTlQ6IDMxLFxuXHRcdE1FTUJFUjogMzIsXG5cdFx0UFJFRklYX09QRVJBVE9SOiAzMyxcblx0XHRCUkFDS0VURUQ6IDM0LFxuXHRcdENPTkRJVElPTkFMOiAzNSxcblx0XHRJTkZJWF9PUEVSQVRPUjogMzYsXG5cdFx0SU5WT0NBVElPTjogNDAsXG5cdFx0U0VDVElPTl9JRjogNTAsXG5cdFx0U0VDVElPTl9VTkxFU1M6IDUxLFxuXHRcdFNFQ1RJT05fRUFDSDogNTIsXG5cdFx0U0VDVElPTl9XSVRIOiA1Myxcblx0XHRTRUNUSU9OX0lGX1dJVEg6IDU0XG5cdH07XG5cblx0LyogdXRpbHMvY3JlYXRlLmpzICovXG5cdHZhciBjcmVhdGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjcmVhdGU7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHRcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdC8vIHNpZ2hcblx0XHRcdGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgRiA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggcHJvdG8sIHByb3BzICkge1xuXHRcdFx0XHRcdHZhciBvYmo7XG5cdFx0XHRcdFx0aWYgKCBwcm90byA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdFx0XHRvYmogPSBuZXcgRigpO1xuXHRcdFx0XHRcdGlmICggcHJvcHMgKSB7XG5cdFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggb2JqLCBwcm9wcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlO1xuXHR9KCk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9lcnJvcnMuanMgKi9cblx0dmFyIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzID0ge1xuXHRcdGV4cGVjdGVkRXhwcmVzc2lvbjogJ0V4cGVjdGVkIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uJyxcblx0XHRleHBlY3RlZFBhcmVuOiAnRXhwZWN0ZWQgY2xvc2luZyBwYXJlbidcblx0fTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL251bWJlckxpdGVyYWwuanMgKi9cblx0dmFyIG51bWJlckxpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgbnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pKD86KD86KD86MHxbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKCByZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuTlVNQkVSX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvYm9vbGVhbkxpdGVyYWwuanMgKi9cblx0dmFyIGJvb2xlYW5MaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCA0ICkgPT09ICd0cnVlJyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyArPSA0O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkJPT0xFQU5fTElURVJBTCxcblx0XHRcdFx0XHR2OiAndHJ1ZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgNSApID09PSAnZmFsc2UnICkge1xuXHRcdFx0XHRwYXJzZXIucG9zICs9IDU7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQk9PTEVBTl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6ICdmYWxzZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL21ha2VRdW90ZWRTdHJpbmdNYXRjaGVyLmpzICovXG5cdHZhciBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cdFx0Ly8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuXHRcdC8vIEVPTC9FT0YgaXMgd3JpdHRlbiBhcyAoPyEuKSAobWVhbmluZyB0aGVyZSdzIG5vIG5vbi1uZXdsaW5lIGNoYXIgbmV4dCkuXG5cdFx0c3RyaW5nTWlkZGxlUGF0dGVybiA9IC9eKD89LilbXlwiJ1xcXFxdKz8oPzooPyEuKXwoPz1bXCInXFxcXF0pKS87XG5cdFx0Ly8gTWF0Y2ggb25lIGVzY2FwZSBzZXF1ZW5jZSwgaW5jbHVkaW5nIHRoZSBiYWNrc2xhc2guXG5cdFx0ZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblx0XHQvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuXHRcdGxpbmVDb250aW51YXRpb25QYXR0ZXJuID0gL15cXFxcKD86XFxyXFxufFtcXHUwMDBBXFx1MDAwRFxcdTIwMjhcXHUyMDI5XSkvO1xuXHRcdC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgZ2V0RG91YmxlUXVvdGVkU3RyaW5nIGFuZCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBva1F1b3RlICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBzdGFydCwgbGl0ZXJhbCwgZG9uZSwgbmV4dDtcblx0XHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRsaXRlcmFsID0gJ1wiJztcblx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHR3aGlsZSAoICFkb25lICkge1xuXHRcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzdHJpbmdNaWRkbGVQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggZXNjYXBlU2VxdWVuY2VQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKCBva1F1b3RlICk7XG5cdFx0XHRcdFx0aWYgKCBuZXh0ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBuZXh0ID09PSAnXCInICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXFxcXCInO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gJ1xcXFxcXCcnICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXCcnO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbGluZUNvbnRpbnVhdGlvblBhdHRlcm4gKTtcblx0XHRcdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29udmVydCBcXChuZXdsaW5lLWxpa2UpIGludG8gYSBcXHUgZXNjYXBlLCB3aGljaCBpcyBhbGxvd2VkIGluIEpTT05cblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFxcXHUnICsgKCAnMDAwJyArIG5leHQuY2hhckNvZGVBdCggMSApLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC00ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGl0ZXJhbCArPSAnXCInO1xuXHRcdFx0XHQvLyB1c2UgSlNPTi5wYXJzZSB0byBpbnRlcnByZXQgZXNjYXBlc1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSggbGl0ZXJhbCApO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL3NpbmdsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgc2luZ2xlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXCInICk7XG5cdH0oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL2RvdWJsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgZG91YmxlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXFwnJyApO1xuXHR9KCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9fc3RyaW5nTGl0ZXJhbC5qcyAqL1xuXHR2YXIgc3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLCBnZXREb3VibGVRdW90ZWRTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgc3RyaW5nO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdcIicgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXCInICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuU1RSSU5HX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogc3RyaW5nXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1xcJycgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0U2luZ2xlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXFwnJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlNUUklOR19MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHN0cmluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMsIHNpbmdsZVF1b3RlZFN0cmluZywgZG91YmxlUXVvdGVkU3RyaW5nICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9wYXR0ZXJucy5qcyAqL1xuXHR2YXIgcGF0dGVybnMgPSB7XG5cdFx0bmFtZTogL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovXG5cdH07XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9rZXkuanMgKi9cblx0dmFyIGtleSA9IGZ1bmN0aW9uKCBnZXRTdHJpbmdMaXRlcmFsLCBnZXROdW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApIHtcblxuXHRcdHZhciBpZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcblx0XHQvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXByb3BlcnRpZXNcblx0XHQvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRva2VuO1xuXHRcdFx0aWYgKCB0b2tlbiA9IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gaWRlbnRpZmllci50ZXN0KCB0b2tlbi52ICkgPyB0b2tlbi52IDogJ1wiJyArIHRva2VuLnYucmVwbGFjZSggL1wiL2csICdcXFxcXCInICkgKyAnXCInO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0b2tlbiA9IGdldE51bWJlckxpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW4udjtcblx0XHRcdH1cblx0XHRcdGlmICggdG9rZW4gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBzdHJpbmdMaXRlcmFsLCBudW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9rZXlWYWx1ZVBhaXIuanMgKi9cblx0dmFyIGtleVZhbHVlUGFpciA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGtleSA9IGdldEtleSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIGtleSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSAnOidcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBleHByZXNzaW9uIG11c3QgYmUgYSwgd2VsbC4uLiBleHByZXNzaW9uXG5cdFx0XHR2YWx1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLktFWV9WQUxVRV9QQUlSLFxuXHRcdFx0XHRrOiBrZXksXG5cdFx0XHRcdHY6IHZhbHVlXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBrZXkgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwva2V5VmFsdWVQYWlycy5qcyAqL1xuXHR2YXIga2V5VmFsdWVQYWlycyA9IGZ1bmN0aW9uKCBnZXRLZXlWYWx1ZVBhaXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBwYWlycywgcGFpciwga2V5VmFsdWVQYWlycztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhaXIgPSBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApO1xuXHRcdFx0aWYgKCBwYWlyID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXJzID0gWyBwYWlyIF07XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAha2V5VmFsdWVQYWlycyApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhaXJzLmNvbmNhdCgga2V5VmFsdWVQYWlycyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhaXJzO1xuXHRcdH07XG5cdH0oIGtleVZhbHVlUGFpciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9fb2JqZWN0TGl0ZXJhbC5qcyAqL1xuXHR2YXIgb2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5VmFsdWVQYWlycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBrZXlWYWx1ZVBhaXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAneycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuT0JKRUNUX0xJVEVSQUwsXG5cdFx0XHRcdG06IGtleVZhbHVlUGFpcnNcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGtleVZhbHVlUGFpcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2V4cHJlc3Npb25MaXN0LmpzICovXG5cdHZhciBleHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uKCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoIGV4cHIgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZXhwcmVzc2lvbnMgPSBbIGV4cHIgXTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBleHByZXNzaW9uIGFuZCAnLCdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0bmV4dCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCBuZXh0ID09PSBudWxsICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQuZm9yRWFjaCggYXBwZW5kICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFwcGVuZCggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0ZXhwcmVzc2lvbnMucHVzaCggZXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuXHRcdH07XG5cdH0oIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9hcnJheUxpdGVyYWwuanMgKi9cblx0dmFyIGFycmF5TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0RXhwcmVzc2lvbkxpc3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSAnWydcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRleHByZXNzaW9uTGlzdCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5BUlJBWV9MSVRFUkFMLFxuXHRcdFx0XHRtOiBleHByZXNzaW9uTGlzdFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgZXhwcmVzc2lvbkxpc3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL19saXRlcmFsLmpzICovXG5cdHZhciBsaXRlcmFsID0gZnVuY3Rpb24oIGdldE51bWJlckxpdGVyYWwsIGdldEJvb2xlYW5MaXRlcmFsLCBnZXRTdHJpbmdMaXRlcmFsLCBnZXRPYmplY3RMaXRlcmFsLCBnZXRBcnJheUxpdGVyYWwgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBsaXRlcmFsID0gZ2V0TnVtYmVyTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0Qm9vbGVhbkxpdGVyYWwoIHBhcnNlciApIHx8IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApIHx8IGdldE9iamVjdExpdGVyYWwoIHBhcnNlciApIHx8IGdldEFycmF5TGl0ZXJhbCggcGFyc2VyICk7XG5cdFx0XHRyZXR1cm4gbGl0ZXJhbDtcblx0XHR9O1xuXHR9KCBudW1iZXJMaXRlcmFsLCBib29sZWFuTGl0ZXJhbCwgc3RyaW5nTGl0ZXJhbCwgb2JqZWN0TGl0ZXJhbCwgYXJyYXlMaXRlcmFsICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvcmVmZXJlbmNlLmpzICovXG5cdHZhciByZWZlcmVuY2UgPSBmdW5jdGlvbiggdHlwZXMsIHBhdHRlcm5zICkge1xuXG5cdFx0dmFyIGRvdFJlZmluZW1lbnRQYXR0ZXJuLCBhcnJheU1lbWJlclBhdHRlcm4sIGdldEFycmF5UmVmaW5lbWVudCwgZ2xvYmFscywga2V5d29yZHM7XG5cdFx0ZG90UmVmaW5lbWVudFBhdHRlcm4gPSAvXlxcLlthLXpBLVpfJDAtOV0rLztcblx0XHRnZXRBcnJheVJlZmluZW1lbnQgPSBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIG51bSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGFycmF5TWVtYmVyUGF0dGVybiApO1xuXHRcdFx0aWYgKCBudW0gKSB7XG5cdFx0XHRcdHJldHVybiAnLicgKyBudW07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eXFxbKDB8WzEtOV1bMC05XSopXFxdLztcblx0XHQvLyBpZiBhIHJlZmVyZW5jZSBpcyBhIGJyb3dzZXIgZ2xvYmFsLCB3ZSBkb24ndCBkZWZlcmVuY2UgaXQgbGF0ZXIsIHNvIGl0IG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50XG5cdFx0Z2xvYmFscyA9IC9eKD86QXJyYXl8Y29uc29sZXxEYXRlfFJlZ0V4cHxkZWNvZGVVUklDb21wb25lbnR8ZGVjb2RlVVJJfGVuY29kZVVSSUNvbXBvbmVudHxlbmNvZGVVUkl8aXNGaW5pdGV8aXNOYU58cGFyc2VGbG9hdHxwYXJzZUludHxKU09OfE1hdGh8TmFOfHVuZGVmaW5lZHxudWxsKSQvO1xuXHRcdC8vIGtleXdvcmRzIGFyZSBub3QgdmFsaWQgcmVmZXJlbmNlcywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGB0aGlzYFxuXHRcdGtleXdvcmRzID0gL14oPzpicmVha3xjYXNlfGNhdGNofGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8cmV0dXJufHN3aXRjaHx0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGgpJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnRQb3MsIGFuY2VzdG9yLCBuYW1lLCBkb3QsIGNvbWJvLCByZWZpbmVtZW50LCBsYXN0RG90SW5kZXg7XG5cdFx0XHRzdGFydFBvcyA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGEgcm9vdC1sZXZlbCByZWZlcmVuY2Vcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnfi8nICkgKSB7XG5cdFx0XHRcdGFuY2VzdG9yID0gJ34vJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHdlIG1pZ2h0IGhhdmUgYW5jZXN0b3IgcmVmcy4uLlxuXHRcdFx0XHRhbmNlc3RvciA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoIHBhcnNlci5tYXRjaFN0cmluZyggJy4uLycgKSApIHtcblx0XHRcdFx0XHRhbmNlc3RvciArPSAnLi4vJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhYW5jZXN0b3IgKSB7XG5cdFx0XHRcdC8vIHdlIG1pZ2h0IGhhdmUgYW4gaW1wbGljaXQgaXRlcmF0b3Igb3IgYSByZXN0cmljdGVkIHJlZmVyZW5jZVxuXHRcdFx0XHRkb3QgPSBwYXJzZXIubWF0Y2hTdHJpbmcoICcuLycgKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuJyApIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIC9eQCg/OmtleXBhdGh8aW5kZXh8a2V5KS8gKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgfHwgJyc7XG5cdFx0XHQvLyBidWcgb3V0IGlmIGl0J3MgYSBrZXl3b3JkXG5cdFx0XHRpZiAoIGtleXdvcmRzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBicm93c2VyIGdsb2JhbCwgc3RvcCBoZXJlXG5cdFx0XHRpZiAoICFhbmNlc3RvciAmJiAhZG90ICYmIGdsb2JhbHMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkdMT0JBTCxcblx0XHRcdFx0XHR2OiBuYW1lXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRjb21ibyA9ICggYW5jZXN0b3IgfHwgZG90ICkgKyBuYW1lO1xuXHRcdFx0aWYgKCAhY29tYm8gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKCByZWZpbmVtZW50ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZG90UmVmaW5lbWVudFBhdHRlcm4gKSB8fCBnZXRBcnJheVJlZmluZW1lbnQoIHBhcnNlciApICkge1xuXHRcdFx0XHRjb21ibyArPSByZWZpbmVtZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIGludm9jYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBmdW5jdGlvbikgd2UgbmVlZFxuXHRcdFx0XHQvLyB0byBzdHJpcCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgcmVmZXJlbmNlIGNvbWJvLCBlbHNlIHRoZSBjb250ZXh0XG5cdFx0XHRcdC8vIHdpbGwgYmUgd3Jvbmdcblx0XHRcdFx0bGFzdERvdEluZGV4ID0gY29tYm8ubGFzdEluZGV4T2YoICcuJyApO1xuXHRcdFx0XHRpZiAoIGxhc3REb3RJbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0Y29tYm8gPSBjb21iby5zdWJzdHIoIDAsIGxhc3REb3RJbmRleCApO1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcyArIGNvbWJvLmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zIC09IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLlJFRkVSRU5DRSxcblx0XHRcdFx0bjogY29tYm8ucmVwbGFjZSggL150aGlzXFwuLywgJy4vJyApLnJlcGxhY2UoIC9edGhpcyQvLCAnLicgKVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGF0dGVybnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9icmFja2V0ZWRFeHByZXNzaW9uLmpzICovXG5cdHZhciBicmFja2V0ZWRFeHByZXNzaW9uID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0ZXhwciA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhZXhwciApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcpJyApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZFBhcmVuICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5CUkFDS0VURUQsXG5cdFx0XHRcdHg6IGV4cHJcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvX3ByaW1hcnkuanMgKi9cblx0dmFyIHByaW1hcnkgPSBmdW5jdGlvbiggZ2V0TGl0ZXJhbCwgZ2V0UmVmZXJlbmNlLCBnZXRCcmFja2V0ZWRFeHByZXNzaW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRyZXR1cm4gZ2V0TGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0UmVmZXJlbmNlKCBwYXJzZXIgKSB8fCBnZXRCcmFja2V0ZWRFeHByZXNzaW9uKCBwYXJzZXIgKTtcblx0XHR9O1xuXHR9KCBsaXRlcmFsLCByZWZlcmVuY2UsIGJyYWNrZXRlZEV4cHJlc3Npb24gKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL3JlZmluZW1lbnQuanMgKi9cblx0dmFyIHJlZmluZW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIGVycm9ycywgcGF0dGVybnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UmVmaW5lbWVudCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBuYW1lLCBleHByO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gXCIuXCIgbmFtZVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuJyApICkge1xuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGlmICggbmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBhdHRlcm5zLm5hbWUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuUkVGSU5FTUVOVCxcblx0XHRcdFx0XHRcdG46IG5hbWVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGEgcHJvcGVydHkgbmFtZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIFwiW1wiIGV4cHJlc3Npb24gXCJdXCJcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdGlmICggIWV4cHIgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIFxcJ11cXCcnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5SRUZJTkVNRU5ULFxuXHRcdFx0XHRcdHg6IGV4cHJcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycywgcGF0dGVybnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvbWVtYmVyT3JJbnZvY2F0aW9uLmpzICovXG5cdHZhciBtZW1iZXJPckludm9jYXRpb24gPSBmdW5jdGlvbiggdHlwZXMsIGdldFByaW1hcnksIGdldEV4cHJlc3Npb25MaXN0LCBnZXRSZWZpbmVtZW50LCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBjdXJyZW50LCBleHByZXNzaW9uLCByZWZpbmVtZW50LCBleHByZXNzaW9uTGlzdDtcblx0XHRcdGV4cHJlc3Npb24gPSBnZXRQcmltYXJ5KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKCBleHByZXNzaW9uICkge1xuXHRcdFx0XHRjdXJyZW50ID0gcGFyc2VyLnBvcztcblx0XHRcdFx0aWYgKCByZWZpbmVtZW50ID0gZ2V0UmVmaW5lbWVudCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLk1FTUJFUixcblx0XHRcdFx0XHRcdHg6IGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0XHRyOiByZWZpbmVtZW50XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbkxpc3QgPSBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICk7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJyknICkgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZFBhcmVuICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5JTlZPQ0FUSU9OLFxuXHRcdFx0XHRcdFx0eDogZXhwcmVzc2lvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKCBleHByZXNzaW9uTGlzdCApIHtcblx0XHRcdFx0XHRcdGV4cHJlc3Npb24ubyA9IGV4cHJlc3Npb25MaXN0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG5cdFx0fTtcblx0fSggdHlwZXMsIHByaW1hcnksIGV4cHJlc3Npb25MaXN0LCByZWZpbmVtZW50LCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy90eXBlb2YuanMgKi9cblx0dmFyIF90eXBlb2YgPSBmdW5jdGlvbiggdHlwZXMsIGVycm9ycywgZ2V0TWVtYmVyT3JJbnZvY2F0aW9uICkge1xuXG5cdFx0dmFyIGdldFR5cGVvZiwgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlcjtcblx0XHRtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24oIHN5bWJvbCwgZmFsbHRocm91Z2ggKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdFx0dmFyIGV4cHJlc3Npb247XG5cdFx0XHRcdGlmICggZXhwcmVzc2lvbiA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHN5bWJvbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0czogc3ltYm9sLFxuXHRcdFx0XHRcdG86IGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0dDogdHlwZXMuUFJFRklYX09QRVJBVE9SXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gY3JlYXRlIGFsbCBwcmVmaXggc2VxdWVuY2UgbWF0Y2hlcnMsIHJldHVybiBnZXRUeXBlb2Zcblx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgcHJlZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblx0XHRcdHByZWZpeE9wZXJhdG9ycyA9ICchIH4gKyAtIHR5cGVvZicuc3BsaXQoICcgJyApO1xuXHRcdFx0ZmFsbHRocm91Z2ggPSBnZXRNZW1iZXJPckludm9jYXRpb247XG5cdFx0XHRmb3IgKCBpID0gMCwgbGVuID0gcHJlZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRtYXRjaGVyID0gbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciggcHJlZml4T3BlcmF0b3JzWyBpIF0sIGZhbGx0aHJvdWdoICk7XG5cdFx0XHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcblx0XHRcdH1cblx0XHRcdC8vIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uLCBzbyBwcm92aWRlcyB0aGVcblx0XHRcdC8vIGZhbGx0aHJvdWdoIGZvciB0aGUgbXVsdGlwbGljYXRpb24gc2VxdWVuY2UgbWF0Y2hlciB3ZSdyZSBhYm91dCB0byBjcmVhdGVcblx0XHRcdC8vICh3ZSdyZSBza2lwcGluZyB2b2lkIGFuZCBkZWxldGUpXG5cdFx0XHRnZXRUeXBlb2YgPSBmYWxsdGhyb3VnaDtcblx0XHR9KCkgKTtcblx0XHRyZXR1cm4gZ2V0VHlwZW9mO1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMsIG1lbWJlck9ySW52b2NhdGlvbiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9sb2dpY2FsT3IuanMgKi9cblx0dmFyIGxvZ2ljYWxPciA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0VHlwZW9mICkge1xuXG5cdFx0dmFyIGdldExvZ2ljYWxPciwgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyO1xuXHRcdG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uKCBzeW1ib2wsIGZhbGx0aHJvdWdoICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBzdGFydCwgbGVmdCwgcmlnaHQ7XG5cdFx0XHRcdGxlZnQgPSBmYWxsdGhyb3VnaCggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIWxlZnQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTG9vcCB0byBoYW5kbGUgbGVmdC1yZWN1cnNpb24gaW4gYSBjYXNlIGxpa2UgYGEgKiBiICogY2AgYW5kIHByb2R1Y2Vcblx0XHRcdFx0Ly8gbGVmdCBhc3NvY2lhdGlvbiwgaS5lLiBgKGEgKiBiKSAqIGNgLiAgVGhlIG1hdGNoZXIgY2FuJ3QgY2FsbCBpdHNlbGZcblx0XHRcdFx0Ly8gdG8gcGFyc2UgYGxlZnRgIGJlY2F1c2UgdGhhdCB3b3VsZCBiZSBpbmZpbml0ZSByZWdyZXNzLlxuXHRcdFx0XHR3aGlsZSAoIHRydWUgKSB7XG5cdFx0XHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHN5bWJvbCApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGluIG9wZXJhdG9yIG11c3Qgbm90IGJlIGZvbGxvd2VkIGJ5IFthLXpBLVpfJDAtOV1cblx0XHRcdFx0XHRpZiAoIHN5bWJvbCA9PT0gJ2luJyAmJiAvW2EtekEtWl8kMC05XS8udGVzdCggcGFyc2VyLnJlbWFpbmluZygpLmNoYXJBdCggMCApICkgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdC8vIHJpZ2h0IG9wZXJhbmQgbXVzdCBhbHNvIGNvbnNpc3Qgb2Ygb25seSBoaWdoZXItcHJlY2VkZW5jZSBvcGVyYXRvcnNcblx0XHRcdFx0XHRyaWdodCA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKTtcblx0XHRcdFx0XHRpZiAoICFyaWdodCApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZWZ0ID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuSU5GSVhfT1BFUkFUT1IsXG5cdFx0XHRcdFx0XHRzOiBzeW1ib2wsXG5cdFx0XHRcdFx0XHRvOiBbXG5cdFx0XHRcdFx0XHRcdGxlZnQsXG5cdFx0XHRcdFx0XHRcdHJpZ2h0XG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIGNyZWF0ZSBhbGwgaW5maXggc2VxdWVuY2UgbWF0Y2hlcnMsIGFuZCByZXR1cm4gZ2V0TG9naWNhbE9yXG5cdFx0KCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpLCBsZW4sIG1hdGNoZXIsIGluZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblx0XHRcdC8vIEFsbCB0aGUgaW5maXggb3BlcmF0b3JzIG9uIG9yZGVyIG9mIHByZWNlZGVuY2UgKHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZSlcblx0XHRcdC8vIEVhY2ggc2VxdWVuY2UgbWF0Y2hlciB3aWxsIGluaXRpYWxseSBmYWxsIHRocm91Z2ggdG8gaXRzIGhpZ2hlciBwcmVjZWRlbmNlXG5cdFx0XHQvLyBuZWlnaGJvdXIsIGFuZCBvbmx5IGF0dGVtcHQgdG8gbWF0Y2ggaWYgb25lIG9mIHRoZSBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnNcblx0XHRcdC8vIChvciwgdWx0aW1hdGVseSwgYSBsaXRlcmFsLCByZWZlcmVuY2UsIG9yIGJyYWNrZXRlZCBleHByZXNzaW9uKSBhbHJlYWR5IG1hdGNoZWRcblx0XHRcdGluZml4T3BlcmF0b3JzID0gJyogLyAlICsgLSA8PCA+PiA+Pj4gPCA8PSA+ID49IGluIGluc3RhbmNlb2YgPT0gIT0gPT09ICE9PSAmIF4gfCAmJiB8fCcuc3BsaXQoICcgJyApO1xuXHRcdFx0Ly8gQSB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvblxuXHRcdFx0ZmFsbHRocm91Z2ggPSBnZXRUeXBlb2Y7XG5cdFx0XHRmb3IgKCBpID0gMCwgbGVuID0gaW5maXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG1hdGNoZXIgPSBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIoIGluZml4T3BlcmF0b3JzWyBpIF0sIGZhbGx0aHJvdWdoICk7XG5cdFx0XHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcblx0XHRcdH1cblx0XHRcdC8vIExvZ2ljYWwgT1IgaXMgdGhlIGZhbGx0aHJvdWdoIGZvciB0aGUgY29uZGl0aW9uYWwgbWF0Y2hlclxuXHRcdFx0Z2V0TG9naWNhbE9yID0gZmFsbHRocm91Z2g7XG5cdFx0fSgpICk7XG5cdFx0cmV0dXJuIGdldExvZ2ljYWxPcjtcblx0fSggdHlwZXMsIF90eXBlb2YgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvY29uZGl0aW9uYWwuanMgKi9cblx0dmFyIGNvbmRpdGlvbmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRMb2dpY2FsT3IsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2U7XG5cdFx0XHRleHByZXNzaW9uID0gZ2V0TG9naWNhbE9yKCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmVHJ1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZUcnVlICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIFwiOlwiJyApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWZGYWxzZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZGYWxzZSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5DT05ESVRJT05BTCxcblx0XHRcdFx0bzogW1xuXHRcdFx0XHRcdGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0aWZUcnVlLFxuXHRcdFx0XHRcdGlmRmFsc2Vcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgbG9naWNhbE9yLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci91dGlscy9mbGF0dGVuRXhwcmVzc2lvbi5qcyAqL1xuXHR2YXIgZmxhdHRlbkV4cHJlc3Npb24gPSBmdW5jdGlvbiggdHlwZXMsIGlzT2JqZWN0ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgcmVmcyA9IFtdLFxuXHRcdFx0XHRmbGF0dGVuZWQ7XG5cdFx0XHRleHRyYWN0UmVmcyggZXhwcmVzc2lvbiwgcmVmcyApO1xuXHRcdFx0ZmxhdHRlbmVkID0ge1xuXHRcdFx0XHRyOiByZWZzLFxuXHRcdFx0XHRzOiBzdHJpbmdpZnkoIHRoaXMsIGV4cHJlc3Npb24sIHJlZnMgKVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiBmbGF0dGVuZWQ7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHF1b3RlU3RyaW5nTGl0ZXJhbCggc3RyICkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCBTdHJpbmcoIHN0ciApICk7XG5cdFx0fVxuXHRcdC8vIFRPRE8gbWF5YmUgcmVmYWN0b3IgdGhpcz9cblx0XHRmdW5jdGlvbiBleHRyYWN0UmVmcyggbm9kZSwgcmVmcyApIHtcblx0XHRcdHZhciBpLCBsaXN0O1xuXHRcdFx0aWYgKCBub2RlLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0aWYgKCByZWZzLmluZGV4T2YoIG5vZGUubiApID09PSAtMSApIHtcblx0XHRcdFx0XHRyZWZzLnVuc2hpZnQoIG5vZGUubiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaXN0ID0gbm9kZS5vIHx8IG5vZGUubTtcblx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0aWYgKCBpc09iamVjdCggbGlzdCApICkge1xuXHRcdFx0XHRcdGV4dHJhY3RSZWZzKCBsaXN0LCByZWZzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0ZXh0cmFjdFJlZnMoIGxpc3RbIGkgXSwgcmVmcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnggKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLngsIHJlZnMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS5yICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS5yLCByZWZzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUudiApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUudiwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLCByZWZzICkge1xuXHRcdFx0dmFyIHN0cmluZ2lmeUFsbCA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIGl0ZW0sIHJlZnMgKTtcblx0XHRcdH07XG5cdFx0XHRzd2l0Y2ggKCBub2RlLnQgKSB7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQk9PTEVBTl9MSVRFUkFMOlxuXHRcdFx0XHRjYXNlIHR5cGVzLkdMT0JBTDpcblx0XHRcdFx0Y2FzZSB0eXBlcy5OVU1CRVJfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS52O1xuXHRcdFx0XHRjYXNlIHR5cGVzLlNUUklOR19MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiBxdW90ZVN0cmluZ0xpdGVyYWwoIG5vZGUudiApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkFSUkFZX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuICdbJyArICggbm9kZS5tID8gbm9kZS5tLm1hcCggc3RyaW5naWZ5QWxsICkuam9pbiggJywnICkgOiAnJyApICsgJ10nO1xuXHRcdFx0XHRjYXNlIHR5cGVzLk9CSkVDVF9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiAneycgKyAoIG5vZGUubSA/IG5vZGUubS5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICd9Jztcblx0XHRcdFx0Y2FzZSB0eXBlcy5LRVlfVkFMVUVfUEFJUjpcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5rICsgJzonICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUudiwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlBSRUZJWF9PUEVSQVRPUjpcblx0XHRcdFx0XHRyZXR1cm4gKCBub2RlLnMgPT09ICd0eXBlb2YnID8gJ3R5cGVvZiAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vLCByZWZzICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuSU5GSVhfT1BFUkFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDAgXSwgcmVmcyApICsgKCBub2RlLnMuc3Vic3RyKCAwLCAyICkgPT09ICdpbicgPyAnICcgKyBub2RlLnMgKyAnICcgOiBub2RlLnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDEgXSwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLklOVk9DQVRJT046XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICcoJyArICggbm9kZS5vID8gbm9kZS5vLm1hcCggc3RyaW5naWZ5QWxsICkuam9pbiggJywnICkgOiAnJyApICsgJyknO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkJSQUNLRVRFRDpcblx0XHRcdFx0XHRyZXR1cm4gJygnICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgJyknO1xuXHRcdFx0XHRjYXNlIHR5cGVzLk1FTUJFUjpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUuciwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlJFRklORU1FTlQ6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUubiA/ICcuJyArIG5vZGUubiA6ICdbJyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICddJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5DT05ESVRJT05BTDpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMCBdLCByZWZzICkgKyAnPycgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAxIF0sIHJlZnMgKSArICc6JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDIgXSwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlJFRkVSRU5DRTpcblx0XHRcdFx0XHRyZXR1cm4gJ18nICsgcmVmcy5pbmRleE9mKCBub2RlLm4gKTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBsZWdhbCBKYXZhU2NyaXB0JyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBpc09iamVjdCApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9fUGFyc2VyLmpzICovXG5cdHZhciBQYXJzZXIgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGNyZWF0ZSwgaGFzT3duUHJvcGVydHksIGdldENvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiApIHtcblxuXHRcdHZhciBQYXJzZXIsIFBhcnNlRXJyb3IsIGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLztcblx0XHRQYXJzZUVycm9yID0gZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSAnUGFyc2VFcnJvcic7XG5cdFx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0dGhpcy5zdGFjayA9IGUuc3RhY2s7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblx0XHRQYXJzZXIgPSBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGl0ZW1zLCBpdGVtLCBsaW5lU3RhcnQgPSAwO1xuXHRcdFx0dGhpcy5zdHIgPSBzdHI7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0dGhpcy5wb3MgPSAwO1xuXHRcdFx0dGhpcy5saW5lcyA9IHRoaXMuc3RyLnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0dGhpcy5saW5lRW5kcyA9IHRoaXMubGluZXMubWFwKCBmdW5jdGlvbiggbGluZSApIHtcblx0XHRcdFx0dmFyIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7XG5cdFx0XHRcdC8vICsxIGZvciB0aGUgbmV3bGluZVxuXHRcdFx0XHRsaW5lU3RhcnQgPSBsaW5lRW5kO1xuXHRcdFx0XHRyZXR1cm4gbGluZUVuZDtcblx0XHRcdH0sIDAgKTtcblx0XHRcdC8vIEN1c3RvbSBpbml0IGxvZ2ljXG5cdFx0XHRpZiAoIHRoaXMuaW5pdCApXG5cdFx0XHRcdHRoaXMuaW5pdCggc3RyLCBvcHRpb25zICk7XG5cdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0d2hpbGUgKCB0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoIGl0ZW0gPSB0aGlzLnJlYWQoKSApICkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcblx0XHRcdHRoaXMucmVzdWx0ID0gdGhpcy5wb3N0UHJvY2VzcyA/IHRoaXMucG9zdFByb2Nlc3MoIGl0ZW1zLCBvcHRpb25zICkgOiBpdGVtcztcblx0XHR9O1xuXHRcdFBhcnNlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiggY29udmVydGVycyApIHtcblx0XHRcdFx0dmFyIHBvcywgaSwgbGVuLCBpdGVtO1xuXHRcdFx0XHRpZiAoICFjb252ZXJ0ZXJzIClcblx0XHRcdFx0XHRjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXHRcdFx0XHRwb3MgPSB0aGlzLnBvcztcblx0XHRcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgPSBwb3M7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgZm9yIGVhY2ggYXR0ZW1wdFxuXHRcdFx0XHRcdGlmICggaXRlbSA9IGNvbnZlcnRlcnNbIGkgXSggdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdHJlYWRFeHByZXNzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciAoZXhjZXB0IHlpZWxkLFxuXHRcdFx0XHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2Vcblx0XHRcdFx0Ly8gc3RhcnQgdGhlcmUuIElmIGl0IGRvZXNuJ3QgbWF0Y2gsIGl0ICdmYWxscyB0aHJvdWdoJyB0byBwcm9ncmVzc2l2ZWx5XG5cdFx0XHRcdC8vIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9ycywgdW50aWwgaXQgZXZlbnR1YWxseSBtYXRjaGVzIChvciBmYWlscyB0b1xuXHRcdFx0XHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG5cdFx0XHRcdC8vIHRyZWUgaGFzIGV2ZXJ5dGhpbmcgaW4gaXRzIHByb3BlciBwbGFjZSwgaS5lLiAyICsgMyAqIDQgPT09IDE0LCBub3QgMjAuXG5cdFx0XHRcdHJldHVybiBnZXRDb25kaXRpb25hbCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGZsYXR0ZW5FeHByZXNzaW9uOiBmbGF0dGVuRXhwcmVzc2lvbixcblx0XHRcdGdldExpbmVQb3M6IGZ1bmN0aW9uKCBjaGFyICkge1xuXHRcdFx0XHR2YXIgbGluZU51bSA9IDAsXG5cdFx0XHRcdFx0bGluZVN0YXJ0ID0gMCxcblx0XHRcdFx0XHRjb2x1bW5OdW07XG5cdFx0XHRcdHdoaWxlICggY2hhciA+PSB0aGlzLmxpbmVFbmRzWyBsaW5lTnVtIF0gKSB7XG5cdFx0XHRcdFx0bGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kc1sgbGluZU51bSBdO1xuXHRcdFx0XHRcdGxpbmVOdW0gKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2x1bW5OdW0gPSBjaGFyIC0gbGluZVN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGxpbmVOdW0gKyAxLFxuXHRcdFx0XHRcdGNvbHVtbk51bSArIDEsXG5cdFx0XHRcdFx0Y2hhclxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiggbWVzc2FnZSApIHtcblx0XHRcdFx0dmFyIHBvcywgbGluZU51bSwgY29sdW1uTnVtLCBsaW5lLCBhbm5vdGF0aW9uLCBlcnJvcjtcblx0XHRcdFx0cG9zID0gdGhpcy5nZXRMaW5lUG9zKCB0aGlzLnBvcyApO1xuXHRcdFx0XHRsaW5lTnVtID0gcG9zWyAwIF07XG5cdFx0XHRcdGNvbHVtbk51bSA9IHBvc1sgMSBdO1xuXHRcdFx0XHRsaW5lID0gdGhpcy5saW5lc1sgcG9zWyAwIF0gLSAxIF07XG5cdFx0XHRcdGFubm90YXRpb24gPSBsaW5lICsgJ1xcbicgKyBuZXcgQXJyYXkoIHBvc1sgMSBdICkuam9pbiggJyAnICkgKyAnXi0tLS0nO1xuXHRcdFx0XHRlcnJvciA9IG5ldyBQYXJzZUVycm9yKCBtZXNzYWdlICsgJyBhdCBsaW5lICcgKyBsaW5lTnVtICsgJyBjaGFyYWN0ZXIgJyArIGNvbHVtbk51bSArICc6XFxuJyArIGFubm90YXRpb24gKTtcblx0XHRcdFx0ZXJyb3IubGluZSA9IHBvc1sgMCBdO1xuXHRcdFx0XHRlcnJvci5jaGFyYWN0ZXIgPSBwb3NbIDEgXTtcblx0XHRcdFx0ZXJyb3Iuc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9LFxuXHRcdFx0bWF0Y2hTdHJpbmc6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zdHIuc3Vic3RyKCB0aGlzLnBvcywgc3RyaW5nLmxlbmd0aCApID09PSBzdHJpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bWF0Y2hQYXR0ZXJuOiBmdW5jdGlvbiggcGF0dGVybiApIHtcblx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRpZiAoIG1hdGNoID0gcGF0dGVybi5leGVjKCB0aGlzLnJlbWFpbmluZygpICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbIDAgXS5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoWyAxIF0gfHwgbWF0Y2hbIDAgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsbG93V2hpdGVzcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMubWF0Y2hQYXR0ZXJuKCBsZWFkaW5nV2hpdGVzcGFjZSApO1xuXHRcdFx0fSxcblx0XHRcdHJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0ci5zdWJzdHJpbmcoIHRoaXMucG9zICk7XG5cdFx0XHR9LFxuXHRcdFx0bmV4dENoYXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KCB0aGlzLnBvcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uKCBwcm90byApIHtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRDaGlsZCwga2V5O1xuXHRcdFx0Q2hpbGQgPSBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHRQYXJzZXIuY2FsbCggdGhpcywgc3RyLCBvcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0Q2hpbGQucHJvdG90eXBlID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRmb3IgKCBrZXkgaW4gcHJvdG8gKSB7XG5cdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggcHJvdG8sIGtleSApICkge1xuXHRcdFx0XHRcdENoaWxkLnByb3RvdHlwZVsga2V5IF0gPSBwcm90b1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdENoaWxkLmV4dGVuZCA9IFBhcnNlci5leHRlbmQ7XG5cdFx0XHRyZXR1cm4gQ2hpbGQ7XG5cdFx0fTtcblx0XHRjaXJjdWxhci5QYXJzZXIgPSBQYXJzZXI7XG5cdFx0cmV0dXJuIFBhcnNlcjtcblx0fSggY2lyY3VsYXIsIGNyZWF0ZSwgaGFzT3duLCBjb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24gKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2RlbGltaXRlckNoYW5nZS5qcyAqL1xuXHR2YXIgZGVsaW1pdGVyQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiA9IC9eW15cXHM9XSsvLFxuXHRcdFx0d2hpdGVzcGFjZVBhdHRlcm4gPSAvXlxccysvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBvcGVuaW5nLCBjbG9zaW5nO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPScgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBuZXcgb3BlbmluZyBkZWxpbWl0ZXJcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFvcGVuaW5nICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSAoaW4gZmFjdCwgaXQncyBuZWNlc3NhcnkuLi4pXG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hQYXR0ZXJuKCB3aGl0ZXNwYWNlUGF0dGVybiApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGNsb3NpbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFjbG9zaW5nICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyAnPSdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRvcGVuaW5nLFxuXHRcdFx0XHRjbG9zaW5nXG5cdFx0XHRdO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2RlbGltaXRlclR5cGVzLmpzICovXG5cdHZhciBkZWxpbWl0ZXJUeXBlcyA9IFsge1xuXHRcdGRlbGltaXRlcnM6ICdkZWxpbWl0ZXJzJyxcblx0XHRpc1RyaXBsZTogZmFsc2UsXG5cdFx0aXNTdGF0aWM6IGZhbHNlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAndHJpcGxlRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IHRydWUsXG5cdFx0aXNTdGF0aWM6IGZhbHNlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAnc3RhdGljRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IGZhbHNlLFxuXHRcdGlzU3RhdGljOiB0cnVlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAnc3RhdGljVHJpcGxlRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IHRydWUsXG5cdFx0aXNTdGF0aWM6IHRydWVcblx0fSBdO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvdHlwZS5qcyAqL1xuXHR2YXIgdHlwZSA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBtdXN0YWNoZVR5cGVzID0ge1xuXHRcdFx0JyMnOiB0eXBlcy5TRUNUSU9OLFxuXHRcdFx0J14nOiB0eXBlcy5JTlZFUlRFRCxcblx0XHRcdCcvJzogdHlwZXMuQ0xPU0lORyxcblx0XHRcdCc+JzogdHlwZXMuUEFSVElBTCxcblx0XHRcdCchJzogdHlwZXMuQ09NTUVOVCxcblx0XHRcdCcmJzogdHlwZXMuVFJJUExFXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciB0eXBlID0gbXVzdGFjaGVUeXBlc1sgcGFyc2VyLnN0ci5jaGFyQXQoIHBhcnNlci5wb3MgKSBdO1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IDE7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvaGFuZGxlYmFyc0Jsb2NrQ29kZXMuanMgKi9cblx0dmFyIGhhbmRsZWJhcnNCbG9ja0NvZGVzID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdCdlYWNoJzogdHlwZXMuU0VDVElPTl9FQUNILFxuXHRcdFx0J2lmJzogdHlwZXMuU0VDVElPTl9JRixcblx0XHRcdCdpZi13aXRoJzogdHlwZXMuU0VDVElPTl9JRl9XSVRILFxuXHRcdFx0J3dpdGgnOiB0eXBlcy5TRUNUSU9OX1dJVEgsXG5cdFx0XHQndW5sZXNzJzogdHlwZXMuU0VDVElPTl9VTkxFU1Ncblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIGVtcHR5L2xlZ2FjeS5qcyAqL1xuXHR2YXIgbGVnYWN5ID0gbnVsbDtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2NvbnRlbnQuanMgKi9cblx0dmFyIGNvbnRlbnQgPSBmdW5jdGlvbiggdHlwZXMsIG11c3RhY2hlVHlwZSwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGluZGV4UmVmUGF0dGVybiA9IC9eXFxzKjpcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuXHRcdFx0YXJyYXlNZW1iZXJQYXR0ZXJuID0gL15bMC05XVsxLTldKiQvLFxuXHRcdFx0aGFuZGxlYmFyc0Jsb2NrUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKCcgKyBPYmplY3Qua2V5cyggaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKS5qb2luKCAnfCcgKSArICcpXFxcXGInICksXG5cdFx0XHRsZWdhbFJlZmVyZW5jZTtcblx0XHRsZWdhbFJlZmVyZW5jZSA9IC9eW2EtekEtWiRfMC05XSsoPzooXFwuW2EtekEtWiRfMC05XSspfChcXFtbYS16QS1aJF8wLTldK1xcXSkpKiQvO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgcG9zLCBtdXN0YWNoZSwgdHlwZSwgYmxvY2ssIGV4cHJlc3Npb24sIGksIHJlbWFpbmluZywgaW5kZXgsIGRlbGltaXRlcnM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRtdXN0YWNoZSA9IHt9O1xuXHRcdFx0ZGVsaW1pdGVycyA9IHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF07XG5cdFx0XHRpZiAoIGRlbGltaXRlclR5cGUuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGV0ZXJtaW5lIG11c3RhY2hlIHR5cGVcblx0XHRcdGlmICggZGVsaW1pdGVyVHlwZS5pc1RyaXBsZSApIHtcblx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBmb3IgZXhwcmVzc2lvbnMgYmVmb3JlIHdlIHRlc3QgZm9yIG11c3RhY2hlIHR5cGUsIGJlY2F1c2Vcblx0XHRcdFx0Ly8gYW4gZXhwcmVzc2lvbiB0aGF0IGJlZ2lucyAnIScgbG9va3MgYSBsb3QgbGlrZSBhIGNvbW1lbnRcblx0XHRcdFx0aWYgKCBwYXJzZXIucmVtYWluaW5nKClbIDAgXSA9PT0gJyEnICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdFx0XHQvLyBXYXMgaXQgYWN0dWFsbHkgYW4gZXhwcmVzc2lvbiwgb3IgYSBjb21tZW50IGJsb2NrIGluIGRpc2d1aXNlP1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdGV4cHJlc3Npb24gPSBudWxsO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge31cblx0XHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRpZiAoIH5pbmRleCApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyIChcXCcnICsgZGVsaW1pdGVyc1sgMSBdICsgJ1xcJyknICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0OiB0eXBlcy5DT01NRU5UXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdHR5cGUgPSBtdXN0YWNoZVR5cGUoIHBhcnNlciApO1xuXHRcdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlIHx8IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHQvLyBkZWZhdWx0XG5cdFx0XHRcdFx0Ly8gU2VlIGlmIHRoZXJlJ3MgYW4gZXhwbGljaXQgc2VjdGlvbiB0eXBlIGUuZy4ge3sjd2l0aH19Li4ue3svd2l0aH19XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHRcdFx0aWYgKCBibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUubiA9IGJsb2NrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHR5cGVzLkNPTU1FTlQgfHwgdHlwZSA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApLnNwbGl0KCAnICcgKVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0Ly8gZ2V0IGV4cHJlc3Npb25cblx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGEgcGFydGlhbCwgaXQgbWF5IGhhdmUgYSBjb250ZXh0IChlLmcuIGB7ez5pdGVtIGZvb319YCkuIFRoZXNlXG5cdFx0XHRcdC8vIGNhc2VzIGludm9sdmUgYSBiaXQgb2YgYSBoYWNrIC0gd2Ugd2FudCB0byB0dXJuIGl0IGludG8gdGhlIGVxdWl2YWxlbnQgb2Zcblx0XHRcdFx0Ly8gYHt7I3dpdGggZm9vfX17ez5pdGVtfX17ey93aXRofX1gLCBidXQgdG8gZ2V0IHRoZXJlIHdlIHRlbXBvcmFyaWx5IGFwcGVuZFxuXHRcdFx0XHQvLyBhICdjb250ZXh0UGFydGlhbEV4cHJlc3Npb24nIHRvIHRoZSBtdXN0YWNoZSwgYW5kIHByb2Nlc3MgdGhlIGNvbnRleHQgaW5zdGVhZCBvZlxuXHRcdFx0XHQvLyB0aGUgcmVmZXJlbmNlXG5cdFx0XHRcdHZhciB0ZW1wO1xuXHRcdFx0XHRpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLlBBUlRJQUwgJiYgZXhwcmVzc2lvbiAmJiAoIHRlbXAgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKSApICkge1xuXHRcdFx0XHRcdG11c3RhY2hlID0ge1xuXHRcdFx0XHRcdFx0Y29udGV4dFBhcnRpYWxFeHByZXNzaW9uOiBleHByZXNzaW9uXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRleHByZXNzaW9uID0gdGVtcDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBXaXRoIGNlcnRhaW4gdmFsaWQgcmVmZXJlbmNlcyB0aGF0IGFyZW4ndCB2YWxpZCBleHByZXNzaW9ucyxcblx0XHRcdFx0Ly8gZS5nLiB7ezEuZm9vfX0sIHdlIGhhdmUgYSBwcm9ibGVtOiBpdCBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBhblxuXHRcdFx0XHQvLyBleHByZXNzaW9uLCBidXQgdGhlIGV4cHJlc3Npb24gZGlkbid0IGNvbnN1bWUgdGhlIGVudGlyZVxuXHRcdFx0XHQvLyByZWZlcmVuY2UuIFNvIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgbXVzdGFjaGUgZGVsaW1pdGVyc1xuXHRcdFx0XHQvLyBhcHBlYXIgbmV4dCwgdW5sZXNzIHRoZXJlJ3MgYW4gaW5kZXggcmVmZXJlbmNlIChpLmUuIGEgY29sb24pXG5cdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCBkZWxpbWl0ZXJzWyAxIF0ubGVuZ3RoICkgIT09IGRlbGltaXRlcnNbIDEgXSAmJiByZW1haW5pbmcuY2hhckF0KCAwICkgIT09ICc6JyApIHtcblx0XHRcdFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKS50cmltKCk7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpdCdzIGEgbGVnYWwgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRpZiAoICFsZWdhbFJlZmVyZW5jZS50ZXN0KCBtdXN0YWNoZS5yICkgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGEgbGVnYWwgTXVzdGFjaGUgcmVmZXJlbmNlJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVmaW5lRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uLCBtdXN0YWNoZSApO1xuXHRcdFx0Ly8gaWYgdGhlcmUgd2FzIGNvbnRleHQsIHByb2Nlc3MgdGhlIGV4cHJlc3Npb24gbm93IGFuZCBzYXZlIGl0IGZvciBsYXRlclxuXHRcdFx0aWYgKCBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbiA9IFsgcmVmaW5lRXhwcmVzc2lvbiggcGFyc2VyLCBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24sIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5QQVJUSUFMXG5cdFx0XHRcdH0gKSBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gb3B0aW9uYWwgaW5kZXggcmVmZXJlbmNlXG5cdFx0XHRpZiAoIGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBpbmRleFJlZlBhdHRlcm4gKSApIHtcblx0XHRcdFx0bXVzdGFjaGUuaSA9IGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZmluZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiwgbXVzdGFjaGUgKSB7XG5cdFx0XHR2YXIgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblx0XHRcdGlmICggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0d2hpbGUgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLkJSQUNLRVRFRCAmJiBleHByZXNzaW9uLnggKSB7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbnRlZ2VycyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhcnJheSBtZW1iZXJzIHJlZmVyZW5jZXMsXG5cdFx0XHRcdC8vIHJhdGhlciB0aGFuIGFzIGV4cHJlc3Npb25zIGluIHRoZWlyIG93biByaWdodFxuXHRcdFx0XHRpZiAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLk5VTUJFUl9MSVRFUkFMICYmIGFycmF5TWVtYmVyUGF0dGVybi50ZXN0KCBleHByZXNzaW9uLnYgKSApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLnY7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcmVmZXJlbmNlRXhwcmVzc2lvbiA9IGdldFJlZmVyZW5jZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiApICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUucnggPSByZWZlcmVuY2VFeHByZXNzaW9uO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS54ID0gcGFyc2VyLmZsYXR0ZW5FeHByZXNzaW9uKCBleHByZXNzaW9uICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0aGlzISBpdCdzIGJld2lsZGVyaW5nXG5cdFx0ZnVuY3Rpb24gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIG1lbWJlcnMgPSBbXSxcblx0XHRcdFx0cmVmaW5lbWVudDtcblx0XHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5NRU1CRVIgJiYgZXhwcmVzc2lvbi5yLnQgPT09IHR5cGVzLlJFRklORU1FTlQgKSB7XG5cdFx0XHRcdHJlZmluZW1lbnQgPSBleHByZXNzaW9uLnI7XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudC54ICkge1xuXHRcdFx0XHRcdGlmICggcmVmaW5lbWVudC54LnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcmVmaW5lbWVudC54ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcGFyc2VyLmZsYXR0ZW5FeHByZXNzaW9uKCByZWZpbmVtZW50LnggKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHJlZmluZW1lbnQubiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV4cHJlc3Npb24udCAhPT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHI6IGV4cHJlc3Npb24ubixcblx0XHRcdFx0bTogbWVtYmVyc1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgdHlwZSwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMsIGxlZ2FjeSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUuanMgKi9cblx0dmFyIG11c3RhY2hlID0gZnVuY3Rpb24oIHR5cGVzLCBkZWxpbWl0ZXJDaGFuZ2UsIGRlbGltaXRlclR5cGVzLCBtdXN0YWNoZUNvbnRlbnQsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBkZWxpbWl0ZXJDaGFuZ2VUb2tlbiA9IHtcblx0XHRcdHQ6IHR5cGVzLkRFTElNQ0hBTkdFLFxuXHRcdFx0ZXhjbHVkZTogdHJ1ZVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBnZXRNdXN0YWNoZTtcblxuXHRcdGZ1bmN0aW9uIGdldE11c3RhY2hlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdHlwZXM7XG5cdFx0XHQvLyBJZiB3ZSdyZSBpbnNpZGUgYSA8c2NyaXB0PiBvciA8c3R5bGU+IHRhZywgYW5kIHdlJ3JlIG5vdFxuXHRcdFx0Ly8gaW50ZXJwb2xhdGluZywgYnVnIG91dFxuXHRcdFx0aWYgKCBwYXJzZXIuaW50ZXJwb2xhdGVbIHBhcnNlci5pbnNpZGUgXSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dHlwZXMgPSBkZWxpbWl0ZXJUeXBlcy5zbGljZSgpLnNvcnQoIGZ1bmN0aW9uIGNvbXBhcmUoIGEsIGIgKSB7XG5cdFx0XHRcdC8vIFNvcnQgaW4gb3JkZXIgb2YgZGVzY2VuZGluZyBvcGVuaW5nIGRlbGltaXRlciBsZW5ndGggKGxvbmdlciBmaXJzdCksXG5cdFx0XHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG5cdFx0XHRcdHJldHVybiBwYXJzZXJbIGIuZGVsaW1pdGVycyBdWyAwIF0ubGVuZ3RoIC0gcGFyc2VyWyBhLmRlbGltaXRlcnMgXVsgMCBdLmxlbmd0aDtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiByKCB0eXBlICkge1xuXHRcdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBnZXRNdXN0YWNoZU9mVHlwZSggcGFyc2VyLCB0eXBlICkgfHwgciggdHlwZXMuc2hpZnQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KCB0eXBlcy5zaGlmdCgpICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TXVzdGFjaGVPZlR5cGUoIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgbXVzdGFjaGUsIGRlbGltaXRlcnMsIGNoaWxkcmVuLCBleHBlY3RlZENsb3NlLCBlbHNlQ2hpbGRyZW4sIGN1cnJlbnRDaGlsZHJlbiwgY2hpbGQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRkZWxpbWl0ZXJzID0gcGFyc2VyWyBkZWxpbWl0ZXJUeXBlLmRlbGltaXRlcnMgXTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGVsaW1pdGVyIGNoYW5nZT9cblx0XHRcdGlmICggbXVzdGFjaGUgPSBkZWxpbWl0ZXJDaGFuZ2UoIHBhcnNlciApICkge1xuXHRcdFx0XHQvLyBmaW5kIGNsb3NpbmcgZGVsaW1pdGVyIG9yIGFib3J0Li4uXG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gLi4udGhlbiBtYWtlIHRoZSBzd2l0Y2hcblx0XHRcdFx0cGFyc2VyWyBkZWxpbWl0ZXJUeXBlLmRlbGltaXRlcnMgXSA9IG11c3RhY2hlO1xuXHRcdFx0XHRyZXR1cm4gZGVsaW1pdGVyQ2hhbmdlVG9rZW47XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRtdXN0YWNoZSA9IG11c3RhY2hlQ29udGVudCggcGFyc2VyLCBkZWxpbWl0ZXJUeXBlICk7XG5cdFx0XHRpZiAoIG11c3RhY2hlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBkZWxpbWl0ZXJcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyIFxcJycgKyBkZWxpbWl0ZXJzWyAxIF0gKyAnXFwnIGFmdGVyIHJlZmVyZW5jZScgKTtcblx0XHRcdH1cblx0XHRcdGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuQ09NTUVOVCApIHtcblx0XHRcdFx0bXVzdGFjaGUuZXhjbHVkZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggLT0gMTtcblx0XHRcdFx0aWYgKCBwYXJzZXIuc2VjdGlvbkRlcHRoIDwgMCApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnQXR0ZW1wdGVkIHRvIGNsb3NlIGEgc2VjdGlvbiB0aGF0IHdhc25cXCd0IG9wZW4nICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHBhcnRpYWxzIHdpdGggY29udGV4dFxuXHRcdFx0aWYgKCBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdG11c3RhY2hlLmYgPSBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb247XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gJ3dpdGgnO1xuXHRcdFx0XHRkZWxldGUgbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uO1xuXHRcdFx0fSBlbHNlIGlmICggaXNTZWN0aW9uKCBtdXN0YWNoZSApICkge1xuXHRcdFx0XHRwYXJzZXIuc2VjdGlvbkRlcHRoICs9IDE7XG5cdFx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0XHRcdGN1cnJlbnRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXHRcdFx0XHRleHBlY3RlZENsb3NlID0gbXVzdGFjaGUubjtcblx0XHRcdFx0d2hpbGUgKCBjaGlsZCA9IHBhcnNlci5yZWFkKCkgKSB7XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0aWYgKCBleHBlY3RlZENsb3NlICYmIGNoaWxkLnIgIT09IGV4cGVjdGVkQ2xvc2UgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIHt7LycgKyBleHBlY3RlZENsb3NlICsgJ319JyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHt7ZWxzZX19IHRhZ3MgcmVxdWlyZSBzcGVjaWFsIHRyZWF0bWVudFxuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuSU5URVJQT0xBVE9SICYmIGNoaWxkLnIgPT09ICdlbHNlJyApIHtcblx0XHRcdFx0XHRcdC8vIG5vIHt7ZWxzZX19IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cblx0XHRcdFx0XHRcdGlmICggbXVzdGFjaGUubiA9PT0gJ3VubGVzcycgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ3t7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319JyApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudENoaWxkcmVuID0gZWxzZUNoaWxkcmVuID0gW107XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5mID0gY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbHNlQ2hpbGRyZW4gJiYgZWxzZUNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5sID0gZWxzZUNoaWxkcmVuO1xuXHRcdFx0XHRcdGlmICggbXVzdGFjaGUubiA9PT0gJ3dpdGgnICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUubiA9ICdpZi13aXRoJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRtdXN0YWNoZS5wID0gcGFyc2VyLmdldExpbmVQb3MoIHN0YXJ0ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZXBsYWNlIGJsb2NrIG5hbWUgd2l0aCBjb2RlXG5cdFx0XHRpZiAoIG11c3RhY2hlLm4gKSB7XG5cdFx0XHRcdG11c3RhY2hlLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1sgbXVzdGFjaGUubiBdO1xuXHRcdFx0fSBlbHNlIGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuSU5WRVJURUQgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gdHlwZXMuU0VDVElPTl9VTkxFU1M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTZWN0aW9uKCBtdXN0YWNoZSApIHtcblx0XHRcdHJldHVybiBtdXN0YWNoZS50ID09PSB0eXBlcy5TRUNUSU9OIHx8IG11c3RhY2hlLnQgPT09IHR5cGVzLklOVkVSVEVEO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBkZWxpbWl0ZXJDaGFuZ2UsIGRlbGltaXRlclR5cGVzLCBjb250ZW50LCBoYW5kbGViYXJzQmxvY2tDb2RlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvY29tbWVudC5qcyAqL1xuXHR2YXIgY29tbWVudCA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBPUEVOX0NPTU1FTlQgPSAnPCEtLScsXG5cdFx0XHRDTE9TRV9DT01NRU5UID0gJy0tPic7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGNvbnRlbnQsIHJlbWFpbmluZywgZW5kSW5kZXgsIGNvbW1lbnQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIE9QRU5fQ09NTUVOVCApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGVuZEluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIENMT1NFX0NPTU1FTlQgKTtcblx0XHRcdGlmICggZW5kSW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIEhUTUwgLSBleHBlY3RlZCBjbG9zaW5nIGNvbW1lbnQgc2VxdWVuY2UgKFxcJy0tPlxcJyknICk7XG5cdFx0XHR9XG5cdFx0XHRjb250ZW50ID0gcmVtYWluaW5nLnN1YnN0ciggMCwgZW5kSW5kZXggKTtcblx0XHRcdHBhcnNlci5wb3MgKz0gZW5kSW5kZXggKyAzO1xuXHRcdFx0Y29tbWVudCA9IHtcblx0XHRcdFx0dDogdHlwZXMuQ09NTUVOVCxcblx0XHRcdFx0YzogY29udGVudFxuXHRcdFx0fTtcblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRjb21tZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyggc3RhcnQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb21tZW50O1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogY29uZmlnL3ZvaWRFbGVtZW50TmFtZXMuanMgKi9cblx0dmFyIHZvaWRFbGVtZW50TmFtZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB2b2lkRWxlbWVudE5hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZG9jdHlwZXxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvaTtcblx0XHRyZXR1cm4gdm9pZEVsZW1lbnROYW1lcztcblx0fSgpO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvdXRpbHMvZ2V0TG93ZXN0SW5kZXguanMgKi9cblx0dmFyIGdldExvd2VzdEluZGV4ID0gZnVuY3Rpb24oIGhheXN0YWNrLCBuZWVkbGVzICkge1xuXHRcdHZhciBpLCBpbmRleCwgbG93ZXN0O1xuXHRcdGkgPSBuZWVkbGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGluZGV4ID0gaGF5c3RhY2suaW5kZXhPZiggbmVlZGxlc1sgaSBdICk7XG5cdFx0XHQvLyBzaG9ydCBjaXJjdWl0XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFsb3dlc3QgfHwgaW5kZXggPCBsb3dlc3QgKSB7XG5cdFx0XHRcdGxvd2VzdCA9IGluZGV4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbG93ZXN0IHx8IC0xO1xuXHR9O1xuXG5cdC8qIHNoYXJlZC9kZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzLmpzICovXG5cdHZhciBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGh0bWxFbnRpdGllcywgY29udHJvbENoYXJhY3RlcnMsIGVudGl0eVBhdHRlcm47XG5cdFx0aHRtbEVudGl0aWVzID0ge1xuXHRcdFx0cXVvdDogMzQsXG5cdFx0XHRhbXA6IDM4LFxuXHRcdFx0YXBvczogMzksXG5cdFx0XHRsdDogNjAsXG5cdFx0XHRndDogNjIsXG5cdFx0XHRuYnNwOiAxNjAsXG5cdFx0XHRpZXhjbDogMTYxLFxuXHRcdFx0Y2VudDogMTYyLFxuXHRcdFx0cG91bmQ6IDE2Myxcblx0XHRcdGN1cnJlbjogMTY0LFxuXHRcdFx0eWVuOiAxNjUsXG5cdFx0XHRicnZiYXI6IDE2Nixcblx0XHRcdHNlY3Q6IDE2Nyxcblx0XHRcdHVtbDogMTY4LFxuXHRcdFx0Y29weTogMTY5LFxuXHRcdFx0b3JkZjogMTcwLFxuXHRcdFx0bGFxdW86IDE3MSxcblx0XHRcdG5vdDogMTcyLFxuXHRcdFx0c2h5OiAxNzMsXG5cdFx0XHRyZWc6IDE3NCxcblx0XHRcdG1hY3I6IDE3NSxcblx0XHRcdGRlZzogMTc2LFxuXHRcdFx0cGx1c21uOiAxNzcsXG5cdFx0XHRzdXAyOiAxNzgsXG5cdFx0XHRzdXAzOiAxNzksXG5cdFx0XHRhY3V0ZTogMTgwLFxuXHRcdFx0bWljcm86IDE4MSxcblx0XHRcdHBhcmE6IDE4Mixcblx0XHRcdG1pZGRvdDogMTgzLFxuXHRcdFx0Y2VkaWw6IDE4NCxcblx0XHRcdHN1cDE6IDE4NSxcblx0XHRcdG9yZG06IDE4Nixcblx0XHRcdHJhcXVvOiAxODcsXG5cdFx0XHRmcmFjMTQ6IDE4OCxcblx0XHRcdGZyYWMxMjogMTg5LFxuXHRcdFx0ZnJhYzM0OiAxOTAsXG5cdFx0XHRpcXVlc3Q6IDE5MSxcblx0XHRcdEFncmF2ZTogMTkyLFxuXHRcdFx0QWFjdXRlOiAxOTMsXG5cdFx0XHRBY2lyYzogMTk0LFxuXHRcdFx0QXRpbGRlOiAxOTUsXG5cdFx0XHRBdW1sOiAxOTYsXG5cdFx0XHRBcmluZzogMTk3LFxuXHRcdFx0QUVsaWc6IDE5OCxcblx0XHRcdENjZWRpbDogMTk5LFxuXHRcdFx0RWdyYXZlOiAyMDAsXG5cdFx0XHRFYWN1dGU6IDIwMSxcblx0XHRcdEVjaXJjOiAyMDIsXG5cdFx0XHRFdW1sOiAyMDMsXG5cdFx0XHRJZ3JhdmU6IDIwNCxcblx0XHRcdElhY3V0ZTogMjA1LFxuXHRcdFx0SWNpcmM6IDIwNixcblx0XHRcdEl1bWw6IDIwNyxcblx0XHRcdEVUSDogMjA4LFxuXHRcdFx0TnRpbGRlOiAyMDksXG5cdFx0XHRPZ3JhdmU6IDIxMCxcblx0XHRcdE9hY3V0ZTogMjExLFxuXHRcdFx0T2NpcmM6IDIxMixcblx0XHRcdE90aWxkZTogMjEzLFxuXHRcdFx0T3VtbDogMjE0LFxuXHRcdFx0dGltZXM6IDIxNSxcblx0XHRcdE9zbGFzaDogMjE2LFxuXHRcdFx0VWdyYXZlOiAyMTcsXG5cdFx0XHRVYWN1dGU6IDIxOCxcblx0XHRcdFVjaXJjOiAyMTksXG5cdFx0XHRVdW1sOiAyMjAsXG5cdFx0XHRZYWN1dGU6IDIyMSxcblx0XHRcdFRIT1JOOiAyMjIsXG5cdFx0XHRzemxpZzogMjIzLFxuXHRcdFx0YWdyYXZlOiAyMjQsXG5cdFx0XHRhYWN1dGU6IDIyNSxcblx0XHRcdGFjaXJjOiAyMjYsXG5cdFx0XHRhdGlsZGU6IDIyNyxcblx0XHRcdGF1bWw6IDIyOCxcblx0XHRcdGFyaW5nOiAyMjksXG5cdFx0XHRhZWxpZzogMjMwLFxuXHRcdFx0Y2NlZGlsOiAyMzEsXG5cdFx0XHRlZ3JhdmU6IDIzMixcblx0XHRcdGVhY3V0ZTogMjMzLFxuXHRcdFx0ZWNpcmM6IDIzNCxcblx0XHRcdGV1bWw6IDIzNSxcblx0XHRcdGlncmF2ZTogMjM2LFxuXHRcdFx0aWFjdXRlOiAyMzcsXG5cdFx0XHRpY2lyYzogMjM4LFxuXHRcdFx0aXVtbDogMjM5LFxuXHRcdFx0ZXRoOiAyNDAsXG5cdFx0XHRudGlsZGU6IDI0MSxcblx0XHRcdG9ncmF2ZTogMjQyLFxuXHRcdFx0b2FjdXRlOiAyNDMsXG5cdFx0XHRvY2lyYzogMjQ0LFxuXHRcdFx0b3RpbGRlOiAyNDUsXG5cdFx0XHRvdW1sOiAyNDYsXG5cdFx0XHRkaXZpZGU6IDI0Nyxcblx0XHRcdG9zbGFzaDogMjQ4LFxuXHRcdFx0dWdyYXZlOiAyNDksXG5cdFx0XHR1YWN1dGU6IDI1MCxcblx0XHRcdHVjaXJjOiAyNTEsXG5cdFx0XHR1dW1sOiAyNTIsXG5cdFx0XHR5YWN1dGU6IDI1Myxcblx0XHRcdHRob3JuOiAyNTQsXG5cdFx0XHR5dW1sOiAyNTUsXG5cdFx0XHRPRWxpZzogMzM4LFxuXHRcdFx0b2VsaWc6IDMzOSxcblx0XHRcdFNjYXJvbjogMzUyLFxuXHRcdFx0c2Nhcm9uOiAzNTMsXG5cdFx0XHRZdW1sOiAzNzYsXG5cdFx0XHRmbm9mOiA0MDIsXG5cdFx0XHRjaXJjOiA3MTAsXG5cdFx0XHR0aWxkZTogNzMyLFxuXHRcdFx0QWxwaGE6IDkxMyxcblx0XHRcdEJldGE6IDkxNCxcblx0XHRcdEdhbW1hOiA5MTUsXG5cdFx0XHREZWx0YTogOTE2LFxuXHRcdFx0RXBzaWxvbjogOTE3LFxuXHRcdFx0WmV0YTogOTE4LFxuXHRcdFx0RXRhOiA5MTksXG5cdFx0XHRUaGV0YTogOTIwLFxuXHRcdFx0SW90YTogOTIxLFxuXHRcdFx0S2FwcGE6IDkyMixcblx0XHRcdExhbWJkYTogOTIzLFxuXHRcdFx0TXU6IDkyNCxcblx0XHRcdE51OiA5MjUsXG5cdFx0XHRYaTogOTI2LFxuXHRcdFx0T21pY3JvbjogOTI3LFxuXHRcdFx0UGk6IDkyOCxcblx0XHRcdFJobzogOTI5LFxuXHRcdFx0U2lnbWE6IDkzMSxcblx0XHRcdFRhdTogOTMyLFxuXHRcdFx0VXBzaWxvbjogOTMzLFxuXHRcdFx0UGhpOiA5MzQsXG5cdFx0XHRDaGk6IDkzNSxcblx0XHRcdFBzaTogOTM2LFxuXHRcdFx0T21lZ2E6IDkzNyxcblx0XHRcdGFscGhhOiA5NDUsXG5cdFx0XHRiZXRhOiA5NDYsXG5cdFx0XHRnYW1tYTogOTQ3LFxuXHRcdFx0ZGVsdGE6IDk0OCxcblx0XHRcdGVwc2lsb246IDk0OSxcblx0XHRcdHpldGE6IDk1MCxcblx0XHRcdGV0YTogOTUxLFxuXHRcdFx0dGhldGE6IDk1Mixcblx0XHRcdGlvdGE6IDk1Myxcblx0XHRcdGthcHBhOiA5NTQsXG5cdFx0XHRsYW1iZGE6IDk1NSxcblx0XHRcdG11OiA5NTYsXG5cdFx0XHRudTogOTU3LFxuXHRcdFx0eGk6IDk1OCxcblx0XHRcdG9taWNyb246IDk1OSxcblx0XHRcdHBpOiA5NjAsXG5cdFx0XHRyaG86IDk2MSxcblx0XHRcdHNpZ21hZjogOTYyLFxuXHRcdFx0c2lnbWE6IDk2Myxcblx0XHRcdHRhdTogOTY0LFxuXHRcdFx0dXBzaWxvbjogOTY1LFxuXHRcdFx0cGhpOiA5NjYsXG5cdFx0XHRjaGk6IDk2Nyxcblx0XHRcdHBzaTogOTY4LFxuXHRcdFx0b21lZ2E6IDk2OSxcblx0XHRcdHRoZXRhc3ltOiA5NzcsXG5cdFx0XHR1cHNpaDogOTc4LFxuXHRcdFx0cGl2OiA5ODIsXG5cdFx0XHRlbnNwOiA4MTk0LFxuXHRcdFx0ZW1zcDogODE5NSxcblx0XHRcdHRoaW5zcDogODIwMSxcblx0XHRcdHp3bmo6IDgyMDQsXG5cdFx0XHR6d2o6IDgyMDUsXG5cdFx0XHRscm06IDgyMDYsXG5cdFx0XHRybG06IDgyMDcsXG5cdFx0XHRuZGFzaDogODIxMSxcblx0XHRcdG1kYXNoOiA4MjEyLFxuXHRcdFx0bHNxdW86IDgyMTYsXG5cdFx0XHRyc3F1bzogODIxNyxcblx0XHRcdHNicXVvOiA4MjE4LFxuXHRcdFx0bGRxdW86IDgyMjAsXG5cdFx0XHRyZHF1bzogODIyMSxcblx0XHRcdGJkcXVvOiA4MjIyLFxuXHRcdFx0ZGFnZ2VyOiA4MjI0LFxuXHRcdFx0RGFnZ2VyOiA4MjI1LFxuXHRcdFx0YnVsbDogODIyNixcblx0XHRcdGhlbGxpcDogODIzMCxcblx0XHRcdHBlcm1pbDogODI0MCxcblx0XHRcdHByaW1lOiA4MjQyLFxuXHRcdFx0UHJpbWU6IDgyNDMsXG5cdFx0XHRsc2FxdW86IDgyNDksXG5cdFx0XHRyc2FxdW86IDgyNTAsXG5cdFx0XHRvbGluZTogODI1NCxcblx0XHRcdGZyYXNsOiA4MjYwLFxuXHRcdFx0ZXVybzogODM2NCxcblx0XHRcdGltYWdlOiA4NDY1LFxuXHRcdFx0d2VpZXJwOiA4NDcyLFxuXHRcdFx0cmVhbDogODQ3Nixcblx0XHRcdHRyYWRlOiA4NDgyLFxuXHRcdFx0YWxlZnN5bTogODUwMSxcblx0XHRcdGxhcnI6IDg1OTIsXG5cdFx0XHR1YXJyOiA4NTkzLFxuXHRcdFx0cmFycjogODU5NCxcblx0XHRcdGRhcnI6IDg1OTUsXG5cdFx0XHRoYXJyOiA4NTk2LFxuXHRcdFx0Y3JhcnI6IDg2MjksXG5cdFx0XHRsQXJyOiA4NjU2LFxuXHRcdFx0dUFycjogODY1Nyxcblx0XHRcdHJBcnI6IDg2NTgsXG5cdFx0XHRkQXJyOiA4NjU5LFxuXHRcdFx0aEFycjogODY2MCxcblx0XHRcdGZvcmFsbDogODcwNCxcblx0XHRcdHBhcnQ6IDg3MDYsXG5cdFx0XHRleGlzdDogODcwNyxcblx0XHRcdGVtcHR5OiA4NzA5LFxuXHRcdFx0bmFibGE6IDg3MTEsXG5cdFx0XHRpc2luOiA4NzEyLFxuXHRcdFx0bm90aW46IDg3MTMsXG5cdFx0XHRuaTogODcxNSxcblx0XHRcdHByb2Q6IDg3MTksXG5cdFx0XHRzdW06IDg3MjEsXG5cdFx0XHRtaW51czogODcyMixcblx0XHRcdGxvd2FzdDogODcyNyxcblx0XHRcdHJhZGljOiA4NzMwLFxuXHRcdFx0cHJvcDogODczMyxcblx0XHRcdGluZmluOiA4NzM0LFxuXHRcdFx0YW5nOiA4NzM2LFxuXHRcdFx0YW5kOiA4NzQzLFxuXHRcdFx0b3I6IDg3NDQsXG5cdFx0XHRjYXA6IDg3NDUsXG5cdFx0XHRjdXA6IDg3NDYsXG5cdFx0XHQnaW50JzogODc0Nyxcblx0XHRcdHRoZXJlNDogODc1Nixcblx0XHRcdHNpbTogODc2NCxcblx0XHRcdGNvbmc6IDg3NzMsXG5cdFx0XHRhc3ltcDogODc3Nixcblx0XHRcdG5lOiA4ODAwLFxuXHRcdFx0ZXF1aXY6IDg4MDEsXG5cdFx0XHRsZTogODgwNCxcblx0XHRcdGdlOiA4ODA1LFxuXHRcdFx0c3ViOiA4ODM0LFxuXHRcdFx0c3VwOiA4ODM1LFxuXHRcdFx0bnN1YjogODgzNixcblx0XHRcdHN1YmU6IDg4MzgsXG5cdFx0XHRzdXBlOiA4ODM5LFxuXHRcdFx0b3BsdXM6IDg4NTMsXG5cdFx0XHRvdGltZXM6IDg4NTUsXG5cdFx0XHRwZXJwOiA4ODY5LFxuXHRcdFx0c2RvdDogODkwMSxcblx0XHRcdGxjZWlsOiA4OTY4LFxuXHRcdFx0cmNlaWw6IDg5NjksXG5cdFx0XHRsZmxvb3I6IDg5NzAsXG5cdFx0XHRyZmxvb3I6IDg5NzEsXG5cdFx0XHRsYW5nOiA5MDAxLFxuXHRcdFx0cmFuZzogOTAwMixcblx0XHRcdGxvejogOTY3NCxcblx0XHRcdHNwYWRlczogOTgyNCxcblx0XHRcdGNsdWJzOiA5ODI3LFxuXHRcdFx0aGVhcnRzOiA5ODI5LFxuXHRcdFx0ZGlhbXM6IDk4MzBcblx0XHR9O1xuXHRcdGNvbnRyb2xDaGFyYWN0ZXJzID0gW1xuXHRcdFx0ODM2NCxcblx0XHRcdDEyOSxcblx0XHRcdDgyMTgsXG5cdFx0XHQ0MDIsXG5cdFx0XHQ4MjIyLFxuXHRcdFx0ODIzMCxcblx0XHRcdDgyMjQsXG5cdFx0XHQ4MjI1LFxuXHRcdFx0NzEwLFxuXHRcdFx0ODI0MCxcblx0XHRcdDM1Mixcblx0XHRcdDgyNDksXG5cdFx0XHQzMzgsXG5cdFx0XHQxNDEsXG5cdFx0XHQzODEsXG5cdFx0XHQxNDMsXG5cdFx0XHQxNDQsXG5cdFx0XHQ4MjE2LFxuXHRcdFx0ODIxNyxcblx0XHRcdDgyMjAsXG5cdFx0XHQ4MjIxLFxuXHRcdFx0ODIyNixcblx0XHRcdDgyMTEsXG5cdFx0XHQ4MjEyLFxuXHRcdFx0NzMyLFxuXHRcdFx0ODQ4Mixcblx0XHRcdDM1Myxcblx0XHRcdDgyNTAsXG5cdFx0XHQzMzksXG5cdFx0XHQxNTcsXG5cdFx0XHQzODIsXG5cdFx0XHQzNzZcblx0XHRdO1xuXHRcdGVudGl0eVBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnJigjPyg/OnhbXFxcXHdcXFxcZF0rfFxcXFxkK3wnICsgT2JqZWN0LmtleXMoIGh0bWxFbnRpdGllcyApLmpvaW4oICd8JyApICsgJykpOz8nLCAnZycgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoIGh0bWwgKSB7XG5cdFx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCBlbnRpdHlQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsIGVudGl0eSApIHtcblx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdC8vIEhhbmRsZSBuYW1lZCBlbnRpdGllc1xuXHRcdFx0XHRpZiAoIGVudGl0eVsgMCBdICE9PSAnIycgKSB7XG5cdFx0XHRcdFx0Y29kZSA9IGh0bWxFbnRpdGllc1sgZW50aXR5IF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVudGl0eVsgMSBdID09PSAneCcgKSB7XG5cdFx0XHRcdFx0Y29kZSA9IHBhcnNlSW50KCBlbnRpdHkuc3Vic3RyaW5nKCAyICksIDE2ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29kZSA9IHBhcnNlSW50KCBlbnRpdHkuc3Vic3RyaW5nKCAxICksIDEwICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhY29kZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoIHZhbGlkYXRlQ29kZSggY29kZSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHQvLyBzb21lIGNvZGUgcG9pbnRzIGFyZSB2ZXJib3Rlbi4gSWYgd2Ugd2VyZSBpbnNlcnRpbmcgSFRNTCwgdGhlIGJyb3dzZXIgd291bGQgcmVwbGFjZSB0aGUgaWxsZWdhbFxuXHRcdC8vIGNvZGUgcG9pbnRzIHdpdGggYWx0ZXJuYXRpdmVzIGluIHNvbWUgY2FzZXMgLSBzaW5jZSB3ZSdyZSBieXBhc3NpbmcgdGhhdCBtZWNoYW5pc20sIHdlIG5lZWRcblx0XHQvLyB0byByZXBsYWNlIHRoZW0gb3Vyc2VsdmVzXG5cdFx0Ly9cblx0XHQvLyBTb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmFjdGVyX2VuY29kaW5nc19pbl9IVE1MI0lsbGVnYWxfY2hhcmFjdGVyc1xuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlQ29kZSggY29kZSApIHtcblx0XHRcdGlmICggIWNvZGUgKSB7XG5cdFx0XHRcdHJldHVybiA2NTUzMztcblx0XHRcdH1cblx0XHRcdC8vIGxpbmUgZmVlZCBiZWNvbWVzIGdlbmVyaWMgd2hpdGVzcGFjZVxuXHRcdFx0aWYgKCBjb2RlID09PSAxMCApIHtcblx0XHRcdFx0cmV0dXJuIDMyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQVNDSUkgcmFuZ2UuIChXaHkgc29tZW9uZSB3b3VsZCB1c2UgSFRNTCBlbnRpdGllcyBmb3IgQVNDSUkgY2hhcmFjdGVycyBJIGRvbid0IGtub3csIGJ1dC4uLilcblx0XHRcdGlmICggY29kZSA8IDEyOCApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG5cdFx0XHQvLyB0byBjb3JyZWN0IHRoZSBtaXN0YWtlIG9yIHdlJ2xsIGVuZCB1cCB3aXRoIG1pc3Npbmcg4oKsIHNpZ25zIGFuZCBzbyBvblxuXHRcdFx0aWYgKCBjb2RlIDw9IDE1OSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRyb2xDaGFyYWN0ZXJzWyBjb2RlIC0gMTI4IF07XG5cdFx0XHR9XG5cdFx0XHQvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblx0XHRcdGlmICggY29kZSA8IDU1Mjk2ICkge1xuXHRcdFx0XHRyZXR1cm4gY29kZTtcblx0XHRcdH1cblx0XHRcdC8vIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG5cdFx0XHRpZiAoIGNvZGUgPD0gNTczNDMgKSB7XG5cdFx0XHRcdHJldHVybiA2NTUzMztcblx0XHRcdH1cblx0XHRcdC8vIHJlc3Qgb2YgdGhlIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuXHRcdFx0aWYgKCBjb2RlIDw9IDY1NTM1ICkge1xuXHRcdFx0XHRyZXR1cm4gY29kZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiA2NTUzMztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBsZWdhY3kgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3RleHQuanMgKi9cblx0dmFyIHRleHQgPSBmdW5jdGlvbiggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBpbmRleCwgcmVtYWluaW5nLCBkaXNhbGxvd2VkLCBiYXJyaWVyO1xuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyAnPC8nICsgcGFyc2VyLmluc2lkZSA6ICc8Jztcblx0XHRcdGlmICggcGFyc2VyLmluc2lkZSAmJiAhcGFyc2VyLmludGVycG9sYXRlWyBwYXJzZXIuaW5zaWRlIF0gKSB7XG5cdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGJhcnJpZXIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FsbG93ZWQgPSBbXG5cdFx0XHRcdFx0cGFyc2VyLmRlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIudHJpcGxlRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci5zdGF0aWNEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnN0YXRpY1RyaXBsZURlbGltaXRlcnNbIDAgXVxuXHRcdFx0XHRdO1xuXHRcdFx0XHQvLyBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC1hdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICggcGFyc2VyLmluQXR0cmlidXRlID09PSB0cnVlICkge1xuXHRcdFx0XHRcdC8vIHdlJ3JlIGluc2lkZSBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcblx0XHRcdFx0XHRkaXNhbGxvd2VkLnB1c2goICdcIicsICdcXCcnLCAnPScsICc8JywgJz4nLCAnYCcgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyc2VyLmluQXR0cmlidXRlICkge1xuXHRcdFx0XHRcdC8vIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcblx0XHRcdFx0XHRkaXNhbGxvd2VkLnB1c2goIHBhcnNlci5pbkF0dHJpYnV0ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggYmFycmllciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIHJlbWFpbmluZywgZGlzYWxsb3dlZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhaW5kZXggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRyZXR1cm4gcGFyc2VyLmluc2lkZSA/IHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkgOiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApICk7XG5cdFx0fTtcblx0fSggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvY2xvc2luZ1RhZy5qcyAqL1xuXHR2YXIgY2xvc2luZ1RhZyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBjbG9zaW5nVGFnUGF0dGVybiA9IC9eKFthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qKVxccypcXD4vO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRhZztcblx0XHRcdC8vIGFyZSB3ZSBsb29raW5nIGF0IGEgY2xvc2luZyB0YWc/XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc8LycgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGNsb3NpbmdUYWdQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQ0xPU0lOR19UQUcsXG5cdFx0XHRcdFx0ZTogdGFnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGFuIGlsbGVnYWwgY2xvc2luZyB0YWcsIHJlcG9ydCBpdFxuXHRcdFx0cGFyc2VyLnBvcyAtPSAyO1xuXHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCBjbG9zaW5nIHRhZycgKTtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9hdHRyaWJ1dGUuanMgKi9cblx0dmFyIGF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBnZXRMb3dlc3RJbmRleCwgZ2V0TXVzdGFjaGUsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuID0gL15bXlxcc1wiJz5cXC89XSsvLFxuXHRcdFx0dW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuID0gL15bXlxcc1wiJz08PmBdKy87XG5cdFx0X19leHBvcnQgPSBnZXRBdHRyaWJ1dGU7XG5cblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoIHBhcnNlciApIHtcblx0XHRcdHZhciBhdHRyLCBuYW1lLCB2YWx1ZTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBhdHRyaWJ1dGVOYW1lUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhbmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHR9O1xuXHRcdFx0dmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRhdHRyLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXR0cjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB2YWx1ZVN0YXJ0LCBzdGFydERlcHRoLCB2YWx1ZTtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR2YWx1ZVN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHN0YXJ0RGVwdGggPSBwYXJzZXIuc2VjdGlvbkRlcHRoO1xuXHRcdFx0dmFsdWUgPSBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCAnXFwnJyApIHx8IGdldFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsICdcIicgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKTtcblx0XHRcdGlmICggcGFyc2VyLnNlY3Rpb25EZXB0aCAhPT0gc3RhcnREZXB0aCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0FuIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGNvbnRhaW4gYXMgbWFueSBvcGVuaW5nIHNlY3Rpb24gdGFncyBhcyBjbG9zaW5nIHNlY3Rpb24gdGFncycgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF2YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWyAwIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggdmFsdWVbIDAgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB0ZXh0LCBoYXlzdGFjaywgbmVlZGxlcywgaW5kZXg7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHR0ZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICF0ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGhheXN0YWNrID0gdGV4dDtcblx0XHRcdG5lZWRsZXMgPSBbXG5cdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci50cmlwbGVEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5zdGF0aWNEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWyAwIF1cblx0XHRcdF07XG5cdFx0XHRpZiAoICggaW5kZXggPSBnZXRMb3dlc3RJbmRleCggaGF5c3RhY2ssIG5lZWRsZXMgKSApICE9PSAtMSApIHtcblx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyKCAwLCBpbmRleCApO1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciApIHtcblx0XHRcdHZhciB0b2tlbnMsIHRva2VuO1xuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gdHJ1ZTtcblx0XHRcdHRva2VucyA9IFtdO1xuXHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKCBwYXJzZXIgKTtcblx0XHRcdHdoaWxlICggdG9rZW4gIT09IG51bGwgKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdG9rZW5zLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0b2tlbnM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgcXVvdGVNYXJrICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB0b2tlbnMsIHRva2VuO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBxdW90ZU1hcmsgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBxdW90ZU1hcms7XG5cdFx0XHR0b2tlbnMgPSBbXTtcblx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApO1xuXHRcdFx0d2hpbGUgKCB0b2tlbiAhPT0gbnVsbCApIHtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBxdW90ZU1hcmsgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRva2Vucztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGluZGV4LCBoYXlzdGFjaywgbmVlZGxlcztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGhheXN0YWNrID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0bmVlZGxlcyA9IFtcblx0XHRcdFx0cXVvdGVNYXJrLFxuXHRcdFx0XHRwYXJzZXIuZGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIudHJpcGxlRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sgMCBdXG5cdFx0XHRdO1xuXHRcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleCggaGF5c3RhY2ssIG5lZWRsZXMgKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdRdW90ZWQgYXR0cmlidXRlIHZhbHVlIG11c3QgaGF2ZSBhIGNsb3NpbmcgcXVvdGUnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0cmV0dXJuIGhheXN0YWNrLnN1YnN0ciggMCwgaW5kZXggKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBnZXRMb3dlc3RJbmRleCwgbXVzdGFjaGUsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiB1dGlscy9wYXJzZUpTT04uanMgKi9cblx0dmFyIHBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBQYXJzZXIsIGdldFN0cmluZ0xpdGVyYWwsIGdldEtleSApIHtcblxuXHRcdHZhciBKc29uUGFyc2VyLCBzcGVjaWFscywgc3BlY2lhbHNQYXR0ZXJuLCBudW1iZXJQYXR0ZXJuLCBwbGFjZWhvbGRlclBhdHRlcm4sIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4sIG9ubHlXaGl0ZXNwYWNlO1xuXHRcdHNwZWNpYWxzID0ge1xuXHRcdFx0J3RydWUnOiB0cnVlLFxuXHRcdFx0J2ZhbHNlJzogZmFsc2UsXG5cdFx0XHQndW5kZWZpbmVkJzogdW5kZWZpbmVkLFxuXHRcdFx0J251bGwnOiBudWxsXG5cdFx0fTtcblx0XHRzcGVjaWFsc1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXig/OicgKyBPYmplY3Qua2V5cyggc3BlY2lhbHMgKS5qb2luKCAnfCcgKSArICcpJyApO1xuXHRcdG51bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuXHRcdHBsYWNlaG9sZGVyUGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblx0XHRwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuXHRcdG9ubHlXaGl0ZXNwYWNlID0gL15cXHMqJC87XG5cdFx0SnNvblBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdHRoaXMuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR9LFxuXHRcdFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cdFx0XHRcdGlmICggcmVzdWx0Lmxlbmd0aCAhPT0gMSB8fCAhb25seVdoaXRlc3BhY2UudGVzdCggdGhpcy5sZWZ0b3ZlciApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJlc3VsdFsgMCBdLnZcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzOiBbXG5cblx0XHRcdFx0ZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLnZhbHVlcyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwbGFjZWhvbGRlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gKTtcblx0XHRcdFx0XHRpZiAoIHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkoIHBsYWNlaG9sZGVyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBwYXJzZXIudmFsdWVzWyBwbGFjZWhvbGRlciBdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3BlY2lhbCggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBzcGVjaWFsO1xuXHRcdFx0XHRcdGlmICggc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHNwZWNpYWxzUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogc3BlY2lhbHNbIHNwZWNpYWwgXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldE51bWJlciggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBudW1iZXI7XG5cdFx0XHRcdFx0aWYgKCBudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiArbnVtYmVyXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3RyaW5nKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSxcblx0XHRcdFx0XHRcdHZhbHVlcztcblx0XHRcdFx0XHRpZiAoIHN0cmluZ0xpdGVyYWwgJiYgKCB2YWx1ZXMgPSBwYXJzZXIudmFsdWVzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBzdHJpbmdMaXRlcmFsLnYucmVwbGFjZSggcGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAkMSBpbiB2YWx1ZXMgPyB2YWx1ZXNbICQxIF0gOiAkMTtcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0T2JqZWN0KCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCwgcGFpcjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd7JyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggcGFpciA9IGdldEtleVZhbHVlUGFpciggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRbIHBhaXIua2V5IF0gPSBwYWlyLnZhbHVlO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRBcnJheSggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQsIHZhbHVlVG9rZW47XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIHZhbHVlVG9rZW4udiApO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSApO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIga2V5LCB2YWx1ZVRva2VuLCBwYWlyO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0a2V5ID0gZ2V0S2V5KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWtleSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlyID0ge1xuXHRcdFx0XHRrZXk6IGtleVxuXHRcdFx0fTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCk7XG5cdFx0XHRpZiAoICF2YWx1ZVRva2VuICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cdFx0XHRyZXR1cm4gcGFpcjtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHIsIHZhbHVlcyApIHtcblx0XHRcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlciggc3RyLCB7XG5cdFx0XHRcdHZhbHVlczogdmFsdWVzXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcGFyc2VyLnJlc3VsdDtcblx0XHR9O1xuXHR9KCBQYXJzZXIsIHN0cmluZ0xpdGVyYWwsIGtleSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9wcm9jZXNzRGlyZWN0aXZlLmpzICovXG5cdHZhciBwcm9jZXNzRGlyZWN0aXZlID0gZnVuY3Rpb24oIFBhcnNlciwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uLCBwYXJzZUpTT04gKSB7XG5cblx0XHR2YXIgbWV0aG9kQ2FsbFBhdHRlcm4gPSAvXihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFwoLyxcblx0XHRcdEV4cHJlc3Npb25QYXJzZXI7XG5cdFx0RXhwcmVzc2lvblBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGNvbnZlcnRlcnM6IFsgY29uZGl0aW9uYWwgXVxuXHRcdH0gKTtcblx0XHQvLyBUT0RPIGNsZWFuIHRoaXMgdXAsIGl0J3Mgc2hvY2tpbmdcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRva2VucyApIHtcblx0XHRcdHZhciByZXN1bHQsIG1hdGNoLCBwYXJzZXIsIGFyZ3MsIHRva2VuLCBjb2xvbkluZGV4LCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzLCBwYXJzZWQ7XG5cdFx0XHRpZiAoIHR5cGVvZiB0b2tlbnMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoIG1hdGNoID0gbWV0aG9kQ2FsbFBhdHRlcm4uZXhlYyggdG9rZW5zICkgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdFx0bTogbWF0Y2hbIDEgXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YXJncyA9ICdbJyArIHRva2Vucy5zbGljZSggcmVzdWx0Lm0ubGVuZ3RoICsgMSwgLTEgKSArICddJztcblx0XHRcdFx0XHRwYXJzZXIgPSBuZXcgRXhwcmVzc2lvblBhcnNlciggYXJncyApO1xuXHRcdFx0XHRcdHJlc3VsdC5hID0gZmxhdHRlbkV4cHJlc3Npb24oIHBhcnNlci5yZXN1bHRbIDAgXSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0b2tlbnMuaW5kZXhPZiggJzonICkgPT09IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMudHJpbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRva2VucyA9IFsgdG9rZW5zIF07XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdGRpcmVjdGl2ZU5hbWUgPSBbXTtcblx0XHRcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblx0XHRcdGlmICggdG9rZW5zICkge1xuXHRcdFx0XHR3aGlsZSAoIHRva2Vucy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRjb2xvbkluZGV4ID0gdG9rZW4uaW5kZXhPZiggJzonICk7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9uSW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cblx0XHRcdFx0XHRcdFx0aWYgKCBjb2xvbkluZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG5vXG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbi5zdWJzdHIoIDAsIGNvbG9uSW5kZXggKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIHRoZSBjb2xvbiBpbiB0aGlzIHRva2VuLCB0cmVhdFxuXHRcdFx0XHRcdFx0XHQvLyBpdCBhcyB0aGUgZmlyc3QgdG9rZW4gb2YgdGhlIGRpcmVjdGl2ZUFyZ3MgZnJhZ21lbnRcblx0XHRcdFx0XHRcdFx0aWYgKCB0b2tlbi5sZW5ndGggPiBjb2xvbkluZGV4ICsgMSApIHtcblx0XHRcdFx0XHRcdFx0XHRkaXJlY3RpdmVBcmdzWyAwIF0gPSB0b2tlbi5zdWJzdHJpbmcoIGNvbG9uSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlyZWN0aXZlQXJncyA9IGRpcmVjdGl2ZUFyZ3MuY29uY2F0KCB0b2tlbnMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWRpcmVjdGl2ZU5hbWUubGVuZ3RoICkge1xuXHRcdFx0XHRyZXN1bHQgPSAnJztcblx0XHRcdH0gZWxzZSBpZiAoIGRpcmVjdGl2ZUFyZ3MubGVuZ3RoIHx8IHR5cGVvZiBkaXJlY3RpdmVOYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByZWFsbHkgbmVjZXNzYXJ5PyBqdXN0IHVzZSB0aGUgYXJyYXlcblx0XHRcdFx0XHRuOiBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVsgMCBdID09PSAnc3RyaW5nJyA/IGRpcmVjdGl2ZU5hbWVbIDAgXSA6IGRpcmVjdGl2ZU5hbWVcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlQXJnc1sgMCBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oICdbJyArIGRpcmVjdGl2ZUFyZ3NbIDAgXSArICddJyApO1xuXHRcdFx0XHRcdHJlc3VsdC5hID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogZGlyZWN0aXZlQXJnc1sgMCBdLnRyaW0oKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQuZCA9IGRpcmVjdGl2ZUFyZ3M7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IGRpcmVjdGl2ZU5hbWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIFBhcnNlciwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uLCBwYXJzZUpTT04gKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQuanMgKi9cblx0dmFyIGVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIHZvaWRFbGVtZW50TmFtZXMsIGdldE11c3RhY2hlLCBnZXRDb21tZW50LCBnZXRUZXh0LCBnZXRDbG9zaW5nVGFnLCBnZXRBdHRyaWJ1dGUsIHByb2Nlc3NEaXJlY3RpdmUgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi8sXG5cdFx0XHR2YWxpZFRhZ05hbWVGb2xsb3dlciA9IC9eW1xcc1xcblxcLz5dLyxcblx0XHRcdG9uUGF0dGVybiA9IC9eb24vLFxuXHRcdFx0cHJveHlFdmVudFBhdHRlcm4gPSAvXm9uLShbYS16QS1aXFxcXCpcXFxcLiRfXVthLXpBLVpcXFxcKlxcXFwuJF8wLTlcXC1dKykkLyxcblx0XHRcdHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZXxjb25zdHJ1Y3R8Y29uZmlnfGluaXR8cmVuZGVyfHVucmVuZGVyfGRldGFjaHxpbnNlcnQpJC8sXG5cdFx0XHRkaXJlY3RpdmVzID0ge1xuXHRcdFx0XHQnaW50cm8tb3V0cm8nOiAndDAnLFxuXHRcdFx0XHRpbnRybzogJ3QxJyxcblx0XHRcdFx0b3V0cm86ICd0MicsXG5cdFx0XHRcdGRlY29yYXRvcjogJ28nXG5cdFx0XHR9LFxuXHRcdFx0ZXhjbHVkZSA9IHtcblx0XHRcdFx0ZXhjbHVkZTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGNvbnZlcnRlcnMsIGRpc2FsbG93ZWRDb250ZW50cztcblx0XHQvLyBEaWZmZXJlbnQgc2V0IG9mIGNvbnZlcnRlcnMsIGJlY2F1c2UgdGhpcyB0aW1lIHdlJ3JlIGxvb2tpbmcgZm9yIGNsb3NpbmcgdGFnc1xuXHRcdGNvbnZlcnRlcnMgPSBbXG5cdFx0XHRnZXRNdXN0YWNoZSxcblx0XHRcdGdldENvbW1lbnQsXG5cdFx0XHRnZXRFbGVtZW50LFxuXHRcdFx0Z2V0VGV4dCxcblx0XHRcdGdldENsb3NpbmdUYWdcblx0XHRdO1xuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LXRhZy1vbWlzc2lvblxuXHRcdGRpc2FsbG93ZWRDb250ZW50cyA9IHtcblx0XHRcdGxpOiBbICdsaScgXSxcblx0XHRcdGR0OiBbXG5cdFx0XHRcdCdkdCcsXG5cdFx0XHRcdCdkZCdcblx0XHRcdF0sXG5cdFx0XHRkZDogW1xuXHRcdFx0XHQnZHQnLFxuXHRcdFx0XHQnZGQnXG5cdFx0XHRdLFxuXHRcdFx0cDogJ2FkZHJlc3MgYXJ0aWNsZSBhc2lkZSBibG9ja3F1b3RlIGRpdiBkbCBmaWVsZHNldCBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkZXIgaGdyb3VwIGhyIG1haW4gbWVudSBuYXYgb2wgcCBwcmUgc2VjdGlvbiB0YWJsZSB1bCcuc3BsaXQoICcgJyApLFxuXHRcdFx0cnQ6IFtcblx0XHRcdFx0J3J0Jyxcblx0XHRcdFx0J3JwJ1xuXHRcdFx0XSxcblx0XHRcdHJwOiBbXG5cdFx0XHRcdCdydCcsXG5cdFx0XHRcdCdycCdcblx0XHRcdF0sXG5cdFx0XHRvcHRncm91cDogWyAnb3B0Z3JvdXAnIF0sXG5cdFx0XHRvcHRpb246IFtcblx0XHRcdFx0J29wdGlvbicsXG5cdFx0XHRcdCdvcHRncm91cCdcblx0XHRcdF0sXG5cdFx0XHR0aGVhZDogW1xuXHRcdFx0XHQndGJvZHknLFxuXHRcdFx0XHQndGZvb3QnXG5cdFx0XHRdLFxuXHRcdFx0dGJvZHk6IFtcblx0XHRcdFx0J3Rib2R5Jyxcblx0XHRcdFx0J3Rmb290J1xuXHRcdFx0XSxcblx0XHRcdHRmb290OiBbICd0Ym9keScgXSxcblx0XHRcdHRyOiBbXG5cdFx0XHRcdCd0cicsXG5cdFx0XHRcdCd0Ym9keSdcblx0XHRcdF0sXG5cdFx0XHR0ZDogW1xuXHRcdFx0XHQndGQnLFxuXHRcdFx0XHQndGgnLFxuXHRcdFx0XHQndHInXG5cdFx0XHRdLFxuXHRcdFx0dGg6IFtcblx0XHRcdFx0J3RkJyxcblx0XHRcdFx0J3RoJyxcblx0XHRcdFx0J3RyJ1xuXHRcdFx0XVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBnZXRFbGVtZW50O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RWxlbWVudCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBlbGVtZW50LCBsb3dlckNhc2VOYW1lLCBkaXJlY3RpdmVOYW1lLCBtYXRjaCwgYWRkUHJveHlFdmVudCwgYXR0cmlidXRlLCBkaXJlY3RpdmUsIHNlbGZDbG9zaW5nLCBjaGlsZHJlbiwgY2hpbGQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoIHBhcnNlci5pbnNpZGUgfHwgcGFyc2VyLmluQXR0cmlidXRlICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzwnICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG5cdFx0XHRpZiAoIHBhcnNlci5uZXh0Q2hhcigpID09PSAnLycgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudCA9IHtcblx0XHRcdFx0dDogdHlwZXMuRUxFTUVOVFxuXHRcdFx0fTtcblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRlbGVtZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyggc3RhcnQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnIScgKSApIHtcblx0XHRcdFx0ZWxlbWVudC55ID0gMTtcblx0XHRcdH1cblx0XHRcdC8vIGVsZW1lbnQgbmFtZVxuXHRcdFx0ZWxlbWVudC5lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdGFnTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIWVsZW1lbnQuZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcblx0XHRcdGlmICggIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QoIHBhcnNlci5uZXh0Q2hhcigpICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgdGFnIG5hbWUnICk7XG5cdFx0XHR9XG5cdFx0XHRhZGRQcm94eUV2ZW50ID0gZnVuY3Rpb24oIG5hbWUsIGRpcmVjdGl2ZSApIHtcblx0XHRcdFx0dmFyIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubiB8fCBkaXJlY3RpdmU7XG5cdFx0XHRcdGlmICggcmVzZXJ2ZWRFdmVudE5hbWVzLnRlc3QoIGRpcmVjdGl2ZU5hbWUgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zIC09IGRpcmVjdGl2ZU5hbWUubGVuZ3RoO1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0Nhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUsIGNvbnN0cnVjdCwgY29uZmlnLCBpbml0LCByZW5kZXIsIHVucmVuZGVyLCBkZXRhY2gsIGluc2VydCknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbWVudC52WyBuYW1lIF0gPSBkaXJlY3RpdmU7XG5cdFx0XHR9O1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gZGlyZWN0aXZlcyBhbmQgYXR0cmlidXRlc1xuXHRcdFx0d2hpbGUgKCBhdHRyaWJ1dGUgPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Ly8gcmVndWxhciBhdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICggYXR0cmlidXRlLm5hbWUgKSB7XG5cdFx0XHRcdFx0Ly8gaW50cm8sIG91dHJvLCBkZWNvcmF0b3Jcblx0XHRcdFx0XHRpZiAoIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVzWyBhdHRyaWJ1dGUubmFtZSBdICkge1xuXHRcdFx0XHRcdFx0ZWxlbWVudFsgZGlyZWN0aXZlTmFtZSBdID0gcHJvY2Vzc0RpcmVjdGl2ZSggYXR0cmlidXRlLnZhbHVlICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZWxlbWVudC52IClcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC52ID0ge307XG5cdFx0XHRcdFx0XHRkaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlKCBhdHRyaWJ1dGUudmFsdWUgKTtcblx0XHRcdFx0XHRcdGFkZFByb3h5RXZlbnQoIG1hdGNoWyAxIF0sIGRpcmVjdGl2ZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoICFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICFlbGVtZW50LmEgKVxuXHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQuYSA9IHt9O1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmFbIGF0dHJpYnV0ZS5uYW1lIF0gPSBhdHRyaWJ1dGUudmFsdWUgfHwgMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCAhZWxlbWVudC5tIClcblx0XHRcdFx0XHRcdGVsZW1lbnQubSA9IFtdO1xuXHRcdFx0XHRcdGVsZW1lbnQubS5wdXNoKCBhdHRyaWJ1dGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nIHNvbGlkdXNcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIHNlbGYtY2xvc2luZyBzb2xpZHVzP1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcvJyApICkge1xuXHRcdFx0XHRzZWxmQ2xvc2luZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBjbG9zaW5nIGFuZ2xlIGJyYWNrZXRcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz4nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0bG93ZXJDYXNlTmFtZSA9IGVsZW1lbnQuZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKCAhc2VsZkNsb3NpbmcgJiYgIXZvaWRFbGVtZW50TmFtZXMudGVzdCggZWxlbWVudC5lICkgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGlmIHdlIG9wZW4gYSBzY3JpcHQgZWxlbWVudCwgZnVydGhlciB0YWdzIHNob3VsZFxuXHRcdFx0XHQvLyBiZSBpZ25vcmVkIHVubGVzcyB0aGV5J3JlIGEgY2xvc2luZyBzY3JpcHQgZWxlbWVudFxuXHRcdFx0XHRpZiAoIGxvd2VyQ2FzZU5hbWUgPT09ICdzY3JpcHQnIHx8IGxvd2VyQ2FzZU5hbWUgPT09ICdzdHlsZScgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmluc2lkZSA9IGxvd2VyQ2FzZU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBjYW5Db250YWluKCBsb3dlckNhc2VOYW1lLCBwYXJzZXIucmVtYWluaW5nKCkgKSAmJiAoIGNoaWxkID0gcGFyc2VyLnJlYWQoIGNvbnZlcnRlcnMgKSApICkge1xuXHRcdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGNsb3Npbmcgc2VjdGlvbiB0YWdcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HX1RBRyApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdGVsZW1lbnQuZiA9IGNoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5zaWRlID0gbnVsbDtcblx0XHRcdGlmICggcGFyc2VyLnNhbml0aXplRWxlbWVudHMgJiYgcGFyc2VyLnNhbml0aXplRWxlbWVudHMuaW5kZXhPZiggbG93ZXJDYXNlTmFtZSApICE9PSAtMSApIHtcblx0XHRcdFx0cmV0dXJuIGV4Y2x1ZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYW5Db250YWluKCBuYW1lLCByZW1haW5pbmcgKSB7XG5cdFx0XHR2YXIgbWF0Y2gsIGRpc2FsbG93ZWQ7XG5cdFx0XHRtYXRjaCA9IC9ePChbYS16QS1aXVthLXpBLVowLTldKikvLmV4ZWMoIHJlbWFpbmluZyApO1xuXHRcdFx0ZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWRDb250ZW50c1sgbmFtZSBdO1xuXHRcdFx0aWYgKCAhbWF0Y2ggfHwgIWRpc2FsbG93ZWQgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICF+ZGlzYWxsb3dlZC5pbmRleE9mKCBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgdm9pZEVsZW1lbnROYW1lcywgbXVzdGFjaGUsIGNvbW1lbnQsIHRleHQsIGNsb3NpbmdUYWcsIGF0dHJpYnV0ZSwgcHJvY2Vzc0RpcmVjdGl2ZSApO1xuXG5cdC8qIHBhcnNlL3V0aWxzL3RyaW1XaGl0ZXNwYWNlLmpzICovXG5cdHZhciB0cmltV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gL15bIFxcdFxcZlxcclxcbl0rLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBpdGVtcywgbGVhZGluZywgdHJhaWxpbmcgKSB7XG5cdFx0XHR2YXIgaXRlbTtcblx0XHRcdGlmICggbGVhZGluZyApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyAwIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoIGxlYWRpbmdXaGl0ZXNwYWNlLCAnJyApO1xuXHRcdFx0XHRcdGlmICggIWl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgMCBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggdHJhaWxpbmcgKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKCB0cmFpbGluZ1doaXRlc3BhY2UsICcnICk7XG5cdFx0XHRcdFx0aWYgKCAhaXRlbSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvdXRpbHMvc3RyaXBTdGFuZGFsb25lcy5qcyAqL1xuXHR2YXIgc3RyaXBTdGFuZGFsb25lcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgbGVhZGluZ0xpbmVicmVhayA9IC9eXFxzKlxccj9cXG4vLFxuXHRcdFx0dHJhaWxpbmdMaW5lYnJlYWsgPSAvXFxyP1xcblxccyokLztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcblx0XHRcdHZhciBpLCBjdXJyZW50LCBiYWNrT25lLCBiYWNrVHdvLCBsYXN0U2VjdGlvbkl0ZW07XG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRjdXJyZW50ID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0YmFja09uZSA9IGl0ZW1zWyBpIC0gMSBdO1xuXHRcdFx0XHRiYWNrVHdvID0gaXRlbXNbIGkgLSAyIF07XG5cdFx0XHRcdC8vIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgYSBbdGV4dF1bY29tbWVudF1bdGV4dF0gc2VxdWVuY2UuLi5cblx0XHRcdFx0aWYgKCBpc1N0cmluZyggY3VycmVudCApICYmIGlzQ29tbWVudCggYmFja09uZSApICYmIGlzU3RyaW5nKCBiYWNrVHdvICkgKSB7XG5cdFx0XHRcdFx0Ly8gLi4uIGFuZCB0aGUgY29tbWVudCBpcyBhIHN0YW5kYWxvbmUgKGkuZS4gbGluZSBicmVha3MgZWl0aGVyIHNpZGUpLi4uXG5cdFx0XHRcdFx0aWYgKCB0cmFpbGluZ0xpbmVicmVhay50ZXN0KCBiYWNrVHdvICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi4gdGhlbiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBhZnRlciB0aGUgZmlyc3QgbGluZSBicmVha1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgLSAyIF0gPSBiYWNrVHdvLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0Ly8gYW5kIHRoZSBsZWFkaW5nIGxpbmUgYnJlYWsgb2YgdGhlIHNlY29uZCB0ZXh0IHRva2VuXG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gY3VycmVudC5yZXBsYWNlKCBsZWFkaW5nTGluZWJyZWFrLCAnJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgY3VycmVudCBpdGVtIGlzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIHByZWNlZGVkIGJ5IGEgbGluZWJyZWFrLCBhbmRcblx0XHRcdFx0Ly8gaXRzIGZpcnN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cblx0XHRcdFx0aWYgKCBpc1NlY3Rpb24oIGN1cnJlbnQgKSAmJiBpc1N0cmluZyggYmFja09uZSApICkge1xuXHRcdFx0XHRcdGlmICggdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggYmFja09uZSApICYmIGlzU3RyaW5nKCBjdXJyZW50LmZbIDAgXSApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudC5mWyAwIF0gKSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIC0gMSBdID0gYmFja09uZS5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdGN1cnJlbnQuZlsgMCBdID0gY3VycmVudC5mWyAwIF0ucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGxhc3QgaXRlbSB3YXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgZm9sbG93ZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuXHRcdFx0XHQvLyBpdHMgbGFzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG5cdFx0XHRcdGlmICggaXNTdHJpbmcoIGN1cnJlbnQgKSAmJiBpc1NlY3Rpb24oIGJhY2tPbmUgKSApIHtcblx0XHRcdFx0XHRsYXN0U2VjdGlvbkl0ZW0gPSBiYWNrT25lLmZbIGJhY2tPbmUuZi5sZW5ndGggLSAxIF07XG5cdFx0XHRcdFx0aWYgKCBpc1N0cmluZyggbGFzdFNlY3Rpb25JdGVtICkgJiYgdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggbGFzdFNlY3Rpb25JdGVtICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50ICkgKSB7XG5cdFx0XHRcdFx0XHRiYWNrT25lLmZbIGJhY2tPbmUuZi5sZW5ndGggLSAxIF0gPSBsYXN0U2VjdGlvbkl0ZW0ucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gY3VycmVudC5yZXBsYWNlKCBsZWFkaW5nTGluZWJyZWFrLCAnJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1N0cmluZyggaXRlbSApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDb21tZW50KCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udCA9PT0gdHlwZXMuQ09NTUVOVCB8fCBpdGVtLnQgPT09IHR5cGVzLkRFTElNQ0hBTkdFO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU2VjdGlvbiggaXRlbSApIHtcblx0XHRcdHJldHVybiAoIGl0ZW0udCA9PT0gdHlwZXMuU0VDVElPTiB8fCBpdGVtLnQgPT09IHR5cGVzLklOVkVSVEVEICkgJiYgaXRlbS5mO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzICk7XG5cblx0LyogdXRpbHMvZXNjYXBlUmVnRXhwLmpzICovXG5cdHZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBwYXR0ZXJuID0gL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCggc3RyICkge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCBwYXR0ZXJuLCAnXFxcXCQmJyApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9fcGFyc2UuanMgKi9cblx0dmFyIHBhcnNlID0gZnVuY3Rpb24oIHR5cGVzLCBQYXJzZXIsIG11c3RhY2hlLCBjb21tZW50LCBlbGVtZW50LCB0ZXh0LCB0cmltV2hpdGVzcGFjZSwgc3RyaXBTdGFuZGFsb25lcywgZXNjYXBlUmVnRXhwICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBTdGFuZGFyZFBhcnNlciwgcGFyc2UsIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSsvZyxcblx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzID0gL14oPzpwcmV8c2NyaXB0fHN0eWxlfHRleHRhcmVhKSQvaSxcblx0XHRcdGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9cXHMrJC87XG5cdFx0U3RhbmRhcmRQYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHQvLyBjb25maWdcblx0XHRcdFx0c2V0RGVsaW1pdGVycyggb3B0aW9ucywgdGhpcyApO1xuXHRcdFx0XHR0aGlzLnNlY3Rpb25EZXB0aCA9IDA7XG5cdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGUgPSB7XG5cdFx0XHRcdFx0c2NyaXB0OiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnNjcmlwdCAhPT0gZmFsc2UsXG5cdFx0XHRcdFx0c3R5bGU6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc3R5bGUgIT09IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggb3B0aW9ucy5zYW5pdGl6ZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRvcHRpb25zLnNhbml0aXplID0ge1xuXHRcdFx0XHRcdFx0Ly8gYmxhY2tsaXN0IGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtY2FqYS9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2NhamEvbGFuZy9odG1sL2h0bWw0LWVsZW1lbnRzLXdoaXRlbGlzdC5qc29uXG5cdFx0XHRcdFx0XHRlbGVtZW50czogJ2FwcGxldCBiYXNlIGJhc2Vmb250IGJvZHkgZnJhbWUgZnJhbWVzZXQgaGVhZCBodG1sIGlzaW5kZXggbGluayBtZXRhIG5vZnJhbWVzIG5vc2NyaXB0IG9iamVjdCBwYXJhbSBzY3JpcHQgc3R5bGUgdGl0bGUnLnNwbGl0KCAnICcgKSxcblx0XHRcdFx0XHRcdGV2ZW50QXR0cmlidXRlczogdHJ1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zYW5pdGl6ZUVsZW1lbnRzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmVsZW1lbnRzO1xuXHRcdFx0XHR0aGlzLnNhbml0aXplRXZlbnRBdHRyaWJ1dGVzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmV2ZW50QXR0cmlidXRlcztcblx0XHRcdFx0dGhpcy5pbmNsdWRlTGluZVBvc2l0aW9ucyA9IG9wdGlvbnMuaW5jbHVkZUxpbmVQb3NpdGlvbnM7XG5cdFx0XHR9LFxuXHRcdFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uKCBpdGVtcywgb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNlY3Rpb25EZXB0aCA+IDAgKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvciggJ0Egc2VjdGlvbiB3YXMgbGVmdCBvcGVuJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNsZWFudXAoIGl0ZW1zLCBvcHRpb25zLnN0cmlwQ29tbWVudHMgIT09IGZhbHNlLCBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgIW9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAhb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIG9wdGlvbnMucmV3cml0ZUVsc2UgIT09IGZhbHNlICk7XG5cdFx0XHRcdHJldHVybiBpdGVtcztcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzOiBbXG5cdFx0XHRcdG11c3RhY2hlLFxuXHRcdFx0XHRjb21tZW50LFxuXHRcdFx0XHRlbGVtZW50LFxuXHRcdFx0XHR0ZXh0XG5cdFx0XHRdXG5cdFx0fSApO1xuXHRcdHBhcnNlID0gZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0dmFyIHJlc3VsdCwgcmVtYWluaW5nLCBwYXJ0aWFscywgbmFtZSwgc3RhcnRNYXRjaCwgZW5kTWF0Y2gsIGlubGluZVBhcnRpYWxTdGFydCwgaW5saW5lUGFydGlhbEVuZDtcblx0XHRcdHNldERlbGltaXRlcnMoIG9wdGlvbnMgKTtcblx0XHRcdGlubGluZVBhcnRpYWxTdGFydCA9IG5ldyBSZWdFeHAoICc8IS0tXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggb3B0aW9ucy5kZWxpbWl0ZXJzWyAwIF0gKSArICdcXFxccyo+XFxcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXFxccyonICsgZXNjYXBlUmVnRXhwKCBvcHRpb25zLmRlbGltaXRlcnNbIDEgXSApICsgJ1xcXFxzKi0tPicgKTtcblx0XHRcdGlubGluZVBhcnRpYWxFbmQgPSBuZXcgUmVnRXhwKCAnPCEtLVxcXFxzKicgKyBlc2NhcGVSZWdFeHAoIG9wdGlvbnMuZGVsaW1pdGVyc1sgMCBdICkgKyAnXFxcXHMqXFxcXC9cXFxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKVxcXFxzKicgKyBlc2NhcGVSZWdFeHAoIG9wdGlvbnMuZGVsaW1pdGVyc1sgMSBdICkgKyAnXFxcXHMqLS0+JyApO1xuXHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHR2OiAxXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBpbmxpbmVQYXJ0aWFsU3RhcnQudGVzdCggdGVtcGxhdGUgKSApIHtcblx0XHRcdFx0cmVtYWluaW5nID0gdGVtcGxhdGU7XG5cdFx0XHRcdHRlbXBsYXRlID0gJyc7XG5cdFx0XHRcdHdoaWxlICggc3RhcnRNYXRjaCA9IGlubGluZVBhcnRpYWxTdGFydC5leGVjKCByZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRuYW1lID0gc3RhcnRNYXRjaFsgMSBdO1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IHJlbWFpbmluZy5zdWJzdHIoIDAsIHN0YXJ0TWF0Y2guaW5kZXggKTtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBzdGFydE1hdGNoLmluZGV4ICsgc3RhcnRNYXRjaFsgMCBdLmxlbmd0aCApO1xuXHRcdFx0XHRcdGVuZE1hdGNoID0gaW5saW5lUGFydGlhbEVuZC5leGVjKCByZW1haW5pbmcgKTtcblx0XHRcdFx0XHRpZiAoICFlbmRNYXRjaCB8fCBlbmRNYXRjaFsgMSBdICE9PSBuYW1lICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW5saW5lIHBhcnRpYWxzIG11c3QgaGF2ZSBhIGNsb3NpbmcgZGVsaW1pdGVyLCBhbmQgY2Fubm90IGJlIG5lc3RlZC4gRXhwZWN0ZWQgY2xvc2luZyBmb3IgXCInICsgbmFtZSArICdcIiwgYnV0ICcgKyAoIGVuZE1hdGNoID8gJ2luc3RlYWQgZm91bmQgXCInICsgZW5kTWF0Y2hbIDEgXSArICdcIicgOiAnIG5vIGNsb3NpbmcgZm91bmQnICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KCBwYXJ0aWFscyB8fCAoIHBhcnRpYWxzID0ge30gKSApWyBuYW1lIF0gPSBuZXcgU3RhbmRhcmRQYXJzZXIoIHJlbWFpbmluZy5zdWJzdHIoIDAsIGVuZE1hdGNoLmluZGV4ICksIG9wdGlvbnMgKS5yZXN1bHQ7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggZW5kTWF0Y2guaW5kZXggKyBlbmRNYXRjaFsgMCBdLmxlbmd0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlICs9IHJlbWFpbmluZztcblx0XHRcdFx0cmVzdWx0LnAgPSBwYXJ0aWFscztcblx0XHRcdH1cblx0XHRcdHJlc3VsdC50ID0gbmV3IFN0YW5kYXJkUGFyc2VyKCB0ZW1wbGF0ZSwgb3B0aW9ucyApLnJlc3VsdDtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IHBhcnNlO1xuXG5cdFx0ZnVuY3Rpb24gY2xlYW51cCggaXRlbXMsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSwgcmV3cml0ZUVsc2UgKSB7XG5cdFx0XHR2YXIgaSwgaXRlbSwgcHJldmlvdXNJdGVtLCBuZXh0SXRlbSwgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCB1bmxlc3NCbG9jaywga2V5O1xuXHRcdFx0Ly8gRmlyc3QgcGFzcyAtIHJlbW92ZSBzdGFuZGFsb25lcyBhbmQgY29tbWVudHMgZXRjXG5cdFx0XHRzdHJpcFN0YW5kYWxvbmVzKCBpdGVtcyApO1xuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0Ly8gUmVtb3ZlIGRlbGltaXRlciBjaGFuZ2VzLCB1bnNhZmUgZWxlbWVudHMgZXRjXG5cdFx0XHRcdGlmICggaXRlbS5leGNsdWRlICkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdHJpcENvbW1lbnRzICYmIGl0ZW0udCA9PT0gdHlwZXMuQ09NTUVOVCApIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgbmVjZXNzYXJ5LCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuXHRcdFx0dHJpbVdoaXRlc3BhY2UoIGl0ZW1zLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlICk7XG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0XHQvLyBSZWN1cnNlXG5cdFx0XHRcdGlmICggaXRlbS5mICkge1xuXHRcdFx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gcHJlc2VydmVXaGl0ZXNwYWNlIHx8IGl0ZW0udCA9PT0gdHlwZXMuRUxFTUVOVCAmJiBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cy50ZXN0KCBpdGVtLmUgKTtcblx0XHRcdFx0XHRpZiAoICFwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdHByZXZpb3VzSXRlbSA9IGl0ZW1zWyBpIC0gMSBdO1xuXHRcdFx0XHRcdFx0bmV4dEl0ZW0gPSBpdGVtc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBwcmV2aW91cyBpdGVtIHdhcyBhIHRleHQgaXRlbSB3aXRoIHRyYWlsaW5nIHdoaXRlc3BhY2UsXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgZnJhZ21lbnRcblx0XHRcdFx0XHRcdGlmICggIXByZXZpb3VzSXRlbSB8fCB0eXBlb2YgcHJldmlvdXNJdGVtID09PSAnc3RyaW5nJyAmJiB0cmFpbGluZ1doaXRlc3BhY2UudGVzdCggcHJldmlvdXNJdGVtICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYW5kIHZpY2UgdmVyc2Fcblx0XHRcdFx0XHRcdGlmICggIW5leHRJdGVtIHx8IHR5cGVvZiBuZXh0SXRlbSA9PT0gJ3N0cmluZycgJiYgbGVhZGluZ1doaXRlc3BhY2UudGVzdCggbmV4dEl0ZW0gKSApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBTcGxpdCBpZi1lbHNlIGJsb2NrcyBpbnRvIHR3byAoYW4gaWYsIGFuZCBhbiB1bmxlc3MpXG5cdFx0XHRcdGlmICggaXRlbS5sICkge1xuXHRcdFx0XHRcdGNsZWFudXAoIGl0ZW0ubCwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0XHRpZiAoIHJld3JpdGVFbHNlICkge1xuXHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sgPSB7XG5cdFx0XHRcdFx0XHRcdHQ6IDQsXG5cdFx0XHRcdFx0XHRcdG46IHR5cGVzLlNFQ1RJT05fVU5MRVNTLFxuXHRcdFx0XHRcdFx0XHRmOiBpdGVtLmxcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHQvLyBjb3B5IHRoZSBjb25kaXRpb25hbCBiYXNlZCBvbiBpdHMgdHlwZVxuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLnIgKSB7XG5cdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnIgPSBpdGVtLnI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0ueCApIHtcblx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sueCA9IGl0ZW0ueDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaXRlbS5yeCApIHtcblx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sucnggPSBpdGVtLnJ4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpICsgMSwgMCwgdW5sZXNzQmxvY2sgKTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBpdGVtLmw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENsZWFuIHVwIGVsZW1lbnQgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGl0ZW0uYSApIHtcblx0XHRcdFx0XHRmb3IgKCBrZXkgaW4gaXRlbS5hICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLmEuaGFzT3duUHJvcGVydHkoIGtleSApICYmIHR5cGVvZiBpdGVtLmFbIGtleSBdICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5hWyBrZXkgXSwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGZpbmFsIHBhc3MgLSBmdXNlIHRleHQgbm9kZXMgdG9nZXRoZXJcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbXNbIGkgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbXNbIGkgKyAxIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGl0ZW1zWyBpIF0gKyBpdGVtc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSArIDEsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlICkge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGl0ZW1zWyBpIF0ucmVwbGFjZSggY29udGlndW91c1doaXRlc3BhY2UsICcgJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGl0ZW1zWyBpIF0gPT09ICcnICkge1xuXHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0RGVsaW1pdGVycyggc291cmNlICkge1xuXHRcdFx0dmFyIHRhcmdldCA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHZvaWQgMCApXG5cdFx0XHRcdHRhcmdldCA9IHNvdXJjZTtcblx0XHRcdHRhcmdldC5kZWxpbWl0ZXJzID0gc291cmNlLmRlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQne3snLFxuXHRcdFx0XHQnfX0nXG5cdFx0XHRdO1xuXHRcdFx0dGFyZ2V0LnRyaXBsZURlbGltaXRlcnMgPSBzb3VyY2UudHJpcGxlRGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdCd7e3snLFxuXHRcdFx0XHQnfX19J1xuXHRcdFx0XTtcblx0XHRcdHRhcmdldC5zdGF0aWNEZWxpbWl0ZXJzID0gc291cmNlLnN0YXRpY0RlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQnW1snLFxuXHRcdFx0XHQnXV0nXG5cdFx0XHRdO1xuXHRcdFx0dGFyZ2V0LnN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBzb3VyY2Uuc3RhdGljVHJpcGxlRGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdCdbW1snLFxuXHRcdFx0XHQnXV1dJ1xuXHRcdFx0XTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgUGFyc2VyLCBtdXN0YWNoZSwgY29tbWVudCwgZWxlbWVudCwgdGV4dCwgdHJpbVdoaXRlc3BhY2UsIHN0cmlwU3RhbmRhbG9uZXMsIGVzY2FwZVJlZ0V4cCApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2dyb3Vwcy9vcHRpb25Hcm91cC5qcyAqL1xuXHR2YXIgb3B0aW9uR3JvdXAgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVPcHRpb25Hcm91cCgga2V5cywgY29uZmlnICkge1xuXHRcdFx0dmFyIGdyb3VwID0ga2V5cy5tYXAoIGNvbmZpZyApO1xuXHRcdFx0a2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5LCBpICkge1xuXHRcdFx0XHRncm91cFsga2V5IF0gPSBncm91cFsgaSBdO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGdyb3VwO1xuXHRcdH07XG5cdH0oIGxlZ2FjeSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2dyb3Vwcy9wYXJzZU9wdGlvbnMuanMgKi9cblx0dmFyIHBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uKCBvcHRpb25Hcm91cCApIHtcblxuXHRcdHZhciBrZXlzLCBwYXJzZU9wdGlvbnM7XG5cdFx0a2V5cyA9IFtcblx0XHRcdCdwcmVzZXJ2ZVdoaXRlc3BhY2UnLFxuXHRcdFx0J3Nhbml0aXplJyxcblx0XHRcdCdzdHJpcENvbW1lbnRzJyxcblx0XHRcdCdkZWxpbWl0ZXJzJyxcblx0XHRcdCd0cmlwbGVEZWxpbWl0ZXJzJyxcblx0XHRcdCdpbnRlcnBvbGF0ZSdcblx0XHRdO1xuXHRcdHBhcnNlT3B0aW9ucyA9IG9wdGlvbkdyb3VwKCBrZXlzLCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHBhcnNlT3B0aW9ucztcblx0fSggb3B0aW9uR3JvdXAgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy90ZW1wbGF0ZS9wYXJzZXIuanMgKi9cblx0dmFyIHBhcnNlciA9IGZ1bmN0aW9uKCBlcnJvcnMsIGlzQ2xpZW50LCBwYXJzZSwgY3JlYXRlLCBwYXJzZU9wdGlvbnMgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0ge1xuXHRcdFx0cGFyc2U6IGRvUGFyc2UsXG5cdFx0XHRmcm9tSWQ6IGZyb21JZCxcblx0XHRcdGlzSGFzaGVkSWQ6IGlzSGFzaGVkSWQsXG5cdFx0XHRpc1BhcnNlZDogaXNQYXJzZWQsXG5cdFx0XHRnZXRQYXJzZU9wdGlvbnM6IGdldFBhcnNlT3B0aW9ucyxcblx0XHRcdGNyZWF0ZUhlbHBlcjogY3JlYXRlSGVscGVyXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUhlbHBlciggcGFyc2VPcHRpb25zICkge1xuXHRcdFx0dmFyIGhlbHBlciA9IGNyZWF0ZSggcGFyc2VyICk7XG5cdFx0XHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiggdGVtcGxhdGUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiBkb1BhcnNlKCB0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMgKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaGVscGVyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvUGFyc2UoIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoICFwYXJzZSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvcnMubWlzc2luZ1BhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zIHx8IHRoaXMub3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZyb21JZCggaWQsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGVtcGxhdGU7XG5cdFx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IHJldHJpZXZlIHRlbXBsYXRlICMnICsgaWQgKyAnIGFzIFJhY3RpdmUgaXMgbm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLicgKTtcblx0XHRcdH1cblx0XHRcdGlmICggaXNIYXNoZWRJZCggaWQgKSApIHtcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHJpbmcoIDEgKTtcblx0XHRcdH1cblx0XHRcdGlmICggISggdGVtcGxhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggaWQgKSApICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgIycgKyBpZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdTQ1JJUFQnICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgIycgKyBpZCArICcsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50JyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0hhc2hlZElkKCBpZCApIHtcblx0XHRcdHJldHVybiBpZCAmJiBpZC5jaGFyQXQoIDAgKSA9PT0gJyMnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzUGFyc2VkKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHJldHVybiAhKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkge1xuXHRcdFx0Ly8gQ291bGQgYmUgUmFjdGl2ZSBvciBhIENvbXBvbmVudFxuXHRcdFx0aWYgKCByYWN0aXZlLmRlZmF1bHRzICkge1xuXHRcdFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5kZWZhdWx0cztcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJzZU9wdGlvbnMucmVkdWNlKCBmdW5jdGlvbiggdmFsLCBrZXkgKSB7XG5cdFx0XHRcdHZhbFsga2V5IF0gPSByYWN0aXZlWyBrZXkgXTtcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0sIHt9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJzZXI7XG5cdH0oIGVycm9ycywgaXNDbGllbnQsIHBhcnNlLCBjcmVhdGUsIHBhcnNlT3B0aW9ucyApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL3RlbXBsYXRlL3RlbXBsYXRlLmpzICovXG5cdHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKCBwYXJzZXIsIHBhcnNlICkge1xuXG5cdFx0dmFyIHRlbXBsYXRlQ29uZmlnID0ge1xuXHRcdFx0bmFtZTogJ3RlbXBsYXRlJyxcblx0XHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGU7XG5cdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGV4aXN0c1xuXHRcdFx0XHRpZiAoICd0ZW1wbGF0ZScgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcoIHRlbXBsYXRlLCBwcm90byApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uIGluaXQoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlLCBmbjtcblx0XHRcdFx0Ly8gVE9ETyBiZWNhdXNlIG9mIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHdlIG1pZ2h0IGp1c3QgYmUgYWJsZSB0byB1c2Vcblx0XHRcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZSwgYW5kIG5vdCBib3RoZXIgcGFzc2luZyB0aHJvdWdoIHRoZSBQYXJlbnQgb2JqZWN0LlxuXHRcdFx0XHQvLyBBdCBwcmVzZW50IHRoYXQgYnJlYWtzIHRoZSB0ZXN0IG1vY2tzJyBleHBlY3RhdGlvbnNcblx0XHRcdFx0dGVtcGxhdGUgPSAndGVtcGxhdGUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRlbXBsYXRlIDogUGFyZW50LnByb3RvdHlwZS50ZW1wbGF0ZTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0Zm4gPSB0ZW1wbGF0ZTtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgZm4gKTtcblx0XHRcdFx0XHRyYWN0aXZlLl9jb25maWcudGVtcGxhdGUgPSB7XG5cdFx0XHRcdFx0XHRmbjogZm4sXG5cdFx0XHRcdFx0XHRyZXN1bHQ6IHRlbXBsYXRlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcoIHRlbXBsYXRlLCByYWN0aXZlICk7XG5cdFx0XHRcdC8vIFRPRE8gdGhlIG5hbWluZyBvZiB0aGlzIGlzIGNvbmZ1c2luZyAtIHJhY3RpdmUudGVtcGxhdGUgcmVmZXJzIHRvIFsuLi5dLFxuXHRcdFx0XHQvLyBidXQgQ29tcG9uZW50LnByb3RvdHlwZS50ZW1wbGF0ZSByZWZlcnMgdG8ge3Y6MSx0OltdLHA6W119Li4uXG5cdFx0XHRcdC8vIGl0J3MgdW5uZWNlc3NhcnksIGJlY2F1c2UgdGhlIGRldmVsb3BlciBuZXZlciBuZWVkcyB0byBhY2Nlc3Ncblx0XHRcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZVxuXHRcdFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gdGVtcGxhdGUudDtcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZS5wICkge1xuXHRcdFx0XHRcdGV4dGVuZFBhcnRpYWxzKCByYWN0aXZlLnBhcnRpYWxzLCB0ZW1wbGF0ZS5wICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNldDogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSByZXNldFZhbHVlKCByYWN0aXZlICksXG5cdFx0XHRcdFx0cGFyc2VkO1xuXHRcdFx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdFx0XHRwYXJzZWQgPSBwYXJzZUlmU3RyaW5nKCByZXN1bHQsIHJhY3RpdmUgKTtcblx0XHRcdFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gcGFyc2VkLnQ7XG5cdFx0XHRcdFx0ZXh0ZW5kUGFydGlhbHMoIHJhY3RpdmUucGFydGlhbHMsIHBhcnNlZC5wLCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRWYWx1ZSggcmFjdGl2ZSApIHtcblx0XHRcdHZhciBpbml0aWFsID0gcmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlLFxuXHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHQvLyBJZiB0aGlzIGlzbid0IGEgZHluYW1pYyB0ZW1wbGF0ZSwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG5cdFx0XHRpZiAoICFpbml0aWFsIHx8ICFpbml0aWFsLmZuICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGluaXRpYWwuZm4gKTtcblx0XHRcdC8vIFRPRE8gZGVlcCBlcXVhbGl0eSBjaGVjayB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcmluZ1xuXHRcdFx0Ly8gaW4gdGhlIGNhc2Ugb2YgYWxyZWFkeS1wYXJzZWQgdGVtcGxhdGVzXG5cdFx0XHRpZiAoIHJlc3VsdCAhPT0gaW5pdGlhbC5yZXN1bHQgKSB7XG5cdFx0XHRcdGluaXRpYWwucmVzdWx0ID0gcmVzdWx0O1xuXHRcdFx0XHRyZXN1bHQgPSBwYXJzZUlmU3RyaW5nKCByZXN1bHQsIHJhY3RpdmUgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGZuICkge1xuXHRcdFx0dmFyIGhlbHBlciA9IHBhcnNlci5jcmVhdGVIZWxwZXIoIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0cmV0dXJuIGZuLmNhbGwoIHJhY3RpdmUsIHJhY3RpdmUuZGF0YSwgaGVscGVyICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHJhY3RpdmUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdC8vIElEIG9mIGFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgdGVtcGxhdGU/XG5cdFx0XHRcdGlmICggdGVtcGxhdGVbIDAgXSA9PT0gJyMnICkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gcGFyc2VyLmZyb21JZCggdGVtcGxhdGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS52ICE9PSAxICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNaXNtYXRjaGVkIHRlbXBsYXRlIHZlcnNpb24hIFBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgUmFjdGl2ZS5qcyBpbiB5b3VyIGJ1aWxkIHByb2Nlc3MgYXMgd2VsbCBhcyBpbiB5b3VyIGFwcCcgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZW1wbGF0ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmRQYXJ0aWFscyggZXhpc3RpbmdQYXJ0aWFscywgbmV3UGFydGlhbHMsIG92ZXJ3cml0ZSApIHtcblx0XHRcdGlmICggIW5ld1BhcnRpYWxzIClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Ly8gVE9ETyB0aGVyZSdzIGFuIGFtYmlndWl0eSBoZXJlIC0gd2UgbmVlZCB0byBvdmVyd3JpdGUgaW4gdGhlIGByZXNldCgpYFxuXHRcdFx0Ly8gY2FzZSwgYnV0IG5vdCBpbml0aWFsbHkuLi5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gbmV3UGFydGlhbHMgKSB7XG5cdFx0XHRcdGlmICggb3ZlcndyaXRlIHx8ICFleGlzdGluZ1BhcnRpYWxzLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHRleGlzdGluZ1BhcnRpYWxzWyBrZXkgXSA9IG5ld1BhcnRpYWxzWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGVtcGxhdGVDb25maWc7XG5cdH0oIHBhcnNlciwgcGFyc2UgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9SZWdpc3RyeS5qcyAqL1xuXHR2YXIgUmVnaXN0cnkgPSBmdW5jdGlvbiggY3JlYXRlICkge1xuXG5cdFx0ZnVuY3Rpb24gUmVnaXN0cnkoIG5hbWUsIHVzZURlZmF1bHRzICkge1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMudXNlRGVmYXVsdHMgPSB1c2VEZWZhdWx0cztcblx0XHR9XG5cdFx0UmVnaXN0cnkucHJvdG90eXBlID0ge1xuXHRcdFx0Y29uc3RydWN0b3I6IFJlZ2lzdHJ5LFxuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5jb25maWd1cmUoIHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsIHRoaXMudXNlRGVmYXVsdHMgPyBwcm90byA6IHByb3RvLmNvbnN0cnVjdG9yLCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5jb25maWd1cmUoIHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHRjb25maWd1cmU6IGZ1bmN0aW9uKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgbmFtZSBdLFxuXHRcdFx0XHRcdHJlZ2lzdHJ5O1xuXHRcdFx0XHRyZWdpc3RyeSA9IGNyZWF0ZSggUGFyZW50WyBuYW1lIF0gKTtcblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmVnaXN0cnlbIGtleSBdID0gb3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IHJlZ2lzdHJ5O1xuXHRcdFx0fSxcblx0XHRcdHJlc2V0OiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dmFyIHJlZ2lzdHJ5ID0gcmFjdGl2ZVsgdGhpcy5uYW1lIF07XG5cdFx0XHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRcdE9iamVjdC5rZXlzKCByZWdpc3RyeSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSByZWdpc3RyeVsga2V5IF07XG5cdFx0XHRcdFx0aWYgKCBpdGVtLl9mbiApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbS5fZm4uaXNPd25lciApIHtcblx0XHRcdFx0XHRcdFx0cmVnaXN0cnlbIGtleSBdID0gaXRlbS5fZm47XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgcmVnaXN0cnlbIGtleSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRPd25lcjogZnVuY3Rpb24oIHJhY3RpdmUsIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIHJhY3RpdmVbIHRoaXMubmFtZSBdLmhhc093blByb3BlcnR5KCBrZXkgKSA/IHJhY3RpdmUgOiB0aGlzLmZpbmRDb25zdHJ1Y3RvciggcmFjdGl2ZS5jb25zdHJ1Y3Rvciwga2V5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbnN0cnVjdG9yOiBmdW5jdGlvbiggY29uc3RydWN0b3IsIGtleSApIHtcblx0XHRcdFx0aWYgKCAhY29uc3RydWN0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb25zdHJ1Y3RvclsgdGhpcy5uYW1lIF0uaGFzT3duUHJvcGVydHkoIGtleSApID8gY29uc3RydWN0b3IgOiB0aGlzLmZpbmRDb25zdHJ1Y3RvciggY29uc3RydWN0b3IuX3BhcmVudCwga2V5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZDogZnVuY3Rpb24oIHJhY3RpdmUsIGtleSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJbIHRoaXMkMC5uYW1lIF1bIGtleSBdO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEluc3RhbmNlOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2VGaW5kKCByYWN0aXZlLCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRyZXR1cm4gclsgdGhpcyQwLm5hbWUgXVsga2V5IF0gPyByIDogdm9pZCAwO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlY3Vyc2VGaW5kKCByYWN0aXZlLCBmbiApIHtcblx0XHRcdHZhciBmaW5kLCBwYXJlbnQ7XG5cdFx0XHRpZiAoIGZpbmQgPSBmbiggcmFjdGl2ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gZmluZDtcblx0XHRcdH1cblx0XHRcdGlmICggIXJhY3RpdmUuaXNvbGF0ZWQgJiYgKCBwYXJlbnQgPSByYWN0aXZlLl9wYXJlbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2VGaW5kKCBwYXJlbnQsIGZuICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBSZWdpc3RyeTtcblx0fSggY3JlYXRlLCBsZWdhY3kgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvcmVnaXN0cmllcy5qcyAqL1xuXHR2YXIgcmVnaXN0cmllcyA9IGZ1bmN0aW9uKCBvcHRpb25Hcm91cCwgUmVnaXN0cnkgKSB7XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdFx0J2FkYXB0b3JzJyxcblx0XHRcdFx0J2NvbXBvbmVudHMnLFxuXHRcdFx0XHQnY29tcHV0ZWQnLFxuXHRcdFx0XHQnZGVjb3JhdG9ycycsXG5cdFx0XHRcdCdlYXNpbmcnLFxuXHRcdFx0XHQnZXZlbnRzJyxcblx0XHRcdFx0J2ludGVycG9sYXRvcnMnLFxuXHRcdFx0XHQncGFydGlhbHMnLFxuXHRcdFx0XHQndHJhbnNpdGlvbnMnXG5cdFx0XHRdLFxuXHRcdFx0cmVnaXN0cmllcyA9IG9wdGlvbkdyb3VwKCBrZXlzLCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2lzdHJ5KCBrZXksIGtleSA9PT0gJ2NvbXB1dGVkJyApO1xuXHRcdFx0fSApO1xuXHRcdHJldHVybiByZWdpc3RyaWVzO1xuXHR9KCBvcHRpb25Hcm91cCwgUmVnaXN0cnkgKTtcblxuXHQvKiB1dGlscy9ub29wLmpzICovXG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKiB1dGlscy93cmFwUHJvdG90eXBlTWV0aG9kLmpzICovXG5cdHZhciB3cmFwUHJvdG90eXBlTWV0aG9kID0gZnVuY3Rpb24oIG5vb3AgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiB3cmFwKCBwYXJlbnQsIG5hbWUsIG1ldGhvZCApIHtcblx0XHRcdGlmICggIS9fc3VwZXIvLnRlc3QoIG1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwU3VwZXIoKSB7XG5cdFx0XHRcdHZhciBzdXBlck1ldGhvZCA9IGdldFN1cGVyTWV0aG9kKCB3cmFwcGVyLl9wYXJlbnQsIG5hbWUgKSxcblx0XHRcdFx0XHRoYXNTdXBlciA9ICdfc3VwZXInIGluIHRoaXMsXG5cdFx0XHRcdFx0b2xkU3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGlmICggaGFzU3VwZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fc3VwZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHR3cmFwcGVyLl9tZXRob2QgPSBtZXRob2Q7XG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0U3VwZXJNZXRob2QoIHBhcmVudCwgbmFtZSApIHtcblx0XHRcdHZhciBtZXRob2Q7XG5cdFx0XHRpZiAoIG5hbWUgaW4gcGFyZW50ICkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJlbnRbIG5hbWUgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gZnVuY3Rpb24gcmV0dXJuVmFsdWUoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWV0aG9kID0gbm9vcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbm9vcCApO1xuXG5cdC8qIGNvbmZpZy9kZXByZWNhdGUuanMgKi9cblx0dmFyIGRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCB3YXJuLCBpc0FycmF5ICkge1xuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlKCBvcHRpb25zLCBkZXByZWNhdGVkLCBjb3JyZWN0ICkge1xuXHRcdFx0aWYgKCBkZXByZWNhdGVkIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggISggY29ycmVjdCBpbiBvcHRpb25zICkgKSB7XG5cdFx0XHRcdFx0d2FybiggZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCApICk7XG5cdFx0XHRcdFx0b3B0aW9uc1sgY29ycmVjdCBdID0gb3B0aW9uc1sgZGVwcmVjYXRlZCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCwgdHJ1ZSApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0LCBpc0Vycm9yICkge1xuXHRcdFx0cmV0dXJuICdvcHRpb25zLicgKyBkZXByZWNhdGVkICsgJyBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBvcHRpb25zLicgKyBjb3JyZWN0ICsgJy4nICsgKCBpc0Vycm9yID8gJyBZb3UgY2Fubm90IHNwZWNpZnkgYm90aCBvcHRpb25zLCBwbGVhc2UgdXNlIG9wdGlvbnMuJyArIGNvcnJlY3QgKyAnLicgOiAnJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZUV2ZW50RGVmaW5pdGlvbnMoIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdldmVudERlZmluaXRpb25zJywgJ2V2ZW50cycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGVBZGFwdG9ycyggb3B0aW9ucyApIHtcblx0XHRcdC8vIFVzaW5nIGV4dGVuZCB3aXRoIENvbXBvbmVudCBpbnN0ZWFkIG9mIG9wdGlvbnMsXG5cdFx0XHQvLyBsaWtlIEh1bWFuLmV4dGVuZCggU3BpZGVyICkgbWVhbnMgYWRhcHRvcnMgYXMgYSByZWdpc3RyeVxuXHRcdFx0Ly8gZ2V0cyBjb3BpZWQgdG8gb3B0aW9ucy4gU28gd2UgaGF2ZSB0byBjaGVjayBpZiBhY3R1YWxseSBhbiBhcnJheVxuXHRcdFx0aWYgKCBpc0FycmF5KCBvcHRpb25zLmFkYXB0b3JzICkgKSB7XG5cdFx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2FkYXB0b3JzJywgJ2FkYXB0JyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24gZGVwcmVjYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2JlZm9yZUluaXQnLCAnb25jb25zdHJ1Y3QnICk7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdpbml0JywgJ29ucmVuZGVyJyApO1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnY29tcGxldGUnLCAnb25jb21wbGV0ZScgKTtcblx0XHRcdGRlcHJlY2F0ZUV2ZW50RGVmaW5pdGlvbnMoIG9wdGlvbnMgKTtcblx0XHRcdGRlcHJlY2F0ZUFkYXB0b3JzKCBvcHRpb25zICk7XG5cdFx0fTtcblx0fSggd2FybiwgaXNBcnJheSApO1xuXG5cdC8qIGNvbmZpZy9jb25maWcuanMgKi9cblx0dmFyIGNvbmZpZyA9IGZ1bmN0aW9uKCBjc3MsIGRhdGEsIGRlZmF1bHRzLCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zLCByZWdpc3RyaWVzLCB3cmFwUHJvdG90eXBlLCBkZXByZWNhdGUgKSB7XG5cblx0XHR2YXIgY3VzdG9tLCBvcHRpb25zLCBjb25maWcsIGJsYWNrbGlzdGVkO1xuXHRcdC8vIHdvdWxkIGJlIG5pY2UgdG8gbm90IGhhdmUgdGhlc2UgaGVyZSxcblx0XHQvLyB0aGV5IGdldCBhZGRlZCBkdXJpbmcgaW5pdGlhbGlzZSwgc28gZm9yIG5vdyB3ZSBoYXZlXG5cdFx0Ly8gdG8gbWFrZSBzdXJlIG5vdCB0byB0cnkgYW5kIGV4dGVuZCB0aGVtLlxuXHRcdC8vIFBvc3NpYmx5LCB3ZSBjb3VsZCByZS1vcmRlciBhbmQgbm90IGFkZCB0aWxsIGxhdGVyXG5cdFx0Ly8gaW4gcHJvY2Vzcy5cblx0XHRibGFja2xpc3RlZCA9IHtcblx0XHRcdCdfcGFyZW50JzogdHJ1ZSxcblx0XHRcdCdfY29tcG9uZW50JzogdHJ1ZVxuXHRcdH07XG5cdFx0Y3VzdG9tID0ge1xuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdGNzczogY3NzXG5cdFx0fTtcblx0XHRvcHRpb25zID0gT2JqZWN0LmtleXMoIGRlZmF1bHRzICkuZmlsdGVyKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuICFyZWdpc3RyaWVzWyBrZXkgXSAmJiAhY3VzdG9tWyBrZXkgXSAmJiAhcGFyc2VPcHRpb25zWyBrZXkgXTtcblx0XHR9ICk7XG5cdFx0Ly8gdGhpcyBkZWZpbmVzIHRoZSBvcmRlcjpcblx0XHRjb25maWcgPSBbXS5jb25jYXQoIGN1c3RvbS5kYXRhLCBwYXJzZU9wdGlvbnMsIG9wdGlvbnMsIHJlZ2lzdHJpZXMsIGN1c3RvbS50ZW1wbGF0ZSwgY3VzdG9tLmNzcyApO1xuXHRcdGZvciAoIHZhciBrZXkgaW4gY3VzdG9tICkge1xuXHRcdFx0Y29uZmlnWyBrZXkgXSA9IGN1c3RvbVsga2V5IF07XG5cdFx0fVxuXHRcdC8vIGZvciBpdGVyYXRpb25cblx0XHRjb25maWcua2V5cyA9IE9iamVjdC5rZXlzKCBkZWZhdWx0cyApLmNvbmNhdCggcmVnaXN0cmllcy5tYXAoIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0cmV0dXJuIHIubmFtZTtcblx0XHR9ICkgKS5jb25jYXQoIFsgJ2NzcycgXSApO1xuXHRcdC8vIGFkZCB0aGVzZSB0byBibGFja2xpc3RlZCBrZXkncyB0aGF0IHdlIGRvbid0IGRvdWJsZSBleHRlbmRcblx0XHRjb25maWcua2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGJsYWNrbGlzdGVkWyBrZXkgXSA9IHRydWU7XG5cdFx0fSApO1xuXHRcdGNvbmZpZy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG5cdFx0Y29uZmlnLnJlZ2lzdHJpZXMgPSByZWdpc3RyaWVzO1xuXG5cdFx0ZnVuY3Rpb24gY3VzdG9tQ29uZmlnKCBtZXRob2QsIGtleSwgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApIHtcblx0XHRcdGN1c3RvbVsga2V5IF1bIG1ldGhvZCBdKCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0fVxuXHRcdGNvbmZpZy5leHRlbmQgPSBmdW5jdGlvbiggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdGNvbmZpZ3VyZSggJ2V4dGVuZCcsIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdGNvbmZpZy5pbml0ID0gZnVuY3Rpb24oIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdGNvbmZpZ3VyZSggJ2luaXQnLCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTdGFuZGFyZERlZmF1bHRLZXkoIGtleSApIHtcblx0XHRcdHJldHVybiBrZXkgaW4gZGVmYXVsdHMgJiYgISgga2V5IGluIGNvbmZpZy5wYXJzZU9wdGlvbnMgKSAmJiAhKCBrZXkgaW4gY3VzdG9tICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29uZmlndXJlKCBtZXRob2QsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMgKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAnZGF0YScsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGNvbmZpZy5wYXJzZU9wdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0aWYgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIGlzU3RhbmRhcmREZWZhdWx0S2V5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwUHJvdG90eXBlKCBQYXJlbnQucHJvdG90eXBlLCBrZXksIHZhbHVlICkgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uZmlnLnJlZ2lzdHJpZXMuZm9yRWFjaCggZnVuY3Rpb24oIHJlZ2lzdHJ5ICkge1xuXHRcdFx0XHRyZWdpc3RyeVsgbWV0aG9kIF0oIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdH0gKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAndGVtcGxhdGUnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ2NzcycsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGV4dGVuZE90aGVyTWV0aG9kcyggUGFyZW50LnByb3RvdHlwZSwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmRPdGhlck1ldGhvZHMoIHBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggISgga2V5IGluIGJsYWNrbGlzdGVkICkgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0dmFyIG1lbWJlciA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgdGhhdCBvdmVyd3JpdGVzIGEgbWV0aG9kLCB3cmFwIGl0OlxuXHRcdFx0XHRcdGlmICggdHlwZW9mIG1lbWJlciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdG1lbWJlciA9IHdyYXBQcm90b3R5cGUoIHBhcmVudCwga2V5LCBtZW1iZXIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zdGFuY2VbIGtleSBdID0gbWVtYmVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbmZpZy5yZXNldCA9IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5maWx0ZXIoIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0XHRyZXR1cm4gYy5yZXNldCAmJiBjLnJlc2V0KCByYWN0aXZlICk7XG5cdFx0XHR9ICkubWFwKCBmdW5jdGlvbiggYyApIHtcblx0XHRcdFx0cmV0dXJuIGMubmFtZTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdGNvbmZpZy5nZXRDb25zdHJ1Y3RUYXJnZXQgPSBmdW5jdGlvbiggcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdGlmICggb3B0aW9ucy5vbmNvbnN0cnVjdCApIHtcblx0XHRcdFx0Ly8gcHJldGVuZCB0aGlzIG9iamVjdCBsaXRlcmFsIGlzIHRoZSByYWN0aXZlIGluc3RhbmNlXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0b25jb25zdHJ1Y3Q6IHdyYXBQcm90b3R5cGUoIHJhY3RpdmUsICdvbmNvbnN0cnVjdCcsIG9wdGlvbnMub25jb25zdHJ1Y3QgKS5iaW5kKCByYWN0aXZlICksXG5cdFx0XHRcdFx0ZmlyZTogcmFjdGl2ZS5maXJlLmJpbmQoIHJhY3RpdmUgKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJhY3RpdmU7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gY29uZmlnO1xuXHR9KCBjc3MsIGRhdGEsIG9wdGlvbnMsIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMsIHJlZ2lzdHJpZXMsIHdyYXBQcm90b3R5cGVNZXRob2QsIGRlcHJlY2F0ZSApO1xuXG5cdC8qIHNoYXJlZC9pbnRlcnBvbGF0ZS5qcyAqL1xuXHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggY2lyY3VsYXIsIHdhcm4sIGludGVycG9sYXRvcnMsIGNvbmZpZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggZnJvbSwgdG8sIHJhY3RpdmUsIHR5cGUgKSB7XG5cdFx0XHRpZiAoIGZyb20gPT09IHRvICkge1xuXHRcdFx0XHRyZXR1cm4gc25hcCggdG8gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZSApIHtcblx0XHRcdFx0dmFyIGludGVycG9sID0gY29uZmlnLnJlZ2lzdHJpZXMuaW50ZXJwb2xhdG9ycy5maW5kKCByYWN0aXZlLCB0eXBlICk7XG5cdFx0XHRcdGlmICggaW50ZXJwb2wgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVycG9sKCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2FybiggJ01pc3NpbmcgXCInICsgdHlwZSArICdcIiBpbnRlcnBvbGF0b3IuIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiBmcm9tIFtUT0RPXScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbnRlcnBvbGF0b3JzLm51bWJlciggZnJvbSwgdG8gKSB8fCBpbnRlcnBvbGF0b3JzLmFycmF5KCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMub2JqZWN0KCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0fTtcblx0XHRjaXJjdWxhci5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuXHRcdF9fZXhwb3J0ID0gaW50ZXJwb2xhdGU7XG5cblx0XHRmdW5jdGlvbiBzbmFwKCB0byApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRvO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjaXJjdWxhciwgd2FybiwgaW50ZXJwb2xhdG9ycywgY29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYW5pbWF0ZS9BbmltYXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkYW5pbWF0ZV9BbmltYXRpb24gPSBmdW5jdGlvbiggd2FybiwgcnVubG9vcCwgaW50ZXJwb2xhdGUgKSB7XG5cblx0XHR2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIga2V5O1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0Ly8gZnJvbSBhbmQgdG9cblx0XHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHRoaXNbIGtleSBdID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGUoIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5yb290LCB0aGlzLmludGVycG9sYXRvciApO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMudGljaygpO1xuXHRcdH07XG5cdFx0QW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdHRpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxhcHNlZCwgdCwgdmFsdWUsIHRpbWVOb3csIGluZGV4LCBrZXlwYXRoO1xuXHRcdFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuXHRcdFx0XHRpZiAoIHRoaXMucnVubmluZyApIHtcblx0XHRcdFx0XHR0aW1lTm93ID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRlbGFwc2VkID0gdGltZU5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuXHRcdFx0XHRcdGlmICggZWxhcHNlZCA+PSB0aGlzLmR1cmF0aW9uICkge1xuXHRcdFx0XHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHRoaXMudG8gKTtcblx0XHRcdFx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0ZXAoIDEsIHRoaXMudG8gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuY29tcGxldGUoIHRoaXMudG8gKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm4oICdBbmltYXRpb24gd2FzIG5vdCBmb3VuZCcgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dCA9IHRoaXMuZWFzaW5nID8gdGhpcy5lYXNpbmcoIGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uICkgOiBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbjtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdG9yKCB0ICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0ZXAoIHQsIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0d2FybiggJ0FuaW1hdGlvbiB3YXMgbm90IGZvdW5kJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQW5pbWF0aW9uO1xuXHR9KCB3YXJuLCBydW5sb29wLCBpbnRlcnBvbGF0ZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2FuaW1hdGUuanMgKi9cblx0dmFyIFJhY3RpdmUkYW5pbWF0ZSA9IGZ1bmN0aW9uKCBpc0VxdWFsLCBQcm9taXNlLCBub3JtYWxpc2VLZXlwYXRoLCBhbmltYXRpb25zLCBBbmltYXRpb24gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9LFxuXHRcdFx0bm9BbmltYXRpb24gPSB7XG5cdFx0XHRcdHN0b3A6IG5vb3Bcblx0XHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBSYWN0aXZlJGFuaW1hdGUoIGtleXBhdGgsIHRvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2UsIGssIGFuaW1hdGlvbiwgYW5pbWF0aW9ucywgZWFzaW5nLCBkdXJhdGlvbiwgc3RlcCwgY29tcGxldGUsIG1ha2VWYWx1ZUNvbGxlY3RvciwgY3VycmVudFZhbHVlcywgY29sbGVjdFZhbHVlLCBkdW1teSwgZHVtbXlPcHRpb25zO1xuXHRcdFx0cHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsICkge1xuXHRcdFx0XHRmdWxmaWxQcm9taXNlID0gZnVsZmlsO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gYW5pbWF0ZSBtdWx0aXBsZSBrZXlwYXRoc1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB0byB8fCB7fTtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0YW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgdGhlIGBzdGVwYCBhbmQgYGNvbXBsZXRlYCBoYW5kbGVycywgYXMgdGhleSB3aWxsXG5cdFx0XHRcdC8vIHJ1biBmb3IgZWFjaCBhbmltYXRpb24hIFNvIGluc3RlYWQgd2UnbGwgc3RvcmUgdGhlIGhhbmRsZXJzIGFuZCBjcmVhdGVcblx0XHRcdFx0Ly8gb3VyIG93bi4uLlxuXHRcdFx0XHRzdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRjdXJyZW50VmFsdWVzID0ge307XG5cdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gbnVsbDtcblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gbnVsbDtcblx0XHRcdFx0XHRtYWtlVmFsdWVDb2xsZWN0b3IgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGsgaW4ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGguaGFzT3duUHJvcGVydHkoIGsgKSApIHtcblx0XHRcdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdFx0Y29sbGVjdFZhbHVlID0gbWFrZVZhbHVlQ29sbGVjdG9yKCBrICk7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGlmICggc3RlcCApIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBjb2xsZWN0VmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZSA/IGNvbGxlY3RWYWx1ZSA6IG5vb3A7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGFuaW1hdGUoIHRoaXMsIGssIGtleXBhdGhbIGsgXSwgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiwgdG8gZmFjaWxpdGF0ZSBzdGVwL2NvbXBsZXRlXG5cdFx0XHRcdC8vIGNhbGxiYWNrcywgYW5kIFByb21pc2UgZnVsZmlsbWVudFxuXHRcdFx0XHRkdW1teU9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggc3RlcCApIHtcblx0XHRcdFx0XHRkdW1teU9wdGlvbnMuc3RlcCA9IGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdFx0c3RlcCggdCwgY3VycmVudFZhbHVlcyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGUoIHQsIGN1cnJlbnRWYWx1ZXMgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHVtbXlPcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblx0XHRcdFx0ZHVtbXkgPSBhbmltYXRlKCB0aGlzLCBudWxsLCBudWxsLCBkdW1teU9wdGlvbnMgKTtcblx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBkdW1teSApO1xuXHRcdFx0XHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uO1xuXHRcdFx0XHRcdHdoaWxlICggYW5pbWF0aW9uID0gYW5pbWF0aW9ucy5wb3AoKSApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggZHVtbXkgKSB7XG5cdFx0XHRcdFx0XHRkdW1teS5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1cblx0XHRcdC8vIGFuaW1hdGUgYSBzaW5nbGUga2V5cGF0aFxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRpZiAoIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRlKCB0aGlzLCBrZXlwYXRoLCB0bywgb3B0aW9ucyApO1xuXHRcdFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGFuaW1hdGUoIHJvb3QsIGtleXBhdGgsIHRvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGVhc2luZywgZHVyYXRpb24sIGFuaW1hdGlvbiwgZnJvbTtcblx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0ZnJvbSA9IHJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2FuY2VsIGFueSBleGlzdGluZyBhbmltYXRpb25cblx0XHRcdC8vIFRPRE8gd2hhdCBhYm91dCB1cHN0cmVhbS9kb3duc3RyZWFtIGtleXBhdGhzP1xuXHRcdFx0YW5pbWF0aW9ucy5hYm9ydCgga2V5cGF0aCwgcm9vdCApO1xuXHRcdFx0Ly8gZG9uJ3QgYm90aGVyIGFuaW1hdGluZyB2YWx1ZXMgdGhhdCBzdGF5IHRoZSBzYW1lXG5cdFx0XHRpZiAoIGlzRXF1YWwoIGZyb20sIHRvICkgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5jb21wbGV0ZSApIHtcblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlKCBvcHRpb25zLnRvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vQW5pbWF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZWFzaW5nIGZ1bmN0aW9uXG5cdFx0XHRpZiAoIG9wdGlvbnMuZWFzaW5nICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlYXNpbmcgPSByb290LmVhc2luZ1sgb3B0aW9ucy5lYXNpbmcgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBlYXNpbmcgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZHVyYXRpb25cblx0XHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gNDAwIDogb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdC8vIFRPRE8gc3RvcmUga2V5cywgdXNlIGFuIGludGVybmFsIHNldCBtZXRob2Rcblx0XHRcdGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oIHtcblx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcblx0XHRcdFx0ZnJvbTogZnJvbSxcblx0XHRcdFx0dG86IHRvLFxuXHRcdFx0XHRyb290OiByb290LFxuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuXHRcdFx0XHRpbnRlcnBvbGF0b3I6IG9wdGlvbnMuaW50ZXJwb2xhdG9yLFxuXHRcdFx0XHQvLyBUT0RPIHdyYXAgY2FsbGJhY2tzIGlmIG5lY2Vzc2FyeSwgdG8gdXNlIGluc3RhbmNlIGFzIGNvbnRleHRcblx0XHRcdFx0c3RlcDogb3B0aW9ucy5zdGVwLFxuXHRcdFx0XHRjb21wbGV0ZTogb3B0aW9ucy5jb21wbGV0ZVxuXHRcdFx0fSApO1xuXHRcdFx0YW5pbWF0aW9ucy5hZGQoIGFuaW1hdGlvbiApO1xuXHRcdFx0cm9vdC5fYW5pbWF0aW9ucy5wdXNoKCBhbmltYXRpb24gKTtcblx0XHRcdHJldHVybiBhbmltYXRpb247XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggaXNFcXVhbCwgUHJvbWlzZSwgbm9ybWFsaXNlS2V5cGF0aCwgYW5pbWF0aW9ucywgUmFjdGl2ZSRhbmltYXRlX0FuaW1hdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRkZXRhY2ggPSBmdW5jdGlvbiggSG9vaywgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIGRldGFjaEhvb2sgPSBuZXcgSG9vayggJ2RldGFjaCcgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRkZXRhY2goKSB7XG5cdFx0XHRpZiAoIHRoaXMuZGV0YWNoZWQgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmVsICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRldGFjaGVkID0gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdGRldGFjaEhvb2suZmlyZSggdGhpcyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kID0gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdXRpbHMvbWF0Y2hlcy5qcyAqL1xuXHR2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApIHtcblxuXHRcdHZhciBtYXRjaGVzLCBkaXYsIG1ldGhvZE5hbWVzLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgaSwgaiwgbWFrZUZ1bmN0aW9uO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0bWF0Y2hlcyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdiA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0XHRtZXRob2ROYW1lcyA9IFtcblx0XHRcdFx0J21hdGNoZXMnLFxuXHRcdFx0XHQnbWF0Y2hlc1NlbGVjdG9yJ1xuXHRcdFx0XTtcblx0XHRcdG1ha2VGdW5jdGlvbiA9IGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlWyBtZXRob2ROYW1lIF0oIHNlbGVjdG9yICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0aSA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICYmICFtYXRjaGVzICkge1xuXHRcdFx0XHR1bnByZWZpeGVkID0gbWV0aG9kTmFtZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBkaXZbIHVucHJlZml4ZWQgXSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKCB1bnByZWZpeGVkICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aiA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0cHJlZml4ZWQgPSB2ZW5kb3JzWyBpIF0gKyB1bnByZWZpeGVkLnN1YnN0ciggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXZbIHByZWZpeGVkIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24oIHByZWZpeGVkICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSUU4Li4uXG5cdFx0XHRpZiAoICFtYXRjaGVzICkge1xuXHRcdFx0XHRtYXRjaGVzID0gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHZhciBub2RlcywgcGFyZW50Tm9kZSwgaTtcblx0XHRcdFx0XHRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdGlmICggIXBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBlbXB0eSBkdW1teSA8ZGl2PlxuXHRcdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRpdjtcblx0XHRcdFx0XHRcdG5vZGUgPSBub2RlLmNsb25lTm9kZSgpO1xuXHRcdFx0XHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBub2RlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGVzID0gcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVzWyBpIF0gPT09IG5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9KCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvdGVzdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3Rlc3QgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbSwgbm9EaXJ0eSApIHtcblx0XHRcdHZhciBpdGVtTWF0Y2hlcyA9IHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAhdGhpcy5zZWxlY3RvciB8fCBpdGVtLm5hbWUgPT09IHRoaXMuc2VsZWN0b3IgOiBtYXRjaGVzKCBpdGVtLm5vZGUsIHRoaXMuc2VsZWN0b3IgKTtcblx0XHRcdGlmICggaXRlbU1hdGNoZXMgKSB7XG5cdFx0XHRcdHRoaXMucHVzaCggaXRlbS5ub2RlIHx8IGl0ZW0uaW5zdGFuY2UgKTtcblx0XHRcdFx0aWYgKCAhbm9EaXJ0eSApIHtcblx0XHRcdFx0XHR0aGlzLl9tYWtlRGlydHkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9jYW5jZWwuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9jYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHNlbGVjdG9yLCBpbmRleDtcblx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX3Jvb3RbIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAnbGl2ZUNvbXBvbmVudFF1ZXJpZXMnIDogJ2xpdmVRdWVyaWVzJyBdO1xuXHRcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvcjtcblx0XHRpbmRleCA9IGxpdmVRdWVyaWVzLmluZGV4T2YoIHNlbGVjdG9yICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydEJ5SXRlbVBvc2l0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhbmNlc3RyeUEsIGFuY2VzdHJ5Qiwgb2xkZXN0QSwgb2xkZXN0QiwgbXV0dWFsQW5jZXN0b3IsIGluZGV4QSwgaW5kZXhCLCBmcmFnbWVudHMsIGZyYWdtZW50QSwgZnJhZ21lbnRCO1xuXHRcdFx0YW5jZXN0cnlBID0gZ2V0QW5jZXN0cnkoIGEuY29tcG9uZW50IHx8IGEuX3JhY3RpdmUucHJveHkgKTtcblx0XHRcdGFuY2VzdHJ5QiA9IGdldEFuY2VzdHJ5KCBiLmNvbXBvbmVudCB8fCBiLl9yYWN0aXZlLnByb3h5ICk7XG5cdFx0XHRvbGRlc3RBID0gYW5jZXN0cnlBWyBhbmNlc3RyeUEubGVuZ3RoIC0gMSBdO1xuXHRcdFx0b2xkZXN0QiA9IGFuY2VzdHJ5QlsgYW5jZXN0cnlCLmxlbmd0aCAtIDEgXTtcblx0XHRcdC8vIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgYm90aCBhbmNlc3RyaWVzIGFzIGxvbmcgYXMgdGhleSBhcmUgaWRlbnRpY2FsXG5cdFx0XHQvLyAtIHRoZSBmaW5hbCBvbmUgcmVtb3ZlZCBpcyB0aGUgY2xvc2VzdCBtdXR1YWwgYW5jZXN0b3Jcblx0XHRcdHdoaWxlICggb2xkZXN0QSAmJiBvbGRlc3RBID09PSBvbGRlc3RCICkge1xuXHRcdFx0XHRhbmNlc3RyeUEucG9wKCk7XG5cdFx0XHRcdGFuY2VzdHJ5Qi5wb3AoKTtcblx0XHRcdFx0bXV0dWFsQW5jZXN0b3IgPSBvbGRlc3RBO1xuXHRcdFx0XHRvbGRlc3RBID0gYW5jZXN0cnlBWyBhbmNlc3RyeUEubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRvbGRlc3RCID0gYW5jZXN0cnlCWyBhbmNlc3RyeUIubGVuZ3RoIC0gMSBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgbXV0dWFsIGFuY2VzdG9yLCB3ZSBjYW4gZmluZCB3aGljaCBpcyBlYXJsaWVzdFxuXHRcdFx0b2xkZXN0QSA9IG9sZGVzdEEuY29tcG9uZW50IHx8IG9sZGVzdEE7XG5cdFx0XHRvbGRlc3RCID0gb2xkZXN0Qi5jb21wb25lbnQgfHwgb2xkZXN0Qjtcblx0XHRcdGZyYWdtZW50QSA9IG9sZGVzdEEucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRmcmFnbWVudEIgPSBvbGRlc3RCLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gaWYgYm90aCBpdGVtcyBzaGFyZSBhIHBhcmVudCBmcmFnbWVudCwgb3VyIGpvYiBpcyBlYXN5XG5cdFx0XHRpZiAoIGZyYWdtZW50QSA9PT0gZnJhZ21lbnRCICkge1xuXHRcdFx0XHRpbmRleEEgPSBmcmFnbWVudEEuaXRlbXMuaW5kZXhPZiggb2xkZXN0QSApO1xuXHRcdFx0XHRpbmRleEIgPSBmcmFnbWVudEIuaXRlbXMuaW5kZXhPZiggb2xkZXN0QiApO1xuXHRcdFx0XHQvLyBpZiBpdCdzIHRoZSBzYW1lIGluZGV4LCBpdCBtZWFucyBvbmUgY29udGFpbnMgdGhlIG90aGVyLFxuXHRcdFx0XHQvLyBzbyB3ZSBzZWUgd2hpY2ggaGFzIHRoZSBsb25nZXN0IGFuY2VzdHJ5XG5cdFx0XHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBtdXR1YWwgYW5jZXN0b3IgaXMgYSBzZWN0aW9uLCB3ZSBmaXJzdCB0ZXN0IHRvIHNlZSB3aGljaCBzZWN0aW9uXG5cdFx0XHQvLyBmcmFnbWVudCBjb21lcyBmaXJzdFxuXHRcdFx0aWYgKCBmcmFnbWVudHMgPSBtdXR1YWxBbmNlc3Rvci5mcmFnbWVudHMgKSB7XG5cdFx0XHRcdGluZGV4QSA9IGZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudEEgKTtcblx0XHRcdFx0aW5kZXhCID0gZnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50QiApO1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQW4gdW5leHBlY3RlZCBjb25kaXRpb24gd2FzIG1ldCB3aGlsZSBjb21wYXJpbmcgdGhlIHBvc2l0aW9uIG9mIHR3byBjb21wb25lbnRzLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIScgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFyZW50KCBpdGVtICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50O1xuXHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudCA9IGl0ZW0ucGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcblx0XHRcdH1cblx0XHRcdGlmICggaXRlbS5jb21wb25lbnQgJiYgKCBwYXJlbnRGcmFnbWVudCA9IGl0ZW0uY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBbmNlc3RyeSggaXRlbSApIHtcblx0XHRcdHZhciBhbmNlc3RyeSwgYW5jZXN0b3I7XG5cdFx0XHRhbmNlc3RyeSA9IFsgaXRlbSBdO1xuXHRcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoIGl0ZW0gKTtcblx0XHRcdHdoaWxlICggYW5jZXN0b3IgKSB7XG5cdFx0XHRcdGFuY2VzdHJ5LnB1c2goIGFuY2VzdG9yICk7XG5cdFx0XHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KCBhbmNlc3RvciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFuY2VzdHJ5O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnRCeURvY3VtZW50UG9zaXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24oIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggbm9kZSwgb3RoZXJOb2RlICkge1xuXHRcdFx0dmFyIGJpdG1hc2s7XG5cdFx0XHRpZiAoIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XG5cdFx0XHRcdGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBvdGhlck5vZGUgKTtcblx0XHRcdFx0cmV0dXJuIGJpdG1hc2sgJiAyID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuXHRcdFx0Ly8gY29tcGFyaW5nIGNvbXBvbmVudCBwb3NpdGlvbnNcblx0XHRcdHJldHVybiBzb3J0QnlJdGVtUG9zaXRpb24oIG5vZGUsIG90aGVyTm9kZSApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0ID0gZnVuY3Rpb24oIHNvcnRCeURvY3VtZW50UG9zaXRpb24sIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc29ydCggdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IHNvcnRCeUl0ZW1Qb3NpdGlvbiA6IHNvcnRCeURvY3VtZW50UG9zaXRpb24gKTtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeURvY3VtZW50UG9zaXRpb24sIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L2RpcnR5LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfZGlydHkgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0aWYgKCAhdGhpcy5fZGlydHkgKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gT25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQsIGVuc3VyZSB0aGUgcXVlcnlcblx0XHRcdFx0Ly8gaXMgY29ycmVjdGx5IG9yZGVyZWRcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMkMC5fc29ydCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvcmVtb3ZlLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfcmVtb3ZlID0gZnVuY3Rpb24oIG5vZGVPckNvbXBvbmVudCApIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBub2RlT3JDb21wb25lbnQuaW5zdGFuY2UgOiBub2RlT3JDb21wb25lbnQgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdHRoaXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L19tYWtlUXVlcnkuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnRpZXMsIHRlc3QsIGNhbmNlbCwgc29ydCwgZGlydHksIHJlbW92ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBtYWtlUXVlcnkoIHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5ICkge1xuXHRcdFx0dmFyIHF1ZXJ5ID0gW107XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBxdWVyeSwge1xuXHRcdFx0XHRzZWxlY3Rvcjoge1xuXHRcdFx0XHRcdHZhbHVlOiBzZWxlY3RvclxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGxpdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2lzQ29tcG9uZW50UXVlcnk6IHtcblx0XHRcdFx0XHR2YWx1ZTogaXNDb21wb25lbnRRdWVyeVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfdGVzdDoge1xuXHRcdFx0XHRcdHZhbHVlOiB0ZXN0XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGlmICggIWxpdmUgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMoIHF1ZXJ5LCB7XG5cdFx0XHRcdGNhbmNlbDoge1xuXHRcdFx0XHRcdHZhbHVlOiBjYW5jZWxcblx0XHRcdFx0fSxcblx0XHRcdFx0X3Jvb3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogcmFjdGl2ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfc29ydDoge1xuXHRcdFx0XHRcdHZhbHVlOiBzb3J0XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9tYWtlRGlydHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogZGlydHlcblx0XHRcdFx0fSxcblx0XHRcdFx0X3JlbW92ZToge1xuXHRcdFx0XHRcdHZhbHVlOiByZW1vdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2RpcnR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGZhbHNlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBkZWZpbmVQcm9wZXJ0aWVzLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfdGVzdCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2NhbmNlbCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnQsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9kaXJ0eSwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3JlbW92ZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZEFsbCA9IGZ1bmN0aW9uKCBtYWtlUXVlcnkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgZmFsc2UgKTtcblx0XHRcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuXHRcdFx0Ly8gaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCBxdWVyeS5saXZlICkge1xuXHRcdFx0XHRsaXZlUXVlcmllcy5wdXNoKCBzZWxlY3RvciApO1xuXHRcdFx0XHRsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXSA9IHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIG1ha2VRdWVyeSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZUNvbXBvbmVudFF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgdHJ1ZSApO1xuXHRcdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG5cdFx0XHQvLyBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzLnB1c2goIHNlbGVjdG9yICk7XG5cdFx0XHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB1dGlscy9nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuanMgKi9cblx0dmFyIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBzdGFyTWFwcyA9IHt9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBrZXlwYXRoIHN1Y2ggYXMgJ2Zvby5iYXIuYmF6JywgYW5kIHJldHVybnNcblx0XHQvLyBhbGwgdGhlIHZhcmlhbnRzIG9mIHRoYXQga2V5cGF0aCB0aGF0IGluY2x1ZGUgYSB3aWxkY2FyZCBpbiBwbGFjZVxuXHRcdC8vIG9mIGEga2V5LCBzdWNoIGFzICdmb28uYmFyLionLCAnZm9vLiouYmF6JywgJ2Zvby4qLionIGFuZCBzbyBvbi5cblx0XHQvLyBUaGVzZSBhcmUgdGhlbiBjaGVja2VkIGFnYWluc3QgdGhlIGRlcGVuZGFudHMgbWFwIChyYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwKVxuXHRcdC8vIHRvIHNlZSBpZiBhbnkgcGF0dGVybiBvYnNlcnZlcnMgYXJlIGRvd25zdHJlYW0gb2Ygb25lIG9yIG1vcmUgb2Zcblx0XHQvLyB0aGVzZSB3aWxkY2FyZCBrZXlwYXRocyAoZS5nLiAnZm9vLmJhci4qLnN0YXR1cycpXG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCBpLCByZXN1bHQsIHdpbGRjYXJkS2V5cGF0aDtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdGlmICggISggc3Rhck1hcCA9IHN0YXJNYXBzWyBrZXlzLmxlbmd0aCBdICkgKSB7XG5cdFx0XHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKCBrZXlzLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggc3RhciwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHN0YXIgPyAnKicgOiBrZXlzWyBpIF07XG5cdFx0XHR9O1xuXHRcdFx0aSA9IHN0YXJNYXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdHdpbGRjYXJkS2V5cGF0aCA9IHN0YXJNYXBbIGkgXS5tYXAoIG1hcHBlciApLmpvaW4oICcuJyApO1xuXHRcdFx0XHRpZiAoICFyZXN1bHQuaGFzT3duUHJvcGVydHkoIHdpbGRjYXJkS2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCB3aWxkY2FyZEtleXBhdGggKTtcblx0XHRcdFx0XHRyZXN1bHRbIHdpbGRjYXJkS2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuXHRcdC8vIGEgZ2l2ZW4gbnVtYmVyIC0gZS5nLiBmb3IgdHdvLCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zIGFyZVxuXHRcdC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cblx0XHQvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuXHRcdGZ1bmN0aW9uIGdldFN0YXJNYXAoIG51bSApIHtcblx0XHRcdHZhciBvbmVzID0gJycsXG5cdFx0XHRcdG1heCwgYmluYXJ5LCBzdGFyTWFwLCBtYXBwZXIsIGk7XG5cdFx0XHRpZiAoICFzdGFyTWFwc1sgbnVtIF0gKSB7XG5cdFx0XHRcdHN0YXJNYXAgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBvbmVzLmxlbmd0aCA8IG51bSApIHtcblx0XHRcdFx0XHRvbmVzICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4ID0gcGFyc2VJbnQoIG9uZXMsIDIgKTtcblx0XHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIGRpZ2l0ICkge1xuXHRcdFx0XHRcdHJldHVybiBkaWdpdCA9PT0gJzEnO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8PSBtYXg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKCAyICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBiaW5hcnkubGVuZ3RoIDwgbnVtICkge1xuXHRcdFx0XHRcdFx0YmluYXJ5ID0gJzAnICsgYmluYXJ5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFyTWFwWyBpIF0gPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoIGJpbmFyeSwgbWFwcGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Rhck1hcHNbIG51bSBdID0gc3Rhck1hcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGFyTWFwc1sgbnVtIF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9maXJlRXZlbnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCA9IGZ1bmN0aW9uKCBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBmaXJlRXZlbnQoIHJhY3RpdmUsIGV2ZW50TmFtZSApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdGlmICggIWV2ZW50TmFtZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhb3B0aW9ucy5ldmVudCApIHtcblx0XHRcdFx0b3B0aW9ucy5ldmVudCA9IHtcblx0XHRcdFx0XHRuYW1lOiBldmVudE5hbWUsXG5cdFx0XHRcdFx0Y29udGV4dDogcmFjdGl2ZS5kYXRhLFxuXHRcdFx0XHRcdGtleXBhdGg6ICcnLFxuXHRcdFx0XHRcdC8vIHVudGlsIGV2ZW50IG5vdCBpbmNsdWRlZCBhcyBhcmd1bWVudCBkZWZhdWx0XG5cdFx0XHRcdFx0X25vQXJnOiB0cnVlXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLmV2ZW50Lm5hbWUgPSBldmVudE5hbWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXZlbnROYW1lcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyggZXZlbnROYW1lICk7XG5cdFx0XHRmaXJlRXZlbnRBcyggcmFjdGl2ZSwgZXZlbnROYW1lcywgb3B0aW9ucy5ldmVudCwgb3B0aW9ucy5hcmdzLCB0cnVlICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGZpcmVFdmVudEFzKCByYWN0aXZlLCBldmVudE5hbWVzLCBldmVudCwgYXJncyApIHtcblx0XHRcdHZhciBpbml0aWFsRmlyZSA9IGFyZ3VtZW50c1sgNCBdO1xuXHRcdFx0aWYgKCBpbml0aWFsRmlyZSA9PT0gdm9pZCAwIClcblx0XHRcdFx0aW5pdGlhbEZpcmUgPSBmYWxzZTtcblx0XHRcdHZhciBzdWJzY3JpYmVycywgaSwgYnViYmxlID0gdHJ1ZTtcblx0XHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZXZlbnQgPSBldmVudDtcblx0XHRcdH1cblx0XHRcdGZvciAoIGkgPSBldmVudE5hbWVzLmxlbmd0aDsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRcdHN1YnNjcmliZXJzID0gcmFjdGl2ZS5fc3Vic1sgZXZlbnROYW1lc1sgaSBdIF07XG5cdFx0XHRcdGlmICggc3Vic2NyaWJlcnMgKSB7XG5cdFx0XHRcdFx0YnViYmxlID0gbm90aWZ5U3Vic2NyaWJlcnMoIHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncyApICYmIGJ1YmJsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBldmVudCApIHtcblx0XHRcdFx0ZGVsZXRlIHJhY3RpdmUuZXZlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJhY3RpdmUuX3BhcmVudCAmJiBidWJibGUgKSB7XG5cdFx0XHRcdGlmICggaW5pdGlhbEZpcmUgJiYgcmFjdGl2ZS5jb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0dmFyIGZ1bGxOYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSArICcuJyArIGV2ZW50TmFtZXNbIGV2ZW50TmFtZXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdGV2ZW50TmFtZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGZ1bGxOYW1lICk7XG5cdFx0XHRcdFx0aWYgKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LmNvbXBvbmVudCA9IHJhY3RpdmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZpcmVFdmVudEFzKCByYWN0aXZlLl9wYXJlbnQsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5U3Vic2NyaWJlcnMoIHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncyApIHtcblx0XHRcdHZhciBvcmlnaW5hbEV2ZW50ID0gbnVsbCxcblx0XHRcdFx0c3RvcEV2ZW50ID0gZmFsc2U7XG5cdFx0XHRpZiAoIGV2ZW50ICYmICFldmVudC5fbm9BcmcgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIGV2ZW50IF0uY29uY2F0KCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzWyBpIF0uYXBwbHkoIHJhY3RpdmUsIGFyZ3MgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0c3RvcEV2ZW50ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBldmVudCAmJiAhZXZlbnQuX25vQXJnICYmIHN0b3BFdmVudCAmJiAoIG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbCApICkge1xuXHRcdFx0XHRvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0ICYmIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0b3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24gJiYgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhc3RvcEV2ZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpcmUuanMgKi9cblx0dmFyIFJhY3RpdmUkZmlyZSA9IGZ1bmN0aW9uKCBmaXJlRXZlbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaXJlKCBldmVudE5hbWUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdFx0YXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApXG5cdFx0XHR9O1xuXHRcdFx0ZmlyZUV2ZW50KCB0aGlzLCBldmVudE5hbWUsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9nZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkZ2V0ID0gZnVuY3Rpb24oIG5vcm1hbGlzZUtleXBhdGgsIHJlc29sdmVSZWYgKSB7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdGNhcHR1cmU6IHRydWVcblx0XHR9O1xuXHRcdC8vIHRvcC1sZXZlbCBjYWxscyBzaG91bGQgYmUgaW50ZXJjZXB0ZWRcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRnZXQoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGgsIG9wdGlvbnMgKTtcblx0XHRcdC8vIENyZWF0ZSBpbnRlci1jb21wb25lbnQgYmluZGluZywgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy5fcGFyZW50ICYmICF0aGlzLmlzb2xhdGVkICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVSZWYoIHRoaXMsIGtleXBhdGgsIHRoaXMuZnJhZ21lbnQgKSApIHtcblx0XHRcdFx0XHQvLyBjcmVhdGVzIGJpbmRpbmcgYXMgc2lkZS1lZmZlY3QsIGlmIGFwcHJvcHJpYXRlXG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZUtleXBhdGgsIHJlc29sdmVSZWYgKTtcblxuXHQvKiB1dGlscy9nZXRFbGVtZW50LmpzICovXG5cdHZhciBnZXRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudCggaW5wdXQgKSB7XG5cdFx0dmFyIG91dHB1dDtcblx0XHRpZiAoICFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhZG9jdW1lbnQgfHwgIWlucHV0ICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdC8vIFdlIGFscmVhZHkgaGF2ZSBhIERPTSBub2RlIC0gbm8gd29yayB0byBkby4gKER1Y2sgdHlwaW5nIGFsZXJ0ISlcblx0XHRpZiAoIGlucHV0Lm5vZGVUeXBlICkge1xuXHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdH1cblx0XHQvLyBHZXQgbm9kZSBmcm9tIHN0cmluZ1xuXHRcdGlmICggdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIHRyeSBJRCBmaXJzdFxuXHRcdFx0b3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlucHV0ICk7XG5cdFx0XHQvLyB0aGVuIGFzIHNlbGVjdG9yLCBpZiBwb3NzaWJsZVxuXHRcdFx0aWYgKCAhb3V0cHV0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgKSB7XG5cdFx0XHRcdG91dHB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGlucHV0ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBkaWQgaXQgd29yaz9cblx0XHRcdGlmICggb3V0cHV0ICYmIG91dHB1dC5ub2RlVHlwZSApIHtcblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNvbGxlY3Rpb24gKGpRdWVyeSwgWmVwdG8gZXRjKSwgZXh0cmFjdCB0aGUgZmlyc3QgaXRlbVxuXHRcdGlmICggaW5wdXRbIDAgXSAmJiBpbnB1dFsgMCBdLm5vZGVUeXBlICkge1xuXHRcdFx0cmV0dXJuIGlucHV0WyAwIF07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2luc2VydC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRpbnNlcnQgPSBmdW5jdGlvbiggSG9vaywgZ2V0RWxlbWVudCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgaW5zZXJ0SG9vayA9IG5ldyBIb29rKCAnaW5zZXJ0JyApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gUmFjdGl2ZSRpbnNlcnQoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0aWYgKCAhdGhpcy5mcmFnbWVudC5yZW5kZXJlZCApIHtcblx0XHRcdFx0Ly8gVE9ETyBjcmVhdGUsIGFuZCBsaW5rIHRvLCBkb2N1bWVudGF0aW9uIGV4cGxhaW5pbmcgdGhpc1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgQVBJIGhhcyBjaGFuZ2VkIC0geW91IG11c3QgY2FsbCBgcmFjdGl2ZS5yZW5kZXIodGFyZ2V0WywgYW5jaG9yXSlgIHRvIHJlbmRlciB5b3VyIFJhY3RpdmUgaW5zdGFuY2UuIE9uY2UgcmVuZGVyZWQgeW91IGNhbiB1c2UgYHJhY3RpdmUuaW5zZXJ0KClgLicgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9IGdldEVsZW1lbnQoIHRhcmdldCApO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgbnVsbDtcblx0XHRcdGlmICggIXRhcmdldCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IG11c3Qgc3BlY2lmeSBhIHZhbGlkIHRhcmdldCB0byBpbnNlcnQgaW50bycgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZGV0YWNoKCksIGFuY2hvciApO1xuXHRcdFx0dGhpcy5lbCA9IHRhcmdldDtcblx0XHRcdCggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAoIHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSApICkucHVzaCggdGhpcyApO1xuXHRcdFx0dGhpcy5kZXRhY2hlZCA9IG51bGw7XG5cdFx0XHRmaXJlSW5zZXJ0SG9vayggdGhpcyApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlSW5zZXJ0SG9vayggcmFjdGl2ZSApIHtcblx0XHRcdGluc2VydEhvb2suZmlyZSggcmFjdGl2ZSApO1xuXHRcdFx0cmFjdGl2ZS5maW5kQWxsQ29tcG9uZW50cyggJyonICkuZm9yRWFjaCggZnVuY3Rpb24oIGNoaWxkICkge1xuXHRcdFx0XHRmaXJlSW5zZXJ0SG9vayggY2hpbGQuaW5zdGFuY2UgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBnZXRFbGVtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvbWVyZ2UuanMgKi9cblx0dmFyIFJhY3RpdmUkbWVyZ2UgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNBcnJheSwgbm9ybWFsaXNlS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG1lcmdlKCBrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBjdXJyZW50QXJyYXksIHByb21pc2U7XG5cdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0Y3VycmVudEFycmF5ID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHQvLyBJZiBlaXRoZXIgdGhlIGV4aXN0aW5nIHZhbHVlIG9yIHRoZSBuZXcgdmFsdWUgaXNuJ3QgYW5cblx0XHRcdC8vIGFycmF5LCBqdXN0IGRvIGEgcmVndWxhciBzZXRcblx0XHRcdGlmICggIWlzQXJyYXkoIGN1cnJlbnRBcnJheSApIHx8ICFpc0FycmF5KCBhcnJheSApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXQoIGtleXBhdGgsIGFycmF5LCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIE1hbmFnZSB0cmFuc2l0aW9uc1xuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHRoaXMudmlld21vZGVsLm1lcmdlKCBrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zICk7XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0Ly8gYXR0YWNoIGNhbGxiYWNrIGFzIGZ1bGZpbG1lbnQgaGFuZGxlciwgaWYgc3BlY2lmaWVkXG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBpc0FycmF5LCBub3JtYWxpc2VLZXlwYXRoICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9PYnNlcnZlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX09ic2VydmVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXHRcdFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG5cdFx0fTtcblx0XHRPYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW1tZWRpYXRlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5jYWxsYmFjay5jYWxsKCB0aGlzLmNvbnRleHQsIHRoaXMudmFsdWUsIHRoaXMub2xkVmFsdWUsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIE9ic2VydmVyO1xuXHR9KCBydW5sb29wLCBpc0VxdWFsICk7XG5cblx0Lyogc2hhcmVkL2dldE1hdGNoaW5nS2V5cGF0aHMuanMgKi9cblx0dmFyIGdldE1hdGNoaW5nS2V5cGF0aHMgPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRNYXRjaGluZ0tleXBhdGhzKCByYWN0aXZlLCBwYXR0ZXJuICkge1xuXHRcdFx0dmFyIGtleXMsIGtleSwgbWF0Y2hpbmdLZXlwYXRocztcblx0XHRcdGtleXMgPSBwYXR0ZXJuLnNwbGl0KCAnLicgKTtcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBbICcnIF07XG5cdFx0XHR3aGlsZSAoIGtleSA9IGtleXMuc2hpZnQoKSApIHtcblx0XHRcdFx0aWYgKCBrZXkgPT09ICcqJyApIHtcblx0XHRcdFx0XHQvLyBleHBhbmQgdG8gZmluZCBhbGwgdmFsaWQgY2hpbGQga2V5cGF0aHNcblx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5yZWR1Y2UoIGV4cGFuZCwgW10gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG1hdGNoaW5nS2V5cGF0aHNbIDAgXSA9PT0gJycgKSB7XG5cdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXlcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHNbIDAgXSA9IGtleTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMubWFwKCBjb25jYXRlbmF0ZSgga2V5ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXG5cdFx0XHRmdW5jdGlvbiBleHBhbmQoIG1hdGNoaW5nS2V5cGF0aHMsIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwga2V5LCBjaGlsZEtleXBhdGg7XG5cdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsga2V5cGF0aCBdID8gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsga2V5cGF0aCBdLmdldCgpIDogcmFjdGl2ZS5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0Zm9yICgga2V5IGluIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggdmFsdWUuaGFzT3duUHJvcGVydHkoIGtleSApICYmICgga2V5ICE9PSAnX3JhY3RpdmUnIHx8ICFpc0FycmF5KCB2YWx1ZSApICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBmb3IgYmVuZWZpdCBvZiBJRThcblx0XHRcdFx0XHRcdGNoaWxkS2V5cGF0aCA9IGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocy5wdXNoKCBjaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvbmNhdGVuYXRlKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4ga2V5cGF0aCA/IGtleXBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvZ2V0UGF0dGVybi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX2dldFBhdHRlcm4gPSBmdW5jdGlvbiggZ2V0TWF0Y2hpbmdLZXlwYXRocyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRQYXR0ZXJuKCByYWN0aXZlLCBwYXR0ZXJuICkge1xuXHRcdFx0dmFyIG1hdGNoaW5nS2V5cGF0aHMsIHZhbHVlcztcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBnZXRNYXRjaGluZ0tleXBhdGhzKCByYWN0aXZlLCBwYXR0ZXJuICk7XG5cdFx0XHR2YWx1ZXMgPSB7fTtcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gcmFjdGl2ZS5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0fTtcblx0fSggZ2V0TWF0Y2hpbmdLZXlwYXRocyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvUGF0dGVybk9ic2VydmVyLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfUGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzRXF1YWwsIGdldFBhdHRlcm4gKSB7XG5cblx0XHR2YXIgUGF0dGVybk9ic2VydmVyLCB3aWxkY2FyZCA9IC9cXCovLFxuXHRcdFx0c2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0UGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdHRoaXMucmVnZXggPSBuZXcgUmVnRXhwKCAnXicgKyBrZXlwYXRoLnJlcGxhY2UoIC9cXC4vZywgJ1xcXFwuJyApLnJlcGxhY2UoIC9cXCovZywgJyhbXlxcXFwuXSspJyApICsgJyQnICk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IHt9O1xuXHRcdFx0aWYgKCB0aGlzLmRlZmVyICkge1xuXHRcdFx0XHR0aGlzLnByb3hpZXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuXHRcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuXHRcdH07XG5cdFx0UGF0dGVybk9ic2VydmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBpbW1lZGlhdGUgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMsIGtleXBhdGg7XG5cdFx0XHRcdHZhbHVlcyA9IGdldFBhdHRlcm4oIHRoaXMucm9vdCwgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW1tZWRpYXRlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIHZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGlmICggdmFsdWVzLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZXM7XG5cdFx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IGdldFBhdHRlcm4oIHRoaXMucm9vdCwga2V5cGF0aCApO1xuXHRcdFx0XHRcdGZvciAoIGtleXBhdGggaW4gdmFsdWVzICkge1xuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZXMuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGFycmF5IG11dGF0aW9uIHNob3VsZCBub3QgdHJpZ2dlciBgYXJyYXkuKmBcblx0XHRcdFx0Ly8gcGF0dGVybiBvYnNlcnZlciB3aXRoIGBhcnJheS5sZW5ndGhgXG5cdFx0XHRcdGlmICggdGhpcy5yb290LnZpZXdtb2RlbC5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5nZXRQcm94eSgga2V5cGF0aCApLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yZWFsbHlVcGRhdGUoIGtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRyZWFsbHlVcGRhdGU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleXMsIGFyZ3M7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gKSB8fCAhdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRrZXlzID0gc2xpY2UuY2FsbCggdGhpcy5yZWdleC5leGVjKCBrZXlwYXRoICksIDEgKTtcblx0XHRcdFx0XHRhcmdzID0gW1xuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHR0aGlzLnZhbHVlc1sga2V5cGF0aCBdLFxuXHRcdFx0XHRcdFx0a2V5cGF0aFxuXHRcdFx0XHRcdF0uY29uY2F0KCBrZXlzICk7XG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFjay5hcHBseSggdGhpcy5jb250ZXh0LCBhcmdzICk7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRnZXRQcm94eTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0aWYgKCAhdGhpcy5wcm94aWVzWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm94aWVzWyBrZXlwYXRoIF0gPSB7XG5cdFx0XHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnJlYWxseVVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMucHJveGllc1sga2V5cGF0aCBdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFBhdHRlcm5PYnNlcnZlcjtcblx0fSggcnVubG9vcCwgaXNFcXVhbCwgUmFjdGl2ZSRvYnNlcnZlX2dldFBhdHRlcm4gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL2dldE9ic2VydmVyRmFjYWRlLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgPSBmdW5jdGlvbiggbm9ybWFsaXNlS2V5cGF0aCwgT2JzZXJ2ZXIsIFBhdHRlcm5PYnNlcnZlciApIHtcblxuXHRcdHZhciB3aWxkY2FyZCA9IC9cXCovLFxuXHRcdFx0ZW1wdHlPYmplY3QgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGYWNhZGUoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciwgY2FuY2VsbGVkO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T2JqZWN0O1xuXHRcdFx0Ly8gcGF0dGVybiBvYnNlcnZlcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHlcblx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRvYnNlcnZlciA9IG5ldyBQYXR0ZXJuT2JzZXJ2ZXIoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMucHVzaCggb2JzZXJ2ZXIgKTtcblx0XHRcdFx0aXNQYXR0ZXJuT2JzZXJ2ZXIgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyID8gJ3BhdHRlcm5PYnNlcnZlcnMnIDogJ29ic2VydmVycycgKTtcblx0XHRcdG9ic2VydmVyLmluaXQoIG9wdGlvbnMuaW5pdCApO1xuXHRcdFx0Ly8gVGhpcyBmbGFnIGFsbG93cyBvYnNlcnZlcnMgdG8gaW5pdGlhbGlzZSBldmVuIHdpdGggdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0b2JzZXJ2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0aWYgKCBjYW5jZWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggaXNQYXR0ZXJuT2JzZXJ2ZXIgKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuaW5kZXhPZiggb2JzZXJ2ZXIgKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsICdwYXR0ZXJuT2JzZXJ2ZXJzJyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCBvYnNlcnZlciwgJ29ic2VydmVycycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoLCBSYWN0aXZlJG9ic2VydmVfT2JzZXJ2ZXIsIFJhY3RpdmUkb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmUgPSBmdW5jdGlvbiggaXNPYmplY3QsIGdldE9ic2VydmVyRmFjYWRlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZSgga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgb2JzZXJ2ZXJzLCBtYXAsIGtleXBhdGhzLCBpO1xuXHRcdFx0Ly8gQWxsb3cgYSBtYXAgb2Yga2V5cGF0aHMgdG8gaGFuZGxlcnNcblx0XHRcdGlmICggaXNPYmplY3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0aWYgKCBtYXAuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbWFwWyBrZXlwYXRoIF07XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggdGhpcy5vYnNlcnZlKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHdoaWxlICggb2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEFsbG93IGByYWN0aXZlLm9ic2VydmUoIGNhbGxiYWNrIClgIC0gaS5lLiBvYnNlcnZlIGVudGlyZSBtb2RlbFxuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0a2V5cGF0aHMgPSBrZXlwYXRoLnNwbGl0KCAnICcgKTtcblx0XHRcdC8vIFNpbmdsZSBrZXlwYXRoXG5cdFx0XHRpZiAoIGtleXBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGtleXBhdGhzXG5cdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdGkgPSBrZXlwYXRocy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyBpIF07XG5cdFx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR3aGlsZSAoIG9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzT2JqZWN0LCBSYWN0aXZlJG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvdHJpbS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfdHJpbSA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL25vdEVtcHR5U3RyaW5nLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ciAhPT0gJyc7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2ZmLmpzICovXG5cdHZhciBSYWN0aXZlJG9mZiA9IGZ1bmN0aW9uKCB0cmltLCBub3RFbXB0eVN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkLCByZW1vdmUgYWxsIGNhbGxiYWNrc1xuXHRcdFx0aWYgKCAhZXZlbnROYW1lICkge1xuXHRcdFx0XHQvLyBUT0RPIHVzZSB0aGlzIGNvZGUgaW5zdGVhZCwgb25jZSB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkXG5cdFx0XHRcdC8vIGluIFBoYW50b21KUyAodGVzdHMgYXJlIHVucGFzc2FibGUgb3RoZXJ3aXNlISlcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE4NTZcblx0XHRcdFx0Ly8gZGVmaW5lUHJvcGVydHkoIHRoaXMsICdfc3VicycsIHsgdmFsdWU6IGNyZWF0ZSggbnVsbCApLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiB0aGlzLl9zdWJzICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9zdWJzWyBldmVudE5hbWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuXHRcdFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KCAnICcgKS5tYXAoIHRyaW0gKS5maWx0ZXIoIG5vdEVtcHR5U3RyaW5nICk7XG5cdFx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGluZGV4O1xuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQuLi5cblx0XHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzID0gdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSApIHtcblx0XHRcdFx0XHRcdC8vIC4uLmlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdFxuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRzdWJzY3JpYmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb24uanMgKi9cblx0dmFyIFJhY3RpdmUkb24gPSBmdW5jdGlvbiggdHJpbSwgbm90RW1wdHlTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvbiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRsaXN0ZW5lcnMsIG4sIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBhbGxvdyBtdXRsaXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG5cdFx0XHRpZiAoIHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRsaXN0ZW5lcnMgPSBbXTtcblx0XHRcdFx0Zm9yICggbiBpbiBldmVudE5hbWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudE5hbWUuaGFzT3duUHJvcGVydHkoIG4gKSApIHtcblx0XHRcdFx0XHRcdGxpc3RlbmVycy5wdXNoKCB0aGlzLm9uKCBuLCBldmVudE5hbWVbIG4gXSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBsaXN0ZW5lcjtcblx0XHRcdFx0XHRcdHdoaWxlICggbGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcblx0XHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0KCB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdIHx8ICggdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSA9IFtdICkgKS5wdXNoKCBjYWxsYmFjayApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLm9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0Lyogc2hhcmVkL2dldE5ld0luZGljZXMuanMgKi9cblx0dmFyIGdldE5ld0luZGljZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5LCB0aGUgbmFtZSBvZiBhIG11dGF0b3IgbWV0aG9kLCBhbmQgdGhlXG5cdFx0Ly8gYXJndW1lbnRzIHRvIGNhbGwgdGhhdCBtdXRhdG9yIG1ldGhvZCB3aXRoLCBhbmQgcmV0dXJucyBhbiBhcnJheSB0aGF0XG5cdFx0Ly8gbWFwcyB0aGUgb2xkIGluZGljZXMgdG8gdGhlaXIgbmV3IGluZGljZXMuXG5cdFx0Ly8gU28gaWYgeW91IGhhZCBzb21ldGhpbmcgbGlrZSB0aGlzLi4uXG5cdFx0Ly9cblx0XHQvLyAgICAgYXJyYXkgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXHRcdC8vICAgICBhcnJheS5wdXNoKCAnZScgKTtcblx0XHQvL1xuXHRcdC8vIC4uLnlvdSdkIGdldCBgWyAwLCAxLCAyLCAzIF1gIC0gaW4gb3RoZXIgd29yZHMsIG5vbmUgb2YgdGhlIG9sZCBpbmRpY2VzXG5cdFx0Ly8gaGF2ZSBjaGFuZ2VkLiBJZiB5b3UgdGhlbiBkaWQgdGhpcy4uLlxuXHRcdC8vXG5cdFx0Ly8gICAgIGFycmF5LnVuc2hpZnQoICd6JyApO1xuXHRcdC8vXG5cdFx0Ly8gLi4udGhlIGluZGljZXMgd291bGQgYmUgYFsgMSwgMiwgMywgNCwgNSBdYCAtIGV2ZXJ5IGl0ZW0gaGFzIGJlZW4gbW92ZWRcblx0XHQvLyBvbmUgaGlnaGVyIHRvIG1ha2Ugcm9vbSBmb3IgdGhlICd6Jy4gSWYgeW91IHJlbW92ZWQgYW4gaXRlbSwgdGhlIG5ldyBpbmRleFxuXHRcdC8vIHdvdWxkIGJlIC0xLi4uXG5cdFx0Ly9cblx0XHQvLyAgICAgYXJyYXkuc3BsaWNlKCAyLCAyICk7XG5cdFx0Ly9cblx0XHQvLyAuLi50aGlzIHdvdWxkIHJlc3VsdCBpbiBbIDAsIDEsIC0xLCAtMSwgMiwgMyBdLlxuXHRcdC8vXG5cdFx0Ly8gVGhpcyBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIGVuYWJsZSBmYXN0LCBub24tZGVzdHJ1Y3RpdmUgc2h1ZmZsaW5nIG9mIGxpc3Rcblx0XHQvLyBzZWN0aW9ucyB3aGVuIHlvdSBkbyBlLmcuIGByYWN0aXZlLnNwbGljZSggJ2l0ZW1zJywgMiwgMiApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZ2V0TmV3SW5kaWNlcyggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgc3BsaWNlQXJndW1lbnRzLCBsZW4sIG5ld0luZGljZXMgPSBbXSxcblx0XHRcdFx0cmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCwgYmFsYW5jZSwgaTtcblx0XHRcdHNwbGljZUFyZ3VtZW50cyA9IGdldFNwbGljZUVxdWl2YWxlbnQoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICk7XG5cdFx0XHRpZiAoICFzcGxpY2VBcmd1bWVudHMgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0YmFsYW5jZSA9IHNwbGljZUFyZ3VtZW50cy5sZW5ndGggLSAyIC0gc3BsaWNlQXJndW1lbnRzWyAxIF07XG5cdFx0XHRyZW1vdmVTdGFydCA9IE1hdGgubWluKCBsZW4sIHNwbGljZUFyZ3VtZW50c1sgMCBdICk7XG5cdFx0XHRyZW1vdmVFbmQgPSByZW1vdmVTdGFydCArIHNwbGljZUFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCByZW1vdmVTdGFydDsgaSArPSAxICkge1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgaSA8IHJlbW92ZUVuZDsgaSArPSAxICkge1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIC0xICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpICsgYmFsYW5jZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ld0luZGljZXM7XG5cdFx0fTtcblx0XHQvLyBUaGUgcG9wLCBwdXNoLCBzaGlmdCBhbiB1bnNoaWZ0IG1ldGhvZHMgY2FuIGFsbCBiZSByZXByZXNlbnRlZFxuXHRcdC8vIGFzIGFuIGVxdWl2YWxlbnQgc3BsaWNlXG5cdFx0ZnVuY3Rpb24gZ2V0U3BsaWNlRXF1aXZhbGVudCggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKSB7XG5cdFx0XHRzd2l0Y2ggKCBtZXRob2ROYW1lICkge1xuXHRcdFx0XHRjYXNlICdzcGxpY2UnOlxuXHRcdFx0XHRcdGlmICggYXJnc1sgMCBdICE9PSB1bmRlZmluZWQgJiYgYXJnc1sgMCBdIDwgMCApIHtcblx0XHRcdFx0XHRcdGFyZ3NbIDAgXSA9IGFycmF5Lmxlbmd0aCArIE1hdGgubWF4KCBhcmdzWyAwIF0sIC1hcnJheS5sZW5ndGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCBhcmdzLmxlbmd0aCA8IDIgKSB7XG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZW5zdXJlIHdlIG9ubHkgcmVtb3ZlIGVsZW1lbnRzIHRoYXQgZXhpc3Rcblx0XHRcdFx0XHRhcmdzWyAxIF0gPSBNYXRoLm1pbiggYXJnc1sgMSBdLCBhcnJheS5sZW5ndGggLSBhcmdzWyAwIF0gKTtcblx0XHRcdFx0XHRyZXR1cm4gYXJncztcblx0XHRcdFx0Y2FzZSAnc29ydCc6XG5cdFx0XHRcdGNhc2UgJ3JldmVyc2UnOlxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRjYXNlICdwb3AnOlxuXHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFx0YXJyYXkubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRcdFx0MVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdGNhc2UgJ3B1c2gnOlxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRhcnJheS5sZW5ndGgsXG5cdFx0XHRcdFx0XHQwXG5cdFx0XHRcdFx0XS5jb25jYXQoIGFyZ3MgKTtcblx0XHRcdFx0Y2FzZSAnc2hpZnQnOlxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0MVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdGNhc2UgJ3Vuc2hpZnQnOlxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0MFxuXHRcdFx0XHRcdF0uY29uY2F0KCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlQXJyYXlNZXRob2QuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCA9IGZ1bmN0aW9uKCBpc0FycmF5LCBydW5sb29wLCBnZXROZXdJbmRpY2VzICkge1xuXG5cdFx0dmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHRcdFx0dmFyIGFyZ3MgPSBTTElDRSQwLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdFx0XHR2YXIgYXJyYXksIG5ld0luZGljZXMgPSBbXSxcblx0XHRcdFx0XHRsZW4sIHByb21pc2UsIHJlc3VsdDtcblx0XHRcdFx0YXJyYXkgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cdFx0XHRcdGlmICggIWlzQXJyYXkoIGFycmF5ICkgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2FsbGVkIHJhY3RpdmUuJyArIG1ldGhvZE5hbWUgKyAnKFxcJycgKyBrZXlwYXRoICsgJ1xcJyksIGJ1dCBcXCcnICsga2V5cGF0aCArICdcXCcgZG9lcyBub3QgcmVmZXIgdG8gYW4gYXJyYXknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXMoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICk7XG5cdFx0XHRcdHJlc3VsdCA9IGFycmF5UHJvdG9bIG1ldGhvZE5hbWUgXS5hcHBseSggYXJyYXksIGFyZ3MgKTtcblx0XHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggISFuZXdJbmRpY2VzICkge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSggaXNBcnJheSwgcnVubG9vcCwgZ2V0TmV3SW5kaWNlcyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3BvcC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwb3AgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3BvcCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcHVzaC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwdXNoID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdwdXNoJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBnbG9iYWwvY3NzLmpzICovXG5cdHZhciBnbG9iYWxfY3NzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIGNzcywgdXBkYXRlLCBydW5sb29wLCBzdHlsZUVsZW1lbnQsIGhlYWQsIHN0eWxlU2hlZXQsIGluRG9tLCBwcmVmaXggPSAnLyogUmFjdGl2ZS5qcyBjb21wb25lbnQgc3R5bGVzICovXFxuJyxcblx0XHRcdGNvbXBvbmVudHNJblBhZ2UgPSB7fSxcblx0XHRcdHN0eWxlcyA9IFtdO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Y3NzID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AgPSBjaXJjdWxhci5ydW5sb29wO1xuXHRcdFx0fSApO1xuXHRcdFx0c3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuXHRcdFx0c3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnaGVhZCcgKVsgMCBdO1xuXHRcdFx0aW5Eb20gPSBmYWxzZTtcblx0XHRcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gdXNlIHN0eWxlU2hlZXQuY3NzVGV4dCBpbnN0ZWFkXG5cdFx0XHRzdHlsZVNoZWV0ID0gc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQ7XG5cdFx0XHR1cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNzcztcblx0XHRcdFx0aWYgKCBzdHlsZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNzcyA9IHByZWZpeCArIHN0eWxlcy5qb2luKCAnICcgKTtcblx0XHRcdFx0XHRpZiAoIHN0eWxlU2hlZXQgKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWluRG9tICkge1xuXHRcdFx0XHRcdFx0aGVhZC5hcHBlbmRDaGlsZCggc3R5bGVFbGVtZW50ICk7XG5cdFx0XHRcdFx0XHRpbkRvbSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpbkRvbSApIHtcblx0XHRcdFx0XHRoZWFkLnJlbW92ZUNoaWxkKCBzdHlsZUVsZW1lbnQgKTtcblx0XHRcdFx0XHRpbkRvbSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Y3NzID0ge1xuXHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKCBDb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhQ29tcG9uZW50LmNzcyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHQvLyB3ZSBjcmVhdGUgdGhpcyBjb3VudGVyIHNvIHRoYXQgd2UgY2FuIGluL2RlY3JlbWVudCBpdCBhc1xuXHRcdFx0XHRcdFx0Ly8gaW5zdGFuY2VzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZC4gV2hlbiBhbGwgY29tcG9uZW50cyBhcmVcblx0XHRcdFx0XHRcdC8vIHJlbW92ZWQsIHRoZSBzdHlsZSBpcyB0b29cblx0XHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdID0gMDtcblx0XHRcdFx0XHRcdHN0eWxlcy5wdXNoKCBDb21wb25lbnQuY3NzICk7XG5cdFx0XHRcdFx0XHR1cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKz0gMTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggQ29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGlmICggIUNvbXBvbmVudC5jc3MgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdIC09IDE7XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHN0eWxlcywgQ29tcG9uZW50LmNzcyApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIHVwZGF0ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNzcztcblx0fSggY2lyY3VsYXIsIGlzQ2xpZW50LCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkcmVuZGVyID0gZnVuY3Rpb24oIGNzcywgSG9vaywgZ2V0RWxlbWVudCwgcnVubG9vcCApIHtcblxuXHRcdHZhciByZW5kZXJIb29rID0gbmV3IEhvb2soICdyZW5kZXInICksXG5cdFx0XHRjb21wbGV0ZUhvb2sgPSBuZXcgSG9vayggJ2NvbXBsZXRlJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlciggdGFyZ2V0LCBhbmNob3IgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwcm9taXNlLCBpbnN0YW5jZXMsIHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdC8vIGlmIGBub0ludHJvYCBpcyBgdHJ1ZWAsIHRlbXBvcmFyaWx5IGRpc2FibGUgdHJhbnNpdGlvbnNcblx0XHRcdHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdFx0aWYgKCB0aGlzLm5vSW50cm8gKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gcmVuZGVySG9vay5maXJlKCB0aGlzJDAgKTtcblx0XHRcdH0sIHRydWUgKTtcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudC5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IGNhbm5vdCBjYWxsIHJhY3RpdmUucmVuZGVyKCkgb24gYW4gYWxyZWFkeSByZW5kZXJlZCBpbnN0YW5jZSEgQ2FsbCByYWN0aXZlLnVucmVuZGVyKCkgZmlyc3QnICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKSB8fCB0aGlzLmVsO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgdGhpcy5hbmNob3I7XG5cdFx0XHR0aGlzLmVsID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cdFx0XHQvLyBBZGQgQ1NTLCBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHRoaXMuY29uc3RydWN0b3IuY3NzICkge1xuXHRcdFx0XHRjc3MuYWRkKCB0aGlzLmNvbnN0cnVjdG9yICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhcmdldCApIHtcblx0XHRcdFx0aWYgKCAhKCBpbnN0YW5jZXMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFsgdGhpcyBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGluc3RhbmNlcy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhbmNob3IgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSwgYW5jaG9yICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdC8vIEl0IGlzIG5vdyBtb3JlIHByb2JsZW1hdGljIHRvIGtub3cgaWYgdGhlIGNvbXBsZXRlIGhvb2tcblx0XHRcdC8vIHdvdWxkIGZpcmUuIE1ldGhvZCBjaGVja2luZyBpcyBzdHJhaWdodC1mb3J3YXJkLCBidXQgd291bGRcblx0XHRcdC8vIGFsc28gcmVxdWlyZSBwcmVmbGlnaHRpbmcgZXZlbnQgc3Vic2NyaXB0aW9ucy4gV2hpY2ggc2VlbXNcblx0XHRcdC8vIGxpa2UgbW9yZSB3b3JrIHRoZW4ganVzdCBsZXR0aW5nIHRoZSBwcm9taXNlIGhhcHBlbi5cblx0XHRcdC8vIEJ1dCBwZXJoYXBzIEknbSB3cm9uZyBhYm91dCB0aGF0Li4uXG5cdFx0XHRwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gY29tcGxldGVIb29rLmZpcmUoIHRoaXMkMCApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggZ2xvYmFsX2NzcywgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgZ2V0RWxlbWVudCwgcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRidWJibGUgPSBmdW5jdGlvbiBGcmFnbWVudCRidWJibGUoKSB7XG5cdFx0dGhpcy5kaXJ0eVZhbHVlID0gdGhpcy5kaXJ0eUFyZ3MgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5ib3VuZCAmJiB0eXBlb2YgdGhpcy5vd25lci5idWJibGUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZGV0YWNoID0gZnVuY3Rpb24gRnJhZ21lbnQkZGV0YWNoKCkge1xuXHRcdHZhciBkb2NGcmFnO1xuXHRcdGlmICggdGhpcy5pdGVtcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVtc1sgMCBdLmRldGFjaCgpO1xuXHRcdH1cblx0XHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHR2YXIgbm9kZSA9IGl0ZW0uZGV0YWNoKCk7XG5cdFx0XHQvLyBUT0RPIFRoZSBpZiB7Li4ufSB3YXNuJ3QgcHJldmlvdXNseSByZXF1aXJlZCAtIGl0IGlzIG5vdywgYmVjYXVzZSB3ZSdyZVxuXHRcdFx0Ly8gZm9yY2libHkgZGV0YWNoaW5nIGV2ZXJ5dGhpbmcgdG8gcmVvcmRlciBzZWN0aW9ucyBhZnRlciBhbiB1cGRhdGUuIFRoYXQnc1xuXHRcdFx0Ly8gYSBub24taWRlYWwgYnJ1dGUgZm9yY2UgYXBwcm9hY2gsIGltcGxlbWVudGVkIHRvIGdldCBhbGwgdGhlIHRlc3RzIHRvIHBhc3Ncblx0XHRcdC8vIC0gYXMgc29vbiBhcyBpdCdzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZWxlZ2FudCwgdGhpcyBzaG91bGRcblx0XHRcdC8vIHJldmVydCB0byBgZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApYFxuXHRcdFx0aWYgKCBub2RlICkge1xuXHRcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBkb2NGcmFnO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRBbGwgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcXVlcnk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW07XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZEFsbENvbXBvbmVudHMgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBsZW4sIGksIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRDb21wb25lbnQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kTmV4dE5vZGUoIGl0ZW0gKSB7XG5cdFx0dmFyIGluZGV4ID0gaXRlbS5pbmRleCxcblx0XHRcdG5vZGU7XG5cdFx0aWYgKCB0aGlzLml0ZW1zWyBpbmRleCArIDEgXSApIHtcblx0XHRcdG5vZGUgPSB0aGlzLml0ZW1zWyBpbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm93bmVyID09PSB0aGlzLnJvb3QgKSB7XG5cdFx0XHRpZiAoICF0aGlzLm93bmVyLmNvbXBvbmVudCApIHtcblx0XHRcdFx0Ly8gVE9ETyBidXQgc29tZXRoaW5nIGVsc2UgY291bGQgaGF2ZSBiZWVuIGFwcGVuZGVkIHRvXG5cdFx0XHRcdC8vIHRoaXMucm9vdC5lbCwgbm8/XG5cdFx0XHRcdG5vZGUgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMub3duZXIuY29tcG9uZW50LmZpbmROZXh0Tm9kZSgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlID0gdGhpcy5vd25lci5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXNbIDAgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZ2V0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRnZXROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZ2V0Tm9kZSgpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSB0aGlzO1xuXHRcdGRvIHtcblx0XHRcdGlmICggZnJhZ21lbnQucEVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBmcmFnbWVudC5wRWxlbWVudC5ub2RlO1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdHJldHVybiB0aGlzLnJvb3QuZGV0YWNoZWQgfHwgdGhpcy5yb290LmVsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2dldFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldFZhbHVlID0gZnVuY3Rpb24oIHBhcnNlSlNPTiApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEZyYWdtZW50JGdldFZhbHVlKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IGVtcHR5O1xuXHRcdFx0dmFyIGFzQXJncywgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgY2FjaGVkUmVzdWx0LCBkaXJ0eUZsYWcsIHJlc3VsdDtcblx0XHRcdGFzQXJncyA9IG9wdGlvbnMuYXJncztcblx0XHRcdGNhY2hlZFJlc3VsdCA9IGFzQXJncyA/ICdhcmdzTGlzdCcgOiAndmFsdWUnO1xuXHRcdFx0ZGlydHlGbGFnID0gYXNBcmdzID8gJ2RpcnR5QXJncycgOiAnZGlydHlWYWx1ZSc7XG5cdFx0XHRpZiAoIHRoaXNbIGRpcnR5RmxhZyBdICkge1xuXHRcdFx0XHRzb3VyY2UgPSBwcm9jZXNzSXRlbXMoIHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQgKTtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCBhc0FyZ3MgPyAnWycgKyBzb3VyY2UgKyAnXScgOiBzb3VyY2UsIHZhbHVlcyApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gYXNBcmdzID8gWyB0aGlzLnRvU3RyaW5nKCkgXSA6IHRoaXMudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1sgY2FjaGVkUmVzdWx0IF0gPSByZXN1bHQ7XG5cdFx0XHRcdHRoaXNbIGRpcnR5RmxhZyBdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1sgY2FjaGVkUmVzdWx0IF07XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyggaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApIHtcblx0XHRcdGNvdW50ZXIgPSBjb3VudGVyIHx8IDA7XG5cdFx0XHRyZXR1cm4gaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0dmFyIHBsYWNlaG9sZGVySWQsIHdyYXBwZWQsIHZhbHVlO1xuXHRcdFx0XHRpZiAoIGl0ZW0udGV4dCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS50ZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaXRlbS5mcmFnbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0uZnJhZ21lbnRzLm1hcCggZnVuY3Rpb24oIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NJdGVtcyggZnJhZ21lbnQuaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApO1xuXHRcdFx0XHRcdH0gKS5qb2luKCAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsYWNlaG9sZGVySWQgPSBndWlkICsgJy0nICsgY291bnRlcisrO1xuXHRcdFx0XHRpZiAoIHdyYXBwZWQgPSBpdGVtLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIGl0ZW0ua2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZXNbIHBsYWNlaG9sZGVySWQgXSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gJyR7JyArIHBsYWNlaG9sZGVySWQgKyAnfSc7XG5cdFx0XHR9ICkuam9pbiggJycgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBwYXJzZUpTT04gKTtcblxuXHQvKiB1dGlscy9lc2NhcGVIdG1sLmpzICovXG5cdHZhciBlc2NhcGVIdG1sID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGVzc1RoYW4gPSAvPC9nO1xuXHRcdHZhciBncmVhdGVyVGhhbiA9IC8+L2c7XG5cdFx0dmFyIGFtcCA9IC8mL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGVzY2FwZUh0bWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggYW1wLCAnJmFtcDsnICkucmVwbGFjZSggbGVzc1RoYW4sICcmbHQ7JyApLnJlcGxhY2UoIGdyZWF0ZXJUaGFuLCAnJmd0OycgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvZGV0YWNoTm9kZS5qcyAqL1xuXHR2YXIgZGV0YWNoTm9kZSA9IGZ1bmN0aW9uIGRldGFjaE5vZGUoIG5vZGUgKSB7XG5cdFx0aWYgKCBub2RlICYmIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9kZXRhY2guanMgKi9cblx0dmFyIGRldGFjaCA9IGZ1bmN0aW9uKCBkZXRhY2hOb2RlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRldGFjaE5vZGUoIHRoaXMubm9kZSApO1xuXHRcdH07XG5cdH0oIGRldGFjaE5vZGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RleHQuanMgKi9cblx0dmFyIFRleHQgPSBmdW5jdGlvbiggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApIHtcblxuXHRcdHZhciBUZXh0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5URVhUO1xuXHRcdFx0dGhpcy50ZXh0ID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHR9O1xuXHRcdFRleHQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggdGhpcy50ZXh0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIGVzY2FwZSApIHtcblx0XHRcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoIHRoaXMudGV4dCApIDogdGhpcy50ZXh0O1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmRldGFjaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVGV4dDtcblx0fSggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3VuYmluZC5qcyAqL1xuXHR2YXIgdW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kKCkge1xuXHRcdGlmICggdGhpcy5yZWdpc3RlcmVkICkge1xuXHRcdFx0Ly8gdGhpcyB3YXMgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGFudFxuXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlc29sdmVyICkge1xuXHRcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvZ2V0VmFsdWUuanMgKi9cblx0dmFyIGdldFZhbHVlID0gZnVuY3Rpb24gTXVzdGFjaGUkZ2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvc3RhcnRzV2l0aEtleXBhdGguanMgKi9cblx0dmFyIHN0YXJ0c1dpdGhLZXlwYXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldCwga2V5cGF0aCApIHtcblx0XHRyZXR1cm4gdGFyZ2V0ICYmIGtleXBhdGggJiYgdGFyZ2V0LnN1YnN0ciggMCwga2V5cGF0aC5sZW5ndGggKyAxICkgPT09IGtleXBhdGggKyAnLic7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvZ2V0TmV3S2V5cGF0aC5qcyAqL1xuXHR2YXIgZ2V0TmV3S2V5cGF0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXROZXdLZXlwYXRoKCB0YXJnZXRLZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0Ly8gZXhhY3QgbWF0Y2hcblx0XHRcdGlmICggdGFyZ2V0S2V5cGF0aCA9PT0gb2xkS2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIG5ld0tleXBhdGggIT09IHVuZGVmaW5lZCA/IG5ld0tleXBhdGggOiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcGFydGlhbCBtYXRjaCBiYXNlZCBvbiBsZWFkaW5nIGtleXBhdGggc2VnbWVudHNcblx0XHRcdGlmICggc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldEtleXBhdGgsIG9sZEtleXBhdGggKSApIHtcblx0XHRcdFx0cmV0dXJuIG5ld0tleXBhdGggPT09IG51bGwgPyBuZXdLZXlwYXRoIDogdGFyZ2V0S2V5cGF0aC5yZXBsYWNlKCBvbGRLZXlwYXRoICsgJy4nLCBuZXdLZXlwYXRoICsgJy4nICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggc3RhcnRzV2l0aEtleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlUmVzb2x2ZXIuanMgKi9cblx0dmFyIFJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHJlc29sdmVSZWYsIGdldE5ld0tleXBhdGggKSB7XG5cblx0XHR2YXIgUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiggb3duZXIsIHJlZiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIga2V5cGF0aDtcblx0XHRcdHRoaXMucmVmID0gcmVmO1xuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5yb290ID0gb3duZXIucm9vdDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCBvd25lci5yb290LCByZWYsIG93bmVyLnBhcmVudEZyYWdtZW50ICk7XG5cdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRydW5sb29wLmFkZFVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy5jYWxsYmFjaygga2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZSggdGhpcy5yZWYgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoO1xuXHRcdFx0XHRpZiAoIHRoaXMua2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGtleXBhdGggPSBnZXROZXdLZXlwYXRoKCB0aGlzLmtleXBhdGgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHQvLyB3YXMgYSBuZXcga2V5cGF0aCBjcmVhdGVkP1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Ly8gcmVzb2x2ZSBpdFxuXHRcdFx0XHRcdFx0dGhpcy5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5yZXNvbHZlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLnJlbW92ZVVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFJlZmVyZW5jZVJlc29sdmVyO1xuXHR9KCBydW5sb29wLCByZXNvbHZlUmVmLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1NwZWNpYWxSZXNvbHZlci5qcyAqL1xuXHR2YXIgU3BlY2lhbFJlc29sdmVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgU3BlY2lhbFJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCByZWYsIGNhbGxiYWNrICkge1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZWYgPSByZWY7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLnJlYmluZCgpO1xuXHRcdH07XG5cdFx0U3BlY2lhbFJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZWYgPSB0aGlzLnJlZixcblx0XHRcdFx0XHRmcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRcdGlmICggcmVmID09PSAnQGtleXBhdGgnICkge1xuXHRcdFx0XHRcdHdoaWxlICggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICEhZnJhZ21lbnQuY29udGV4dCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soICdAJyArIGZyYWdtZW50LmNvbnRleHQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHJlZiA9PT0gJ0BpbmRleCcgfHwgcmVmID09PSAnQGtleScgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBmcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdGlmICggZnJhZ21lbnQuaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soICdAJyArIGZyYWdtZW50LmluZGV4ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biBzcGVjaWFsIHJlZmVyZW5jZSBcIicgKyByZWYgKyAnXCIgLSB2YWxpZCByZWZlcmVuY2VzIGFyZSBAaW5kZXgsIEBrZXkgYW5kIEBrZXlwYXRoJyApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cdFx0cmV0dXJuIFNwZWNpYWxSZXNvbHZlcjtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9JbmRleFJlc29sdmVyLmpzICovXG5cdHZhciBJbmRleFJlc29sdmVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgSW5kZXhSZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcmVmLCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVmID0gcmVmO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5yZWJpbmQoKTtcblx0XHR9O1xuXHRcdEluZGV4UmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmViaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJlZiA9IHRoaXMucmVmLFxuXHRcdFx0XHRcdGluZGV4UmVmcyA9IHRoaXMucGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzLFxuXHRcdFx0XHRcdGluZGV4ID0gaW5kZXhSZWZzWyByZWYgXTtcblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2soICdAJyArIGluZGV4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge31cblx0XHR9O1xuXHRcdHJldHVybiBJbmRleFJlc29sdmVyO1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLmpzICovXG5cdHZhciBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBSZWZlcmVuY2VSZXNvbHZlciwgU3BlY2lhbFJlc29sdmVyLCBJbmRleFJlc29sdmVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCBvd25lciwgcmVmLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBpbmRleFJlZnMsIGluZGV4O1xuXHRcdFx0aWYgKCByZWYuY2hhckF0KCAwICkgPT09ICdAJyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBTcGVjaWFsUmVzb2x2ZXIoIG93bmVyLCByZWYsIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRpbmRleFJlZnMgPSBvd25lci5wYXJlbnRGcmFnbWVudC5pbmRleFJlZnM7XG5cdFx0XHRpZiAoIGluZGV4UmVmcyAmJiAoIGluZGV4ID0gaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgSW5kZXhSZXNvbHZlciggb3duZXIsIHJlZiwgY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUmVmZXJlbmNlUmVzb2x2ZXIoIG93bmVyLCByZWYsIGNhbGxiYWNrICk7XG5cdFx0fTtcblx0fSggUmVmZXJlbmNlUmVzb2x2ZXIsIFNwZWNpYWxSZXNvbHZlciwgSW5kZXhSZXNvbHZlciApO1xuXG5cdC8qIHNoYXJlZC9nZXRGdW5jdGlvbkZyb21TdHJpbmcuanMgKi9cblx0dmFyIGdldEZ1bmN0aW9uRnJvbVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNhY2hlID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEZ1bmN0aW9uRnJvbVN0cmluZyggc3RyLCBpICkge1xuXHRcdFx0dmFyIGZuLCBhcmdzO1xuXHRcdFx0aWYgKCBjYWNoZVsgc3RyIF0gKSB7XG5cdFx0XHRcdHJldHVybiBjYWNoZVsgc3RyIF07XG5cdFx0XHR9XG5cdFx0XHRhcmdzID0gW107XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0YXJnc1sgaSBdID0gJ18nICsgaTtcblx0XHRcdH1cblx0XHRcdGZuID0gbmV3IEZ1bmN0aW9uKCBhcmdzLmpvaW4oICcsJyApLCAncmV0dXJuKCcgKyBzdHIgKyAnKScgKTtcblx0XHRcdGNhY2hlWyBzdHIgXSA9IGZuO1xuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvRXhwcmVzc2lvblJlc29sdmVyLmpzICovXG5cdHZhciBFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggZGVmaW5lUHJvcGVydHksIGlzTnVtZXJpYywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGdldEZ1bmN0aW9uRnJvbVN0cmluZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRXhwcmVzc2lvblJlc29sdmVyLCBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cdFx0RXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCBwYXJlbnRGcmFnbWVudCwgZXhwcmVzc2lvbiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBpbmRleFJlZnM7XG5cdFx0XHRyYWN0aXZlID0gb3duZXIucm9vdDtcblx0XHRcdHJlc29sdmVyLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0cmVzb2x2ZXIucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlc29sdmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXNvbHZlci5vd25lciA9IG93bmVyO1xuXHRcdFx0cmVzb2x2ZXIuc3RyID0gZXhwcmVzc2lvbi5zO1xuXHRcdFx0cmVzb2x2ZXIua2V5cGF0aHMgPSBbXTtcblx0XHRcdGluZGV4UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG5cdFx0XHRyZXNvbHZlci5wZW5kaW5nID0gZXhwcmVzc2lvbi5yLmxlbmd0aDtcblx0XHRcdHJlc29sdmVyLnJlZlJlc29sdmVycyA9IGV4cHJlc3Npb24uci5tYXAoIGZ1bmN0aW9uKCByZWYsIGkgKSB7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggcmVzb2x2ZXIsIHJlZiwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIucmVzb2x2ZSggaSwga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXNvbHZlci5yZWFkeSA9IHRydWU7XG5cdFx0XHRyZXNvbHZlci5idWJibGUoKTtcblx0XHR9O1xuXHRcdEV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVuaXF1ZVN0cmluZyA9IGdldFVuaXF1ZVN0cmluZyggdGhpcy5zdHIsIHRoaXMua2V5cGF0aHMgKTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0gZ2V0S2V5cGF0aCggdGhpcy51bmlxdWVTdHJpbmcgKTtcblx0XHRcdFx0dGhpcy5jcmVhdGVFdmFsdWF0b3IoKTtcblx0XHRcdFx0dGhpcy5jYWxsYmFjayggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJlc29sdmVyO1xuXHRcdFx0XHR3aGlsZSAoIHJlc29sdmVyID0gdGhpcy5yZWZSZXNvbHZlcnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbiggaW5kZXgsIGtleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMua2V5cGF0aHNbIGluZGV4IF0gPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZUV2YWx1YXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdFx0Y29tcHV0YXRpb24sIHZhbHVlR2V0dGVycywgc2lnbmF0dXJlLCBrZXlwYXRoLCBmbjtcblx0XHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGF0aW9uc1sgdGhpcy5rZXlwYXRoIF07XG5cdFx0XHRcdC8vIG9ubHkgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQhXG5cdFx0XHRcdGlmICggIWNvbXB1dGF0aW9uICkge1xuXHRcdFx0XHRcdGZuID0gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKCB0aGlzLnN0ciwgdGhpcy5yZWZSZXNvbHZlcnMubGVuZ3RoICk7XG5cdFx0XHRcdFx0dmFsdWVHZXR0ZXJzID0gdGhpcy5rZXlwYXRocy5tYXAoIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0XHRcdFx0aWYgKCBrZXlwYXRoID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyAnc3BlY2lhbCcga2V5cGF0aHMgZW5jb2RlIGEgdmFsdWVcblx0XHRcdFx0XHRcdGlmICgga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0ga2V5cGF0aC5zbGljZSggMSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaXNOdW1lcmljKCB2YWx1ZSApID8gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICt2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fSA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcyQwLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBGdW5jdGlvbiggdmFsdWUsIHNlbGYucm9vdCApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHNpZ25hdHVyZSA9IHtcblx0XHRcdFx0XHRcdGRlcHM6IHRoaXMua2V5cGF0aHMuZmlsdGVyKCBpc1ZhbGlkRGVwZW5kZW5jeSApLFxuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSB2YWx1ZUdldHRlcnMubWFwKCBjYWxsICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmbi5hcHBseSggbnVsbCwgYXJncyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGUoIHRoaXMua2V5cGF0aCwgc2lnbmF0dXJlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5tYXJrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0Ly8gVE9ETyBvbmx5IGJ1YmJsZSBvbmNlLCBubyBtYXR0ZXIgaG93IG1hbnkgcmVmZXJlbmNlcyBhcmUgYWZmZWN0ZWQgYnkgdGhlIHJlYmluZFxuXHRcdFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRyZXR1cm4gci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IEV4cHJlc3Npb25SZXNvbHZlcjtcblxuXHRcdGZ1bmN0aW9uIGNhbGwoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLmNhbGwoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbmlxdWVTdHJpbmcoIHN0ciwga2V5cGF0aHMgKSB7XG5cdFx0XHQvLyBnZXQgc3RyaW5nIHRoYXQgaXMgdW5pcXVlIHRvIHRoaXMgZXhwcmVzc2lvblxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXyhbMC05XSspL2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoLCB2YWx1ZTtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyAkMSBdO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gJ3VuZGVmaW5lZCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBrZXlwYXRoWyAwIF0gPT09ICdAJyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGtleXBhdGguc2xpY2UoIDEgKTtcblx0XHRcdFx0XHRyZXR1cm4gaXNOdW1lcmljKCB2YWx1ZSApID8gdmFsdWUgOiAnXCInICsgdmFsdWUgKyAnXCInO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBrZXlwYXRoO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEtleXBhdGgoIHVuaXF1ZVN0cmluZyApIHtcblx0XHRcdC8vIFNhbml0aXplIGJ5IHJlbW92aW5nIGFueSBwZXJpb2RzIG9yIHNxdWFyZSBicmFja2V0cy4gT3RoZXJ3aXNlXG5cdFx0XHQvLyB3ZSBjYW4ndCBzcGxpdCB0aGUga2V5cGF0aCBpbnRvIGtleXMhXG5cdFx0XHRyZXR1cm4gJyR7JyArIHVuaXF1ZVN0cmluZy5yZXBsYWNlKCAvW1xcLlxcW1xcXV0vZywgJy0nICkgKyAnfSc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNWYWxpZERlcGVuZGVuY3koIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4ga2V5cGF0aCAhPT0gdW5kZWZpbmVkICYmIGtleXBhdGhbIDAgXSAhPT0gJ0AnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdyYXBGdW5jdGlvbiggZm4sIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgd3JhcHBlZCwgcHJvcCwga2V5O1xuXHRcdFx0aWYgKCBmbi5fbm9XcmFwICkge1xuXHRcdFx0XHRyZXR1cm4gZm47XG5cdFx0XHR9XG5cdFx0XHRwcm9wID0gJ19fcmFjdGl2ZV8nICsgcmFjdGl2ZS5fZ3VpZDtcblx0XHRcdHdyYXBwZWQgPSBmblsgcHJvcCBdO1xuXHRcdFx0aWYgKCB3cmFwcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gd3JhcHBlZDtcblx0XHRcdH0gZWxzZSBpZiAoIC90aGlzLy50ZXN0KCBmbi50b1N0cmluZygpICkgKSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KCBmbiwgcHJvcCwge1xuXHRcdFx0XHRcdHZhbHVlOiBiaW5kLmNhbGwoIGZuLCByYWN0aXZlIClcblx0XHRcdFx0fSApO1xuXHRcdFx0XHQvLyBBZGQgcHJvcGVydGllcy9tZXRob2RzIHRvIHdyYXBwZWQgZnVuY3Rpb25cblx0XHRcdFx0Zm9yICgga2V5IGluIGZuICkge1xuXHRcdFx0XHRcdGlmICggZm4uaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdFx0Zm5bIHByb3AgXVsga2V5IF0gPSBmblsga2V5IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmblsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIGZuLCAnX19yYWN0aXZlX25vd3JhcCcsIHtcblx0XHRcdFx0dmFsdWU6IGZuXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gZm4uX19yYWN0aXZlX25vd3JhcDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBkZWZpbmVQcm9wZXJ0eSwgaXNOdW1lcmljLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nLCBsZWdhY3kgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyL01lbWJlclJlc29sdmVyLmpzICovXG5cdHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApIHtcblxuXHRcdHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uKCB0ZW1wbGF0ZSwgcmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0dmFyIG1lbWJlciA9IHRoaXMsXG5cdFx0XHRcdGtleXBhdGg7XG5cdFx0XHRtZW1iZXIucmVzb2x2ZXIgPSByZXNvbHZlcjtcblx0XHRcdG1lbWJlci5yb290ID0gcmVzb2x2ZXIucm9vdDtcblx0XHRcdG1lbWJlci5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuXHRcdFx0bWVtYmVyLnZpZXdtb2RlbCA9IHJlc29sdmVyLnJvb3Qudmlld21vZGVsO1xuXHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRtZW1iZXIudmFsdWUgPSB0ZW1wbGF0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0bWVtYmVyLnJlZlJlc29sdmVyID0gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIHRoaXMsIHRlbXBsYXRlLm4sIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdG1lbWJlci5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ldyBFeHByZXNzaW9uUmVzb2x2ZXIoIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdG1lbWJlci5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdE1lbWJlclJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIHRoaXMua2V5cGF0aCApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIHRoaXMucmVmUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy51bnJlc29sdmVkICkge1xuXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZC51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZWZSZXNvbHZlciApIHtcblx0XHRcdFx0XHR0aGlzLnJlZlJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gTWVtYmVyUmVzb2x2ZXI7XG5cdH0oIHR5cGVzLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgRXhwcmVzc2lvblJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIuanMgKi9cblx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCByZXNvbHZlUmVmLCBSZWZlcmVuY2VSZXNvbHZlciwgTWVtYmVyUmVzb2x2ZXIgKSB7XG5cblx0XHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIG11c3RhY2hlLCB0ZW1wbGF0ZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciByZXNvbHZlciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIHJlZiwga2V5cGF0aCwgcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZXNvbHZlci5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50ID0gbXVzdGFjaGUucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZXNvbHZlci5yb290ID0gcmFjdGl2ZSA9IG11c3RhY2hlLnJvb3Q7XG5cdFx0XHRyZXNvbHZlci5tdXN0YWNoZSA9IG11c3RhY2hlO1xuXHRcdFx0cmVzb2x2ZXIucmVmID0gcmVmID0gdGVtcGxhdGUucjtcblx0XHRcdHJlc29sdmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXNvbHZlci51bnJlc29sdmVkID0gW107XG5cdFx0XHQvLyBGaW5kIGJhc2Uga2V5cGF0aFxuXHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc29sdmVyLmJhc2VSZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VSZXNvbHZlciggdGhpcywgcmVmLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuXHRcdFx0XHRcdHJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaW5kIHZhbHVlcyBmb3IgbWVtYmVycywgb3IgbWFyayB0aGVtIGFzIHVucmVzb2x2ZWRcblx0XHRcdHJlc29sdmVyLm1lbWJlcnMgPSB0ZW1wbGF0ZS5tLm1hcCggZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IE1lbWJlclJlc29sdmVyKCB0ZW1wbGF0ZSwgdGhpcyQwLCBwYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmVzb2x2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0S2V5cGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1lbWJlcnMubWFwKCBnZXRWYWx1ZSApO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXMuZXZlcnkoIGlzRGVmaW5lZCApIHx8IHRoaXMuYmFzZVJlc29sdmVyICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmJhc2UgKyAnLicgKyB2YWx1ZXMuam9pbiggJy4nICk7XG5cdFx0XHR9LFxuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5yZWFkeSB8fCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jYWxsYmFjayggdGhpcy5nZXRLZXlwYXRoKCkgKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgY2hhbmdlZDtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBtZW1iZXJzICkge1xuXHRcdFx0XHRcdGlmICggbWVtYmVycy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHR0aGlzLmJhc2UgPSB0aGlzLnJlZjtcblx0XHRcdFx0XHR0aGlzLmJhc2VSZXNvbHZlci51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBtICkge1xuXHRcdFx0XHRcdHJldHVybiBtLmZvcmNlUmVzb2x1dGlvbigpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlKCBtZW1iZXIgKSB7XG5cdFx0XHRyZXR1cm4gbWVtYmVyLnZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzRGVmaW5lZCggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgIT0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggbWVtYmVyICkge1xuXHRcdFx0bWVtYmVyLnVuYmluZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyO1xuXHR9KCByZXNvbHZlUmVmLCBSZWZlcmVuY2VSZXNvbHZlciwgTWVtYmVyUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9pbml0aWFsaXNlLmpzICovXG5cdHZhciBpbml0aWFsaXNlID0gZnVuY3Rpb24oIHR5cGVzLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gTXVzdGFjaGUkaW5pdCggbXVzdGFjaGUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcmVmLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRtdXN0YWNoZS5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdG11c3RhY2hlLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRtdXN0YWNoZS5wRWxlbWVudCA9IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXHRcdFx0bXVzdGFjaGUudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0bXVzdGFjaGUuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG5cdFx0XHRtdXN0YWNoZS5pc1N0YXRpYyA9IG9wdGlvbnMudGVtcGxhdGUucztcblx0XHRcdG11c3RhY2hlLnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLnQ7XG5cdFx0XHRtdXN0YWNoZS5yZWdpc3RlcmVkID0gZmFsc2U7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgc2ltcGxlIG11c3RhY2hlLCB3aXRoIGEgcmVmZXJlbmNlLCB3ZSBqdXN0IG5lZWQgdG8gcmVzb2x2ZVxuXHRcdFx0Ly8gdGhlIHJlZmVyZW5jZSB0byBhIGtleXBhdGhcblx0XHRcdGlmICggcmVmID0gdGVtcGxhdGUuciApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIG11c3RhY2hlLCByZWYsIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIGl0J3MgYW4gZXhwcmVzc2lvbiwgd2UgaGF2ZSBhIGJpdCBtb3JlIHdvcmsgdG8gZG9cblx0XHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS54ICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBFeHByZXNzaW9uUmVzb2x2ZXIoIG11c3RhY2hlLCBwYXJlbnRGcmFnbWVudCwgb3B0aW9ucy50ZW1wbGF0ZS54LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4gKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS5yeCApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKCBtdXN0YWNoZSwgb3B0aW9ucy50ZW1wbGF0ZS5yeCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpbnZlcnRlZCBzZWN0aW9uc1xuXHRcdFx0aWYgKCBtdXN0YWNoZS50ZW1wbGF0ZS5uID09PSB0eXBlcy5TRUNUSU9OX1VOTEVTUyAmJiAhbXVzdGFjaGUuaGFzT3duUHJvcGVydHkoICd2YWx1ZScgKSApIHtcblx0XHRcdFx0bXVzdGFjaGUuc2V0VmFsdWUoIHVuZGVmaW5lZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBrZXlwYXRoICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiggbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG9sZEtleXBhdGggPSBtdXN0YWNoZS5rZXlwYXRoO1xuXHRcdFx0XHRpZiAoIG5ld0tleXBhdGggIT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZSggbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRcdGlmICggb2xkS2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuZnJhZ21lbnRzICYmIG11c3RhY2hlLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRcdFx0Zi5yZWJpbmQoIG51bGwsIG51bGwsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciwgRXhwcmVzc2lvblJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvcmVzb2x2ZS5qcyAqL1xuXHR2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uKCBpc051bWVyaWMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gTXVzdGFjaGUkcmVzb2x2ZSgga2V5cGF0aCApIHtcblx0XHRcdHZhciB3YXNSZXNvbHZlZCwgdmFsdWUsIHR3b3dheUJpbmRpbmc7XG5cdFx0XHQvLyAnU3BlY2lhbCcga2V5cGF0aHMsIGUuZy4gQGZvbyBvciBANywgZW5jb2RlIGEgdmFsdWVcblx0XHRcdGlmICgga2V5cGF0aCAmJiBrZXlwYXRoWyAwIF0gPT09ICdAJyApIHtcblx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnNsaWNlKCAxICk7XG5cdFx0XHRcdGlmICggaXNOdW1lcmljKCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHZhbHVlID0gK3ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHdlIHJlc29sdmVkIHByZXZpb3VzbHksIHdlIG5lZWQgdG8gdW5yZWdpc3RlclxuXHRcdFx0aWYgKCB0aGlzLnJlZ2lzdGVyZWQgKSB7XG5cdFx0XHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXHRcdFx0XHR3YXNSZXNvbHZlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0Ly8gSWYgdGhlIG5ldyBrZXlwYXRoIGV4aXN0cywgd2UgbmVlZCB0byByZWdpc3RlclxuXHRcdFx0Ly8gd2l0aCB0aGUgdmlld21vZGVsXG5cdFx0XHRpZiAoIGtleXBhdGggIT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIEVpdGhlciB3YXkgd2UgbmVlZCB0byBxdWV1ZSB1cCBhIHJlbmRlciAoYHZhbHVlYFxuXHRcdFx0Ly8gd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGVyZSdzIG5vIGtleXBhdGgpXG5cdFx0XHR0aGlzLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0Ly8gVHdvLXdheSBiaW5kaW5ncyBuZWVkIHRvIHBvaW50IHRvIHRoZWlyIG5ldyB0YXJnZXQga2V5cGF0aFxuXHRcdFx0aWYgKCB3YXNSZXNvbHZlZCAmJiAoIHR3b3dheUJpbmRpbmcgPSB0aGlzLnR3b3dheUJpbmRpbmcgKSApIHtcblx0XHRcdFx0dHdvd2F5QmluZGluZy5yZWJvdW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNOdW1lcmljICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvcmViaW5kLmpzICovXG5cdHZhciByZWJpbmQgPSBmdW5jdGlvbiBNdXN0YWNoZSRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHQvLyBDaGlsZHJlbiBmaXJzdFxuXHRcdGlmICggdGhpcy5mcmFnbWVudHMgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0cmV0dXJuIGYucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0Ly8gRXhwcmVzc2lvbiBtdXN0YWNoZT9cblx0XHRpZiAoIHRoaXMucmVzb2x2ZXIgKSB7XG5cdFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL19NdXN0YWNoZS5qcyAqL1xuXHR2YXIgTXVzdGFjaGUgPSBmdW5jdGlvbiggZ2V0VmFsdWUsIGluaXQsIHJlc29sdmUsIHJlYmluZCApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXRWYWx1ZTogZ2V0VmFsdWUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcblx0XHRcdHJlYmluZDogcmViaW5kXG5cdFx0fTtcblx0fSggZ2V0VmFsdWUsIGluaXRpYWxpc2UsIHJlc29sdmUsIHJlYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvSW50ZXJwb2xhdG9yLmpzICovXG5cdHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggdHlwZXMsIHJ1bmxvb3AsIGVzY2FwZUh0bWwsIGRldGFjaE5vZGUsIGlzRXF1YWwsIHVuYmluZCwgTXVzdGFjaGUsIGRldGFjaCApIHtcblxuXHRcdHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEludGVycG9sYXRvci5wcm90b3R5cGUgPSB7XG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm5vZGUuZGF0YSA9IHRoaXMudmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB0aGlzLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6ICcnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0XHRkZXRhY2hOb2RlKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblx0XHRcdC8vIFRFTVBcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB3cmFwcGVyO1xuXHRcdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIHRoaXMua2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIGVzY2FwZSApIHtcblx0XHRcdFx0dmFyIHN0cmluZyA9IHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gJycgKyB0aGlzLnZhbHVlIDogJyc7XG5cdFx0XHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKCBzdHJpbmcgKSA6IHN0cmluZztcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBJbnRlcnBvbGF0b3I7XG5cdH0oIHR5cGVzLCBydW5sb29wLCBlc2NhcGVIdG1sLCBkZXRhY2hOb2RlLCBpc0VxdWFsLCB1bmJpbmQsIE11c3RhY2hlLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGJ1YmJsZSA9IGZ1bmN0aW9uIFNlY3Rpb24kYnViYmxlKCkge1xuXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRkZXRhY2ggPSBmdW5jdGlvbiBTZWN0aW9uJGRldGFjaCgpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1sgMCBdLmRldGFjaCgpO1xuXHRcdH1cblx0XHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZG9jRnJhZztcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmQoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW47XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbjtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzWyBpIF0uZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmROZXh0Tm9kZSggZnJhZ21lbnQgKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50c1sgZnJhZ21lbnQuaW5kZXggKyAxIF0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdLmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIFNlY3Rpb24kZmlyc3ROb2RlKCkge1xuXHRcdHZhciBsZW4sIGksIG5vZGU7XG5cdFx0aWYgKCBsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpZiAoIG5vZGUgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpcnN0Tm9kZSgpICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvc2h1ZmZsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNodWZmbGUgPSBmdW5jdGlvbiggdHlwZXMsIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFNlY3Rpb24kc2h1ZmZsZSggbmV3SW5kaWNlcyApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLFxuXHRcdFx0XHRwYXJlbnRGcmFnbWVudCwgZmlyc3RDaGFuZ2UsIGksIG5ld0xlbmd0aCwgcmVib3VuZEZyYWdtZW50cywgZnJhZ21lbnRPcHRpb25zLCBmcmFnbWVudDtcblx0XHRcdC8vIHNob3J0IGNpcmN1aXQgYW55IGRvdWJsZS11cGRhdGVzLCBhbmQgZW5zdXJlIHRoYXQgdGhpcyBpc24ndCBhcHBsaWVkIHRvXG5cdFx0XHQvLyBub24tbGlzdCBzZWN0aW9uc1xuXHRcdFx0aWYgKCB0aGlzLnNodWZmbGluZyB8fCB0aGlzLnVuYm91bmQgfHwgdGhpcy5zdWJ0eXBlICYmIHRoaXMuc3VidHlwZSAhPT0gdHlwZXMuU0VDVElPTl9FQUNIICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNodWZmbGluZyA9IHRydWU7XG5cdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzJDAuc2h1ZmZsaW5nID0gZmFsc2U7XG5cdFx0XHR9ICk7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZWJvdW5kRnJhZ21lbnRzID0gW107XG5cdFx0XHQvLyBmaXJzdCwgcmViaW5kIGV4aXN0aW5nIGZyYWdtZW50c1xuXHRcdFx0bmV3SW5kaWNlcy5mb3JFYWNoKCBmdW5jdGlvbiByZWJpbmRJZk5lY2Vzc2FyeSggbmV3SW5kZXgsIG9sZEluZGV4ICkge1xuXHRcdFx0XHR2YXIgZnJhZ21lbnQsIGJ5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXHRcdFx0XHRpZiAoIG5ld0luZGV4ID09PSBvbGRJbmRleCApIHtcblx0XHRcdFx0XHRyZWJvdW5kRnJhZ21lbnRzWyBuZXdJbmRleCBdID0gc2VjdGlvbi5mcmFnbWVudHNbIG9sZEluZGV4IF07XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbIG9sZEluZGV4IF07XG5cdFx0XHRcdGlmICggZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRmaXJzdENoYW5nZSA9IG9sZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvZXMgdGhpcyBmcmFnbWVudCBuZWVkIHRvIGJlIHRvcm4gZG93bj9cblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgaXQgbmVlZHMgdG8gYmUgcmVib3VuZCB0byBhIG5ldyBpbmRleFxuXHRcdFx0XHRieSA9IG5ld0luZGV4IC0gb2xkSW5kZXg7XG5cdFx0XHRcdG9sZEtleXBhdGggPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBvbGRJbmRleDtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIG5ld0luZGV4O1xuXHRcdFx0XHRmcmFnbWVudC5yZWJpbmQoIHNlY3Rpb24udGVtcGxhdGUuaSwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0ZnJhZ21lbnQuaW5kZXggPSBuZXdJbmRleDtcblx0XHRcdFx0cmVib3VuZEZyYWdtZW50c1sgbmV3SW5kZXggXSA9IGZyYWdtZW50O1xuXHRcdFx0fSApO1xuXHRcdFx0bmV3TGVuZ3RoID0gdGhpcy5yb290LmdldCggdGhpcy5rZXlwYXRoICkubGVuZ3RoO1xuXHRcdFx0Ly8gSWYgbm90aGluZyBjaGFuZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGZyYWdtZW50cywgdGhlbiB3ZSBzdGFydCBhZGRpbmdcblx0XHRcdC8vIG5ldyBmcmFnbWVudHMgYXQgdGhlIGVuZC4uLlxuXHRcdFx0aWYgKCBmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyAuLi51bmxlc3MgdGhlcmUgYXJlIG5vIG5ldyBmcmFnbWVudHMgdG8gYWRkXG5cdFx0XHRcdGlmICggdGhpcy5sZW5ndGggPT09IG5ld0xlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Zmlyc3RDaGFuZ2UgPSB0aGlzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHRoaXMubGVuZ3RoID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID0gbmV3TGVuZ3RoO1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIFByZXBhcmUgbmV3IGZyYWdtZW50IG9wdGlvbnNcblx0XHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fTtcblx0XHRcdGlmICggdGhpcy50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSB0aGlzLnRlbXBsYXRlLmk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgYXMgbWFueSBuZXcgZnJhZ21lbnRzIGFzIHdlIG5lZWQgdG8sIG9yIGFkZCBiYWNrIGV4aXN0aW5nXG5cdFx0XHQvLyAoZGV0YWNoZWQpIGZyYWdtZW50c1xuXHRcdFx0Zm9yICggaSA9IGZpcnN0Q2hhbmdlOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gcmVib3VuZEZyYWdtZW50c1sgaSBdO1xuXHRcdFx0XHRpZiAoICFmcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdID0gZnJhZ21lbnQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRyZW5kZXIgPSBmdW5jdGlvbiBTZWN0aW9uJHJlbmRlcigpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRkb2NGcmFnID0gdGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdXRpbHMvaXNBcnJheUxpa2UuanMgKi9cblx0dmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcGF0dGVybiA9IC9eXFxbb2JqZWN0ICg/OkFycmF5fEZpbGVMaXN0KVxcXSQvLFxuXHRcdFx0dG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdG9TdHJpbmcuY2FsbCggb2JqICkgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9zZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNldFZhbHVlID0gZnVuY3Rpb24oIHR5cGVzLCBpc0FycmF5TGlrZSwgaXNPYmplY3QsIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gU2VjdGlvbiRzZXRWYWx1ZSggdmFsdWUgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciB3cmFwcGVyLCBmcmFnbWVudE9wdGlvbnM7XG5cdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdC8vIElmIGEgY2hpbGQgb2YgdGhpcyBzZWN0aW9uIGNhdXNlcyBhIHJlLWV2YWx1YXRpb24gLSBmb3IgZXhhbXBsZSwgYW5cblx0XHRcdFx0Ly8gZXhwcmVzc2lvbiByZWZlcnMgdG8gYSBmdW5jdGlvbiB0aGF0IG11dGF0ZXMgdGhlIGFycmF5IHRoYXQgdGhpc1xuXHRcdFx0XHQvLyBzZWN0aW9uIGRlcGVuZHMgb24gLSB3ZSdsbCBlbmQgdXAgd2l0aCBhIGRvdWJsZSByZW5kZXJpbmcgYnVnIChzZWVcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy83NDgpLiBUaGlzIHByZXZlbnRzIGl0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdC8vIHdpdGggc2VjdGlvbnMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBmYWtlIHZhbHVlIGlmIHdlIGhhdmUgYSB3cmFwcGVkIG9iamVjdFxuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYW55IGZyYWdtZW50cyBhcmUgYXdhaXRpbmcgY3JlYXRpb24gYWZ0ZXIgYSBzcGxpY2UsXG5cdFx0XHQvLyB0aGlzIGlzIHRoZSBwbGFjZSB0byBkbyBpdFxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCApIHtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzLnBFbGVtZW50LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdGluZGV4UmVmOiB0aGlzLnRlbXBsYXRlLmlcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5mb3JFYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdFx0dmFyIGZyYWdtZW50O1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gdGhpcyQwLmtleXBhdGggKyAnLicgKyBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0dGhpcyQwLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHRoaXMkMC5mcmFnbWVudHNbIGluZGV4IF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIHJlZXZhbHVhdGVTZWN0aW9uKCB0aGlzLCB2YWx1ZSApICkge1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZVNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlICkge1xuXHRcdFx0dmFyIGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHNlY3Rpb24udGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogc2VjdGlvbi5yb290LFxuXHRcdFx0XHRwRWxlbWVudDogc2VjdGlvbi5wYXJlbnRGcmFnbWVudC5wRWxlbWVudCxcblx0XHRcdFx0b3duZXI6IHNlY3Rpb25cblx0XHRcdH07XG5cdFx0XHQvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhlIHNlY3Rpb24gdHlwZSwgZ3JlYXRcblx0XHRcdC8vIFRPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkPyBpLmUuIHBpY2sgYW4gcmVldmFsdWF0ZVNlY3Rpb24gZnVuY3Rpb24gZHVyaW5nIGluaXRcblx0XHRcdC8vIGFuZCBhdm9pZCBkb2luZyB0aGlzIGVhY2ggdGltZT9cblx0XHRcdGlmICggc2VjdGlvbi5zdWJ0eXBlICkge1xuXHRcdFx0XHRzd2l0Y2ggKCBzZWN0aW9uLnN1YnR5cGUgKSB7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX0lGOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1VOTEVTUzpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgdHJ1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1dJVEg6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fSUZfV0lUSDpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9FQUNIOlxuXHRcdFx0XHRcdFx0aWYgKCBpc09iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3b3JrIG91dCB3aGF0IHNvcnQgb2Ygc2VjdGlvbiB3ZSdyZSBkZWFsaW5nIHdpdGhcblx0XHRcdHNlY3Rpb24ub3JkZXJlZCA9ICEhaXNBcnJheUxpa2UoIHZhbHVlICk7XG5cdFx0XHQvLyBPcmRlcmVkIGxpc3Qgc2VjdGlvblxuXHRcdFx0aWYgKCBzZWN0aW9uLm9yZGVyZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVub3JkZXJlZCBsaXN0LCBvciBjb250ZXh0XG5cdFx0XHRpZiAoIGlzT2JqZWN0KCB2YWx1ZSApIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gSW5kZXggcmVmZXJlbmNlIGluZGljYXRlcyBzZWN0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbGlzdFxuXHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBvYmplY3QgcHJvdmlkZXMgY29udGV4dCBmb3IgY29udGVudHNcblx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb25kaXRpb25hbCBzZWN0aW9uXG5cdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaSwgbGVuZ3RoLCBmcmFnbWVudDtcblx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdGlmICggbGVuZ3RoID09PSBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gTm90aGluZyB0byBkb1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIGl0IHdhcyBwcmV2aW91c2x5LCByZW1vdmUgaXRlbXNcblx0XHRcdGlmICggbGVuZ3RoIDwgc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggbGVuZ3RoLCBzZWN0aW9uLmxlbmd0aCAtIGxlbmd0aCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIGFkZCBhbnkgbmV3IG9uZXNcblx0XHRcdFx0XHRmb3IgKCBpID0gc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRcdC8vIGFwcGVuZCBsaXN0IGl0ZW0gdG8gY29udGV4dCBzdGFja1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBpO1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaTtcblx0XHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyBpIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBsZW5ndGg7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaWQsIGksIGhhc0tleSwgZnJhZ21lbnQsIGNoYW5nZWQ7XG5cdFx0XHRoYXNLZXkgPSBzZWN0aW9uLmhhc0tleSB8fCAoIHNlY3Rpb24uaGFzS2V5ID0ge30gKTtcblx0XHRcdC8vIHJlbW92ZSBhbnkgZnJhZ21lbnRzIHRoYXQgc2hvdWxkIG5vIGxvbmdlciBleGlzdFxuXHRcdFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBpIF07XG5cdFx0XHRcdGlmICggISggZnJhZ21lbnQuaW5kZXggaW4gdmFsdWUgKSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRoYXNLZXlbIGZyYWdtZW50LmluZGV4IF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGFueSB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldFxuXHRcdFx0Zm9yICggaWQgaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIWhhc0tleVsgaWQgXSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGlkO1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGlkO1xuXHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gc2VjdGlvbi50ZW1wbGF0ZS5pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0aGFzS2V5WyBpZCBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoIHNlY3Rpb24gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBmcmFnbWVudDtcblx0XHRcdC8vIC4uLnRoZW4gaWYgaXQgaXNuJ3QgcmVuZGVyZWQsIHJlbmRlciBpdCwgYWRkaW5nIHNlY3Rpb24ua2V5cGF0aCB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gKGlmIGl0IGlzIGFscmVhZHkgcmVuZGVyZWQsIHRoZW4gYW55IGNoaWxkcmVuIGRlcGVuZGVudCBvbiB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyB3aXRob3V0IGFueSBwcm9tcHRpbmcpXG5cdFx0XHRpZiAoICFzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gYXBwZW5kIHRoaXMgc2VjdGlvbiB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aDtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBpbnZlcnRlZCwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGRvUmVuZGVyLCBlbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgZnJhZ21lbnQsIG5hbWU7XG5cdFx0XHRlbXB0eUFycmF5ID0gaXNBcnJheUxpa2UoIHZhbHVlICkgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuXHRcdFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcblx0XHRcdGlmICggIWlzQXJyYXlMaWtlKCB2YWx1ZSApICYmIGlzT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRlbXB0eU9iamVjdCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gdmFsdWUgKSB7XG5cdFx0XHRcdFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbnZlcnRlZCApIHtcblx0XHRcdFx0ZG9SZW5kZXIgPSBlbXB0eUFycmF5IHx8IGVtcHR5T2JqZWN0IHx8ICF2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvUmVuZGVyID0gdmFsdWUgJiYgIWVtcHR5QXJyYXkgJiYgIWVtcHR5T2JqZWN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkb1JlbmRlciApIHtcblx0XHRcdFx0aWYgKCAhc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gbm8gY2hhbmdlIHRvIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHNlY3Rpb24ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDEgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKCBzZWN0aW9uICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyggc2VjdGlvbiApIHtcblx0XHRcdGlmICggc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggMCwgc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoICkuZmlsdGVyKCBpc1JlbmRlcmVkICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLmxlbmd0aCA9IDA7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1JlbmRlcmVkKCBmcmFnbWVudCApIHtcblx0XHRcdHJldHVybiBmcmFnbWVudC5yZW5kZXJlZDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgaXNBcnJheUxpa2UsIGlzT2JqZWN0LCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR0b1N0cmluZyA9IGZ1bmN0aW9uIFNlY3Rpb24kdG9TdHJpbmcoIGVzY2FwZSApIHtcblx0XHR2YXIgc3RyLCBpLCBsZW47XG5cdFx0c3RyID0gJyc7XG5cdFx0aSA9IDA7XG5cdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50c1sgaSBdLnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVuYmluZCA9IGZ1bmN0aW9uKCB1bmJpbmQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBTZWN0aW9uJHVuYmluZCgpIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIHVuYmluZEZyYWdtZW50ICk7XG5cdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy51bmJvdW5kID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kRnJhZ21lbnQoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBTZWN0aW9uJHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggc2hvdWxkRGVzdHJveSA/IHVucmVuZGVyQW5kRGVzdHJveSA6IHVucmVuZGVyICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVucmVuZGVyQW5kRGVzdHJveSggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggdHJ1ZSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVucmVuZGVyKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCBmYWxzZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVwZGF0ZSA9IGZ1bmN0aW9uIFNlY3Rpb24kdXBkYXRlKCkge1xuXHRcdHZhciBmcmFnbWVudCwgcmVuZGVySW5kZXgsIHJlbmRlcmVkRnJhZ21lbnRzLCBhbmNob3IsIHRhcmdldCwgaSwgbGVuO1xuXHRcdC8vIGB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzYCBpcyBpbiB0aGUgb3JkZXIgb2YgdGhlIHByZXZpb3VzIHJlbmRlci5cblx0XHQvLyBJZiBmcmFnbWVudHMgaGF2ZSBzaHVmZmxlZCBhYm91dCwgdGhpcyBhbGxvd3MgdXMgdG8gcXVpY2tseVxuXHRcdC8vIHJlaW5zZXJ0IHRoZW0gaW4gdGhlIGNvcnJlY3QgcGxhY2Vcblx0XHRyZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMucmVuZGVyZWRGcmFnbWVudHM7XG5cdFx0Ly8gUmVtb3ZlIGZyYWdtZW50cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgZm9yIGRlc3RydWN0aW9uXG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wb3AoKSApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCB0cnVlICk7XG5cdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoIHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50ICksIDEgKTtcblx0XHR9XG5cdFx0Ly8gUmVuZGVyIG5ldyBmcmFnbWVudHMgKGJ1dCBkb24ndCBpbnNlcnQgdGhlbSB5ZXQpXG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuc2hpZnQoKSApIHtcblx0XHRcdGZyYWdtZW50LnJlbmRlcigpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblx0XHR9XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzWyBpIF07XG5cdFx0XHRyZW5kZXJJbmRleCA9IHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50LCBpICk7XG5cdFx0XHQvLyBzZWFyY2ggZnJvbSBjdXJyZW50IGluZGV4IC0gaXQncyBndWFyYW50ZWVkIHRvIGJlIHRoZSBzYW1lIG9yIGhpZ2hlclxuXHRcdFx0aWYgKCByZW5kZXJJbmRleCA9PT0gaSApIHtcblx0XHRcdFx0Ly8gYWxyZWFkeSBpbiB0aGUgcmlnaHQgcGxhY2UuIGluc2VydCBhY2N1bXVsYXRlZCBub2RlcyAoaWYgYW55KSBhbmQgY2Fycnkgb25cblx0XHRcdFx0aWYgKCB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0YW5jaG9yID0gZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBhbmNob3IgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggZnJhZ21lbnQuZGV0YWNoKCkgKTtcblx0XHRcdC8vIHVwZGF0ZSByZW5kZXJlZEZyYWdtZW50c1xuXHRcdFx0aWYgKCByZW5kZXJJbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZSggcmVuZGVySW5kZXgsIDEgKTtcblx0XHRcdH1cblx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZSggaSwgMCwgZnJhZ21lbnQgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIGFuY2hvciApO1xuXHRcdH1cblx0XHQvLyBTYXZlIHRoZSByZW5kZXJpbmcgb3JkZXIgZm9yIG5leHQgdGltZVxuXHRcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cy5zbGljZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9fU2VjdGlvbi5qcyAqL1xuXHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCB0eXBlcywgTXVzdGFjaGUsIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIHNodWZmbGUsIHJlbmRlciwgc2V0VmFsdWUsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdHRoaXMuc3VidHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcblx0XHRcdHRoaXMuaW52ZXJ0ZWQgPSB0aGlzLnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fVU5MRVNTO1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZSA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1VucmVuZGVyID0gW107XG5cdFx0XHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gW107XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdFx0XHQvLyBudW1iZXIgb2YgdGltZXMgdGhpcyBzZWN0aW9uIGlzIHJlbmRlcmVkXG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRTZWN0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXHRcdFx0c2h1ZmZsZTogc2h1ZmZsZSxcblx0XHRcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0c2V0VmFsdWU6IHNldFZhbHVlLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIFNlY3Rpb247XG5cdH0oIHR5cGVzLCBNdXN0YWNoZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmQsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZE5leHROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2h1ZmZsZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNldFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bnJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVwZGF0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGRldGFjaCA9IGZ1bmN0aW9uIFRyaXBsZSRkZXRhY2goKSB7XG5cdFx0dmFyIGxlbiwgaTtcblx0XHRpZiAoIHRoaXMuZG9jRnJhZyApIHtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKCB0aGlzLm5vZGVzWyBpIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlSZXN1bHQ7XG5cdFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm5vZGVzWyBpIF07XG5cdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hdGNoZXMoIG5vZGUsIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBxdWVyeVJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3Rvciggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZEFsbCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnlSZXN1bHQgKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeUFsbFJlc3VsdCwgbnVtTm9kZXMsIGo7XG5cdFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm5vZGVzWyBpIF07XG5cdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hdGNoZXMoIG5vZGUsIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0cXVlcnlSZXN1bHQucHVzaCggbm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcXVlcnlBbGxSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0bnVtTm9kZXMgPSBxdWVyeUFsbFJlc3VsdC5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBudW1Ob2RlczsgaiArPSAxICkge1xuXHRcdFx0XHRcdFx0cXVlcnlSZXN1bHQucHVzaCggcXVlcnlBbGxSZXN1bHRbIGogXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaXJzdE5vZGUgPSBmdW5jdGlvbiBUcmlwbGUkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiB0aGlzLm5vZGVzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2Rlc1sgMCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9oZWxwZXJzL2luc2VydEh0bWwuanMgKi9cblx0dmFyIGluc2VydEh0bWwgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZWxlbWVudENhY2hlID0ge30sXG5cdFx0XHRpZUJ1ZywgaWVCbGFja2xpc3Q7XG5cdFx0dHJ5IHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQoICd0YWJsZScgKS5pbm5lckhUTUwgPSAnZm9vJztcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0aWVCdWcgPSB0cnVlO1xuXHRcdFx0aWVCbGFja2xpc3QgPSB7XG5cdFx0XHRcdFRBQkxFOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VEhFQUQ6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0aGVhZCBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3RoZWFkPjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUQk9EWTogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRib2R5IGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdGJvZHk+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRSOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dHIgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90cj48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0U0VMRUNUOiBbXG5cdFx0XHRcdFx0JzxzZWxlY3QgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC9zZWxlY3Q+J1xuXHRcdFx0XHRdXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBodG1sLCBub2RlLCBkb2NGcmFnICkge1xuXHRcdFx0dmFyIGNvbnRhaW5lciwgbm9kZXMgPSBbXSxcblx0XHRcdFx0d3JhcHBlciwgc2VsZWN0ZWRPcHRpb24sIGNoaWxkLCBpO1xuXHRcdFx0Ly8gcmVuZGVyIDAgYW5kIGZhbHNlXG5cdFx0XHRpZiAoIGh0bWwgIT0gbnVsbCAmJiBodG1sICE9PSAnJyApIHtcblx0XHRcdFx0aWYgKCBpZUJ1ZyAmJiAoIHdyYXBwZXIgPSBpZUJsYWNrbGlzdFsgbm9kZS50YWdOYW1lIF0gKSApIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KCAnRElWJyApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSB3cmFwcGVyWyAwIF0gKyBodG1sICsgd3JhcHBlclsgMSBdO1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCAnLngnICk7XG5cdFx0XHRcdFx0aWYgKCBjb250YWluZXIudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zWyBjb250YWluZXIuc2VsZWN0ZWRJbmRleCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnICkge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoICdESVYnICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnIGNsYXNzPVwieFwiPicgKyBodG1sICsgJzwvc3ZnPic7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoICcueCcgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KCBub2RlLnRhZ05hbWUgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcblx0XHRcdFx0XHRpZiAoIGNvbnRhaW5lci50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbIGNvbnRhaW5lci5zZWxlY3RlZEluZGV4IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZCApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGNoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVGhpcyBpcyByZWFsbHkgYW5ub3lpbmcuIEV4dHJhY3RpbmcgPG9wdGlvbj4gbm9kZXMgZnJvbSB0aGVcblx0XHRcdFx0Ly8gdGVtcG9yYXJ5IGNvbnRhaW5lciA8c2VsZWN0PiBjYXVzZXMgdGhlIHJlbWFpbmluZyBvbmVzIHRvXG5cdFx0XHRcdC8vIGJlY29tZSBzZWxlY3RlZC4gU28gbm93IHdlIGhhdmUgdG8gZGVzZWxlY3QgdGhlbS4gSUU4LCB5b3Vcblx0XHRcdFx0Ly8gYW1hemUgbWUuIFlvdSByZWFsbHkgZG9cblx0XHRcdFx0Ly8gLi4uYW5kIG5vdyBDaHJvbWUgdG9vXG5cdFx0XHRcdGlmICggbm9kZS50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcblx0XHRcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCBub2Rlc1sgaSBdICE9PSBzZWxlY3RlZE9wdGlvbiApIHtcblx0XHRcdFx0XHRcdFx0bm9kZXNbIGkgXS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGVzO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBlbGVtZW50KCB0YWdOYW1lICkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRDYWNoZVsgdGFnTmFtZSBdIHx8ICggZWxlbWVudENhY2hlWyB0YWdOYW1lIF0gPSBjcmVhdGVFbGVtZW50KCB0YWdOYW1lICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50ICk7XG5cblx0LyogdXRpbHMvdG9BcnJheS5qcyAqL1xuXHR2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoIGFycmF5TGlrZSApIHtcblx0XHR2YXIgYXJyYXkgPSBbXSxcblx0XHRcdGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YXJyYXlbIGkgXSA9IGFycmF5TGlrZVsgaSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvaGVscGVycy91cGRhdGVTZWxlY3QuanMgKi9cblx0dmFyIHVwZGF0ZVNlbGVjdCA9IGZ1bmN0aW9uKCB0b0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gdXBkYXRlU2VsZWN0KCBwYXJlbnRFbGVtZW50ICkge1xuXHRcdFx0dmFyIHNlbGVjdGVkT3B0aW9ucywgb3B0aW9uLCB2YWx1ZTtcblx0XHRcdGlmICggIXBhcmVudEVsZW1lbnQgfHwgcGFyZW50RWxlbWVudC5uYW1lICE9PSAnc2VsZWN0JyB8fCAhcGFyZW50RWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxlY3RlZE9wdGlvbnMgPSB0b0FycmF5KCBwYXJlbnRFbGVtZW50Lm5vZGUub3B0aW9ucyApLmZpbHRlciggaXNTZWxlY3RlZCApO1xuXHRcdFx0Ly8gSWYgb25lIG9mIHRoZW0gaGFkIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIHdlIG5lZWQgdG8gc3luY1xuXHRcdFx0Ly8gdGhlIG1vZGVsIHRvIHRoZSB2aWV3XG5cdFx0XHRpZiAoIHBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gc2VsZWN0ZWRPcHRpb25zLm1hcCggZnVuY3Rpb24oIG8gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG8udmFsdWU7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbiA9IHNlbGVjdGVkT3B0aW9uc1sgMCBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbi52YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cGFyZW50RWxlbWVudC5iaW5kaW5nLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0cGFyZW50RWxlbWVudC5idWJibGUoKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTZWxlY3RlZCggb3B0aW9uICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbi5zZWxlY3RlZDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0b0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkcmVuZGVyID0gZnVuY3Rpb24oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkcmVuZGVyKCkge1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gcmVuZGVyIGFuIGl0ZW0gdGhhdCB3YXMgYWxyZWFkeSByZW5kZXJlZCcgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKCB0aGlzLnZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSwgdGhpcy5kb2NGcmFnICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cblx0XHRcdHVwZGF0ZVNlbGVjdCggdGhpcy5wRWxlbWVudCApO1xuXHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuXHRcdH07XG5cdH0oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9zZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkc2V0VmFsdWUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkc2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdFx0dmFyIHdyYXBwZXI7XG5cdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR0b1N0cmluZyA9IGZ1bmN0aW9uKCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSR0b1N0cmluZygpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoICcnICsgdGhpcy52YWx1ZSApIDogJyc7XG5cdFx0fTtcblx0fSggZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdW5yZW5kZXIgPSBmdW5jdGlvbiggZGV0YWNoTm9kZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKCBkZXRhY2hOb2RlICk7XG5cdFx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBkZXRhY2hOb2RlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlID0gZnVuY3Rpb24oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5vZGUsIHBhcmVudE5vZGU7XG5cdFx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXhpc3Rpbmcgbm9kZXNcblx0XHRcdHdoaWxlICggdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXMucG9wKCk7XG5cdFx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW5zZXJ0IG5ldyBub2Rlc1xuXHRcdFx0cGFyZW50Tm9kZSA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXHRcdFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwoIHRoaXMudmFsdWUsIHBhcmVudE5vZGUsIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKSApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9fVHJpcGxlLmpzICovXG5cdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggdHlwZXMsIE11c3RhY2hlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpcnN0Tm9kZSwgcmVuZGVyLCBzZXRWYWx1ZSwgdG9TdHJpbmcsIHVucmVuZGVyLCB1cGRhdGUsIHVuYmluZCApIHtcblxuXHRcdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdFRyaXBsZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBzZXRWYWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBUcmlwbGU7XG5cdH0oIHR5cGVzLCBNdXN0YWNoZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkc2V0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1bnJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlLCB1bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRkZXRhY2ggPSBmdW5jdGlvbiBFbGVtZW50JGRldGFjaCgpIHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdHBhcmVudE5vZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Ly8gbmVlZCB0byBjaGVjayBmb3IgcGFyZW50IG5vZGUgLSBET00gbWF5IGhhdmUgYmVlbiBhbHRlcmVkXG5cdFx0XHQvLyBieSBzb21ldGhpbmcgb3RoZXIgdGhhbiBSYWN0aXZlISBlLmcuIGpRdWVyeSBVSS4uLlxuXHRcdFx0aWYgKCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdGlmICggbWF0Y2hlcyggdGhpcy5ub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmluZCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0Ly8gQWRkIHRoaXMgbm9kZSB0byB0aGUgcXVlcnksIGlmIGFwcGxpY2FibGUsIGFuZCByZWdpc3RlciB0aGVcblx0XHQvLyBxdWVyeSBvbiB0aGlzIGVsZW1lbnRcblx0XHRpZiAoIHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICkgJiYgcXVlcnkubGl2ZSApIHtcblx0XHRcdCggdGhpcy5saXZlUXVlcmllcyB8fCAoIHRoaXMubGl2ZVF1ZXJpZXMgPSBbXSApICkucHVzaCggcXVlcnkgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZmluZE5leHROb2RlKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gRWxlbWVudCRmaXJzdE5vZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2dldEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZ2V0QXR0cmlidXRlKCBuYW1lICkge1xuXHRcdGlmICggIXRoaXMuYXR0cmlidXRlcyB8fCAhdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXS52YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc2hhcmVkL2VuZm9yY2VDYXNlLmpzICovXG5cdHZhciBlbmZvcmNlQ2FzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzLCBjcmVhdGVNYXAsIG1hcDtcblx0XHRzdmdDYW1lbENhc2VFbGVtZW50cyA9ICdhbHRHbHlwaCBhbHRHbHlwaERlZiBhbHRHbHlwaEl0ZW0gYW5pbWF0ZUNvbG9yIGFuaW1hdGVNb3Rpb24gYW5pbWF0ZVRyYW5zZm9ybSBjbGlwUGF0aCBmZUJsZW5kIGZlQ29sb3JNYXRyaXggZmVDb21wb25lbnRUcmFuc2ZlciBmZUNvbXBvc2l0ZSBmZUNvbnZvbHZlTWF0cml4IGZlRGlmZnVzZUxpZ2h0aW5nIGZlRGlzcGxhY2VtZW50TWFwIGZlRGlzdGFudExpZ2h0IGZlRmxvb2QgZmVGdW5jQSBmZUZ1bmNCIGZlRnVuY0cgZmVGdW5jUiBmZUdhdXNzaWFuQmx1ciBmZUltYWdlIGZlTWVyZ2UgZmVNZXJnZU5vZGUgZmVNb3JwaG9sb2d5IGZlT2Zmc2V0IGZlUG9pbnRMaWdodCBmZVNwZWN1bGFyTGlnaHRpbmcgZmVTcG90TGlnaHQgZmVUaWxlIGZlVHVyYnVsZW5jZSBmb3JlaWduT2JqZWN0IGdseXBoUmVmIGxpbmVhckdyYWRpZW50IHJhZGlhbEdyYWRpZW50IHRleHRQYXRoIHZrZXJuJy5zcGxpdCggJyAnICk7XG5cdFx0c3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyA9ICdhdHRyaWJ1dGVOYW1lIGF0dHJpYnV0ZVR5cGUgYmFzZUZyZXF1ZW5jeSBiYXNlUHJvZmlsZSBjYWxjTW9kZSBjbGlwUGF0aFVuaXRzIGNvbnRlbnRTY3JpcHRUeXBlIGNvbnRlbnRTdHlsZVR5cGUgZGlmZnVzZUNvbnN0YW50IGVkZ2VNb2RlIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGdseXBoUmVmIGdyYWRpZW50VHJhbnNmb3JtIGdyYWRpZW50VW5pdHMga2VybmVsTWF0cml4IGtlcm5lbFVuaXRMZW5ndGgga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxpbWl0aW5nQ29uZUFuZ2xlIG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrQ29udGVudFVuaXRzIG1hc2tVbml0cyBudW1PY3RhdmVzIHBhdGhMZW5ndGggcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVHJhbnNmb3JtIHBhdHRlcm5Vbml0cyBwb2ludHNBdFggcG9pbnRzQXRZIHBvaW50c0F0WiBwcmVzZXJ2ZUFscGhhIHByZXNlcnZlQXNwZWN0UmF0aW8gcHJpbWl0aXZlVW5pdHMgcmVmWCByZWZZIHJlcGVhdENvdW50IHJlcGVhdER1ciByZXF1aXJlZEV4dGVuc2lvbnMgcmVxdWlyZWRGZWF0dXJlcyBzcGVjdWxhckNvbnN0YW50IHNwZWN1bGFyRXhwb25lbnQgc3ByZWFkTWV0aG9kIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdGl0Y2hUaWxlcyBzdXJmYWNlU2NhbGUgc3lzdGVtTGFuZ3VhZ2UgdGFibGVWYWx1ZXMgdGFyZ2V0WCB0YXJnZXRZIHRleHRMZW5ndGggdmlld0JveCB2aWV3VGFyZ2V0IHhDaGFubmVsU2VsZWN0b3IgeUNoYW5uZWxTZWxlY3RvciB6b29tQW5kUGFuJy5zcGxpdCggJyAnICk7XG5cdFx0Y3JlYXRlTWFwID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdFx0dmFyIG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG1hcFsgaXRlbXNbIGkgXS50b0xvd2VyQ2FzZSgpIF0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcDtcblx0XHR9O1xuXHRcdG1hcCA9IGNyZWF0ZU1hcCggc3ZnQ2FtZWxDYXNlRWxlbWVudHMuY29uY2F0KCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzICkgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnROYW1lICkge1xuXHRcdFx0dmFyIGxvd2VyQ2FzZUVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBtYXBbIGxvd2VyQ2FzZUVsZW1lbnROYW1lIF0gfHwgbG93ZXJDYXNlRWxlbWVudE5hbWU7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNFcXVhbCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkYnViYmxlKCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0Ly8gVE9ETyB0aGlzIGNhbiByZWdpc3RlciB0aGUgYXR0cmlidXRlIG11bHRpcGxlIHRpbWVzIChzZWUgcmVuZGVyIHRlc3Rcblx0XHRcdC8vICdBdHRyaWJ1dGUgd2l0aCBuZXN0ZWQgbXVzdGFjaGVzJylcblx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdC8vIE5lZWQgdG8gY2xlYXIgb2xkIGlkIGZyb20gcmFjdGl2ZS5ub2Rlc1xuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lkJyAmJiB0aGlzLnZhbHVlICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbIHRoaXMudmFsdWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGlmICggdGhpcy5uYW1lID09PSAndmFsdWUnICYmIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIHN0b3JlIHRoZSB2YWx1ZSBvbiB0aGUgRE9NIGxpa2UgdGhpcyBzbyB3ZVxuXHRcdFx0XHRcdC8vIGNhbiByZXRyaWV2ZSBpdCBsYXRlciB3aXRob3V0IGl0IGJlaW5nIGNvZXJjZWQgdG8gYSBzdHJpbmdcblx0XHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wLCBpc0VxdWFsICk7XG5cblx0LyogY29uZmlnL2Jvb2xlYW5BdHRyaWJ1dGVzLmpzICovXG5cdHZhciBib29sZWFuQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9odG1sLW1pbmlmaWVyL2lzc3Vlcy82MyNpc3N1ZWNvbW1lbnQtMzc3NjMzMTZcblx0XHR2YXIgYm9vbGVhbkF0dHJpYnV0ZXMgPSAvXihhbGxvd0Z1bGxzY3JlZW58YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNoZWNrZWR8Y29tcGFjdHxjb250cm9sc3xkZWNsYXJlfGRlZmF1bHR8ZGVmYXVsdENoZWNrZWR8ZGVmYXVsdE11dGVkfGRlZmF1bHRTZWxlY3RlZHxkZWZlcnxkaXNhYmxlZHxkcmFnZ2FibGV8ZW5hYmxlZHxmb3JtTm9WYWxpZGF0ZXxoaWRkZW58aW5kZXRlcm1pbmF0ZXxpbmVydHxpc01hcHxpdGVtU2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxub0hyZWZ8bm9SZXNpemV8bm9TaGFkZXxub1ZhbGlkYXRlfG5vV3JhcHxvcGVufHBhdXNlT25FeGl0fHJlYWRPbmx5fHJlcXVpcmVkfHJldmVyc2VkfHNjb3BlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cmFuc2xhdGV8dHJ1ZVNwZWVkfHR5cGVNdXN0TWF0Y2h8dmlzaWJsZSkkL2k7XG5cdFx0cmV0dXJuIGJvb2xlYW5BdHRyaWJ1dGVzO1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9oZWxwZXJzL2RldGVybWluZU5hbWVBbmROYW1lc3BhY2UuanMgKi9cblx0dmFyIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgZW5mb3JjZUNhc2UgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgbmFtZSApIHtcblx0XHRcdHZhciBjb2xvbkluZGV4LCBuYW1lc3BhY2VQcmVmaXg7XG5cdFx0XHQvLyBhcmUgd2UgZGVhbGluZyB3aXRoIGEgbmFtZXNwYWNlZCBhdHRyaWJ1dGUsIGUuZy4geGxpbms6aHJlZj9cblx0XHRcdGNvbG9uSW5kZXggPSBuYW1lLmluZGV4T2YoICc6JyApO1xuXHRcdFx0aWYgKCBjb2xvbkluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gbG9va3MgbGlrZSB3ZSBhcmUsIHllcy4uLlxuXHRcdFx0XHRuYW1lc3BhY2VQcmVmaXggPSBuYW1lLnN1YnN0ciggMCwgY29sb25JbmRleCApO1xuXHRcdFx0XHQvLyAuLi51bmxlc3MgaXQncyBhIG5hbWVzcGFjZSAqZGVjbGFyYXRpb24qLCB3aGljaCB3ZSBpZ25vcmUgKG9uIHRoZSBhc3N1bXB0aW9uXG5cdFx0XHRcdC8vIHRoYXQgb25seSB2YWxpZCBuYW1lc3BhY2VzIHdpbGwgYmUgdXNlZClcblx0XHRcdFx0aWYgKCBuYW1lc3BhY2VQcmVmaXggIT09ICd4bWxucycgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUuc3Vic3RyaW5nKCBjb2xvbkluZGV4ICsgMSApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gZW5mb3JjZUNhc2UoIG5hbWUgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlID0gbmFtZXNwYWNlc1sgbmFtZXNwYWNlUHJlZml4LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlUHJlZml4ID0gbmFtZXNwYWNlUHJlZml4O1xuXHRcdFx0XHRcdGlmICggIWF0dHJpYnV0ZS5uYW1lc3BhY2UgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnVW5rbm93biBuYW1lc3BhY2UgKFwiJyArIG5hbWVzcGFjZVByZWZpeCArICdcIiknO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFNWRyBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Ugc2Vuc2l0aXZlXG5cdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5lbGVtZW50Lm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlcy5odG1sID8gZW5mb3JjZUNhc2UoIG5hbWUgKSA6IG5hbWU7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgZW5mb3JjZUNhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZ2V0SW50ZXJwb2xhdG9yLmpzICovXG5cdHZhciBnZXRJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBhdHRyaWJ1dGUuZnJhZ21lbnQuaXRlbXM7XG5cdFx0XHRpZiAoIGl0ZW1zLmxlbmd0aCAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpdGVtc1sgMCBdLnR5cGUgPT09IHR5cGVzLklOVEVSUE9MQVRPUiApIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW1zWyAwIF07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZGV0ZXJtaW5lUHJvcGVydHlOYW1lLmpzICovXG5cdHZhciBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgcHJvcGVydHlOYW1lcyA9IHtcblx0XHRcdCdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0Jyxcblx0XHRcdGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG5cdFx0XHRiZ2NvbG9yOiAnYmdDb2xvcicsXG5cdFx0XHQnY2xhc3MnOiAnY2xhc3NOYW1lJyxcblx0XHRcdGNvZGViYXNlOiAnY29kZUJhc2UnLFxuXHRcdFx0Y29sc3BhbjogJ2NvbFNwYW4nLFxuXHRcdFx0Y29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcblx0XHRcdGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuXHRcdFx0ZGlybmFtZTogJ2Rpck5hbWUnLFxuXHRcdFx0J2Zvcic6ICdodG1sRm9yJyxcblx0XHRcdCdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG5cdFx0XHRpc21hcDogJ2lzTWFwJyxcblx0XHRcdG1heGxlbmd0aDogJ21heExlbmd0aCcsXG5cdFx0XHRub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG5cdFx0XHRwdWJkYXRlOiAncHViRGF0ZScsXG5cdFx0XHRyZWFkb25seTogJ3JlYWRPbmx5Jyxcblx0XHRcdHJvd3NwYW46ICdyb3dTcGFuJyxcblx0XHRcdHRhYmluZGV4OiAndGFiSW5kZXgnLFxuXHRcdFx0dXNlbWFwOiAndXNlTWFwJ1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcHJvcGVydHlOYW1lO1xuXHRcdFx0aWYgKCBhdHRyaWJ1dGUucE5vZGUgJiYgIWF0dHJpYnV0ZS5uYW1lc3BhY2UgJiYgKCAhb3B0aW9ucy5wTm9kZS5uYW1lc3BhY2VVUkkgfHwgb3B0aW9ucy5wTm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApICkge1xuXHRcdFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzWyBhdHRyaWJ1dGUubmFtZSBdIHx8IGF0dHJpYnV0ZS5uYW1lO1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMucE5vZGVbIHByb3BlcnR5TmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cblx0XHRcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcblx0XHRcdFx0aWYgKCBib29sZWFuQXR0cmlidXRlcy50ZXN0KCBwcm9wZXJ0eU5hbWUgKSB8fCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCBib29sZWFuQXR0cmlidXRlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQVRUUklCVVRFO1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0ZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSggdGhpcywgb3B0aW9ucy5uYW1lICk7XG5cdFx0XHQvLyBpZiBpdCdzIGFuIGVtcHR5IGF0dHJpYnV0ZSwgb3IganVzdCBhIHN0cmFpZ2h0IGtleS12YWx1ZSBwYWlyLCB3aXRoIG5vXG5cdFx0XHQvLyBtdXN0YWNoZSBzaGVuYW5pZ2Fucywgc2V0IHRoZSBhdHRyaWJ1dGUgYWNjb3JkaW5nbHkgYW5kIGdvIGhvbWVcblx0XHRcdGlmICggIW9wdGlvbnMudmFsdWUgfHwgdHlwZW9mIG9wdGlvbnMudmFsdWUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggdGhpcy5uYW1lICkgPyB0cnVlIDogb3B0aW9ucy52YWx1ZSB8fCAnJztcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZG8gc29tZSB3b3JrXG5cdFx0XHQvLyBzaGFyZSBwYXJlbnRGcmFnbWVudCB3aXRoIHBhcmVudCBlbGVtZW50XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHR0ZW1wbGF0ZTogb3B0aW9ucy52YWx1ZSxcblx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoaXMgYXR0cmlidXRlJ3MgaW50ZXJwb2xhdG9yLCBpZiBpdHMgZnJhZ21lbnRcblx0XHRcdC8vIHRha2VzIHRoZSBmb3JtIGB7e2Zvb319YC4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIHR3by13YXkgYmluZGluZyBhbmRcblx0XHRcdC8vIGZvciBjb3JyZWN0bHkgcmVuZGVyaW5nIEhUTUwgbGF0ZXJcblx0XHRcdHRoaXMuaW50ZXJwb2xhdG9yID0gZ2V0SW50ZXJwb2xhdG9yKCB0aGlzICk7XG5cdFx0XHR0aGlzLmlzQmluZGFibGUgPSAhIXRoaXMuaW50ZXJwb2xhdG9yICYmICF0aGlzLmludGVycG9sYXRvci5pc1N0YXRpYztcblx0XHRcdC8vIGNhbiB3ZSBlc3RhYmxpc2ggdGhpcyBhdHRyaWJ1dGUncyBwcm9wZXJ0eSBuYW1lIGVxdWl2YWxlbnQ/XG5cdFx0XHRkZXRlcm1pbmVQcm9wZXJ0eU5hbWUoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRcdC8vIG1hcmsgYXMgcmVhZHlcblx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBib29sZWFuQXR0cmlidXRlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlYmluZCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZW5kZXIgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgcHJvcGVydHlOYW1lcyA9IHtcblx0XHRcdCdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0Jyxcblx0XHRcdCdhY2Nlc3NrZXknOiAnYWNjZXNzS2V5Jyxcblx0XHRcdCdiZ2NvbG9yJzogJ2JnQ29sb3InLFxuXHRcdFx0J2NsYXNzJzogJ2NsYXNzTmFtZScsXG5cdFx0XHQnY29kZWJhc2UnOiAnY29kZUJhc2UnLFxuXHRcdFx0J2NvbHNwYW4nOiAnY29sU3BhbicsXG5cdFx0XHQnY29udGVudGVkaXRhYmxlJzogJ2NvbnRlbnRFZGl0YWJsZScsXG5cdFx0XHQnZGF0ZXRpbWUnOiAnZGF0ZVRpbWUnLFxuXHRcdFx0J2Rpcm5hbWUnOiAnZGlyTmFtZScsXG5cdFx0XHQnZm9yJzogJ2h0bWxGb3InLFxuXHRcdFx0J2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2Jyxcblx0XHRcdCdpc21hcCc6ICdpc01hcCcsXG5cdFx0XHQnbWF4bGVuZ3RoJzogJ21heExlbmd0aCcsXG5cdFx0XHQnbm92YWxpZGF0ZSc6ICdub1ZhbGlkYXRlJyxcblx0XHRcdCdwdWJkYXRlJzogJ3B1YkRhdGUnLFxuXHRcdFx0J3JlYWRvbmx5JzogJ3JlYWRPbmx5Jyxcblx0XHRcdCdyb3dzcGFuJzogJ3Jvd1NwYW4nLFxuXHRcdFx0J3RhYmluZGV4JzogJ3RhYkluZGV4Jyxcblx0XHRcdCd1c2VtYXAnOiAndXNlTWFwJ1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZW5kZXIoIG5vZGUgKSB7XG5cdFx0XHR2YXIgcHJvcGVydHlOYW1lO1xuXHRcdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHRcdC8vIHNob3VsZCB3ZSB1c2UgZGlyZWN0IHByb3BlcnR5IGFjY2Vzcywgb3Igc2V0QXR0cmlidXRlP1xuXHRcdFx0aWYgKCAhbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApIHtcblx0XHRcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1sgdGhpcy5uYW1lIF0gfHwgdGhpcy5uYW1lO1xuXHRcdFx0XHRpZiAoIG5vZGVbIHByb3BlcnR5TmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaXMgYXR0cmlidXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUgb3IgJ3ZhbHVlJz8gSWYgc28gd2UncmUgYmV0dGVyIG9mZiBkb2luZyBlLmcuXG5cdFx0XHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG5cdFx0XHRcdGlmICggYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggcHJvcGVydHlOYW1lICkgfHwgcHJvcGVydHlOYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdHRoaXMudXNlUHJvcGVydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcHJvcGVydHlOYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdHRoaXMudXNlUHJvcGVydHkgPSB0cnVlO1xuXHRcdFx0XHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR0b1N0cmluZyA9IGZ1bmN0aW9uKCBib29sZWFuQXR0cmlidXRlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR0b1N0cmluZygpIHtcblx0XHRcdHZhciBuYW1lID0gKCBmcmFnbWVudCA9IHRoaXMgKS5uYW1lLFxuXHRcdFx0XHRuYW1lc3BhY2VQcmVmaXggPSBmcmFnbWVudC5uYW1lc3BhY2VQcmVmaXgsXG5cdFx0XHRcdHZhbHVlID0gZnJhZ21lbnQudmFsdWUsXG5cdFx0XHRcdGludGVycG9sYXRvciA9IGZyYWdtZW50LmludGVycG9sYXRvcixcblx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5mcmFnbWVudDtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdCBhbmQgdGV4dGFyZWEgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuXHRcdFx0aWYgKCBuYW1lID09PSAndmFsdWUnICYmICggdGhpcy5lbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnIHx8IHRoaXMuZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnQgZWRpdGFibGVcblx0XHRcdGlmICggbmFtZSA9PT0gJ3ZhbHVlJyAmJiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWVzXG5cdFx0XHRpZiAoIG5hbWUgPT09ICduYW1lJyAmJiB0aGlzLmVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyAmJiBpbnRlcnBvbGF0b3IgKSB7XG5cdFx0XHRcdHJldHVybiAnbmFtZT17eycgKyAoIGludGVycG9sYXRvci5rZXlwYXRoIHx8IGludGVycG9sYXRvci5yZWYgKSArICd9fSc7XG5cdFx0XHR9XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXNcblx0XHRcdGlmICggYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyBuYW1lIDogJyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGZyYWdtZW50ICkge1xuXHRcdFx0XHR2YWx1ZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5hbWVzcGFjZVByZWZpeCApIHtcblx0XHRcdFx0bmFtZSA9IG5hbWVzcGFjZVByZWZpeCArICc6JyArIG5hbWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgPyBuYW1lICsgJz1cIicgKyBlc2NhcGUoIHZhbHVlICkgKyAnXCInIDogbmFtZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZXNjYXBlKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvJi9nLCAnJmFtcDsnICkucmVwbGFjZSggL1wiL2csICcmcXVvdDsnICkucmVwbGFjZSggLycvZywgJyYjMzk7JyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGJvb2xlYW5BdHRyaWJ1dGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVuYmluZCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1bmJpbmQoKSB7XG5cdFx0Ly8gaWdub3JlIG5vbi1keW5hbWljIGF0dHJpYnV0ZXNcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lkJyApIHtcblx0XHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbIHRoaXMudmFsdWUgXTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVNlbGVjdFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3QoKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdG9wdGlvbnMsIG9wdGlvbiwgb3B0aW9uVmFsdWUsIGk7XG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0Ly8gZG91YmxlIGVxdWFscyBhcyB3ZSBtYXkgYmUgY29tcGFyaW5nIG51bWJlcnMgd2l0aCBzdHJpbmdzXG5cdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiB1dGlscy9hcnJheUNvbnRhaW5zLmpzICovXG5cdHZhciBhcnJheUNvbnRhaW5zID0gZnVuY3Rpb24gYXJyYXlDb250YWlucyggYXJyYXksIHZhbHVlICkge1xuXHRcdGZvciAoIHZhciBpID0gMCwgYyA9IGFycmF5Lmxlbmd0aDsgaSA8IGM7IGkrKyApIHtcblx0XHRcdGlmICggYXJyYXlbIGkgXSA9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uKCBhcnJheUNvbnRhaW5zLCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdCgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG5cdFx0XHRcdG9wdGlvbnMsIGksIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRpZiAoICFpc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IFsgdmFsdWUgXTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IGFycmF5Q29udGFpbnMoIHZhbHVlLCBvcHRpb25WYWx1ZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGFycmF5Q29udGFpbnMsIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlUmFkaW9OYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lKCkge1xuXHRcdHZhciBub2RlID0gKCB2YWx1ZSA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZTtcblx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSBub2RlLl9yYWN0aXZlLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVSYWRpb1ZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWUoKSB7XG5cdFx0XHR2YXIgd2FzQ2hlY2tlZCwgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0YmluZGluZywgYmluZGluZ3MsIGk7XG5cdFx0XHR3YXNDaGVja2VkID0gbm9kZS5jaGVja2VkO1xuXHRcdFx0bm9kZS52YWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSA9PT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cdFx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gaWYgdGhlIGlucHV0IHdhcyBjaGVja2VkLCBhbmQgdGhlIHZhbHVlXG5cdFx0XHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBvdXQgb2YgZGF0ZS4gVG8gZml4IGl0IHdlIGhhdmUgdG8ganVtcCB0aHJvdWdoIHNvbWVcblx0XHRcdC8vIGhvb3BzLi4uIHRoaXMgaXMgYSBsaXR0bGUga2x1ZGd5IGJ1dCBpdCB3b3Jrc1xuXHRcdFx0aWYgKCB3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5lbGVtZW50LmJpbmRpbmcuc2libGluZ3M7XG5cdFx0XHRcdGlmICggaSA9IGJpbmRpbmdzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCAhYmluZGluZy5lbGVtZW50Lm5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLCBzaWJsaW5ncyBhcmUgc3RpbGwgcmVuZGVyaW5nIVxuXHRcdFx0XHRcdFx0XHQvLyB3ZSdsbCBjb21lIGJhY2sgbGF0ZXIuLi5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkICkge1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggYmluZGluZy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGJpbmRpbmcucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCB1bmRlZmluZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2hlY2tib3hOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUgPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lKCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSAoIHZhbHVlID0gdGhpcyApLmVsZW1lbnQsXG5cdFx0XHRcdG5vZGUgPSB2YWx1ZS5ub2RlLFxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlLFxuXHRcdFx0XHR2YWx1ZUF0dHJpYnV0ZSwgaTtcblx0XHRcdHZhbHVlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggIWlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IHZhbHVlQXR0cmlidXRlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZUF0dHJpYnV0ZSA9PSB2YWx1ZVsgaSBdICkge1xuXHRcdFx0XHRcdFx0bm9kZS5jaGVja2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVDbGFzc05hbWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdG5vZGUuY2xhc3NOYW1lID0gdmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUlkQXR0cmlidXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZSgpIHtcblx0XHR2YXIgbm9kZSA9ICggdmFsdWUgPSB0aGlzICkubm9kZSxcblx0XHRcdHZhbHVlID0gdmFsdWUudmFsdWU7XG5cdFx0dGhpcy5yb290Lm5vZGVzWyB2YWx1ZSBdID0gbm9kZTtcblx0XHRub2RlLmlkID0gdmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSgpIHtcblx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9XG5cdFx0bm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoICdjc3NUZXh0JywgdmFsdWUgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlKCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlVmFsdWUoKSB7XG5cdFx0dmFyIG5vZGUgPSAoIHZhbHVlID0gdGhpcyApLm5vZGUsXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuXHRcdC8vIHN0b3JlIGFjdHVhbCB2YWx1ZSwgc28gaXQgZG9lc24ndCBnZXQgY29lcmNlZCB0byBhIHN0cmluZ1xuXHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0bm9kZS52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVCb29sZWFuLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVCb29sZWFuID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGUoKSB7XG5cdFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuXHRcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2Vcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IHRoaXMudmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVFdmVyeXRoaW5nRWxzZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgPSBmdW5jdGlvbiggYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlKCkge1xuXHRcdFx0dmFyIG5vZGUgPSAoIGZyYWdtZW50ID0gdGhpcyApLm5vZGUsXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGZyYWdtZW50Lm5hbWVzcGFjZSxcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50Lm5hbWUsXG5cdFx0XHRcdHZhbHVlID0gZnJhZ21lbnQudmFsdWUsXG5cdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQuZnJhZ21lbnQ7XG5cdFx0XHRpZiAoIG5hbWVzcGFjZSApIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyggbmFtZXNwYWNlLCBuYW1lLCAoIGZyYWdtZW50IHx8IHZhbHVlICkudG9TdHJpbmcoKSApO1xuXHRcdFx0fSBlbHNlIGlmICggIWJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoIG5hbWUsICggZnJhZ21lbnQgfHwgdmFsdWUgKS50b1N0cmluZygpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCBuYW1lLCAnJyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBib29sZWFuQXR0cmlidXRlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgbm9vcCwgdXBkYXRlU2VsZWN0VmFsdWUsIHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUsIHVwZGF0ZVJhZGlvTmFtZSwgdXBkYXRlUmFkaW9WYWx1ZSwgdXBkYXRlQ2hlY2tib3hOYW1lLCB1cGRhdGVDbGFzc05hbWUsIHVwZGF0ZUlkQXR0cmlidXRlLCB1cGRhdGVJRVN0eWxlQXR0cmlidXRlLCB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSwgdXBkYXRlVmFsdWUsIHVwZGF0ZUJvb2xlYW4sIHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGUoKSB7XG5cdFx0XHR2YXIgbmFtZSA9ICggbm9kZSA9IHRoaXMgKS5uYW1lLFxuXHRcdFx0XHRlbGVtZW50ID0gbm9kZS5lbGVtZW50LFxuXHRcdFx0XHRub2RlID0gbm9kZS5ub2RlLFxuXHRcdFx0XHR0eXBlLCB1cGRhdGVNZXRob2Q7XG5cdFx0XHRpZiAoIG5hbWUgPT09ICdpZCcgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlkQXR0cmlidXRlO1xuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gc2VsZWN0c1xuXHRcdFx0XHRpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgJiYgbmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApID8gdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA6IHVwZGF0ZVNlbGVjdFZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICd0ZXh0YXJlYScgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyApIHtcblx0XHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRcdC8vIHR5cGU9J2ZpbGUnIHZhbHVlPSd7e2ZpbGVMaXN0fX0nPlxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2ZpbGUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9vcDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAncmFkaW8nICYmIGVsZW1lbnQuYmluZGluZyAmJiBlbGVtZW50LmJpbmRpbmcubmFtZSA9PT0gJ25hbWUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9WYWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnR3b3dheSAmJiBuYW1lID09PSAnbmFtZScgKSB7XG5cdFx0XHRcdGlmICggbm9kZS50eXBlID09PSAncmFkaW8nICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvTmFtZTtcblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS50eXBlID09PSAnY2hlY2tib3gnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNoZWNrYm94TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ3N0eWxlJyAmJiBub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdjbGFzcycgJiYgKCAhbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDbGFzc05hbWU7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnVzZVByb3BlcnR5ICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVCb29sZWFuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdXBkYXRlTWV0aG9kICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVFdmVyeXRoaW5nRWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlID0gdXBkYXRlTWV0aG9kO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBub29wLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9OYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNsYXNzTmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQm9vbGVhbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL19BdHRyaWJ1dGUuanMgKi9cblx0dmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBidWJibGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIEF0dHJpYnV0ZTtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlQXR0cmlidXRlcy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBBdHRyaWJ1dGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHR2YXIgbmFtZSwgYXR0cmlidXRlLCByZXN1bHQgPSBbXTtcblx0XHRcdGZvciAoIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cmlidXRlc1sgbmFtZSBdLFxuXHRcdFx0XHRcdFx0cm9vdDogZWxlbWVudC5yb290XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCByZXN1bHRbIG5hbWUgXSA9IGF0dHJpYnV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIEF0dHJpYnV0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9Db25kaXRpb25hbEF0dHJpYnV0ZS9fQ29uZGl0aW9uYWxBdHRyaWJ1dGUuanMgKi9cblx0dmFyIENvbmRpdGlvbmFsQXR0cmlidXRlID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50LCB0b0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBGcmFnbWVudCwgZGl2O1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdGRpdiA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0fVxuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0dmFyIENvbmRpdGlvbmFsQXR0cmlidXRlID0gZnVuY3Rpb24oIGVsZW1lbnQsIHRlbXBsYXRlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHJvb3Q6IGVsZW1lbnQucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdHRlbXBsYXRlOiBbIHRlbXBsYXRlIF1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5lbGVtZW50LmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oIG5vZGUgKSB7XG5cdFx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0XHRcdHRoaXMuaXNTdmcgPSBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmc7XG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHN0ciwgYXR0cnM7XG5cdFx0XHRcdHN0ciA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdFx0YXR0cnMgPSBwYXJzZUF0dHJpYnV0ZXMoIHN0ciwgdGhpcy5pc1N2ZyApO1xuXHRcdFx0XHQvLyBhbnkgYXR0cmlidXRlcyB0aGF0IHByZXZpb3VzbHkgZXhpc3RlZCBidXQgbm8gbG9uZ2VyIGRvXG5cdFx0XHRcdC8vIG11c3QgYmUgcmVtb3ZlZFxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90SW4oIGF0dHJzLCBhICk7XG5cdFx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHR0aGlzJDAubm9kZS5yZW1vdmVBdHRyaWJ1dGUoIGEubmFtZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGF0dHJzLmZvckVhY2goIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRcdHRoaXMkMC5ub2RlLnNldEF0dHJpYnV0ZSggYS5uYW1lLCBhLnZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cnM7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBDb25kaXRpb25hbEF0dHJpYnV0ZTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyggc3RyLCBpc1N2ZyApIHtcblx0XHRcdHZhciB0YWcgPSBpc1N2ZyA/ICdzdmcnIDogJ2Rpdic7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gJzwnICsgdGFnICsgJyAnICsgc3RyICsgJz48LycgKyB0YWcgKyAnPic7XG5cdFx0XHRyZXR1cm4gdG9BcnJheSggZGl2LmNoaWxkTm9kZXNbIDAgXS5hdHRyaWJ1dGVzICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90SW4oIGhheXN0YWNrLCBuZWVkbGUgKSB7XG5cdFx0XHR2YXIgaSA9IGhheXN0YWNrLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIGhheXN0YWNrWyBpIF0ubmFtZSA9PT0gbmVlZGxlLm5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjaXJjdWxhciwgbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCwgdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBDb25kaXRpb25hbEF0dHJpYnV0ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgYXR0cmlidXRlcyApIHtcblx0XHRcdGlmICggIWF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhdHRyaWJ1dGVzLm1hcCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQ29uZGl0aW9uYWxBdHRyaWJ1dGUoIGVsZW1lbnQsIGEgKTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBDb25kaXRpb25hbEF0dHJpYnV0ZSApO1xuXG5cdC8qIHV0aWxzL2V4dGVuZC5qcyAqL1xuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHR2YXIgc291cmNlcyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHByb3AsIHNvdXJjZTtcblx0XHR3aGlsZSAoIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKSApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xuXHRcdFx0XHRpZiAoIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRcdHRhcmdldFsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9CaW5kaW5nLmpzICovXG5cdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGludGVycG9sYXRvciwga2V5cGF0aCwgdmFsdWU7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbIHRoaXMubmFtZSB8fCAndmFsdWUnIF07XG5cdFx0XHRpbnRlcnBvbGF0b3IgPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3I7XG5cdFx0XHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cdFx0XHRpZiAoIGludGVycG9sYXRvci5rZXlwYXRoICYmIGludGVycG9sYXRvci5rZXlwYXRoLnN1YnN0ciggMCwgMiApID09PSAnJHsnICkge1xuXHRcdFx0XHR3YXJuKCAnVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCBleHByZXNzaW9ucyAoYCcgKyBpbnRlcnBvbGF0b3Iua2V5cGF0aC5zbGljZSggMiwgLTEgKSArICdgKScgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQSBtdXN0YWNoZSBtYXkgYmUgKmFtYmlndW91cyouIExldCdzIHNheSB3ZSB3ZXJlIGdpdmVuXG5cdFx0XHQvLyBgdmFsdWU9XCJ7e2Jhcn19XCJgLiBJZiB0aGUgY29udGV4dCB3YXMgYGZvb2AsIGFuZCBgZm9vLmJhcmBcblx0XHRcdC8vICp3YXNuJ3QqIGB1bmRlZmluZWRgLCB0aGUga2V5cGF0aCB3b3VsZCBiZSBgZm9vLmJhcmAuXG5cdFx0XHQvLyBUaGVuLCBhbnkgdXNlciBpbnB1dCB3b3VsZCByZXN1bHQgaW4gYGZvby5iYXJgIGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gSWYsIGhvd2V2ZXIsIGBmb28uYmFyYCAqd2FzKiB1bmRlZmluZWQsIGFuZCBzbyB3YXMgYGJhcmAsIHdlIHdvdWxkIGJlXG5cdFx0XHQvLyBsZWZ0IHdpdGggYW4gdW5yZXNvbHZlZCBwYXJ0aWFsIGtleXBhdGggLSBzbyB3ZSBhcmUgZm9yY2VkIHRvIG1ha2UgYW5cblx0XHRcdC8vIGFzc3VtcHRpb24uIFRoYXQgYXNzdW1wdGlvbiBpcyB0aGF0IHRoZSBpbnB1dCBpbiBxdWVzdGlvbiBzaG91bGRcblx0XHRcdC8vIGJlIGZvcmNlZCB0byByZXNvbHZlIHRvIGBiYXJgLCBhbmQgYW55IHVzZXIgaW5wdXQgd291bGQgYWZmZWN0IGBiYXJgXG5cdFx0XHQvLyBhbmQgbm90IGBmb28uYmFyYC5cblx0XHRcdC8vXG5cdFx0XHQvLyBEaWQgdGhhdCBtYWtlIGFueSBzZW5zZT8gTm8/IE9oLiBTb3JyeS4gV2VsbCB0aGUgbW9yYWwgb2YgdGhlIHN0b3J5IGlzXG5cdFx0XHQvLyBiZSBleHBsaWNpdCB3aGVuIHVzaW5nIHR3by13YXkgZGF0YS1iaW5kaW5nIGFib3V0IHdoYXQga2V5cGF0aCB5b3UncmVcblx0XHRcdC8vIHVwZGF0aW5nLiBVc2luZyBpdCBpbiBsaXN0cyBpcyBwcm9iYWJseSBhIHJlY2lwZSBmb3IgY29uZnVzaW9uLi4uXG5cdFx0XHRpZiAoICFpbnRlcnBvbGF0b3Iua2V5cGF0aCApIHtcblx0XHRcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoO1xuXHRcdFx0Ly8gaW5pdGlhbGlzZSB2YWx1ZSwgaWYgaXQncyB1bmRlZmluZWRcblx0XHRcdGlmICggdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0QmluZGluZy5wcm90b3R5cGUgPSB7XG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHRoaXMuZ2V0VmFsdWUoKSApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJvdW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGJpbmRpbmdzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuXHRcdFx0XHRuZXdLZXlwYXRoID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLmtleXBhdGg7XG5cdFx0XHRcdC8vIFRoZSBhdHRyaWJ1dGUgdGhpcyBiaW5kaW5nIGlzIGxpbmtlZCB0byBoYXMgYWxyZWFkeSBkb25lIHRoZSB3b3JrXG5cdFx0XHRcdGlmICggb2xkS2V5cGF0aCA9PT0gbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBvbGRLZXlwYXRoIF0sIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBuZXdLZXlwYXRoIF0gfHwgKCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBuZXdLZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblx0XHRCaW5kaW5nLmV4dGVuZCA9IGZ1bmN0aW9uKCBwcm9wZXJ0aWVzICkge1xuXHRcdFx0dmFyIFBhcmVudCA9IHRoaXMsXG5cdFx0XHRcdFNwZWNpYWxpc2VkQmluZGluZztcblx0XHRcdFNwZWNpYWxpc2VkQmluZGluZyA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0XHRCaW5kaW5nLmNhbGwoIHRoaXMsIGVsZW1lbnQgKTtcblx0XHRcdFx0aWYgKCB0aGlzLmluaXQgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRleHRlbmQoIFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUsIHByb3BlcnRpZXMgKTtcblx0XHRcdFNwZWNpYWxpc2VkQmluZGluZy5leHRlbmQgPSBCaW5kaW5nLmV4dGVuZDtcblx0XHRcdHJldHVybiBTcGVjaWFsaXNlZEJpbmRpbmc7XG5cdFx0fTtcblx0XHRyZXR1cm4gQmluZGluZztcblx0fSggcnVubG9vcCwgd2FybiwgY3JlYXRlLCBleHRlbmQsIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL3NoYXJlZC9oYW5kbGVEb21FdmVudC5qcyAqL1xuXHR2YXIgaGFuZGxlRG9tRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG5cdFx0dGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NvbnRlbnRFZGl0YWJsZUJpbmRpbmcuanMgKi9cblx0dmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ29udGVudEVkaXRhYmxlQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZyYWdtZW50ID8gdGhpcy5lbGVtZW50LmZyYWdtZW50LnRvU3RyaW5nKCkgOiAnJztcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5yb290LmxhenkgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuaW5uZXJIVE1MO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gQ29udGVudEVkaXRhYmxlQmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9zaGFyZWQvZ2V0U2libGluZ3MuanMgKi9cblx0dmFyIGdldFNpYmxpbmdzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc2V0cyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRTaWJsaW5ncyggaWQsIGdyb3VwLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGhhc2ggPSBpZCArIGdyb3VwICsga2V5cGF0aDtcblx0XHRcdHJldHVybiBzZXRzWyBoYXNoIF0gfHwgKCBzZXRzWyBoYXNoIF0gPSBbXSApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9SYWRpb0JpbmRpbmcuanMgKi9cblx0dmFyIFJhZGlvQmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGdldFNpYmxpbmdzLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBSYWRpb0JpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ2NoZWNrZWQnLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAncmFkaW8nLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLmZvckVhY2goIGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KCBiaW5kaW5nLmtleXBhdGgsIGJpbmRpbmcuZ2V0VmFsdWUoKSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIFJhZGlvQmluZGluZztcblx0fSggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9SYWRpb05hbWVCaW5kaW5nLmpzICovXG5cdHZhciBSYWRpb05hbWVCaW5kaW5nID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQsIGdldFNpYmxpbmdzICkge1xuXG5cdFx0dmFyIFJhZGlvTmFtZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ25hbWUnLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAncmFkaW9uYW1lJywgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0XHR0aGlzLnJhZGlvTmFtZSA9IHRydWU7XG5cdFx0XHRcdC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLnR3b3dheSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY2hlY2tlZCcgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5uYW1lID0gJ3t7JyArIHRoaXMua2V5cGF0aCArICd9fSc7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKSA9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRyZXR1cm4gbm9kZS5fcmFjdGl2ZSA/IG5vZGUuX3JhY3RpdmUudmFsdWUgOiBub2RlLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcblx0XHRcdFx0Ly8gYG5hbWVgIGtleXBhdGggZ2V0cyBzZXQgdG8gaXRzIHZhbHVlXG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZCApIHtcblx0XHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVib3VuZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLnJlYm91bmQuY2FsbCggdGhpcywgaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlICkge1xuXHRcdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBSYWRpb05hbWVCaW5kaW5nO1xuXHR9KCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50LCBnZXRTaWJsaW5ncyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NoZWNrYm94TmFtZUJpbmRpbmcuanMgKi9cblx0dmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBmdW5jdGlvbiggaXNBcnJheSwgYXJyYXlDb250YWlucywgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ2hlY2tib3hOYW1lQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRuYW1lOiAnbmFtZScsXG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgZ3JvdXAgKG9mIGlucHV0cyB0aGF0XG5cdFx0XHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuXHRcdFx0XHQvLyBpc24ndCBhbiBpbml0aWFsIHZhbHVlLiBCeSB0aGUgc2FtZSB0b2tlbiwgd2UgY2FuIG1ha2Vcblx0XHRcdFx0Ly8gYSBub3RlIG9mIHRoYXQgZmFjdCB0aGF0IHRoZXJlIHdhcyBubyBpbml0aWFsIHZhbHVlLFxuXHRcdFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcblx0XHRcdFx0Ly8gZXhpc3QgKHdoaWNoIHVzZXJzIHNob3VsZCBhdm9pZCwgYnV0IHdoaWNoIHdlIHNob3VsZFxuXHRcdFx0XHQvLyBzdXBwb3J0IGFueXdheSB0byBhdm9pZCBicmVha2luZyBleHBlY3RhdGlvbnMpXG5cdFx0XHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWU7XG5cdFx0XHRcdHRoaXMuY2hlY2tib3hOYW1lID0gdHJ1ZTtcblx0XHRcdFx0Ly8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUudHdvd2F5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gd2Ugc2V0IHRoaXMgcHJvcGVydHkgc28gdGhhdCB0aGUgYXR0cmlidXRlIGdldHMgdGhlIGNvcnJlY3QgdXBkYXRlIG1ldGhvZFxuXHRcdFx0XHQvLyBFYWNoIGlucHV0IGhhcyBhIHJlZmVyZW5jZSB0byBhbiBhcnJheSBjb250YWluaW5nIGl0IGFuZCBpdHNcblx0XHRcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG5cdFx0XHRcdC8vIHRoZSBzdGF0dXMgb2YgYWxsIGlucHV0cyB3aXRoaW4gdGhlIGdyb3VwXG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAnY2hlY2tib3hlcycsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0aWYgKCB0aGlzLm5vSW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIG5vIGluaXRpYWwgdmFsdWUgd2FzIHNldCwgYW5kIHRoaXMgaW5wdXQgaXMgY2hlY2tlZCwgd2Vcblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBtb2RlbFxuXHRcdFx0XHRpZiAoIHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICkgKSB7XG5cdFx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0ZXhpc3RpbmdWYWx1ZS5wdXNoKCBiaW5kaW5nVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG5cdFx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXHRcdFx0XHRleGlzdGluZ1ZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdGlmICggaXNBcnJheSggZXhpc3RpbmdWYWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gYXJyYXlDb250YWlucyggZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBleGlzdGluZ1ZhbHVlID09IGJpbmRpbmdWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5pc0NoZWNrZWQ7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIElFIGVtZXJnZW5jeSwgYmluZCB0byBjbGljayBldmVudCBhcyB3ZWxsXG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zaWJsaW5ncy5maWx0ZXIoIGlzQ2hlY2tlZCApLm1hcCggZ2V0VmFsdWUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRmdW5jdGlvbiBpc0NoZWNrZWQoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gQ2hlY2tib3hOYW1lQmluZGluZztcblx0fSggaXNBcnJheSwgYXJyYXlDb250YWlucywgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveEJpbmRpbmcuanMgKi9cblx0dmFyIENoZWNrYm94QmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBDaGVja2JveEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ2NoZWNrZWQnLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gQ2hlY2tib3hCaW5kaW5nO1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL1NlbGVjdEJpbmRpbmcuanMgKi9cblx0dmFyIFNlbGVjdEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgU2VsZWN0QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuXHRcdFx0XHRcdGxlbiwgaSwgdmFsdWUsIG9wdGlvbldhc1NlbGVjdGVkO1xuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGlmICggIWxlbiApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdGFrZSB0aGUgZmluYWwgc2VsZWN0ZWQgb3B0aW9uLi4uXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJyApICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb3IgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24sIGlmIG5vbmUgYXJlIHNlbGVjdGVkXG5cdFx0XHRcdGlmICggIW9wdGlvbldhc1NlbGVjdGVkICkge1xuXHRcdFx0XHRcdHdoaWxlICggKytpIDwgbGVuICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIChha2EgaGFjaykgdGhhdCBhbGxvd3MgdXMgdG8gZm9yZ28gc29tZVxuXHRcdFx0XHQvLyBvdGhlciBtb3JlIGV4cGVuc2l2ZSB3b3JrXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cmlidXRlcy52YWx1ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVE9ETyB0aGlzIG1ldGhvZCBpcyBhbiBhbm9tYWx5Li4uIGlzIGl0IG5lY2Vzc2FyeT9cblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucywgaSwgbGVuLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcblx0XHRcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgaSBdLnNlbGVjdGVkICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBTZWxlY3RCaW5kaW5nO1xuXHR9KCBydW5sb29wLCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHV0aWxzL2FycmF5Q29udGVudHNNYXRjaC5qcyAqL1xuXHR2YXIgYXJyYXlDb250ZW50c01hdGNoID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdGlmICggIWlzQXJyYXkoIGEgKSB8fCAhaXNBcnJheSggYiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGEubGVuZ3RoICE9PSBiLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggYVsgaSBdICE9PSBiWyBpIF0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KCBpc0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvTXVsdGlwbGVTZWxlY3RCaW5kaW5nLmpzICovXG5cdHZhciBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgYXJyYXlDb250ZW50c01hdGNoLCBTZWxlY3RCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBTZWxlY3RCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vcHRpb25zLmZpbHRlciggZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJyApO1xuXHRcdFx0XHR9ICkubWFwKCBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWVGcm9tTW9kZWw7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0dmFsdWVGcm9tTW9kZWwgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggdmFsdWVGcm9tTW9kZWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBnZXQgdmFsdWUgZnJvbSBET00sIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVDaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVE9ETyBub3QgaW1wbGVtZW50ZWQgeWV0JyApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNlbGVjdGVkVmFsdWVzLCBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRcdHNlbGVjdGVkVmFsdWVzID0gW107XG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuXHRcdFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0XHRcdHNlbGVjdGVkVmFsdWVzLnB1c2goIG9wdGlvblZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZWxlY3RlZFZhbHVlcztcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlLCBwcmV2aW91c1ZhbHVlLCB2YWx1ZTtcblx0XHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG5cdFx0XHRcdHByZXZpb3VzVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHByZXZpb3VzVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhYXJyYXlDb250ZW50c01hdGNoKCB2YWx1ZSwgcHJldmlvdXNWYWx1ZSApICkge1xuXHRcdFx0XHRcdFNlbGVjdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlTW9kZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlLnZhbHVlID09PSB1bmRlZmluZWQgfHwgIXRoaXMuYXR0cmlidXRlLnZhbHVlLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB0aGlzLmluaXRpYWxWYWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBNdWx0aXBsZVNlbGVjdEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIGFycmF5Q29udGVudHNNYXRjaCwgU2VsZWN0QmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9GaWxlTGlzdEJpbmRpbmcuanMgKi9cblx0dmFyIEZpbGVMaXN0QmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBGaWxlTGlzdEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmZpbGVzO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gRmlsZUxpc3RCaW5kaW5nO1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0dlbmVyaWNCaW5kaW5nLmpzICovXG5cdHZhciBHZW5lcmljQmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgR2VuZXJpY0JpbmRpbmcsIGdldE9wdGlvbnM7XG5cdFx0Z2V0T3B0aW9ucyA9IHtcblx0XHRcdGV2YWx1YXRlV3JhcHBlZDogdHJ1ZVxuXHRcdH07XG5cdFx0R2VuZXJpY0JpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoICF0aGlzLnJvb3QubGF6eSApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IEdlbmVyaWNCaW5kaW5nO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGhhbmRsZURvbUV2ZW50LmNhbGwoIHRoaXMgKTtcblx0XHRcdHZhbHVlID0gdGhpcy5fcmFjdGl2ZS5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMuX3JhY3RpdmUuYmluZGluZy5rZXlwYXRoLCBnZXRPcHRpb25zICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL051bWVyaWNCaW5kaW5nLmpzICovXG5cdHZhciBOdW1lcmljQmluZGluZyA9IGZ1bmN0aW9uKCBHZW5lcmljQmluZGluZyApIHtcblxuXHRcdHJldHVybiBHZW5lcmljQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KCB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZSApO1xuXHRcdFx0XHRyZXR1cm4gaXNOYU4oIHZhbHVlICkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0oIEdlbmVyaWNCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZVR3b3dheUJpbmRpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcgPSBmdW5jdGlvbiggbG9nLCBDb250ZW50RWRpdGFibGVCaW5kaW5nLCBSYWRpb0JpbmRpbmcsIFJhZGlvTmFtZUJpbmRpbmcsIENoZWNrYm94TmFtZUJpbmRpbmcsIENoZWNrYm94QmluZGluZywgU2VsZWN0QmluZGluZywgTXVsdGlwbGVTZWxlY3RCaW5kaW5nLCBGaWxlTGlzdEJpbmRpbmcsIE51bWVyaWNCaW5kaW5nLCBHZW5lcmljQmluZGluZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcyxcblx0XHRcdFx0dHlwZSwgQmluZGluZywgYmluZE5hbWUsIGJpbmRDaGVja2VkO1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGxhdGUgYmluZGluZywgYW5kIHRoZXJlJ3MgYWxyZWFkeSBvbmUsIGl0XG5cdFx0XHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cblx0XHRcdGlmICggZWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcblx0XHRcdFx0ZWxlbWVudC5iaW5kaW5nID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnRlbnRlZGl0YWJsZVxuXHRcdFx0aWYgKCAvLyBpZiB0aGUgY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZSBpcyB0cnVlIG9yIGlzIGJpbmRhYmxlIGFuZCBtYXkgdGh1cyBiZWNvbWUgdHJ1ZVxuXHRcdFx0XHQoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApIHx8ICEhYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgJiYgaXNCaW5kYWJsZSggYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgKSApICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgKSB7XG5cdFx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnICkge1xuXHRcdFx0XHRcdGJpbmROYW1lID0gaXNCaW5kYWJsZSggYXR0cmlidXRlcy5uYW1lICk7XG5cdFx0XHRcdFx0YmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLmNoZWNrZWQgKTtcblx0XHRcdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIGJpbmQgdGhlIG5hbWUgYXR0cmlidXRlLCBvciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aFxuXHRcdFx0XHRcdGlmICggYmluZE5hbWUgJiYgYmluZENoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ2JhZFJhZGlvSW5wdXRCaW5kaW5nJ1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGJpbmROYW1lICkge1xuXHRcdFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09ICdyYWRpbycgPyBSYWRpb05hbWVCaW5kaW5nIDogQ2hlY2tib3hOYW1lQmluZGluZztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBiaW5kQ2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAncmFkaW8nID8gUmFkaW9CaW5kaW5nIDogQ2hlY2tib3hCaW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2ZpbGUnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHRCaW5kaW5nID0gRmlsZUxpc3RCaW5kaW5nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdyYW5nZScgPyBOdW1lcmljQmluZGluZyA6IEdlbmVyaWNCaW5kaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgPyBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgOiBTZWxlY3RCaW5kaW5nO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IEdlbmVyaWNCaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBCaW5kaW5nICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJpbmRpbmcoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNCaW5kYWJsZSggYXR0cmlidXRlICkge1xuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCaW5kYWJsZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBsb2csIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcsIFJhZGlvQmluZGluZywgUmFkaW9OYW1lQmluZGluZywgQ2hlY2tib3hOYW1lQmluZGluZywgQ2hlY2tib3hCaW5kaW5nLCBTZWxlY3RCaW5kaW5nLCBNdWx0aXBsZVNlbGVjdEJpbmRpbmcsIEZpbGVMaXN0QmluZGluZywgTnVtZXJpY0JpbmRpbmcsIEdlbmVyaWNCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGJ1YmJsZSA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRidWJibGUoKSB7XG5cdFx0dmFyIGhhc0FjdGlvbiA9IHRoaXMuZ2V0QWN0aW9uKCk7XG5cdFx0aWYgKCBoYXNBY3Rpb24gJiYgIXRoaXMuaGFzTGlzdGVuZXIgKSB7XG5cdFx0XHR0aGlzLmxpc3RlbigpO1xuXHRcdH0gZWxzZSBpZiAoICFoYXNBY3Rpb24gJiYgdGhpcy5oYXNMaXN0ZW5lciApIHtcblx0XHRcdHRoaXMudW5yZW5kZXIoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvZmlyZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlID0gZnVuY3Rpb24oIGZpcmVFdmVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZmlyZSggZXZlbnQgKSB7XG5cdFx0XHRmaXJlRXZlbnQoIHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwge1xuXHRcdFx0XHRldmVudDogZXZlbnRcblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9nZXRBY3Rpb24uanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkZ2V0QWN0aW9uID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGdldEFjdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hY3Rpb24udG9TdHJpbmcoKS50cmltKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRpbml0ID0gZnVuY3Rpb24oIGdldEZ1bmN0aW9uRnJvbVN0cmluZywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGNpcmN1bGFyLCBmaXJlRXZlbnQsIGxvZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucyA9IHtcblx0XHRcdFx0YXJnczogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGV2ZW50UGF0dGVybiA9IC9eZXZlbnQoPzpcXC4oLispKT8vO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkaW5pdCggZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHRoaXMsXG5cdFx0XHRcdGFjdGlvbiwgcmVmcywgcmFjdGl2ZTtcblx0XHRcdGhhbmRsZXIuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRoYW5kbGVyLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRoYW5kbGVyLm5hbWUgPSBuYW1lO1xuXHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoICcqJyApICE9PSAtMSApIHtcblx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHRoaXMucm9vdC5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9FbGVtZW50UHJveHlFdmVudFdpbGRjYXJkcycsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudC50YWdOYW1lLFxuXHRcdFx0XHRcdFx0ZXZlbnQ6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5pbnZhbGlkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggdGVtcGxhdGUubSApIHtcblx0XHRcdFx0cmVmcyA9IHRlbXBsYXRlLmEucjtcblx0XHRcdFx0Ly8gVGhpcyBpcyBhIG1ldGhvZCBjYWxsXG5cdFx0XHRcdGhhbmRsZXIubWV0aG9kID0gdGVtcGxhdGUubTtcblx0XHRcdFx0aGFuZGxlci5rZXlwYXRocyA9IFtdO1xuXHRcdFx0XHRoYW5kbGVyLmZuID0gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKCB0ZW1wbGF0ZS5hLnMsIHJlZnMubGVuZ3RoICk7XG5cdFx0XHRcdGhhbmRsZXIucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0XHRyYWN0aXZlID0gaGFuZGxlci5yb290O1xuXHRcdFx0XHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuXHRcdFx0XHRoYW5kbGVyLnJlZlJlc29sdmVycyA9IHJlZnMubWFwKCBmdW5jdGlvbiggcmVmLCBpICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSB0aGUgYGV2ZW50YCBvYmplY3Rcblx0XHRcdFx0XHRpZiAoIG1hdGNoID0gZXZlbnRQYXR0ZXJuLmV4ZWMoIHJlZiApICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlci5rZXlwYXRoc1sgaSBdID0ge1xuXHRcdFx0XHRcdFx0XHRldmVudE9iamVjdDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0cmVmaW5lbWVudHM6IG1hdGNoWyAxIF0gPyBtYXRjaFsgMSBdLnNwbGl0KCAnLicgKSA6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggaGFuZGxlciwgcmVmLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIucmVzb2x2ZSggaSwga2V5cGF0aCApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlTWV0aG9kQ2FsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEdldCBhY3Rpb24gKCdmb28nIGluICdvbi1jbGljaz0nZm9vJylcblx0XHRcdFx0YWN0aW9uID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRhY3Rpb24gPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiBhY3Rpb24sXG5cdFx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFjdGlvbiA9IGFjdGlvbjtcblx0XHRcdFx0Ly8gR2V0IHBhcmFtZXRlcnNcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZS5kICkge1xuXHRcdFx0XHRcdHRoaXMuZHluYW1pY1BhcmFtcyA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoUGFyYW1zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGZpcmVNZXRob2RDYWxsKCBldmVudCApIHtcblx0XHRcdHZhciByYWN0aXZlLCB2YWx1ZXMsIGFyZ3M7XG5cdFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXHRcdFx0aWYgKCB0eXBlb2YgcmFjdGl2ZVsgdGhpcy5tZXRob2QgXSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIGNhbGwgYSBub24tZXhpc3RlbnQgbWV0aG9kIChcIicgKyB0aGlzLm1ldGhvZCArICdcIiknICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmtleXBhdGhzLm1hcCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgbGVuLCBpO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBub3QgeWV0IHJlc29sdmVkXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUT0RPIHRoZSByZWZpbmVtZW50cyBzdHVmZiB3b3VsZCBiZSBiZXR0ZXIgaGFuZGxlZCBhdCBwYXJzZSB0aW1lXG5cdFx0XHRcdGlmICgga2V5cGF0aC5ldmVudE9iamVjdCApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGV2ZW50O1xuXHRcdFx0XHRcdGlmICggbGVuID0ga2V5cGF0aC5yZWZpbmVtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlWyBrZXlwYXRoLnJlZmluZW1lbnRzWyBpIF0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9ICk7XG5cdFx0XHRyYWN0aXZlLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHRhcmdzID0gdGhpcy5mbi5hcHBseSggbnVsbCwgdmFsdWVzICk7XG5cdFx0XHRyYWN0aXZlWyB0aGlzLm1ldGhvZCBdLmFwcGx5KCByYWN0aXZlLCBhcmdzICk7XG5cdFx0XHRkZWxldGUgcmFjdGl2ZS5ldmVudDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRXaXRoUGFyYW1zKCBldmVudCApIHtcblx0XHRcdGZpcmVFdmVudCggdGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7XG5cdFx0XHRcdGV2ZW50OiBldmVudCxcblx0XHRcdFx0YXJnczogdGhpcy5wYXJhbXNcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcyggZXZlbnQgKSB7XG5cdFx0XHR2YXIgYXJncyA9IHRoaXMuZHluYW1pY1BhcmFtcy5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHQvLyBuZWVkIHRvIHN0cmlwIFtdIGZyb20gZW5kcyBpZiBhIHN0cmluZyFcblx0XHRcdGlmICggdHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRhcmdzID0gYXJncy5zdWJzdHIoIDEsIGFyZ3MubGVuZ3RoIC0gMiApO1xuXHRcdFx0fVxuXHRcdFx0ZmlyZUV2ZW50KCB0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHtcblx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRhcmdzOiBhcmdzXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgY2lyY3VsYXIsIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCwgbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9zaGFyZWQvZ2VuZXJpY0hhbmRsZXIuanMgKi9cblx0dmFyIGdlbmVyaWNIYW5kbGVyID0gZnVuY3Rpb24gZ2VuZXJpY0hhbmRsZXIoIGV2ZW50ICkge1xuXHRcdHZhciBzdG9yYWdlLCBoYW5kbGVyO1xuXHRcdHN0b3JhZ2UgPSB0aGlzLl9yYWN0aXZlO1xuXHRcdGhhbmRsZXIgPSBzdG9yYWdlLmV2ZW50c1sgZXZlbnQudHlwZSBdO1xuXHRcdGhhbmRsZXIuZmlyZSgge1xuXHRcdFx0bm9kZTogdGhpcyxcblx0XHRcdG9yaWdpbmFsOiBldmVudCxcblx0XHRcdGluZGV4OiBzdG9yYWdlLmluZGV4LFxuXHRcdFx0a2V5cGF0aDogc3RvcmFnZS5rZXlwYXRoLFxuXHRcdFx0Y29udGV4dDogc3RvcmFnZS5yb290LmdldCggc3RvcmFnZS5rZXlwYXRoIClcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvbGlzdGVuLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGxpc3RlbiA9IGZ1bmN0aW9uKCBjb25maWcsIGdlbmVyaWNIYW5kbGVyLCBsb2cgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGN1c3RvbUhhbmRsZXJzID0ge30sXG5cdFx0XHR0b3VjaEV2ZW50cyA9IHtcblx0XHRcdFx0dG91Y2hzdGFydDogdHJ1ZSxcblx0XHRcdFx0dG91Y2htb3ZlOiB0cnVlLFxuXHRcdFx0XHR0b3VjaGVuZDogdHJ1ZSxcblx0XHRcdFx0dG91Y2hjYW5jZWw6IHRydWUsXG5cdFx0XHRcdC8vbm90IHczYywgYnV0IHN1cHBvcnRlZCBpbiBzb21lIGJyb3dzZXJzXG5cdFx0XHRcdHRvdWNobGVhdmU6IHRydWVcblx0XHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkbGlzdGVuKCkge1xuXHRcdFx0dmFyIGRlZmluaXRpb24sIG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHRpZiAoIHRoaXMuaW52YWxpZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkZWZpbml0aW9uID0gY29uZmlnLnJlZ2lzdHJpZXMuZXZlbnRzLmZpbmQoIHRoaXMucm9vdCwgbmFtZSApICkge1xuXHRcdFx0XHR0aGlzLmN1c3RvbSA9IGRlZmluaXRpb24oIHRoaXMubm9kZSwgZ2V0Q3VzdG9tSGFuZGxlciggbmFtZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN0YW5kYXJkIERPTSBldmVudC4uLiBidXQgbGV0J3MgY2hlY2tcblx0XHRcdFx0aWYgKCAhKCAnb24nICsgbmFtZSBpbiB0aGlzLm5vZGUgKSAmJiAhKCB3aW5kb3cgJiYgJ29uJyArIG5hbWUgaW4gd2luZG93ICkgKSB7XG5cdFx0XHRcdFx0Ly8gb2theSB0byB1c2UgdG91Y2ggZXZlbnRzIGlmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlbVxuXHRcdFx0XHRcdGlmICggIXRvdWNoRXZlbnRzWyBuYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHRoaXMucm9vdC5kZWJ1Zyxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ21pc3NpbmdQbHVnaW4nLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cGx1Z2luOiAnZXZlbnQnLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoIG5hbWUsIGdlbmVyaWNIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oYXNMaXN0ZW5lciA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldEN1c3RvbUhhbmRsZXIoIG5hbWUgKSB7XG5cdFx0XHRpZiAoICFjdXN0b21IYW5kbGVyc1sgbmFtZSBdICkge1xuXHRcdFx0XHRjdXN0b21IYW5kbGVyc1sgbmFtZSBdID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdHZhciBzdG9yYWdlID0gZXZlbnQubm9kZS5fcmFjdGl2ZTtcblx0XHRcdFx0XHRldmVudC5pbmRleCA9IHN0b3JhZ2UuaW5kZXg7XG5cdFx0XHRcdFx0ZXZlbnQua2V5cGF0aCA9IHN0b3JhZ2Uua2V5cGF0aDtcblx0XHRcdFx0XHRldmVudC5jb250ZXh0ID0gc3RvcmFnZS5yb290LmdldCggc3RvcmFnZS5rZXlwYXRoICk7XG5cdFx0XHRcdFx0c3RvcmFnZS5ldmVudHNbIG5hbWUgXS5maXJlKCBldmVudCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGN1c3RvbUhhbmRsZXJzWyBuYW1lIF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY29uZmlnLCBnZW5lcmljSGFuZGxlciwgbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlYmluZCA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHR2YXIgZnJhZ21lbnQ7XG5cdFx0aWYgKCB0aGlzLm1ldGhvZCApIHtcblx0XHRcdGZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHRoaXMuYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHJlYmluZCggdGhpcy5hY3Rpb24gKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmR5bmFtaWNQYXJhbXMgKSB7XG5cdFx0XHRyZWJpbmQoIHRoaXMuZHluYW1pY1BhcmFtcyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlYmluZCggdGhpbmcgKSB7XG5cdFx0XHR0aGluZyAmJiB0aGluZy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVuZGVyID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlbmRlcigpIHtcblx0XHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG5cdFx0Ly8gdW5pdmVyc2FsIGhhbmRsZXJcblx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuZXZlbnRzWyB0aGlzLm5hbWUgXSA9IHRoaXM7XG5cdFx0aWYgKCB0aGlzLm1ldGhvZCB8fCB0aGlzLmdldEFjdGlvbigpICkge1xuXHRcdFx0dGhpcy5saXN0ZW4oKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvcmVzb2x2ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZXNvbHZlID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlc29sdmUoIGluZGV4LCBrZXlwYXRoICkge1xuXHRcdHRoaXMua2V5cGF0aHNbIGluZGV4IF0gPSBrZXlwYXRoO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bmJpbmQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bmJpbmQoKSB7XG5cdFx0XHRpZiAoIHRoaXMubWV0aG9kICkge1xuXHRcdFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgbmFtZVxuXHRcdFx0aWYgKCB0eXBlb2YgdGhpcy5hY3Rpb24gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLmFjdGlvbi51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdC8vIFRlYXIgZG93biBkeW5hbWljIHBhcmFtZXRlcnNcblx0XHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggeCApIHtcblx0XHRcdHgudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVucmVuZGVyID0gZnVuY3Rpb24oIGdlbmVyaWNIYW5kbGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bnJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5jdXN0b20gKSB7XG5cdFx0XHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggdGhpcy5uYW1lLCBnZW5lcmljSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFzTGlzdGVuZXIgPSBmYWxzZTtcblx0XHR9O1xuXHR9KCBnZW5lcmljSGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvX0V2ZW50SGFuZGxlci5qcyAqL1xuXHR2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oIGJ1YmJsZSwgZmlyZSwgZ2V0QWN0aW9uLCBpbml0LCBsaXN0ZW4sIHJlYmluZCwgcmVuZGVyLCByZXNvbHZlLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApIHtcblx0XHRcdHRoaXMuaW5pdCggZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUgKTtcblx0XHR9O1xuXHRcdEV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGZpcmU6IGZpcmUsXG5cdFx0XHRnZXRBY3Rpb246IGdldEFjdGlvbixcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRsaXN0ZW46IGxpc3Rlbixcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBFdmVudEhhbmRsZXI7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGZpcmUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkZ2V0QWN0aW9uLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkbGlzdGVuLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVzb2x2ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5yZW5kZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlRXZlbnRIYW5kbGVycy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uKCBFdmVudEhhbmRsZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGksIG5hbWUsIG5hbWVzLCBoYW5kbGVyLCByZXN1bHQgPSBbXTtcblx0XHRcdGZvciAoIG5hbWUgaW4gdGVtcGxhdGUgKSB7XG5cdFx0XHRcdGlmICggdGVtcGxhdGUuaGFzT3duUHJvcGVydHkoIG5hbWUgKSApIHtcblx0XHRcdFx0XHRuYW1lcyA9IG5hbWUuc3BsaXQoICctJyApO1xuXHRcdFx0XHRcdGkgPSBuYW1lcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlciggZWxlbWVudCwgbmFtZXNbIGkgXSwgdGVtcGxhdGVbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIGhhbmRsZXIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fSggRXZlbnRIYW5kbGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0RlY29yYXRvci9fRGVjb3JhdG9yLmpzICovXG5cdHZhciBEZWNvcmF0b3IgPSBmdW5jdGlvbiggbG9nLCBjaXJjdWxhciwgY29uZmlnICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBnZXRWYWx1ZU9wdGlvbnMsIERlY29yYXRvcjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdGdldFZhbHVlT3B0aW9ucyA9IHtcblx0XHRcdGFyZ3M6IHRydWVcblx0XHR9O1xuXHRcdERlY29yYXRvciA9IGZ1bmN0aW9uKCBlbGVtZW50LCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBkZWNvcmF0b3IgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblx0XHRcdGRlY29yYXRvci5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdGRlY29yYXRvci5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcblx0XHRcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IG5hbWUsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0ZGVjb3JhdG9yLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS5kICkge1xuXHRcdFx0XHRkZWNvcmF0b3IuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0ZGVjb3JhdG9yLnBhcmFtcyA9IGRlY29yYXRvci5mcmFnbWVudC5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHRcdGRlY29yYXRvci5mcmFnbWVudC5idWJibGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0ZGVjb3JhdG9yLnBhcmFtcyA9IHRoaXMuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRcdGlmICggZGVjb3JhdG9yLnJlYWR5ICkge1xuXHRcdFx0XHRcdFx0ZGVjb3JhdG9yLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGRlY29yYXRvci5mbiA9IGNvbmZpZy5yZWdpc3RyaWVzLmRlY29yYXRvcnMuZmluZCggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCAhZGVjb3JhdG9yLmZuICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cGx1Z2luOiAnZGVjb3JhdG9yJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdERlY29yYXRvci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRlY29yYXRvciA9IHRoaXMsXG5cdFx0XHRcdFx0bm9kZSwgcmVzdWx0LCBhcmdzO1xuXHRcdFx0XHRub2RlID0gZGVjb3JhdG9yLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0aWYgKCBkZWNvcmF0b3IucGFyYW1zICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBbIG5vZGUgXS5jb25jYXQoIGRlY29yYXRvci5wYXJhbXMgKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkZWNvcmF0b3IuZm4uYXBwbHkoIGRlY29yYXRvci5yb290LCBhcmdzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGVjb3JhdG9yLmZuLmNhbGwoIGRlY29yYXRvci5yb290LCBub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhcmVzdWx0IHx8ICFyZXN1bHQudGVhcmRvd24gKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRGVjb3JhdG9yIGRlZmluaXRpb24gbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYSB0ZWFyZG93biBtZXRob2QnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgbWFrZSBzZW5zZT9cblx0XHRcdFx0ZGVjb3JhdG9yLmFjdHVhbCA9IHJlc3VsdDtcblx0XHRcdFx0ZGVjb3JhdG9yLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYWN0dWFsLnVwZGF0ZSApIHtcblx0XHRcdFx0XHR0aGlzLmFjdHVhbC51cGRhdGUuYXBwbHkoIHRoaXMucm9vdCwgdGhpcy5wYXJhbXMgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93biggdHJ1ZSApO1xuXHRcdFx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCB1cGRhdGluZyApIHtcblx0XHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oKTtcblx0XHRcdFx0aWYgKCAhdXBkYXRpbmcgJiYgdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gRGVjb3JhdG9yO1xuXHR9KCBsb2csIGNpcmN1bGFyLCBjb25maWcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9zZWxlY3Qvc3luYy5qcyAqL1xuXHR2YXIgc3luYyA9IGZ1bmN0aW9uKCB0b0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gc3luY1NlbGVjdCggc2VsZWN0RWxlbWVudCApIHtcblx0XHRcdHZhciBzZWxlY3ROb2RlLCBzZWxlY3RWYWx1ZSwgaXNNdWx0aXBsZSwgb3B0aW9ucywgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cdFx0XHRzZWxlY3ROb2RlID0gc2VsZWN0RWxlbWVudC5ub2RlO1xuXHRcdFx0aWYgKCAhc2VsZWN0Tm9kZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IHRvQXJyYXkoIHNlbGVjdE5vZGUub3B0aW9ucyApO1xuXHRcdFx0c2VsZWN0VmFsdWUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICk7XG5cdFx0XHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuXHRcdFx0Ly8gdGhlc2Ugb3B0aW9uc1xuXHRcdFx0aWYgKCBzZWxlY3RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRvcHRpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuXHRcdFx0XHRcdHNob3VsZFNlbGVjdCA9IGlzTXVsdGlwbGUgPyB2YWx1ZUNvbnRhaW5zKCBzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUgKSA6IHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlO1xuXHRcdFx0XHRcdGlmICggc2hvdWxkU2VsZWN0ICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvLnNlbGVjdGVkID0gc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggIW9wdGlvbldhc1NlbGVjdGVkICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgMCBdICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc1sgMCBdLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHNlbGVjdEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHZhbHVlQ29udGFpbnMoIHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSApIHtcblx0XHRcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VsZWN0VmFsdWVbIGkgXSA9PSBvcHRpb25WYWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHRvQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9zZWxlY3QvYnViYmxlLmpzICovXG5cdHZhciBidWJibGUgPSBmdW5jdGlvbiggcnVubG9vcCwgc3luY1NlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBidWJibGVTZWxlY3QoKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG5cdFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c3luY1NlbGVjdCggdGhpcyQwICk7XG5cdFx0XHRcdFx0dGhpcyQwLmRpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgc3luYyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL29wdGlvbi9maW5kUGFyZW50U2VsZWN0LmpzICovXG5cdHZhciBmaW5kUGFyZW50U2VsZWN0ID0gZnVuY3Rpb24gZmluZFBhcmVudFNlbGVjdCggZWxlbWVudCApIHtcblx0XHRkbyB7XG5cdFx0XHRpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9vcHRpb24vaW5pdC5qcyAqL1xuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCBmaW5kUGFyZW50U2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGluaXRPcHRpb24oIG9wdGlvbiwgdGVtcGxhdGUgKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ID0gZmluZFBhcmVudFNlbGVjdCggb3B0aW9uLnBhcmVudCApO1xuXHRcdFx0Ly8gd2UgbWlnaHQgYmUgaW5zaWRlIGEgPGRhdGFsaXN0PiBlbGVtZW50XG5cdFx0XHRpZiAoICFvcHRpb24uc2VsZWN0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaCggb3B0aW9uICk7XG5cdFx0XHQvLyBJZiB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIG1pc3NpbmcsIHVzZSB0aGUgZWxlbWVudCdzIGNvbnRlbnRcblx0XHRcdGlmICggIXRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHRlbXBsYXRlLmEgPSB7fTtcblx0XHRcdH1cblx0XHRcdC8vIC4uLmFzIGxvbmcgYXMgaXQgaXNuJ3QgZGlzYWJsZWRcblx0XHRcdGlmICggdGVtcGxhdGUuYS52YWx1ZSA9PT0gdW5kZWZpbmVkICYmICF0ZW1wbGF0ZS5hLmhhc093blByb3BlcnR5KCAnZGlzYWJsZWQnICkgKSB7XG5cdFx0XHRcdHRlbXBsYXRlLmEudmFsdWUgPSB0ZW1wbGF0ZS5mO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgYnV0IHRoZSA8c2VsZWN0PlxuXHRcdFx0Ly8gYWxyZWFkeSBoYXMgYSB2YWx1ZSwgZGVsZXRlIGl0XG5cdFx0XHRpZiAoICdzZWxlY3RlZCcgaW4gdGVtcGxhdGUuYSAmJiBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRlbGV0ZSB0ZW1wbGF0ZS5hLnNlbGVjdGVkO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGZpbmRQYXJlbnRTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCBlbmZvcmNlQ2FzZSwgY3JlYXRlQXR0cmlidXRlcywgY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzLCBjcmVhdGVUd293YXlCaW5kaW5nLCBjcmVhdGVFdmVudEhhbmRsZXJzLCBEZWNvcmF0b3IsIGJ1YmJsZVNlbGVjdCwgaW5pdE9wdGlvbiwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gRWxlbWVudCRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3M7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5FTEVNRU5UO1xuXHRcdFx0Ly8gc3R1ZmYgd2UnbGwgbmVlZCBsYXRlclxuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UoIHRlbXBsYXRlLmUgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+IGVsZW1lbnRzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdGluaXRPcHRpb24oIHRoaXMsIHRlbXBsYXRlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMgPSBbXTtcblx0XHRcdFx0dGhpcy5idWJibGUgPSBidWJibGVTZWxlY3Q7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlcyggdGhpcywgdGVtcGxhdGUuYSApO1xuXHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMoIHRoaXMsIHRlbXBsYXRlLm0gKTtcblx0XHRcdC8vIGFwcGVuZCBjaGlsZHJlbiwgaWYgdGhlcmUgYXJlIGFueVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5mICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmYsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0XHRwRWxlbWVudDogdGhpc1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgdHdvd2F5IGJpbmRpbmdcblx0XHRcdGlmICggcmFjdGl2ZS50d293YXkgJiYgKCBiaW5kaW5nID0gY3JlYXRlVHdvd2F5QmluZGluZyggdGhpcywgdGVtcGxhdGUuYSApICkgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG5cdFx0XHRcdC8vIHJlZ2lzdGVyIHRoaXMgd2l0aCB0aGUgcm9vdCwgc28gdGhhdCB3ZSBjYW4gZG8gcmFjdGl2ZS51cGRhdGVNb2RlbCgpXG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF0gfHwgKCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBiaW5kaW5nLmtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSBldmVudCBwcm94aWVzXG5cdFx0XHRpZiAoIHRlbXBsYXRlLnYgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycyA9IGNyZWF0ZUV2ZW50SGFuZGxlcnMoIHRoaXMsIHRlbXBsYXRlLnYgKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSBkZWNvcmF0b3Jcblx0XHRcdGlmICggdGVtcGxhdGUubyApIHtcblx0XHRcdFx0dGhpcy5kZWNvcmF0b3IgPSBuZXcgRGVjb3JhdG9yKCB0aGlzLCB0ZW1wbGF0ZS5vICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgdHJhbnNpdGlvbnNcblx0XHRcdHRoaXMuaW50cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MTtcblx0XHRcdHRoaXMub3V0cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50Mjtcblx0XHR9O1xuXHR9KCB0eXBlcywgZW5mb3JjZUNhc2UsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUF0dHJpYnV0ZXMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlVHdvd2F5QmluZGluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlRXZlbnRIYW5kbGVycywgRGVjb3JhdG9yLCBidWJibGUsIGluaXQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvc3RhcnRzV2l0aC5qcyAqL1xuXHR2YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzdGFydHNXaXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0ID09PSBrZXlwYXRoIHx8IHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKTtcblx0XHR9O1xuXHR9KCBzdGFydHNXaXRoS2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2Fzc2lnbk5ld0tleXBhdGguanMgKi9cblx0dmFyIGFzc2lnbk5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhc3NpZ25OZXdLZXlwYXRoKCB0YXJnZXQsIHByb3BlcnR5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGV4aXN0aW5nS2V5cGF0aCA9IHRhcmdldFsgcHJvcGVydHkgXTtcblx0XHRcdGlmICggIWV4aXN0aW5nS2V5cGF0aCB8fCBzdGFydHNXaXRoKCBleGlzdGluZ0tleXBhdGgsIG5ld0tleXBhdGggKSB8fCAhc3RhcnRzV2l0aCggZXhpc3RpbmdLZXlwYXRoLCBvbGRLZXlwYXRoICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRhcmdldFsgcHJvcGVydHkgXSA9IGdldE5ld0tleXBhdGgoIGV4aXN0aW5nS2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGgsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBhc3NpZ25OZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgaSwgc3RvcmFnZSwgbGl2ZVF1ZXJpZXMsIHJhY3RpdmU7XG5cdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlcyApIHtcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcyApIHtcblx0XHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciApIHtcblx0XHRcdFx0cmViaW5kKCB0aGlzLmRlY29yYXRvciApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmViaW5kIGNoaWxkcmVuXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHJlYmluZCggdGhpcy5mcmFnbWVudCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVXBkYXRlIGxpdmUgcXVlcmllcywgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoIGxpdmVRdWVyaWVzID0gdGhpcy5saXZlUXVlcmllcyApIHtcblx0XHRcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblx0XHRcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0bGl2ZVF1ZXJpZXNbIGkgXS5fbWFrZURpcnR5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ub2RlICYmICggc3RvcmFnZSA9IHRoaXMubm9kZS5fcmFjdGl2ZSApICkge1xuXHRcdFx0XHQvLyBhZGp1c3Qga2V5cGF0aCBpZiBuZWVkZWRcblx0XHRcdFx0YXNzaWduTmV3S2V5cGF0aCggc3RvcmFnZSwgJ2tleXBhdGgnLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW5kZXhSZWYgIT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHN0b3JhZ2UuaW5kZXhbIGluZGV4UmVmIF0gPSBuZXdJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZWJpbmQoIHRoaW5nICkge1xuXHRcdFx0XHR0aGluZy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGFzc2lnbk5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9pbWcvcmVuZGVyLmpzICovXG5cdHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJJbWFnZSggaW1nICkge1xuXHRcdHZhciBsb2FkSGFuZGxlcjtcblx0XHQvLyBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heSBuZWVkIHRvIHByZXZlbnQgaXRcblx0XHQvLyBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcblx0XHRpZiAoIGltZy5hdHRyaWJ1dGVzLndpZHRoIHx8IGltZy5hdHRyaWJ1dGVzLmhlaWdodCApIHtcblx0XHRcdGltZy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHdpZHRoID0gaW1nLmdldEF0dHJpYnV0ZSggJ3dpZHRoJyApLFxuXHRcdFx0XHRcdGhlaWdodCA9IGltZy5nZXRBdHRyaWJ1dGUoICdoZWlnaHQnICk7XG5cdFx0XHRcdGlmICggd2lkdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoICd3aWR0aCcsIHdpZHRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBoZWlnaHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoICdoZWlnaHQnLCBoZWlnaHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbWcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIGxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fSwgZmFsc2UgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGluaXQgPSBmdW5jdGlvbiggbG9nLCBjb25maWcsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBnZXRWYWx1ZU9wdGlvbnMgPSB7fTtcblx0XHQvLyBUT0RPIHdoYXQgYXJlIHRoZSBvcHRpb25zP1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyYW5zaXRpb24kaW5pdCggZWxlbWVudCwgdGVtcGxhdGUsIGlzSW50cm8gKSB7XG5cdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXHRcdFx0dC5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHQucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0LmlzSW50cm8gPSBpc0ludHJvO1xuXHRcdFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRpZiAoIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0dC5uYW1lID0gbmFtZTtcblx0XHRcdGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0dC5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIHdheSB0byBpbnRlcnByZXQgZHluYW1pYyBhcmd1bWVudHMgd2l0aG91dCBhbGwgdGhlXG5cdFx0XHRcdC8vICdkZXBlbmRlbmN5IHRocmFzaGluZyc/XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHQucGFyYW1zID0gZnJhZ21lbnQuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdHQuX2ZuID0gY29uZmlnLnJlZ2lzdHJpZXMudHJhbnNpdGlvbnMuZmluZCggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCAhdC5fZm4gKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRwbHVnaW46ICd0cmFuc2l0aW9uJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGxvZywgY29uZmlnLCBjaXJjdWxhciApO1xuXG5cdC8qIHV0aWxzL2NhbWVsQ2FzZS5qcyAqL1xuXHR2YXIgY2FtZWxDYXNlID0gZnVuY3Rpb24oIGh5cGhlbmF0ZWRTdHIgKSB7XG5cdFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSggLy0oW2EtekEtWl0pL2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRyZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy9wcmVmaXguanMgKi9cblx0dmFyIHByZWZpeCA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlICkge1xuXG5cdFx0dmFyIHByZWZpeCwgcHJlZml4Q2FjaGUsIHRlc3RTdHlsZTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdHByZWZpeCA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByZWZpeENhY2hlID0ge307XG5cdFx0XHR0ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApLnN0eWxlO1xuXHRcdFx0cHJlZml4ID0gZnVuY3Rpb24oIHByb3AgKSB7XG5cdFx0XHRcdHZhciBpLCB2ZW5kb3IsIGNhcHBlZDtcblx0XHRcdFx0cHJvcCA9IGNhbWVsQ2FzZSggcHJvcCApO1xuXHRcdFx0XHRpZiAoICFwcmVmaXhDYWNoZVsgcHJvcCBdICkge1xuXHRcdFx0XHRcdGlmICggdGVzdFN0eWxlWyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdHByZWZpeENhY2hlWyBwcm9wIF0gPSBwcm9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB0ZXN0IHZlbmRvcnMuLi5cblx0XHRcdFx0XHRcdGNhcHBlZCA9IHByb3AuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKCAxICk7XG5cdFx0XHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgdmVuZG9yICsgY2FwcGVkIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVsgcHJvcCBdID0gdmVuZG9yICsgY2FwcGVkO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcmVmaXhDYWNoZVsgcHJvcCBdO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWZpeDtcblx0fSggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9nZXRTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kZ2V0U3R5bGUgPSBmdW5jdGlvbiggbGVnYWN5LCBpc0NsaWVudCwgaXNBcnJheSwgcHJlZml4ICkge1xuXG5cdFx0dmFyIGdldFN0eWxlLCBnZXRDb21wdXRlZFN0eWxlO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Z2V0U3R5bGUgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cdFx0XHRnZXRTdHlsZSA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGNvbXB1dGVkU3R5bGUsIHN0eWxlcywgaSwgcHJvcCwgdmFsdWU7XG5cdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVsgcHJlZml4KCBwcm9wcyApIF07XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBwcm9wcyApICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RyYW5zaXRpb24kZ2V0U3R5bGUgbXVzdCBiZSBwYXNzZWQgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIENTUyBwcm9wZXJ0aWVzJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlcyA9IHt9O1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRwcm9wID0gcHJvcHNbIGkgXTtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcCApIF07XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0eWxlc1sgcHJvcCBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0eWxlcztcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBnZXRTdHlsZTtcblx0fSggbGVnYWN5LCBpc0NsaWVudCwgaXNBcnJheSwgcHJlZml4ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3NldFN0eWxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzZXRTdHlsZSA9IGZ1bmN0aW9uKCBwcmVmaXggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0eWxlLCB2YWx1ZSApIHtcblx0XHRcdHZhciBwcm9wO1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbIHByZWZpeCggc3R5bGUgKSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHN0eWxlICkge1xuXHRcdFx0XHRcdGlmICggc3R5bGUuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IHN0eWxlWyBwcm9wIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KCBwcmVmaXggKTtcblxuXHQvKiBzaGFyZWQvVGlja2VyLmpzICovXG5cdHZhciBUaWNrZXIgPSBmdW5jdGlvbiggd2FybiwgZ2V0VGltZSwgYW5pbWF0aW9ucyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgVGlja2VyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZWFzaW5nO1xuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHR0aGlzLnN0ZXAgPSBvcHRpb25zLnN0ZXA7XG5cdFx0XHR0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblx0XHRcdC8vIGVhc2luZ1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLnJvb3QuZWFzaW5nWyBvcHRpb25zLmVhc2luZyBdO1xuXHRcdFx0XHRpZiAoICFlYXNpbmcgKSB7XG5cdFx0XHRcdFx0d2FybiggJ01pc3NpbmcgZWFzaW5nIGZ1bmN0aW9uIChcIicgKyBvcHRpb25zLmVhc2luZyArICdcIikuIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiBmcm9tIFtUT0RPXScgKTtcblx0XHRcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVhc2luZyA9IGVhc2luZztcblx0XHRcdHRoaXMuc3RhcnQgPSBnZXRUaW1lKCk7XG5cdFx0XHR0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdGFuaW1hdGlvbnMuYWRkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRUaWNrZXIucHJvdG90eXBlID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oIG5vdyApIHtcblx0XHRcdFx0dmFyIGVsYXBzZWQsIGVhc2VkO1xuXHRcdFx0XHRpZiAoICF0aGlzLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbm93ID4gdGhpcy5lbmQgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0ZXAoIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb21wbGV0ZSggMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxhcHNlZCA9IG5vdyAtIHRoaXMuc3RhcnQ7XG5cdFx0XHRcdGVhc2VkID0gdGhpcy5lYXNpbmcoIGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uICk7XG5cdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdHRoaXMuc3RlcCggZWFzZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmFib3J0ICkge1xuXHRcdFx0XHRcdHRoaXMuYWJvcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gVGlja2VyO1xuXG5cdFx0ZnVuY3Rpb24gbGluZWFyKCB0ICkge1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggd2FybiwgZ2V0VGltZSwgYW5pbWF0aW9ucyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvdW5wcmVmaXguanMgKi9cblx0dmFyIHVucHJlZml4ID0gZnVuY3Rpb24oIHZlbmRvcnMgKSB7XG5cblx0XHR2YXIgdW5wcmVmaXhQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14tKD86JyArIHZlbmRvcnMuam9pbiggJ3wnICkgKyAnKS0nICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwcm9wICkge1xuXHRcdFx0cmV0dXJuIHByb3AucmVwbGFjZSggdW5wcmVmaXhQYXR0ZXJuLCAnJyApO1xuXHRcdH07XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9oZWxwZXJzL2h5cGhlbmF0ZS5qcyAqL1xuXHR2YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24oIHZlbmRvcnMgKSB7XG5cblx0XHR2YXIgdmVuZG9yUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKD86JyArIHZlbmRvcnMuam9pbiggJ3wnICkgKyAnKShbQS1aXSknICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHR2YXIgaHlwaGVuYXRlZDtcblx0XHRcdGlmICggIXN0ciApIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2ZW5kb3JQYXR0ZXJuLnRlc3QoIHN0ciApICkge1xuXHRcdFx0XHRzdHIgPSAnLScgKyBzdHI7XG5cdFx0XHR9XG5cdFx0XHRoeXBoZW5hdGVkID0gc3RyLnJlcGxhY2UoIC9bQS1aXS9nLCBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGh5cGhlbmF0ZWQ7XG5cdFx0fTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9hbmltYXRlU3R5bGUvY3JlYXRlVHJhbnNpdGlvbnMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgd2FybiwgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlLCBpbnRlcnBvbGF0ZSwgVGlja2VyLCBwcmVmaXgsIHVucHJlZml4LCBoeXBoZW5hdGUgKSB7XG5cblx0XHR2YXIgY3JlYXRlVHJhbnNpdGlvbnMsIHRlc3RTdHlsZSwgVFJBTlNJVElPTiwgVFJBTlNJVElPTkVORCwgQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQsIFRSQU5TSVRJT05fRFVSQVRJT04sIFRSQU5TSVRJT05fUFJPUEVSVFksIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OLCBjYW5Vc2VDc3NUcmFuc2l0aW9ucyA9IHt9LFxuXHRcdFx0Y2Fubm90VXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKS5zdHlsZTtcblx0XHRcdC8vIGRldGVybWluZSBzb21lIGZhY3RzIGFib3V0IG91ciBlbnZpcm9ubWVudFxuXHRcdFx0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0ZXN0U3R5bGUudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG5cdFx0XHRcdFx0VFJBTlNJVElPTkVORCA9ICd0cmFuc2l0aW9uZW5kJztcblx0XHRcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRlc3RTdHlsZS53ZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0VFJBTlNJVElPTiA9ICd3ZWJraXRUcmFuc2l0aW9uJztcblx0XHRcdFx0XHRUUkFOU0lUSU9ORU5EID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KCkgKTtcblx0XHRcdGlmICggVFJBTlNJVElPTiApIHtcblx0XHRcdFx0VFJBTlNJVElPTl9EVVJBVElPTiA9IFRSQU5TSVRJT04gKyAnRHVyYXRpb24nO1xuXHRcdFx0XHRUUkFOU0lUSU9OX1BST1BFUlRZID0gVFJBTlNJVElPTiArICdQcm9wZXJ0eSc7XG5cdFx0XHRcdFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OID0gVFJBTlNJVElPTiArICdUaW1pbmdGdW5jdGlvbic7XG5cdFx0XHR9XG5cdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCB0LCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUgKSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiZWF0IChvdGhlcndpc2UgdGhlIHRhcmdldCBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIGltbWVkaWF0ZWx5KVxuXHRcdFx0XHQvLyBUT0RPIHVzZSBhIGZhc3Rkb20tc3R5bGUgbWVjaGFuaXNtP1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaGFzaFByZWZpeCwganNUcmFuc2l0aW9uc0NvbXBsZXRlLCBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlLCBjaGVja0NvbXBsZXRlLCB0cmFuc2l0aW9uRW5kSGFuZGxlcjtcblx0XHRcdFx0XHRjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGpzVHJhbnNpdGlvbnNDb21wbGV0ZSAmJiBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0XHQvLyB3aWxsIGNoYW5nZXMgdG8gZXZlbnRzIGFuZCBmaXJlIGhhdmUgYW4gdW5leHBlY3RlZCBjb25zZXF1ZW5jZSBoZXJlP1xuXHRcdFx0XHRcdFx0XHR0LnJvb3QuZmlyZSggdC5uYW1lICsgJzplbmQnLCB0Lm5vZGUsIHQuaXNJbnRybyApO1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHQvLyB0aGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBlbGVtZW50cyBjYW4gdXNlIENTUyB0byBhbmltYXRlXG5cdFx0XHRcdFx0Ly8gd2hpY2ggcHJvcGVydGllc1xuXHRcdFx0XHRcdGhhc2hQcmVmaXggPSAoIHQubm9kZS5uYW1lc3BhY2VVUkkgfHwgJycgKSArIHQubm9kZS50YWdOYW1lO1xuXHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgVFJBTlNJVElPTl9QUk9QRVJUWSBdID0gY2hhbmdlZFByb3BlcnRpZXMubWFwKCBwcmVmaXggKS5tYXAoIGh5cGhlbmF0ZSApLmpvaW4oICcsJyApO1xuXHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gXSA9IGh5cGhlbmF0ZSggb3B0aW9ucy5lYXNpbmcgfHwgJ2xpbmVhcicgKTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fRFVSQVRJT04gXSA9IG9wdGlvbnMuZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXHRcdFx0XHRcdHRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKCBjYW1lbENhc2UoIHVucHJlZml4KCBldmVudC5wcm9wZXJ0eU5hbWUgKSApICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHN0aWxsIHRyYW5zaXRpb25pbmcuLi5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIgaSA9IGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0aGFzaCwgb3JpZ2luYWxWYWx1ZSwgaW5kZXgsIHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzID0gW10sXG5cdFx0XHRcdFx0XHRcdHByb3AsIHN1ZmZpeDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRwcm9wID0gY2hhbmdlZFByb3BlcnRpZXNbIGkgXTtcblx0XHRcdFx0XHRcdFx0aGFzaCA9IGhhc2hQcmVmaXggKyBwcm9wO1xuXHRcdFx0XHRcdFx0XHRpZiAoIENTU19UUkFOU0lUSU9OU19FTkFCTEVEICYmICFjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IHN1cmUgaWYgQ1NTIHRyYW5zaXRpb25zIGFyZSBzdXBwb3J0ZWQgZm9yXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyB0YWcvcHJvcGVydHkgY29tYm8sIGZpbmQgb3V0IG5vd1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIWNhblVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZSggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhpcyBwcm9wZXJ0eSBpcyB0cmFuc2l0aW9uYWJsZSBpbiB0aGlzIGJyb3dzZXIsXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBzdHlsZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXQgc3R5bGVcblx0XHRcdFx0XHRcdFx0XHRcdGNhblVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gPSB0LmdldFN0eWxlKCBwcm9wICkgIT0gdG9bIHByb3AgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gPSAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJlc2V0LCBpZiB3ZSdyZSBnb2luZyB0byB1c2UgdGltZXJzIGFmdGVyIGFsbFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBvcmlnaW5hbFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoICFDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCB8fCBjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRpbWVyLWJhc2VkIHN0dWZmXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBvcmlnaW5hbFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZSggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBuZWVkIHRvIHJlbW92ZSB0aGlzIGZyb20gY2hhbmdlZFByb3BlcnRpZXMsIG90aGVyd2lzZSB0cmFuc2l0aW9uRW5kSGFuZGxlclxuXHRcdFx0XHRcdFx0XHRcdC8vIHdpbGwgZ2V0IGNvbmZ1c2VkXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3YXJuKCAnU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZCB3aXRoIHRyYW5zaXRpb25zLiBJZiB5b3Ugc2VlIHRoaXMgbWVzc2FnZSwgcGxlYXNlIGxldCBAUmFjdGl2ZUpTIGtub3cuIFRoYW5rcyEnICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGFuaW1hdGFibGUgYXQgYWxsXG5cdFx0XHRcdFx0XHRcdFx0c3VmZml4ID0gL1teXFxkXSokLy5leGVjKCB0b1sgcHJvcCBdIClbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi50aGVuIGtpY2sgb2ZmIGEgdGltZXItYmFzZWQgdHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHByZWZpeCggcHJvcCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yOiBpbnRlcnBvbGF0ZSggcGFyc2VGbG9hdCggb3JpZ2luYWxWYWx1ZSApLCBwYXJzZUZsb2F0KCB0b1sgcHJvcCBdICkgKSxcblx0XHRcdFx0XHRcdFx0XHRcdHN1ZmZpeDogc3VmZml4XG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBqYXZhc2NyaXB0IHRyYW5zaXRpb25zXG5cdFx0XHRcdFx0XHRpZiAoIHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0bmV3IFRpY2tlcigge1xuXHRcdFx0XHRcdFx0XHRcdHJvb3Q6IHQucm9vdCxcblx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmc6IGNhbWVsQ2FzZSggb3B0aW9ucy5lYXNpbmcgfHwgJycgKSxcblx0XHRcdFx0XHRcdFx0XHRzdGVwOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHByb3AsIGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcC5pbnRlcnBvbGF0b3IoIHBvcyApICsgcHJvcC5zdWZmaXg7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBhbmQgZGVhbCB3aXRoXG5cdFx0XHRcdFx0XHRcdC8vIHRoZSBmYWN0IHRoYXQgaXQgd2lsbCBuZXZlciBmaXJlXG5cdFx0XHRcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCAwICk7XG5cdFx0XHRcdH0sIG9wdGlvbnMuZGVsYXkgfHwgMCApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZVRyYW5zaXRpb25zO1xuXHR9KCBpc0NsaWVudCwgd2FybiwgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlLCBpbnRlcnBvbGF0ZSwgVGlja2VyLCBwcmVmaXgsIHVucHJlZml4LCBoeXBoZW5hdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL3Zpc2liaWxpdHkuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5ID0gZnVuY3Rpb24oIHZlbmRvcnMgKSB7XG5cblx0XHR2YXIgaGlkZGVuLCB2ZW5kb3IsIHByZWZpeCwgaSwgdmlzaWJpbGl0eTtcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRoaWRkZW4gPSAnaGlkZGVuJztcblx0XHRcdHZpc2liaWxpdHkgPSB7fTtcblx0XHRcdGlmICggaGlkZGVuIGluIGRvY3VtZW50ICkge1xuXHRcdFx0XHRwcmVmaXggPSAnJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSB2ZW5kb3JzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1sgaSBdO1xuXHRcdFx0XHRcdGhpZGRlbiA9IHZlbmRvciArICdIaWRkZW4nO1xuXHRcdFx0XHRcdGlmICggaGlkZGVuIGluIGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0cHJlZml4ID0gdmVuZG9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBwcmVmaXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggcHJlZml4ICsgJ3Zpc2liaWxpdHljaGFuZ2UnLCBvbkNoYW5nZSApO1xuXHRcdFx0XHQvLyBpbml0aWFsaXNlXG5cdFx0XHRcdG9uQ2hhbmdlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBnYWgsIHdlJ3JlIGluIGFuIG9sZCBicm93c2VyXG5cdFx0XHRcdGlmICggJ29uZm9jdXNvdXQnIGluIGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1c291dCcsIG9uSGlkZSApO1xuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1c2luJywgb25TaG93ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdwYWdlaGlkZScsIG9uSGlkZSApO1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsIG9uSGlkZSApO1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncGFnZXNob3cnLCBvblNob3cgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3VzJywgb25TaG93ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkNoYW5nZSgpIHtcblx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZG9jdW1lbnRbIGhpZGRlbiBdO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uSGlkZSgpIHtcblx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblNob3coKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmlzaWJpbGl0eTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9hbmltYXRlU3R5bGUvX2FuaW1hdGVTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX19hbmltYXRlU3R5bGUgPSBmdW5jdGlvbiggbGVnYWN5LCBpc0NsaWVudCwgd2FybiwgUHJvbWlzZSwgcHJlZml4LCBjcmVhdGVUcmFuc2l0aW9ucywgdmlzaWJpbGl0eSApIHtcblxuXHRcdHZhciBhbmltYXRlU3R5bGUsIGdldENvbXB1dGVkU3R5bGUsIHJlc29sdmVkO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0YW5pbWF0ZVN0eWxlID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXHRcdFx0YW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24oIHN0eWxlLCB2YWx1ZSwgb3B0aW9ucywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcyxcblx0XHRcdFx0XHR0bztcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gcGFnZSBpc24ndCB2aXNpYmxlLiBEb24ndCBhbmltYXRlIGFueXRoaW5nLCBiZWNhdXNlXG5cdFx0XHRcdC8vIHRoYXQgd2F5IHlvdSdsbCBuZXZlciBnZXQgQ1NTIHRyYW5zaXRpb25lbmQgZXZlbnRzXG5cdFx0XHRcdGlmICggdmlzaWJpbGl0eS5oaWRkZW4gKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRTdHlsZSggc3R5bGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc29sdmVkIHx8ICggcmVzb2x2ZWQgPSBQcm9taXNlLnJlc29sdmUoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR0byA9IHt9O1xuXHRcdFx0XHRcdHRvWyBzdHlsZSBdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG8gPSBzdHlsZTtcblx0XHRcdFx0XHQvLyBzaHVmZmxlIGFyZ3VtZW50c1xuXHRcdFx0XHRcdGNvbXBsZXRlID0gb3B0aW9ucztcblx0XHRcdFx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQXMgb2YgMC4zLjksIHRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgc3VwcGx5IGFuIGBvcHRpb25gIG9iamVjdCB3aXRoXG5cdFx0XHRcdC8vIGBkdXJhdGlvbmAgYW5kIGBlYXNpbmdgIHByb3BlcnRpZXMgKGFuZCBvcHRpb25hbCBgZGVsYXlgKSwgcGx1cyBhXG5cdFx0XHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcblx0XHRcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG5cdFx0XHRcdGlmICggIW9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0d2FybiggJ1RoZSBcIicgKyB0Lm5hbWUgKyAnXCIgdHJhbnNpdGlvbiBkb2VzIG5vdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gYHQuYW5pbWF0ZVN0eWxlKClgLiBUaGlzIHdpbGwgYnJlYWsgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzLzM0MCcgKTtcblx0XHRcdFx0XHRvcHRpb25zID0gdDtcblx0XHRcdFx0XHRjb21wbGV0ZSA9IHQuY29tcGxldGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIHJlc29sdmUgKSB7XG5cdFx0XHRcdFx0dmFyIHByb3BlcnR5TmFtZXMsIGNoYW5nZWRQcm9wZXJ0aWVzLCBjb21wdXRlZFN0eWxlLCBjdXJyZW50LCBmcm9tLCBpLCBwcm9wO1xuXHRcdFx0XHRcdC8vIEVkZ2UgY2FzZSAtIGlmIGR1cmF0aW9uIGlzIHplcm8sIHNldCBzdHlsZSBzeW5jaHJvbm91c2x5IGFuZCBjb21wbGV0ZVxuXHRcdFx0XHRcdGlmICggIW9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHRcdFx0XHR0LnNldFN0eWxlKCB0byApO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBHZXQgYSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHdlJ3JlIGFuaW1hdGluZ1xuXHRcdFx0XHRcdHByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyggdG8gKTtcblx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcyA9IFtdO1xuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBjdXJyZW50IHN0eWxlc1xuXHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0Lm5vZGUgKTtcblx0XHRcdFx0XHRmcm9tID0ge307XG5cdFx0XHRcdFx0aSA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnR5TmFtZXNbIGkgXTtcblx0XHRcdFx0XHRcdGN1cnJlbnQgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgoIHByb3AgKSBdO1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50ID09PSAnMHB4JyApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGtub3cgaWYgd2UncmUgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmdcblx0XHRcdFx0XHRcdGlmICggY3VycmVudCAhPSB0b1sgcHJvcCBdICkge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgIT0gaW5zdGVhZCBvZiAhPT0sIHNvIHdlIGNhbiBjb21wYXJlIHN0cmluZ3Mgd2l0aCBudW1iZXJzXG5cdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnB1c2goIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0Ly8gbWFrZSB0aGUgY29tcHV0ZWQgc3R5bGUgZXhwbGljaXQsIHNvIHdlIGNhbiBhbmltYXRlIHdoZXJlXG5cdFx0XHRcdFx0XHRcdC8vIGUuZy4gaGVpZ2h0PSdhdXRvJ1xuXHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3QgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmcsIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50XG5cdFx0XHRcdFx0Ly8gd2lsbCBuZXZlciBmaXJlISBTbyB3ZSBjb21wbGV0ZSBlYXJseVxuXHRcdFx0XHRcdGlmICggIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMoIHQsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdC8vIElmIGEgY2FsbGJhY2sgd2FzIHN1cHBsaWVkLCBkbyB0aGUgaG9ub3Vyc1xuXHRcdFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGZ1dHVyZVxuXHRcdFx0XHRpZiAoIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdHdhcm4oICd0LmFuaW1hdGVTdHlsZSByZXR1cm5zIGEgUHJvbWlzZSBhcyBvZiAwLjQuMC4gVHJhbnNpdGlvbiBhdXRob3JzIHNob3VsZCBkbyB0LmFuaW1hdGVTdHlsZSguLi4pLnRoZW4oY2FsbGJhY2spJyApO1xuXHRcdFx0XHRcdHByb21pc2UudGhlbiggY29tcGxldGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBhbmltYXRlU3R5bGU7XG5cdH0oIGxlZ2FjeSwgaXNDbGllbnQsIHdhcm4sIFByb21pc2UsIHByZWZpeCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSApO1xuXG5cdC8qIHV0aWxzL2ZpbGxHYXBzLmpzICovXG5cdHZhciBmaWxsR2FwcyA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0dmFyIHNvdXJjZXMgPSBTTElDRSQwLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHNvdXJjZXMuZm9yRWFjaCggZnVuY3Rpb24oIHMgKSB7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHMgKSB7XG5cdFx0XHRcdGlmICggcy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgISgga2V5IGluIHRhcmdldCApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSBzWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9wcm9jZXNzUGFyYW1zLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRwcm9jZXNzUGFyYW1zID0gZnVuY3Rpb24oIGZpbGxHYXBzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJhbXMsIGRlZmF1bHRzICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBwYXJhbXNcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoIHBhcmFtcyA9PT0gJ3Nsb3cnICkge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiA2MDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbXMgPT09ICdmYXN0JyApIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogMjAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogNDAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggIXBhcmFtcyApIHtcblx0XHRcdFx0cGFyYW1zID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmlsbEdhcHMoIHt9LCBwYXJhbXMsIGRlZmF1bHRzICk7XG5cdFx0fTtcblx0fSggZmlsbEdhcHMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvc3RhcnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBUcmFuc2l0aW9uJHN0YXJ0KCkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRub2RlLCBvcmlnaW5hbFN0eWxlLCBjb21wbGV0ZWQ7XG5cdFx0XHRub2RlID0gdC5ub2RlID0gdC5lbGVtZW50Lm5vZGU7XG5cdFx0XHRvcmlnaW5hbFN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKTtcblx0XHRcdC8vIGNyZWF0ZSB0LmNvbXBsZXRlKCkgLSB3ZSBkb24ndCB3YW50IHRoaXMgb24gdGhlIHByb3RvdHlwZSxcblx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBgdGhpc2Agc2lsbGluZXNzIHdoZW4gcGFzc2luZyBpdCBhc1xuXHRcdFx0Ly8gYW4gYXJndW1lbnRcblx0XHRcdHQuY29tcGxldGUgPSBmdW5jdGlvbiggbm9SZXNldCApIHtcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW5vUmVzZXQgJiYgdC5pc0ludHJvICkge1xuXHRcdFx0XHRcdHJlc2V0U3R5bGUoIG5vZGUsIG9yaWdpbmFsU3R5bGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuXHRcdFx0XHR0Ll9tYW5hZ2VyLnJlbW92ZSggdCApO1xuXHRcdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdC8vIElmIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3QsIGFib3J0XG5cdFx0XHRpZiAoICF0Ll9mbiApIHtcblx0XHRcdFx0dC5jb21wbGV0ZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbi5hcHBseSggdC5yb290LCBbIHQgXS5jb25jYXQoIHQucGFyYW1zICkgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRTdHlsZSggbm9kZSwgc3R5bGUgKSB7XG5cdFx0XHRpZiAoIHN0eWxlICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgc3R5bGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE5leHQgbGluZSBpcyBuZWNlc3NhcnksIHRvIHJlbW92ZSBlbXB0eSBzdHlsZSBhdHRyaWJ1dGUhXG5cdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTY3NTUzXG5cdFx0XHRcdG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL19UcmFuc2l0aW9uLmpzICovXG5cdHZhciBUcmFuc2l0aW9uID0gZnVuY3Rpb24oIGluaXQsIGdldFN0eWxlLCBzZXRTdHlsZSwgYW5pbWF0ZVN0eWxlLCBwcm9jZXNzUGFyYW1zLCBzdGFydCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIFRyYW5zaXRpb247XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRUcmFuc2l0aW9uID0gZnVuY3Rpb24oIG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3duZXIsIHRlbXBsYXRlLCBpc0ludHJvICk7XG5cdFx0fTtcblx0XHRUcmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRnZXRTdHlsZTogZ2V0U3R5bGUsXG5cdFx0XHRzZXRTdHlsZTogc2V0U3R5bGUsXG5cdFx0XHRhbmltYXRlU3R5bGU6IGFuaW1hdGVTdHlsZSxcblx0XHRcdHByb2Nlc3NQYXJhbXM6IHByb2Nlc3NQYXJhbXNcblx0XHR9O1xuXHRcdHJldHVybiBUcmFuc2l0aW9uO1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRnZXRTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc2V0U3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9fYW5pbWF0ZVN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRwcm9jZXNzUGFyYW1zLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzdGFydCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlbmRlciA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBpc0FycmF5LCB3YXJuLCBjcmVhdGUsIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBub29wLCBydW5sb29wLCBnZXRJbm5lckNvbnRleHQsIHJlbmRlckltYWdlLCBUcmFuc2l0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciB1cGRhdGVDc3MsIHVwZGF0ZVNjcmlwdDtcblx0XHR1cGRhdGVDc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuXHRcdFx0XHRjb250ZW50ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHRcdC8vIElFOCBoYXMgbm8gc3R5bGVTaGVldCB1bmxlc3MgdGhlcmUncyBhIHR5cGUgdGV4dC9jc3Ncblx0XHRcdGlmICggd2luZG93ICYmIHdpbmRvdy5hcHBlYXJzVG9CZUlFTGVzc0VxdWFsOCApIHtcblx0XHRcdFx0bm9kZS50eXBlID0gJ3RleHQvY3NzJztcblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS5zdHlsZVNoZWV0ICkge1xuXHRcdFx0XHRub2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIG5vZGUuaGFzQ2hpbGROb2RlcygpICkge1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBjb250ZW50ICkgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHVwZGF0ZVNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5ub2RlLnR5cGUgfHwgdGhpcy5ub2RlLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnICkge1xuXHRcdFx0XHR3YXJuKCAnU2NyaXB0IHRhZyB3YXMgdXBkYXRlZC4gVGhpcyBkb2VzIG5vdCBjYXVzZSB0aGUgY29kZSB0byBiZSByZS1ldmFsdWF0ZWQhJyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFbGVtZW50JHJlbmRlcigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHJvb3QgPSB0aGlzLnJvb3QsXG5cdFx0XHRcdG5hbWVzcGFjZSwgbm9kZTtcblx0XHRcdG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSggdGhpcyApO1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQoIHRoaXMubmFtZSwgbmFtZXNwYWNlICk7XG5cdFx0XHQvLyBJcyB0aGlzIGEgdG9wLWxldmVsIG5vZGUgb2YgYSBjb21wb25lbnQ/IElmIHNvLCB3ZSBtYXkgbmVlZCB0byBhZGRcblx0XHRcdC8vIGEgZGF0YS1ydmNndWlkIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG5cdFx0XHQvLyBOT1RFOiBjc3Mgbm8gbG9uZ2VyIGNvcGllZCB0byBpbnN0YW5jZSwgc28gd2UgY2hlY2sgY29uc3RydWN0b3IuY3NzIC1cblx0XHRcdC8vIHdlIGNhbiBlbmhhbmNlIHRvIGhhbmRsZSBpbnN0YW5jZSwgYnV0IHRoaXMgaXMgbW9yZSBcImNvcnJlY3RcIiB3aXRoIGN1cnJlbnRcblx0XHRcdC8vIGZ1bmN0aW9uYWxpdHlcblx0XHRcdGlmICggcm9vdC5jb25zdHJ1Y3Rvci5jc3MgJiYgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgPT09IHJvb3QuZWwgKSB7XG5cdFx0XHRcdHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoICdkYXRhLXJ2Y2d1aWQnLCByb290LmNvbnN0cnVjdG9yLl9ndWlkICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgX3JhY3RpdmUgcHJvcGVydHkgdG8gdGhlIG5vZGUgLSB3ZSB1c2UgdGhpcyBvYmplY3QgdG8gc3RvcmUgc3R1ZmZcblx0XHRcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHRoaXMubm9kZSwgJ19yYWN0aXZlJywge1xuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdHByb3h5OiB0aGlzLFxuXHRcdFx0XHRcdGtleXBhdGg6IGdldElubmVyQ29udGV4dCggdGhpcy5wYXJlbnRGcmFnbWVudCApLFxuXHRcdFx0XHRcdGluZGV4OiB0aGlzLnBhcmVudEZyYWdtZW50LmluZGV4UmVmcyxcblx0XHRcdFx0XHRldmVudHM6IGNyZWF0ZSggbnVsbCApLFxuXHRcdFx0XHRcdHJvb3Q6IHJvb3Rcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0cmV0dXJuIGEucmVuZGVyKCBub2RlICk7XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0cmV0dXJuIGEucmVuZGVyKCBub2RlICk7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBSZW5kZXIgY2hpbGRyZW5cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNjcmlwdD4gZWxlbWVudFxuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3NjcmlwdCcgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVTY3JpcHQ7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdFx0XHRcdC8vIGJ5cGFzcyB3YXJuaW5nIGluaXRpYWxseVxuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm5hbWUgPT09ICdzdHlsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVDc3M7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iaW5kaW5nICYmIHRoaXMuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgucmVuZGVyKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIGRlYWwgd2l0aCB0d28td2F5IGJpbmRpbmdzXG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZTogaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXlcblx0XHRcdC8vIG5lZWQgdG8gcHJldmVudCBpdCBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaW1nJyApIHtcblx0XHRcdFx0cmVuZGVySW1hZ2UoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIGFwcGx5IGRlY29yYXRvcihzKVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciAmJiB0aGlzLmRlY29yYXRvci5mbiApIHtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAuZGVjb3JhdG9yLmluaXQoKTtcblx0XHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHJpZ2dlciBpbnRybyB0cmFuc2l0aW9uXG5cdFx0XHRpZiAoIHJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMuaW50cm8gKSB7XG5cdFx0XHRcdHZhciB0cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb24oIHRoaXMsIHRoaXMuaW50cm8sIHRydWUgKTtcblx0XHRcdFx0cnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24oIHRyYW5zaXRpb24gKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG5cdFx0XHRcdH0sIHRydWUgKTtcblx0XHRcdFx0dGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0cHJvY2Vzc09wdGlvbiggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm5vZGUuYXV0b2ZvY3VzICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UuIFNvbWUgYnJvd3NlcnMgKCpjb3VnaCogRmlyZWZpeCAqY291Z2gqKSBoYXZlIGEgcHJvYmxlbVxuXHRcdFx0XHQvLyB3aXRoIGR5bmFtaWNhbGx5LWdlbmVyYXRlZCBlbGVtZW50cyBoYXZpbmcgYXV0b2ZvY3VzLCBhbmQgdGhleSB3b24ndFxuXHRcdFx0XHQvLyBhbGxvdyB5b3UgdG8gcHJvZ3JhbW1hdGljYWxseSBmb2N1cyB0aGUgZWxlbWVudCB1bnRpbCBpdCdzIGluIHRoZSBET01cblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAubm9kZS5mb2N1cygpO1xuXHRcdFx0XHR9LCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVMaXZlUXVlcmllcyggdGhpcyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0TmFtZXNwYWNlKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSwgeG1sbnMsIHBhcmVudDtcblx0XHRcdC8vIFVzZSBzcGVjaWZpZWQgbmFtZXNwYWNlLi4uXG5cdFx0XHRpZiAoIHhtbG5zID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd4bWxucycgKSApIHtcblx0XHRcdFx0bmFtZXNwYWNlID0geG1sbnM7XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzdmcnICkge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLnN2Zztcblx0XHRcdH0gZWxzZSBpZiAoIHBhcmVudCA9IGVsZW1lbnQucGFyZW50ICkge1xuXHRcdFx0XHQvLyAuLi5vciBIVE1MLCBpZiB0aGUgcGFyZW50IGlzIGEgPGZvcmVpZ25PYmplY3Q+XG5cdFx0XHRcdGlmICggcGFyZW50Lm5hbWUgPT09ICdmb3JlaWduT2JqZWN0JyApIHtcblx0XHRcdFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmh0bWw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlID0gcGFyZW50Lm5vZGUubmFtZXNwYWNlVVJJO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSBlbGVtZW50LnJvb3QuZWwubmFtZXNwYWNlVVJJO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5hbWVzcGFjZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzT3B0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXHRcdFx0aWYgKCAhb3B0aW9uLnNlbGVjdCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0VmFsdWUgPSBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBzZWxlY3RWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggb3B0aW9uLnNlbGVjdC5ub2RlLm11bHRpcGxlICYmIGlzQXJyYXkoIHNlbGVjdFZhbHVlICkgKSB7XG5cdFx0XHRcdGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWVbIGkgXSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVMaXZlUXVlcmllcyggZWxlbWVudCApIHtcblx0XHRcdHZhciBpbnN0YW5jZSwgbGl2ZVF1ZXJpZXMsIGksIHNlbGVjdG9yLCBxdWVyeTtcblx0XHRcdC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIGFkZGVkIHRvIGFueSBsaXZlIHF1ZXJpZXM/XG5cdFx0XHRpbnN0YW5jZSA9IGVsZW1lbnQucm9vdDtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGl2ZVF1ZXJpZXMgPSBpbnN0YW5jZS5fbGl2ZVF1ZXJpZXM7XG5cdFx0XHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gbGl2ZVF1ZXJpZXNbIGkgXTtcblx0XHRcdFx0XHRxdWVyeSA9IGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdO1xuXHRcdFx0XHRcdGlmICggcXVlcnkuX3Rlc3QoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0XHRcdC8vIGtlZXAgcmVnaXN0ZXIgb2YgYXBwbGljYWJsZSBzZWxlY3RvcnMsIGZvciB3aGVuIHdlIHRlYXJkb3duXG5cdFx0XHRcdFx0XHQoIGVsZW1lbnQubGl2ZVF1ZXJpZXMgfHwgKCBlbGVtZW50LmxpdmVRdWVyaWVzID0gW10gKSApLnB1c2goIHF1ZXJ5ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICggaW5zdGFuY2UgPSBpbnN0YW5jZS5fcGFyZW50ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbmFtZXNwYWNlcywgaXNBcnJheSwgd2FybiwgY3JlYXRlLCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgbm9vcCwgcnVubG9vcCwgZ2V0SW5uZXJDb250ZXh0LCByZW5kZXIsIFRyYW5zaXRpb24gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdG9TdHJpbmcgPSBmdW5jdGlvbiggdm9pZEVsZW1lbnROYW1lcywgaXNBcnJheSwgZXNjYXBlSHRtbCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0ciwgZXNjYXBlO1xuXHRcdFx0c3RyID0gJzwnICsgKCB0aGlzLnRlbXBsYXRlLnkgPyAnIURPQ1RZUEUnIDogdGhpcy50ZW1wbGF0ZS5lICk7XG5cdFx0XHRzdHIgKz0gdGhpcy5hdHRyaWJ1dGVzLm1hcCggc3RyaW5naWZ5QXR0cmlidXRlICkuam9pbiggJycgKSArIHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLm1hcCggc3RyaW5naWZ5QXR0cmlidXRlICkuam9pbiggJycgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyAmJiBvcHRpb25Jc1NlbGVjdGVkKCB0aGlzICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnIHNlbGVjdGVkJztcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHR3by13YXkgcmFkaW8gbmFtZSBiaW5kaW5nc1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpbnB1dCcgJiYgaW5wdXRJc0NoZWNrZWRSYWRpbyggdGhpcyApICkge1xuXHRcdFx0XHRzdHIgKz0gJyBjaGVja2VkJztcblx0XHRcdH1cblx0XHRcdHN0ciArPSAnPic7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB0ZXh0YXJlYVxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICd0ZXh0YXJlYScgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdHIgKz0gZXNjYXBlSHRtbCggdGhpcy5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSApO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c3RyICs9IHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdGVzY2FwZSA9IHRoaXMubmFtZSAhPT0gJ3NjcmlwdCcgJiYgdGhpcy5uYW1lICE9PSAnc3R5bGUnO1xuXHRcdFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZXNjYXBlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgYSBjbG9zaW5nIHRhZyBpZiB0aGlzIGlzbid0IGEgdm9pZCBlbGVtZW50XG5cdFx0XHRpZiAoICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoIHRoaXMudGVtcGxhdGUuZSApICkge1xuXHRcdFx0XHRzdHIgKz0gJzwvJyArIHRoaXMudGVtcGxhdGUuZSArICc+Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG9wdGlvbklzU2VsZWN0ZWQoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXHRcdFx0b3B0aW9uVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50LnNlbGVjdCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0VmFsdWUgPSBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSAmJiBpc0FycmF5KCBzZWxlY3RWYWx1ZSApICkge1xuXHRcdFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIHNlbGVjdFZhbHVlWyBpIF0gPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbnB1dElzQ2hlY2tlZFJhZGlvKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMsIHR5cGVBdHRyaWJ1dGUsIHZhbHVlQXR0cmlidXRlLCBuYW1lQXR0cmlidXRlO1xuXHRcdFx0YXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblx0XHRcdHR5cGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnR5cGU7XG5cdFx0XHR2YWx1ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudmFsdWU7XG5cdFx0XHRuYW1lQXR0cmlidXRlID0gYXR0cmlidXRlcy5uYW1lO1xuXHRcdFx0aWYgKCAhdHlwZUF0dHJpYnV0ZSB8fCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSAncmFkaW8nIHx8ICF2YWx1ZUF0dHJpYnV0ZSB8fCAhbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWVBdHRyaWJ1dGUudmFsdWUgPT09IG5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLnZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnlBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHZhciBzdHIgPSBhdHRyaWJ1dGUudG9TdHJpbmcoKTtcblx0XHRcdHJldHVybiBzdHIgPyAnICcgKyBzdHIgOiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB2b2lkRWxlbWVudE5hbWVzLCBpc0FycmF5LCBlc2NhcGVIdG1sICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X3NwZWNpYWxfb3B0aW9uX3VuYmluZCA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5iaW5kT3B0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3QgKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggb3B0aW9uLnNlbGVjdC5vcHRpb25zLCBvcHRpb24gKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVuYmluZCA9IGZ1bmN0aW9uKCB1bmJpbmRPcHRpb24gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFbGVtZW50JHVuYmluZCgpIHtcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5iaW5kaW5nICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj5cblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0dW5iaW5kT3B0aW9uKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCB4ICkge1xuXHRcdFx0eC51bmJpbmQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfc3BlY2lhbF9vcHRpb25fdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVucmVuZGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIFRyYW5zaXRpb24gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0dmFyIGJpbmRpbmcsIGJpbmRpbmdzO1xuXHRcdFx0aWYgKCB0aGlzLnRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbi5jb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGV0YWNoIGFzIHNvb24gYXMgd2UgY2FuXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuXHRcdFx0XHQvLyB0aGVpciBwYXJlbnQgPHNlbGVjdD4gZWxlbWVudCBzeW5jcyBjb3JyZWN0bHksIGFuZFxuXHRcdFx0XHQvLyBzaW5jZSBvcHRpb24gZWxlbWVudHMgY2FuJ3QgaGF2ZSB0cmFuc2l0aW9ucyBhbnl3YXlcblx0XHRcdFx0dGhpcy5kZXRhY2goKTtcblx0XHRcdH0gZWxzZSBpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHJ1bmxvb3AuZGV0YWNoV2hlblJlYWR5KCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG5cdFx0XHQvLyBoYW5kbGVkIGJ5IHRoZSBjdXJyZW50IHRyYW5zaXRpb25NYW5hZ2VyXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy51bnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IG51bGw7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF07XG5cdFx0XHRcdGJpbmRpbmdzLnNwbGljZSggYmluZGluZ3MuaW5kZXhPZiggYmluZGluZyApLCAxICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgudW5yZW5kZXIoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciApIHtcblx0XHRcdFx0dGhpcy5kZWNvcmF0b3IudGVhcmRvd24oKTtcblx0XHRcdH1cblx0XHRcdC8vIHRyaWdnZXIgb3V0cm8gdHJhbnNpdGlvbiBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggdGhpcy5yb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLm91dHJvICkge1xuXHRcdFx0XHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKCB0aGlzLCB0aGlzLm91dHJvLCBmYWxzZSApO1xuXHRcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIHRoaXMgbm9kZSBmcm9tIGFueSBsaXZlIHF1ZXJpZXNcblx0XHRcdGlmICggdGhpcy5saXZlUXVlcmllcyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlUXVlcmllcyggZWxlbWVudCApIHtcblx0XHRcdHZhciBxdWVyeSwgc2VsZWN0b3IsIGk7XG5cdFx0XHRpID0gZWxlbWVudC5saXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0cXVlcnkgPSBlbGVtZW50LmxpdmVRdWVyaWVzWyBpIF07XG5cdFx0XHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cdFx0XHRcdHF1ZXJ5Ll9yZW1vdmUoIGVsZW1lbnQubm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHJ1bmxvb3AsIFRyYW5zaXRpb24gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvX0VsZW1lbnQuanMgKi9cblx0dmFyIEVsZW1lbnQgPSBmdW5jdGlvbiggYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgZ2V0QXR0cmlidXRlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgRWxlbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRFbGVtZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gRWxlbWVudDtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZE5leHROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZ2V0QXR0cmlidXRlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5yZW5kZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvZGVJbmRlbnQuanMgKi9cblx0dmFyIGRlSW5kZW50ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGVtcHR5ID0gL15cXHMqJC8sXG5cdFx0XHRsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKi87XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0dmFyIGxpbmVzLCBmaXJzdExpbmUsIGxhc3RMaW5lLCBtaW5JbmRlbnQ7XG5cdFx0XHRsaW5lcyA9IHN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBsaW5lLCBpZiB0aGV5IG9ubHkgY29udGFpbiB3aGl0ZXNwYWNlXG5cdFx0XHRmaXJzdExpbmUgPSBsaW5lc1sgMCBdO1xuXHRcdFx0aWYgKCBmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBmaXJzdExpbmUgKSApIHtcblx0XHRcdFx0bGluZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHRcdGxhc3RMaW5lID0gbGluZXNbIGxpbmVzLmxlbmd0aCAtIDEgXTtcblx0XHRcdGlmICggbGFzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBsYXN0TGluZSApICkge1xuXHRcdFx0XHRsaW5lcy5wb3AoKTtcblx0XHRcdH1cblx0XHRcdG1pbkluZGVudCA9IGxpbmVzLnJlZHVjZSggcmVkdWNlciwgbnVsbCApO1xuXHRcdFx0aWYgKCBtaW5JbmRlbnQgKSB7XG5cdFx0XHRcdHN0ciA9IGxpbmVzLm1hcCggZnVuY3Rpb24oIGxpbmUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUucmVwbGFjZSggbWluSW5kZW50LCAnJyApO1xuXHRcdFx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZHVjZXIoIHByZXZpb3VzLCBsaW5lICkge1xuXHRcdFx0dmFyIGxpbmVJbmRlbnQgPSBsZWFkaW5nV2hpdGVzcGFjZS5leGVjKCBsaW5lIClbIDAgXTtcblx0XHRcdGlmICggcHJldmlvdXMgPT09IG51bGwgfHwgbGluZUluZGVudC5sZW5ndGggPCBwcmV2aW91cy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBsaW5lSW5kZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZXZpb3VzO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvZ2V0UGFydGlhbFRlbXBsYXRlLmpzICovXG5cdHZhciBnZXRQYXJ0aWFsVGVtcGxhdGUgPSBmdW5jdGlvbiggbG9nLCBjb25maWcsIHBhcnNlciwgZGVJbmRlbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBnZXRQYXJ0aWFsVGVtcGxhdGUoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcGFydGlhbDtcblx0XHRcdC8vIElmIHRoZSBwYXJ0aWFsIGluIGluc3RhbmNlIG9yIHZpZXcgaGVpcmFyY2h5IGluc3RhbmNlcywgZ3JlYXRcblx0XHRcdGlmICggcGFydGlhbCA9IGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRpYWw7XG5cdFx0XHR9XG5cdFx0XHQvLyBEb2VzIGl0IGV4aXN0IG9uIHRoZSBwYWdlIGFzIGEgc2NyaXB0IHRhZz9cblx0XHRcdHBhcnRpYWwgPSBwYXJzZXIuZnJvbUlkKCBuYW1lLCB7XG5cdFx0XHRcdG5vVGhyb3c6IHRydWVcblx0XHRcdH0gKTtcblx0XHRcdGlmICggcGFydGlhbCApIHtcblx0XHRcdFx0Ly8gaXMgdGhpcyBuZWNlc3Nhcnk/XG5cdFx0XHRcdHBhcnRpYWwgPSBkZUluZGVudCggcGFydGlhbCApO1xuXHRcdFx0XHQvLyBwYXJzZSBhbmQgcmVnaXN0ZXIgdG8gdGhpcyByYWN0aXZlIGluc3RhbmNlXG5cdFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoIHBhcnRpYWwsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0XHQvLyByZWdpc3RlciAoYW5kIHJldHVybiBtYWluIHBhcnRpYWwgaWYgdGhlcmUgYXJlIG90aGVycyBpbiB0aGUgdGVtcGxhdGUpXG5cdFx0XHRcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzWyBuYW1lIF0gPSBwYXJzZWQudDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFydGlhbEZyb21SZWdpc3RyeSggcmFjdGl2ZSwgbmFtZSApIHtcblx0XHRcdHZhciBwYXJ0aWFscyA9IGNvbmZpZy5yZWdpc3RyaWVzLnBhcnRpYWxzO1xuXHRcdFx0Ly8gZmluZCBmaXJzdCBpbnN0YW5jZSBpbiB0aGUgcmFjdGl2ZSBvciB2aWV3IGhpZXJhcmNoeSB0aGF0IGhhcyB0aGlzIHBhcnRpYWxcblx0XHRcdHZhciBpbnN0YW5jZSA9IHBhcnRpYWxzLmZpbmRJbnN0YW5jZSggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJ0aWFsID0gaW5zdGFuY2UucGFydGlhbHNbIG5hbWUgXSxcblx0XHRcdFx0Zm47XG5cdFx0XHQvLyBwYXJ0aWFsIGlzIGEgZnVuY3Rpb24/XG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRmbiA9IHBhcnRpYWwuYmluZCggaW5zdGFuY2UgKTtcblx0XHRcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLnBhcnRpYWxzLmhhc093blByb3BlcnR5KCBuYW1lICk7XG5cdFx0XHRcdHBhcnRpYWwgPSBmbiggaW5zdGFuY2UuZGF0YSwgcGFyc2VyICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFwYXJ0aWFsICkge1xuXHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4nLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdHJlZ2lzdHJ5OiAncGFydGlhbCcsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFkZGVkIG1hbnVhbGx5IHRvIHRoZSByZWdpc3RyeSxcblx0XHRcdC8vIGJ1dCBoYXNuJ3QgYmVlbiBwYXJzZWQsIHBhcnNlIGl0IG5vd1xuXHRcdFx0aWYgKCAhcGFyc2VyLmlzUGFyc2VkKCBwYXJ0aWFsICkgKSB7XG5cdFx0XHRcdC8vIHVzZSB0aGUgcGFyc2VPcHRpb25zIG9mIHRoZSByYWN0aXZlIGluc3RhbmNlIG9uIHdoaWNoIGl0IHdhcyBmb3VuZFxuXHRcdFx0XHR2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKCBwYXJ0aWFsLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCBpbnN0YW5jZSApICk7XG5cdFx0XHRcdC8vIFBhcnRpYWxzIGNhbm5vdCBjb250YWluIG5lc3RlZCBwYXJ0aWFscyFcblx0XHRcdFx0Ly8gVE9ETyBhZGQgYSB0ZXN0IGZvciB0aGlzXG5cdFx0XHRcdGlmICggcGFyc2VkLnAgKSB7XG5cdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogJ25vTmVzdGVkUGFydGlhbHMnLFxuXHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRybmFtZTogbmFtZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiBmbiwgdXNlIGluc3RhbmNlIHRvIHN0b3JlIHJlc3VsdCwgb3RoZXJ3aXNlIG5lZWRzIHRvIGdvXG5cdFx0XHRcdC8vIGluIHRoZSBjb3JyZWN0IHBvaW50IGluIHByb3RvdHlwZSBjaGFpbiBvbiBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvclxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZm4gPyBpbnN0YW5jZSA6IHBhcnRpYWxzLmZpbmRPd25lciggaW5zdGFuY2UsIG5hbWUgKTtcblx0XHRcdFx0Ly8gbWF5IGJlIGEgdGVtcGxhdGUgd2l0aCBwYXJ0aWFscywgd2hpY2ggbmVlZCB0byBiZSByZWdpc3RlcmVkIGFuZCBtYWluIHRlbXBsYXRlIGV4dHJhY3RlZFxuXHRcdFx0XHR0YXJnZXQucGFydGlhbHNbIG5hbWUgXSA9IHBhcnRpYWwgPSBwYXJzZWQudDtcblx0XHRcdH1cblx0XHRcdC8vIHN0b3JlIGZvciByZXNldFxuXHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0cGFydGlhbC5fZm4gPSBmbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJ0aWFsLnYgPyBwYXJ0aWFsLnQgOiBwYXJ0aWFsO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGxvZywgY29uZmlnLCBwYXJzZXIsIGRlSW5kZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2FwcGx5SW5kZW50LmpzICovXG5cdHZhciBhcHBseUluZGVudCA9IGZ1bmN0aW9uKCBzdHJpbmcsIGluZGVudCApIHtcblx0XHR2YXIgaW5kZW50ZWQ7XG5cdFx0aWYgKCAhaW5kZW50ICkge1xuXHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHR9XG5cdFx0aW5kZW50ZWQgPSBzdHJpbmcuc3BsaXQoICdcXG4nICkubWFwKCBmdW5jdGlvbiggbGluZSwgbm90Rmlyc3RMaW5lICkge1xuXHRcdFx0cmV0dXJuIG5vdEZpcnN0TGluZSA/IGluZGVudCArIGxpbmUgOiBsaW5lO1xuXHRcdH0gKS5qb2luKCAnXFxuJyApO1xuXHRcdHJldHVybiBpbmRlbnRlZDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvX1BhcnRpYWwuanMgKi9cblx0dmFyIFBhcnRpYWwgPSBmdW5jdGlvbiggbG9nLCB0eXBlcywgZ2V0UGFydGlhbFRlbXBsYXRlLCBhcHBseUluZGVudCwgY2lyY3VsYXIsIHJ1bmxvb3AsIE11c3RhY2hlLCByZWJpbmQsIHVuYmluZCApIHtcblxuXHRcdHZhciBQYXJ0aWFsLCBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdFBhcnRpYWwgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlBBUlRJQUw7XG5cdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUucjtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHQvLyBJZiB0aGlzIGRpZG4ndCByZXNvbHZlLCBpdCBtb3N0IGxpa2VseSBtZWFucyB3ZSBoYXZlIGEgbmFtZWQgcGFydGlhbFxuXHRcdFx0Ly8gKGkuZS4gYHt7PmZvb319YCBtZWFucyAndXNlIHRoZSBmb28gcGFydGlhbCcsIG5vdCAndXNlIHRoZSBwYXJ0aWFsXG5cdFx0XHQvLyB3aG9zZSBuYW1lIGlzIHRoZSB2YWx1ZSBvZiBgZm9vYCcpXG5cdFx0XHRpZiAoICF0aGlzLmtleXBhdGggJiYgKCB0ZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yb290LCB0aGlzLm5hbWUgKSApICkge1xuXHRcdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0XHQvLyBwcmV2ZW50IGFueSBmdXJ0aGVyIGNoYW5nZXNcblx0XHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSggdGVtcGxhdGUgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFBhcnRpYWwucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRkZXRhY2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbDogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0cmViaW5kLmNhbGwoIHRoaXMsIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdFx0Ly8gbm90aGluZyBoYXMgY2hhbmdlZCwgc28gbm8gd29yayB0byBiZSBkb25lXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlKCB0aGlzLnJvb3QsICcnICsgdmFsdWUgKTtcblx0XHRcdFx0Ly8gd2UgbWF5IGJlIGhlcmUgaWYgd2UgaGF2ZSBhIHBhcnRpYWwgbGlrZSBge3s+Zm9vfX1gIGFuZCBgZm9vYCBpcyB0aGVcblx0XHRcdFx0Ly8gbmFtZSBvZiBib3RoIGEgZGF0YSBwcm9wZXJ0eSAod2hvc2UgdmFsdWUgSVNOJ1QgdGhlIG5hbWUgb2YgYSBwYXJ0aWFsKVxuXHRcdFx0XHQvLyBhbmQgYSBwYXJ0aWFsLiBJbiB0aG9zZSBjYXNlcywgdGhpcyBiZWNvbWVzIGEgbmFtZWQgcGFydGlhbFxuXHRcdFx0XHRpZiAoICF0ZW1wbGF0ZSAmJiB0aGlzLm5hbWUgJiYgKCB0ZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yb290LCB0aGlzLm5hbWUgKSApICkge1xuXHRcdFx0XHRcdHVuYmluZC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF0ZW1wbGF0ZSApIHtcblx0XHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRcdGRlYnVnOiB0aGlzLnJvb3QuZGVidWcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnbm9UZW1wbGF0ZUZvclBhcnRpYWwnLFxuXHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB0aGlzLm5hbWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSggdGVtcGxhdGUgfHwgW10gKTtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRUZW1wbGF0ZTogZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IHRoaXMuZnJhZ21lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IHRoaXMucGFyZW50RnJhZ21lbnQucEVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiggdG9TdHJpbmcgKSB7XG5cdFx0XHRcdHZhciBzdHJpbmcsIHByZXZpb3VzSXRlbSwgbGFzdExpbmUsIG1hdGNoO1xuXHRcdFx0XHRzdHJpbmcgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0b1N0cmluZyApO1xuXHRcdFx0XHRwcmV2aW91c0l0ZW0gPSB0aGlzLnBhcmVudEZyYWdtZW50Lml0ZW1zWyB0aGlzLmluZGV4IC0gMSBdO1xuXHRcdFx0XHRpZiAoICFwcmV2aW91c0l0ZW0gfHwgcHJldmlvdXNJdGVtLnR5cGUgIT09IHR5cGVzLlRFWFQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0TGluZSA9IHByZXZpb3VzSXRlbS50ZXh0LnNwbGl0KCAnXFxuJyApLnBvcCgpO1xuXHRcdFx0XHRpZiAoIG1hdGNoID0gL15cXHMrJC8uZXhlYyggbGFzdExpbmUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYXBwbHlJbmRlbnQoIHN0cmluZywgbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5pc05hbWVkICkge1xuXHRcdFx0XHRcdC8vIGR5bmFtaWMgcGFydGlhbCAtIG5lZWQgdG8gdW5iaW5kIHNlbGZcblx0XHRcdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0LCBhbmNob3I7XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIudW5yZW5kZXIoIHRydWUgKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50VG9SZW5kZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50VG9SZW5kZXIucmVuZGVyKCkgKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblx0XHRcdFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgYW5jaG9yICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBQYXJ0aWFsO1xuXHR9KCBsb2csIHR5cGVzLCBnZXRQYXJ0aWFsVGVtcGxhdGUsIGFwcGx5SW5kZW50LCBjaXJjdWxhciwgcnVubG9vcCwgTXVzdGFjaGUsIHJlYmluZCwgdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvZ2V0Q29tcG9uZW50LmpzICovXG5cdHZhciBnZXRDb21wb25lbnQgPSBmdW5jdGlvbiggY29uZmlnLCBsb2csIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmU7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRSYWN0aXZlID0gY2lyY3VsYXIuUmFjdGl2ZTtcblx0XHR9ICk7XG5cdFx0Ly8gZmluZHMgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBpbiB0aGUgcmVnaXN0cnkgb3IgdmlldyBoaWVyYXJjaHkgcmVnaXN0cmllc1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRDb21wb25lbnQoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50LCBpbnN0YW5jZSA9IGNvbmZpZy5yZWdpc3RyaWVzLmNvbXBvbmVudHMuZmluZEluc3RhbmNlKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRjb21wb25lbnQgPSBpbnN0YW5jZS5jb21wb25lbnRzWyBuYW1lIF07XG5cdFx0XHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcblx0XHRcdFx0aWYgKCAhY29tcG9uZW50Ll9wYXJlbnQgKSB7XG5cdFx0XHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcblx0XHRcdFx0XHR2YXIgZm4gPSBjb21wb25lbnQuYmluZCggaW5zdGFuY2UgKTtcblx0XHRcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApO1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGZuKCBpbnN0YW5jZS5kYXRhICk7XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4nLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cmVnaXN0cnk6ICdjb21wb25lbnQnLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0Ly9hbGxvdyBzdHJpbmcgbG9va3VwXG5cdFx0XHRcdFx0XHRjb21wb25lbnQgPSBnZXRDb21wb25lbnQoIHJhY3RpdmUsIGNvbXBvbmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnQuX2ZuID0gZm47XG5cdFx0XHRcdFx0aW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdID0gY29tcG9uZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50O1xuXHRcdH07XG5cdH0oIGNvbmZpZywgbG9nLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGRldGFjaCA9IGZ1bmN0aW9uKCBIb29rICkge1xuXG5cdFx0dmFyIGRldGFjaEhvb2sgPSBuZXcgSG9vayggJ2RldGFjaCcgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gQ29tcG9uZW50JGRldGFjaCgpIHtcblx0XHRcdHZhciBkZXRhY2hlZCA9IHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHRkZXRhY2hIb29rLmZpcmUoIHRoaXMuaW5zdGFuY2UgKTtcblx0XHRcdHJldHVybiBkZXRhY2hlZDtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICk7XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdGlmICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSB0aGlzLm5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmROZXh0Tm9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBDb21wb25lbnQkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL0NvbXBvbmVudFBhcmFtZXRlci5qcyAqL1xuXHR2YXIgQ29tcG9uZW50UGFyYW1ldGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBDb21wb25lbnRQYXJhbWV0ZXI7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRDb21wb25lbnRQYXJhbWV0ZXIgPSBmdW5jdGlvbiggY29tcG9uZW50LCBrZXksIHZhbHVlICkge1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXHRcdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB2YWx1ZSxcblx0XHRcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdH07XG5cdFx0Q29tcG9uZW50UGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5LCB2YWx1ZSApO1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5jb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50UGFyYW1ldGVyO1xuXHR9KCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlTW9kZWwvUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlci5qcyAqL1xuXHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciA9IGZ1bmN0aW9uKCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKSB7XG5cblx0XHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciA9IGZ1bmN0aW9uKCBjb21wb25lbnQsIGNoaWxkS2V5cGF0aCwgdGVtcGxhdGUsIHRvQmluZCApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dGhpcy5yb290ID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZWFkeSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5oYXNoID0gbnVsbDtcblx0XHRcdHRoaXMucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKCB0aGlzLCB0ZW1wbGF0ZSwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdC8vIEFyZSB3ZSB1cGRhdGluZyBhbiBleGlzdGluZyBiaW5kaW5nP1xuXHRcdFx0XHRpZiAoIHRoaXMkMC5iaW5kaW5nIHx8ICggdGhpcyQwLmJpbmRpbmcgPSBjb21wb25lbnQuYmluZGluZ3NbIHRoaXMkMC5oYXNoIF0gKSApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuYmluZGluZ3NbIHRoaXMkMC5oYXNoIF0gPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMkMC5iaW5kaW5nLnJlYmluZCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMkMC5oYXNoID0ga2V5cGF0aCArICc9JyArIGNoaWxkS2V5cGF0aDtcblx0XHRcdFx0XHRjb21wb25lbnQuYmluZGluZ3NbIHRoaXMkMC5oYXNoIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcyQwLnJlYWR5ICkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGNoaWxkIGluc3RhbmNlIGlzbid0IGNyZWF0ZWQgeWV0LCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgYmluZGluZyBsYXRlclxuXHRcdFx0XHRcdFx0dG9CaW5kLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGRLZXlwYXRoOiBjaGlsZEtleXBhdGgsXG5cdFx0XHRcdFx0XHRcdHBhcmVudEtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBjb21wb25lbnQucm9vdCwga2V5cGF0aCwgY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMkMC52YWx1ZSA9IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyO1xuXHR9KCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL19jcmVhdGVNb2RlbC5qcyAqL1xuXHR2YXIgY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiggdHlwZXMsIHBhcnNlSlNPTiwgcmVzb2x2ZVJlZiwgQ29tcG9uZW50UGFyYW1ldGVyLCBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGNvbXBvbmVudCwgZGVmYXVsdERhdGEsIGF0dHJpYnV0ZXMsIHRvQmluZCApIHtcblx0XHRcdHZhciBkYXRhID0ge30sXG5cdFx0XHRcdGtleSwgdmFsdWU7XG5cdFx0XHQvLyBzb21lIHBhcmFtZXRlcnMsIGUuZy4gZm9vPVwiVGhlIHZhbHVlIGlzIHt7YmFyfX1cIiwgYXJlICdjb21wbGV4JyAtIGluXG5cdFx0XHQvLyBvdGhlciB3b3Jkcywgd2UgbmVlZCB0byBjb25zdHJ1Y3QgYSBzdHJpbmcgZnJhZ21lbnQgdG8gd2F0Y2hcblx0XHRcdC8vIHdoZW4gdGhleSBjaGFuZ2UuIFdlIHN0b3JlIHRoZXNlIHNvIHRoZXkgY2FuIGJlIHRvcm4gZG93biBsYXRlclxuXHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzID0gW107XG5cdFx0XHRmb3IgKCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGdldFZhbHVlKCBjb21wb25lbnQsIGtleSwgYXR0cmlidXRlc1sga2V5IF0sIHRvQmluZCApO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCB8fCBkZWZhdWx0RGF0YVsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZSwgdG9CaW5kICkge1xuXHRcdFx0dmFyIHBhcmFtZXRlciwgcGFyc2VkLCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIGtleXBhdGgsIGluZGV4UmVmO1xuXHRcdFx0cGFyZW50SW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHN0YXRpYyB2YWx1ZSwgZ3JlYXRcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCB0ZW1wbGF0ZSApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJzZWQudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBudWxsLCB3ZSB0cmVhdCBpdCBhcyBhIGJvb2xlYW4gYXR0cmlidXRlIChpLmUuIHRydWUpXG5cdFx0XHRpZiAoIHRlbXBsYXRlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIFNpbmdsZSBpbnRlcnBvbGF0b3I/XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmxlbmd0aCA9PT0gMSAmJiB0ZW1wbGF0ZVsgMCBdLnQgPT09IHR5cGVzLklOVEVSUE9MQVRPUiApIHtcblx0XHRcdFx0Ly8gSWYgaXQncyBhIHJlZ3VsYXIgaW50ZXJwb2xhdG9yLCB3ZSBiaW5kIHRvIGl0XG5cdFx0XHRcdGlmICggdGVtcGxhdGVbIDAgXS5yICkge1xuXHRcdFx0XHRcdC8vIElzIGl0IGFuIGluZGV4IHJlZmVyZW5jZT9cblx0XHRcdFx0XHRpZiAoIHBhcmVudEZyYWdtZW50LmluZGV4UmVmcyAmJiBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnNbIGluZGV4UmVmID0gdGVtcGxhdGVbIDAgXS5yIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGNvbXBvbmVudC5pbmRleFJlZkJpbmRpbmdzWyBpbmRleFJlZiBdID0ga2V5O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50LmluZGV4UmVmc1sgaW5kZXhSZWYgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gVE9ETyB3aGF0IGFib3V0IHJlZmVyZW5jZXMgdGhhdCByZXNvbHZlIGxhdGU/IFNob3VsZCB0aGVzZSBiZSBjb25zaWRlcmVkP1xuXHRcdFx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCBwYXJlbnRJbnN0YW5jZSwgdGVtcGxhdGVbIDAgXS5yLCBwYXJlbnRGcmFnbWVudCApIHx8IHRlbXBsYXRlWyAwIF0ucjtcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB1cCBiaW5kaW5ncyBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQsIGJ1dFxuXHRcdFx0XHRcdC8vIHdlIGNhbid0IGRvIGl0IHlldCBiZWNhdXNlIHRoZSBjaGlsZCBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0XG5cdFx0XHRcdFx0Ly8geWV0IC0gc28gd2UgbWFrZSBhIG5vdGUgaW5zdGVhZFxuXHRcdFx0XHRcdHRvQmluZC5wdXNoKCB7XG5cdFx0XHRcdFx0XHRjaGlsZEtleXBhdGg6IGtleSxcblx0XHRcdFx0XHRcdHBhcmVudEtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudEluc3RhbmNlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBpdCdzIGEgcmVmZXJlbmNlIGV4cHJlc3Npb24gKGUuZy4gYHt7Zm9vW2Jhcl19fWApLCB3ZSBuZWVkXG5cdFx0XHRcdC8vIHRvIHdhdGNoIHRoZSBrZXlwYXRoIGFuZCBjcmVhdGUvZGVzdHJveSBiaW5kaW5nc1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlWyAwIF0ucnggKSB7XG5cdFx0XHRcdFx0cGFyYW1ldGVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZVsgMCBdLnJ4LCB0b0JpbmQgKTtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMucHVzaCggcGFyYW1ldGVyICk7XG5cdFx0XHRcdFx0cGFyYW1ldGVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gcGFyYW1ldGVyLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGEgJ2NvbXBsZXggcGFyYW1ldGVyJyAtIHdlIG5lZWQgdG8gY3JlYXRlIGEgZnVsbC1ibG93biBzdHJpbmdcblx0XHRcdC8vIGZyYWdtZW50IGluIG9yZGVyIHRvIGV2YWx1YXRlIGFuZCBvYnNlcnZlIGl0cyB2YWx1ZVxuXHRcdFx0cGFyYW1ldGVyID0gbmV3IENvbXBvbmVudFBhcmFtZXRlciggY29tcG9uZW50LCBrZXksIHRlbXBsYXRlICk7XG5cdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMucHVzaCggcGFyYW1ldGVyICk7XG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVyLnZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBwYXJzZUpTT04sIHJlc29sdmVSZWYsIENvbXBvbmVudFBhcmFtZXRlciwgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlSW5zdGFuY2UuanMgKi9cblx0dmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggY29tcG9uZW50LCBDb21wb25lbnQsIGRhdGEsIGNvbnRlbnREZXNjcmlwdG9yICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBwYXJlbnRGcmFnbWVudCwgcGFydGlhbHMsIHJhY3RpdmU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJhY3RpdmUgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdC8vIE1ha2UgY29udGVudHMgYXZhaWxhYmxlIGFzIGEge3s+Y29udGVudH19IHBhcnRpYWxcblx0XHRcdHBhcnRpYWxzID0ge1xuXHRcdFx0XHRjb250ZW50OiBjb250ZW50RGVzY3JpcHRvciB8fCBbXVxuXHRcdFx0fTtcblx0XHRcdGlmICggQ29tcG9uZW50LmRlZmF1bHRzLmVsICkge1xuXHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdkZWZhdWx0RWxTcGVjaWZpZWQnLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdG5hbWU6IGNvbXBvbmVudC5uYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0YW5jZSA9IG5ldyBDb21wb25lbnQoIHtcblx0XHRcdFx0ZWw6IG51bGwsXG5cdFx0XHRcdGFwcGVuZDogdHJ1ZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuXHRcdFx0XHRtYWdpYzogcmFjdGl2ZS5tYWdpYyB8fCBDb21wb25lbnQuZGVmYXVsdHMubWFnaWMsXG5cdFx0XHRcdG1vZGlmeUFycmF5czogcmFjdGl2ZS5tb2RpZnlBcnJheXMsXG5cdFx0XHRcdF9wYXJlbnQ6IHJhY3RpdmUsXG5cdFx0XHRcdF9jb21wb25lbnQ6IGNvbXBvbmVudCxcblx0XHRcdFx0Ly8gbmVlZCB0byBpbmhlcml0IHJ1bnRpbWUgcGFyZW50IGFkYXB0b3JzXG5cdFx0XHRcdGFkYXB0OiByYWN0aXZlLmFkYXB0LFxuXHRcdFx0XHR5aWVsZDoge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBjb250ZW50RGVzY3JpcHRvcixcblx0XHRcdFx0XHRpbnN0YW5jZTogcmFjdGl2ZVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdFx0fTtcblx0fSggbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVCaW5kaW5ncy5qcyAqL1xuXHR2YXIgY3JlYXRlQmluZGluZ3MgPSBmdW5jdGlvbiggY3JlYXRlQ29tcG9uZW50QmluZGluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVJbml0aWFsQ29tcG9uZW50QmluZGluZ3MoIGNvbXBvbmVudCwgdG9CaW5kICkge1xuXHRcdFx0dG9CaW5kLmZvckVhY2goIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxDb21wb25lbnRCaW5kaW5nKCBwYWlyICkge1xuXHRcdFx0XHR2YXIgY2hpbGRWYWx1ZSwgcGFyZW50VmFsdWU7XG5cdFx0XHRcdGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIGNvbXBvbmVudCwgY29tcG9uZW50LnJvb3QsIHBhaXIucGFyZW50S2V5cGF0aCwgcGFpci5jaGlsZEtleXBhdGggKTtcblx0XHRcdFx0Y2hpbGRWYWx1ZSA9IGNvbXBvbmVudC5pbnN0YW5jZS52aWV3bW9kZWwuZ2V0KCBwYWlyLmNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbC5nZXQoIHBhaXIucGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGNoaWxkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwYXJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5yb290LnZpZXdtb2RlbC5zZXQoIHBhaXIucGFyZW50S2V5cGF0aCwgY2hpbGRWYWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggY3JlYXRlQ29tcG9uZW50QmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvcHJvcGFnYXRlRXZlbnRzLmpzICovXG5cdHZhciBwcm9wYWdhdGVFdmVudHMgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGZpcmVFdmVudCwgbG9nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnRzKCBjb21wb25lbnQsIGV2ZW50c0Rlc2NyaXB0b3IgKSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdFx0Zm9yICggZXZlbnROYW1lIGluIGV2ZW50c0Rlc2NyaXB0b3IgKSB7XG5cdFx0XHRcdGlmICggZXZlbnRzRGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eSggZXZlbnROYW1lICkgKSB7XG5cdFx0XHRcdFx0cHJvcGFnYXRlRXZlbnQoIGNvbXBvbmVudC5pbnN0YW5jZSwgY29tcG9uZW50LnJvb3QsIGV2ZW50TmFtZSwgZXZlbnRzRGVzY3JpcHRvclsgZXZlbnROYW1lIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9wYWdhdGVFdmVudCggY2hpbGRJbnN0YW5jZSwgcGFyZW50SW5zdGFuY2UsIGV2ZW50TmFtZSwgcHJveHlFdmVudE5hbWUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm94eUV2ZW50TmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiBwYXJlbnRJbnN0YW5jZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9Db21wb25lbnRFdmVudEFyZ3VtZW50cydcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGRJbnN0YW5jZS5vbiggZXZlbnROYW1lLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGV2ZW50LCBhcmdzO1xuXHRcdFx0XHQvLyBzZW1pLXdlYWsgdGVzdCwgYnV0IHdoYXQgZWxzZT8gdGFnIHRoZSBldmVudCBvYmogLl9pc0V2ZW50ID9cblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1sgMCBdICYmIGFyZ3VtZW50c1sgMCBdLm5vZGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQgPSBBcnJheS5wcm90b3R5cGUuc2hpZnQuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZmlyZUV2ZW50KCBwYXJlbnRJbnN0YW5jZSwgcHJveHlFdmVudE5hbWUsIHtcblx0XHRcdFx0XHRldmVudDogZXZlbnQsXG5cdFx0XHRcdFx0YXJnczogYXJnc1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdC8vIGNhbmNlbCBidWJibGluZ1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCwgbG9nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS91cGRhdGVMaXZlUXVlcmllcy5qcyAqL1xuXHR2YXIgdXBkYXRlTGl2ZVF1ZXJpZXMgPSBmdW5jdGlvbiggY29tcG9uZW50ICkge1xuXHRcdHZhciBhbmNlc3RvciwgcXVlcnk7XG5cdFx0Ly8gSWYgdGhlcmUncyBhIGxpdmUgcXVlcnkgZm9yIHRoaXMgY29tcG9uZW50IHR5cGUsIGFkZCBpdFxuXHRcdGFuY2VzdG9yID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0d2hpbGUgKCBhbmNlc3RvciApIHtcblx0XHRcdGlmICggcXVlcnkgPSBhbmNlc3Rvci5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIGNvbXBvbmVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdHF1ZXJ5LnB1c2goIGNvbXBvbmVudC5pbnN0YW5jZSApO1xuXHRcdFx0fVxuXHRcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5fcGFyZW50O1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgd2FybiwgY3JlYXRlTW9kZWwsIGNyZWF0ZUluc3RhbmNlLCBjcmVhdGVCaW5kaW5ncywgcHJvcGFnYXRlRXZlbnRzLCB1cGRhdGVMaXZlUXVlcmllcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBDb21wb25lbnQkaW5pdCggb3B0aW9ucywgQ29tcG9uZW50ICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCByb290LCBkYXRhLCB0b0JpbmQ7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnJvb3QgPSByb290O1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQ09NUE9ORU5UO1xuXHRcdFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5lO1xuXHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR0aGlzLmluZGV4UmVmQmluZGluZ3MgPSB7fTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSBbXTtcblx0XHRcdC8vIGV2ZW4gdGhvdWdoIG9ubHkgb25lIHlpZWxkZXIgaXMgYWxsb3dlZCwgd2UgbmVlZCB0byBoYXZlIGFuIGFycmF5IG9mIHRoZW1cblx0XHRcdC8vIGFzIGl0J3MgcG9zc2libGUgdG8gY2F1c2UgYSB5aWVsZGVyIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBsYXN0IG9uZVxuXHRcdFx0Ly8gd2FzIGRlc3Ryb3llZCBpbiB0aGUgc2FtZSB0dXJuIG9mIHRoZSBydW5sb29wXG5cdFx0XHR0aGlzLnlpZWxkZXJzID0gW107XG5cdFx0XHRpZiAoICFDb21wb25lbnQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NvbXBvbmVudCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgbm90IGZvdW5kJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmlyc3QsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbW9kZWwgZm9yIHRoZSBjb21wb25lbnQgLSBlLmcuIGlmIHdlXG5cdFx0XHQvLyBlbmNvdW50ZXIgPHdpZGdldCBmb289J2JhcicvPiB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGEgd2lkZ2V0XG5cdFx0XHQvLyB3aXRoIGBkYXRhOiB7IGZvbzogJ2JhcicgfWAuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gVGhpcyBtYXkgaW52b2x2ZSBzZXR0aW5nIHVwIHNvbWUgYmluZGluZ3MsIGJ1dCB3ZSBjYW4ndCBkbyBpdFxuXHRcdFx0Ly8geWV0IHNvIHdlIHRha2Ugc29tZSBub3RlcyBpbnN0ZWFkXG5cdFx0XHR0b0JpbmQgPSBbXTtcblx0XHRcdGRhdGEgPSBjcmVhdGVNb2RlbCggdGhpcywgQ29tcG9uZW50LmRlZmF1bHRzLmRhdGEgfHwge30sIG9wdGlvbnMudGVtcGxhdGUuYSwgdG9CaW5kICk7XG5cdFx0XHRjcmVhdGVJbnN0YW5jZSggdGhpcywgQ29tcG9uZW50LCBkYXRhLCBvcHRpb25zLnRlbXBsYXRlLmYgKTtcblx0XHRcdGNyZWF0ZUJpbmRpbmdzKCB0aGlzLCB0b0JpbmQgKTtcblx0XHRcdHByb3BhZ2F0ZUV2ZW50cyggdGhpcywgb3B0aW9ucy50ZW1wbGF0ZS52ICk7XG5cdFx0XHQvLyBpbnRybywgb3V0cm8gYW5kIGRlY29yYXRvciBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0XG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUudDEgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MiB8fCBvcHRpb25zLnRlbXBsYXRlLm8gKSB7XG5cdFx0XHRcdHdhcm4oICdUaGUgXCJpbnRyb1wiLCBcIm91dHJvXCIgYW5kIFwiZGVjb3JhdG9yXCIgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdCBvbiBjb21wb25lbnRzJyApO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHR9O1xuXHR9KCB0eXBlcywgd2FybiwgY3JlYXRlTW9kZWwsIGNyZWF0ZUluc3RhbmNlLCBjcmVhdGVCaW5kaW5ncywgcHJvcGFnYXRlRXZlbnRzLCB1cGRhdGVMaXZlUXVlcmllcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBydW5sb29wLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHZhciBjaGlsZEluc3RhbmNlID0gdGhpcy5pbnN0YW5jZSxcblx0XHRcdFx0cGFyZW50SW5zdGFuY2UgPSBjaGlsZEluc3RhbmNlLl9wYXJlbnQsXG5cdFx0XHRcdGluZGV4UmVmQWxpYXMsIHF1ZXJ5O1xuXHRcdFx0dGhpcy5iaW5kaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWQ7XG5cdFx0XHRcdGlmICggYmluZGluZy5yb290ICE9PSBwYXJlbnRJbnN0YW5jZSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB1cGRhdGVkID0gZ2V0TmV3S2V5cGF0aCggYmluZGluZy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0YmluZGluZy5yZWJpbmQoIHVwZGF0ZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5jb21wbGV4UGFyYW1ldGVycy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdGlmICggdGhpcy55aWVsZGVyc1sgMCBdICkge1xuXHRcdFx0XHRyZWJpbmQoIHRoaXMueWllbGRlcnNbIDAgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleFJlZkFsaWFzID0gdGhpcy5pbmRleFJlZkJpbmRpbmdzWyBpbmRleFJlZiBdICkge1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggY2hpbGRJbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0Y2hpbGRJbnN0YW5jZS52aWV3bW9kZWwuc2V0KCBpbmRleFJlZkFsaWFzLCBuZXdJbmRleCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBxdWVyeSA9IHRoaXMucm9vdC5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIHRoaXMubmFtZSBdICkge1xuXHRcdFx0XHRxdWVyeS5fbWFrZURpcnR5KCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlYmluZCggeCApIHtcblx0XHRcdFx0eC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZW5kZXIgPSBmdW5jdGlvbiBDb21wb25lbnQkcmVuZGVyKCkge1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cdFx0aW5zdGFuY2UucmVuZGVyKCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSApO1xuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiBpbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHRvU3RyaW5nID0gZnVuY3Rpb24gQ29tcG9uZW50JHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5iaW5kID0gZnVuY3Rpb24oIEhvb2ssIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgdGVhcmRvd25Ib29rID0gbmV3IEhvb2soICd0ZWFyZG93bicgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIENvbXBvbmVudCR1bmJpbmQoKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXHRcdFx0dGhpcy5jb21wbGV4UGFyYW1ldGVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRyZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoIHRoaXMgKTtcblx0XHRcdC8vIHRlYXJkb3duIHRoZSBpbnN0YW5jZVxuXHRcdFx0aW5zdGFuY2UuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRpbnN0YW5jZS52aWV3bW9kZWwudGVhcmRvd24oKTtcblx0XHRcdGlmICggaW5zdGFuY2UuZnJhZ21lbnQucmVuZGVyZWQgJiYgaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgaW5zdGFuY2UgKTtcblx0XHRcdH1cblx0XHRcdHRlYXJkb3duSG9vay5maXJlKCBpbnN0YW5jZSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIHRoaW5nICkge1xuXHRcdFx0dGhpbmcudW5iaW5kKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKCBjb21wb25lbnQgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UsIHF1ZXJ5O1xuXHRcdFx0aW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKCBxdWVyeSA9IGluc3RhbmNlLl9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgY29tcG9uZW50Lm5hbWUgXSApIHtcblx0XHRcdFx0XHRxdWVyeS5fcmVtb3ZlKCBjb21wb25lbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGluc3RhbmNlID0gaW5zdGFuY2UuX3BhcmVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiBDb21wb25lbnQkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcblx0XHR0aGlzLmluc3RhbmNlLnVucmVuZGVyKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvX0NvbXBvbmVudC5qcyAqL1xuXHR2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24oIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMsIENvbnN0cnVjdG9yICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zLCBDb25zdHJ1Y3RvciApO1xuXHRcdH07XG5cdFx0Q29tcG9uZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBDb21wb25lbnQ7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5yZW5kZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbW1lbnQuanMgKi9cblx0dmFyIENvbW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIGRldGFjaCApIHtcblxuXHRcdHZhciBDb21tZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5DT01NRU5UO1xuXHRcdFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudGVtcGxhdGUuYztcblx0XHR9O1xuXHRcdENvbW1lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCB0aGlzLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnPCEtLScgKyB0aGlzLnZhbHVlICsgJy0tPic7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMubm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tbWVudDtcblx0fSggdHlwZXMsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvWWllbGRlci5qcyAqL1xuXHR2YXIgWWllbGRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0dmFyIFlpZWxkZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHZhciBjb21wb25lbnRJbnN0YW5jZSwgY29tcG9uZW50O1xuXHRcdFx0Y29tcG9uZW50SW5zdGFuY2UgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGNvbXBvbmVudEluc3RhbmNlLmNvbXBvbmVudDtcblx0XHRcdHRoaXMuc3Vycm9nYXRlUGFyZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRyb290OiBjb21wb25lbnRJbnN0YW5jZS55aWVsZC5pbnN0YW5jZSxcblx0XHRcdFx0dGVtcGxhdGU6IGNvbXBvbmVudEluc3RhbmNlLnlpZWxkLnRlbXBsYXRlLFxuXHRcdFx0XHRwRWxlbWVudDogdGhpcy5zdXJyb2dhdGVQYXJlbnQucEVsZW1lbnRcblx0XHRcdH0gKTtcblx0XHRcdGNvbXBvbmVudC55aWVsZGVycy5wdXNoKCB0aGlzICk7XG5cdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY29tcG9uZW50LnlpZWxkZXJzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQSBjb21wb25lbnQgdGVtcGxhdGUgY2FuIG9ubHkgaGF2ZSBvbmUge3t5aWVsZH19IGRlY2xhcmF0aW9uIGF0IGEgdGltZScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0WWllbGRlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbDogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3Vycm9nYXRlUGFyZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5yZW5kZXIoKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuY29tcG9uZW50LnlpZWxkZXJzLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFlpZWxkZXI7XG5cdH0oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUl0ZW0uanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdF9jcmVhdGVJdGVtID0gZnVuY3Rpb24oIHR5cGVzLCBUZXh0LCBJbnRlcnBvbGF0b3IsIFNlY3Rpb24sIFRyaXBsZSwgRWxlbWVudCwgUGFydGlhbCwgZ2V0Q29tcG9uZW50LCBDb21wb25lbnQsIENvbW1lbnQsIFlpZWxkZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlSXRlbSggb3B0aW9ucyApIHtcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRleHQoIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoIG9wdGlvbnMudGVtcGxhdGUudCApIHtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlRFUlBPTEFUT1I6XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnIgPT09ICd5aWVsZCcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFlpZWxkZXIoIG9wdGlvbnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBJbnRlcnBvbGF0b3IoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgU2VjdGlvbiggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlRSSVBMRTpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRyaXBsZSggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkVMRU1FTlQ6XG5cdFx0XHRcdFx0dmFyIGNvbnN0cnVjdG9yO1xuXHRcdFx0XHRcdGlmICggY29uc3RydWN0b3IgPSBnZXRDb21wb25lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdCwgb3B0aW9ucy50ZW1wbGF0ZS5lICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IENvbXBvbmVudCggb3B0aW9ucywgY29uc3RydWN0b3IgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBFbGVtZW50KCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuUEFSVElBTDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhcnRpYWwoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5DT01NRU5UOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgQ29tbWVudCggb3B0aW9ucyApO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1NvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMuIFRoYW5rcyEnICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIFRleHQsIEludGVycG9sYXRvciwgU2VjdGlvbiwgVHJpcGxlLCBFbGVtZW50LCBQYXJ0aWFsLCBnZXRDb21wb25lbnQsIENvbXBvbmVudCwgQ29tbWVudCwgWWllbGRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlLCBjcmVhdGVJdGVtICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgcGFyZW50UmVmcywgcmVmO1xuXHRcdFx0Ly8gVGhlIGl0ZW0gdGhhdCBvd25zIHRoaXMgZnJhZ21lbnQgLSBhbiBlbGVtZW50LCBzZWN0aW9uLCBwYXJ0aWFsLCBvciBhdHRyaWJ1dGVcblx0XHRcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudCA9IHRoaXMub3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHQvLyBpbmhlcml0ZWQgcHJvcGVydGllc1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdFx0XHQvLyBJZiBwYXJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIHRoaXMgbWF5IG5vdCBiZSB0aGUgb25seSBmcmFnbWVudFxuXHRcdFx0Ly8gdGhhdCBiZWxvbmdzIHRvIGl0IC0gd2UgbmVlZCB0byBtYWtlIGEgbm90ZSBvZiB0aGUgaW5kZXhcblx0XHRcdGlmICggdGhpcy5vd25lci50eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdH1cblx0XHRcdC8vIGluZGV4IHJlZmVyZW5jZXMgKHRoZSAnaScgaW4ge3sjc2VjdGlvbjppfX0uLi57ey9zZWN0aW9ufX0pIG5lZWQgdG8gY2FzY2FkZVxuXHRcdFx0Ly8gZG93biB0aGUgdHJlZVxuXHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdFx0cGFyZW50UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdFx0aWYgKCBwYXJlbnRSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHRcdFx0Ly8gYXZvaWRzIG5lZWQgZm9yIGhhc093blByb3BlcnR5XG5cdFx0XHRcdFx0Zm9yICggcmVmIGluIHBhcmVudFJlZnMgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgcmVmIF0gPSBwYXJlbnRSZWZzWyByZWYgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy5pbmRleFJlZiApIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5pbmRleFJlZnMgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbmRleFJlZnMgPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgb3B0aW9ucy5pbmRleFJlZiBdID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWUgdG8gY3JlYXRlIHRoaXMgZnJhZ21lbnQncyBjaGlsZCBpdGVtc1xuXHRcdFx0Ly8gVEVNUCBzaG91bGQgdGhpcyBiZSBoYXBwZW5pbmc/XG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0b3B0aW9ucy50ZW1wbGF0ZSA9IFsgb3B0aW9ucy50ZW1wbGF0ZSBdO1xuXHRcdFx0fSBlbHNlIGlmICggIW9wdGlvbnMudGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9wdGlvbnMudGVtcGxhdGUgPSBbXTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaXRlbXMgPSBvcHRpb25zLnRlbXBsYXRlLm1hcCggZnVuY3Rpb24oIHRlbXBsYXRlLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlSXRlbSgge1xuXHRcdFx0XHRcdHBhcmVudEZyYWdtZW50OiB0aGlzJDAsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IG9wdGlvbnMucEVsZW1lbnQsXG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmFyZ3NMaXN0ID0gbnVsbDtcblx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblx0XHRcdHRoaXMuYm91bmQgPSB0cnVlO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBjcmVhdGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdF9jcmVhdGVJdGVtICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBhc3NpZ25OZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dGhpcy5pbmRleCA9IG5ld0luZGV4O1xuXHRcdFx0Ly8gYXNzaWduIG5ldyBjb250ZXh0IGtleXBhdGggaWYgbmVlZGVkXG5cdFx0XHRhc3NpZ25OZXdLZXlwYXRoKCB0aGlzLCAnY29udGV4dCcsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdGlmICggdGhpcy5pbmRleFJlZnMgJiYgdGhpcy5pbmRleFJlZnNbIGluZGV4UmVmIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIGluZGV4UmVmIF0gPSBuZXdJbmRleDtcblx0XHRcdH1cblx0XHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdGlmICggaXRlbS5yZWJpbmQgKSB7XG5cdFx0XHRcdFx0aXRlbS5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggYXNzaWduTmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRyZW5kZXIgPSBmdW5jdGlvbiBGcmFnbWVudCRyZW5kZXIoKSB7XG5cdFx0dmFyIHJlc3VsdDtcblx0XHRpZiAoIHRoaXMuaXRlbXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cmVzdWx0ID0gdGhpcy5pdGVtc1sgMCBdLnJlbmRlcigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRyZXN1bHQuYXBwZW5kQ2hpbGQoIGl0ZW0ucmVuZGVyKCkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR0b1N0cmluZyA9IGZ1bmN0aW9uIEZyYWdtZW50JHRvU3RyaW5nKCBlc2NhcGUgKSB7XG5cdFx0aWYgKCAhdGhpcy5pdGVtcyApIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtLnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHR9ICkuam9pbiggJycgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5iaW5kID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBGcmFnbWVudCR1bmJpbmQoKSB7XG5cdFx0XHRpZiAoICF0aGlzLmJvdW5kICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIHVuYmluZEl0ZW0gKTtcblx0XHRcdHRoaXMuYm91bmQgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kSXRlbSggaXRlbSApIHtcblx0XHRcdGlmICggaXRlbS51bmJpbmQgKSB7XG5cdFx0XHRcdGl0ZW0udW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVucmVuZGVyID0gZnVuY3Rpb24gRnJhZ21lbnQkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0aWYgKCAhdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0F0dGVtcHRlZCB0byB1bnJlbmRlciBhIGZyYWdtZW50IHRoYXQgd2FzIG5vdCByZW5kZXJlZCcgKTtcblx0XHR9XG5cdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHJldHVybiBpLnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0fSApO1xuXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50LmpzICovXG5cdHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uKCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBnZXROb2RlLCBnZXRWYWx1ZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRGcmFnbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldE5vZGU6IGdldE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogZ2V0VmFsdWUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRjaXJjdWxhci5GcmFnbWVudCA9IEZyYWdtZW50O1xuXHRcdHJldHVybiBGcmFnbWVudDtcblx0fSggdmlydHVhbGRvbV9GcmFnbWVudCRidWJibGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZGV0YWNoLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9GcmFnbWVudCRmaXJzdE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0Tm9kZSwgdmlydHVhbGRvbV9GcmFnbWVudCRnZXRWYWx1ZSwgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0LCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlYmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCRyZW5kZXIsIHZpcnR1YWxkb21fRnJhZ21lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5iaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVucmVuZGVyLCBjaXJjdWxhciApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3Jlc2V0LmpzICovXG5cdHZhciBSYWN0aXZlJHJlc2V0ID0gZnVuY3Rpb24oIEhvb2ssIHJ1bmxvb3AsIEZyYWdtZW50LCBjb25maWcgKSB7XG5cblx0XHR2YXIgc2hvdWxkUmVyZW5kZXIgPSBbXG5cdFx0XHRcdCd0ZW1wbGF0ZScsXG5cdFx0XHRcdCdwYXJ0aWFscycsXG5cdFx0XHRcdCdjb21wb25lbnRzJyxcblx0XHRcdFx0J2RlY29yYXRvcnMnLFxuXHRcdFx0XHQnZXZlbnRzJ1xuXHRcdFx0XSxcblx0XHRcdHJlc2V0SG9vayA9IG5ldyBIb29rKCAncmVzZXQnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXQoIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2UsIHdyYXBwZXIsIGNoYW5nZXMsIGksIHJlcmVuZGVyO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YScgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZSByb290IG9iamVjdCBpcyB3cmFwcGVkLCB0cnkgYW5kIHVzZSB0aGUgd3JhcHBlcidzIHJlc2V0IHZhbHVlXG5cdFx0XHRpZiAoICggd3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbICcnIF0gKSAmJiB3cmFwcGVyLnJlc2V0ICkge1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIucmVzZXQoIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgd2FzIHJlamVjdGVkLCB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIG9iamVjdFxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcblx0XHRcdGNoYW5nZXMgPSBjb25maWcucmVzZXQoIHRoaXMgKTtcblx0XHRcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZFJlcmVuZGVyLmluZGV4T2YoIGNoYW5nZXNbIGkgXSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmVyZW5kZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlcmVuZGVyICkge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50O1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG5cdFx0XHRcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuXHRcdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcblx0XHRcdFx0aWYgKCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51bnJlbmRlcigpO1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdHJvb3Q6IHRoaXMsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fVxuXHRcdFx0cmVzZXRIb29rLmZpcmUoIHRoaXMsIGRhdGEgKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJ1bmxvb3AsIEZyYWdtZW50LCBjb25maWcgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXNldFRlbXBsYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJHJlc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiggY29uZmlnLCBGcmFnbWVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0VGVtcGxhdGUoIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIHRyYW5zaXRpb25zRW5hYmxlZCwgY29tcG9uZW50O1xuXHRcdFx0Y29uZmlnLnRlbXBsYXRlLmluaXQoIG51bGwsIHRoaXMsIHtcblx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlXG5cdFx0XHR9ICk7XG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG5cdFx0XHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcblx0XHRcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuXHRcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcblx0XHRcdGlmICggY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQgKSB7XG5cdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMudW5yZW5kZXIoKTtcblx0XHRcdGlmICggY29tcG9uZW50ICkge1xuXHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVtb3ZlIGV4aXN0aW5nIGZyYWdtZW50IGFuZCBjcmVhdGUgbmV3IG9uZVxuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG5cdFx0XHRcdHJvb3Q6IHRoaXMsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnJlbmRlciggdGhpcy5lbCwgdGhpcy5hbmNob3IgKTtcblx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdH07XG5cdH0oIGNvbmZpZywgRnJhZ21lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXZlcnNlLmpzICovXG5cdHZhciBSYWN0aXZlJHJldmVyc2UgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3JldmVyc2UnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzZXQgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNPYmplY3QsIG5vcm1hbGlzZUtleXBhdGgsIGdldE1hdGNoaW5nS2V5cGF0aHMgKSB7XG5cblx0XHR2YXIgd2lsZGNhcmQgPSAvXFwqLztcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRzZXQoIGtleXBhdGgsIHZhbHVlLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIG1hcCwgcHJvbWlzZTtcblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHQvLyBTZXQgbXVsdGlwbGUga2V5cGF0aHMgaW4gb25lIGdvXG5cdFx0XHRpZiAoIGlzT2JqZWN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdG1hcCA9IGtleXBhdGg7XG5cdFx0XHRcdGNhbGxiYWNrID0gdmFsdWU7XG5cdFx0XHRcdGZvciAoIGtleXBhdGggaW4gbWFwICkge1xuXHRcdFx0XHRcdGlmICggbWFwLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG1hcFsga2V5cGF0aCBdO1xuXHRcdFx0XHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGdldE1hdGNoaW5nS2V5cGF0aHMoIHRoaXMsIGtleXBhdGggKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMkMC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNPYmplY3QsIG5vcm1hbGlzZUtleXBhdGgsIGdldE1hdGNoaW5nS2V5cGF0aHMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGlmdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGlmdCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc2hpZnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NvcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc29ydCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc29ydCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc3BsaWNlLmpzICovXG5cdHZhciBSYWN0aXZlJHNwbGljZSA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc3BsaWNlJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zdWJ0cmFjdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzdWJ0cmFjdCA9IGZ1bmN0aW9uKCBhZGQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRzdWJ0cmFjdCgga2V5cGF0aCwgZCApIHtcblx0XHRcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IC0xIDogLWQgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9hZGQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR0ZWFyZG93biA9IGZ1bmN0aW9uKCBIb29rLCBQcm9taXNlLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgdGVhcmRvd25Ib29rID0gbmV3IEhvb2soICd0ZWFyZG93bicgKTtcblx0XHQvLyBUZWFyZG93bi4gVGhpcyBnb2VzIHRocm91Z2ggdGhlIHJvb3QgZnJhZ21lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW4sIHJlbW92aW5nIG9ic2VydmVyc1xuXHRcdC8vIGFuZCBnZW5lcmFsbHkgY2xlYW5pbmcgdXAgYWZ0ZXIgaXRzZWxmXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdGVhcmRvd24oIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2U7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwudGVhcmRvd24oKTtcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudC5yZW5kZXJlZCAmJiB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zaG91bGREZXN0cm95ID0gdHJ1ZTtcblx0XHRcdHByb21pc2UgPSB0aGlzLmZyYWdtZW50LnJlbmRlcmVkID8gdGhpcy51bnJlbmRlcigpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHR0ZWFyZG93bkhvb2suZmlyZSggdGhpcyApO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0Ly8gVE9ETyBkZXByZWNhdGUgdGhpcz9cblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIFByb21pc2UsIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3RvZ2dsZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR0b2dnbGUgPSBmdW5jdGlvbiggbG9nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdG9nZ2xlKCBrZXlwYXRoLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsb2cuZXJyb3JPbmx5KCB7XG5cdFx0XHRcdFx0ZGVidWc6IHRoaXMuZGVidWcsXG5cdFx0XHRcdFx0bWVzc3NhZ2U6ICdiYWRBcmd1bWVudHMnLFxuXHRcdFx0XHRcdGFyZzoge1xuXHRcdFx0XHRcdFx0YXJndW1lbnRzOiBrZXlwYXRoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoIGtleXBhdGgsICF2YWx1ZSwgY2FsbGJhY2sgKTtcblx0XHR9O1xuXHR9KCBsb2cgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90b0hUTUwuanMgKi9cblx0dmFyIFJhY3RpdmUkdG9IVE1MID0gZnVuY3Rpb24gUmFjdGl2ZSR0b0hUTUwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIHRydWUgKTtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1bnJlbmRlciA9IGZ1bmN0aW9uKCBjc3MsIEhvb2ssIGxvZywgUHJvbWlzZSwgcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICkge1xuXG5cdFx0dmFyIHVucmVuZGVySG9vayA9IG5ldyBIb29rKCAndW5yZW5kZXInICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdW5yZW5kZXIoKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwcm9taXNlLCBzaG91bGREZXN0cm95O1xuXHRcdFx0aWYgKCAhdGhpcy5mcmFnbWVudC5yZW5kZXJlZCApIHtcblx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAncmFjdGl2ZS51bnJlbmRlcigpIHdhcyBjYWxsZWQgb24gYSBSYWN0aXZlIGluc3RhbmNlIHRoYXQgd2FzIG5vdCByZW5kZXJlZCdcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgYW5kIHRoZSBjb21wb25lbnQgaXNuJ3QgbWFya2VkIGZvciBkZXN0cnVjdGlvbixcblx0XHRcdC8vIGRvbid0IGRldGFjaCBub2RlcyBmcm9tIHRoZSBET00gdW5uZWNlc3NhcmlseVxuXHRcdFx0c2hvdWxkRGVzdHJveSA9ICF0aGlzLmNvbXBvbmVudCB8fCB0aGlzLmNvbXBvbmVudC5zaG91bGREZXN0cm95IHx8IHRoaXMuc2hvdWxkRGVzdHJveTtcblx0XHRcdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5jc3MgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y3NzLnJlbW92ZSggdGhpcyQwLmNvbnN0cnVjdG9yICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIENhbmNlbCBhbnkgYW5pbWF0aW9ucyBpbiBwcm9ncmVzc1xuXHRcdFx0d2hpbGUgKCB0aGlzLl9hbmltYXRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnNbIDAgXS5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHR1bnJlbmRlckhvb2suZmlyZSggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIGdsb2JhbF9jc3MsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIGxvZywgUHJvbWlzZSwgcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5zaGlmdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1bnNoaWZ0ID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICd1bnNoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdXBkYXRlID0gZnVuY3Rpb24oIEhvb2ssIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgdXBkYXRlSG9vayA9IG5ldyBIb29rKCAndXBkYXRlJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZSgga2V5cGF0aCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9ICcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGggfHwgJyc7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwubWFyaygga2V5cGF0aCApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdHVwZGF0ZUhvb2suZmlyZSggdGhpcywga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJ1bmxvb3AgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91cGRhdGVNb2RlbC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1cGRhdGVNb2RlbCA9IGZ1bmN0aW9uKCBhcnJheUNvbnRlbnRzTWF0Y2gsIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKCBrZXlwYXRoLCBjYXNjYWRlICkge1xuXHRcdFx0dmFyIHZhbHVlcztcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRrZXlwYXRoID0gJyc7XG5cdFx0XHRcdGNhc2NhZGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCB0aGlzLCBrZXlwYXRoLCB2YWx1ZXMgPSB7fSwgY2FzY2FkZSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCB2YWx1ZXMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCByYWN0aXZlLCBrZXlwYXRoLCB2YWx1ZXMsIGNhc2NhZGUgKSB7XG5cdFx0XHR2YXIgYmluZGluZ3MsIGNoaWxkRGVwcywgaSwgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjaGVja2JveEdyb3VwcyA9IFtdO1xuXHRcdFx0YmluZGluZ3MgPSByYWN0aXZlLl90d293YXlCaW5kaW5nc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBiaW5kaW5ncyAmJiAoIGkgPSBiaW5kaW5ncy5sZW5ndGggKSApIHtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuXHRcdFx0XHRcdGlmICggYmluZGluZy5yYWRpb05hbWUgJiYgIWJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cblx0XHRcdFx0XHQvLyB3ZSB3YW50IHRvIGdldCB0aGUgdmFsdWUgb25jZSBhdCBtb3N0XG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmNoZWNrYm94TmFtZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNoZWNrYm94R3JvdXBzWyBiaW5kaW5nLmtleXBhdGggXSAmJiAhYmluZGluZy5jaGFuZ2VkKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goIGJpbmRpbmcua2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRjaGVja2JveEdyb3Vwc1sgYmluZGluZy5rZXlwYXRoIF0gPSBiaW5kaW5nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCBhcnJheUNvbnRlbnRzTWF0Y2goIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWlzRXF1YWwoIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0dmFsdWVzWyBrZXlwYXRoIF0gPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBncm91cHMgb2YgYDxpbnB1dCB0eXBlPSdjaGVja2JveCcgbmFtZT0ne3tmb299fScgLi4uPmBcblx0XHRcdGlmICggY2hlY2tib3hHcm91cHMubGVuZ3RoICkge1xuXHRcdFx0XHRjaGVja2JveEdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXHRcdFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1sga2V5cGF0aCBdO1xuXHRcdFx0XHRcdC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCAhYXJyYXlDb250ZW50c01hdGNoKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gbmV3VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjYXNjYWRlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXNjYWRlXG5cdFx0XHRjaGlsZERlcHMgPSByYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwWyAnZGVmYXVsdCcgXVsga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjaGlsZERlcHMgKSB7XG5cdFx0XHRcdGkgPSBjaGlsZERlcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHJhY3RpdmUsIGNoaWxkRGVwc1sgaSBdLCB2YWx1ZXMsIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGFycmF5Q29udGVudHNNYXRjaCwgaXNFcXVhbCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlLmpzICovXG5cdHZhciBwcm90b3R5cGUgPSBmdW5jdGlvbiggYWRkLCBhbmltYXRlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaXJlLCBnZXQsIGluc2VydCwgbWVyZ2UsIG9ic2VydmUsIG9mZiwgb24sIHBvcCwgcHVzaCwgcmVuZGVyLCByZXNldCwgcmVzZXRUZW1wbGF0ZSwgcmV2ZXJzZSwgc2V0LCBzaGlmdCwgc29ydCwgc3BsaWNlLCBzdWJ0cmFjdCwgdGVhcmRvd24sIHRvZ2dsZSwgdG9IVE1MLCB1bnJlbmRlciwgdW5zaGlmdCwgdXBkYXRlLCB1cGRhdGVNb2RlbCApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRhZGQ6IGFkZCxcblx0XHRcdGFuaW1hdGU6IGFuaW1hdGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpcmU6IGZpcmUsXG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdGluc2VydDogaW5zZXJ0LFxuXHRcdFx0bWVyZ2U6IG1lcmdlLFxuXHRcdFx0b2JzZXJ2ZTogb2JzZXJ2ZSxcblx0XHRcdG9mZjogb2ZmLFxuXHRcdFx0b246IG9uLFxuXHRcdFx0cG9wOiBwb3AsXG5cdFx0XHRwdXNoOiBwdXNoLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNldDogcmVzZXQsXG5cdFx0XHRyZXNldFRlbXBsYXRlOiByZXNldFRlbXBsYXRlLFxuXHRcdFx0cmV2ZXJzZTogcmV2ZXJzZSxcblx0XHRcdHNldDogc2V0LFxuXHRcdFx0c2hpZnQ6IHNoaWZ0LFxuXHRcdFx0c29ydDogc29ydCxcblx0XHRcdHNwbGljZTogc3BsaWNlLFxuXHRcdFx0c3VidHJhY3Q6IHN1YnRyYWN0LFxuXHRcdFx0dGVhcmRvd246IHRlYXJkb3duLFxuXHRcdFx0dG9nZ2xlOiB0b2dnbGUsXG5cdFx0XHR0b0hUTUw6IHRvSFRNTCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlcixcblx0XHRcdHVuc2hpZnQ6IHVuc2hpZnQsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZSxcblx0XHRcdHVwZGF0ZU1vZGVsOiB1cGRhdGVNb2RlbFxuXHRcdH07XG5cdH0oIFJhY3RpdmUkYWRkLCBSYWN0aXZlJGFuaW1hdGUsIFJhY3RpdmUkZGV0YWNoLCBSYWN0aXZlJGZpbmQsIFJhY3RpdmUkZmluZEFsbCwgUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cywgUmFjdGl2ZSRmaW5kQ29tcG9uZW50LCBSYWN0aXZlJGZpcmUsIFJhY3RpdmUkZ2V0LCBSYWN0aXZlJGluc2VydCwgUmFjdGl2ZSRtZXJnZSwgUmFjdGl2ZSRvYnNlcnZlLCBSYWN0aXZlJG9mZiwgUmFjdGl2ZSRvbiwgUmFjdGl2ZSRwb3AsIFJhY3RpdmUkcHVzaCwgUmFjdGl2ZSRyZW5kZXIsIFJhY3RpdmUkcmVzZXQsIFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSwgUmFjdGl2ZSRyZXZlcnNlLCBSYWN0aXZlJHNldCwgUmFjdGl2ZSRzaGlmdCwgUmFjdGl2ZSRzb3J0LCBSYWN0aXZlJHNwbGljZSwgUmFjdGl2ZSRzdWJ0cmFjdCwgUmFjdGl2ZSR0ZWFyZG93biwgUmFjdGl2ZSR0b2dnbGUsIFJhY3RpdmUkdG9IVE1MLCBSYWN0aXZlJHVucmVuZGVyLCBSYWN0aXZlJHVuc2hpZnQsIFJhY3RpdmUkdXBkYXRlLCBSYWN0aXZlJHVwZGF0ZU1vZGVsICk7XG5cblx0LyogdXRpbHMvZ2V0R3VpZC5qcyAqL1xuXHR2YXIgZ2V0R3VpZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKCAvW3h5XS9nLCBmdW5jdGlvbiggYyApIHtcblx0XHRcdHZhciByLCB2O1xuXHRcdFx0ciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG5cdFx0XHR2ID0gYyA9PSAneCcgPyByIDogciAmIDMgfCA4O1xuXHRcdFx0cmV0dXJuIHYudG9TdHJpbmcoIDE2ICk7XG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHV0aWxzL2dldE5leHROdW1iZXIuanMgKi9cblx0dmFyIGdldE5leHROdW1iZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBpID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJ3ItJyArIGkrKztcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2hvb2tzL0hvb2tRdWV1ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9va1F1ZXVlID0gZnVuY3Rpb24oIEhvb2sgKSB7XG5cblx0XHRmdW5jdGlvbiBIb29rUXVldWUoIGV2ZW50ICkge1xuXHRcdFx0dGhpcy5ob29rID0gbmV3IEhvb2soIGV2ZW50ICk7XG5cdFx0XHR0aGlzLmluUHJvY2VzcyA9IHt9O1xuXHRcdFx0dGhpcy5xdWV1ZSA9IHt9O1xuXHRcdH1cblx0XHRIb29rUXVldWUucHJvdG90eXBlID0ge1xuXHRcdFx0Y29uc3RydWN0b3I6IEhvb2tRdWV1ZSxcblx0XHRcdGJlZ2luOiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dGhpcy5pblByb2Nlc3NbIHJhY3RpdmUuX2d1aWQgXSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0ZW5kOiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dmFyIHBhcmVudCA9IHJhY3RpdmUuX3BhcmVudDtcblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyAqaXNuJ3QqIGEgY2hpbGQgb2YgYSBjb21wb25lbnQgdGhhdCdzIGluIHByb2Nlc3MsXG5cdFx0XHRcdC8vIGl0IHNob3VsZCBjYWxsIG1ldGhvZHMgb3IgZmlyZSBhdCB0aGlzIHBvaW50XG5cdFx0XHRcdGlmICggIXBhcmVudCB8fCAhdGhpcy5pblByb2Nlc3NbIHBhcmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdGZpcmUoIHRoaXMsIHJhY3RpdmUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnZXRDaGlsZFF1ZXVlKCB0aGlzLnF1ZXVlLCBwYXJlbnQgKS5wdXNoKCByYWN0aXZlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHRoaXMuaW5Qcm9jZXNzWyByYWN0aXZlLl9ndWlkIF07XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldENoaWxkUXVldWUoIHF1ZXVlLCByYWN0aXZlICkge1xuXHRcdFx0cmV0dXJuIHF1ZXVlWyByYWN0aXZlLl9ndWlkIF0gfHwgKCBxdWV1ZVsgcmFjdGl2ZS5fZ3VpZCBdID0gW10gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaXJlKCBob29rUXVldWUsIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgY2hpbGRRdWV1ZSA9IGdldENoaWxkUXVldWUoIGhvb2tRdWV1ZS5xdWV1ZSwgcmFjdGl2ZSApO1xuXHRcdFx0aG9va1F1ZXVlLmhvb2suZmlyZSggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gcXVldWUgaXMgXCJsaXZlXCIgYmVjYXVzZSBjb21wb25lbnRzIGNhbiBlbmQgdXAgYmVpbmdcblx0XHRcdC8vIGFkZGVkIHdoaWxlIGhvb2tzIGZpcmUgb24gcGFyZW50cyB0aGF0IG1vZGlmeSBkYXRhIHZhbHVlcy5cblx0XHRcdHdoaWxlICggY2hpbGRRdWV1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdGZpcmUoIGhvb2tRdWV1ZSwgY2hpbGRRdWV1ZS5zaGlmdCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgaG9va1F1ZXVlLnF1ZXVlWyByYWN0aXZlLl9ndWlkIF07XG5cdFx0fVxuXHRcdHJldHVybiBIb29rUXVldWU7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2sgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcHJvY2Vzc1dyYXBwZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3Byb2Nlc3NXcmFwcGVyID0gZnVuY3Rpb24oIHdyYXBwZXIsIGFycmF5LCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzICkge1xuXHRcdHZhciByb290ID0gd3JhcHBlci5yb290LFxuXHRcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblx0XHQvLyBJZiB0aGlzIGlzIGEgc29ydCBvciByZXZlcnNlLCB3ZSBqdXN0IGRvIHJvb3Quc2V0KCkuLi5cblx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cblx0XHRpZiAoIG1ldGhvZE5hbWUgPT09ICdzb3J0JyB8fCBtZXRob2ROYW1lID09PSAncmV2ZXJzZScgKSB7XG5cdFx0XHRyb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIGFycmF5ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJvb3Qudmlld21vZGVsLnNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyApO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L2FycmF5QWRhcHRvci9wYXRjaC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcGF0Y2ggPSBmdW5jdGlvbiggcnVubG9vcCwgZGVmaW5lUHJvcGVydHksIGdldE5ld0luZGljZXMsIHByb2Nlc3NXcmFwcGVyICkge1xuXG5cdFx0dmFyIHBhdGNoZWRBcnJheVByb3RvID0gW10sXG5cdFx0XHRtdXRhdG9yTWV0aG9kcyA9IFtcblx0XHRcdFx0J3BvcCcsXG5cdFx0XHRcdCdwdXNoJyxcblx0XHRcdFx0J3JldmVyc2UnLFxuXHRcdFx0XHQnc2hpZnQnLFxuXHRcdFx0XHQnc29ydCcsXG5cdFx0XHRcdCdzcGxpY2UnLFxuXHRcdFx0XHQndW5zaGlmdCdcblx0XHRcdF0sXG5cdFx0XHR0ZXN0T2JqLCBwYXRjaEFycmF5TWV0aG9kcywgdW5wYXRjaEFycmF5TWV0aG9kcztcblx0XHRtdXRhdG9yTWV0aG9kcy5mb3JFYWNoKCBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdHZhciBtZXRob2QgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0XHRcdHZhciBhcmdzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblx0XHRcdFx0dmFyIG5ld0luZGljZXMsIHJlc3VsdCwgd3JhcHBlciwgaTtcblx0XHRcdFx0bmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXMoIHRoaXMsIG1ldGhvZE5hbWUsIGFyZ3MgKTtcblx0XHRcdFx0Ly8gYXBwbHkgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG5cdFx0XHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVsgbWV0aG9kTmFtZSBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0Ly8gdHJpZ2dlciBjaGFuZ2VzXG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoKTtcblx0XHRcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aSA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHR3cmFwcGVyID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVyc1sgaSBdO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB3cmFwcGVyLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cHJvY2Vzc1dyYXBwZXIoIHdyYXBwZXIsIHRoaXMsIG1ldGhvZE5hbWUsIG5ld0luZGljZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggcGF0Y2hlZEFycmF5UHJvdG8sIG1ldGhvZE5hbWUsIHtcblx0XHRcdFx0dmFsdWU6IG1ldGhvZFxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0XHQvLyBjYW4gd2UgdXNlIHByb3RvdHlwZSBjaGFpbiBpbmplY3Rpb24/XG5cdFx0Ly8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaG93LWVjbWFzY3JpcHQtNS1zdGlsbC1kb2VzLW5vdC1hbGxvdy10by1zdWJjbGFzcy1hbi1hcnJheS8jd3JhcHBlcnNfcHJvdG90eXBlX2NoYWluX2luamVjdGlvblxuXHRcdHRlc3RPYmogPSB7fTtcblx0XHRpZiAoIHRlc3RPYmouX19wcm90b19fICkge1xuXHRcdFx0Ly8geWVzLCB3ZSBjYW5cblx0XHRcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHRhcnJheS5fX3Byb3RvX18gPSBwYXRjaGVkQXJyYXlQcm90bztcblx0XHRcdH07XG5cdFx0XHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHRhcnJheS5fX3Byb3RvX18gPSBBcnJheS5wcm90b3R5cGU7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBubywgd2UgY2FuJ3Rcblx0XHRcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHR2YXIgaSwgbWV0aG9kTmFtZTtcblx0XHRcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0bWV0aG9kTmFtZSA9IG11dGF0b3JNZXRob2RzWyBpIF07XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCBtZXRob2ROYW1lLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogcGF0Y2hlZEFycmF5UHJvdG9bIG1ldGhvZE5hbWUgXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRkZWxldGUgYXJyYXlbIG11dGF0b3JNZXRob2RzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cGF0Y2hBcnJheU1ldGhvZHMudW5wYXRjaCA9IHVucGF0Y2hBcnJheU1ldGhvZHM7XG5cdFx0cmV0dXJuIHBhdGNoQXJyYXlNZXRob2RzO1xuXHR9KCBydW5sb29wLCBkZWZpbmVQcm9wZXJ0eSwgZ2V0TmV3SW5kaWNlcywgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcHJvY2Vzc1dyYXBwZXIgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnR5LCBpc0FycmF5LCBwYXRjaCApIHtcblxuXHRcdHZhciBhcnJheUFkYXB0b3IsXG5cdFx0XHQvLyBoZWxwZXJzXG5cdFx0XHRBcnJheVdyYXBwZXIsIGVycm9yTWVzc2FnZTtcblx0XHRhcnJheUFkYXB0b3IgPSB7XG5cdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cdFx0XHRcdC8vIHdyYXAgdGhlIGFycmF5IGlmIGEpIGIpIGl0J3MgYW4gYXJyYXksIGFuZCBiKSBlaXRoZXIgaXQgaGFzbid0IGJlZW4gd3JhcHBlZCBhbHJlYWR5LFxuXHRcdFx0XHQvLyBvciB0aGUgYXJyYXkgZGlkbid0IHRyaWdnZXIgdGhlIGdldCgpIGl0c2VsZlxuXHRcdFx0XHRyZXR1cm4gaXNBcnJheSggb2JqZWN0ICkgJiYgKCAhb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcblx0XHRcdGlmICggIWFycmF5Ll9yYWN0aXZlICkge1xuXHRcdFx0XHQvLyBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBfcmFjdGl2ZSBwcm9wZXJ0eSB0byBzdG9yZSB0aGUgd3JhcHBlcnNcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCAnX3JhY3RpdmUnLCB7XG5cdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdHdyYXBwZXJzOiBbXSxcblx0XHRcdFx0XHRcdGluc3RhbmNlczogW10sXG5cdFx0XHRcdFx0XHRzZXR0aW5nOiBmYWxzZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cGF0Y2goIGFycmF5ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuXHRcdFx0aWYgKCAhYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gKSB7XG5cdFx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdID0gMDtcblx0XHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2goIHJhY3RpdmUgKTtcblx0XHRcdH1cblx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdICs9IDE7XG5cdFx0XHRhcnJheS5fcmFjdGl2ZS53cmFwcGVycy5wdXNoKCB0aGlzICk7XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJyYXksIHN0b3JhZ2UsIHdyYXBwZXJzLCBpbnN0YW5jZXMsIGluZGV4O1xuXHRcdFx0XHRhcnJheSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHN0b3JhZ2UgPSBhcnJheS5fcmFjdGl2ZTtcblx0XHRcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuXHRcdFx0XHRpbnN0YW5jZXMgPSBzdG9yYWdlLmluc3RhbmNlcztcblx0XHRcdFx0Ly8gaWYgdGVhcmRvd24oKSB3YXMgaW52b2tlZCBiZWNhdXNlIHdlJ3JlIGNsZWFyaW5nIHRoZSBjYWNoZSBhcyBhIHJlc3VsdCBvZlxuXHRcdFx0XHQvLyBhIGNoYW5nZSB0aGF0IHRoZSBhcnJheSBpdHNlbGYgdHJpZ2dlcmVkLCB3ZSBjYW4gc2F2ZSBvdXJzZWx2ZXMgdGhlIHRlYXJkb3duXG5cdFx0XHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcblx0XHRcdFx0aWYgKCBzdG9yYWdlLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdyYXBwZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcblx0XHRcdFx0Ly8gbmF0dXJhbCBzdGF0ZVxuXHRcdFx0XHRpZiAoICF3cmFwcGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5Ll9yYWN0aXZlO1xuXHRcdFx0XHRcdHBhdGNoLnVucGF0Y2goIHRoaXMudmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgcmFjdGl2ZSBpbnN0YW5jZSBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdGluc3RhbmNlc1sgdGhpcy5yb290Ll9ndWlkIF0gLT0gMTtcblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbnN0YW5jZXMuaW5kZXhPZiggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGluc3RhbmNlcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRlcnJvck1lc3NhZ2UgPSAnU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5Jztcblx0XHRyZXR1cm4gYXJyYXlBZGFwdG9yO1xuXHR9KCBkZWZpbmVQcm9wZXJ0eSwgaXNBcnJheSwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcGF0Y2ggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9tYWdpY0FycmF5QWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciA9IGZ1bmN0aW9uKCBtYWdpY0FkYXB0b3IsIGFycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cdFx0aWYgKCBtYWdpY0FkYXB0b3IgKSB7XG5cdFx0XHRtYWdpY0FycmF5QWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHJldHVybiBtYWdpY0FkYXB0b3IuZmlsdGVyKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSAmJiBhcnJheUFkYXB0b3IuZmlsdGVyKCBvYmplY3QgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBtYWdpY0FkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5hcnJheVdyYXBwZXIgPSBhcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyLnRlYXJkb3duKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gbWFnaWNBcnJheUFkYXB0b3I7XG5cdH0oIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvYWRhcHQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhZGFwdCA9IGZ1bmN0aW9uKCBjb25maWcsIGFycmF5QWRhcHRvciwgbG9nLCBtYWdpY0FkYXB0b3IsIG1hZ2ljQXJyYXlBZGFwdG9yICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBwcmVmaXhlcnMgPSB7fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRhZGFwdCgga2V5cGF0aCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcmFjdGl2ZSA9IHRoaXMucmFjdGl2ZSxcblx0XHRcdFx0bGVuLCBpLCBhZGFwdG9yLCB3cmFwcGVkO1xuXHRcdFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuXHRcdFx0bGVuID0gcmFjdGl2ZS5hZGFwdC5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRhZGFwdG9yID0gcmFjdGl2ZS5hZGFwdFsgaSBdO1xuXHRcdFx0XHQvLyBBZGFwdG9ycyBjYW4gYmUgc3BlY2lmaWVkIGFzIGUuZy4gWyAnQmFja2JvbmUuTW9kZWwnLCAnQmFja2JvbmUuQ29sbGVjdGlvbicgXSAtXG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gZ2V0IHRoZSBhY3R1YWwgYWRhcHRvciBpZiB0aGF0J3MgdGhlIGNhc2Vcblx0XHRcdFx0aWYgKCB0eXBlb2YgYWRhcHRvciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dmFyIGZvdW5kID0gY29uZmlnLnJlZ2lzdHJpZXMuYWRhcHRvcnMuZmluZCggcmFjdGl2ZSwgYWRhcHRvciApO1xuXHRcdFx0XHRcdGlmICggIWZvdW5kICkge1xuXHRcdFx0XHRcdFx0Ly8gd2lsbCB0aHJvdy4gXCJyZXR1cm5cIiBmb3Igc2FmZXR5LCBpZiB3ZSBkb3duZ3JhZGUgOilcblx0XHRcdFx0XHRcdHJldHVybiBsb2cuY3JpdGljYWwoIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHBsdWdpbjogJ2FkYXB0b3InLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGFkYXB0b3Jcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhZGFwdG9yID0gcmFjdGl2ZS5hZGFwdFsgaSBdID0gZm91bmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0XHR3cmFwcGVkID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBhZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoLCBnZXRQcmVmaXhlcigga2V5cGF0aCApICk7XG5cdFx0XHRcdFx0d3JhcHBlZC52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByYWN0aXZlLm1hZ2ljICkge1xuXHRcdFx0XHRpZiAoIG1hZ2ljQXJyYXlBZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZWRbIGtleXBhdGggXSA9IG1hZ2ljQXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hZ2ljQWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBtYWdpY0FkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggcmFjdGl2ZS5tb2RpZnlBcnJheXMgJiYgYXJyYXlBZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBhcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJlZml4S2V5cGF0aCggb2JqLCBwcmVmaXggKSB7XG5cdFx0XHR2YXIgcHJlZml4ZWQgPSB7fSxcblx0XHRcdFx0a2V5O1xuXHRcdFx0aWYgKCAhcHJlZml4ICkge1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fVxuXHRcdFx0cHJlZml4ICs9ICcuJztcblx0XHRcdGZvciAoIGtleSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggb2JqLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHRwcmVmaXhlZFsgcHJlZml4ICsga2V5IF0gPSBvYmpbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJlZml4ZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UHJlZml4ZXIoIHJvb3RLZXlwYXRoICkge1xuXHRcdFx0dmFyIHJvb3REb3Q7XG5cdFx0XHRpZiAoICFwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHJvb3REb3QgPSByb290S2V5cGF0aCA/IHJvb3RLZXlwYXRoICsgJy4nIDogJyc7XG5cdFx0XHRcdHByZWZpeGVyc1sgcm9vdEtleXBhdGggXSA9IGZ1bmN0aW9uKCByZWxhdGl2ZUtleXBhdGgsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBvYmo7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdG9iaiA9IHt9O1xuXHRcdFx0XHRcdFx0b2JqWyByb290RG90ICsgcmVsYXRpdmVLZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdFx0XHQvLyAncmVsYXRpdmVLZXlwYXRoJyBpcyBpbiBmYWN0IGEgaGFzaCwgbm90IGEga2V5cGF0aFxuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3REb3QgPyBwcmVmaXhLZXlwYXRoKCByZWxhdGl2ZUtleXBhdGgsIHJvb3RLZXlwYXRoICkgOiByZWxhdGl2ZUtleXBhdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWZpeGVyc1sgcm9vdEtleXBhdGggXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjb25maWcsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yLCBsb2csIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X21hZ2ljQXJyYXlBZGFwdG9yICk7XG5cblx0Lyogdmlld21vZGVsL2hlbHBlcnMvZ2V0VXBzdHJlYW1DaGFuZ2VzLmpzICovXG5cdHZhciBnZXRVcHN0cmVhbUNoYW5nZXMgPSBmdW5jdGlvbiBnZXRVcHN0cmVhbUNoYW5nZXMoIGNoYW5nZXMgKSB7XG5cdFx0dmFyIHVwc3RyZWFtQ2hhbmdlcyA9IFsgJycgXSxcblx0XHRcdGksIGtleXBhdGgsIGtleXMsIHVwc3RyZWFtS2V5cGF0aDtcblx0XHRpID0gY2hhbmdlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRrZXlwYXRoID0gY2hhbmdlc1sgaSBdO1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHVwc3RyZWFtS2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdGlmICggdXBzdHJlYW1DaGFuZ2VzLmluZGV4T2YoIHVwc3RyZWFtS2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMucHVzaCggdXBzdHJlYW1LZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVwc3RyZWFtQ2hhbmdlcztcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy9nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHN0YXJNYXBzID0ge307XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuXHRcdC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG5cdFx0Ly8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuXHRcdC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG5cdFx0Ly8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuXHRcdC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcygga2V5cGF0aCApIHtcblx0XHRcdHZhciBrZXlzLCBzdGFyTWFwLCBtYXBwZXIsIHJlc3VsdDtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKCBrZXlzLmxlbmd0aCApO1xuXHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIHN0YXIsIGkgKSB7XG5cdFx0XHRcdHJldHVybiBzdGFyID8gJyonIDoga2V5c1sgaSBdO1xuXHRcdFx0fTtcblx0XHRcdHJlc3VsdCA9IHN0YXJNYXAubWFwKCBmdW5jdGlvbiggbWFzayApIHtcblx0XHRcdFx0cmV0dXJuIG1hc2subWFwKCBtYXBwZXIgKS5qb2luKCAnLicgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHRoZSBwb3NzaWJsZSB0cnVlL2ZhbHNlIGNvbWJpbmF0aW9ucyBmb3Jcblx0XHQvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcblx0XHQvLyBbIHRydWUsIHRydWUgXSwgWyB0cnVlLCBmYWxzZSBdLCBbIGZhbHNlLCB0cnVlIF0sIFsgZmFsc2UsIGZhbHNlIF0uXG5cdFx0Ly8gSXQgZG9lcyBzbyBieSBnZXR0aW5nIGFsbCB0aGUgYmluYXJ5IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGUuZy4gMTFcblx0XHRmdW5jdGlvbiBnZXRTdGFyTWFwKCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgb25lcyA9ICcnLFxuXHRcdFx0XHRtYXgsIGJpbmFyeSwgc3Rhck1hcCwgbWFwcGVyLCBpO1xuXHRcdFx0aWYgKCAhc3Rhck1hcHNbIGxlbmd0aCBdICkge1xuXHRcdFx0XHRzdGFyTWFwID0gW107XG5cdFx0XHRcdHdoaWxlICggb25lcy5sZW5ndGggPCBsZW5ndGggKSB7XG5cdFx0XHRcdFx0b25lcyArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heCA9IHBhcnNlSW50KCBvbmVzLCAyICk7XG5cdFx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBkaWdpdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGlnaXQgPT09ICcxJztcblx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPD0gbWF4OyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YmluYXJ5ID0gaS50b1N0cmluZyggMiApO1xuXHRcdFx0XHRcdHdoaWxlICggYmluYXJ5Lmxlbmd0aCA8IGxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGJpbmFyeSA9ICcwJyArIGJpbmFyeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Rhck1hcFsgaSBdID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKCBiaW5hcnksIG1hcHBlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJNYXBzWyBsZW5ndGggXSA9IHN0YXJNYXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3Rhck1hcHNbIGxlbmd0aCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy9ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMgPSBmdW5jdGlvbiggZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBsYXN0S2V5ID0gL1teXFwuXSskLztcblx0XHRfX2V4cG9ydCA9IG5vdGlmeVBhdHRlcm5PYnNlcnZlcnM7XG5cblx0XHRmdW5jdGlvbiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGtleXBhdGgsIG9ubHlEaXJlY3QgKSB7XG5cdFx0XHR2YXIgcG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzO1xuXHRcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGtleXBhdGggKTtcblx0XHRcdGlmICggb25seURpcmVjdCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBrZXlwYXRoICk7XG5cdFx0XHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuZm9yRWFjaCggZnVuY3Rpb24oIHVwc3RyZWFtUGF0dGVybiApIHtcblx0XHRcdFx0Y2FzY2FkZSggdmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYXNjYWRlKCB2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCApIHtcblx0XHRcdHZhciBncm91cCwgbWFwLCBhY3R1YWxDaGlsZEtleXBhdGg7XG5cdFx0XHRncm91cCA9IHZpZXdtb2RlbC5kZXBzTWFwLnBhdHRlcm5PYnNlcnZlcnM7XG5cdFx0XHRtYXAgPSBncm91cFsgdXBzdHJlYW1QYXR0ZXJuIF07XG5cdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0bWFwLmZvckVhY2goIGZ1bmN0aW9uKCBjaGlsZEtleXBhdGggKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGxhc3RLZXkuZXhlYyggY2hpbGRLZXlwYXRoIClbIDAgXTtcblx0XHRcdFx0XHQvLyAnYmF6J1xuXHRcdFx0XHRcdGFjdHVhbENoaWxkS2V5cGF0aCA9IGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHRcdC8vICdmb28uYmFyLmJheidcblx0XHRcdFx0XHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwgYWN0dWFsQ2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0Y2FzY2FkZSggdmlld21vZGVsLCBjaGlsZEtleXBhdGgsIGFjdHVhbENoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR2aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5mb3JFYWNoKCBmdW5jdGlvbiggb2JzZXJ2ZXIgKSB7XG5cdFx0XHRcdGlmICggb2JzZXJ2ZXIucmVnZXgudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdG9ic2VydmVyLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdmlld21vZGVsJGFwcGx5Q2hhbmdlc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uKCBnZXRVcHN0cmVhbUNoYW5nZXMsIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGNoYW5nZXMsIHVwc3RyZWFtQ2hhbmdlcywgaGFzaCA9IHt9O1xuXHRcdFx0Y2hhbmdlcyA9IHRoaXMuY2hhbmdlcztcblx0XHRcdGlmICggIWNoYW5nZXMubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBUT0RPIHdlIGVuZCB1cCBoZXJlIG9uIGluaXRpYWwgcmVuZGVyLiBQZXJoYXBzIHdlIHNob3VsZG4ndD9cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYXNjYWRlKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgbWFwLCBkZXBlbmRhbnRzLCBrZXlzO1xuXHRcdFx0XHRpZiAoIHNlbGYubm9DYXNjYWRlLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZGVwZW5kYW50cyA9IHNlbGYuZGVwcy5jb21wdXRlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGRlcGVuZGFudHMuZm9yRWFjaCggaW52YWxpZGF0ZSApO1xuXHRcdFx0XHRcdGtleXMgPSBkZXBlbmRhbnRzLm1hcCggZ2V0S2V5ICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBtYXJrICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXAgPSBzZWxmLmRlcHNNYXAuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRtYXAuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG1hcmsoIGtleXBhdGggKSB7XG5cdFx0XHRcdHNlbGYubWFyaygga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHR1cHN0cmVhbUNoYW5nZXMgPSBnZXRVcHN0cmVhbUNoYW5nZXMoIGNoYW5nZXMgKTtcblx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGRlcGVuZGFudHMsIGtleXM7XG5cdFx0XHRcdGlmICggZGVwZW5kYW50cyA9IHNlbGYuZGVwcy5jb21wdXRlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGRlcGVuZGFudHMuZm9yRWFjaCggaW52YWxpZGF0ZSApO1xuXHRcdFx0XHRcdGtleXMgPSBkZXBlbmRhbnRzLm1hcCggZ2V0S2V5ICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBtYXJrICk7XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXHRcdFx0Ly8gUGF0dGVybiBvYnNlcnZlcnMgYXJlIGEgd2VpcmQgc3BlY2lhbCBjYXNlXG5cdFx0XHRpZiAoIHRoaXMucGF0dGVybk9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoLCB0cnVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZXBzLm9ic2VydmVycyApIHtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoIHRoaXMkMCwgbnVsbCwga2V5cGF0aCwgJ29ic2VydmVycycgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKCB0aGlzLCBjaGFuZ2VzLCAnb2JzZXJ2ZXJzJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlcHNbICdkZWZhdWx0JyBdICkge1xuXHRcdFx0XHR2YXIgYmluZGluZ3MgPSBbXTtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoIHRoaXMkMCwgYmluZGluZ3MsIGtleXBhdGgsICdkZWZhdWx0JyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggYmluZGluZ3MubGVuZ3RoICkge1xuXHRcdFx0XHRcdG5vdGlmeUJpbmRpbmdzKCB0aGlzLCBiaW5kaW5ncywgY2hhbmdlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vdGlmeUFsbERlcGVuZGFudHMoIHRoaXMsIGNoYW5nZXMsICdkZWZhdWx0JyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmV0dXJuIGEgaGFzaCBvZiBrZXlwYXRocyB0byB1cGRhdGVkIHZhbHVlc1xuXHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0aGFzaFsga2V5cGF0aCBdID0gdGhpcyQwLmdldCgga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcblx0XHRcdHRoaXMubm9DYXNjYWRlID0ge307XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW52YWxpZGF0ZSggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0S2V5KCBjb21wdXRhdGlvbiApIHtcblx0XHRcdHJldHVybiBjb21wdXRhdGlvbi5rZXk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGJpbmRpbmdzLCBrZXlwYXRoLCBncm91cE5hbWUgKSB7XG5cdFx0XHR2YXIgZGVwZW5kYW50cywgdmFsdWU7XG5cdFx0XHRpZiAoIGRlcGVuZGFudHMgPSBmaW5kRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUgKSApIHtcblx0XHRcdFx0dmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGRlcGVuZGFudHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgXCJzZXRcIiB0aGUgcGFyZW50IHZhbHVlLCByZWZpbmUgaXRcblx0XHRcdFx0XHQvLyBpLmUuIG5vdCBkYXRhID0gdmFsdWUsIGJ1dCBkYXRhW2Zvb10gPSBmb29WYWx1ZVxuXHRcdFx0XHRcdGlmICggYmluZGluZ3MgJiYgZC5yZWZpbmVWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGJpbmRpbmdzLnB1c2goIGQgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZC5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3RpZnlCaW5kaW5ncyggdmlld21vZGVsLCBiaW5kaW5ncywgY2hhbmdlcyApIHtcblx0XHRcdGJpbmRpbmdzLmZvckVhY2goIGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXHRcdFx0XHR2YXIgdXNlU2V0ID0gZmFsc2UsXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0bGVuZ3RoID0gY2hhbmdlcy5sZW5ndGgsXG5cdFx0XHRcdFx0cmVmaW5lbWVudHMgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBpIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdHZhciBrZXlwYXRoID0gY2hhbmdlc1sgaSBdO1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aCA9PT0gYmluZGluZy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0dXNlU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGtleXBhdGguc2xpY2UoIDAsIGJpbmRpbmcua2V5cGF0aC5sZW5ndGggKSA9PT0gYmluZGluZy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0cmVmaW5lbWVudHMucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB1c2VTZXQgKSB7XG5cdFx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZSggdmlld21vZGVsLmdldCggYmluZGluZy5rZXlwYXRoICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHJlZmluZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJlZmluZVZhbHVlKCByZWZpbmVtZW50cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5QWxsRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRocywgZ3JvdXBOYW1lICkge1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0XHRhZGRLZXlwYXRocygga2V5cGF0aHMgKTtcblx0XHRcdHF1ZXVlLmZvckVhY2goIGRpc3BhdGNoICk7XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEtleXBhdGhzKCBrZXlwYXRocyApIHtcblx0XHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggYWRkS2V5cGF0aCApO1xuXHRcdFx0XHRrZXlwYXRocy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEtleXBhdGgoIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBkZXBzID0gZmluZERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICk7XG5cdFx0XHRcdGlmICggZGVwcyApIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCB7XG5cdFx0XHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuXHRcdFx0XHRcdFx0ZGVwczogZGVwc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYXNjYWRlKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgY2hpbGREZXBzO1xuXHRcdFx0XHRpZiAoIGNoaWxkRGVwcyA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cE5hbWUgXVsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGFkZEtleXBhdGhzKCBjaGlsZERlcHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBkaXNwYXRjaCggc2V0ICkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBzZXQua2V5cGF0aCApO1xuXHRcdFx0XHRzZXQuZGVwcy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZC5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBncm91cCA9IHZpZXdtb2RlbC5kZXBzWyBncm91cE5hbWUgXTtcblx0XHRcdHJldHVybiBncm91cCA/IGdyb3VwWyBrZXlwYXRoIF0gOiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGdldFVwc3RyZWFtQ2hhbmdlcywgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jYXB0dXJlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY2FwdHVyZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRjYXB0dXJlKCkge1xuXHRcdHRoaXMuY2FwdHVyZUdyb3Vwcy5wdXNoKCBbXSApO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvY2xlYXJDYWNoZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBWaWV3bW9kZWwkY2xlYXJDYWNoZSgga2V5cGF0aCwgZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHR2YXIgY2FjaGVNYXAsIHdyYXBwZXI7XG5cdFx0aWYgKCAhZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG5cdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0Ly8gRGlkIHdlIHVud3JhcCBpdD9cblx0XHRcdFx0aWYgKCB3cmFwcGVyLnRlYXJkb3duKCkgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdC8vIElzIHRoaXMgcmlnaHQ/XG5cdFx0XHRcdFx0Ly8gV2hhdCdzIHRoZSBtZWFuaW5nIG9mIHJldHVybmluZyBmYWxzZSBmcm9tIHRlYXJkb3duP1xuXHRcdFx0XHRcdC8vIENvdWxkIHRoZXJlIGJlIGEgR0MgcmFtaWZpY2F0aW9uIGlmIHRoaXMgaXMgYSBcInJlYWxcIiByYWN0aXZlLnRlYXJkb3duKCk/XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuY2FjaGVbIGtleXBhdGggXSA9IHVuZGVmaW5lZDtcblx0XHRpZiAoIGNhY2hlTWFwID0gdGhpcy5jYWNoZU1hcFsga2V5cGF0aCBdICkge1xuXHRcdFx0d2hpbGUgKCBjYWNoZU1hcC5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJDYWNoZSggY2FjaGVNYXAucG9wKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL2dldENvbXB1dGF0aW9uU2lnbmF0dXJlLmpzICovXG5cdHZhciBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBwYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIHNpZ25hdHVyZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRnZXQ6IHNpZ25hdHVyZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRnZXQ6IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlIClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRzaWduYXR1cmUgPSB7XG5cdFx0XHRcdFx0Z2V0OiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZS5nZXQgKSxcblx0XHRcdFx0XHRzZXQ6IHNpZ25hdHVyZS5zZXRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzaWduYXR1cmU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlICkge1xuXHRcdFx0dmFyIGZ1bmN0aW9uQm9keSA9ICd2YXIgX19yYWN0aXZlPXRoaXM7cmV0dXJuKCcgKyBzaWduYXR1cmUucmVwbGFjZSggcGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCBrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm4gJ19fcmFjdGl2ZS5nZXQoXCInICsga2V5cGF0aCArICdcIiknO1xuXHRcdFx0fSApICsgJyknO1xuXHRcdFx0cmV0dXJuIG5ldyBGdW5jdGlvbiggZnVuY3Rpb25Cb2R5ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9Db21wdXRhdGlvbi5qcyAqL1xuXHR2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiggbG9nLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwgPSByYWN0aXZlLnZpZXdtb2RlbDtcblx0XHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdFx0dGhpcy5nZXR0ZXIgPSBzaWduYXR1cmUuZ2V0O1xuXHRcdFx0dGhpcy5zZXR0ZXIgPSBzaWduYXR1cmUuc2V0O1xuXHRcdFx0dGhpcy5oYXJkRGVwcyA9IHNpZ25hdHVyZS5kZXBzIHx8IFtdO1xuXHRcdFx0dGhpcy5zb2Z0RGVwcyA9IFtdO1xuXHRcdFx0dGhpcy5kZXBWYWx1ZXMgPSB7fTtcblx0XHRcdGlmICggdGhpcy5oYXJkRGVwcyApIHtcblx0XHRcdFx0dGhpcy5oYXJkRGVwcy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoIGQsIHRoaXMkMCwgJ2NvbXB1dGVkJyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IHRoaXMuX2ZpcnN0UnVuID0gdHJ1ZTtcblx0XHR9O1xuXHRcdENvbXB1dGF0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGNvbnN0cnVjdG9yOiBDb21wdXRhdGlvbixcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5pdGlhbDtcblx0XHRcdFx0dGhpcy5ieXBhc3MgPSB0cnVlO1xuXHRcdFx0XHRpbml0aWFsID0gdGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5ICk7XG5cdFx0XHRcdHRoaXMucmFjdGl2ZS52aWV3bW9kZWwuY2xlYXJDYWNoZSggdGhpcy5rZXkgKTtcblx0XHRcdFx0dGhpcy5ieXBhc3MgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRlciAmJiBpbml0aWFsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXQoIGluaXRpYWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGludmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciByYWN0aXZlLCBuZXdEZXBzLCBkZXBlbmRlbmNpZXNDaGFuZ2VkLCBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRoaXMuZ2V0dGluZyApIHtcblx0XHRcdFx0XHQvLyBwcmV2ZW50IGRvdWJsZS1jb21wdXRhdGlvbiAoZS5nLiBjYXVzZWQgYnkgYXJyYXkgbXV0YXRpb24gaW5zaWRlIGNvbXB1dGF0aW9uKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmdldHRpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIHRoaXMuX2RpcnR5ICkge1xuXHRcdFx0XHRcdHJhY3RpdmUgPSB0aGlzLnJhY3RpdmU7XG5cdFx0XHRcdFx0Ly8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGlucHV0cyBoYXZlIGNoYW5nZWQsIGluIGNhc2UgdGhpcyBkZXBlbmRzIG9uXG5cdFx0XHRcdFx0Ly8gb3RoZXIgY29tcHV0ZWQgdmFsdWVzXG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9maXJzdFJ1biB8fCAhdGhpcy5oYXJkRGVwcy5sZW5ndGggJiYgIXRoaXMuc29mdERlcHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdHRoaXMuaGFyZERlcHMsXG5cdFx0XHRcdFx0XHRcdHRoaXMuc29mdERlcHNcblx0XHRcdFx0XHRcdF0uZm9yRWFjaCggZnVuY3Rpb24oIGRlcHMgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBrZXlwYXRoLCB2YWx1ZSwgaTtcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSA9IGRlcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0XHRrZXlwYXRoID0gZGVwc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMkMC5kZXBWYWx1ZXNbIGtleXBhdGggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcyQwLmRlcFZhbHVlc1sga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgKSB7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCggcmFjdGl2ZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnZmFpbGVkQ29tcHV0YXRpb24nLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGtleTogdGhpcy5rZXksXG5cdFx0XHRcdFx0XHRcdFx0XHRlcnI6IGVyci5tZXNzYWdlIHx8IGVyclxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdm9pZCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bmV3RGVwcyA9IHJhY3RpdmUudmlld21vZGVsLnJlbGVhc2UoKTtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZURlcGVuZGVuY2llcyggbmV3RGVwcyApO1xuXHRcdFx0XHRcdFx0aWYgKCBkZXBlbmRlbmNpZXNDaGFuZ2VkICkge1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5oYXJkRGVwcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNvZnREZXBzXG5cdFx0XHRcdFx0XHRcdF0uZm9yRWFjaCggZnVuY3Rpb24oIGRlcHMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVwcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMkMC5kZXBWYWx1ZXNbIGtleXBhdGggXSA9IHJhY3RpdmUudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZ2V0dGluZyA9IHRoaXMuX2ZpcnN0UnVuID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZyApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXRoaXMuc2V0dGVyICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NvbXB1dGVkIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJzIGFyZSByZWFkLW9ubHkuIChUaGlzIG1heSBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlISknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zZXR0ZXIuY2FsbCggdGhpcy5yYWN0aXZlLCB2YWx1ZSApO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZURlcGVuZGVuY2llczogZnVuY3Rpb24oIG5ld0RlcHMgKSB7XG5cdFx0XHRcdHZhciBpLCBvbGREZXBzLCBrZXlwYXRoLCBkZXBlbmRlbmNpZXNDaGFuZ2VkO1xuXHRcdFx0XHRvbGREZXBzID0gdGhpcy5zb2Z0RGVwcztcblx0XHRcdFx0Ly8gcmVtb3ZlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZFxuXHRcdFx0XHRpID0gb2xkRGVwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGtleXBhdGggPSBvbGREZXBzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBuZXdEZXBzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZXMgZm9yIGFueSBuZXcgZGVwZW5kZW5jaWVzXG5cdFx0XHRcdGkgPSBuZXdEZXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0a2V5cGF0aCA9IG5ld0RlcHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9sZERlcHMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSAmJiAoICF0aGlzLmhhcmREZXBzIHx8IHRoaXMuaGFyZERlcHMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgdGhpcywgJ2NvbXB1dGVkJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGRlcGVuZGVuY2llc0NoYW5nZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zb2Z0RGVwcyA9IG5ld0RlcHMuc2xpY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzQ2hhbmdlZDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBDb21wdXRhdGlvbjtcblx0fSggbG9nLCBpc0VxdWFsICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jb21wdXRlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY29tcHV0ZSA9IGZ1bmN0aW9uKCBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSwgQ29tcHV0YXRpb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGNvbXB1dGUoIGtleSwgc2lnbmF0dXJlICkge1xuXHRcdFx0c2lnbmF0dXJlID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUoIHNpZ25hdHVyZSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY29tcHV0YXRpb25zWyBrZXkgXSA9IG5ldyBDb21wdXRhdGlvbiggdGhpcy5yYWN0aXZlLCBrZXksIHNpZ25hdHVyZSApO1xuXHRcdH07XG5cdH0oIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlLCBDb21wdXRhdGlvbiApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L0ZBSUxFRF9MT09LVVAuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfRkFJTEVEX0xPT0tVUCA9IHtcblx0XHRGQUlMRURfTE9PS1VQOiB0cnVlXG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9VbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApIHtcblxuXHRcdHZhciBlbXB0eSA9IHt9O1xuXHRcdHZhciBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gZnVuY3Rpb24oIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHRoaXMudmlld21vZGVsID0gdmlld21vZGVsO1xuXHRcdFx0dGhpcy5yb290ID0gdmlld21vZGVsLnJhY3RpdmU7XG5cdFx0XHQvLyBUT0RPIGVsaW1pbmF0ZSB0aGlzXG5cdFx0XHR0aGlzLnJlZiA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZW1wdHk7XG5cdFx0XHR2aWV3bW9kZWwudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzWyBrZXlwYXRoIF0gPSB0cnVlO1xuXHRcdFx0dmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcy5wdXNoKCB0aGlzICk7XG5cdFx0XHRydW5sb29wLmFkZFVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kucHJvdG90eXBlID0ge1xuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIHRoaXMucmVmICk7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sgdGhpcy5yZWYgXSA9IGZhbHNlO1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMudmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXQgPSBmdW5jdGlvbiggaXNOdW1lcmljLCBGQUlMRURfTE9PS1VQLCBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBlbXB0eSA9IHt9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJGdldCgga2V5cGF0aCApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSBlbXB0eTtcblx0XHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlLFxuXHRcdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUsXG5cdFx0XHRcdHZhbHVlLCBjb21wdXRhdGlvbiwgd3JhcHBlZCwgY2FwdHVyZUdyb3VwO1xuXHRcdFx0aWYgKCBrZXlwYXRoWyAwIF0gPT09ICdAJyApIHtcblx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnNsaWNlKCAxICk7XG5cdFx0XHRcdHJldHVybiBpc051bWVyaWMoIHZhbHVlICkgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggY2FjaGVbIGtleXBhdGggXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBJcyB0aGlzIGEgY29tcHV0ZWQgcHJvcGVydHk/XG5cdFx0XHRcdGlmICggKCBjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zWyBrZXlwYXRoIF0gKSAmJiAhY29tcHV0YXRpb24uYnlwYXNzICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG5cdFx0XHRcdFx0dGhpcy5hZGFwdCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggd3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGFwdCggJycsIHJhY3RpdmUuZGF0YSApO1xuXHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS5kYXRhO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gcmV0cmlldmUoIHRoaXMsIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWNoZVsga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IGNhY2hlWyBrZXlwYXRoIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMuZXZhbHVhdGVXcmFwcGVkICYmICggd3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlZC5nZXQoKTtcblx0XHRcdH1cblx0XHRcdC8vIGNhcHR1cmUgdGhlIGtleXBhdGgsIGlmIHdlJ3JlIGluc2lkZSBhIGNvbXB1dGF0aW9uXG5cdFx0XHRpZiAoIG9wdGlvbnMuY2FwdHVyZSAmJiAoIGNhcHR1cmVHcm91cCA9IHRoaXMuY2FwdHVyZUdyb3Vwc1sgdGhpcy5jYXB0dXJlR3JvdXBzLmxlbmd0aCAtIDEgXSApICkge1xuXHRcdFx0XHRpZiAoICF+Y2FwdHVyZUdyb3VwLmluZGV4T2YoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRjYXB0dXJlR3JvdXAucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdC8vIGlmIHdlIGNvdWxkbid0IHJlc29sdmUgdGhlIGtleXBhdGgsIHdlIG5lZWQgdG8gbWFrZSBpdCBhcyBhIGZhaWxlZFxuXHRcdFx0XHRcdC8vIGxvb2t1cCwgc28gdGhhdCB0aGUgY29tcHV0YXRpb24gdXBkYXRlcyBjb3JyZWN0bHkgb25jZSB3ZSBDQU5cblx0XHRcdFx0XHQvLyByZXNvbHZlIHRoZSBrZXlwYXRoXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCAmJiB0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sga2V5cGF0aCBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0bmV3IFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3koIHRoaXMsIGtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCA/IHZvaWQgMCA6IHZhbHVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXRyaWV2ZSggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIGtleSwgcGFyZW50S2V5cGF0aCwgcGFyZW50VmFsdWUsIGNhY2hlTWFwLCB2YWx1ZSwgd3JhcHBlZDtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdGtleSA9IGtleXMucG9wKCk7XG5cdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0aWYgKCB3cmFwcGVkID0gdmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXSApIHtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJlbnRWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgY2FjaGUgbWFwXG5cdFx0XHRpZiAoICEoIGNhY2hlTWFwID0gdmlld21vZGVsLmNhY2hlTWFwWyBwYXJlbnRLZXlwYXRoIF0gKSApIHtcblx0XHRcdFx0dmlld21vZGVsLmNhY2hlTWFwWyBwYXJlbnRLZXlwYXRoIF0gPSBbIGtleXBhdGggXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggY2FjaGVNYXAuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0XHRjYWNoZU1hcC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBleGlzdCwgd2UgcmV0dXJuIGEgc2VudGluZWwgdmFsdWVcblx0XHRcdC8vIHNvIHRoYXQgd2Uga25vdyB0byBxdWVyeSBwYXJlbnQgc2NvcGUgKGlmIHN1Y2ggdGhlcmUgYmUpXG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgISgga2V5IGluIHBhcmVudFZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB2aWV3bW9kZWwuY2FjaGVbIGtleXBhdGggXSA9IEZBSUxFRF9MT09LVVA7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHBhcmVudFZhbHVlWyBrZXkgXTtcblx0XHRcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cblx0XHRcdHZpZXdtb2RlbC5hZGFwdCgga2V5cGF0aCwgdmFsdWUsIGZhbHNlICk7XG5cdFx0XHQvLyBVcGRhdGUgY2FjaGVcblx0XHRcdHZpZXdtb2RlbC5jYWNoZVsga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggaXNOdW1lcmljLCB2aWV3bW9kZWwkZ2V0X0ZBSUxFRF9MT09LVVAsIHZpZXdtb2RlbCRnZXRfVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGluaXQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRpbml0KCkge1xuXHRcdFx0dmFyIGtleSwgY29tcHV0YXRpb24sIGNvbXB1dGF0aW9ucyA9IFtdO1xuXHRcdFx0Zm9yICgga2V5IGluIHRoaXMucmFjdGl2ZS5jb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGUoIGtleSwgdGhpcy5yYWN0aXZlLmNvbXB1dGVkWyBrZXkgXSApO1xuXHRcdFx0XHRjb21wdXRhdGlvbnMucHVzaCggY29tcHV0YXRpb24gKTtcblx0XHRcdH1cblx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKCBpbml0ICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXQoIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0Y29tcHV0YXRpb24uaW5pdCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL21hcmsuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtYXJrID0gZnVuY3Rpb24gVmlld21vZGVsJG1hcmsoIGtleXBhdGgsIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGNvbXB1dGF0aW9uO1xuXHRcdC8vIGltcGxpY2l0IGNoYW5nZXMgKGkuZS4gYGZvby5sZW5ndGhgIG9uIGByYWN0aXZlLnB1c2goJ2ZvbycsNDIpYClcblx0XHQvLyBzaG91bGQgbm90IGJlIHBpY2tlZCB1cCBieSBwYXR0ZXJuIG9ic2VydmVyc1xuXHRcdGlmICggb3B0aW9ucyApIHtcblx0XHRcdGlmICggb3B0aW9ucy5pbXBsaWNpdCApIHtcblx0XHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMubm9DYXNjYWRlICkge1xuXHRcdFx0XHR0aGlzLm5vQ2FzY2FkZVsga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5jaGFuZ2VzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHR0aGlzLmNoYW5nZXMucHVzaCgga2V5cGF0aCApO1xuXHRcdH1cblx0XHR0aGlzLmNsZWFyQ2FjaGUoIGtleXBhdGggKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL21lcmdlL21hcE9sZFRvTmV3SW5kZXguanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtZXJnZV9tYXBPbGRUb05ld0luZGV4ID0gZnVuY3Rpb24oIG9sZEFycmF5LCBuZXdBcnJheSApIHtcblx0XHR2YXIgdXNlZEluZGljZXMsIGZpcnN0VW51c2VkSW5kZXgsIG5ld0luZGljZXMsIGNoYW5nZWQ7XG5cdFx0dXNlZEluZGljZXMgPSB7fTtcblx0XHRmaXJzdFVudXNlZEluZGV4ID0gMDtcblx0XHRuZXdJbmRpY2VzID0gb2xkQXJyYXkubWFwKCBmdW5jdGlvbiggaXRlbSwgaSApIHtcblx0XHRcdHZhciBpbmRleCwgc3RhcnQsIGxlbjtcblx0XHRcdHN0YXJ0ID0gZmlyc3RVbnVzZWRJbmRleDtcblx0XHRcdGxlbiA9IG5ld0FycmF5Lmxlbmd0aDtcblx0XHRcdGRvIHtcblx0XHRcdFx0aW5kZXggPSBuZXdBcnJheS5pbmRleE9mKCBpdGVtLCBzdGFydCApO1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnQgPSBpbmRleCArIDE7XG5cdFx0XHR9IHdoaWxlICggdXNlZEluZGljZXNbIGluZGV4IF0gJiYgc3RhcnQgPCBsZW4gKTtcblx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHVudXNlZCBpbmRleCwgc28gd2UgZG9uJ3Qgc2VhcmNoXG5cdFx0XHQvLyB0aGUgd2hvbGUgb2YgbmV3QXJyYXkgZm9yIGVhY2ggaXRlbSBpbiBvbGRBcnJheSB1bm5lY2Vzc2FyaWx5XG5cdFx0XHRpZiAoIGluZGV4ID09PSBmaXJzdFVudXNlZEluZGV4ICkge1xuXHRcdFx0XHRmaXJzdFVudXNlZEluZGV4ICs9IDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ICE9PSBpICkge1xuXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHVzZWRJbmRpY2VzWyBpbmRleCBdID0gdHJ1ZTtcblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIG5ld0luZGljZXM7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tZXJnZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1lcmdlID0gZnVuY3Rpb24oIHdhcm4sIG1hcE9sZFRvTmV3SW5kZXggKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGNvbXBhcmF0b3JzID0ge307XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkbWVyZ2UoIGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgb2xkQXJyYXksIG5ld0FycmF5LCBjb21wYXJhdG9yLCBuZXdJbmRpY2VzO1xuXHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJlICkge1xuXHRcdFx0XHRjb21wYXJhdG9yID0gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKCBvcHRpb25zLmNvbXBhcmUgKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheS5tYXAoIGNvbXBhcmF0b3IgKTtcblx0XHRcdFx0XHRuZXdBcnJheSA9IGFycmF5Lm1hcCggY29tcGFyYXRvciApO1xuXHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdC8vIGZhbGxiYWNrIHRvIGFuIGlkZW50aXR5IGNoZWNrIC0gd29yc3QgY2FzZSBzY2VuYXJpbyB3ZSBoYXZlXG5cdFx0XHRcdFx0Ly8gdG8gZG8gbW9yZSBET00gbWFuaXB1bGF0aW9uIHRoYW4gd2UgdGhvdWdodC4uLlxuXHRcdFx0XHRcdC8vIC4uLnVubGVzcyB3ZSdyZSBpbiBkZWJ1ZyBtb2RlIG9mIGNvdXJzZVxuXHRcdFx0XHRcdGlmICggdGhpcy5kZWJ1ZyApIHtcblx0XHRcdFx0XHRcdHRocm93IGVycjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0d2FybiggJ01lcmdlIG9wZXJhdGlvbjogY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG5cdFx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG5cdFx0XHRcdG5ld0FycmF5ID0gYXJyYXk7XG5cdFx0XHR9XG5cdFx0XHQvLyBmaW5kIG5ldyBpbmRpY2VzIGZvciBtZW1iZXJzIG9mIG9sZEFycmF5XG5cdFx0XHRuZXdJbmRpY2VzID0gbWFwT2xkVG9OZXdJbmRleCggb2xkQXJyYXksIG5ld0FycmF5ICk7XG5cdFx0XHR0aGlzLnNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcywgY3VycmVudEFycmF5Lmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeSggaXRlbSApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggaXRlbSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbXBhcmF0b3JGdW5jdGlvbiggY29tcGFyYXRvciApIHtcblx0XHRcdC8vIElmIGBjb21wYXJlYCBpcyBgdHJ1ZWAsIHdlIHVzZSBKU09OLnN0cmluZ2lmeSB0byBjb21wYXJlXG5cdFx0XHQvLyBvYmplY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHNoYXBlLCBidXQgbm9uLWlkZW50aWNhbCAtIGkuZS5cblx0XHRcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuXHRcdFx0aWYgKCBjb21wYXJhdG9yID09PSB0cnVlICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggIWNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF0gKSB7XG5cdFx0XHRcdFx0Y29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXSA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW1bIGNvbXBhcmF0b3IgXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgYGNvbXBhcmVgIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24sIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBpZGVudGlmeWluZyBmaWVsZCAob3IgYHRydWVgIHRvIHVzZSBKU09OLnN0cmluZ2lmeSknICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggd2Fybiwgdmlld21vZGVsJG1lcmdlX21hcE9sZFRvTmV3SW5kZXggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3JlZ2lzdGVyLmpzICovXG5cdHZhciB2aWV3bW9kZWwkcmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWdpc3Rlcigga2V5cGF0aCwgZGVwZW5kYW50ICkge1xuXHRcdFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIGdyb3VwID09PSB2b2lkIDAgKVxuXHRcdFx0XHRncm91cCA9ICdkZWZhdWx0Jztcblx0XHRcdHZhciBkZXBzQnlLZXlwYXRoLCBkZXBzO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnQuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlcHNCeUtleXBhdGggPSB0aGlzLmRlcHNbIGdyb3VwIF0gfHwgKCB0aGlzLmRlcHNbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0ZGVwcyA9IGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSB8fCAoIGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRkZXBzLnB1c2goIGRlcGVuZGFudCApO1xuXHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlRGVwZW5kYW50c01hcCggdGhpcywga2V5cGF0aCwgZ3JvdXAgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlRGVwZW5kYW50c01hcCggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cCApIHtcblx0XHRcdHZhciBrZXlzLCBwYXJlbnRLZXlwYXRoLCBtYXAsIHBhcmVudDtcblx0XHRcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdIHx8ICggdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0XHRwYXJlbnQgPSBtYXBbIHBhcmVudEtleXBhdGggXSB8fCAoIG1hcFsgcGFyZW50S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0aWYgKCBwYXJlbnRbIGtleXBhdGggXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdID0gMDtcblx0XHRcdFx0XHRwYXJlbnQucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdICs9IDE7XG5cdFx0XHRcdGtleXBhdGggPSBwYXJlbnRLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3JlbGVhc2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRyZWxlYXNlID0gZnVuY3Rpb24gVmlld21vZGVsJHJlbGVhc2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FwdHVyZUdyb3Vwcy5wb3AoKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3NldC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHNldCA9IGZ1bmN0aW9uKCBpc0VxdWFsLCBjcmVhdGVCcmFuY2ggKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgc2lsZW50ICkge1xuXHRcdFx0dmFyIGNvbXB1dGF0aW9uLCB3cmFwcGVyLCBkb250VGVhcmRvd25XcmFwcGVyO1xuXHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjb21wdXRhdGlvbiApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRhdGlvbi5zZXR0aW5nICkge1xuXHRcdFx0XHRcdC8vIGxldCB0aGUgb3RoZXIgY29tcHV0YXRpb24gc2V0KCkgaGFuZGxlIHRoaW5ncy4uLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb21wdXRhdGlvbi5zZXQoIHZhbHVlICk7XG5cdFx0XHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGlzRXF1YWwoIHRoaXMuY2FjaGVbIGtleXBhdGggXSwgdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdO1xuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHdyYXBwZXIgd2l0aCBhIGByZXNldCgpYCBtZXRob2QsIHdlIHRyeSBhbmQgdXNlIGl0LiBJZiB0aGVcblx0XHRcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG5cdFx0XHQvLyAobW9zdCBsaWtlbHkpIGEgbmV3IG9uZSBzaG91bGQgYmUgY3JlYXRlZCBsYXRlclxuXHRcdFx0aWYgKCB3cmFwcGVyICYmIHdyYXBwZXIucmVzZXQgKSB7XG5cdFx0XHRcdGRvbnRUZWFyZG93bldyYXBwZXIgPSB3cmFwcGVyLnJlc2V0KCB2YWx1ZSApICE9PSBmYWxzZTtcblx0XHRcdFx0aWYgKCBkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhY29tcHV0YXRpb24gJiYgIWRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0XHRcdHJlc29sdmVTZXQoIHRoaXMsIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFzaWxlbnQgKSB7XG5cdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UncmUgc2V0dGluZyBhIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdGFyZ2V0IGtleXBhdGggKGkuZS5cblx0XHRcdFx0Ly8gY3JlYXRpbmcgYSBmcmVzaCBicmFuY2gpIC0gd2UgbmVlZCB0byBjbGVhciB0aGUgY2FjaGUsIGJ1dFxuXHRcdFx0XHQvLyBub3QgbWFyayBpdCBhcyBhIGNoYW5nZVxuXHRcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVNldCggdmlld21vZGVsLCBrZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdHZhciBrZXlzLCBsYXN0S2V5LCBwYXJlbnRLZXlwYXRoLCB3cmFwcGVyLCBwYXJlbnRWYWx1ZSwgd3JhcHBlclNldCwgdmFsdWVTZXQ7XG5cdFx0XHR3cmFwcGVyU2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggd3JhcHBlci5zZXQgKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5zZXQoIGxhc3RLZXksIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0XHRcdHZhbHVlU2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR2YWx1ZVNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFwYXJlbnRWYWx1ZSApIHtcblx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaCggbGFzdEtleSApO1xuXHRcdFx0XHRcdHZpZXdtb2RlbC5zZXQoIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50VmFsdWVbIGxhc3RLZXkgXSA9IHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdGxhc3RLZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHR3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXTtcblx0XHRcdGlmICggd3JhcHBlciApIHtcblx0XHRcdFx0d3JhcHBlclNldCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdC8vIG1heSBoYXZlIGJlZW4gd3JhcHBlZCB2aWEgdGhlIGFib3ZlIC5nZXQoKVxuXHRcdFx0XHQvLyBjYWxsIG9uIHZpZXdtb2RlbCBpZiB0aGlzIGlzIGZpcnN0IGFjY2VzcyB2aWEgLnNldCgpIVxuXHRcdFx0XHRpZiAoIHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHdyYXBwZXJTZXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZVNldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggaXNFcXVhbCwgY3JlYXRlQnJhbmNoICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9zbWFydFVwZGF0ZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHNtYXJ0VXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGltcGxpY2l0T3B0aW9uID0ge1xuXHRcdFx0XHRpbXBsaWNpdDogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdG5vQ2FzY2FkZU9wdGlvbiA9IHtcblx0XHRcdFx0bm9DYXNjYWRlOiB0cnVlXG5cdFx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJHNtYXJ0VXBkYXRlKCBrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIGRlcGVuZGFudHMsIG9sZExlbmd0aDtcblx0XHRcdG9sZExlbmd0aCA9IG5ld0luZGljZXMubGVuZ3RoO1xuXHRcdFx0Ly8gSW5kaWNlcyB0aGF0IGFyZSBiZWluZyByZW1vdmVkIHNob3VsZCBiZSBtYXJrZWQgYXMgZGlydHlcblx0XHRcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24oIG5ld0luZGV4LCBvbGRJbmRleCApIHtcblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dGhpcyQwLm1hcmsoIGtleXBhdGggKyAnLicgKyBvbGRJbmRleCwgbm9DYXNjYWRlT3B0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdC8vIFVwZGF0ZSB0aGUgbW9kZWxcblx0XHRcdC8vIFRPRE8gYWxsb3cgZXhpc3RpbmcgYXJyYXkgdG8gYmUgdXBkYXRlZCBpbiBwbGFjZSwgcmF0aGVyIHRoYW4gcmVwbGFjZWQ/XG5cdFx0XHR0aGlzLnNldCgga2V5cGF0aCwgYXJyYXksIHRydWUgKTtcblx0XHRcdGlmICggZGVwZW5kYW50cyA9IHRoaXMuZGVwc1sgJ2RlZmF1bHQnIF1bIGtleXBhdGggXSApIHtcblx0XHRcdFx0ZGVwZW5kYW50cy5maWx0ZXIoIGNhblNodWZmbGUgKS5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZC5zaHVmZmxlKCBuZXdJbmRpY2VzLCBhcnJheSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9sZExlbmd0aCAhPT0gYXJyYXkubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKyAnLmxlbmd0aCcsIGltcGxpY2l0T3B0aW9uICk7XG5cdFx0XHRcdGZvciAoIHZhciBpID0gb2xkTGVuZ3RoOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICsgJy4nICsgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvbid0IGFsbG93IHJlbW92ZWQgaW5kZXhlcyBiZXlvbmQgZW5kIG9mIG5ldyBhcnJheSB0byB0cmlnZ2VyIHJlY29tcHV0YXRpb25zXG5cdFx0XHRcdGZvciAoIHZhciBpJDAgPSBhcnJheS5sZW5ndGg7IGkkMCA8IG9sZExlbmd0aDsgaSQwICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICsgJy4nICsgaSQwLCBub0Nhc2NhZGVPcHRpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjYW5TaHVmZmxlKCBkZXBlbmRhbnQgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGRlcGVuZGFudC5zaHVmZmxlID09PSAnZnVuY3Rpb24nO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3RlYXJkb3duLmpzICovXG5cdHZhciB2aWV3bW9kZWwkdGVhcmRvd24gPSBmdW5jdGlvbiBWaWV3bW9kZWwkdGVhcmRvd24oKSB7XG5cdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0dmFyIHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cdFx0Ly8gQ2xlYXIgZW50aXJlIGNhY2hlIC0gdGhpcyBoYXMgdGhlIGRlc2lyZWQgc2lkZS1lZmZlY3Rcblx0XHQvLyBvZiB1bndyYXBwaW5nIGFkYXB0ZWQgdmFsdWVzIChlLmcuIGFycmF5cylcblx0XHRPYmplY3Qua2V5cyggdGhpcy5jYWNoZSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMkMC5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0fSApO1xuXHRcdC8vIFRlYXJkb3duIGFueSBmYWlsZWQgbG9va3VwcyAtIHdlIGRvbid0IG5lZWQgdGhlbSB0byByZXNvbHZlIGFueSBtb3JlXG5cdFx0d2hpbGUgKCB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucG9wKCkgKSB7XG5cdFx0XHR1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnRlYXJkb3duKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvdW5yZWdpc3Rlci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHVucmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCR1bnJlZ2lzdGVyKCBrZXlwYXRoLCBkZXBlbmRhbnQgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbIDIgXTtcblx0XHRcdGlmICggZ3JvdXAgPT09IHZvaWQgMCApXG5cdFx0XHRcdGdyb3VwID0gJ2RlZmF1bHQnO1xuXHRcdFx0dmFyIGRlcHMsIGluZGV4O1xuXHRcdFx0aWYgKCBkZXBlbmRhbnQuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlcHMgPSB0aGlzLmRlcHNbIGdyb3VwIF1bIGtleXBhdGggXTtcblx0XHRcdGluZGV4ID0gZGVwcy5pbmRleE9mKCBkZXBlbmRhbnQgKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgZGVwZW5kYW50IHRoYXQgd2FzIG5vIGxvbmdlciByZWdpc3RlcmVkISBUaGlzIHNob3VsZCBub3QgaGFwcGVuLiBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIGJ1ZyBpbiBkZXZlbG9wbWVudCBwbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcycgKTtcblx0XHRcdH1cblx0XHRcdGRlcHMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlRGVwZW5kYW50c01hcCggdGhpcywga2V5cGF0aCwgZ3JvdXAgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlRGVwZW5kYW50c01hcCggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cCApIHtcblx0XHRcdHZhciBrZXlzLCBwYXJlbnRLZXlwYXRoLCBtYXAsIHBhcmVudDtcblx0XHRcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdO1xuXHRcdFx0XHRwYXJlbnQgPSBtYXBbIHBhcmVudEtleXBhdGggXTtcblx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gLT0gMTtcblx0XHRcdFx0aWYgKCAhcGFyZW50WyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIGZyb20gcGFyZW50IGRlcHMgbWFwXG5cdFx0XHRcdFx0cGFyZW50LnNwbGljZSggcGFyZW50LmluZGV4T2YoIGtleXBhdGggKSwgMSApO1xuXHRcdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSBwYXJlbnRLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvYWRhcHRDb25maWcuanMgKi9cblx0dmFyIGFkYXB0Q29uZmlnID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBzaG91bGQgdGhpcyBiZSBjb21iaW5lZCB3aXRoIHByb3RvdHlwZS9hZGFwdC5qcz9cblx0XHR2YXIgY29uZmlndXJlID0ge1xuXHRcdFx0bG9va3VwOiBmdW5jdGlvbiggdGFyZ2V0LCBhZGFwdG9ycyApIHtcblx0XHRcdFx0dmFyIGksIGFkYXB0ID0gdGFyZ2V0LmFkYXB0O1xuXHRcdFx0XHRpZiAoICFhZGFwdCB8fCAhYWRhcHQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFkYXB0b3JzICYmIE9iamVjdC5rZXlzKCBhZGFwdG9ycyApLmxlbmd0aCAmJiAoIGkgPSBhZGFwdC5sZW5ndGggKSApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHZhciBhZGFwdG9yID0gYWRhcHRbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGFkYXB0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0XHRhZGFwdFsgaSBdID0gYWRhcHRvcnNbIGFkYXB0b3IgXSB8fCBhZGFwdG9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHR9LFxuXHRcdFx0Y29tYmluZTogZnVuY3Rpb24oIHBhcmVudCwgYWRhcHQgKSB7XG5cdFx0XHRcdC8vIG5vcm1hbGl6ZSAnRm9vJyB0byBbICdGb28nIF1cblx0XHRcdFx0cGFyZW50ID0gYXJyYXlJZlN0cmluZyggcGFyZW50ICk7XG5cdFx0XHRcdGFkYXB0ID0gYXJyYXlJZlN0cmluZyggYWRhcHQgKTtcblx0XHRcdFx0Ly8gbm8gcGFyZW50PyByZXR1cm4gYWRhcHRcblx0XHRcdFx0aWYgKCAhcGFyZW50IHx8ICFwYXJlbnQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBubyBhZGFwdD8gcmV0dXJuICdjb3B5JyBvZiBwYXJlbnRcblx0XHRcdFx0aWYgKCAhYWRhcHQgfHwgIWFkYXB0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LnNsaWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRkIHBhcmVudCBhZGFwdG9ycyB0byBvcHRpb25zXG5cdFx0XHRcdHBhcmVudC5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHQvLyBkb24ndCBwdXQgaW4gZHVwbGljYXRlc1xuXHRcdFx0XHRcdGlmICggYWRhcHQuaW5kZXhPZiggYSApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGFkYXB0LnB1c2goIGEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhcnJheUlmU3RyaW5nKCBhZGFwdCApIHtcblx0XHRcdGlmICggdHlwZW9mIGFkYXB0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YWRhcHQgPSBbIGFkYXB0IF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0fVxuXHRcdHJldHVybiBjb25maWd1cmU7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvVmlld21vZGVsLmpzICovXG5cdHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiggY3JlYXRlLCBhZGFwdCwgYXBwbHlDaGFuZ2VzLCBjYXB0dXJlLCBjbGVhckNhY2hlLCBjb21wdXRlLCBnZXQsIGluaXQsIG1hcmssIG1lcmdlLCByZWdpc3RlciwgcmVsZWFzZSwgc2V0LCBzbWFydFVwZGF0ZSwgdGVhcmRvd24sIHVucmVnaXN0ZXIsIGFkYXB0Q29uZmlnICkge1xuXG5cdFx0dmFyIG5vTWFnaWM7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgge30sICd0ZXN0Jywge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSApO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRub01hZ2ljID0gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdC8vIFRPRE8gZXZlbnR1YWxseSwgd2Ugc2hvdWxkbid0IG5lZWQgdGhpcyByZWZlcmVuY2Vcblx0XHRcdFZpZXdtb2RlbC5leHRlbmQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUgKTtcblx0XHRcdHRoaXMuY2FjaGUgPSB7fTtcblx0XHRcdC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byB1c2UgaGFzT3duUHJvcGVydHksIHNvIGNhbid0IGluaGVyaXQgZnJvbSBudWxsXG5cdFx0XHR0aGlzLmNhY2hlTWFwID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmRlcHMgPSB7XG5cdFx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdFx0J2RlZmF1bHQnOiB7fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMuZGVwc01hcCA9IHtcblx0XHRcdFx0Y29tcHV0ZWQ6IHt9LFxuXHRcdFx0XHQnZGVmYXVsdCc6IHt9XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzID0gW107XG5cdFx0XHR0aGlzLndyYXBwZWQgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdHRoaXMuY29tcHV0YXRpb25zID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmNhcHR1cmVHcm91cHMgPSBbXTtcblx0XHRcdHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHR0aGlzLmNoYW5nZXMgPSBbXTtcblx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG5cdFx0XHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXHRcdH07XG5cdFx0Vmlld21vZGVsLmV4dGVuZCA9IGZ1bmN0aW9uKCBQYXJlbnQsIGluc3RhbmNlICkge1xuXHRcdFx0aWYgKCBpbnN0YW5jZS5tYWdpYyAmJiBub01hZ2ljICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdHZXR0ZXJzIGFuZCBzZXR0ZXJzIChtYWdpYyBtb2RlKSBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0YW5jZS5hZGFwdCA9IGFkYXB0Q29uZmlnLmNvbWJpbmUoIFBhcmVudC5wcm90b3R5cGUuYWRhcHQsIGluc3RhbmNlLmFkYXB0ICkgfHwgW107XG5cdFx0XHRpbnN0YW5jZS5hZGFwdCA9IGFkYXB0Q29uZmlnLmxvb2t1cCggaW5zdGFuY2UsIGluc3RhbmNlLmFkYXB0b3JzICk7XG5cdFx0fTtcblx0XHRWaWV3bW9kZWwucHJvdG90eXBlID0ge1xuXHRcdFx0YWRhcHQ6IGFkYXB0LFxuXHRcdFx0YXBwbHlDaGFuZ2VzOiBhcHBseUNoYW5nZXMsXG5cdFx0XHRjYXB0dXJlOiBjYXB0dXJlLFxuXHRcdFx0Y2xlYXJDYWNoZTogY2xlYXJDYWNoZSxcblx0XHRcdGNvbXB1dGU6IGNvbXB1dGUsXG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRtYXJrOiBtYXJrLFxuXHRcdFx0bWVyZ2U6IG1lcmdlLFxuXHRcdFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxuXHRcdFx0cmVsZWFzZTogcmVsZWFzZSxcblx0XHRcdHNldDogc2V0LFxuXHRcdFx0c21hcnRVcGRhdGU6IHNtYXJ0VXBkYXRlLFxuXHRcdFx0dGVhcmRvd246IHRlYXJkb3duLFxuXHRcdFx0dW5yZWdpc3RlcjogdW5yZWdpc3RlclxuXHRcdH07XG5cdFx0cmV0dXJuIFZpZXdtb2RlbDtcblx0fSggY3JlYXRlLCB2aWV3bW9kZWwkYWRhcHQsIHZpZXdtb2RlbCRhcHBseUNoYW5nZXMsIHZpZXdtb2RlbCRjYXB0dXJlLCB2aWV3bW9kZWwkY2xlYXJDYWNoZSwgdmlld21vZGVsJGNvbXB1dGUsIHZpZXdtb2RlbCRnZXQsIHZpZXdtb2RlbCRpbml0LCB2aWV3bW9kZWwkbWFyaywgdmlld21vZGVsJG1lcmdlLCB2aWV3bW9kZWwkcmVnaXN0ZXIsIHZpZXdtb2RlbCRyZWxlYXNlLCB2aWV3bW9kZWwkc2V0LCB2aWV3bW9kZWwkc21hcnRVcGRhdGUsIHZpZXdtb2RlbCR0ZWFyZG93biwgdmlld21vZGVsJHVucmVnaXN0ZXIsIGFkYXB0Q29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9pbml0aWFsaXNlLmpzICovXG5cdHZhciBSYWN0aXZlX2luaXRpYWxpc2UgPSBmdW5jdGlvbiggY29uZmlnLCBjcmVhdGUsIEZyYWdtZW50LCBnZXRFbGVtZW50LCBnZXROZXh0TnVtYmVyLCBIb29rLCBIb29rUXVldWUsIFZpZXdtb2RlbCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgY29uc3RydWN0SG9vayA9IG5ldyBIb29rKCAnY29uc3RydWN0JyApLFxuXHRcdFx0Y29uZmlnSG9vayA9IG5ldyBIb29rKCAnY29uZmlnJyApLFxuXHRcdFx0aW5pdEhvb2sgPSBuZXcgSG9va1F1ZXVlKCAnaW5pdCcgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2UoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHRpbml0aWFsaXNlUHJvcGVydGllcyggcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gbWFrZSB0aGlzIG9wdGlvbiBkbyB3aGF0IHdvdWxkIGJlIGV4cGVjdGVkIGlmIHNvbWVvbmVcblx0XHRcdC8vIGRpZCBpbmNsdWRlIGl0IG9uIGEgbmV3IFJhY3RpdmUoKSBvciBuZXcgQ29tcG9uZW50KCkgY2FsbC5cblx0XHRcdC8vIFNpbGx5IHRvIGRvIHNvIChwdXQgYSBob29rIG9uIHRoZSB2ZXJ5IG9wdGlvbnMgYmVpbmcgdXNlZCksXG5cdFx0XHQvLyBidXQgaGFuZGxlIGl0IGNvcnJlY3RseSwgY29uc2lzdGVudCB3aXRoIHRoZSBpbnRlbnQuXG5cdFx0XHRjb25zdHJ1Y3RIb29rLmZpcmUoIGNvbmZpZy5nZXRDb25zdHJ1Y3RUYXJnZXQoIHJhY3RpdmUsIG9wdGlvbnMgKSwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gaW5pdCBjb25maWcgZnJvbSBQYXJlbnQgYW5kIG9wdGlvbnNcblx0XHRcdGNvbmZpZy5pbml0KCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHRjb25maWdIb29rLmZpcmUoIHJhY3RpdmUgKTtcblx0XHRcdC8vIFRlYXJkb3duIGFueSBleGlzdGluZyBpbnN0YW5jZXMgKmJlZm9yZSogdHJ5aW5nIHRvIHNldCB1cCB0aGUgbmV3IG9uZSAtXG5cdFx0XHQvLyBhdm9pZHMgY2VydGFpbiB3ZWlyZCBidWdzXG5cdFx0XHRpZiAoIGVsID0gZ2V0RWxlbWVudCggcmFjdGl2ZS5lbCApICkge1xuXHRcdFx0XHRpZiAoICFyYWN0aXZlLmFwcGVuZCApIHtcblx0XHRcdFx0XHRpZiAoIGVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXy5zcGxpY2UoIDAsIGVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXy5sZW5ndGggKS5mb3JFYWNoKCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge31cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGluaXRIb29rLmJlZ2luKCByYWN0aXZlICk7XG5cdFx0XHQvLyBURU1QT1JBUlkuIFRoaXMgaXMgc28gd2UgY2FuIGltcGxlbWVudCBWaWV3bW9kZWwgZ3JhZHVhbGx5XG5cdFx0XHRyYWN0aXZlLnZpZXdtb2RlbCA9IG5ldyBWaWV3bW9kZWwoIHJhY3RpdmUgKTtcblx0XHRcdC8vIGhhY2t5IGNpcmN1bGFyIHByb2JsZW0gdW50aWwgd2UgZ2V0IHRoaXMgc29ydGVkIG91dFxuXHRcdFx0Ly8gaWYgdmlld21vZGVsIGltbWVkaWF0ZWx5IHByb2Nlc3NlcyBjb21wdXRlZCBwcm9wZXJ0aWVzLFxuXHRcdFx0Ly8gdGhleSBtYXkgY2FsbCByYWN0aXZlLmdldCwgd2hpY2ggY2FsbHMgcmFjdGl2ZS52aWV3bW9kZWwsXG5cdFx0XHQvLyB3aGljaCBoYXNuJ3QgYmVlbiBzZXQgdGlsbCBsaW5lIGFib3ZlIGZpbmlzaGVzLlxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuaW5pdCgpO1xuXHRcdFx0Ly8gUmVuZGVyIG91ciAqcm9vdCBmcmFnbWVudCpcblx0XHRcdGlmICggcmFjdGl2ZS50ZW1wbGF0ZSApIHtcblx0XHRcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiByYWN0aXZlLnRlbXBsYXRlLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IHJhY3RpdmVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aW5pdEhvb2suZW5kKCByYWN0aXZlICk7XG5cdFx0XHQvLyByZW5kZXIgYXV0b21hdGljYWxseSAoIGlmIGBlbGAgaXMgc3BlY2lmaWVkIClcblx0XHRcdGlmICggZWwgKSB7XG5cdFx0XHRcdHJhY3RpdmUucmVuZGVyKCBlbCwgcmFjdGl2ZS5hcHBlbmQgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG5cdFx0XHQvLyBleGlzdGVkXG5cdFx0XHRyYWN0aXZlLl9ndWlkID0gZ2V0TmV4dE51bWJlcigpO1xuXHRcdFx0Ly8gZXZlbnRzXG5cdFx0XHRyYWN0aXZlLl9zdWJzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuXHRcdFx0Ly8gbGlrZSBkeW5hbWljIGZ1bmN0aW9ucyBvciBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHJhY3RpdmUuX2NvbmZpZyA9IHt9O1xuXHRcdFx0Ly8gdHdvLXdheSBiaW5kaW5nc1xuXHRcdFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdC8vIGFuaW1hdGlvbnMgKHNvIHdlIGNhbiBzdG9wIGFueSBpbiBwcm9ncmVzcyBhdCB0ZWFyZG93bilcblx0XHRcdHJhY3RpdmUuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRcdC8vIG5vZGVzIHJlZ2lzdHJ5XG5cdFx0XHRyYWN0aXZlLm5vZGVzID0ge307XG5cdFx0XHQvLyBsaXZlIHF1ZXJpZXNcblx0XHRcdHJhY3RpdmUuX2xpdmVRdWVyaWVzID0gW107XG5cdFx0XHRyYWN0aXZlLl9saXZlQ29tcG9uZW50UXVlcmllcyA9IFtdO1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudFxuXHRcdFx0aWYgKCBvcHRpb25zLl9wYXJlbnQgJiYgb3B0aW9ucy5fY29tcG9uZW50ICkge1xuXHRcdFx0XHRyYWN0aXZlLl9wYXJlbnQgPSBvcHRpb25zLl9wYXJlbnQ7XG5cdFx0XHRcdHJhY3RpdmUuY29tcG9uZW50ID0gb3B0aW9ucy5fY29tcG9uZW50O1xuXHRcdFx0XHQvLyBBbmQgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9uIHRoZSBjb21wb25lbnRcblx0XHRcdFx0b3B0aW9ucy5fY29tcG9uZW50Lmluc3RhbmNlID0gcmFjdGl2ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjb25maWcsIGNyZWF0ZSwgRnJhZ21lbnQsIGdldEVsZW1lbnQsIGdldE5leHROdW1iZXIsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2tRdWV1ZSwgVmlld21vZGVsICk7XG5cblx0LyogZXh0ZW5kL3Vud3JhcEV4dGVuZGVkLmpzICovXG5cdHZhciB1bndyYXBFeHRlbmRlZCA9IGZ1bmN0aW9uKCB3cmFwLCBjb25maWcsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBSYWN0aXZlO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0UmFjdGl2ZSA9IGNpcmN1bGFyLlJhY3RpdmU7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gdW53cmFwRXh0ZW5kZWQoIENoaWxkICkge1xuXHRcdFx0aWYgKCAhKCBDaGlsZC5wcm90b3R5cGUgaW5zdGFuY2VvZiBSYWN0aXZlICkgKSB7XG5cdFx0XHRcdHJldHVybiBDaGlsZDtcblx0XHRcdH1cblx0XHRcdHZhciBvcHRpb25zID0ge307XG5cdFx0XHR3aGlsZSAoIENoaWxkICkge1xuXHRcdFx0XHRjb25maWcucmVnaXN0cmllcy5mb3JFYWNoKCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRhZGRSZWdpc3RyeSggci51c2VEZWZhdWx0cyA/IENoaWxkLnByb3RvdHlwZSA6IENoaWxkLCBvcHRpb25zLCByLm5hbWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRPYmplY3Qua2V5cyggQ2hpbGQucHJvdG90eXBlICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRpZiAoIGtleSA9PT0gJ2NvbXB1dGVkJyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gQ2hpbGQucHJvdG90eXBlWyBrZXkgXTtcblx0XHRcdFx0XHRpZiAoICEoIGtleSBpbiBvcHRpb25zICkgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlLl9tZXRob2QgPyB2YWx1ZS5fbWV0aG9kIDogdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIG9wdGlvbnNbIGtleSBdID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zWyBrZXkgXS5fbWV0aG9kICkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdCwgbmVlZHNTdXBlciA9IHZhbHVlLl9tZXRob2Q7XG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzU3VwZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuX21ldGhvZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHJld3JhcCBib3VuZCBkaXJlY3RseSB0byBwYXJlbnQgZm5cblx0XHRcdFx0XHRcdHJlc3VsdCA9IHdyYXAoIG9wdGlvbnNbIGtleSBdLl9tZXRob2QsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzU3VwZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5fbWV0aG9kID0gcmVzdWx0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSByZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggQ2hpbGQuX3BhcmVudCAhPT0gUmFjdGl2ZSApIHtcblx0XHRcdFx0XHRDaGlsZCA9IENoaWxkLl9wYXJlbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Q2hpbGQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGFkZFJlZ2lzdHJ5KCB0YXJnZXQsIG9wdGlvbnMsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcmVnaXN0cnksIGtleXMgPSBPYmplY3Qua2V5cyggdGFyZ2V0WyBuYW1lIF0gKTtcblx0XHRcdGlmICggIWtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEoIHJlZ2lzdHJ5ID0gb3B0aW9uc1sgbmFtZSBdICkgKSB7XG5cdFx0XHRcdHJlZ2lzdHJ5ID0gb3B0aW9uc1sgbmFtZSBdID0ge307XG5cdFx0XHR9XG5cdFx0XHRrZXlzLmZpbHRlciggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuICEoIGtleSBpbiByZWdpc3RyeSApO1xuXHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiByZWdpc3RyeVsga2V5IF0gPSB0YXJnZXRbIG5hbWUgXVsga2V5IF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggd3JhcE1ldGhvZCwgY29uZmlnLCBjaXJjdWxhciApO1xuXG5cdC8qIGV4dGVuZC9fZXh0ZW5kLmpzICovXG5cdHZhciBSYWN0aXZlX2V4dGVuZCA9IGZ1bmN0aW9uKCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgaW5pdGlhbGlzZSwgVmlld21vZGVsLCB1bndyYXAgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0dmFyIFBhcmVudCA9IHRoaXMsXG5cdFx0XHRcdENoaWxkLCBwcm90bywgc3RhdGljUHJvcGVydGllcztcblx0XHRcdC8vIGlmIHdlJ3JlIGV4dGVuZGluZyB3aXRoIGFub3RoZXIgUmFjdGl2ZSBpbnN0YW5jZSwgaW5oZXJpdCBpdHNcblx0XHRcdC8vIHByb3RvdHlwZSBtZXRob2RzIGFuZCBkZWZhdWx0IG9wdGlvbnMgYXMgd2VsbFxuXHRcdFx0b3B0aW9ucyA9IHVud3JhcCggb3B0aW9ucyApO1xuXHRcdFx0Ly8gY3JlYXRlIENoaWxkIGNvbnN0cnVjdG9yXG5cdFx0XHRDaGlsZCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHRpbml0aWFsaXNlKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvdG8gPSBjcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcblx0XHRcdHByb3RvLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG5cdFx0XHRzdGF0aWNQcm9wZXJ0aWVzID0ge1xuXHRcdFx0XHQvLyBlYWNoIGNvbXBvbmVudCBuZWVkcyBhIGd1aWQsIGZvciBtYW5hZ2luZyBDU1MgZXRjXG5cdFx0XHRcdF9ndWlkOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGdldEd1aWQoKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcblx0XHRcdFx0ZGVmYXVsdHM6IHtcblx0XHRcdFx0XHR2YWx1ZTogcHJvdG9cblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gZXh0ZW5kYWJsZVxuXHRcdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogZXh0ZW5kLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBQYXJlbnQgLSBmb3IgSUU4LCBjYW4ndCB1c2UgT2JqZWN0LmdldFByb3RvdHlwZU9mXG5cdFx0XHRcdF9wYXJlbnQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogUGFyZW50XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBDaGlsZCwgc3RhdGljUHJvcGVydGllcyApO1xuXHRcdFx0Ly8gZXh0ZW5kIGNvbmZpZ3VyYXRpb25cblx0XHRcdGNvbmZpZy5leHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHRcdFZpZXdtb2RlbC5leHRlbmQoIFBhcmVudCwgcHJvdG8gKTtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdH07XG5cdH0oIGNyZWF0ZSwgZGVmaW5lUHJvcGVydGllcywgZ2V0R3VpZCwgY29uZmlnLCBSYWN0aXZlX2luaXRpYWxpc2UsIFZpZXdtb2RlbCwgdW53cmFwRXh0ZW5kZWQgKTtcblxuXHQvKiBSYWN0aXZlLmpzICovXG5cdHZhciBSYWN0aXZlID0gZnVuY3Rpb24oIGRlZmF1bHRzLCBlYXNpbmcsIGludGVycG9sYXRvcnMsIHN2ZywgbWFnaWMsIGRlZmluZVByb3BlcnRpZXMsIHByb3RvLCBQcm9taXNlLCBleHRlbmRPYmosIGV4dGVuZCwgcGFyc2UsIGluaXRpYWxpc2UsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmUsIHByb3BlcnRpZXM7XG5cdFx0Ly8gTWFpbiBSYWN0aXZlIHJlcXVpcmVkIG9iamVjdFxuXHRcdFJhY3RpdmUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdGluaXRpYWxpc2UoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdC8vIFJhY3RpdmUgcHJvcGVydGllc1xuXHRcdHByb3BlcnRpZXMgPSB7XG5cdFx0XHQvLyBzdGF0aWMgbWV0aG9kczpcblx0XHRcdGV4dGVuZDoge1xuXHRcdFx0XHR2YWx1ZTogZXh0ZW5kXG5cdFx0XHR9LFxuXHRcdFx0cGFyc2U6IHtcblx0XHRcdFx0dmFsdWU6IHBhcnNlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gTmFtZXNwYWNlZCBjb25zdHJ1Y3RvcnNcblx0XHRcdFByb21pc2U6IHtcblx0XHRcdFx0dmFsdWU6IFByb21pc2Vcblx0XHRcdH0sXG5cdFx0XHQvLyBzdXBwb3J0XG5cdFx0XHRzdmc6IHtcblx0XHRcdFx0dmFsdWU6IHN2Z1xuXHRcdFx0fSxcblx0XHRcdG1hZ2ljOiB7XG5cdFx0XHRcdHZhbHVlOiBtYWdpY1xuXHRcdFx0fSxcblx0XHRcdC8vIHZlcnNpb25cblx0XHRcdFZFUlNJT046IHtcblx0XHRcdFx0dmFsdWU6ICcwLjYuMSdcblx0XHRcdH0sXG5cdFx0XHQvLyBQbHVnaW5zXG5cdFx0XHRhZGFwdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0Y29tcG9uZW50czoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0ZGVjb3JhdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0ZWFzaW5nOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogZWFzaW5nXG5cdFx0XHR9LFxuXHRcdFx0ZXZlbnRzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHRpbnRlcnBvbGF0b3JzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogaW50ZXJwb2xhdG9yc1xuXHRcdFx0fSxcblx0XHRcdHBhcnRpYWxzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHR0cmFuc2l0aW9uczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvLyBSYWN0aXZlIHByb3BlcnRpZXNcblx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBSYWN0aXZlLCBwcm9wZXJ0aWVzICk7XG5cdFx0UmFjdGl2ZS5wcm90b3R5cGUgPSBleHRlbmRPYmooIHByb3RvLCBkZWZhdWx0cyApO1xuXHRcdFJhY3RpdmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZTtcblx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcblx0XHRSYWN0aXZlLmRlZmF1bHRzID0gUmFjdGl2ZS5wcm90b3R5cGU7XG5cdFx0Ly8gQ2VydGFpbiBtb2R1bGVzIGhhdmUgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLiBJZiB3ZSB3ZXJlIGJ1bmRsaW5nIGFcblx0XHQvLyBtb2R1bGUgbG9hZGVyLCBlLmcuIGFsbW9uZC5qcywgdGhpcyB3b3VsZG4ndCBiZSBhIHByb2JsZW0sIGJ1dCB3ZSdyZVxuXHRcdC8vIG5vdCAtIHdlJ3JlIHVzaW5nIGFtZGNsZWFuIGFzIHBhcnQgb2YgdGhlIGJ1aWxkIHByb2Nlc3MuIEJlY2F1c2Ugb2Zcblx0XHQvLyB0aGlzLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgYWxsIG1vZHVsZXMgaGF2ZSBsb2FkZWQgYmVmb3JlIHRob3NlXG5cdFx0Ly8gY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGNhbiBiZSByZXF1aXJlZC5cblx0XHRjaXJjdWxhci5SYWN0aXZlID0gUmFjdGl2ZTtcblx0XHR3aGlsZSAoIGNpcmN1bGFyLmxlbmd0aCApIHtcblx0XHRcdGNpcmN1bGFyLnBvcCgpKCk7XG5cdFx0fVxuXHRcdC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG5cdFx0Ly8gb2xkZXIgYnJvd3NlcnMsIHRoZXNlIGFyZSBtYWRlIGF2YWlsYWJsZSB2aWEgYSBzaGltIC0gaGVyZSwgd2UgZG8gYSBxdWlja1xuXHRcdC8vIHByZS1mbGlnaHQgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgZWl0aGVyIGEpIHdlJ3JlIG5vdCBpbiBhIHNoaXQgYnJvd3Nlcixcblx0XHQvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG5cdFx0dmFyIEZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblx0XHRpZiAoIHR5cGVvZiBEYXRlLm5vdyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIE9iamVjdC5rZXlzICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5tYXAgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmlsdGVyICE9PSBGVU5DVElPTiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IEZVTkNUSU9OICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBSYWN0aXZlLmpzIGluIGFuIG9sZGVyIGJyb3dzZXIuIFlvdVxcJ2xsIG5lZWQgdG8gdXNlIG9uZSBvZiB0aGUgXFwnbGVnYWN5IGJ1aWxkc1xcJyBpbiBvcmRlciB0byBjb250aW51ZSAtIHNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9sZWdhY3ktYnVpbGRzIGZvciBtb3JlIGluZm9ybWF0aW9uLicgKTtcblx0XHR9XG5cdFx0cmV0dXJuIFJhY3RpdmU7XG5cdH0oIG9wdGlvbnMsIGVhc2luZywgaW50ZXJwb2xhdG9ycywgc3ZnLCBtYWdpYywgZGVmaW5lUHJvcGVydGllcywgcHJvdG90eXBlLCBQcm9taXNlLCBleHRlbmQsIFJhY3RpdmVfZXh0ZW5kLCBwYXJzZSwgUmFjdGl2ZV9pbml0aWFsaXNlLCBjaXJjdWxhciApO1xuXG5cblx0Ly8gZXhwb3J0IGFzIENvbW1vbiBKUyBtb2R1bGUuLi5cblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gUmFjdGl2ZTtcblx0fVxuXG5cdC8vIC4uLiBvciBhcyBBTUQgbW9kdWxlXG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFJhY3RpdmU7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gLi4uIG9yIGFzIGJyb3dzZXIgZ2xvYmFsXG5cdGdsb2JhbC5SYWN0aXZlID0gUmFjdGl2ZTtcblxuXHRSYWN0aXZlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcblx0XHRnbG9iYWwuUmFjdGl2ZSA9IG5vQ29uZmxpY3Q7XG5cdFx0cmV0dXJuIFJhY3RpdmU7XG5cdH07XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyApICk7XG4iXX0=
